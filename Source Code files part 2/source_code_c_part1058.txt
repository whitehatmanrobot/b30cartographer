AN         Relocated;          //  TRUE if relocated sectors


#if !defined ( _AUTOCHECK_ )

    if(_FatSa->QueryVolumeFlags() & (FAT_BPB_RESERVED_DIRTY | FAT_BPB_RESERVED_TEST_SURFACE)) {
    //
    //  The volume dirty bit is set??? Need to CHKDSK first.
    //
        _Message->Set( MSG_CONV_DISK_IS_DIRTY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_DRIVE_IS_DIRTY;
        return FALSE;
    }

#endif // !_AUTOCHECK_

    //
    //  Identify all the "holes" that we need i.e. all those spots
    //  that are used by NTFS structures that need to be at a fixed
    //  location.
    //
    //
    if ( !QueryNeededHoles( &HoleStack ) ) {
        return FALSE;
    }

    SectorsTotal = _FatSa->QueryVirtualSectors();
    SectorsFree  = _FatSa->QueryFreeSectors();
    // Census =  ( SectorsFree > ( SectorsTotal / 2 ) ) ? NULL : &CensusReport;
    Census       = &CensusReport;
    Relocated    = FALSE;

    //
    //  Create the holes and obtain the census if necessary
    //
    _Message->Set( MSG_CONV_CHECKING_SPACE );
    _Message->Display();

    if ( !_FatSa->QueryCensusAndRelocate( Census, &HoleStack, &Relocated )) {

        _Message->Set( MSG_CONV_NO_DISK_SPACE, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_INSUFFICIENT_FREE_SPACE;
        return FALSE;
    }

#if defined ( _AUTOCONV_ )

    //
    //  If relocated sectors, then we will be overwritting data that might
    //  be needed by the system. In order to avoid this, we reboot so that
    //  the system will read its stuff from the new locations.
    //
    if ( Relocated ) {

        _Drive->FlushCache();

        _Message->Set( MSG_CONV_REBOOT_AFTER_RELOCATION );
        _Message->Display();

        IFS_SYSTEM::Reboot();
        //
        //  If we reach this point, the reboot failed and we should not
        //  continue the conversion.
        //
        _Message->Set( MSG_CONV_CANNOT_RELOCATE, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }


#endif

    //
    //  Determine the number of sectors needed for the conversion
    //
    if ( Census ) {

        //
        //  Estimate the number of sectors needed based on the
        //  volume census.
        //
        QuerySectorsNeededForConversion( Census, &SectorsNeeded );

    } else {

        //
        //  We'll say that we need half of the disk
        //
        SectorsNeeded = SectorsTotal / 2;
    }

    //
    // Take into account that the convert zone file is actually a free
    // space for NTFS to use to put system files
    //
    SectorsFree += (_CvtZoneSize * _FatSa->QuerySectorsPerCluster());

    KbytesTotal = SectorsTotal * _Drive->QuerySectorSize() / 1024;
    KbytesFree = SectorsFree * _Drive->QuerySectorSize() / 1024;
    KbytesNeeded = SectorsNeeded * _Drive->QuerySectorSize() / 1024;

    _Message->Set( MSG_CONV_KBYTES_TOTAL );
    _Message->Display( "%8d", KbytesTotal.GetLowPart() );
    _Message->Set( MSG_CONV_KBYTES_FREE );
    _Message->Display( "%8d", KbytesFree.GetLowPart() );
    _Message->Set( MSG_CONV_KBYTES_NEEDED );
    _Message->Display( "%8d", KbytesNeeded.GetLowPart() );


    if ( SectorsFree < SectorsNeeded ) {
        //
        //  Not enough disk space for conversion
        //
        _Message->Set( MSG_CONV_NO_DISK_SPACE, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_INSUFFICIENT_FREE_SPACE;
        return FALSE;
    }


    //
    //  The disk has enough disk space.
    //
    return TRUE;
}



BOOLEAN
FAT_NTFS::ConvertRoot (
    IN PFATDIR  Directory
    )

/*++

Routine Description:

    Converts the FAT root directory and recursively all its
    subdirectories.

    This is basically the same as the ConvertDirectory method, the
    differences being:

    1.- The index for the root has already been created by
        NTFS_SA::CreateElementaryStructures()

    2.- No FRS is created

    3.- ConvertRoot does some extra checkings for
        EA file (which is at the root level only).


Arguments:

    Directory   -   Supplies root directory.

Return Value:

    BOOLEAN -   TRUE if root directory successfully converted
                FALSE otherwise

--*/

{
    NTFS_FILE_RECORD_SEGMENT    FrsOfRootIndex;             //  FRS of NTFS root index
    NTFS_INDEX_TREE             RootIndex;                  //  Root index
    BOOLEAN                     Converted;


    DebugPtrAssert( Directory );

    _Level = 0;

    //
    //  Obtain the NTFS root index
    //
    if ( !FrsOfRootIndex.Initialize( ROOT_FILE_NAME_INDEX_NUMBER, &_Mft )  ||
         !FrsOfRootIndex.Read()                                            ||
         !RootIndex.Initialize( _Drive,
                                _ClusterFactor,
                                &_VolumeBitmap,
                                FrsOfRootIndex.GetUpcaseTable(),
                                FrsOfRootIndex.QueryMaximumAttributeRecordSize()/2,
                                &FrsOfRootIndex,
                                &_RootIndexName )
       ) {

        _Message->Set( MSG_CONV_CANNOT_MAKE_INDEX, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  Convert the directory
    //
    if ( Converted = ConvertDir( Directory, &RootIndex, &FrsOfRootIndex )) {
        //
        //  Save the index
        //
        if ( !RootIndex.Save( &FrsOfRootIndex ) ||
             !FrsOfRootIndex.Flush( &_VolumeBitmap ) ) {

            _Message->Set( MSG_CONV_CANNOT_WRITE, ERROR_MESSAGE );
            _Message->Display();
            _Status = CONVERT_STATUS_ERROR;
            Converted = FALSE;
        }
    }

    return Converted;
}



BOOLEAN
FAT_NTFS::ConvertDirectory (
    IN      PFATDIR                     Directory,
    IN      PFAT_DIRENT                 DirEntry,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   FrsDir
    )

/*++

Routine Description:

    Converts a FAT directory and recursively all its subdirectories

Arguments:

    Directory   -   Supplies directory to convert
    DirEntry    -   Supplies the directory entry of the directory
    FrsDir      -   Supplies pointer to FRS of directory

Return Value:

    BOOLEAN -   TRUE if directory successfully converted
                FALSE otherwise

--*/

{

    NTFS_INDEX_TREE             Index;                      //  NTFS index
    BOOLEAN                     Converted;                  //  FALSE if error
    ULONG                       DirSize;                    //  Dir size
    ULONG                       SectorsPerFatCluster;       //  Sectors per cluster
    ULONG                       Cluster;                    //  Dir cluster number
    PFAT                        Fat;                        //  Pointer to FAT
    LCN                         Lcn;                        //  LCN


    DebugPtrAssert( Directory );
    DebugPtrAssert( DirEntry );
    DebugPtrAssert( FrsDir );


    //
    //  Create an index for this directory:
    //
    if ( !Index.Initialize( $FILE_NAME,
                            _Drive,
                            _ClusterFactor,
                            &_VolumeBitmap,
                            FrsDir->GetUpcaseTable(),
                            COLLATION_FILE_NAME,
                            SMALL_INDEX_BUFFER_SIZE,
                            FrsDir->QueryMaximumAttributeRecordSize() /2,
                            &_RootIndexName
                          )
       ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    _Level++;

    //
    //  Convert the directory.
    //
    if ( Converted = ConvertDir( Directory, &Index, FrsDir ) ) {

        //
        //  If the directory has extended attributes, convert them.
        //
        //  Then save the index.
        //
        if ( Converted = (BOOLEAN)( !DirEntry->QueryEaHandle() ||
                                    ConvertExtendedAttributes( DirEntry, FrsDir ) ) ) {


            //
            //  Mark the sectors used by this directory in the reserved
            //  bitmap.
            //
            DirSize                 = DirEntry->QueryFileSize();
            SectorsPerFatCluster    = _FatSa->QuerySectorsPerCluster();
            Cluster                 = DirEntry->QueryStartingCluster();
            Fat                     = _FatSa->GetFat();

            while ( TRUE ) {

                Lcn = FatClusterToLcn( Cluster )/_ClusterFactor;

                _ReservedBitmap.SetAllocated( Lcn, _ClusterRatio );

                if ( Fat->IsEndOfChain( Cluster )) {
                    break;
                }

                Cluster = Fat->QueryEntry( Cluster );
            }


            //
            //  Save the index for this directory
            //
            if ( !( Converted = (Index.Save( FrsDir ) ) ) ) {
                _Message->Set( MSG_CONV_CANNOT_WRITE, ERROR_MESSAGE );
                _Message->Display();
                _Status = CONVERT_STATUS_ERROR;
            }
        }
    }

    _Level--;

    return Converted;
}



BOOLEAN
FAT_NTFS::ConvertDir (
    IN      PFATDIR                     Directory,
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   FrsDir
    )

/*++

Routine Description:

    Converts a FAT directory and recursively all its subdirectories

Arguments:


Return Value:

    BOOLEAN -   TRUE if directory successfully converted
                FALSE otherwise

--*/

{

    FAT_DIRENT                  Entry;              //  Directory entry
    HMEM                        HMem;               //  Memory
    DSTRING                     DirName;            //  This dir's name
    DSTRING                     LongName;           //  the associated long name
    BOOLEAN                     UseLongName;        //  make one name attrib
    STANDARD_INFORMATION        StandardInformation;//  Std. Info
    ULONG                       EntryNumber;        //  Entry number counter
    BOOLEAN                     Converted;          //  FALSE if error
    NTFS_FILE_RECORD_SEGMENT    Frs;                //  FRS of each entry
    VCN                         FileNumber;         //  File Number of child.
    USHORT                      FrsFlags;
    PVOID                       DirEntry;
    FILEDIR                     SubDir;
    BOOLEAN                     HasLongName;
    UCHAR                       FatType;
    CANNED_SECURITY_TYPE        Sd;

#if defined(CONVERT_PERF_COUNTERS)
    PERF_DATA   pdata;
#endif

    Converted = TRUE;
    EntryNumber = 0;

    if (_FatSa->GetFileDir())
        FatType = FAT_TYPE_FAT32;
    else
        FatType = FAT_TYPE_EAS_OKAY;

    DebugPtrAssert( Directory );
    DebugPtrAssert( Index );
    DebugPtrAssert( FrsDir );


    //
    //  Traverse the directory, converting all its entries.
    //
    while ( Converted ) {

        //
        //  Get next directory entry
        //
        if ( !(DirEntry = Directory->GetDirEntry( EntryNumber ))) {
            break;
        }
        if ( !Entry.Initialize( DirEntry, FatType))
        {
            _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            _Message->Display();
            _Status = CONVERT_STATUS_ERROR;
            Converted = FALSE;
            DebugAssert(FALSE);
            break;
        }

        //
        //  If end of directory, get out
        //
        if ( Entry.IsEndOfDirectory() ) {
            break;
        }

        //
        //  Ignore the deleted, the "parent" and the "self" entries, the
        //  volume label and the EA file.
        //
        if (( Entry.IsErased()        ||
              Entry.IsDot()           ||
              Entry.IsDotDot()        ||
              Entry.IsVolumeLabel()   ||
              Entry.IsLongEntry()     ||
              (_CvtZoneFileFirstCluster != 0 &&
               Entry.QueryStartingCluster() == _CvtZoneFileFirstCluster) ||
              (_EAFileFirstCluster != 0 &&
               Entry.QueryStartingCluster() == _EAFileFirstCluster) ) ) {

              EntryNumber++;
              continue;
        }

        //  Fill in the standard information for this file or
        //  directory.  Note that NTFS stores Universal Time,
        //  whereas FAT stores Local Time, so the time has to
        //  be converted.
        //

        LARGE_INTEGER FatTime, NtfsTime;

        Entry.QueryLastWriteTime( &FatTime );
        RtlLocalTimeToSystemTime( &FatTime, &NtfsTime );

        StandardInformation.LastModificationTime = NtfsTime;
        StandardInformation.LastChangeTime = NtfsTime;

        if (Entry.IsValidCreationTime()) {

            Entry.QueryCreationTime( &FatTime );
            RtlLocalTimeToSystemTime( &FatTime, &NtfsTime );
            StandardInformation.CreationTime = NtfsTime;
        } else {

            StandardInformation.CreationTime = StandardInformation.LastChangeTime;
        }

        if (Entry.IsValidLastAccessTime()) {

            Entry.QueryLastAccessTime( &FatTime );
            RtlLocalTimeToSystemTime( &FatTime, &NtfsTime );
            StandardInformation.LastAccessTime = NtfsTime;
        } else {

            StandardInformation.LastAccessTime = StandardInformation.LastChangeTime;
        }

        StandardInformation.FileAttributes = Entry.QueryAttributeByte();


        //
        //  Get the WSTR name of the entry and fill in the FILE_NAME
        //  structure for the file name attribute.  If this entry
        //  does not have an associated Long File Name, then its
        //  name is both a valid DOS and NTFS name; if there is an
        //  associated Long File Name, then the name is the DOS name
        //  and the long name is the NTFS name.
        //
        //  If the long name is identical to the short name, ignore
        //  the long name.
        //
        Entry.QueryName( &DirName );

        if( !Directory->QueryLongName( EntryNumber, &LongName ) ) {

            DebugPrintTrace(( "CUFAT: QueryLongName failed.\n" ));
            _Status = CONVERT_STATUS_ERROR;
            Converted = FALSE;
            break;
        }

        HasLongName = (LongName.QueryChCount() != 0);

        //
        // If the long name is only a casewise permutation of the
        // short name, use the long name as the single ntfs name
        // attribute.
        //

        UseLongName = (HasLongName &&
                   0 == NtfsUpcaseCompare( DirName.GetWSTR(),
                                           DirName.QueryChCount(),
                                           LongName.GetWSTR(),
                                           LongName.QueryChCount(),
                                           FrsDir->GetUpcaseTable(),
                                           FALSE ));


        _FileNameBuffer->ParentDirectory = FrsDir->QuerySegmentReference();
        _FileNameBuffer->FileNameLength  = (unsigned char)DirName.QueryChCount();
        if (UseLongName) {

            _FileNameBuffer->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

            if ( !LongName.QueryWSTR( 0, TO_END, NtfsFileNameGetName(_FileNameBuffer), NAMEBUFFERSIZE ) ) {
                _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                _Message->Display();
                _Status = CONVERT_STATUS_ERROR;
                Converted = FALSE;
                DebugAssert(FALSE);
                break;
            }

        } else {

            _FileNameBuffer->Flags = HasLongName ?
                                     FILE_NAME_DOS :
                                     FILE_NAME_NTFS | FILE_NAME_DOS;

            if ( !DirName.QueryWSTR( 0, TO_END, NtfsFileNameGetName(_FileNameBuffer), NAMEBUFFERSIZE ) ) {
                _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                _Message->Display();
                _Status = CONVERT_STATUS_ERROR;
                Converted = FALSE;
                DebugAssert(FALSE);
                break;
            }
        }

        //  Allocate and create the FRS for this file or directory,
        //  add its file name, and add an appropriate entry to the
        //  index.
        //
        FrsFlags = (Entry.IsDirectory()) ? (USHORT)FILE_FILE_NAME_INDEX_PRESENT : (USHORT)0;

        if (_Flags & CONVERT_NOSECURITY_FLAG) {
            Sd = Entry.IsDirectory() ? EditWorldCannedDirSd : EditWorldCannedFileSd;
        } else {
            Sd = Entry.IsDirectory() ? NoAclCannedSd : NoAclCannedFileSd;
        }

        if ( !_Mft.AllocateFileRecordSegment( &FileNumber, FALSE )  ||
             !Frs.Initialize( FileNumber, &_Mft )          ||
             !Frs.Create( &StandardInformation, FrsFlags ) ||
             !Frs.AddFileNameAttribute( _FileNameBuffer )  ||
             !Frs.AddSecurityDescriptor( Sd, &_VolumeBitmap )  ||
             !Index->InsertEntry( NtfsFileNameGetLength( _FileNameBuffer ),
                                  _FileNameBuffer,
                                  Frs.QuerySegmentReference() ) ) {

            DebugPrint( "Can't create FRS in ConvertDirectory.\n" );
            Converted = FALSE;
            break;
        }

        //  If the file has separate long name, add that entry to the FRS
        //  and the index.
        //
        if( HasLongName && !UseLongName ) {


            _FileNameBuffer->ParentDirectory = FrsDir->QuerySegmentReference();
            _FileNameBuffer->FileNameLength  = (unsigned char)LongName.QueryChCount();
            _FileNameBuffer->Flags = FILE_NAME_NTFS;

            if ( !LongName.QueryWSTR( 0, TO_END, NtfsFileNameGetName(_FileNameBuffer), NAMEBUFFERSIZE ) ) {
                 _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                 _Message->Display();
                 _Status = CONVERT_STATUS_ERROR;
                 Converted = FALSE;
                 DebugAssert(FALSE);
                 break;
            }

            if ( !Frs.AddFileNameAttribute( _FileNameBuffer )   ||
                 !Index->InsertEntry( NtfsFileNameGetLength( _FileNameBuffer ),
                                      _FileNameBuffer,
                                      Frs.QuerySegmentReference() ) ) {

                DebugPrint( "Can't create FRS in ConvertDirectory.\n" );
                Converted = FALSE;
                break;
            }
        }

        if ( _Flags & CONVERT_VERBOSE_FLAG ) {
            STATIC CHAR NameDisplayBuffer[128];
            ULONG NameStart = _Level * 4;
            PWSTRING Name;

            Name = (HasLongName ? &LongName : &DirName);

            memset(NameDisplayBuffer, ' ', NameStart);
            Name->QuerySTR( 0, TO_END, NameDisplayBuffer + NameStart,
                128 - Name->QueryByteCount() );
            NameDisplayBuffer[NameStart + Name->QueryByteCount()] = 0;
            _Message->Set( MSG_ONE_STRING );
            _Message->Display( "%s", NameDisplayBuffer );
        }

        //
        //  Determine if the entry is a directory or a file, and proccess it
        //  accordingly.
        //
        if ( Entry.IsDirectory() ) {

            //
            //  Directory
            //
            //
            //  Convert the directory (and all its subdirectories)
            //


            if ( !HMem.Initialize()     ||
                 !SubDir.Initialize( &HMem,
                                     _Drive,
                                     _FatSa,
                                     _FatSa->GetFat(),
                                     Entry.QueryStartingCluster() ) ) {

                _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
                _Message->Display();
                _Status = CONVERT_STATUS_ERROR;
                DebugAssert(FALSE);
                return FALSE;
            }

            if ( !SubDir.Read() ) {
                _Message->Set( MSG_CONV_CANNOT_READ, ERROR_MESSAGE );
                _Message->Display( );
                _Status = CONVERT_STATUS_ERROR;
                return FALSE;
            }

#if defined(CONVERT_PERF_COUNTERS)
            pdata.first_call = TRUE;
            CheckTime(_Message, _Drive, &pdata, "ConvertDirectory");
            _Message->Set(MSG_CHK_NTFS_MESSAGE);
            _Message->Display("%s%W", "VVVV Dir: ", &DirName);
#endif
            if ( !ConvertDirectory( &SubDir, &Entry, &Frs ) ||
                 !Frs.Flush( &_VolumeBitmap, Index ) ) {

                _Message->Set( MSG_CONV_CANNOT_CONVERT_DIRECTORY );
                _Message->Display( "%W", &DirName );
                Converted = FALSE;
                break;
            }
#if defined(CONVERT_PERF_COUNTERS)
            CheckTime(_Message, _Drive, &pdata, "ConvertDirectory Done");
#endif

        } else {

            //
            //  File
            //
            DebugAssert( !Entry.IsVolumeLabel() );
            DebugAssert( !Entry.IsLongEntry() );
            DebugAssert( !_EAFileFirstCluster ||
                       (Entry.QueryStartingCluster() != _EAFileFirstCluster) );

            //
            //  Convert the file.
            //
            if ( !ConvertFile( &Entry, &Frs ) ||
                 !Frs.Flush( &_VolumeBitmap, Index ) ) {

                Converted = FALSE;
                break;
            }
        }

        EntryNumber++;
    }


    return Converted;
}




BOOLEAN
FAT_NTFS::ConvertExtendedAttributes (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs
    )

/*++

Routine Description:

    Converts the extended attributes of a FAT directory entry.

Arguments:

    Dirent  -   Supplies the directory entry
    Frs     -   Supplies the file's FRS

Return Value:

    BOOLEAN -   TRUE if extended attributes converted
                FALSE otherwise

--*/

{
    USHORT  EaHandle;

    DebugPtrAssert( Dirent );
    DebugPtrAssert( Frs );

    EaHandle = Dirent->QueryEaHandle();

    //
    //  If this entry has extended attributes, convert them
    //
    if ( EaHandle ) {

        //
        //  Make sure that there is an EA file
        //
        if ( _EAFileFirstCluster == 0 ) {

            _Message->Set( MSG_CONV_NO_EA_FILE, ERROR_MESSAGE );
            _Message->Display( );
            _Status = CONVERT_STATUS_ERROR;

            return FALSE;
        }

        //
        //  Convert the attributes
        //
        return ConvertExtendedAttributes( Frs,
                                          EaHandle );


    }

    return TRUE;
}




BOOLEAN
FAT_NTFS::ConvertExtendedAttributes (
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN      USHORT                      EaHandle
    )

/*++

Routine Description:

    Converts the extended attributes of a FAT directory entry.

Arguments:

    Frs         -   Supplies the file's FRS
    Eahandle    -   Supplies the EA handle

Return Value:

    BOOLEAN -   TRUE if extended attributes converted
                FALSE otherwise

--*/

{
    EA_INFORMATION  EaInformation;
    NTFS_ATTRIBUTE  EaInformationAttribute;
    NTFS_ATTRIBUTE  EaDataAttribute;

    EA_SET      EaSet;      //  Extended attribute set
    HMEM        Mem;        //  Memory
    ULONG       Index;      //  EA Index
    PEA         Ea;         //  Pointer to EA
    ULONG       Cluster;    //  EA set cluster number
    PBYTE       UnpackedEaList;
    ULONG       PackedEaLength, UnpackedEaLength, PackedListLength,
                UnpackedListLength, NeedEaCount, TargetOffset;


    //
    //  Read in the EA set
    //
    Cluster = (_FatSa->GetFat())->QueryNthCluster( _EAFileFirstCluster,
                                                   _EAHeader.QueryEaSetClusterNumber( EaHandle ));

    if ( !Mem.Initialize()                          ||
         !EaSet.Initialize( &Mem,
                            _Drive,
                            _FatSa,
                            _FatSa->GetFat(),
                            Cluster )
       ) {
        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    if ( !EaSet.Read() ) {
        _Message->Set( MSG_CONV_CANNOT_READ, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    // Walk the list to determine the packed and unpacked length.  The
    // packed list is simply all the EA's concatenated together, so its
    // length is the sum of the individual lengths.  The unpacked list
    // consists of a set of entries which in turn consist of a ULONG
    // and a DWORD-aligned EA, so it length is a bit more complex to
    // compute.
    //
    Index = 0;
    PackedListLength = 0;
    UnpackedListLength = 0;
    NeedEaCount = 0;

    while( (Ea = EaSet.GetEa( Index++ )) != NULL ) {

        PackedEaLength = sizeof( EA ) + Ea->NameSize +
                            *(USHORT UNALIGNED *)Ea->ValueSize;

        UnpackedEaLength = sizeof(ULONG) + DwordAlign( PackedEaLength );

        PackedListLength += PackedEaLength;
        UnpackedListLength += UnpackedEaLength;

        if( Ea->Flag & NeedFlag ) {

            NeedEaCount += 1;
        }
    }

    //
    // Allocate a buffer to hold the unpacked list.
    //
    if( (UnpackedEaList = (PBYTE)MALLOC( (unsigned int)UnpackedListLength )) == NULL ) {

        return FALSE;
    }

    memset( UnpackedEaList, 0, (unsigned int)UnpackedListLength );

    //
    // Walk the list again, copying EA's into the packed list buffer.
    //
    Index = 0;
    TargetOffset = 0;

    while( (Ea = EaSet.GetEa( Index++ )) != NULL ) {

        PackedEaLength = sizeof( EA ) + Ea->NameSize +
                            *(USHORT UNALIGNED *)Ea->ValueSize;

        UnpackedEaLength = sizeof(ULONG) + DwordAlign( PackedEaLength );

        memcpy( UnpackedEaList + TargetOffset,
                &UnpackedEaLength,
                sizeof( ULONG ) );

        memcpy( UnpackedEaList + TargetOffset + sizeof( ULONG ),
                Ea,
                (unsigned int)PackedEaLength );

        TargetOffset += UnpackedEaLength;
    }

    // Create the EA Information Attribute--fill in the fields of
    // the EA information structure, put it into a resident attribute
    // of type $EA_INFORMATION, and insert the attribute into the file.
    //
    EaInformation.PackedEaSize      = (unsigned short)PackedListLength;
    EaInformation.NeedEaCount       = (unsigned short)NeedEaCount;
    EaInformation.UnpackedEaSize    = UnpackedListLength;

    if( !EaInformationAttribute.Initialize( _Drive,
                                            _Mft.QueryClusterFactor(),
                                            &EaInformation,
                                            sizeof( EA_INFORMATION ),
                                            $EA_INFORMATION,
                                            NULL,
                                            0 ) ||
        !EaInformationAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

        FREE( UnpackedEaList );
        return FALSE;
    }

    //
    // Set up the Ea Data attribute.  Start out with it resident; if
    // it doesn't fit into the FRS, make it nonresident.
    //
    if( !EaDataAttribute.Initialize( _Drive,
                                     _Mft.QueryClusterFactor(),
                                     UnpackedEaList,
                                     UnpackedListLength,
                                     $EA_DATA,
                                     NULL,
                                     0 ) ) {

        DebugPrint( "Cannot initialize resident attribute for EA List.\n" );
        FREE( UnpackedEaList );
        return FALSE;
    }

    if( !EaDataAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

        // Couldn't insert it in resident form; make it nonresident.

        if( !EaDataAttribute.MakeNonresident( &_VolumeBitmap ) ||
            !EaDataAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

            // Can't insert it.

            FREE( UnpackedEaList );
            return FALSE;
        }
    }


    //
    //  All the EAs have been converted
    //
    FREE( UnpackedEaList );
    return TRUE;
}



BOOLEAN
FAT_NTFS::ConvertFile (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   File
    )

/*++

Routine Description:

    Converts a file from FAT to NTFS

Arguments:

    Dirent      -   Supplies the directory entry of the file to convert
    ParentFrs   -   Supplies the FRS of the directory which contains this file
    File        -   Supplies pointer to FRS of file

Return Value:

    BOOLEAN -   TRUE if file successfully converted
                FALSE otherwise

--*/

{
    DSTRING                     FileName;               //  File name

    DebugPtrAssert( Dirent );
    DebugPtrAssert( File );

    Dirent->QueryName( &FileName );

    //
    //  Convert the file data and extended attributes.
    //
    if ( !ConvertFileData( Dirent, File )                ||
         !( !Dirent->QueryEaHandle()                     ||
            ConvertExtendedAttributes( Dirent, File ))
       ) {


        _Message->Set( MSG_CONV_CANNOT_CONVERT_FILE, ERROR_MESSAGE );
        _Message->Display( "%W", &FileName );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;

    }

    //
    //  File converted
    //
    return TRUE;
}




BOOLEAN
FAT_NTFS::ConvertFileData (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs
    )

/*++

Routine Description:

    Converts the file data from FAT to NTFS

Arguments:

    Dirent  -   Supplies the directory entry of the file to convert
    Frs     -   Supplies the FRS for the file

Return Value:

    BOOLEAN -   TRUE if file data successfully converted
                FALSE otherwise

--*/

{

    ULONG               FileSize;               //  File size
    ULONG               SectorsPerFatCluster;   //  Sectors per cluster

    DebugPtrAssert( Dirent );
    DebugPtrAssert( Frs );

    //
    //  Get the file size
    //
    FileSize                = Dirent->QueryFileSize();
    SectorsPerFatCluster    = _FatSa->QuerySectorsPerCluster();

    //
    //  If the data is small enough to fit in the FRS, we make it resident and free
    //  the cluster it occupies, otherwise we reuse its allocation and make it
    //  non-resident.
    //
    //  Note that we only make the data resident if it is less than one FAT cluster
    //  long.
    //
    if ( ( Frs->QueryFreeSpace() > (FileSize + SIZE_OF_RESIDENT_HEADER ) )  &&
         ( FileSize <= (SectorsPerFatCluster * _Drive->QuerySectorSize( )) )
       ) {

        return ConvertFileDataResident( Dirent, Frs );

    } else {

        DebugAssert( FileSize > 0 );

        return ConvertFileDataNonResident( Dirent, Frs );
    }
}





BOOLEAN
FAT_NTFS::ConvertFileDataNonResident (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs
    )

/*++

Routine Description:

    Converts the file data from FAT to NTFS in nonresident form

Arguments:

    Dirent  -   Supplies the directory entry of the file to convert
    Frs     -   Supplies the FRS for the file

Return Value:

    BOOLEAN -   TRUE if file data successfully converted
                FALSE otherwise

--*/

{

    ULONG               Cluster;                //  File cluster number
    NTFS_ATTRIBUTE      DataAttribute;          //  File's $DATA attribute
    NTFS_EXTENT_LIST    ExtentList;             //  NTFS extent list
    ULONG               Length;                 //  Length of extent
    ULONG               FileSize;               //  File size
    ULONG               ClusterSize;            //  NTFS cluster size
    ULONG               ClustersLeft;           //  NTFS clusters left to convert
    ULONG               SectorsPerCluster;      //  Sectors per FAT cluster
    VCN                 Vcn;                    //  VCN
    LCN                 Lcn;                    //  LCN
    PFAT                Fat;                    //  Pointer to FAT

    DebugPtrAssert( Dirent );
    DebugPtrAssert( Frs );

    //
    //  Get the file size
    //
    FileSize            = Dirent->QueryFileSize();
    SectorsPerCluster   = _FatSa->QuerySectorsPerCluster();

    DebugAssert( FileSize > 0 );

    //
    //  First we generate an extent list mapping the file's data
    //  allocation. We just add all the clusters in the file as
    //  extents of size SectorsPerCluster. Note that we don't
    //  have to do anything special about consecutive clusters
    //  (the Extent List coallesces them for us).
    //
    //  If there are unused sectors in the last cluster, we mark
    //  them in  the ReservedBitmap.
    //
    if ( !ExtentList.Initialize( 0, 0 ) ) {
        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    Cluster             = Dirent->QueryStartingCluster();
    ClusterSize         = _ClusterFactor*_Drive->QuerySectorSize();
    ClustersLeft        = (FileSize + ClusterSize - 1)/ClusterSize;
    Fat                 = _FatSa->GetFat();
    Vcn                 = 0;

    //  Add all the FAT clusters to the NTFS extent list. Note that in the last
    //  cluster we only add those sectors that contain file data, and the rest
    //  will become free after the conversion.
    //
    while ( ClustersLeft ) {

        Lcn = FatClusterToLcn( Cluster )/_ClusterFactor;
        Length = min( ClustersLeft, _ClusterRatio );

        //DebugPrintTrace(( "    Extent: Cluster %d Vcn %d Lcn %d Length %d Left %d\n",
        //            Cluster, Vcn.GetLowPart(), Lcn.GetLowPart(), Length,
        //            SectorsLeft ));

        if ( !ExtentList.AddExtent( Vcn, Lcn, Length ) ) {
            _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            _Message->Display( );
            _Status = CONVERT_STATUS_ERROR;
            DebugAssert(FALSE);
            return FALSE;
        }

        Vcn += Length;
        ClustersLeft -= Length;

        DebugAssert((ClustersLeft > 0) || Fat->IsEndOfChain(Cluster));

        Cluster = Fat->QueryEntry( Cluster );
    }

    //
    //  Unused sectors in the last cluster are marked in the
    //  ReservedBitmap.
    //
    if ( Length < _ClusterRatio  ) {

        _ReservedBitmap.SetAllocated( Lcn+Length,
                                      _ClusterRatio - Length );
    }

    //
    //  Now put the file data in the $DATA attribute of the file
    //
    if ( !DataAttribute.Initialize( _Drive,
                                    _ClusterFactor,
                                    &ExtentList,
                                    FileSize,
                                    FileSize,
                                    $DATA ) ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    if ( !DataAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

        _Message->Set( MSG_CONV_CANNOT_CONVERT_DATA, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  File data converted
    //
    return TRUE;
}





BOOLEAN
FAT_NTFS::ConvertFileDataResident (
    IN      PFAT_DIRENT                 Dirent,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs
    )

/*++

Routine Description:

    Converts the file data from FAT to NTFS in resident form

Arguments:

    Dirent  -   Supplies the directory entry of the file to convert
    Frs     -   Supplies the FRS for the file

Return Value:

    BOOLEAN -   TRUE if file data successfully converted
                FALSE otherwise

--*/

{

    HMEM                Hmem;                   //  Memory
    CLUSTER_CHAIN       ClusterChain;           //  File cluster
    NTFS_ATTRIBUTE      DataAttribute;          //  File's $DATA attribute
    ULONG               FileSize;               //  File size

    DebugPtrAssert( Dirent );
    DebugPtrAssert( Frs );

    //
    //  Get the file size
    //
    FileSize = Dirent->QueryFileSize();

    if ( FileSize > 0 ) {
        //
        //  Read the file data.
        //
        if ( !Hmem.Initialize() ||
             !ClusterChain.Initialize( &Hmem,
                                       _Drive,
                                       _FatSa,
                                       _FatSa->GetFat(),
                                       Dirent->QueryStartingCluster(), 1 ) ) {

            _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            _Message->Display( );
            _Status = CONVERT_STATUS_ERROR;
            DebugAssert(FALSE);
            return FALSE;
        }

        if ( !ClusterChain.Read() ) {

            //
            //  We cannot read the file data, possibly because there is a
            //  bad sector on the volume. We will try make the file data
            //  non-resident (that way we don't need to read the data, since
            //  all we do is generate the allocation info). Doing things
            //  this way does not change the state of the drive (i.e. it was
            //  bad before conversion, it is bad after the conversion).
            //
            return ConvertFileDataNonResident( Dirent, Frs );
        }
    }

    //
    //  Now put the file data in the $DATA attribute of the file
    //
    if ( (FileSize > 0 && !ClusterChain.GetBuf()) ||
         !DataAttribute.Initialize( _Drive,
                                    _ClusterFactor,
                                    (FileSize > 0) ? ClusterChain.GetBuf() : NULL,
                                    FileSize,
                                    $DATA ) ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    if ( !DataAttribute.InsertIntoFile( Frs, &_VolumeBitmap ) ) {

        _Message->Set( MSG_CONV_CANNOT_CONVERT_DATA, ERROR_MESSAGE );
        _Message->Display( );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  We can now mark the cluster with the file data in the
    //  ReservedBitmap, so it will be freed after the conversion.
    //
    //  Note that we cannot mark it free in the VolumeBitmap because
    //  the conversion process must NOT overwrite it (or data may
    //  be lost if the conversion fails!).
    //
    if ( FileSize > 0 ) {
        ReserveCluster( Dirent->QueryStartingCluster() );
    }

    //
    //  File data converted
    //
    return TRUE;
}





BOOLEAN
FAT_NTFS::ConvertFileSystem(
    )

/*++

Routine Description:

    Converts the existing FAT file system to NTFS. This is done by
    traversing the file system tree and converting the FAT structures
    (i.e. directories, files and EAs).

    The space occupied by FAT-specific files (e.g. the EA file) is marked
    in the ReservedBitmap so it will be freed up when the conversion is
    done.

    Note that Operating-System-specific files (e.g. IO.SYS, MSDOS.SYS) are
    NOT removed by the conversion process. This is a File System conversion,
    not an Operating System conversion (If this file system conversion is
    being invoked by an operating system conversion program, then that
    program is responsible for removing any system files).

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if file system successfully converted
                FALSE otherwise

--*/

{
    PFATDIR                     RootDir;        //  FAT root directory
    FAT_DIRENT                  EAFileDirEnt;   //  Entry for EA file
    DSTRING                     EAFile;         //  Name of EA file
    ULONG                       i;              //  Cluster index
    PFAT                        Fat;            //  Pointer to FAT
    UCHAR    FatType;

    _Message->Set( MSG_CONV_CONVERTING_FS );
    _Message->Display();

    //
    //  Get the root directory
    //
    RootDir = (PFATDIR)_FatSa->GetRootDir();

    FatType = FAT_TYPE_EAS_OKAY;

    if ( !RootDir ) {
        RootDir = (PFATDIR)_FatSa->GetFileDir();
        FatType = FAT_TYPE_FAT32;
    }

    DebugPtrAssert( RootDir );

    //
    //  Locate the EA file. If it exists then remember its starting cluster
    //  number and initialize the EA header.
    //
    //  The starting cluster of the EA file is remembered because it is used
    //  later on for identifying the EA file while traversing the root directory.
    //
    EAFile.Initialize( "EA DATA. SF" );

    if ( (FAT_TYPE_FAT32 != FatType) && EAFileDirEnt.Initialize( RootDir->SearchForDirEntry( &EAFile )) )
    {
        _EAFileFirstCluster = EAFileDirEnt.QueryStartingCluster();

        Fat = _FatSa->GetFat();

        if ( !_EAMemory.Initialize()                        ||
             !_EAHeader.Initialize( &_EAMemory,
                                    _Drive,
                                    _FatSa,
                                    Fat,
                                    _EAFileFirstCluster )   ||

             !_EAHeader.Read()
           ) {

            _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
            _Message->Display();
            _Status = CONVERT_STATUS_ERROR;
            DebugAssert(FALSE);
            return FALSE;
        }

        //
        //  Mark all the EA file sectors in the ReservedBitmap, so the
        //  space will be freed up when the conversion is done.
        //
        i = _EAFileFirstCluster;

#if DBG
        if ( _Flags & CONVERT_VERBOSE_FLAG ) {
            DebugPrintTrace(( "EA file at cluster %X\n", _EAFileFirstCluster ));
        }
#endif

        while (TRUE) {

            ReserveCluster( i );

            if ( Fat->IsEndOfChain( i ) ) {
                break;
            }

            i = Fat->QueryEntry( i );
        }

    } else {

#if DBG
        if ( _Flags & CONVERT_VERBOSE_FLAG ) {
            DebugPrintTrace(( "The volume contains no EA file\n" ));
        }
#endif

        _EAFileFirstCluster = 0;

    }


    //
    //  Convert the volume by recursively converting the root directory
    //
    return ConvertRoot( RootDir );
}



BOOLEAN
FAT_NTFS::CreateBitmaps(
    )

/*++

Routine Description:

    Creates the NTFS bitmaps for the volume and the bad block stack.

    Two bitmaps are created:

        _VolumeBitmap   - Is the bitmap for the volume. Represents the volume at
                          seemed by NTFS.

        _ReservedBitmap - Contains those NTFS clusters that are marked as "in use"
                          in the _VolumeBitmap during the conversion, but that must
                          be marked as "free" after the conversion. This is
                          required so that the conversion don't try to allocate
                          those clusters. These "reserved" clusters include all
                          the FAT structures that will be thrown away after the
                          conversion.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if bitmaps and bad block stack created.
                FALSE otherwise

--*/

{
    PFAT    Fat;                //  The FAT
    ULONG   Cluster;            //  Used to traverse FAT
    LCN     Lcn;                //  Same as Cluster, but in sectors
    ULONG   ClusterCount;       //  Number of clusters in volume
    LCN     DataAreaStart;      //  Start of data area;
    ULONG   SectorsPerFatCluster;   //  Sector counter
    BIG_INT NumberOfClusters;

    //
    //  Initialize bitmaps
    //

    DebugAssert(_FatSa->IsVolumeDataAligned() || (_ClusterFactor == 1));

    NumberOfClusters = (_Drive->QuerySectors() - 1)/_ClusterFactor;
    DebugAssert(NumberOfClusters.GetHighPart() == 0);

    if (!_VolumeBitmap.Initialize(NumberOfClusters, FALSE, _Drive, _ClusterFactor) ||
        !_ReservedBitmap.Initialize(NumberOfClusters, FALSE, NULL, 0)) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    //
    //  The boot area must be free (it will become reserved when creating
    //  the elementary NTFS structures).
    //

    //
    //  The FAT ( From the end of the boot area up to the beginning of
    //  the data area) is reserved but will be freed at the end of the
    //  conversion.
    //
    DataAreaStart = _FatSa->QueryStartDataLbn();

    DebugAssert(!_FatSa->IsVolumeDataAligned() || (DataAreaStart % _ClusterFactor == 0));

    DataAreaStart = DataAreaStart / _ClusterFactor;

    _VolumeBitmap.SetAllocated( CLUSTERS_IN_BOOT,
                                DataAreaStart - CLUSTERS_IN_BOOT );

    _ReservedBitmap.SetAllocated( CLUSTERS_IN_BOOT,
                                  DataAreaStart - CLUSTERS_IN_BOOT );

    //
    //  Allocate the rest of the bitmap according to the FAT
    //
    Lcn             = DataAreaStart;
    Cluster         = FirstDiskCluster;
    ClusterCount    = _FatSa->QueryClusterCount() - (ULONG)FirstDiskCluster;
    Fat             = _FatSa->GetFat();
    SectorsPerFatCluster = _ClusterRatio * _ClusterFactor;

    while ( ClusterCount-- ) {

        //
        //  If the cluster is not free then allocate it if its OK, or
        //  push it onto the bad stack if it is bad.
        //
        if ( Fat->IsClusterFree( Cluster ) ) {

            Lcn += _ClusterRatio;

        } else if ( Fat->IsClusterBad( Cluster ) ) {

            _BadLcn.Add( Lcn*_ClusterFactor, SectorsPerFatCluster );
            Lcn += _ClusterRatio;

        } else {

            _VolumeBitmap.SetAllocated( Lcn, _ClusterRatio );
            Lcn += _ClusterRatio;
        }

        Cluster++;
    }

    //
    //  Note that CLUSTERS_IN_BOOT are not really free (will be
    //  allocated later on).
    //
    _FreeSectorsBefore = ((BIG_INT)(_VolumeBitmap.QueryFreeClusters() - CLUSTERS_IN_BOOT))*
                         _Drive->QuerySectorSize();

    return TRUE;
}




BOOLEAN
FAT_NTFS::CreateElementary(
    )

/*++

Routine Description:

    Creates the elementary NTFS data structures.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if elementary NTFS data structures created.
                FALSE otherwise

--*/

{
    NTFS_UPCASE_FILE    UpcaseFile;
    NTFS_ATTRIBUTE      UpcaseAttribute;
    NTFS_LOG_FILE       LogFile;
    DSTRING             VolumeLabel;    //  Volume label

    BOOLEAN             Error;

    DebugAssert( _VolumeBitmap.IsFree( 0, CLUSTERS_IN_BOOT ) );

    //
    //  Get the volume label and create the elementary NTFS structures.
    //  Pass in zero for the initial log file size to indicate that
    //  CreateElementaryStructures should decide how big to make it.
    //
    if ( !_FatSa->QueryLabel( &VolumeLabel )            ||
         !_NtfsSa.CreateElementaryStructures( &_VolumeBitmap,
                                              _ClusterFactor,
                                              _FrsSize,
                                              SMALL_INDEX_BUFFER_SIZE,
                                              0,
                                              &_BadLcn,
                                              TRUE,
                                              TRUE,
                                              _Message,
                                              _FatSa->GetBpb(),
                                              &VolumeLabel ) ) {


        _Message->Set( MSG_CONV_CANNOT_CREATE_ELEMENTARY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;

        return FALSE;
    }

    //
    //  Now that we have the elementary structures, obtain the MFT, which is
    //  used later on during the conversion.  Since we don't have an upcase
    //  table yet, pass in NULL for that parameter.
    //
    if ( !_Mft.Initialize( _Drive,
                           _NtfsSa.QueryMftStartingLcn(),
                           _ClusterFactor,
                           _FrsSize,
                           _NtfsSa.QueryVolumeSectors(),
                           &_VolumeBitmap,
                           NULL )             ||
         !_Mft.Read() ) {

        _Message->Set( MSG_CONV_CANNOT_READ, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;

        return FALSE;
    }

    // Tell the volume bitmap about the new Mft so it can add any
    // bad clusters it finds to the bad cluster file.

    _VolumeBitmap.SetMftPointer(_Mft.GetMasterFileTable());


    // Get the upcase table.
    //
    if( !UpcaseFile.Initialize( _Mft.GetMasterFileTable() ) ||
        !UpcaseFile.Read() ||
        !UpcaseFile.QueryAttribute( &UpcaseAttribute, &Error, $DATA ) ||
        !_UpcaseTable.Initialize( &UpcaseAttribute ) ) {

        DebugPrint( "Can't get the upcase table.\n" );
        return FALSE;
    }

    _Mft.SetUpcaseTable( &_UpcaseTable );
    _Mft.GetMasterFileTable()->SetUpcaseTable( &_UpcaseTable );

    //
    //  If we know how many files there are on the volume, extend the
    //  MFT so it is (sort of) contiguous.
    //
    if ( (_NumberOfFiles + _NumberOfDirectories) > 0 ) {

        if ( !_Mft.Extend( _NumberOfFiles + _NumberOfDirectories + 20 ) ) {

            DebugPrintTrace(( "Cannot extend MFT by %d segments\n", _NumberOfFiles + _NumberOfDirectories  ));

            _Message->Set( MSG_CONV_CANNOT_CREATE_ELEMENTARY, ERROR_MESSAGE );
            _Message->Display();
            _Status = CONVERT_STATUS_ERROR;
            return FALSE;
        }
    }

    //  Flush the MFT now, so that it gets first claim to the FRS's
    //  at the beginning of the MFT.
    //
    if( !_Mft.Flush() ) {

        DebugPrintTrace(( "CONVERT: Cannot flush the MFT\n"  ));

        _Message->Set( MSG_CONV_CANNOT_CREATE_ELEMENTARY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    // Sanity check: make sure that the log file doesn't have
    // an attribute list.  The file system will die horribly
    // if Convert creates a log file with external attributes.
    //
    if( !LogFile.Initialize( _Mft.GetMasterFileTable() ) ||
        !LogFile.Read() ||
        LogFile.IsAttributePresent( $ATTRIBUTE_LIST ) ) {

        _Message->Set( MSG_CONV_VOLUME_TOO_FRAGMENTED );
        _Message->Display( "" );
        return FALSE;
    }


    return TRUE;
}




BOOLEAN
FAT_NTFS::FreeReservedSectors (
    )

/*++

Routine Description:

    Frees up those sectors marked as "in use" in the _ReservedBitmap.
    The _VolumeBitmap is updated and written to disk.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if sectors freed and _VolumeBitmap written.
                FALSE otherwise.

--*/

{

    NTFS_BITMAP_FILE        BitmapFile;     //  NTFS bitmap file
    NTFS_ATTRIBUTE          Attribute;      //  $DATA attribute of bitmap file
    LCN                     Lcn;            //  LCN
    BOOLEAN                 Error;
    PFILEDIR                DirF32;         // Pointer to FAT 32 Root dir
    BIG_INT                 NumberOfLcn;

    //
    //  Free the "reserved" clusters
    //
    NumberOfLcn = _Drive->QuerySectors()/_ClusterFactor;
    for ( Lcn = 0; Lcn < NumberOfLcn; Lcn += 1 ) {
        if ( !_ReservedBitmap.IsFree( Lcn, 1 ) ) {
            _VolumeBitmap.SetFree( Lcn, 1 );
            _ReservedBitmap.SetFree( Lcn, 1 );
        }
    }

    DirF32 = _FatSa->GetFileDir();
    if (DirF32) { // it's a fat32 drive..
        ULONG       clus;
        PFAT        Fat;                //  The FAT
        ULONG       SectorsPerCluster;  //  Sectors per cluster
        LCN         DataAreaStart;      //  Start of data area;
        LCN         Lcn;                //  Logical cluster number

        SectorsPerCluster = _FatSa->QuerySectorsPerCluster();
        Fat           = _FatSa->GetFat();
        DataAreaStart = _FatSa->QueryStartDataLbn();

        //
        // Mark the first 32 reserved sectors for later cleanup
        //
        _ReservedBitmap.SetAllocated( CLUSTERS_IN_BOOT, (32-1)/_ClusterFactor+1-CLUSTERS_IN_BOOT );

        //
        // Mark the root chain as "UN-used" in the NTFS bitmap.
        // Mark those root directory clusters in the reserved bitmap for later cleanup
        //
        for (clus = DirF32->QueryStartingCluster(); !Fat->IsEndOfChain(clus); clus = Fat->QueryEntry(clus)) {
            {   // Free sectors under this Root Dir Cluster
                Lcn = (DataAreaStart + ((clus-FirstDiskCluster)*SectorsPerCluster))/_ClusterFactor;
                _VolumeBitmap.SetFree( Lcn, _ClusterRatio );
                _ReservedBitmap.SetAllocated( Lcn, _ClusterRatio );
            }
        }
        {   // Free sectors under this Root Dir Cluster
            Lcn = (DataAreaStart + ((clus-FirstDiskCluster)*SectorsPerCluster))/_ClusterFactor;
            _VolumeBitmap.SetFree( Lcn, _ClusterRatio );
            _ReservedBitmap.SetAllocated( Lcn, _ClusterRatio );
        }
    } else {

        ULONG root_offset = _FatSa->QueryReservedSectors()+_FatSa->QueryFats()*_FatSa->QuerySectorsPerFat();
        ULONG root_size = (_FatSa->QueryRootEntries()*BytesPerDirent - 1)/_Drive->QuerySectorSize() + 1;

        DebugAssert( root_offset % _ClusterFactor == 0 );
        DebugAssert( root_size % _ClusterFactor == 0 );

        _ReservedBitmap.SetAllocated( root_offset/_ClusterFactor, root_size/_ClusterFactor );
    }

    //
    //  Update the Bitmap file.
    //
    if ( !BitmapFile.Initialize( _Mft.GetMasterFileTable() )  ||
         !BitmapFile.Read()                                   ||
         !BitmapFile.QueryAttribute( &Attribute, &Error, $DATA )
         ) {

        _Message->Set( MSG_CONV_CANNOT_READ, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  Update the Bitmap file data attribute (i.e. the volume bitmap)
    //
    if ( !_VolumeBitmap.Write( &Attribute, &_VolumeBitmap ) ) {
        _Message->Set( MSG_CONV_CANNOT_WRITE, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    _FreeSectorsAfter = ((BIG_INT)_VolumeBitmap.QueryFreeClusters())*_ClusterFactor;

#if DBG
    if ( _Flags & CONVERT_VERBOSE_FLAG ) {
        DebugPrintTrace(( "Free sectors before conversion: %d\n", _FreeSectorsBefore.GetLowPart() ));
        DebugPrintTrace(( "Free sectors after conversion:  %d\n", _FreeSectorsAfter.GetLowPart() ));
    }
#endif

    return TRUE;
}





BOOLEAN
FAT_NTFS::QueryNeededHoles (
    OUT  PINTSTACK   Stack
    )

/*++

Routine Description:

    Determines what holes are required and pushes the hole
    information in the supplied stack.

Arguments:

    Stack   -   Supplies the stack where the hole information is
                passed

Return Value:

    BOOLEAN -   TRUE if all hole information is in stack
                FALSE otherwise

--*/

{
    BIG_INT     HoleStart;              //  Starting sector of hole
    BIG_INT     HoleSize;               //  Size of the hole
    BIG_INT     BootSize;               //  Size of boot code
    BIG_INT     MftSize;                //  Size of MFT
    BIG_INT     MftReflectionSize;      //  Size of MFT reflection
    ULONG       sectorsize;
    USHORT      i;

    //
    //  Initialize the hole stack
    //

    if ( !Stack->Initialize() ) {
        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    //
    //  The only NTFS structure that needs a fixed location is
    //  the BOOT backup.  Push the size and location of this sector
    //  onto the stack.
    //

    if ( !Stack->Push( 1 )   ||
     !Stack->Push( _FatSa->QueryVirtualSectors() - 1 ) ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    //
    //  We also want to create a hole big enough for the MFT and
    //  the MFT reflection. These don't need to be in a particular
    //  location, but they have to be contiguous (i.e. occupy a
    //  single "hole").
    //
    sectorsize = _Drive->QuerySectorSize();

    MftSize = (_FrsSize * FIRST_USER_FILE_NUMBER + (sectorsize - 1)) / sectorsize;

    MftReflectionSize = (_FrsSize * REFLECTED_MFT_SEGMENTS + (sectorsize - 1))
                / sectorsize;

    HoleSize = MftSize + MftReflectionSize;
    HoleStart = _FatSa->QueryVirtualSectors() - 1 - HoleSize;

#if DBG
    if ( _Flags & CONVERT_VERBOSE_FLAG ) {
        DebugPrintTrace(( "Hole required: Sector %X, size %X\n",
                     HoleStart.GetLowPart(), HoleSize.GetLowPart() ));
    }
#endif

    //
    //  Make sure that the hole lies entirely in the FAT data area. Otherwise
    //  we won't be able to relocate the clusters in the hole.
    //
    if ( HoleStart < _FatSa->QueryStartDataLbn() ) {
        _Message->Set( MSG_CONV_CANNOT_CONVERT_VOLUME, ERROR_MESSAGE );
        _Message->Display( "%s%s", "NTFS", "FAT" );
        _Status = CONVERT_STATUS_ERROR;
        return FALSE;
    }

    //
    //  Push the hole data in the stack. Size goes first!
    //
    if ( !Stack->Push( HoleSize  )   ||
         !Stack->Push( HoleStart ) ) {

        _Message->Set( MSG_CONV_NO_MEMORY, ERROR_MESSAGE );
        _Message->Display();
        _Status = CONVERT_STATUS_ERROR;
        DebugAssert(FALSE);
        return FALSE;
    }

    return TRUE;
}




VOID
FAT_NTFS::QuerySectorsNeededForConversion (
    IN  PCENSUS_REPORT  Census,
    OUT PBIG_INT        SectorsNeeded
    )
/*++

Routine Description:

    Determines how many sectors are required for the conversion, given
    the volume census.

Arguments:

    Census          -   Supplies the volume census
    SectorsNeeded   -   Supplies pointer to number of sectors needed

Return Value:

    None

--*/

{
    BIG_INT     SectorsRequired;
    BIG_INT     BytesInIndices;

    ULONG   szTemp;
    ULONG       NtfsClusterSize;    //  Size of an NTFS cluster
    ULONG       sectorsize;

    CONST       AverageBytesPerIndexEntry = 128;


#if DBG
    if ( _Flags & CONVERT_VERBOSE_FLAG ) {
        DebugPrintTrace(( "\n" ));
        DebugPrintTrace(( "---- Volume Census Data ----\n" ));
        DebugPrintTrace(( "Number of dirs:      %d\n", Census->DirEntriesCount ));
        DebugPrintTrace(( "Number of files:     %d\n", Census->FileEntriesCount ));
        DebugPrintTrace(( "Clusters in dirs:    %d\n", Census->DirClusters ));
        DebugPrintTrace(( "Clusters in files:   %d\n", Census->FileClusters ));
        DebugPrintTrace(( "Clusters in EA file: %d\n", Census->EaClusters ));
        DebugPrintTrace(( "\n\n" ));
    }
#endif


    NtfsClusterSize      = _Drive->QuerySectorSize() * _ClusterFactor;
    _NumberOfFiles       = Census->FileEntriesCount;
    _NumberOfDirectories = Census->DirEntriesCount;

    SectorsRequired =
        NTFS_SA::QuerySectorsInElementaryStructures( _Drive,
                                                     _ClusterFactor,
                                                     _FrsSize,
                                                     _ClustersPerIndexBuffer,
                                                     0 );


    //
    //  We will need _ClustersPerFrs clusters for each file or
    //  directory, plus enough index blocks to hold the required
    //  index entries.  (Multiply the size of indices by two to
    //  reflect the fact that the average index block will be
    //  half full.)
    //

    sectorsize = _Drive->QuerySectorSize();

    SectorsRequired += ( _NumberOfFiles + _NumberOfDirectories ) *
                            ((_FrsSize + (sectorsize - 1))/sectorsize);

    BytesInIndices = ( _NumberOfFiles + _NumberOfDirectories ) *
                         AverageBytesPerIndexEntry * 2;

    SectorsRequired += BytesInIndices / _Drive->QuerySectorSize();

    //
    //  Extended attributes
    //
    if(Census->EaClusters) {

        //
        // With EAs each file will require one extra header for the EA itself
        //
        SectorsRequired += _NumberOfFiles *
                           ((_FrsSize + (sectorsize - 1))/sectorsize);

        //
        // Compute the "per file average EA size", round it up to
        // the sector size and multiply it times the file count to get
        // the projected EA size on NTFS.
        //
        szTemp = Census->EaClusters * _FatSa->QuerySectorsPerCluster();
        szTemp = (szTemp + (_NumberOfFiles - 1)) / _NumberOfFiles; // sectors per file in EAs
        if(szTemp == 0) {
            szTemp = 1;
        }
        SectorsRequired += szTemp * _NumberOfFiles;
    }

    //
    //  In case of unreported bad sectors, we reserve 0.1% of the disk
    //
    SectorsRequired += _Drive->QuerySectors() / 1000;

    // And that's that.

    *SectorsNeeded = SectorsRequired;

}





BOOLEAN
FAT_NTFS::ReserveCluster (
    IN ULONG     Cluster
    )
/*++

Routine Description:

    "Reserves" all the sectors in the given clusters. This is done
    by marking the sectors in the ReservedBitmap.

Arguments:

    Cluster -   Supplies cluster whose sectors are to be reserved

Return Value:

    BOOLEAN -   TRUE if all sectors in the cluster have been reserved
                FALSE otherwise

--*/

{
    LCN         Lcn;
    BIG_INT     Clusters;

    Clusters = ((ULONG)_FatSa->QuerySectorsPerCluster()) / _ClusterFactor;

    if ( Cluster > 0 ) {

        Lcn = FatClusterToLcn( Cluster )/_ClusterFactor;

        _ReservedBitmap.SetAllocated( Lcn, Clusters );

        return TRUE;
    }

    return FALSE;
}



NONVIRTUAL
BOOLEAN
FAT_NTFS::CheckGeometryMatch(
    )
/*++

Routine Description:

    This method checks that the geometry recorded in the
    Bios Parameter Block agrees with the geometry reported
    by the driver.

Arguments:

    None.

Return Value:

    TRUE if the geometry in the BPB matches that reported
    by the driver; false if not.  Note that the only field
    which is checked is BytesPerSector.

--*/
{
    USHORT SectorSize, SectorsPerTrack, Heads;
    ULONG HiddenSectors;

    _FatSa->QueryGeometry( &SectorSize,
                           &SectorsPerTrack,
                           &Heads,
                           &HiddenSectors );

    if( SectorSize      != _Drive->QuerySectorSize() ) {

        return FALSE;
    }

    return TRUE;
}




BOOLEAN
FAT_NTFS::WriteBoot (
    )

/*++

Routine Description:

    Updates the boot sector and writes any other information (e.g.
    partition data) so that the volume will be recognized as an NTFS
    volume.

Arguments:

    none

Return Value:

    BOOLEAN -   TRUE if boot sector updated
                FALSE otherwise

--*/

{
    FSTRING BootLogFileName;
    PBYTE   ZeroBuf;
    ULONG   Lcn;

    BOOLEAN Done;

    Done =  (BOOLEAN)(_Mft.Flush() &&
                      _NtfsSa.Write( _Message ) &&
                      _NtfsSa.WriteRemainingBootCode());

    if (Done) {
        //
        // Now that it passses the point of no return, we clean up
        // any remaining fat32 reserved boot sectors and/or fat root directory.
        //

        ZeroBuf = (PBYTE)MALLOC( _Drive->QuerySectorSize()*_ClusterFactor );

        if (ZeroBuf == NULL) {
            _Message->Set( MSG_CONV_NO_MEMORY );
            _Message->Display();
            return FALSE;
        }

        memset( ZeroBuf, 0, _Drive->QuerySectorSize()*_ClusterFactor );

        for ( Lcn = 0; Lcn < _ReservedBitmap.QuerySize(); Lcn +=1 ) {

            if ( !_ReservedBitmap.IsFree( Lcn, 1 ) && _VolumeBitmap.IsFree( Lcn, 1 ) ) {
                if (!_Drive->Write( Lcn*_ClusterFactor, 1, ZeroBuf )) {
                    DebugPrintTrace(("CUFAT: Failed to wipe clean cluster %x\n", Lcn));
                }
            }
        }

        FREE(ZeroBuf);
    }

#if defined ( _AUTOCONV_ )

    if ( Done ) {

        //
        //  The volume is no longer FAT. We have to reboot so that the
        //  system recognizes it.  Note that before we reboot, we
        //  must flush the drive's cache.
        //
        BootLogFileName.Initialize( L"bootex.log" );

        if( _Message->IsLoggingEnabled() &&
            !NTFS_SA::DumpMessagesToFile( &BootLogFileName,
                                          &_Mft,
                                          _Message ) ) {

            DebugPrintTrace(( "CONVERT: Error writing messages to BOOTEX.LOG\n" ));
        }

        _Drive->FlushCache();

        _Drive->InvalidateVolume();

        //
        // Unlock the volume and close our handle, to let the filesystem
        // notice that things have changed.
        //

        DELETE(_Drive);

        if ( _Flags & CONVERT_PAUSE_FLAG ) {

            _Message->Set( MSG_CONV_PAUSE_BEFORE_REBOOT );
            _Message->Display();

            _Message->WaitForUserSignal();
        } else {
            _Message->Set( MSG_CONV_CONVERSION_COMPLETE );
            _Message->Display();
        }

        //
        // If we've paused for oem setup, we pass PowerOff = TRUE to
        // Reboot.
        //

        IFS_SYSTEM::Reboot( (_Flags & CONVERT_PAUSE_FLAG) ? TRUE : FALSE );
    }
#endif

    return Done;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dasdread.cpp ===
/*****************************************************************************************************************

FILENAME: DasdRead.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

OVERVIEW:
	Routines for reading directly from the disk.
*/

#include "stdafx.h"

#ifdef BOOTIME
extern "C" {
	#include <stdio.h>
}
	#include "Offline.h"
#else
	#include <windows.h>
#endif

extern "C" {
	#include "SysStruc.h"
}
#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"

#include "Alloc.h"
#include "Message.h"

/*****************************************************************************************************************

ROUTINE: DasdLoadSectors

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine allocates a buffer and fills it with sectors read from a disk.
	NOTE: This memory buffer must be larger than the data it is to hold by the number of bytes in a sector.
	this is because this routine will align the read on a sector boundary, and this may temporarily
	shift the buffer as much as there are bytes in a sector.  It will be shifted back before returning.

INPUT + OUTPUT:
	IN hVolume			- A handle to the volume to read sectors from.
	IN Sector			- Sector to start reading from.
	IN Sectors			- Number of sectors to read.
	IN BytesPerSector	- The number of bytes in a sector.

RETURN:
	Handle to the memory that the sectors were read into.
	NULL = Failure
*/

HANDLE
DasdLoadSectors(
	IN HANDLE			hVolume,
	IN LONGLONG 		Sector,
	IN LONGLONG 		Sectors,
	IN LONGLONG 		BytesPerSector
	)
{
	HANDLE				hBuffer = NULL;
	LPBYTE				pBuffer = NULL;
	LONGLONG			BufferSize = Sectors * BytesPerSector;
	LONGLONG			ByteOffset = Sector * BytesPerSector; 
	LONGLONG			AllocSize = BufferSize + BytesPerSector;
	LPBYTE				pLoad = NULL;
	OVERLAPPED			Seek = {0};
	DWORD				Read = 0;
	BOOL				bOk = FALSE;

	//0.0E00 Error if we were requested to read nothing.
	if (BufferSize == 0){
		EH(FALSE);
		return (HANDLE) NULL;
	}

	//0.0E00 Allocate and lock a buffer; allocate 1 sector more than needed for alignment
	if (!AllocateMemory((DWORD) AllocSize, &hBuffer, (PVOID*) &pBuffer)){
		EH(FALSE);
		return (HANDLE) NULL;
	}

	__try{

		//0.0E00 Sector align the buffer for DASD read
		pLoad = pBuffer;
		if(((DWORD_PTR)pBuffer & (BytesPerSector-1)) != 0){
			pLoad = (LPBYTE)(((DWORD_PTR)pBuffer&~(BytesPerSector-1))+BytesPerSector);
		}	

		//0.0E00 Set the seek address
		*(PLONGLONG)(&Seek.Offset) = ByteOffset;
		Seek.hEvent = NULL;

		//0.0E00 Read the sectors
		if (!ReadFile(hVolume, pLoad, (DWORD)BufferSize, &Read, &Seek)){
			EH_ASSERT(FALSE);
			__leave;
		}

		//0.0E00 De-align the data back to the start of the buffer
		if(((DWORD_PTR)pBuffer&(BytesPerSector-1)) != 0){
			MoveMemory(pBuffer, pLoad, (DWORD)BufferSize);
            ZeroMemory(pBuffer + BufferSize, (DWORD)(AllocSize - BufferSize));
		}

		bOk = TRUE;
	}

	__finally{

		// if not OK, delete the memory and null the handle
		if (!bOk){ 
			if (hBuffer){ 
				EH_ASSERT(GlobalUnlock(hBuffer) == FALSE);
				EH_ASSERT(GlobalFree(hBuffer) == NULL);
			}
			hBuffer = NULL;
		}
	}

	return hBuffer;
}	
/*****************************************************************************************************************

ROUTINE: DasdStoreSectors

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine stores a buffer to sectors on a disk.
	NOTE: This memory buffer must be larger than the data it is to hold by the number of bytes in a sector.
	this is because this routine will align the read on a sector boundary, and this may temporarily
	shift the buffer as much as there are bytes in a sector.  It will be shifted back before returning.

INPUT + OUTPUT:
	IN hVolume			- A handle to the volume to read sectors from.
	IN Sector			- Sector to start reading from.
	IN Sectors			- Number of sectors to read.
	IN BytesPerSector	- The number of bytes in a sector.
	IN pBuffer			- The buffer to write to the disk.

RETURN:
	TRUE = Success
	FALSE = Failure
*/

BOOL
DasdStoreSectors(
	IN HANDLE			hVolume,
    IN LONGLONG	       	Sector,
	IN LONGLONG			Sectors,
	IN LONGLONG			BytesPerSector,
	IN LPBYTE			pBuffer
    )
{
	LONGLONG			BufferSize = Sectors * BytesPerSector;
	LONGLONG	 		ByteOffset = Sector * BytesPerSector; 
	LPBYTE				pLoad = NULL;
	OVERLAPPED			Seek = {0};
	DWORD				Read = 0;
	BOOL				bStatus = FALSE;

	//0.0E00 Error if we were requested to write nothing.
	EF_ASSERT(BufferSize != 0);

	//0.0E00 Sector align the buffer for DASD write
	pLoad = pBuffer;
	if(((DWORD_PTR)pBuffer & (BytesPerSector-1)) != 0){
		pLoad = (LPBYTE)(((DWORD_PTR)pBuffer&~(BytesPerSector-1))+BytesPerSector);
		MoveMemory(pLoad, pBuffer, (DWORD)BufferSize);
	}
	//0.0E00 Set the seek address
	*(PLONGLONG)(&Seek.Offset) = ByteOffset;
	Seek.hEvent = NULL;

	//0.0E00 Read the sectors
	EF_ASSERT(WriteFile(hVolume, pLoad, (DWORD)BufferSize, &Read, &Seek));

	//0.0E00 De-align the data back to the start of the buffer
	if(((DWORD_PTR)pBuffer&(BytesPerSector-1)) != 0){
		MoveMemory(pBuffer, pLoad, (DWORD)BufferSize);
        ZeroMemory(pBuffer + BufferSize, (DWORD)(pLoad - pBuffer));
	}
	return TRUE;
}	
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine reads clusters from a disk into a memory buffer.
	NOTE: This memory buffer must be larger than the data it is to hold by the number of bytes in a sector.
	this is because this routine will align the read on a sector boundary, and this may temporarily
	shift the buffer as much as there are bytes in a sector.  It will be shifted back before returning.

INPUT + OUTPUT:
	IN hVolume			- A handle to the volume to read sectors from.
	IN Cluster			- Cluster to start reading from.
	IN Clusters			- Number of clusters to read.
	OUT pBuffer			- Where the clusters will be written into memory.
	IN BytesPerSector	- The number of bytes in a sector.
	IN BytesPerCluster	- The number of bytes in a cluster.

RETURN:
	TRUE = Success
	FALSE = Failure
*/

BOOL
DasdReadClusters(
	IN HANDLE			hVolume,
    IN LONGLONG	       	Cluster,
	IN LONGLONG			Clusters,
	IN PVOID			pBuffer,
	IN LONGLONG			BytesPerSector,
	IN LONGLONG			BytesPerCluster
    )
{
	LONGLONG	       	ByteOffset = Cluster * BytesPerCluster;
	LONGLONG			ByteLength = Clusters * BytesPerCluster;
    LONGLONG            FullLength = ByteLength + BytesPerSector;
	LPBYTE				pLoad = NULL;
	OVERLAPPED			Seek;
	DWORD				Read = 0;

	//0.0E00 Error if requested to read nothing.
	EF_ASSERT(ByteLength != 0);

	//Zero out the seek parameter.
	ZeroMemory(&Seek, sizeof(OVERLAPPED));

	//On FAT, or FAT32, we have to bump the offset up since the "clusters" don't start until after the boot
	//block and the FAT's.
	if(VolData.FileSystem == FS_FAT || VolData.FileSystem == FS_FAT32){
		ByteOffset += VolData.FirstDataOffset;
	}

	//0.0E00 Sector align the buffer for DASD read
	pLoad = (LPBYTE)pBuffer;
	if(((DWORD_PTR)pBuffer & (BytesPerSector-1)) != 0){
		pLoad = (LPBYTE)(((DWORD_PTR)pBuffer&~(BytesPerSector-1))+BytesPerSector);
	}
	
	//0.0E00 Set the seek address
	*(PLONGLONG)(&Seek.Offset) = ByteOffset;
	Seek.hEvent = NULL;

	//DURING INTEGRATION BETWEEN DKMS AND OFFLINE, I DIDN'T KNOW IF THE WSPRINTF AND ERROR STUFF IS NECESSARY.
	//SO I PUT IT IN AS WELL AS THE EF_ASSERT.
	//0.0E00 Read the clusters
//	EF_ASSERT(ReadFile(hVolume, pLoad, (DWORD)ByteLength, &Read, &Seek));
	if(!ReadFile(hVolume, pLoad, (DWORD)ByteLength, &Read, &Seek)){
        TCHAR cOutline[200];
        wsprintf (cOutline,
			TEXT("ReadFile: Handle=0x%08lx, pLoad=0x%08lx, ByteLength=0x%08lx, Offset=0x%08lx, Cluster=0x%08lx\n"),
            hVolume, 
			pLoad, 
			(DWORD)ByteLength, 
			(LONG) ByteOffset, 
			(LONG) Cluster);
        Message (cOutline, GetLastError(), NULL);
		EF(FALSE);
    }

	//0.0E00 De-align the data back to the start of the buffer
	if(((DWORD_PTR)pBuffer&(BytesPerSector-1)) != 0){
		MoveMemory(pBuffer, pLoad, (DWORD)ByteLength);
        ZeroMemory((char*)pBuffer + ByteLength, (DWORD)(FullLength - ByteLength));
	}

	return TRUE;
}
/*****************************************************************************************************************

ROUTINE: DasdWriteClusters

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine writes clusters from a disk into a memory buffer.
	NOTE: This memory buffer must be larger than the data it is to hold by the number of bytes in a sector.
	this is because this routine will align the read on a sector boundary, and this may temporarily
	shift the buffer as much as there are bytes in a sector.  It will be shifted back before returning.

INPUT + OUTPUT:
	IN hVolume			- A handle to the volume to read sectors from.
	IN Cluster			- Cluster to start reading from.
	IN Clusters			- Number of clusters to read.
	OUT pBuffer			- Where the clusters will be written into memory.
	IN BytesPerSector	- The number of bytes in a sector.
	IN BytesPerCluster	- The number of bytes in a cluster.

RETURN:
	TRUE = Success
	FALSE = Failure
*/
 
BOOL
DasdWriteClusters(
	IN HANDLE			hVolume,
    IN LONGLONG	       	Cluster,
	IN LONGLONG			Clusters,
	IN PVOID			pBuffer,
	IN LONGLONG			BytesPerSector,
	IN LONGLONG			BytesPerCluster
    )
{
	LONGLONG	       	ByteOffset = Cluster * BytesPerCluster;
	LONGLONG			ByteLength = Clusters * BytesPerCluster;
    LONGLONG            FullLength = ByteLength + BytesPerSector;
	LPBYTE				pLoad = NULL;
	OVERLAPPED			Seek;
	DWORD				Read = 0;



	//0.0E00 Error if requested to write nothing.
	EF_ASSERT(ByteLength != 0);

	//Zero out the seek parameter.
	ZeroMemory(&Seek, sizeof(OVERLAPPED));

	//On FAT, or FAT32, we have to bump the offset up since the "clusters" don't start until after the boot
	//block and the FAT's.
	if(VolData.FileSystem == FS_FAT || VolData.FileSystem == FS_FAT32){
		ByteOffset += VolData.FirstDataOffset;
	}

	//0.0E00 Sector align the buffer for DASD write
	pLoad = (LPBYTE)pBuffer;
	if(((DWORD_PTR)pBuffer & (BytesPerSector-1)) != 0){
		pLoad = (LPBYTE)(((DWORD_PTR)pBuffer&~(BytesPerSector-1))+BytesPerSector);
		MoveMemory(pLoad, pBuffer, (DWORD)ByteLength);
	}

	//0.0E00 Set the seek address
	*(PLONGLONG)(&Seek.Offset) = ByteOffset;
	Seek.hEvent = NULL;

	//0.0E00 Write the clusters
	EF_ASSERT(WriteFile(hVolume, pLoad, (DWORD)ByteLength, &Read, &Seek));

	//0.0E00 De-align the data back to the start of the buffer
	if(((DWORD_PTR)pBuffer&(BytesPerSector-1)) != 0){
		MoveMemory(pBuffer, pLoad, (DWORD)ByteLength);
        ZeroMemory((char*)pBuffer + ByteLength, (DWORD)(FullLength - ByteLength));
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dataio.cpp ===
/**************************************************************************************************

FILENAME: DataIo.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#define INC_OLE2
#include "stdafx.h"

#ifndef SNAPIN
#include <windows.h>
#endif
//#include <objbase.h>
#include <initguid.h>

#include "DataIo.h"
#include "DataIoCl.h"
#include "Message.h"
#include "ErrMacro.h"

// If we use DataIo with a console application, then we cannot use
// the Windows message pump PostMessage() routine as there is No
// window to post the message to, so we will use a locally created
// PostMessageLocal() routine instead.

#ifdef ESI_POST_MESSAGE
    #pragma message ("Information: ESI_POST_MESSAGE defined.")
    #include "PostMsgC.h"
#endif


/**************************************************************************************************

Globals 

*/

int vcObjects = 0;
CClassFactory g_ClassFactory;

extern HWND hwndMain;

/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    CClassFactory::QueryInterface implementation.

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    IN  REFIID riid - reference IID of the ClassFactory Interface.
    OUT void** ppv.- receives a pointer to the interface pointer of the object.

RETURN:
	HRESULT - zero = success.  
    HRESULT - non zero = error code.
*/

STDMETHODIMP
CClassFactory::QueryInterface(REFIID riid, void** ppv)
{
    // Check for valid argunment - ppv should be NULL.
    if (ppv == NULL) {
//        Message(TEXT("CClassFactory::QueryInterface"), E_INVALIDARG, NULL);
        return E_INVALIDARG;
    }
    // Make sure we are being asked for a ClassFactory or Unknown interface.
    if (riid == IID_IClassFactory || riid == IID_IUnknown) {

        // If so return a pointer to this interface.
        *ppv = (IClassFactory*) this;
        AddRef();
//        Message(TEXT("CClassFactory::QueryInterface"), S_OK, NULL);
        return S_OK;
    }
    // No interface.
    *ppv = NULL;
//    Message(TEXT("CClassFactory::QueryInterface"), E_NOINTERFACE, NULL);
    return E_NOINTERFACE;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    CClassFactory::CreateInstance implementation of the ESI Data Object.

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    IN  LPUNKNOWN punkOuter - aggregate pointer - must be NULL as we don't support aggregation.
    IN  REFIID riid - reference IID of the ClassFactory Interface.
    OUT void** ppv.- receives a pointer to the interface pointer of the object.

RETURN:
	HRESULT - zero = success.  
    HRESULT - non zero = error code.
*/

STDMETHODIMP
CClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void** ppv)
{
    LPUNKNOWN punk;
    HRESULT hr;

    *ppv = NULL;

    // Check for aggregation - we don't support it..
    if (punkOuter != NULL) {
//        Message(TEXT("CClassFactory::CreateInstance"), CLASS_E_NOAGGREGATION, NULL);
        return CLASS_E_NOAGGREGATION;
    }
    // Create the ESI Data Object.
//    Message(TEXT("CClassFactory::CreateInstance"), S_OK, NULL);
    punk = new EsiDataObject;

    // If we didn't get a pointer then we are out of memory.
    if (punk == NULL) {
//        Message(TEXT("CClassFactory::CreateInstance"), E_OUTOFMEMORY, NULL);
        return E_OUTOFMEMORY;
    }
    // Get a pointer to the ESI Data Object interface.
    hr = punk->QueryInterface(riid, ppv);

    // Release the pointer to the ESI Data Object.
    punk->Release();
    return hr;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    EsiDataObject::EsiDataObject constructor.

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    None.

RETURN:
    None.
*/

EsiDataObject::EsiDataObject(void)
{
    m_cRef = 1;
    
    hDataOut = NULL;
    hDataIn = NULL; 

//    Message(TEXT("EsiDataObject::EsiDataObject"), S_OK, NULL);
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    EsiDataObject::EsiDataObject destructor.

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    None.

RETURN:
    None.
*/

EsiDataObject::~EsiDataObject(void)
{
//    Message(TEXT("EsiDataObject::~EsiDataObject"), S_OK, NULL);
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    EsiDataObject::QueryInterface

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    IN  REFIID riid - reference IID of the EsiDataObject interfavce.
    OUT void** ppv.- receives a pointer to the interface pointer of the object.

RETURN:
	HRESULT - zero = success.  
	HRESULT - non zero = error code.
*/

STDMETHODIMP
EsiDataObject::QueryInterface(REFIID riid, void** ppv)
{
    // Check for valid argunment - ppv should be NULL.
    if (ppv == NULL) {
//        Message(TEXT("EsiDataObject::QueryInterface"), E_INVALIDARG, NULL);
        return E_INVALIDARG;
	}
    // Make sure we are being asked for a DataObject interface.
    if (riid == IID_IUnknown || riid == IID_IDataObject) {

        // If so return a pointer to this interface.
        *ppv = (IUnknown *) this;
        AddRef();
//        Message(TEXT("EsiDataObject::QueryInterface"), S_OK, NULL);
        return S_OK;
    }
    // No interface.
    *ppv = NULL;
//    Message(TEXT("EsiDataObject::QueryInterface"), E_NOINTERFACE, NULL);
    return E_NOINTERFACE;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Decrements the reference count and when zero deletes the interface object and post a
    WM_CLOSE message to terminate the program.

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    IN  REFIID riid - reference IID of the EsiDataObject interfavce.
    OUT void** ppv.- receives a pointer to the interface pointer of the object.

RETURN:
	ULONG - m_cRef  
*/

STDMETHODIMP_(ULONG)
EsiDataObject::Release(void) 
{ 
    if (InterlockedDecrement(&m_cRef) == 0) {

        delete this; 
        return 0; 
    } 
    return m_cRef; 
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    EsiDataObject::GetData only supports CF_TEXT

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    IN LPFORMATETC
    IN LPSTGMEDIUM

RETURN:
	HRESULT - zero = success.  
	HRESULT - non zero = error code.
*/

STDMETHODIMP
EsiDataObject::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{   
    char FAR* pstrDest;
    char FAR* pDataOut = NULL;
//  char FAR* pstrSrc;
   
    if (!(pformatetcIn->dwAspect & DVASPECT_CONTENT))
        return DATA_E_FORMATETC;
                                                 
    switch (pformatetcIn->cfFormat) {

        case CF_TEXT:

            if (!(pformatetcIn->tymed & TYMED_HGLOBAL))
                return DATA_E_FORMATETC;
            
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;

            pmedium->hGlobal = GlobalAlloc(GHND,GlobalSize(hDataOut));
			EE_ASSERT(pmedium->hGlobal);

            pstrDest = (char FAR *)GlobalLock(pmedium->hGlobal);
			EE_ASSERT(pstrDest);

            pDataOut  = (char FAR *)GlobalLock(hDataOut);
			EE_ASSERT(pDataOut);

            memcpy(pstrDest,pDataOut,(ULONG)GlobalSize(hDataOut));

            GlobalUnlock(hDataOut);
            GlobalUnlock(pmedium->hGlobal);
            break;
    
        default:
            return DATA_E_FORMATETC;
    }
    return S_OK;
}
// ------------------------------------------------------------------------------------------------
// %%Function: EsiDataObject::GetData
// ------------------------------------------------------------------------------------------------

// GetData only supports CF_TEXT
/*

STDMETHODIMP
EsiDataObject::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{   
    char FAR *pstrDest;
    char FAR *pstrSrc;
   
    if (!(pformatetcIn->dwAspect & DVASPECT_CONTENT))
        return DATA_E_FORMATETC;
                                                 
    switch (pformatetcIn->cfFormat) {

    case CF_TEXT:

        if (!(pformatetcIn->tymed & TYMED_HGLOBAL))
            return DATA_E_FORMATETC;
            
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = GlobalAlloc(GHND,GlobalSize(hGuid));
        pmedium->pUnkForRelease = NULL;
        pstrDest = (char FAR *)GlobalLock(pmedium->hGlobal);
        pstrSrc  = (char FAR *)GlobalLock(hGuid);
        memcpy(pstrDest,pstrSrc,GlobalSize(hGuid));
        GlobalUnlock(hGuid);
        GlobalUnlock(pmedium->hGlobal);
        break;
    
    default:
        return DATA_E_FORMATETC;
    }
    return S_OK;
}
/**************************************************************************************************

EsiDataObject::GetDataHere - NOT IMPLEMENTED.

*/

STDMETHODIMP
EsiDataObject::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
//    Message(TEXT("EsiDataObject::GetDataHere"), E_NOTIMPL, NULL);
    return E_NOTIMPL;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine tells the caller that we support only CF_TEXT and TYMED_HGLOBAL formats.

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    IN LPFORMATETC

RETURN:
	HRESULT - zero = success.  
    HRESULT - non zero = error code.
*/

STDMETHODIMP
EsiDataObject::QueryGetData(LPFORMATETC pformatetc)
{
    // Check for DVASPECT_CONTENT.
    if (!(DVASPECT_CONTENT & pformatetc->dwAspect)) {
//        Message(TEXT("EsiDataObject::QueryGetData"), DATA_E_FORMATETC, NULL);
        return DATA_E_FORMATETC;
    }
    // Check for CF_TEXT.        
    if (pformatetc->cfFormat != CF_TEXT) {
//        Message(TEXT("EsiDataObject::QueryGetData"), DATA_E_FORMATETC, NULL);
        return DATA_E_FORMATETC;
    }
    // Check for TYMED_HGLOBAL.        
    if (!(TYMED_HGLOBAL & pformatetc->tymed)) {
//        Message(TEXT("EsiDataObject::QueryGetData"), DV_E_TYMED, NULL);
        return DV_E_TYMED;
    }
//    Message(TEXT("EsiDataObject::QueryGetData"), S_OK, NULL);
    return S_OK;
}
/*
/**************************************************************************************************

EsiDataObject::GetCanonicalFormatEtc - NOT IMPLEMENTED.

*/

STDMETHODIMP
EsiDataObject::GetCanonicalFormatEtc(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
//    Message(TEXT("EsiDataObject::GetCanonicalFormatEtc"), DATA_S_SAMEFORMATETC, NULL);
    return DATA_S_SAMEFORMATETC;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    EsiDataObject::GetData only supports CF_TEXT

GLOBAL VARIABLES:
	None.

ARGUMENTS:
    IN LPFORMATETC
    IN LPSTGMEDIUM
    IN BOOL fRelease

RETURN:
	HRESULT - zero = success.  
	HRESULT - non zero = error code.

typedef struct {
	WORD dwID;          // ESI data structre ID always = 0x4553 'ES'
	WORD dwType;        // Type of data structure
   	WORD dwVersion;     // Version number
   	WORD dwCompatibilty;// Compatibilty number
    ULONG ulDataSize;   // Data size
    WPARAM wparam;      // LOWORD(wparam) = Command
    char cData;         // Void pointer to the data - NULL = no data
} DATA_IO, *PDATA_IO;

*/

STDMETHODIMP EsiDataObject::SetData(LPFORMATETC pformatetc, 
                                    STGMEDIUM FAR * pmedium,
                                    BOOL fRelease)
{
    WPARAM wpPostCommand;
    
    // We only support CF_TEXT
    if (pformatetc->cfFormat != CF_TEXT) {
//        Message(TEXT("EsiDataObject::SetData"), E_FAIL, NULL);
        return E_FAIL;
    }
    // We want memory only.
    if (pformatetc->tymed != TYMED_HGLOBAL) {
//        Message(TEXT("EsiDataObject::SetData"), E_FAIL, NULL);
        return E_FAIL;
    }

    DWORD dwGlobalSize;
    char FAR* pstrSrc;
    PCHAR pDataIn;

    // Check for valid memory handle.
    if(pmedium->hGlobal == NULL) {
//        Message(TEXT("EsiDataObject::SetData"), E_FAIL, NULL);
        return E_FAIL;
    }
    // Get the size of the incoming data.
    dwGlobalSize = (DWORD)GlobalSize(pmedium->hGlobal);

    // Allocate enough memory for the incoming data.
    hDataIn = GlobalAlloc(GHND,dwGlobalSize);
	EE_ASSERT(hDataIn);

    // Lock and get pointers to the data.
    pDataIn = (PCHAR)GlobalLock(hDataIn);
	EE_ASSERT(pDataIn);
    pstrSrc  = (char FAR*)GlobalLock(pmedium->hGlobal);
	EE_ASSERT(pstrSrc);

    // Copy the data to this processes memory.
    CopyMemory(pDataIn, pstrSrc, dwGlobalSize);

    // Unlock and release the pointer to the source memory.
    GlobalUnlock(pmedium->hGlobal);

	// Release the memory if requested by the caller.
    if (fRelease) {
	    ReleaseStgMedium(pmedium);
	}

    DATA_IO* pDataIo = (DATA_IO*)pDataIn;

    // Extract the Post Command message
    wpPostCommand = pDataIo->wparam;

    // Cehck ESI data structre ID which is always = 0x4553 'ES'
    if(pDataIo->dwID != ESI_DATA_STRUCTURE) {
//        Message(TEXT("EsiDataObject::SetData"), E_FAIL, NULL);
        return FALSE;
    }
    // Cehck the data structure type.
    if(pDataIo->dwType != FR_COMMAND_BUFFER) {
//        Message(TEXT("EsiDataObject::SetData"), E_FAIL, NULL);
        return FALSE;
    }
    // Check for data structure compatibility.
   	if(pDataIo->dwCompatibilty != FR_COMMAND_BUFFER_ONE) {
//        Message(TEXT("EsiDataObject::SetData"), E_FAIL, NULL);
        return FALSE;
    }
    // Unlock the memory.
    GlobalUnlock(hDataIn);

    // Check for any data.
   	if(pDataIo->ulDataSize == 0) {
        // Unlock the memory since there is no data other than the command.
        EH_ASSERT(GlobalFree(hDataIn) == NULL);
        hDataIn = NULL;
    }
    // Send the data to the message pump.
    // NOTE THAT THE MEMORY MUST FREED BY THE PROCESSING FUNCTION.

    // If we use DataIo with a console application, then we cannot use the WNT
    // PostMessage() routine as there is No window to post the message to, so
    // we will use a locally created PostMessageConsole() routine instead.

#ifdef ESI_POST_MESSAGE
#ifndef DKMS
    PostMessageLocal(NULL, WM_COMMAND, wpPostCommand, (LPARAM)hDataIn);
#endif
#else
    PostMessage(hwndMain, WM_COMMAND, wpPostCommand, (LPARAM)hDataIn);
#endif

//    Message(TEXT("EsiDataObject::SetData"), S_OK, NULL);
    return S_OK;
}
/**************************************************************************************************

EsiDataObject::EnumFormatEtc - NOT IMPLEMENTED.

*/

STDMETHODIMP
EsiDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc)
{
//    Message(TEXT("EsiDataObject::DAdvise"), E_NOTIMPL, NULL);
    return E_NOTIMPL ;
}
/**************************************************************************************************

EsiDataObject::DAdvise - NOT SUPPORTED.

*/

STDMETHODIMP
EsiDataObject::DAdvise(FORMATETC FAR* pFormatetc, 
                              DWORD advf, 
                              LPADVISESINK pAdvSink, 
                              DWORD FAR* pdwConnection)
{
//    Message(TEXT("EsiDataObject::DAdvise"), OLE_E_ADVISENOTSUPPORTED, NULL);
    return OLE_E_ADVISENOTSUPPORTED;
}
/**************************************************************************************************

EsiDataObject::DUnadvise - NOT SUPPORTED.

*/

STDMETHODIMP
EsiDataObject::DUnadvise(DWORD dwConnection)
{
//    Message(TEXT("EsiDataObject::DUnadvise"), OLE_E_ADVISENOTSUPPORTED, NULL);
    return OLE_E_ADVISENOTSUPPORTED;
}
/**************************************************************************************************

EsiDataObject::DUnadvise - NOT SUPPORTED.

*/

STDMETHODIMP
EsiDataObject::EnumDAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
//    Message(TEXT("EsiDataObject::EnumDAdvise"), OLE_E_ADVISENOTSUPPORTED, NULL);
    return OLE_E_ADVISENOTSUPPORTED;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This is the WinMain function for the Diskeeper Gui.

GLOBAL VARIABLES:
    None.

INPUT:
	hInstance - The handle to this instance.
	hPrevInstance - The handle to the previous instance.
	lpCmdLine - The command line which was passed in.
	nCmdShow - Whether the window should be minimized or not.

RETURN:
	TRUE - Success.
	FALSE - Failure to initilize.
*/

DWORD
InitializeDataIo(
    IN REFCLSID refCLSID,
	DWORD dwRegCls
	)
{
    HRESULT hr;
    DWORD dwRegister;

    // initialize COM for free-threading.
	// DO NOT want this for controls that are derived from ATL.  Bad Mojo
#ifndef ESI_DFRGUI
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#endif

    // Register the class-object with OLE.
    hr = CoRegisterClassObject(refCLSID,
							   &g_ClassFactory,
							   CLSCTX_SERVER,
                               dwRegCls, 
							   &dwRegister);

    if (FAILED(hr)) {
		return 0;
    }
    
	return( dwRegister );
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	Exit routine for DataIo

GLOBAL VARIABLES:
    None.

INPUT:
    None

RETURN:
	TRUE - Success.
	FALSE - Failure.
*/

BOOL
ExitDataIo(
    )
{
#ifndef ESI_DFRGUI
	// DO NOT want this for controls that are derived from ATL.  Bad Mojo
    CoUninitialize();
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\defragcommon.cpp ===
/**************************************************************************************************

FILENAME: defragcommon.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Common routines used in MFTdefrag and bootoptimize.

**************************************************************************************************/

#include "stdafx.h"

extern "C"{
    #include <string.h>
    #include <stdio.h>
    #include <stdlib.h>
}

#include "Windows.h"
#include <winioctl.h>
#include <math.h>
#include <fcntl.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>   // IsVolumeSnapshotted


extern "C" {
    #include "SysStruc.h"
}
#include "defragcommon.h"
#include "DfrgCmn.h"
#include "GetReg.h"

#include "Devio.h"

#include "FreeSpace.h"

#include "Alloc.h"
//#include "Message.h"

extern HWND hwndMain;
extern BOOL bCommandLineMode;

#if OPTLONGLONGMATH
#define DIVIDELONGLONGBY32(num)        Int64ShraMod32((num), 5)
#define MODULUSLONGLONGBY32(num)       ((num) & 0x1F)
#else
#define DIVIDELONGLONGBY32(num)        ((num) / 32)
#define MODULUSLONGLONGBY32(num)       ((num) % 32)
#endif




/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Returns the location of the first free space chunk found of size Get the size of the file in clusters from calling FSCL_GET_RETRIEVAL_POINTERS.

INPUT:
        LONGLONG BitmapSize                     The size of the bitmap for the volume
        LONGLONG BytesPerSector                 The bytes per sector
        LONGLONG TotalClusters                  The total clusters on the drive
        ULONGLONG lMFTsize                      The size of the MFT to look for
        ULONGLONG MftZoneStart                  The start of the MFT Zone
        ULONGLONG MftZoneEnd                    The end of the MFT Zone
        HANDLE  hVolumeHandle                   Volume HANDLE
RETURN:
        The starting cluster of where free space is located, or 0 if not found
*/



ULONGLONG FindFreeSpaceChunk(
        IN LONGLONG BitmapSize,
        IN LONGLONG BytesPerSector,
        IN LONGLONG TotalClusters,
        IN ULONGLONG ulFileSize,
        IN BOOL IsNtfs,
        IN ULONGLONG MftZoneStart,
        IN ULONGLONG MftZoneEnd,
        IN HANDLE hVolumeHandle
        )
{

    STARTING_LCN_INPUT_BUFFER   StartingLcnInputBuffer;         //input buffer for FSCTL_GET_VOLUME_BITMAP
    PVOLUME_BITMAP_BUFFER       pVolumeBitmap = NULL;           //pointer to Volume Bitmap
    HANDLE                      hVolumeBitmap = NULL;           //Handle to Volume Bitmap
    PULONG                      pBitmap = NULL;                 //pointer to the volume Bitmap
    ULONG                       BytesReturned = 0;              //number of bytes returned from ESDeviceIoControl
    BOOL                        bRetStatus = FALSE; // assume an error
    LONGLONG                    SearchStartLcn = 0;             //The LCN of where to start searching for free space
    LONGLONG                    FreeStartLcn = 0;               //The LCN of where free space starts
    LONGLONG                    FreeCount = 0;                  //The size of the free space in clusters

    //set the starting LCN to 0
    StartingLcnInputBuffer.StartingLcn.QuadPart = 0;

    if(!AllocateMemory((DWORD)(sizeof(VOLUME_BITMAP_BUFFER) + (BitmapSize / 8) + 1 + BytesPerSector),
                      &hVolumeBitmap,
                      NULL))
    {
            FreeStartLcn = 0;

    } else  //continue processing
    {
        //0.0E00 Lock and clear the bitmap buffer
        pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(hVolumeBitmap);
        if (pVolumeBitmap == (PVOLUME_BITMAP_BUFFER) NULL)
        {
            FreeStartLcn = 0;

        } else              //continue processing

        {
            ZeroMemory(pVolumeBitmap, (DWORD)(sizeof(VOLUME_BITMAP_BUFFER) + (BitmapSize / 8)));

            //0.0E00 Load the bitmap
            StartingLcnInputBuffer.StartingLcn.QuadPart = 0;
            pVolumeBitmap->BitmapSize.QuadPart = BitmapSize;

            //get the volume bit map
            if(ESDeviceIoControl(hVolumeHandle,
                                FSCTL_GET_VOLUME_BITMAP,
                                &StartingLcnInputBuffer,
                                sizeof(STARTING_LCN_INPUT_BUFFER),
                                pVolumeBitmap,
                                (DWORD)GlobalSize(hVolumeBitmap),
                                &BytesReturned,
                                NULL))

            {


                //start and the beginning of the disk with 0 free space found
                FreeCount = 0;
                SearchStartLcn = 0;

                //get a pointer that points to the bitmap part of the bitmap
                //(past the header)
                pBitmap = (PULONG)&pVolumeBitmap->Buffer;


                //mark the bit map used for the mft in NTFS
                if(IsNtfs)
                {
                    MarkBitMapforNTFS(pBitmap, MftZoneStart, MftZoneEnd);
                }       //search for free space on the drive starting with lcn 0    
                while(FreeCount < (LONGLONG)ulFileSize &&  SearchStartLcn < TotalClusters)
                {
                    FindFreeExtent(
                        pBitmap,            //Volume bit map
                        TotalClusters,      //range end
                        &SearchStartLcn,        //where to start searching
                        &FreeStartLcn,      //first free starting LCN
                        &FreeCount          //cluster count found
                        );

                    if(FreeCount > (LONGLONG)ulFileSize)
                    {
                        break;

                    }
                }


            }
        }
    }

    if(hVolumeBitmap != NULL)
    {
        GlobalUnlock(hVolumeBitmap);
        GlobalFree(hVolumeBitmap);
    }
    hVolumeBitmap = NULL;
    return FreeStartLcn;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
        Update the volume bitmap marking the MFT Zone as used space

INPUT:
        PULONG pBitmap                      The volume bit map
        ULONGLONG MftZoneStart              Start of the MFT Zone
        ULONGLONG MftZoneEnd                End of the MFT Zone
RETURN:
        PULONG pBitmap                      Updated bitmap with the MFT Zone marked as used
    
*/
VOID MarkBitMapforNTFS(
        IN OUT PULONG pBitmap,
        IN ULONGLONG MftZoneStart,
        IN ULONGLONG MftZoneEnd
        )
{
    //0.0E00 Fill the MFT zone with not-free

    ULONGLONG Cluster;
    if(MftZoneEnd > MftZoneStart)
    {
        Cluster = MftZoneStart;
        while((MODULUSLONGLONGBY32(Cluster) != 0) && (Cluster < MftZoneEnd)) 
        {
            pBitmap[DIVIDELONGLONGBY32(Cluster)] |= (1 << (ULONG) MODULUSLONGLONGBY32(Cluster));
            Cluster ++;
        }
        if(Cluster < MftZoneEnd) 
        {
            while(MftZoneEnd - Cluster >= 32)
            {
                pBitmap[DIVIDELONGLONGBY32(Cluster)] = 0xffffffff;
                Cluster += 32;
            }
            while(Cluster < MftZoneEnd) 
            {

                pBitmap[DIVIDELONGLONGBY32(Cluster)] |= (1 << (ULONG) MODULUSLONGLONGBY32(Cluster));
                Cluster ++;
            }
        }
    }

}



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Move a file to a new location to defrag it.

INPUT:
        HANDLE hMFTHandle                               Handle for the MFT          
        ULONGLONG ulFirstAvailableFreeSpace             Cluster location to move the file to
        ULONGLONG ulFileSize                            Size of the file in clusters
        ULONGLONG ulStartingVcn                         What VCN to start with when moving the file
        HANDLE hVolumeHandle                            The handle to the current volume                
RETURN:
        BOOL returns if the move was successful, TRUE it worked, FALSE it didn't
*/
BOOL MoveFileLocation(
        IN HANDLE hMFTHandle,
        IN ULONGLONG ulFirstAvailableFreeSpace,
        IN ULONGLONG ulFileSize,
        IN ULONGLONG ulStartingVcn,
        IN HANDLE hVolumeHandle
        )
{
    MOVE_FILE_DATA                  MoveFileData;                       //buffer to hold move file data
    ULONG                           BytesReturned = 0;                  //number of bytes returned from NTControlFile
    HANDLE                          hRetrievalPointersBuffer = NULL;    //handle for the retrieval pointers
    BOOL                            bReturnValue = FALSE;                       //value to return

    //
    // Open the file
    //
    if ((hMFTHandle) && (hMFTHandle != INVALID_HANDLE_VALUE)) {

            // Initialize the call to the hook to move this file.
        MoveFileData.FileHandle = hMFTHandle;
        MoveFileData.StartingVcn.QuadPart = ulStartingVcn;
        MoveFileData.StartingLcn.QuadPart = ulFirstAvailableFreeSpace;
        MoveFileData.ClusterCount = (ULONG)ulFileSize;

        bReturnValue = ESDeviceIoControl(hVolumeHandle,
                          FSCTL_MOVE_FILE,
                          &MoveFileData,
                          sizeof(MOVE_FILE_DATA),
                          NULL,
                          0,
                          &BytesReturned,
                          NULL);
    }

    return bReturnValue; 

}


//
// Returns true if szName starts with \??\Volume{ or \\?\Volume{
//
BOOL
StartsWithVolumeGuid(IN PCWSTR szName) {

    if (!szName) {
        return FALSE;
    }

    if (wcslen(szName) < 49) {
        return FALSE;
    }

    //
    // This is ugly, but I'm not using wcsicmp since we don't link
    // to msvcrt
    //
    if ((L'\\' == szName[0]) &&
        ((L'\\' == szName[1]) || (L'?' == szName[1])) &&
        (L'?'  == szName[2]) &&
        (L'\\' == szName[3]) &&
        ((L'V' == szName[4]) || (L'v' == szName[4])) &&
        ((L'O' == szName[5]) || (L'o' == szName[5])) &&
        ((L'L' == szName[6]) || (L'l' == szName[6])) &&
        ((L'U' == szName[7]) || (L'u' == szName[7])) &&
        ((L'M' == szName[8]) || (L'm' == szName[8])) &&
        ((L'E' == szName[9]) || (L'e' == szName[9])) &&
        (L'{' == szName[10])
        ) {
        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************************************************

ROUTINE DESCRIPTION:
    Send a pause message to the engine if a snapshot has been created for the 
    the volume being defragmented.

INPUT:
    PWSTR pVolumeName:  The volume name of the volume being defragmented:
        of the form \\?\Volume{GUID} or \\?\Volume{GUID}\

RETURN:
    BOOL returns TRUE
*/

BOOL PauseOnVolumeSnapshot(
    IN PWSTR pVolumeName
    )
{

    BOOL bSnapshot = FALSE, bPaused = FALSE;
    WCHAR szVolumeName[GUID_LENGTH + 1];
    DWORD dwLength = 0, count = 0;
    LONG lSnapCapability = 0;

    wcsncpy(szVolumeName, pVolumeName, GUID_LENGTH-1);
    dwLength = wcslen(szVolumeName);

    if (L'\\' != szVolumeName[dwLength]) {
        //
        // Add a terminating back-slash
        //
        szVolumeName[dwLength+1] = L'\0';
        szVolumeName[dwLength]   = L'\\';
    }

    while ((S_OK == IsVolumeSnapshotted(szVolumeName, &bSnapshot, &lSnapCapability))
        && bSnapshot
        && (lSnapCapability & VSS_SC_DISABLE_DEFRAG)
        ) {
        //
        // A snapshot is present for this volume.  Send a pause message to 
        // the engine (this updates the UI as well), and idle-wait here.
        //
        // Note that we're sending the pause message in a loop, since the
        // user might hit Resume.
        //
        PostMessage(hwndMain, WM_COMMAND, ID_PAUSE_ON_SNAPSHOT, 0);
        bPaused = TRUE;

        if ((bCommandLineMode) && (++count > 10)) {
            PostMessage(hwndMain, WM_COMMAND, ID_CONTINUE, 0);
            PostMessage(hwndMain, WM_COMMAND, ID_ABORT_ON_SNAPSHOT, 0);
        }

        Sleep(60000);   // check after a minute;
    }

    if (bPaused) {
        //
        // If we paused the engine, restart it.
        //
        PostMessage(hwndMain, WM_COMMAND, ID_CONTINUE, 0);
    }

    return TRUE;
}


/*****************************************************************************************************************

ROUTINE DESCRIPTION:
    Acquire the required privilege (such as the backup privilege)

INPUT:
    PCWSTR szPrivilegeName - The privilege to be acquired

RETURN:
    TRUE if the privilege could be acquired, FALSE otherwise.
    GetLastError will return the error code.
*/

BOOL
AcquirePrivilege(
    IN CONST PCWSTR szPrivilegeName
    )
{
    HANDLE hToken = NULL;
    BOOL bResult = FALSE;
    LUID luid;

    TOKEN_PRIVILEGES tNewState;

    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );

    if (!bResult) {
        return FALSE;
    }

    bResult = LookupPrivilegeValue(NULL, szPrivilegeName, &luid);
    if (!bResult) {
        CloseHandle(hToken);
        return FALSE;
    }

    tNewState.PrivilegeCount = 1;
    tNewState.Privileges[0].Luid = luid;
    tNewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // We will always call GetLastError below, so clear
    // any prior error values on this thread.
    //
    SetLastError(ERROR_SUCCESS);

    bResult = AdjustTokenPrivileges(
        hToken,         // Token Handle
        FALSE,          // DisableAllPrivileges    
        &tNewState,     // NewState
        (DWORD) 0,      // BufferLength
        NULL,           // PreviousState
        NULL            // ReturnLength
        );

    //
    // Supposedly, AdjustTokenPriveleges always returns TRUE
    // (even when it fails). So, call GetLastError to be
    // extra sure everything's cool.
    //
    if (ERROR_SUCCESS != GetLastError()) {
        bResult = FALSE;
    }

    CloseHandle(hToken);
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\devio.cpp ===
/*****************************************************************************************************************

FILENAME: Devio.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/


#include "stdafx.h"

#ifdef BOOTIME
    #include "Offline.h"
#else
	#include <windows.h>
#endif

extern "C" {
	#include "SysStruc.h"
}

#ifdef DFRG
	#include "DfrgCmn.h"
	#include "DfrgEngn.h"
#endif

#include "ErrMacro.h"
#include "DevIo.h"

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:
    None.

INPUT:

RETURN:

/**/

BOOL
WINAPI
ESDeviceIoControl(
    IN HANDLE hDevice,
    IN DWORD dwIoControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    IN OUT LPVOID lpOutBuffer,
    IN OUT DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned,
    IN OUT LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

	EF_ASSERT(hDevice != NULL && dwIoControlCode != 0);

    Status = NtFsControlFile(hDevice,
                             NULL,
                             NULL,             // APC routine
                             NULL,             // APC Context
                             &Iosb,
                             dwIoControlCode,  // IoControlCode
                             lpInBuffer,       // Buffer for data to the FS
                             nInBufferSize,	   // InputBuffer Length
                             lpOutBuffer,      // OutputBuffer for data from the FS
                             nOutBufferSize    // OutputBuffer Length
                             );

    if ( Status == STATUS_PENDING) {
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = Iosb.Status;
        }
    }

    if ( NT_SUCCESS(Status) ) {
        *lpBytesReturned = PtrToUlong((PVOID)Iosb.Information);
        return TRUE;
    }
    else {

		// Handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) ) {
            *lpBytesReturned = PtrToUlong((PVOID)Iosb.Information);
        }
		if(Status == STATUS_BUFFER_OVERFLOW){
			SetLastError(ERROR_MORE_DATA);
		}
		if(Status == STATUS_ALREADY_COMMITTED){
			SetLastError(ERROR_RETRY);
		}
		if(Status == STATUS_INVALID_PARAMETER){
			SetLastError(ERROR_INVALID_PARAMETER);
		}
		if(Status == STATUS_END_OF_FILE){
			SetLastError(ERROR_HANDLE_EOF);
		}
//        BaseSetLastNTError(Status);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dataiocl.cpp ===
/**************************************************************************************************

FILENAME: DataIoClient.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#define INC_OLE2

#include "stdafx.h"

#ifndef SNAPIN
#include <windows.h>
#endif
#include <stdio.h>

#include "DataIo.h"
#include "DataIoCl.h"
#include "Message.h"
#include "ErrMacro.h"

MULTI_QI mq;

/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This module inititalizes the DCOM DataIo Client communications.

INPUT:
    None.

RETURN:
	TRUE - Success.
	FALSE - Failure to initilize.
*/

BOOL
InitializeDataIoClient(
    IN REFCLSID rclsid,
    IN PTCHAR pMachine,
    IN OUT LPDATAOBJECT* ppstm
	)
{
    // Check if we already have a pointer to this DCOM server.
    if(*ppstm != NULL) {
		Message(TEXT("InitializeDataIoClient - called with non-NULL pointer"), -1, NULL);
        return FALSE;
    }

    HRESULT hr;
//    TCHAR wsz [200];
    COSERVERINFO sServerInfo;

    ZeroMemory(&sServerInfo, sizeof(sServerInfo));
/*
    if(pMachine != NULL) {
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pMachine, -1, wsz, 200);
        sServerInfo.pwszName = wsz;
    }
*/
    // Initialize the Multi QueryInterface structure.
    mq.pIID = &IID_IDataObject;
    mq.pItf = NULL;
    mq.hr = S_OK;

    // Create a remote instance of the object on the argv[1] machine
    hr = CoCreateInstanceEx(rclsid,
                            NULL,
                            CLSCTX_SERVER,
                            &sServerInfo,
                            1,
                            &mq);

//	Message(TEXT("InitializeDataIoClient - CoCreateInstanceEx"), hr, NULL);

    //  Check for failure.
    if (FAILED(hr)) {
		return FALSE;
	}
    // Return the pointer to the server.
    *ppstm = (IDataObject*)mq.pItf;
    return TRUE;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:


INPUT:


RETURN:
	TRUE - Success.
	FALSE - Failure.

typedef struct {
	WORD dwID;          // ESI data structre ID always = 0x4553 'ES'
	WORD dwType;        // Type of data structure
   	WORD dwVersion;     // Version number
   	WORD dwCompatibilty;// Compatibilty number
    ULONG ulDataSize;   // Data size
    WPARAM wparam;      // LOWORD(wparam) = Command
    TCHAR cData;        // Void pointer to the data - NULL = no data
} DATA_IO, *PDATA_IO;

*/

BOOL
DataIoClientSetData(
    IN WPARAM wparam,
    IN PTCHAR pData,
    IN DWORD dwDataSize,
    IN LPDATAOBJECT pstm
	)
{
    // Check for DCOM pointer to the server.
    if(pstm == NULL) {
        return FALSE;
    }

    HRESULT hr;
    HANDLE hData;
    DATA_IO* pDataIo;
    
    // Allocate and lock enough memory for the ESI data structure and the data being sent.
    hData = GlobalAlloc(GHND,dwDataSize + sizeof(DATA_IO));
	EF_ASSERT(hData);
    pDataIo = (DATA_IO*)GlobalLock(hData);
	EF_ASSERT(pDataIo);

    // Fill in the ESI data structure.
    pDataIo->dwID = ESI_DATA_STRUCTURE;              // ESI data structre ID always = 0x4553 'ES'
	pDataIo->dwType = FR_COMMAND_BUFFER;             // Type of data structure
   	pDataIo->dwVersion = FR_COMMAND_BUFFER_ONE;      // Version number
   	pDataIo->dwCompatibilty = FR_COMMAND_BUFFER_ONE; // Compatibilty number
    pDataIo->ulDataSize = dwDataSize;                // Data size
    pDataIo->wparam = wparam;                        // LOWORD(wparam) = Command

    // Copy the memory into the buffer, unlock it and
    // put the handle into the STGMEDIUM data structure.
    CopyMemory((PTCHAR)&pDataIo->cData, pData, dwDataSize);
    GlobalUnlock(hData);

    FORMATETC formatetc;
    STGMEDIUM medium;

    // Set up FORMATETC with CF_TEXT and global memory.
    formatetc.cfFormat = CF_TEXT;
    formatetc.ptd      = NULL;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex   = -1;
    formatetc.tymed    = TYMED_HGLOBAL;
                        
    // Set up STGMEDIUM with global memory and NULL for pUnkForRelease. 
    // SetData msut then be responsible for freeing the memory.
    medium.tymed          = TYMED_HGLOBAL;
    medium.pUnkForRelease = NULL;
    medium.hGlobal = hData;

    // Send it all to SetData, telling it that it is responsible for freeing the memory.
    hr = pstm->SetData(&formatetc, &medium, TRUE);

//    Message(TEXT("DataIoClientSetData - IDataObject::SetData"), hr, NULL);

    // Check for failure.
    if (FAILED(hr)) {
		return FALSE;
    }
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBALS:    
    FORMATETC - has been initialized in InitializeDataIoClient.

INPUT:
    None.

RETURN:
	HGLOBAL - handle to the memory containing the data.
    HGLOBAL - NULL = failure.
*/

HGLOBAL
DataIoClientGetData(
    IN LPDATAOBJECT pstm
    )
{
    // Check for DCOM pointer to the server.
    if(pstm == NULL) {
        return NULL;
    }

    FORMATETC formatetc;
    STGMEDIUM medium;
    HRESULT hr;
    
    // Zero the STGMEDIUM structure.
    ZeroMemory((void*)&medium, sizeof(STGMEDIUM));

    // Set up FORMATETC with CF_TEXT and global memory.
    formatetc.cfFormat = CF_TEXT;
    formatetc.ptd      = NULL;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex   = -1;
    formatetc.tymed    = TYMED_HGLOBAL;
                        
    // Get the data from the object.
    hr = pstm->GetData(&formatetc, &medium);

//    Message(TEXT("DataIoClientGetData - IDataObject::GetData"), hr, NULL);

    // Check for failure.
    if (FAILED(hr)) {
        return NULL;
    }
    DWORD dwSize;
    HGLOBAL hDataIn;
    PTCHAR pDataSource;
    PTCHAR pDataIn;

    // Allocate and lock enough memory for the data we received.
    dwSize = (DWORD)GlobalSize(medium.hGlobal);
    hDataIn = GlobalAlloc(GHND, dwSize);
	EF_ASSERT(hDataIn);
    pDataIn = (PTCHAR)GlobalLock(hDataIn);
	EF_ASSERT(hDataIn);

    // Get a pointer and lock the source data.
    pDataSource = (PTCHAR)GlobalLock(medium.hGlobal);

    // Copy the memory into the local buffer.
    CopyMemory(pDataIn, pDataSource, dwSize);

    // Unlock the memory.
    GlobalUnlock(hDataIn);
	GlobalUnlock(medium.hGlobal);
    
    // Free the source memory.
    ReleaseStgMedium(&medium);

    // Return the handle to the memory.
    return hDataIn;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	Exit routine for DataIo

GLOBAL VARIABLES:

INPUT:
    None;

RETURN:

*/

BOOL
ExitDataIoClient(
    IN LPDATAOBJECT* ppstm
    )
{
	// Release the object.
    if(*ppstm != NULL) { 
        
        LPDATAOBJECT pstm = *ppstm;
        
        pstm->Release(); 
        *ppstm = NULL; 
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\diskdisp.cpp ===
//*****************************************************************************************************************
//
//  CLASS: DISKDISPLAY
//  
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//  
// CLASS DESCRIPTION:
//      Uses an array passed in from the DiskView class called the LineArray that contains the necessary
//      data to draw a graphical representation of a disk.  Each byte in the LineArray is set to a specific
//      value that specifies the color of a corresponding vertical line on the screen when painted using
//      the DiskDisplay class.  This class also handles the painting of a legend at the bottom of the display
//      and data about the size of the disk, etc.  All the computational data for the display is done by
//      DiskView; DiskDisplay just paints it on the screen.
//  
//*****************************************************************************************************************

#include "stdafx.h"
#include "DiskDisp.h"
#include "Graphix.h"
#include "ErrMacro.h"

/*****************************************************************************************************************

  METHOD: DiskDisplay::DiskDisplay (Constructor)

METHOD DESCRIPTION:
    Initializes class variables.

RETURN:
    None.
*/

DiskDisplay::DiskDisplay()
{
    int i;

    //There is not yet data to draw with, so don't execute drawing functions later on until there is data to draw.
    m_bReadyToDraw = FALSE;

    m_LineArray = NULL;
    m_NumLines = 0;

    m_SpacerHeight = SPACER_HEIGHT;
    m_GraphicWellWidth = 0;
    m_GraphicWellHeight = 0;
    _tcscpy(m_Label, TEXT(""));

    //Allocate internal arrays for the maximum number of colors of lines we will be displaying.
    m_ColorArray = NULL;
    m_PenArray = NULL;
    m_BrushArray = NULL;

    //Initialize the colors for the various lines.
    m_ColorArray = new int [NUM_COLORS];
    EV(m_ColorArray);
    ChangeLineColor(SystemFileColor, GREEN);        // System files
    ChangeLineColor(PageFileColor, YELLOW);       // Pagefile
    ChangeLineColor(FragmentColor, RED);          // Fragmented files
    ChangeLineColor(UsedSpaceColor, BLUE);         // Contiguous files
    ChangeLineColor(FreeSpaceColor, LIGHTGRAY);     // Free space
    ChangeLineColor(DirectoryColor, LIGHTBLUE);     // Directories
    ChangeLineColor(MftZoneFreeSpaceColor, BLUE);     // MFT Zone  sks defrag mft changed from GREEN


    m_bStripeMftZone = TRUE;

    //Create all the pens that we'll draw with.
    m_PenArray = new HPEN [NUM_COLORS];
    EV(m_PenArray);
    for(i=0; i<NUM_COLORS; i++){
        m_PenArray[i] = CreatePen(PS_SOLID, 1, m_ColorArray[i]);
        EH(m_PenArray[i]);
    }

    //Create all the brushes that we'll draw with.
    m_BrushArray = new HBRUSH [NUM_COLORS];
    EV(m_BrushArray);
    for(i=0; i<NUM_COLORS; i++){
        m_BrushArray[i] = CreateHatchBrush(HS_BDIAGONAL, m_ColorArray[i]);
        EH(m_BrushArray[i]);
    }

    m_hCurrentPen = 0;
}

/*****************************************************************************************************************

METHOD: DiskDisplay::~DiskDisplay (Destructor)

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Does cleanup.

*/

DiskDisplay::~DiskDisplay()
{
    int i;

    if (m_LineArray)
        delete [] m_LineArray;
    
    if (m_PenArray) {
        for(i=0; i<NUM_COLORS; i++){
            if (m_PenArray[i])
                DeleteObject(m_PenArray[i]);
        }
        delete [] m_PenArray;
    }
    
    if (m_BrushArray) {
        for(i=0; i<NUM_COLORS; i++){
            if (m_BrushArray[i])
                DeleteObject(m_BrushArray[i]);
        }
        delete [] m_BrushArray;
    }

    if (m_ColorArray)
        delete [] m_ColorArray;
}
/*****************************************************************************************************************

METHOD: DiskView::operator=

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Duplicates a DiskDisplay.

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
    none.
*/

DiskDisplay& DiskDisplay::operator=(DiskDisplay& InDiskDisplay)
{
    if(this == &InDiskDisplay){
        return *this;
    }

    //If the other DiskDisplay has data to draw, then so will we.
    m_bReadyToDraw = InDiskDisplay.m_bReadyToDraw;

    //Don't need to do anything with m_PenArray, m_BrushArray, or m_ColorArray since these are already created by the constructor.
    m_hCurrentPen = InDiskDisplay.m_hCurrentPen;

    //If the number of clusters in the cluster array are not identical, realloc the array.
    if(m_NumLines != InDiskDisplay.m_NumLines){
        //Get the new size for the cluster array.
        m_NumLines = InDiskDisplay.m_NumLines;
        //Redimension the cluster array.
        if (m_LineArray)
            delete [] m_LineArray;

        m_LineArray = new char [m_NumLines];
        EH(m_LineArray);
    }

    //Copy over the line array.
    if (m_LineArray != NULL && InDiskDisplay.m_LineArray != NULL)
        CopyMemory(m_LineArray, InDiskDisplay.m_LineArray, m_NumLines);

    return *this;
}
/*****************************************************************************************************************

METHOD: DiskDisplay::SetNewOutputDimensions

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Given new coordinates to draw in, calculate anew how many lines we can draw in and figure what the
    m_ClusterFactor now is.  Reset all the appropriate variables and redimension the internal arrays.

INPUT + OUTPUT:
    rect - rectangle that borders the entire graphics area
    isSingleRow - set to TRUE is the rectangle holds a single row of graphics
    spacerHeight - number of pixels between each graphic well

RETURN:
    None.
*/

void DiskDisplay::SetOutputArea(RECT rect, BOOL isSingleRow, UINT spacerHeight)
{
    m_GraphicWellWidth = rect.right - rect.left - 1;
    m_Rect = rect;

    if (isSingleRow){
        m_SpacerHeight = 0;
        m_NumGraphicsRows = 1;
        m_GraphicWellHeight = rect.bottom - rect.top - 1;
    }
    else {
        m_SpacerHeight = spacerHeight;
        m_GraphicWellHeight = GRAPHIC_WELL_HEIGHT;
        m_NumGraphicsRows = (rect.bottom - rect.top + m_SpacerHeight) / (m_GraphicWellHeight + m_SpacerHeight);
    }

    int numLines = m_NumGraphicsRows * m_GraphicWellWidth;
    EV_ASSERT(numLines);

    if (numLines != m_NumLines){
        m_NumLines = numLines;

        if (m_LineArray)
            delete [] m_LineArray;

        m_LineArray = new char [m_NumLines];
        EV(m_LineArray);

        m_bReadyToDraw = FALSE;
    }
}
/*****************************************************************************************************************

METHOD: DiskDisplay::ChangeLineColor

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Sets the color of in the ColorArray to a passed in color.

CLASS VARIABLES:
    m_ColorArray - The ColorArray. 

INPUT + OUTPUT:
    iSet - The index in the ColorArray to set to NewColor.
    NewColor - The new color to put in the array.

RETURN:
    None.
*/

void DiskDisplay::ChangeLineColor(int iSet, int NewColor)
{
    require(iSet < NUM_COLORS);

    // this is a no-op if there is no color array allocated
    if (m_ColorArray != NULL){
        //The RGB values define the red, green, and blue contents for each of these colors.
        //These numbers give good results over different color setups (256 colors, or 65536 colors).
        switch (NewColor){
        case BLACK:
            m_ColorArray[iSet] = RGB(0, 0, 0);
            break;
        case RED:
            m_ColorArray[iSet] = RGB(220, 0, 0);
            break;
        case GREEN:
            m_ColorArray[iSet] = RGB(0, 220, 0);
            break;
        case YELLOW:
            m_ColorArray[iSet] = RGB(220, 220, 0);
            break;
        case BLUE:
            m_ColorArray[iSet] = RGB(0, 0, 220);
            break;
        case PURPLE:
            m_ColorArray[iSet] = RGB(200, 0, 200);
            break;
        case LIGHTBLUE:
            m_ColorArray[iSet] = RGB(0, 255, 255);
            break;
        case WHITE:
            m_ColorArray[iSet] = RGB(255, 255, 255);
            break;
        case LIGHTGRAY:
            m_ColorArray[iSet] = RGB(200, 200, 200);
            break;
        default:
            EV_ASSERT(FALSE);
            break;
        }
    }
}
/*****************************************************************************************************************

METHOD: DiskDisplay::SetNewLineColor

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Changes the color of one of the types of display lines.

INPUT + OUTPUT:
    iSet - The index in the ColorArray to set to NewColor.
    NewColor - The new color to put in the array.

RETURN:
    None.
*/

void DiskDisplay::SetNewLineColor(int iSet, int NewColor)
{
    require(iSet < NUM_COLORS);

    if(m_ColorArray != NULL){

        ChangeLineColor(iSet, NewColor);

        if (m_PenArray != NULL){
            if (m_PenArray[iSet]){
                EH_ASSERT(DeleteObject(m_PenArray[iSet]));
            }
            m_PenArray[iSet] = CreatePen(PS_SOLID, 1, m_ColorArray[iSet]);
            EH(m_PenArray[iSet]);
        }

        if (m_BrushArray != NULL){
            if (m_BrushArray[iSet]){
                EH_ASSERT(DeleteObject(m_BrushArray[iSet]));
            }
            m_BrushArray[iSet] = CreateHatchBrush(HS_BDIAGONAL, m_ColorArray[iSet]);
            EH(m_BrushArray[iSet]);
        }
    }
}
/*****************************************************************************************************************

METHOD: DiskDisplay::StripeMftZoneFreeSpace

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Determines whether the MFT zone is displayed as a striped color or as a solid color.

INPUT + OUTPUT:
    bInStripeMftZone - The value to set to.

RETURN:
    None.
*/

void DiskDisplay::StripeMftZoneFreeSpace(BOOL bInStripeMftZone)
{
    m_bStripeMftZone = bInStripeMftZone;
}

/*****************************************************************************************************************

METHOD: DiskDisplay::DrawLinesInHDC

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Draw the display.

INPUT + OUTPUT:
    hWndOutput - The window handle to use for painting functions.
    WorkDC - The DC to output to.
    rcPaint - The rectangle to paint within (usually because a portion of the screen was covered up by
                    another window).  NULL if no paint area specified.

RETURN:
    None.
*/

void DiskDisplay::DrawLinesInHDC(HDC WorkDC)
{
    RECT BoxRect;
    m_hCurrentPen = 0;


    //Draw each line in the HDC.
    BoxRect.left = m_Rect.left;
    BoxRect.right = m_Rect.right;

    ::SetBkColor(WorkDC, RGB(255, 255, 255));
    ::SetBkMode(WorkDC, OPAQUE);
    
    int iLine = 0;
    int yOffset;

    for (int row=0; row<m_NumGraphicsRows; row++) {

        yOffset = m_Rect.top + (m_GraphicWellHeight + m_SpacerHeight) * row;

        //Make a box around this row
        BoxRect.top = yOffset-1;
        BoxRect.bottom = yOffset + m_GraphicWellHeight;

        // Fill the dark gray graphics area
        HBRUSH hBrush = ::CreateSolidBrush(GetSysColor(COLOR_3DSHADOW));
        EV_ASSERT(hBrush);
        ::FillRect(WorkDC, &BoxRect, hBrush);
        ::DeleteObject(hBrush);

        // draw a border
        ::DrawBorderEx(WorkDC, BoxRect, SUNKEN_BOX);

        // draw the label in the center of the first well
        if (row==0 && _tcslen(m_Label)) {
            // make the text white in all color schemes
            SetTextColor(WorkDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            SetBkMode(WorkDC, TRANSPARENT);
            ::DrawText(WorkDC, m_Label, _tcslen(m_Label), &BoxRect, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
        }

        if (m_bReadyToDraw && m_LineArray){
            //Draw the individual lines
            for(int line=0; line < m_GraphicWellWidth && iLine < m_NumLines; line++){
                DrawLine(WorkDC, m_LineArray[iLine++], m_Rect.left + line + 1, yOffset, yOffset + m_GraphicWellHeight);
            }
        }
    }
}
/*****************************************************************************************************************

METHOD: DiskDisplay::DrawLine

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Draw one line in the display.

CLASS VARIABLES:
    m_PenArray - An array of pens of different colors that we use to draw the lines.
    m_BrushArray - An array of brushes we also use to draw the lines.
    m_xOut - The x coordinate of the upper left-hand corner of the box we can paint in in the HDC.
    m_yOut - The y coordinate.
    m_hCurrentPen - The pen selected into the DC last time DrawLine was called (used so we don't keep reselecting the same pen into the same DC).
    
INPUT + OUTPUT:
    WorkDC - The DC to draw in.
    Line - The color to draw

RETURN:
    None.
*/

inline void DiskDisplay::DrawLine(
    HDC WorkDC,
    char Color, 
    int x, 
    int yStart,
    int yEnd)
{
    if(m_BrushArray != NULL && m_PenArray != NULL){
        //Striped colors.
        if(m_bStripeMftZone && Color == MftZoneFreeSpaceColor){

            RECT Rect;

            //Get the appropriate brush.
            if (m_hCurrentBrush != (HBRUSH)m_BrushArray[MftZoneFreeSpaceColor]){
                m_hCurrentBrush = (HBRUSH)m_BrushArray[MftZoneFreeSpaceColor];
            }

            //Get the rectangle for one line.
            Rect.left = x;
            Rect.right = x + 1;
            Rect.top = yStart;
            Rect.bottom = Rect.top + m_GraphicWellHeight;

            //Draw the striped line.
            FillRect(WorkDC, &Rect, m_hCurrentBrush);
        }
        //Solid colors.
        else{
            //Get the appropriate pen.
            if (m_hCurrentPen != (HPEN)m_PenArray[Color]){
                SelectObject(WorkDC, (HPEN)m_PenArray[Color]);
                m_hCurrentPen = (HPEN)m_PenArray[Color];
            }

            //Draw the line.
            MoveToEx(WorkDC, x, yStart, NULL);
            LineTo(WorkDC, x, yEnd);
        }
    }
}
/*****************************************************************************************************************

METHOD: DiskDisplay::SetLineArray

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
    Store a new LineArray from the DiskView class.

CLASS VARIABLES:
    m_NumLines - How many lines we have in m_LineArray.
    m_LineArray - The array of bytes that store the color code for each line to display.

INPUT + OUTPUT:
    pInLineArray - Passed in buffer to be copied to m_LineArray.
    InNumLines - The number of lines in this passed in buffer.

RETURN:
    TRUE - Success.
    FALSE - Invalid size buffer was passed in.
*/

void DiskDisplay::SetLineArray(char* pInLineArray, int InNumLines)
{
    //If the size of the passed in buffer does not match what we're expecting, bail out.
    if (InNumLines > 0 && InNumLines == m_NumLines){
        //Copy the new buffer into the LineArray buffer.
        if (m_LineArray) {
            CopyMemory(m_LineArray, pInLineArray, m_NumLines);
            //Note that we now have data to draw with.
            m_bReadyToDraw = TRUE;
        }
    }
}

void DiskDisplay::SetReadyToDraw(IN BOOL bReadyToDraw)
{
    m_bReadyToDraw = bReadyToDraw;
}


void DiskDisplay::DeleteAllData(void)
{
    m_bReadyToDraw = FALSE;
}


void DiskDisplay::SetLabel(PTCHAR InLabel)
{
    if (InLabel) {
        if (_tcslen(InLabel) > MAX_PATH * 2 - 3) {
            _tcsncpy(m_Label, InLabel, MAX_PATH * 2 - 3);
            m_Label[MAX_PATH * 2 - 3] = TEXT('\0');
            _tcscat(m_Label, TEXT("..."));
        }
        else {
            _tcscpy(m_Label, InLabel);
        }
    }
    else {
        _tcscpy(m_Label, TEXT(""));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgfat.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

	   $(SDK_LIB_PATH)\crtdll.lib	\
	   $(SDK_LIB_PATH)\libcd.lib	\


!ENDIF

USE_MSVCRT=1

TARGETNAME=DfrgFat
TARGETPATH=obj
TARGETTYPE=PROGRAM

INCLUDES=..\Inc

USE_ATL=1

!ifdef TEST
TESTDEFINE= -DTest -DPauseAtEnd
!endif

!ifdef VISIBLEWINDOW
!ifndef TEST
VISIBLEWINDOWDEFINE= -DVisibleWindow
!endif
!endif

!ifdef ERRORSACTIVE
ERRORDEFINE= -DErrorsActive
!endif

!ifdef LOGGING
LOGDEFINE= -DLogging
!endif

C_DEFINES= -DNOTIMER -DWIN32 -DUNICODE -D_UNICODE -DENGINE -DNOEVTLOG -DDFRGFAT -DDFRG -DDKMS $(TESTDEFINE) $(VISIBLEWINDOWDEFINE) $(ERRORDEFINE) $(LOGDEFINE)
WIN32_WINNT_VERSION=0x0500

LINKER_STACKSIZE=/STACK:1048576,12288

MISCFILES=..\dfrg.reg    \
          ..\install.bat
	  
PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_CXX=1

SOURCES=..\Alloc.cpp     \
        BootOptimizeFat.cpp \
        ..\DasdRead.cpp  \
        ..\DataIo.cpp    \
        ..\DataIoCl.cpp  \
	..\defragcommon.cpp \
        ..\DevIo.cpp     \
        ..\DiskView.cpp  \
        DfrgFat.cpp      \
        ..\ErrLog.cpp    \
        ..\ErrMsg.cpp    \
        ..\Error.cpp     \
        ..\Exclude.cpp   \
        ..\Expand.cpp    \
        ..\Extents.cpp   \
        ..\FastFat2.cpp  \
        ..\FatSubs.cpp   \
        ..\FraggedFileList.cpp   \
        ..\FreeSpace.cpp  \
        ..\FsSubs.cpp    \
        ..\GetDfrgRes.cpp\
        ..\GetReg.cpp    \
        ..\GetTime.cpp   \
        ..\Graphix.cpp   \
        ..\IntFuncs.cpp  \
        ..\LoadFile.cpp  \
        ..\LogFile.cpp   \
        ..\Logging.cpp   \
        ..\MoveFile.cpp  \
        ..\Priority.c \
        ..\RemMsg.cpp    \
        ..\SecAttr.cpp \
        ..\TextBlock.cpp  \
        ..\UiCommon.cpp \
	..\vDebugGlobal.cpp \
	..\vWindowAppCore.cpp \
        ..\DfrgFat.rc    

UMENTRY=winmain
UMTYPE=windows
TARGETLIBS=$(SDK_LIB_PATH)\ntdll.lib	\
	   $(SDK_LIB_PATH)\comctl32.lib \
	   $(SDK_LIB_PATH)\shell32.lib  \
	   $(SDK_LIB_PATH)\ole32.lib	\
	   $(SDK_LIB_PATH)\uuid.lib     \
	   $(SDK_LIB_PATH)\vssapi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\diskview.cpp ===
/**********************************************************************************

FILENAME:   DiskView.cpp

CLASS:      DISKVIEW

CLASS DESCRIPTION:
    DiskView takes data from the engines about what each cluster of the disk is used for.
    It creates an array in memory (ClusterArray) to hold this data and then creates a 
    similar array to hold the data that DiskDisplay will use (LineArray) to display a 
    graphical image on the screen.  This means that DiskView must look through many 
    clusters in it's array an determine that the bulk of them are fragmented or not, 
    (or some special type of file), and set a byte to a specific color in the LineArray 
    (memory array for the display data -- 1 line = 1 block of clusters).

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/


#include "stdafx.h"
#ifndef SNAPIN
#include <windows.h>
#endif

extern "C" {
    #include "SysStruc.h"
}
#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"

#include "DiskView.h"
#include "Graphix.h"
#include "IntFuncs.h"

#include "GetReg.h"


#ifdef _DEBUG
#define CLASSINVARIANT()        EH_ASSERT(Invariant())
#else
#define CLASSINVARIANT()
#endif

// default: set line to frag color if 3% of clusters are fragged
#define FRAGTHRESHDEFAULT       3

// TEMP TEMP
#define ANALYZE_MEM_FAIL        0
#define DEFRAG_MEM_FAIL         0


/**********************************************************************************

Construction/Destruction

**********************************************************************************/

DiskView::DiskView()
{
    ::InitializeCriticalSection(&m_CriticalSection);

    // data we need from UI
    NumLines = 0;
    ClusterFactor = 0;
    pLineArray = NULL;

    // control variables
    m_bIsDataSent = FALSE;
    m_IsActive = FALSE;
    m_FragColorThreshold = FRAGTHRESHDEFAULT;
    m_bMemAllocFailed = FALSE;

    m_nFreeDelta = 0;
    m_nFragDelta = 0;
    m_nNonMovableDelta = 0;
    m_nUsedDelta = 0;

    // init basic variables.
    MftZoneStart = 0;
    MftZoneEnd = 0;
    Clusters = 0;
    pClusterArray = NULL;

    InitFragColorThreshold();

    CLASSINVARIANT();
}

DiskView::DiskView(const int InClusters, 
                   const int InMftZoneStart = 0, 
                   const int InMftZoneEnd = 0)
{
    require(InClusters > 0);

    ::InitializeCriticalSection(&m_CriticalSection);

    // data we need from UI
    NumLines = 0;
    ClusterFactor = 0;
    pLineArray = NULL;

    // control variables
    m_bIsDataSent = FALSE;
    m_IsActive = FALSE;
    m_FragColorThreshold = FRAGTHRESHDEFAULT;
    m_bMemAllocFailed = FALSE;

    // init basic variables.
    MftZoneStart = InMftZoneStart;
    MftZoneEnd = InMftZoneEnd;
    Clusters = InClusters;

    // cluster map
    ClusterArraySize = Clusters / 2 + Clusters % 2;     // one cluster per nibble
#if ANALYZE_MEM_FAIL    // TEMP TEMP
    pClusterArray = new char [ClusterArraySize * 10000];
#else
    pClusterArray = new char [ClusterArraySize];
#endif
    EH(pClusterArray);

    // fill the array initially with free space.
    if (pClusterArray) {
        FillMemory(pClusterArray, ClusterArraySize, (FreeSpaceColor << 4) | FreeSpaceColor);
    }
    else {
        // new failed, keep class consistent
        m_bMemAllocFailed = TRUE;
        Clusters = 0;
        ClusterArraySize = 0;
    }

    InitFragColorThreshold();

    CLASSINVARIANT();
}

/*

METHOD: DiskView::InitFragColorThreshold

DESCRIPTION:
    Get the threshold percentage of fragmented clusters that it takes to cause 
    a line to display in the fragmented color.  If it is not in the registry at 
    all then we don't set it.  Otherwise it will be defaulted by the constructor.

*/

void DiskView::InitFragColorThreshold()
{
    // get frag color threshold percent from registry
    TCHAR cRegValue[100];
    HKEY hValue = NULL;
    DWORD dwRegValueSize = sizeof(cRegValue);

    // get the free space error threshold from the registry
    long ret = GetRegValue(
        &hValue,
        TEXT("SOFTWARE\\Microsoft\\Dfrg"),
        TEXT("FragColorThreshold"),
        cRegValue,
        &dwRegValueSize);

    RegCloseKey(hValue);

    // convert it and apply range limits
    if (ret == ERROR_SUCCESS) {
        m_FragColorThreshold = (UINT) _ttoi(cRegValue);

        // > 50 does not make sense!
        if (m_FragColorThreshold > 50)
            m_FragColorThreshold = 50;

        // < 0 does not either!
        if (m_FragColorThreshold < 1)
            m_FragColorThreshold = 0;
    }
}

/*

METHOD: DiskView::DiskView (Copy Contructor)

DESCRIPTION:
    Copies a DiskView class.

RETURN:
    New Class reference.
*/

DiskView::DiskView(const DiskView& InDiskView)
{
    EH_ASSERT(InDiskView.Invariant());
    require(InDiskView.HasMapMemory());

    ::InitializeCriticalSection(&m_CriticalSection);

    // copy over some basic variables from the input DiskView.
    Clusters = InDiskView.Clusters;
    ClusterArraySize = Clusters / 2 + Clusters % 2;     // one cluster per nibble
    NumLines = InDiskView.NumLines;
    if (NumLines > 0)
        ClusterFactor = (Clusters / NumLines) + ((Clusters % NumLines) ? 1 : 0);
    else
        ClusterFactor = 0;
    EH_ASSERT(ClusterFactor == InDiskView.ClusterFactor);

    MftZoneEnd = InDiskView.MftZoneEnd;
    MftZoneStart = InDiskView.MftZoneStart;
    m_bIsDataSent = FALSE;
    m_bMemAllocFailed = FALSE;
    m_IsActive = InDiskView.m_IsActive;
    m_FragColorThreshold = InDiskView.m_FragColorThreshold;

    // cluster map
#if DEFRAG_MEM_FAIL // TEMP TEMP
    pClusterArray = new char [ClusterArraySize * 10000];
#else
    pClusterArray = new char [ClusterArraySize];
#endif
    EH(pClusterArray);

    // copy over the cluster array.
    if (pClusterArray) {
        CopyMemory(pClusterArray, InDiskView.pClusterArray, ClusterArraySize);
    }
    else {
        // new failed, keep class consistent
        m_bMemAllocFailed = TRUE;
        Clusters = 0;
        ClusterArraySize = 0;
    }

    // line array
    if (NumLines > 0) {
        pLineArray = new char [NumLines];
        EH(pLineArray);
        if (pLineArray) {
            FillMemory(pLineArray, NumLines, DirtyColor);
        }
        else {
            // new failed, keep class consistent
            m_bMemAllocFailed = TRUE;
            NumLines = 0;
        }
    }
    else {
        pLineArray = NULL;
    }

    CLASSINVARIANT();
}

/*

METHOD: DiskView::operator= (Assignment Operator)

DESCRIPTION:
    Makes the Lvalue a duplicate of the Rvalue.

*/

DiskView& DiskView::operator=(const DiskView& InDiskView)
{
    // check for assignment to self
    if (this == &InDiskView) {
        return *this;
    }

    EH_ASSERT(InDiskView.Invariant());
    require(InDiskView.HasMapMemory());

    __try
    {

        ::EnterCriticalSection(&m_CriticalSection);

        // copy over some basic variables from the input DiskView.
        MftZoneEnd = InDiskView.MftZoneEnd;
        MftZoneStart = InDiskView.MftZoneStart;
        m_bIsDataSent = FALSE;
        m_bMemAllocFailed = FALSE;
        m_IsActive = InDiskView.m_IsActive;
        m_FragColorThreshold = InDiskView.m_FragColorThreshold;

        // if the number of clusters in the cluster array are not identical, realloc the array.
        if (Clusters != InDiskView.Clusters) {

            // get the new size for the cluster array.
            Clusters = InDiskView.Clusters;
            ClusterArraySize = Clusters / 2 + Clusters % 2;     // one cluster per nibble

            // redimension the cluster array.
            if (pClusterArray)
                delete [] pClusterArray;
    #if DEFRAG_MEM_FAIL // TEMP TEMP
            pClusterArray = new char [ClusterArraySize * 10000];
    #else
            pClusterArray = new char [ClusterArraySize];
    #endif
            EH(pClusterArray);
        }

        // copy over the cluster array.
        if (pClusterArray) {
            CopyMemory(pClusterArray, InDiskView.pClusterArray, ClusterArraySize);
        }
        else {
            // new failed, keep class consistent
            m_bMemAllocFailed = TRUE;
            Clusters = 0;
            ClusterArraySize = 0;
        }

        // line array
        NumLines = InDiskView.NumLines;
        if (NumLines > 0)
            ClusterFactor = (Clusters / NumLines) + ((Clusters % NumLines) ? 1 : 0);
        else
            ClusterFactor = 0;

        if (NumLines > 0) {
            pLineArray = new char [NumLines];
            EH(pLineArray);
            if (pLineArray) {
                FillMemory(pLineArray, NumLines, DirtyColor);
            }
            else {
                // new failed, keep class consistent
                m_bMemAllocFailed = TRUE;
                NumLines = 0;
            }
        }
        else {
            pLineArray = NULL;
        }

        CLASSINVARIANT();
    }
    __finally
    {
        ::LeaveCriticalSection(&m_CriticalSection);
    }

    return *this;
}

/*

METHOD: DiskView::~DiskView (Destructor)

*/

DiskView::~DiskView()
{
    CLASSINVARIANT();

    ::DeleteCriticalSection(&m_CriticalSection);

    if (pClusterArray)
        delete [] pClusterArray;

    if (pLineArray)
        delete [] pLineArray;
}

/**********************************************************************************

Implementation

**********************************************************************************/

void DiskView::SetClusterCount(const int InClusters)
{
    require(InClusters > 0);

    __try
    {
        
        ::EnterCriticalSection(&m_CriticalSection);

        m_IsActive = TRUE;

        Clusters = InClusters;

        // cluster map
        ClusterArraySize = Clusters / 2 + Clusters % 2;     // one cluster per nibble
    #if ANALYZE_MEM_FAIL    // TEMP TEMP
        pClusterArray = new char [ClusterArraySize * 10000];
    #else
        pClusterArray = new char [ClusterArraySize];
    #endif
        EH(pClusterArray);

        // fill the array initially with free space.
        if (pClusterArray) {
            FillMemory(pClusterArray, ClusterArraySize, (FreeSpaceColor << 4) | FreeSpaceColor);
        }
        else {
            // new failed, keep class consistent
            m_bMemAllocFailed = TRUE;
            Clusters = 0;
            ClusterArraySize = 0;
        }

        CLASSINVARIANT();
    }
    __finally
    {
        ::LeaveCriticalSection(&m_CriticalSection);
    }
}

void DiskView::SetMftZone(const int InZoneStart, const int InZoneEnd)
{
    require(InZoneEnd >= InZoneStart);

    __try
    {
        ::EnterCriticalSection(&m_CriticalSection);

        MftZoneStart = InZoneStart;
        MftZoneEnd = InZoneEnd;

        CLASSINVARIANT();
    }
    __finally
    {
        ::LeaveCriticalSection(&m_CriticalSection);
    }
}

/*

METHOD: DiskView::SetNumLines

DESCRIPTION:
    Called to update the number of lines (pixels) that are displayed on the UI

*/

void DiskView::SetNumLines(const int inNumLines)
{
    if (NumLines != inNumLines && inNumLines > 0 && pClusterArray != NULL) {

        __try
        {

            ::EnterCriticalSection(&m_CriticalSection);

            CLASSINVARIANT();

            NumLines = inNumLines;

            ClusterFactor = (Clusters / NumLines) + ((Clusters % NumLines) ? 1 : 0);
            
            EH(ClusterFactor > 0);
            
            if (pLineArray)
                delete [] pLineArray;

            pLineArray = new char [NumLines];
            EH(pLineArray);

            if (pLineArray) {
                FillMemory(pLineArray, NumLines, DirtyColor);
            }
            else {
                // new failed, keep class consistent
                m_bMemAllocFailed = TRUE;
                NumLines = 0;
            }

            CLASSINVARIANT();
        }

        __finally
        {
            ::LeaveCriticalSection(&m_CriticalSection);
        }

    }
}

/*

METHOD: DiskView::GetLineArray

DESCRIPTION:
    Makes LineArray available outside of the class so it can be passed to DiskDisplay.

*/

BOOL DiskView::GetLineArray(char ** ppOutLineArray, DWORD *pNumLines)
{
    BOOL bReturn = TRUE;
    // initialize outputs
    *ppOutLineArray = NULL;
    *pNumLines = 0;

    if (!m_IsActive || pClusterArray == NULL){
        bReturn = FALSE;

    } else
    {
        // see if we have a line array
        if (pLineArray != NULL && NumLines > 0) {

            __try
            {
                ::EnterCriticalSection(&m_CriticalSection);

                CLASSINVARIANT();

                // update the line array from the cluster array
                TransferToLineArray();

                // allocate space for a copy of the line array
                *ppOutLineArray = new char[NumLines];

                // if we got memory, set the outputs
                if (*ppOutLineArray) {
                    CopyMemory(*ppOutLineArray, pLineArray, NumLines);
                    *pNumLines = (DWORD) NumLines;
                }

                m_bIsDataSent = TRUE;
            
            }
            __finally
            {
                ::LeaveCriticalSection(&m_CriticalSection);
                bReturn = TRUE;
            }
        }
        else {
            bReturn = FALSE;
        }
    }
    return bReturn;
}

/*

METHOD: DiskView::UpdateClusterArray

DESCRIPTION:
    Updates portions of the cluster array from extent data about the disk.  (An extent 
    is a series of adjacent clusters that are part of the same file -- or sometimes in 
    our program, part of no file.)  The extents are passed in as a series of EXTENT_LIST 
    structures with a LONGLONG header.  The first 7 bytes of the LONGLONG contain the 
    number of EXTENT_LIST structures following, the last byte of the LONGLONG contains 
    the color code of the extents (meaning a series of extents all represent the same 
    type of data: contiguous files, fragmented files, etc.)  After the last EXTENT_LIST 
    structure, there may be another LONGLONG identifying that there is another series of 
    EXTENT_LIST's.  Eventually there will be a zeroed out LONGLONG indicating there is 
    no more data.  UpdateClusterArray goes through each of these extents and updates the 
    appropriate clusters in ClusterArray.  It then re-evaluates those specific lines in 
    the LineArray that would be affected by the changes in ClusterArray.

INPUT + OUTPUT:
    pBuffer - The buffer holding the EXTENT_LIST's and their LONGLONG headers.

*/

void DiskView::UpdateClusterArray(PBYTE pBuffer)
{
    LONGLONG StartingLcn;
    BYTE Color;
    int ClusterCount;
    EXTENT_LIST* pUpdateArray;
    LONGLONG Extents = 0;
    LONGLONG Extent = 0;
    int TotalRunLength = 0;
    BYTE * pTempBuffer = pBuffer;

    if (!m_IsActive || pClusterArray == NULL){
        return;
    }

    __try
    {

        ::EnterCriticalSection(&m_CriticalSection);

        CLASSINVARIANT();

        //Indefinite length loop that goes through all the series of EXTENT_LIST's 
        //until there are no more.
        while(TRUE){
            
            //Get the number of extents.
            Extents = *(LONGLONG*)pBuffer & 0x0FFFFFFFFFFF;
            if(Extents == 0){
                break;
            }
            //Point to the EXTENT_LIST's.
            pBuffer += sizeof(LONGLONG);

            //Get the color code.
            Color = pBuffer[-1];

            //Get a movable pointer to the EXTENT_LIST's
            pUpdateArray = (EXTENT_LIST*)pBuffer;

            //Set the high nibble to have the same color code as the low nibble of color.
            //Color = (Low nibble) | (High nibble which is low nibble shifted)
            Color = (Color & 0x0F) | (Color << 4);

            //Go through each extent and 
            //update the ClusterArray and LineArray for that extent.
            for(Extent = 0; Extent < Extents; pUpdateArray ++, Extent ++) {

                //Get the data for this extent and validate it is correct 
                //(doesn't run of the end of the disk)
                StartingLcn = pUpdateArray->StartingLcn;
                ClusterCount = (UINT)pUpdateArray->ClusterCount;
                if ((StartingLcn < 0) || (ClusterCount <= 0) || 
                    (StartingLcn + ClusterCount > Clusters)) {
                    __leave;
                }

                if (pLineArray != NULL && NumLines > 0) {
                    // mark the affected lines in the line array dirty
                    UINT nStartLine = (UINT) (StartingLcn / ClusterFactor);
                    UINT nEndLine = (UINT) ((StartingLcn + ClusterCount - 1) / ClusterFactor);

                    for (UINT ii = nStartLine; ii <= nEndLine; ii++) {
                        //sks bug#206244
                        if(ii >= (UINT) NumLines)
                        {
                            __leave;
                        }
                        pLineArray[ii] = DirtyColor;
                    }
                }

                //Set the ClusterArray nibbles to the appropriate color for this extent.
                //If the extent starts on an odd number, 
                //then the first cluster is a high nibble of one byte.
                if(StartingLcn % 2){
                    //Clear out that high nibble.
                    pClusterArray[StartingLcn / 2] &= 0x0F;
                    //Put our color in it.
                    pClusterArray[StartingLcn / 2] |= (Color & 0xF0);
                    //Change the counters to reflect that we wrote this cluster.
                    ClusterCount --;
                    StartingLcn ++;
                }
                //Fill in the middle range that consists of whole bytes 
                //(high and low nibbles) needing to be set.
                if(ClusterCount != 0){
                    FillMemory(pClusterArray + (StartingLcn / 2), ClusterCount / 2, Color);
                }
                //If the extent ends on an odd number, 
                //then the last cluster is a low nibble of one byte.
                if ((ClusterCount % 2) && (ClusterCount != 0)) {
                    //Update counter to point to it after previous writes.
                    StartingLcn += ClusterCount - 1;
                    //Clear out that low nibble.
                    pClusterArray[StartingLcn / 2] &= 0xF0;
                    //Put our color in it.
                    pClusterArray[StartingLcn / 2] |= (Color & 0x0F);
                }

            }
            //Point to the next series of extents (since the for loop we just exited exits 
            //when all the extents in that series have been done).
            pBuffer = (PBYTE)pUpdateArray;
        }
    }

    __finally
    {
        ::LeaveCriticalSection(&m_CriticalSection);
    }
}

/*

METHOD: DiskView::TransferToLineArray

DESCRIPTION:
    Create the compressed line array from the current data in the cluster array.

RETURN:
    TRUE=ok, FALSE=error.
*/

BOOL DiskView::TransferToLineArray()
{
    // make sure we have the arrays
    if (!m_IsActive || pClusterArray == NULL || pLineArray == NULL) {
        return FALSE;
    }

    EF_ASSERT(ClusterFactor > 0);
    EF_ASSERT(NumLines > 0);

    __try
    {

        ::EnterCriticalSection(&m_CriticalSection);

        CLASSINVARIANT();

        // loop variables
        int nClust;             // nClust = cluster number
        int nClustByte;         // nClustByte = byte in cluster array 
                                // (nClust / 2, bytes to nibbles)
        BOOL bHighNibble;       // bHighNibble = TRUE for high nibble and FALSE for low nibble
                                // (stored one cluster per nibble)
        int nLine;              // nLine = line number
        char cClustColor;       // current cluster's color
        UINT nUsed;             // number of used clusters in this line
        UINT nFree;             // number of free clusters in this line
        UINT nFrag;             // fragmented cluster(s) in this line
        UINT nNonMovable;       // number of non movable clusters in this line 
        BOOL bNonMovable;       // system file cluster(s) in this line
        BOOL bMftFragmented;    // MFT in this line sks added MFT defrag
        BOOL bMftUnFragmented;  // MFT in this line sks added MFT defrag

        // loop through line array
        for (nLine = 0; nLine < NumLines; nLine++) {

            // if this item is not dirty, move on
            if (pLineArray[nLine] != DirtyColor) {
                continue;
            }

            // initialize line variables
            nUsed = 0;
            nFree = 0;
            nFrag = 0;
            nNonMovable = 0;        //bug#184739 sks 9/18/2000
            bNonMovable = FALSE;
            bMftFragmented = FALSE;
            bMftUnFragmented = FALSE;

            // reset to the starting point for this line
            nClust = nLine * ClusterFactor; 

            // loop through the clusters in this line
            for (int ii = 0; ii < ClusterFactor && nClust < Clusters; ii++, nClust++) {

                // set loop variables
                nClustByte = nClust / 2;                            // cluster array byte index
                bHighNibble = (nClust % 2) ? TRUE : FALSE;          // which nibble in byte?

                // get the current cluster's color
                // (the >> 4 extracts the high nibble, the & 0x0F extracts the low nibble)
                if(bHighNibble) {
                    cClustColor = pClusterArray[nClustByte] >> 4;
                }
                else {
                    cClustColor = pClusterArray[nClustByte] & 0x0F;
                }

                // evaluate the color
                switch (cClustColor) {

                    
                case SystemFileColor:
                case PageFileColor:
                    nNonMovable++;              //bug#184739 sks 9/18/2000
                    break;

                case FragmentColor:
                    nFrag++;
                    break;

                case UsedSpaceColor:
                case DirectoryColor:
                    nUsed++;
                    break;

                case FreeSpaceColor:
                    nFree++;
                    break;

                default:
                    __leave;
                    break;
                }

                //bug#184739 sks 9/18/2000
                // system file overrides all, break out of inner loop

            }           // end inner loop: clusters in current line


            //
            // #243245 changing the color scheme as follows
            //
            // Add the current file counts for each type to our running
            // total.  Think of this running total as "the file-counts of each
            // type that were ignored in the previous lines displayed."
            //
            // For each line, then test which running total is more:
            //  contiguous, unmovable, fragmented files or free space.  
            //
            // Whoever is greater wins, (if all are equal, fragmented wins)
            // Subtract the ClusterFactor from the running count for the 
            // winner (since this line is his)
            //
            m_nFreeDelta += nFree;
            m_nFragDelta += nFrag;
            m_nNonMovableDelta += nNonMovable;
            m_nUsedDelta += nUsed;

            if((m_nFragDelta > m_nNonMovableDelta) && 
                (m_nFragDelta > m_nFreeDelta) && 
                (m_nFragDelta > m_nUsedDelta)
                ) {
                // 
                // Fragmented is greatest
                //
                m_nFragDelta -= ClusterFactor;
                pLineArray[nLine] = FragmentColor;
            } 
            else if ((m_nUsedDelta > m_nFreeDelta) && 
                (m_nUsedDelta > m_nNonMovableDelta) && 
                (m_nUsedDelta > m_nFragDelta)
                ) {
                // 
                // Used is greatest
                //
                m_nUsedDelta -= ClusterFactor;
                pLineArray[nLine] = UsedSpaceColor;
            }
            else if ((m_nFreeDelta > m_nUsedDelta) && 
                (m_nFreeDelta > m_nNonMovableDelta) && 
                (m_nFreeDelta > m_nFragDelta)
                ) {
                // 
                // Free is greatest
                //
                m_nFreeDelta -= ClusterFactor;
                pLineArray[nLine] = FreeSpaceColor;
            } 
            else if ((m_nNonMovableDelta > m_nUsedDelta) && 
                (m_nNonMovableDelta > m_nFreeDelta) && 
                (m_nNonMovableDelta > m_nFragDelta)
                ) {
                // 
                // Nonmovable is greatest
                //
                m_nNonMovableDelta -= ClusterFactor;
                pLineArray[nLine] = SystemFileColor;
            } 
            else {
                // 
                // They're all equal--use Fragmented colour
                //
                m_nFragDelta -= ClusterFactor;
                pLineArray[nLine] = FragmentColor;
            }
        }               // end outer loop: lines
    }

    __finally
    {
        ::LeaveCriticalSection(&m_CriticalSection);
    }

    return TRUE;
}

/*

METHOD: DiskView::Invariant

DESCRIPTION:
    Check the internal state of a DiskView instance.

*/

BOOL DiskView::Invariant() const
{
    // clusters
    EF((pClusterArray == NULL && Clusters == 0) || 
       (pClusterArray != NULL && Clusters > 0));
    EF(ClusterArraySize == Clusters / 2 + Clusters % 2);    // one cluster per nibble

    // lines
    EF((pLineArray == NULL && NumLines == 0) || 
       (pLineArray != NULL && NumLines > 0));
    EF((NumLines == 0 && ClusterFactor == 0) || 
       (NumLines > 0 && ClusterFactor > 0));

    // MFT zone
    EF(MftZoneEnd >= MftZoneStart);

    return TRUE;
}

/*

METHOD: DiskView::HasMapMemory

DESCRIPTION:
    Check if the DiskView has memory for the cluster array 
    (and line array if applicable).

*/

BOOL DiskView::HasMapMemory() const
{
    return !m_bMemAllocFailed;
}

/*

METHOD: DiskView::EnterMyCriticalSection()

DESCRIPTION:
    Enter the critical section, so that when we terminate thread was have the critical section
    bug #26213 sks .

*/
void DiskView::EnterMyCriticalSection()
{
    ::EnterCriticalSection(&m_CriticalSection);
}

/*

METHOD: DiskView::LeaveMyCriticalSection()

DESCRIPTION:
    Leave the critical section, so that when we terminate thread was have the critical section
    bug #26213 sks .

*/
void DiskView::LeaveMyCriticalSection()
{
    ::LeaveCriticalSection(&m_CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgntfs.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

USE_MSVCRT=1
TARGETNAME=DfrgNtfs
TARGETPATH=obj
TARGETTYPE=PROGRAM
USE_ATL=1

INCLUDES=..\Inc

!ifdef TEST
TESTDEFINE= -DTest -DPauseAtEnd
!endif

!ifdef VISIBLEWINDOW
!ifndef TEST
VISIBLEWINDOWDEFINE= -DVisibleWindow
!endif
!endif

!ifdef ERRORSACTIVE
ERRORDEFINE= -DErrorsActive
!endif

!ifdef LOGGING
LOGDEFINE= -DLogging
!endif


C_DEFINES= -DNOTIMER -DWIN32 -DUNICODE -D_UNICODE -DENGINE -DNOEVTLOG -DDFRGNTFS -DDFRG -DDKMS $(TESTDEFINE) $(VISIBLEWINDOWDEFINE) $(ERRORDEFINE) $(LOGDEFINE)
WIN32_WINNT_VERSION=0x0500

LINKER_STACKSIZE=/STACK:1048576,12288

MISCFILES=..\dfrg.reg    \
          ..\install.bat
	  
PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_CXX=1

SOURCES=..\Alloc.cpp     \
        BootOptimizeNtfs.cpp \
        ..\DasdRead.cpp  \
        ..\DataIo.cpp    \
        ..\DataIoCl.cpp  \
	..\defragcommon.cpp \
        ..\DevIo.cpp     \
        ..\DiskView.cpp  \
        DfrgNtfs.cpp  \
	..\DfrgNtfs.rc   \
        ..\ErrLog.cpp    \
        ..\ErrMsg.cpp    \
        ..\Error.cpp     \
        ..\Exclude.cpp   \
        ..\Expand.cpp    \
        ..\Extents.cpp   \
        ..\FraggedFileList.cpp   \
        ..\FreeSpace.cpp  \
        ..\FsSubs.cpp    \
        ..\GetDfrgRes.cpp    \
        ..\GetReg.cpp    \
        ..\GetTime.cpp   \
        ..\Graphix.cpp   \
        ..\IntFuncs.cpp  \
        ..\LoadFile.cpp  \
        ..\LogFile.cpp   \
        ..\Logging.cpp   \
	..\MFTDefrag.cpp \
        ..\MoveFile.cpp  \
        ..\NtfsSubs.cpp  \
        ..\Priority.c \
        ..\SecAttr.cpp \
        ..\TextBlock.cpp  \
        ..\UiCommon.cpp \
	..\vDebugGlobal.cpp \
	..\vWindowAppCore.cpp 

UMENTRY=winmain
UMTYPE=windows
TARGETLIBS=$(SDK_LIB_PATH)\ntdll.lib	\
	   $(SDK_LIB_PATH)\comctl32.lib \
	   $(SDK_LIB_PATH)\shell32.lib  \
	   $(SDK_LIB_PATH)\ole32.lib	\
	   $(SDK_LIB_PATH)\uuid.lib     \
	   $(SDK_LIB_PATH)\vssapi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\errlog.cpp ===
/**************************************************************************************************

FILENAME: ErrLog.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"

#ifdef BOOTIME
    extern "C"{
        #include <stdio.h>
    }
        #include "Offline.h"
#else
    #ifndef NOWINDOWSH
        #include <windows.h>
    #endif
#endif

#include "ErrLog.h"
#include "secattr.h"

static HANDLE hErrLogMutex = NULL;
static TCHAR cErrLogName[200];
static BOOL bErrLogEnabled = FALSE;
static TCHAR cLoggerIdentifier[256];

#define ERRLOG_MUTEX_NAME "Dfrg Error Log"

/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine is called to enable the Error Log.

GLOBALS:
    hErrLogMutex : Mutex to sychronize write access to the Error Log.
    cErrLogName : Where the name of the error log is stored.
    bErrLogEnabled : Boolean to indicate whether the error log has been initialized.

INPUT:
    pErrLogName - String containing full path/file name of log file.
    pLoggerIdentifier - String containing on identification of who is doing this logging.

RETURN:
    TRUE - Success
    FALSE - Failure (indicates that the error log could not be created)

*/
BOOL
InitializeErrorLog (
    IN PTCHAR   pErrLogName,
    IN PTCHAR   pLoggerIdentifier
    )
{
    HANDLE hErrLog = NULL;            // Handle to the Error Log.
    BOOL bRetStatus = TRUE;
    OVERLAPPED  LogOverLap;
    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;

    ZeroMemory(&LogOverLap, sizeof(OVERLAPPED));
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

    // Check if a mutex has been created to synchronize writing to the Log file
    if (NULL == hErrLogMutex) {
        hErrLogMutex = CreateMutex(NULL, FALSE, TEXT(ERRLOG_MUTEX_NAME));
    }

    if (NULL == hErrLogMutex) {
        return FALSE;
    }

    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = FALSE;

    if (!ConstructSecurityAttributes(&saSecurityAttributes, esatFile, FALSE)) {
        return FALSE;
    }

    // Make sure that we can Create/Open the Log file
    hErrLog = CreateFile(pErrLogName, 
        GENERIC_READ|GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        &saSecurityAttributes,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    CleanupSecurityAttributes(&saSecurityAttributes);
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
    
    if (INVALID_HANDLE_VALUE == hErrLog) {
        return FALSE;
    }

    // On success, set up the overlay option so we known the offset to
    // the end of the file, so when we write, we append to the end of the file.
    LogOverLap.Offset = GetFileSize(hErrLog, &LogOverLap.OffsetHigh);
    LogOverLap.hEvent = NULL;

    //If the log file is greater than 64K in size, we want to keep that last 64K and nuke everything before it.
    //This keeps the log file from becoming too much larger than 64K,
    //and it guarantees that we have all the errors in the last pass (which may be more than 64K, but the file won't be shrunk until another instance is run.)
    if(LogOverLap.Offset > 0x10000) {
        HANDLE hBuffer = NULL;
        char* pBuffer = NULL;
        DWORD dwRead = 0;
        DWORD dwWritten = 0;

        //Allocate a 64K to hold the last 64K of the file.
        if(!(hBuffer = GlobalAlloc(GHND, 0x10000))){
            bRetStatus = FALSE;
        }
        if(!(pBuffer = (char*)GlobalLock(hBuffer))){
            bRetStatus = FALSE;
        }

        if (bRetStatus) {
            //Read the last 64K
            LogOverLap.Offset -= 0x10000;
            if(!ReadFile(hErrLog, pBuffer, 0x10000, &dwRead, &LogOverLap)){
                bRetStatus = FALSE;
            }

            //We want to create the file again in order to truncate it.
            CloseHandle(hErrLog);

            saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
            saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
            saSecurityAttributes.bInheritHandle       = FALSE;

            if (!ConstructSecurityAttributes(&saSecurityAttributes, esatFile, FALSE)) {
                bRetStatus = FALSE;
            }
            else {

                //This will truncate the file as well as open it.
                hErrLog = CreateFile(pErrLogName,
                    GENERIC_READ|GENERIC_WRITE,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    &saSecurityAttributes,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

                CleanupSecurityAttributes(&saSecurityAttributes);
                ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

                if (INVALID_HANDLE_VALUE == hErrLog) {
                    // On failure, indicate it in return status
                    bRetStatus = FALSE;
                }
                else {
                    if(!WriteFile(hErrLog, pBuffer, dwRead, &dwWritten, NULL)){
                        bRetStatus = FALSE;
                    }
                }
            }
        }

        if (hBuffer) {
            GlobalUnlock(hBuffer);
            GlobalFree(hBuffer);
        }
    }

    if (bRetStatus) {
        // On success, close file, save a global copy of the filename, and set flag to indicate the Error Log is enabled
        CloseHandle(hErrLog);
        lstrcpy(cErrLogName, pErrLogName);
        lstrcpy(cLoggerIdentifier, pLoggerIdentifier);
        bErrLogEnabled = TRUE;
    }

    return bRetStatus;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Write the error to the error file. Since this routine may be called from different
    processes, a Mutex is used to synchronize write access to the log file. Also, the file is 
    Opened and Closed for each write. This is done so that each write gets the correct offset
    to the end of the file to append the new message data.

GLOBAL VARIABLES:
    hErrLogMutex : Mutex to sychronize write access to the Error Log.
    cErrLogName : Where the name of the error log is stored.
    bErrLogEnabled : Boolean to indicate whether the error log has been initialized.

INPUT:
    IN LPTSTR szMessage - message string.
    IN HRESULT hr - [Optional] error number. (-1 indicates No valid hr to format)
    IN LPTSTR szParameter1 - [Optional] Parameter String, NULL if not present

RETURN:
    None.

*/
void
WriteErrorToErrorLog(
    IN LPTSTR pMessage,
    IN HRESULT  hr,
    IN LPTSTR pParameter1
    )
{
    //If the error log isn't enabled, don't write to it.
    if (!bErrLogEnabled) {
        return;
    }

    static TCHAR szError[128];
    static TCHAR szTemp[32];
    static BOOL bFirstError = TRUE;
    
    HANDLE      hErrLog=NULL;            // Handle to the Error Log.
    OVERLAPPED  LogOverLap;
    DWORD       dwMsgLength;
    DWORD       dwNumBytesWritten;

    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;

    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
    
    //If this is the first time this routine was called, then put in a message identifying that a new logger is present.
    if(bFirstError){
        bFirstError = FALSE;
        WriteErrorToErrorLog(TEXT("INITIALIZE A NEW LOGGER---------------------------------------------------------------------------------"),
            -1,
            cLoggerIdentifier);
    }

    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = FALSE;

    if (!ConstructSecurityAttributes(&saSecurityAttributes, esatFile, FALSE)) {
        return;
    }

    // Before writing the entry to the log file, we have to
    // 1 Get Mutex to synchronize writing to the Log file
    // 2 Create/Open the FR Log file
    // If euther fail, then just return without writing to the log file.
    if ( (WaitForSingleObject(hErrLogMutex, 30000) != WAIT_FAILED) &&
         ((hErrLog = CreateFile(cErrLogName, 
                                 GENERIC_READ|GENERIC_WRITE,
                                 FILE_SHARE_READ|FILE_SHARE_WRITE,
                                 &saSecurityAttributes,
                                 OPEN_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL)) != INVALID_HANDLE_VALUE) ) {
                                 
    
        // On success, set up the overlay option so we known the offset to
        // the end of the file, so when we write, we append to the end of the file.
        LogOverLap.Offset = GetFileSize(hErrLog, &LogOverLap.OffsetHigh);
        LogOverLap.hEvent = NULL;

        // Get the current date
        GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                      DATE_SHORTDATE,
                      NULL,
                      NULL,
                      szError,
                      sizeof(szError)/sizeof(TCHAR));

        // Get the current local time
        GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                      TIME_FORCE24HOURFORMAT,
                      NULL,
                      TEXT(" HH':'mm':'ss"),
                      szTemp,
                      sizeof(szTemp)/sizeof(TCHAR));

        // 1) Write out 1st part of message = Date stamp, Time stamp & Thread Id
        //
        // Format message
        wcsncat(szError, szTemp, (sizeof(szError)/sizeof(WCHAR) - lstrlen(szError) - 1));
        szError[sizeof(szError)/sizeof(WCHAR) - 1] = TEXT('\0');

        wsprintf(szTemp, TEXT(" Thread# = %04lx\r\n    Message   :"), GetCurrentThreadId());
        wcsncat(szError, szTemp, (sizeof(szError)/sizeof(WCHAR) - lstrlen(szError) - 1));
        szError[sizeof(szError)/sizeof(WCHAR) - 1] = TEXT('\0');

        dwMsgLength = lstrlen(szError) * sizeof(TCHAR);
        //
        // Write data out to file
        WriteFile(hErrLog, szError, dwMsgLength, &dwNumBytesWritten, &LogOverLap);
        //
        // Update the offset to end of file
        LogOverLap.Offset += dwMsgLength;

        if (pMessage) {
            // 2) Write out next part of message = the Message String
            dwMsgLength = lstrlen(pMessage) * sizeof(TCHAR);
            WriteFile(hErrLog, pMessage, dwMsgLength, &dwNumBytesWritten, &LogOverLap);
            LogOverLap.Offset += dwMsgLength;
        }

        // If a valid error status 'hr' was passed in, then format a message out of it
        // A valid status is any number other than -1
        if (hr != -1) {
            if (HRESULT_FACILITY(hr) == FACILITY_WINDOWS) {
                hr = HRESULT_CODE(hr);
            }

            if((dwMsgLength = FormatMessage(/*FORMAT_MESSAGE_ALLOCATE_BUFFER | */FORMAT_MESSAGE_FROM_SYSTEM,
                                       NULL,
                                       hr,
                                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
                                       (LPTSTR)&szError,
                                       sizeof(szError)/sizeof(TCHAR),
                                       NULL)) == 0) {

                GetLastError();
                CleanupSecurityAttributes(&saSecurityAttributes);
                return;
            }
            // Remove the line feed at the end of the error string.
            szError[dwMsgLength - 2] = 0;

            //Append the error number.
            wsprintf(szTemp, TEXT("%d"), hr);
            lstrcat(szError, TEXT(" - Error #"));
            lstrcat(szError, szTemp);
        }
        else {

            // A valid error status was not passed in, so set error message to a Null message
            szError[0] = NULL;
        }
        // 3) Write out next part of message = the Status String
        wcscpy(szTemp, TEXT("\r\n    Status    : "));
        dwMsgLength = lstrlen(szTemp) * sizeof(TCHAR);
        WriteFile(hErrLog, szTemp, dwMsgLength, &dwNumBytesWritten, &LogOverLap);
        LogOverLap.Offset += dwMsgLength;

        dwMsgLength = lstrlen(szError) * sizeof(TCHAR);
        WriteFile(hErrLog, szError, dwMsgLength, &dwNumBytesWritten, &LogOverLap);
        LogOverLap.Offset += dwMsgLength;

        // 4) Write out next part of message = the Parameter String
        if(pParameter1 != NULL) {
            wcscpy(szTemp, TEXT("\r\n    Parameter : "));
            dwMsgLength = lstrlen(szTemp) * sizeof(TCHAR);
            WriteFile(hErrLog, szTemp, dwMsgLength, &dwNumBytesWritten, &LogOverLap);
            LogOverLap.Offset += dwMsgLength;

            dwMsgLength = lstrlen(pParameter1) * sizeof(TCHAR);
            WriteFile(hErrLog, pParameter1, dwMsgLength, &dwNumBytesWritten, &LogOverLap);
            LogOverLap.Offset += dwMsgLength;

        }
        
        wcscpy(szTemp, TEXT("\r\n"));
        dwMsgLength = lstrlen(szTemp) * sizeof(TCHAR);
        WriteFile(hErrLog, szTemp, dwMsgLength, &dwNumBytesWritten, &LogOverLap);
        LogOverLap.Offset += dwMsgLength;
        
        // Close the handle to the file & release the log file mutex
        CloseHandle(hErrLog);
        ReleaseMutex(hErrLogMutex);
    }    
    
    CleanupSecurityAttributes(&saSecurityAttributes);
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
    
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine is called to disable the Error Log.

GLOBALS:
    bErrLogEnabled : Boolean to indicate whether the error log has been initialized.

INPUT:
    None

RETURN:
    None

*/
void
ExitErrorLog (
    )
{
    bErrLogEnabled = FALSE;

    if(hErrLogMutex){
        CloseHandle(hErrLogMutex);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\error.cpp ===
/*****************************************************************************************************************

  File Name: Error.cpp

  COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"
#include <windows.h>
#include "Message.h"
#include "ErrLog.h"

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Perform the logging functions of the ErrMacro macros.

USAGE:
    LogErrMacro(TEXT(__FILE__), TEXT(__TIMESTAMP__), __LINE__);
*/

void LogErrForMacro(LPTSTR filename, LPTSTR timestamp, UINT lineno)
{
    DWORD hr = GetLastError();

    TCHAR cErrorLocation[2 * MAX_PATH];
    TCHAR cCompileTime[2 * 128];

    // prepare logging messages
    wsprintf(cErrorLocation, TEXT( "Error in file %s line %d"), filename, lineno);
    wsprintf(cCompileTime, TEXT( "Compiled %s"), timestamp);

    // log to message window
    Message(cErrorLocation, hr, cCompileTime);

    // log to error log file
    WriteErrorToErrorLog(cErrorLocation, hr, cCompileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\errmsg.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  ErrMsg.cpp
//=============================================================================*

#include "stdafx.h"
#include <windows.h>
#include "ErrMacro.h"
#include "Message.h"
#include "ErrLog.h"
#include "Dfrgres.h"
#include "IntFuncs.h"
#include "vString.hpp"
#include "GetDfrgRes.h" // to use the GetDfrgResHandle()

//This logfile capability is activated only for the engines.
#if defined(DFRGFAT) || defined(DFRGNTFS)
	#include "LogFile.h"
	extern BOOL bLogFile;
#endif

extern BOOL bPopups;
extern BOOL bIdentifiedErrorPath;
extern HINSTANCE hInst;

//-------------------------------------------------------------------*
//	function:	ErrorMessageBox
//
//	returns:	None
//	note:		
//-------------------------------------------------------------------*
BOOL
ErrorMessageBox(
	TCHAR* cMsg,
	TCHAR* cTitle
	)
{
	//Added cNewMsg code to take care of the case where cMsg == NULL, so that we put some message
	//out instead of nothing.  
	TCHAR cNewMsg[256];

	if(cMsg == NULL)
	{
		FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,		// source and processing options
						NULL,							// message source
						NULL,							// message identifier
						NULL,							// language identifier
						cNewMsg,						// message buffer
						255,							// maximum size of message buffer
						NULL							// array of message inserts
						);
	} else
	{
			wcscpy(cNewMsg, cMsg);
	}

#ifndef OFFLINEDK

	//Write the error to the error log.
	WriteErrorToErrorLog(cNewMsg, -1, NULL);

//This logfile capability is activated only for the engines.
#if defined(DFRGFAT) || defined(DFRGNTFS)
	//If the logfile for the test harness is enabled, then log it there too.
	if(bLogFile){
		WriteStringToLogFile(cNewMsg);
		//return TRUE;  //Have to bail out here so we don't print the messagebox below.
	}
#endif

	//If this is set for messageboxes (not IoStress) then pop up a messagebox too.
	if(bPopups && !bIdentifiedErrorPath){
		MessageBox(NULL, cNewMsg, cTitle, MB_ICONSTOP|MB_OK);
		//Once an error message has been printed, don't print another.
		bIdentifiedErrorPath = TRUE;
	}
#endif
	return TRUE;
}


//-------------------------------------------------------------------*
//	function:	FileBugReportMessage
//
//	returns:	Always TRUE
//	FileBugReportMessage is identical to ErrorMessageBox, except that it puts up 
//	a generic message telling the user to give us a log file
//	rather than pop up a message explaining the error.
//	This function is used when there is a code error, not when it isn't a bug, such as
//	when the user tells us to run on a volume that doesn't exist.
//-------------------------------------------------------------------*
BOOL
FileBugReportMessage(
	TCHAR* cMsg,
	TCHAR* cTitle
	)
{
#ifndef OFFLINEDK
	VString msg(IDS_FILE_BUG_MESSAGE, GetDfrgResHandle());

	//Write the error to the error log.
	WriteErrorToErrorLog(cMsg, -1, NULL);

	//If this is set for messageboxes (not IoStress) then pop up a messagebox too.
	if(bPopups && !bIdentifiedErrorPath){
		MessageBox(NULL, msg.GetBuffer(), cTitle, MB_OK|MB_ICONSTOP);
		//Once an error message has been printed, don't print another.
		bIdentifiedErrorPath = TRUE;
	}
#endif
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\exclude.cpp ===
/*****************************************************************************************************************

FILENAME: Exclude.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION: Handles exclusion of files.

*/

#include "stdafx.h"
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>

#include <windows.h>

extern "C" {
    #include "SysStruc.h"
}
#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgNtfs.h"   //Includes function prototype for CheckPagefileNameMatch which is the same in FAT.

#include "Alloc.h"
#include "GetReg.h"
#include "LoadFile.h"
#include "Exclude.h"
#include "Expand.h"

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

INPUT + OUTPUT:
    IN cExcludeFile - The name of the file to check for exclusion.
    OUT phExcludeList - Pointer to handle for memory to be alloced and filled with the list of excluded files.

GLOBALS:
    None.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
GetExcludeFile(
    IN PTCHAR cExcludeFile,
    OUT PHANDLE phExcludeList
    )
{
    HKEY hValue = NULL;
    TCHAR cRegValue[MAX_PATH];
    DWORD dwRegValueSize = sizeof(cRegValue);
    DWORD dwExcludeFileSize = 0;

    //0.0E00 Get the install path.
    // todo NOTE: SFP will prevent us from using the system32 folder for this purpose!
    EF(GetRegValue(&hValue,
                   TEXT("SOFTWARE\\Microsoft\\Dfrg"),
                   (PTCHAR)TEXT("PathName"),
                   cRegValue,
                   &dwRegValueSize) == ERROR_SUCCESS);

    EF_ASSERT(RegCloseKey(hValue)==ERROR_SUCCESS);

    //Translate any environment variables in the string.
    EF_ASSERT(ExpandEnvVars(cRegValue));

    //0.0E00 Print out the name of the exclude file.
    lstrcat(cRegValue, TEXT("\\"));
    lstrcat(cRegValue, cExcludeFile);

    //0.0E00 Read the file into memory.
    *phExcludeList = LoadFile((PTCHAR)cRegValue, 
                              &dwExcludeFileSize, 
                              FILE_SHARE_READ|FILE_SHARE_WRITE, 
                              OPEN_EXISTING);

    //0.0E00 Print out whether or not the file was loaded.
    if(*phExcludeList != NULL) {
        Message(TEXT("Loaded exclude file"), S_OK, cRegValue);
    }
    else {
        Message(TEXT("No exclude file"), S_OK, cRegValue);
    }
    Message(TEXT(""), -1, NULL);
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Check to see if this file is excluded.

INPUT + OUTPUT:
    IN VolData.cFileName - The name of the file which is excluded.
    IN VolData.FileSystem - Which file system the drive is.

GLOBALS:
    None.

RETURN:
    TRUE - File is not excluded.
    FALSE - File is excluded.
*/

BOOL
CheckFileForExclude(
    IN CONST BOOL fAcceptNameOnly
    )
{
    PTCHAR pFileName = VolData.vFileName.GetBuffer();
    PTCHAR pExcludeList = NULL;
    PTCHAR pExcludeListEnd = NULL;
    UINT ExcludeLength;
    int i;

    if (!pFileName) {
        return FALSE;
    }

    if((VolData.FileSystem == FS_FAT || VolData.FileSystem == FS_FAT32) && 
       (CompareString(LOCALE_INVARIANT,// locale identifier 
                     NORM_IGNORECASE,       // comparison-style options
                     TEXT("BOOTSECT.DOS"),  // pointer to first string
                     -1,                    // null terminated first string
                     pFileName+3,           // pointer to second string
                     -1) == 2)){            // null terminated second string

        return FALSE;
    }

    // Look get the file name from after the last slash.
    TCHAR *cFileName = wcsrchr(VolData.vFileName.GetBuffer(), L'\\');

    if (fAcceptNameOnly) {
        if (!cFileName) {
            cFileName = pFileName;
        }
    }
    else {
        //If there was no path to extract, then bail.
        EF_ASSERT(cFileName);
        // start at first character after the last backslash
        cFileName++; 
    }

    //Check to see if this is a pagefile.
    if(CheckPagefileNameMatch(cFileName, pPageFileNames)){
        return FALSE;
    }
    //sks bug#200579 removed ShellIconCache from the list


    // Do not move the file safeboot.fs
    //  Moving this file can cause desktop problems.
    //  Raffi - 20-Oct-1997 - added in Build V2.0.172
    if (lstrlen(pFileName) >= lstrlen(TEXT("safeboot.fs"))) {
        i = lstrlen(pFileName) - lstrlen(TEXT("safeboot.fs"));
        if(CompareString(LOCALE_INVARIANT,// locale identifier 
                         NORM_IGNORECASE,       // comparison-style options
                         TEXT("safeboot.fs"),   // pointer to first string
                         -1,                    // null terminated first string
                         pFileName+i,           // pointer to second string
                         -1) == 2){         // null terminated second string
            Message(TEXT("Excluding safeboot.fs"), -1, pFileName);
            return FALSE;
        }
    }
    
    // Do not move the file safeboot.csv
    //  Moving this file can cause desktop problems.
    //  Raffi - 20-Oct-1997 - added in Build V2.0.172
    if (lstrlen(pFileName) >= lstrlen(TEXT("safeboot.csv"))) {
        i = lstrlen(pFileName) - lstrlen(TEXT("safeboot.csv"));
        if(CompareString(LOCALE_INVARIANT,// locale identifier 
                         NORM_IGNORECASE,       // comparison-style options
                         TEXT("safeboot.csv"),  // pointer to first string
                         -1,                    // null terminated first string
                         pFileName+i,           // pointer to second string
                         -1) == 2){         // null terminated second string
            Message(TEXT("Excluding safeboot.csv"), -1, pFileName);
            return FALSE;
        }
    }
    
    // Do not move the file safeboot.rsv
    //  Moving this file can cause desktop problems.
    //  Raffi - 20-Oct-1997 - added in Build V2.0.172
    if (lstrlen(pFileName) >= lstrlen(TEXT("safeboot.rsv"))) {
        i = lstrlen(pFileName) - lstrlen(TEXT("safeboot.rsv"));
        if(CompareString(LOCALE_INVARIANT,// locale identifier 
                         NORM_IGNORECASE,       // comparison-style options
                         TEXT("safeboot.rsv"),  // pointer to first string
                         -1,                    // null terminated first string
                         pFileName+i,           // pointer to second string
                         -1) == 2){         // null terminated second string
            Message(TEXT("Excluding safeboot.rsv"), -1, pFileName); 
            return FALSE;
        }
    }
    
    // Do not move the file hiberfil.sys
    //  Moving this file can cause problems.
    if (lstrlen(pFileName) >= lstrlen(TEXT("hiberfil.sys"))) {
        i = lstrlen(pFileName) - lstrlen(TEXT("hiberfil.sys"));
        if(CompareString(LOCALE_INVARIANT,// locale identifier 
                         NORM_IGNORECASE,       // comparison-style options
                         TEXT("hiberfil.sys"),  // pointer to first string
                         -1,                    // null terminated first string
                         pFileName+i,           // pointer to second string
                         -1) == 2){         // null terminated second string
            Message(TEXT("Excluding hiberfil.sys"), -1, pFileName); 
            return FALSE;
        }
    }

    // Do not move the file memory.dmp
    //  Moving this file can cause problems.
    if (lstrlen(pFileName) >= lstrlen(TEXT("memory.dmp"))) {
        i = lstrlen(pFileName) - lstrlen(TEXT("memory.dmp"));
        if(CompareString(LOCALE_INVARIANT,// locale identifier 
                         NORM_IGNORECASE,       // comparison-style options
                         TEXT("memory.dmp"),    // pointer to first string
                         -1,                    // null terminated first string
                         pFileName+i,           // pointer to second string
                         -1) == 2){         // null terminated second string
            Message(TEXT("Excluding memory.dmp"), -1, pFileName); 
            return FALSE;
        }
    }

    //0.0E00 No Match
    if(VolData.hExcludeList == NULL){
        return TRUE;
    }

    BOOL bReturnValue;

    __try{
    
        //0.0E00 Lock the memory and get pointer to the memory
        pExcludeList = (PTCHAR) GlobalLock(VolData.hExcludeList);
        if (pExcludeList == (PTCHAR) NULL){
            EH_ASSERT(FALSE);
            bReturnValue = FALSE;
            __leave;
        }

        //0.0E00  Get the pointer to the end of the exclude list
        pExcludeListEnd = pExcludeList + GlobalSize(VolData.hExcludeList);

        //0.0E00 Loop until match or end of Exclude List
        while (pExcludeList < pExcludeListEnd){

            ExcludeLength = lstrlen(pExcludeList);
//
//          if(CompareString(LOCALE_INVARIANT, // locale identifier 
//                           NORM_IGNORECASE,       // comparison-style options
//                           pExcludeList,          // pointer to first string
//                           ExcludeLength,         // size, in bytes or characters, of first string
//                           pFileName,             // pointer to second string
//                           ExcludeLength) == 2){  // size, in bytes or characters, of second string
//
//              //0.0E00 If there is a match then this file should be excluded.
//              if((lstrlen(pFileName) == (int)ExcludeLength) || (pFileName[ExcludeLength] == TEXT('\\'))){
//                  //0.0E00 Exclude the file.
//                  Message(TEXT("Excluding File."), -1, pFileName); 
//                  return FALSE;
//              }
//          }
            // Check to see if it is a wild string type of exclusion *RA*
            // It is not case sensitive
            if (lStrWildCmp(pFileName, pExcludeList, FALSE)) {
                //0.0E00 Exclude the file.
                Message(TEXT("Excluding File."), -1, pFileName); 
                bReturnValue = FALSE;
                __leave;
            }
            //0.0E00 Set pointer to next record
            pExcludeList += ExcludeLength + 2;
        }
        //0.0E00 No Match
        bReturnValue = TRUE;
    }

    __finally {
        if (pExcludeList) {
            GlobalUnlock(VolData.hExcludeList);
        }
    }

    return bReturnValue;
}
/*****************************************************************************************************************
    
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
        
ROUTINE DESCRIPTION:
  This routine does a wild string comparison of a given Source string and a Pattern string that
  may contain wild string characters (*, ?).
          
INPUT:
  pOrigSourceString - Pointer to null terminated Source String to check for pattern match on.
  pOrigPatternString - Pointer to null terminated string containing the match pattern.
  bCaseType - TRUE=Case Sensitive comparison, FALSE=Non-Case Sensitive comparison
            
RETURN:
  Success - TRUE - It was a match.
  Failure - FALSE - It was NOT a match.
*/

BOOL
lStrWildCmp (
             IN PTCHAR   pOrigSourceString,
             IN PTCHAR   pOrigPatternString,
             IN BOOL     bCaseType
             )
{
    
    TCHAR       cSource[500];     // Local copy of Source String
    TCHAR       cPattern[500];    // Local copy of Match Pattern String
    PTCHAR      pSource;                // Pointer into our local Source String
    PTCHAR      pPattern;               // Pointer into our local Match Pattern String
    PTCHAR      pEndPattern;            // Pointer to the end of our local Match Pattern String
    
    DWORD       dwCompareFlag=0;        // Flag used in CompareString function
    BOOL        bMatchFound;
    int         nchars;                 // Number of characters in pattern section that we are checking against.
    int         lastn;                  // Indicates if last char was or was not, a cWildn (0=No, 1=Yes)
    
    // Define some characters we use
    TCHAR       cWildn   = {'*'};
    TCHAR       cWild1   = {'?'};
    TCHAR       cEndstr  = {'\0'};
    PTCHAR      cStopset = TEXT("*?\0");      // note order is cWildn/cWild1
    
    
    // Verify that a valid Source and Pattern string was passed in. If not, return failure status.
    if ((pOrigPatternString == NULL) || (lstrlen(pOrigPatternString) == 0)) {
        return FALSE;
        }
    if ((pOrigSourceString == NULL) || (lstrlen(pOrigSourceString) == 0)) {
        return FALSE;
        }
    
    
    // Check for the simple case of No wildcards in the pattern.
#ifndef UNICODE
    if ((strchr(pOrigPatternString, cWildn) == NULL) &&
        (strchr(pOrigPatternString, cWild1) == NULL)) {
#else
        if ((wcschr(pOrigPatternString, cWildn) == NULL) &&
            (wcschr(pOrigPatternString, cWild1) == NULL)) {
#endif
            // This is a simple case of a 'straight' string comparison
            // If the lengths do not equal, then the strings do not equal.
            if (lstrlen(pOrigSourceString) != lstrlen(pOrigPatternString)) {
                // No Match
                return FALSE;
                }
            else {
                // Set up CompareString flag for No Case-sensitive checking if selected
                if (bCaseType == FALSE) { dwCompareFlag = NORM_IGNORECASE; }
                
                if(!lstrcmpi(pOrigSourceString, pOrigPatternString)){
//  WRITE A REAL SHELL FOR COMPARESTRING!
                // Compare strings
//                if ((CompareString(LOCALE_INVARIANT,
//                    dwCompareFlag,
//                    pOrigSourceString,
//                    lstrlen(pOrigSourceString),
//                    pOrigPatternString,
//                    lstrlen(pOrigPatternString)
//                    )) == 2) {
                   // Match found
                    return TRUE;
                    }
                else {
                    // No Match found
                    return FALSE;
                    }
                }
            }
        
        
        // There was wildcard(s) in the match pattern, so it is a more complex check
        //
        // Set up data for wildcard comparisons.
        //
        // Reset indicator that last char was not a cWildn(*) character
        lastn = 0;
        // Make our own local copies of the strings
        if (lstrcpy(cPattern, pOrigPatternString) == NULL) { return FALSE;}
        if (lstrcpy(cSource, pOrigSourceString) == NULL) { return FALSE;}
        
        // If Not case-sensitive check, then make both strings upper case
        if (bCaseType == FALSE) {
            CharUpper(cPattern);
            CharUpper(cSource);
//#ifndef UNICODE
//            strupr(cPattern);
//            strupr(cSource);
//#else
//            wcsupr(cPattern);
//            wcsupr(cSource);
//#endif
            }
        // Set up pointers to strings
        pSource     = cSource;
        pPattern    = cPattern;
        pEndPattern = pPattern + (lstrlen(cPattern) * sizeof(TCHAR));
        
        
        // This section of the code will take the pattern string and extract each pattern section, where a
        // string sections is seperated by one of the following:
        //
        //      a) The start of the string
        //      b) The end of the string (0 termination)
        //      c) A wildcard character (* or ?)
        //
        // For each pattern section, it will then try to find a match in the source string. If a match is found, then
        // the next pattern section is extracted and the next match check is made on the source string, starting at 
        // the source string location where the last match was found.
        //
        // There are several types of pattern sections to consider
        //   1) *nnn* - Section with '*' on both ends. This means that the match be anywhere in the source string.
        //   2) nnn*  - '*' just at the section end, so the string must match starting at the current source string
        //              location.
        //   3) *nnn  - '*' just at the section start, so just the end of the source string is checked. For example,
        //               *.dat
        //   4) ? - For single character wildcards, we just skip the next character in the source string to check.
        //
        //
        while (pPattern <= pEndPattern) {
            
            switch (*pPattern) {
                
                // Case 1: Next pattern char is cWildn (*) character
                //  Indicate that last character was cWildn and continue on with check
                case '*' : {
                    pPattern = pPattern + 1;
                    lastn = 1;
                    break;
                    }   // End Case 1
                    
                    // Case 2: Next pattern char is cWild1 (?) character
                case '?' : {
                    // Check where we are in the source string
                    if (*pSource != cEndstr) {
                        
                        // We are not at the end, so we know the next character is the Source String will be
                        // a match, so just increment to the next character and continue on with check.
                        pSource  = pSource + 1;
                        pPattern = pPattern + 1;
                        lastn = 0;
                        break;
                        }
                    else {
                        // We are at the end of the Source string, so NO Match found
                        return FALSE;
                        }
                    }   // End Case 2
                    
                    
                    // Case 3: End of the pattern string reached
                case '\0' : {
                    // If we are also at the end of the Source string, then all done with a Match found
                    if (*pSource == cEndstr) {
                        return TRUE;
                        }
                    else {
                        // If the last character was a '*', then all done with a Match found
                        if (lastn == 1) {
                            return TRUE;
                            }
                        // If the last character was NOT a '*', then all done with NO Match found
                        else {
                            return FALSE;
                            }
                        }
                    }   // End Case 3
                    
                    
                    // Case 4: Anything else (NON wild or terminating character), we get 
                    // the next pattern section to check against the source string.
                default : {
                    
                    // Get number of character in next pattern section
#ifndef UNICODE
                    nchars = strcspn(pPattern, cStopset);
#else
                    nchars = wcscspn(pPattern, cStopset);
#endif
                    // If the last character was Not a cWildn (*), then just 
                    // check the pattern section starting at the current point in the source string.
                    if (lastn == 0) {
                        
                        // If a match found, then reset pattern and source pointers for the next sections to
                        // check against and start search for next section.
#ifndef UNICODE
                        if (strncmp(pPattern, pSource, nchars) == 0) {
#else
                            if (wcsncmp(pPattern, pSource, nchars) == 0) {
#endif
                                pPattern = pPattern + nchars;
                                pSource  = pSource + nchars;
                                break;
                                }
                            else {
                                // NO Match found, return back failure status
                                return FALSE;
                                }
                            }
                        
                        
                        
                        // The last character was a cWildn (*), but we need to see if
                        // the string ends the pattern and check that as a special case
                        
                        // Check for special case of the last pattern section
                        if (nchars == (int)lstrlen(pPattern)) {
                            
                            // For the last pattern section case, if the length of the pattern section is greater
                            // than the source string section to check against, then there cannot be a match.
                            if ((int)lstrlen(pSource) < nchars) {
                                return FALSE;
                                }
                            
                            
                            // For the last pattern section case, we just need to compare to the end section of the
                            // source string, adjust the source string pointer to this location (= 'cEndstr'-nchars),
                            // and go continue checking.
                            pSource = pSource + (lstrlen(pSource) - nchars);
                            lastn   = 0;
                            break;
                            }
                        
                        // It was not the special case, so since the last char was a cWildn (*), the match could be anywhere.
                        // So, we start checking at the current Source string location for a match with the pattern section.
                        // Note: If No Match is found, then it falls out of this loop.
                        bMatchFound = FALSE;
                        while (*pSource != cEndstr) {
                            
                            // If a match found, then reset pattern and source pointers for the next sections to
                            // check against and start search for next section.
#ifndef UNICODE
                            if (strncmp(pPattern, pSource, nchars) == 0) {
#else
                                if (wcsncmp(pPattern, pSource, nchars) == 0) {
#endif
                                    pPattern = pPattern + nchars;
                                    pSource = pSource + nchars;
                                    lastn = 0;
                                    bMatchFound = TRUE;
                                    break;
                                    }
                                else {
                                    pSource = pSource + 1;
                                    }
                                }
                            // If no match found, then return back failure status
                            if (!bMatchFound) {
                                return FALSE;
                                }
                            // else a match was found, so go check next pattern section
                            break;
                            }   // End Case 4
                        }   // End Switch
                    }   // End While
                    
                    // It should never fall out of the while loop, because the checks within the loop should catch
                    // when processing is completed, but just in case, it will fail if it comes out of the loop.
                    return FALSE;
                    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\expand.cpp ===
/*****************************************************************************************************************

FILENAME: Exclude.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"

#ifndef SNAPIN
#include <windows.h>
#endif

#include "ErrMacro.h"
#include "expand.h"
#include <tchar.h>

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Checks for an environment parameters in the string, and if found, replaces them with the
    non-logical value of the environment parameters.

INPUT + OUTPUT:
    IN OUT pString - The string that may contain the environment parameter.

GLOBALS:
    None.

RETURN:
    TRUE - Success.
    FALSE - Fatal error.
*/
BOOL
ExpandEnvVars(
    IN OUT TCHAR * pString  // should be at least MAX_PATH characters long
    )
{
    TCHAR szOriginalString[MAX_PATH+1];
    DWORD cchSize = 0;

    if (!pString || (_tcslen(pString) >= MAX_PATH)) {
        return FALSE;
    }

    _tcsncpy(szOriginalString, pString, MAX_PATH);
    szOriginalString[MAX_PATH] = TEXT('\0');

    cchSize = ExpandEnvironmentStrings(szOriginalString, pString, MAX_PATH);

    if ((0 == cchSize) || (cchSize > MAX_PATH)) {
        return FALSE;
    }
    
    return TRUE;
}


LPTSTR 
GetHelpFilePath()
{
    static TCHAR szHelpFilePath[MAX_PATH + 20];
    static BOOL bReset = TRUE;

    if (bReset) {

        ZeroMemory(szHelpFilePath, sizeof(TCHAR) * (MAX_PATH + 20));
        if (0 == GetSystemWindowsDirectory(szHelpFilePath, MAX_PATH + 1)) {
            szHelpFilePath[0] = TEXT('\0');
        }
        _tcscat(szHelpFilePath, TEXT("\\Help\\Defrag.HLP"));

        //TODO: Check if file exists?

        bReset = FALSE;
    }

    return szHelpFilePath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\esbutton.cpp ===
/*****************************************************************************************************************

FILENAME: ESButton.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

CLASS: ESButton
	This is a class to create a button window.
*/

#include "stdafx.h"
#ifndef SNAPIN
#include <windows.h>
#endif

#include "errmacro.h"
#include "ESButton.h"

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
	Constructor - Initializes class variables.

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	None.
*/

ESButton::ESButton(HWND hwndParent, UINT ButtonId, HINSTANCE hInstance)
{
    m_hwndButton = CreateWindow(
		TEXT("Button"),
		TEXT("TEST"),
		WS_CHILD|BS_PUSHBUTTON,
		400,
		400,
		100,
		100,
		hwndParent,
		(HMENU)IntToPtr(ButtonId),
		hInstance,
		(LPVOID)IntToPtr(NULL));

	if (m_hwndButton == NULL){
		DWORD dwErrorCode = GetLastError();
	}
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
	Destroys the button window

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	None.
*/

ESButton::~ESButton()
{
	if (m_hwndButton != NULL){
		if (IsWindow(m_hwndButton)){
			DestroyWindow(m_hwndButton);
		}
	}
}

BOOL
ESButton::ShowButton(int cmdShow)
{
    if (m_hwndButton != NULL){
        return ::ShowWindow(m_hwndButton, cmdShow);
    }

    return FALSE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
	Initializes class variables.

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	None.
*/

BOOL ESButton::PositionButton(RECT* prcPos)
{
	if (m_hwndButton != NULL){
		MoveWindow(m_hwndButton,
				   prcPos->left,
				   prcPos->top,
				   prcPos->right - prcPos->left,
				   prcPos->bottom - prcPos->top,
				   FALSE);
	}

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
	Initializes class variables.

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	None.
*/

BOOL ESButton::SetText(TCHAR* szNewText)
{
	if (m_hwndButton != NULL){
		SetWindowText(m_hwndButton, szNewText);
	}

	return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	None.
*/

BOOL ESButton::LoadString(HINSTANCE hInstance, UINT labelResourceID)
{
	if (m_hwndButton != NULL){
		TCHAR cText[200];
		::LoadString(hInstance, labelResourceID, cText, sizeof(cText)/sizeof(TCHAR));
		SetWindowText(m_hwndButton, cText);
	}

	return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
	Initializes class variables.

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	None.
*/

BOOL ESButton::SetFont(HFONT hNewFont)
{
	if (m_hwndButton != NULL){
		SendMessage(m_hwndButton, WM_SETFONT, (WPARAM)hNewFont, MAKELPARAM(TRUE, 0));
	}

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
	Enables or disables the button.

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	None.
*/

BOOL ESButton::EnableButton(BOOL bEnable)
{
	if (m_hwndButton != NULL){
		if (bEnable != ::IsWindowEnabled(m_hwndButton)){
			EnableWindow(m_hwndButton, bEnable); // this repaints the button
		}
	}

	return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
	returns the state of the button

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	Button State, true or false
*/

BOOL ESButton::IsButtonEnabled(void)
{
	if (m_hwndButton != NULL)
		return ::IsWindowEnabled(m_hwndButton);
	else
		return FALSE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

METHOD DESCRIPTION:
	Enables or disables the button.

CLASS VARIABLES:

INPUT + OUTPUT:

RETURN:
	None.
*/

BOOL ESButton::ShowWindow(UINT showState)
{
	if (m_hwndButton != NULL){
		::ShowWindow(m_hwndButton, showState); // this repaints the button
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\extents.cpp ===
/*****************************************************************************************************************

FILENAME: Extents.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This module keeps track of extent updates from MoveFile -- any changes to extent data for files on the drive
    caused by defragging or moving the files are recorded using the function SendExtents().  This buffers the
    changes which can be periodically given to the DiskView class so as to update the graphical representation of
    the drive.
*/


#include "stdafx.h"

#include <windows.h>

extern "C" {
    #include "SysStruc.h"
}
#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"

#include "Extents.h"

#include "Alloc.h"
#include "DiskView.h"
#include "dfrgengn.h"

//1.0E00 These vars are global within the current module only.

//1.0E00 Handle to the extent buffer.
static  HANDLE hExtentBuffer = NULL;

//1.0E00 Pointer to the extent buffer.
static  PBYTE pExtentBuffer = NULL;

//1.0E00 Pointer to the current location in the extent buffer.
static  PBYTE pExtentBufferPos = NULL;

extern DiskView AnalyzeView;
extern DiskView DefragView;

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Allocates a buffer for file extent changes due to defragging or moving files.

INPUT + OUTPUT:
    None.

GLOBALS:
    OUT hExtentBuffer       - Handle to the buffer.
    OUT pExtentBuffer       - Pointer to the buffer.
    OUT pExtentBufferPos    - Pointer to the current location in the buffer.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
CreateExtentBuffer(
    )
{
    //1,0E00 First allocate the buffer.
    EF(AllocateMemory(EXTENT_BUFFER_LENGTH, &hExtentBuffer, (void**)&pExtentBuffer));

    //1.0E00 pExtentBufferPos keeps the current location in the buffer.
    //1.0E00 Initialize to the beginning of the buffer.
    pExtentBufferPos = pExtentBuffer;

    //1.0E00 Zero out the buffer.
    ZeroMemory(pExtentBuffer, EXTENT_BUFFER_LENGTH);

    return TRUE;
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Sends any residual data in the extent buffer to DiskView then frees up the buffer.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT hExtentBuffer    - Handle to the buffer.
    IN OUT pExtentBuffer    - Pointer to the buffer.
    IN OUT pExtentBufferPos - Pointer to the current location in the buffer.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
DestroyExtentBuffer(
    )
{
    //1.0E00 Error if this is called but CreateExtentBuffer wasn't.
    EF(hExtentBuffer != NULL);

    //1.0E00 If there is anything left in the buffer...
    if(pExtentBufferPos != pExtentBuffer){
        //1.0E00 Send the updates to the DiskView.      
        PurgeExtentBuffer();
    }

    //1.0E00 Free the buffer and nuke the pointers.
    EH_ASSERT(GlobalUnlock(hExtentBuffer) == FALSE);
    EH_ASSERT(GlobalFree(hExtentBuffer) == NULL);
    hExtentBuffer = NULL;
    pExtentBuffer = NULL;
    pExtentBufferPos = NULL;

    return TRUE;
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Sends any residual data in the extent buffer to DiskView then frees up the buffer.

INPUT + OUTPUT:
    IN Color - The color code for the following series of extents (whether this is fragmented color etc.)

GLOBALS:
    IN OUT pExtentBuffer - Pointer to the buffer.
    IN OUT pExtentBufferPos - Pointer to the current location in the buffer.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
AddExtents(
    BYTE Color
    )
{
    UINT i;
    FILE_EXTENT_HEADER* pFileExtentHeader;
    STREAM_EXTENT_HEADER* pStreamExtentHeader;

    //Get pointers to the headers of the extent list data for the file.
    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));

    //Loop through each stream.  We're going to return the lowest starting lcn for any stream.
    for(i=0; i<pFileExtentHeader->NumberOfStreams; i++){

        EF(AddExtentsStream(Color, pStreamExtentHeader));

        //Go to the next stream.
        pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST));
    }
    return TRUE;
}
BOOL
AddExtentsStream(
    BYTE Color,
    STREAM_EXTENT_HEADER* pStreamExtentHeader
    )
{
    LONGLONG lExtentCount = 0;
    LONGLONG ExtentsAdded = 0;
    EXTENT_LIST* pExtents;
    BOOL bPurgeNext = FALSE;

    //Get a pointer to this stream's extents.
    pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

    //1.0E00 Add extents into the buffer and send the buffer each time it's full.
    for(ExtentsAdded=0; 
        ExtentsAdded < pStreamExtentHeader->ExtentCount;    //1.0E00 Keep adding extents until we've added them all.
        ExtentsAdded += lExtentCount){                      //1.0E00 Update how many extents we've added.
    
        //1.0E00 Check to see if the buffer is full.
        //1.0E00 If the pointer to the current position in the buffer plus the minimum addition of data is at the end of the buffer...
        //1.0E00 The minimum addition is 2*sizeof(LONGLONG) since you need a LONGLONG header plus at least a LONGLONG for an extent.
        //1.0E00 However, there must be space for 3*sizeof(LONGLONG since there must be a LONGLONG terminator.
        if((pExtentBufferPos + (3*sizeof(LONGLONG))) >= (pExtentBuffer + EXTENT_BUFFER_LENGTH)){
            //1.0E00 The buffer is full, send the updates to the DiskView.
            PurgeExtentBuffer();
        }

        //1.0E00 Determine how many extents will fit in the remainder of the buffer
        //1.0E00 (The end of the buffer - (the current position + the header + the terminator)) / sizeof(an extent)
        lExtentCount = ((pExtentBuffer + EXTENT_BUFFER_LENGTH) - (pExtentBufferPos + (2*sizeof(LONGLONG)))) / sizeof(EXTENT_LIST);

        //1.0E00 If all of the extents will fit with room to spare, trim our count down so as to only add as many extents as there are.
        if(lExtentCount > pStreamExtentHeader->ExtentCount - ExtentsAdded){
            lExtentCount = pStreamExtentHeader->ExtentCount - ExtentsAdded;
        }
        else{
            //If all the extents don't fit, then we'll fill up the buffer to it's end, and then purge it.
            bPurgeNext = TRUE;
        }

        //1.0E00 Add these extents into the buffer
        EF(AddExtentChunk(Color, pExtents, ExtentsAdded, lExtentCount));

        //Purge the buffer.
        if(bPurgeNext){
            PurgeExtentBuffer();
            bPurgeNext = FALSE;
        }
    }
    return TRUE;
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Sends any residual data in the extent buffer to DiskView then frees up the buffer.

INPUT + OUTPUT:
    IN Color - The color code for the following series of extents (whether this is fragmented color etc.)
    IN pExtentList - A pointer to the extent list of extents to add to the extent buffer.
    IN lExtentCount - The number of extents to add from pExtentList.

GLOBALS:
    IN OUT pExtentBuffer - Pointer to the buffer.
    IN OUT pExtentBufferPos - Pointer to the current location in the buffer.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
AddExtentChunk(
    BYTE Color,
    EXTENT_LIST* pExtentList,
    LONGLONG ExtentsAdded,
    LONGLONG lExtentCount
    )
{
    EXTENT_LIST* pUpdateArray = NULL;
    LONGLONG RealExtentCount = 0;

    //1.0E00 Don't attempt to add zero extents.
    EF(lExtentCount != 0);

    //1.0E00 Get an extent pointer into the buffer -- one header past the current position.
    pUpdateArray = (EXTENT_LIST*)(pExtentBufferPos + sizeof(LONGLONG));

    //ExtentCount is the number of extents to add.  Since we may be starting in the middle of an extent list, we need to offset
    //the value to where we are so we add the extents to the right place.
    lExtentCount += ExtentsAdded;

    //1.0E00 Copy extents into the buffer (no virtual extents)
    for(; 
        ExtentsAdded < lExtentCount;    //1.0E00 Until all the extents have been added.
        ExtentsAdded ++){
        
        //1.0E00 If this is not a virtual extent, copy it into the buffer and bump copied extent count
        if(pExtentList[ExtentsAdded].StartingLcn != 0xFFFFFFFFFFFFFFFF){
            //1.0E00 Copy the extent into the buffer.
            pUpdateArray->StartingLcn = (ULONG)pExtentList[ExtentsAdded].StartingLcn;
            pUpdateArray->ClusterCount = (ULONG)pExtentList[ExtentsAdded].ClusterCount;

            //1.0E00 This was not a virtual extent, so increment the real extent count.
            RealExtentCount ++;

            //1.0E00 Move to the next location in the buffer.
            pUpdateArray ++;
        }
    }

    //1.0E00 Set the extent count for this list of extents. This count is the real extent count (viz. excluding virtual extents.)
    //1.0E00 This goes into the extent header.
    CopyMemory(pExtentBufferPos, &RealExtentCount, sizeof(LONGLONG));

    //1.0E00 Set the extent buffer now to point just beyond the header, and go one byte back (last byte in the LONGLONG) to set the color code.
    pExtentBufferPos += sizeof(LONGLONG);
    pExtentBufferPos[-1] = Color;

    //1.0E00 Update the buffer pointer to after all the extents -- the new current location in the buffer.
    pExtentBufferPos = (PBYTE)pUpdateArray;

    return TRUE;
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine sends the data in the extent buffer to the DiskView class.  When done, it resets the pointer
    to the buffer and zeros out the buffer so more extents can be added.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN pDiskView - Pointer to the DiskView class.
    IN pExtentBuffer - Pointer to the extent buffer.
    IN OUT pExtentBufferPos - Pointer to the current location in the extent buffer.

RETURN:
    TRUE - Success.
    FALSE - Fatal error.
*/

BOOL
PurgeExtentBuffer(
    )
{
    //1.0E00 Don't process anything if there isn't an extent buffer yet.
    if(!pExtentBuffer || !pExtentBufferPos){
        return TRUE;
    }

    //1.0E00 Put the terminator on the end of the buffer before sending it in to DiskView.
    //1.0E00 First check to make sure there is space for a LONGLONG terminator.
    EF((pExtentBufferPos + (sizeof(LONGLONG))) <= (pExtentBuffer + EXTENT_BUFFER_LENGTH));
    //1.0E00 Now write the terminator.
    *((LONGLONG*)pExtentBufferPos) = 0;
  
    //If a defrag view exists, that means we're in the defrag pass, and the analyze view 
    //should not be given any file updates.
    //It's either one or the other.
    if(DefragView.IsActive()){
        //1.0E00 Update the array with the data in the extent buffer.
        DefragView.UpdateClusterArray(pExtentBuffer);
    }
    else if(AnalyzeView.IsActive()){
        //1.0E00 Update the array with the data in the extent buffer.
        AnalyzeView.UpdateClusterArray(pExtentBuffer);
    }

    //1.0E00 Reset the position in the buffer to the beginning.
    pExtentBufferPos = pExtentBuffer;
    *((LONGLONG*)pExtentBufferPos) = 0;

    //1.0E00 Zero out the buffer.
    //ZeroMemory(pExtentBuffer, EXTENT_BUFFER_LENGTH);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\fastfat2.cpp ===
/*****************************************************************************************************************

FILENAME: FastFat2.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

  This file contains the routines that traverse the FAT directory structure returning file names so our
  engine can process every file on the disk.  See other write-ups for the format of the FAT file system.
  We traverse the directory tree beginning in the root directory.  All files in that directory are
  processed first, then we move down into the first subdirectory and process every file in it.  Then we
  move down again into its first subdirectory and process all the files in it, etc.  Once we reach the
  end of a directory chain, then we move back up one level and immediately move down again into the next
  undone directory from that level.  We keep the FAT directories in memory for our current directory and
  each directory in the chain above us.

  We process all the files before moving into subdirs to save space.  As soon as all the files are
  processed, we delete all the file entries from our current FAT directory and that consolidates all
  the directories.  We can then step through each directory.

*/

#include "stdafx.h"

extern "C"{
#include <stdio.h>
}

#ifdef BOOTIME
    #include "Offline.h"
#else
    #include <Windows.h>
#endif

extern "C" {
#include "SysStruc.h"
}

#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"

#include "DfrgFat.h"

#include "DasdRead.h"
#include "Devio.h"
#include "Extents.h"
#include "FatSubs.h"
#include "FastFat2.h"

#include "Alloc.h"
#include "IntFuncs.h"
#ifdef OFFLINEDK
#include "OffLog.h"
#else
#include "Logging.h"
#endif
#include "ErrMsg.h"
#include "Event.h"
#include "GetDfrgRes.h"

static TREE_DATA TreeData;


                                

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine gets basic data about the FAT volume that the FastFat2 routines need to carry out their work.
	Most notably, this routine loads in the root dir and initializes a pass for NextFatFile() which traverses
	the disk.  NextFatFile() can be re-initialized to begin again at the beginning of the disk simply by calling
	this routine again.

INPUT + OUTPUT:
	None.

GLOBALS:
	OUT TreeData					- Initialized by this function.  Holds all the current data necessary for
									NextFatFile() to traverse the directory tree of a disk.

	IN OUT Multiple VolData fields.  Pointless to enumerate here.
	Of note:
	OUT VolData.FirstDataOffset		- The byte offset from the beginning of the disk to the data portion of the disk.
	OUT VolData.FatOffset			- The byte offset of the FAT from the beginning of the disk.

RETURN:
	TRUE - Success
	FALSE - Failure
*/

BOOLEAN
GetFatBootSector(
	)
{
	HANDLE					hBoot = NULL;
	BYTE*					pBoot = NULL;
	DWORD					ReservedSectors = 0;
	DWORD					NumberOfFats = 0;
	DWORD					SectorsPerFat = 0;
	DWORD					NumberOfRootEntries = 0;
	DWORD					dMirroring = 0;
	BOOL					bMirroring = FALSE;
	DWORD					ActiveFat = 0;
	EXTENT_LIST*			pExtentList = 0;
	LONGLONG				Cluster = 0;
	DWORD					Extent = 0;
	STREAM_EXTENT_HEADER*	pStreamExtentHeader = NULL;

	__try{


		//#Dk172_066 Divide by zero check goes here...
		EF(VolData.BytesPerSector!=0);
		
		//0.0E00 Load the boot sector 
		EF((hBoot = DasdLoadSectors(VolData.hVolume, 0, 1, VolData.BytesPerSector)) != NULL);

		EF((pBoot = (BYTE*)GlobalLock(hBoot)) != NULL);



		//1.0E00 Get data from the boot sector for this volume about where the on disk structures are.
//		bug #187823 change from casting to memcpy to avoid memory allignment errors
		ReservedSectors			= (DWORD)*((WORD*)(pBoot+0x0E));	//Total number of reserved sectors from the
		//beginning of the disk including
//		memcpy(&ReservedSectors,(pBoot+0x0E),sizeof(DWORD));	//Total number of reserved sectors from the
//				//beginning of the disk including

//		bug #187823 change from casting to memcpy to avoid memory allignment errors
																	//the boot records. 2 bytes long.
		memcpy(&NumberOfFats,(pBoot+0x10),sizeof(UCHAR));			//The number of FATs on the drive.  1 byte long.

		memcpy(&SectorsPerFat,(pBoot+0x16),sizeof(UCHAR)*2);			//The number of sectors per FAT, or 0 if this is
		
		memcpy(&VolData.FatVersion,(pBoot+0x2a),sizeof(UCHAR)*2);		//The version number of the FAT or FAT32 volume.

		

		//1.0E00 If this is a FAT volume...
		if(SectorsPerFat != 0){

//			bug #187823 change from casting to memcpy to avoid memory allignment errors
			memcpy(&NumberOfRootEntries,(pBoot+0x11),sizeof(UCHAR)*2);

		}
		//1.0E00 Otherwise this is a FAT32 volume.
		else{
			memcpy(&SectorsPerFat,(pBoot+0x24),sizeof(UCHAR)*4);		//The number of sectors per fat on a FAT32 volume.
															
			memcpy(&dMirroring,(pBoot+0x28),sizeof(UCHAR)*2);			//Extract the bit that says whether mirroring
			bMirroring			= dMirroring & 0x0080 ? FALSE : TRUE;	//of the FATs is enabled. 1=Mirroring disabled.

			memcpy(&ActiveFat,(pBoot+0x28),sizeof(UCHAR)*2);		//Extract the number of the active FAT.  Only valid
			ActiveFat = ActiveFat & 0x0007;
		}

		//1.0E00 On FAT and FAT32 volumes, FirstDataOffset points to the "zeroth" byte.  That is, if you do a
		//1.0E00 dasd read on a FAT or FAT32 volume for byte 0, you will get the actual byte number of
		//1.0E00 FirstDataOffset on the volume.  That is - byte 0 is byte 0 of the data portion of a FAT volume.
		//1.0E00 If FatSectorsPerFat is zero that indicates this is a FAT32 volume.
		if(VolData.FileSystem == FS_FAT){
			VolData.FirstDataOffset =
				(DWORD) ((ReservedSectors +				//The number of reserved sectors at the beginning of the disk.
				NumberOfFats * SectorsPerFat +			//The number of sectors in the FAT at the beginning of the disk.
				sizeof(DIRSTRUC) * NumberOfRootEntries / VolData.BytesPerSector) *		//The number of sectors in the root directory.
				VolData.BytesPerSector);				//Gives us a byte offset instead of a sector offset.
		}
		//1.0E00 This is a FAT32 volume.
		else if(VolData.FileSystem == FS_FAT32){
			VolData.FirstDataOffset = 
				(ReservedSectors +					//The number of reserved sectors at the beginning of the disk.
				(NumberOfFats * SectorsPerFat)) *	//The number of sectors in the FAT at the beginning of the disk.
				(DWORD)VolData.BytesPerSector;	//Gives us a byte offset instead of a sector offset.
		}
		else{
			EF(FALSE);
		}

		//1.0E00 We also need the offset of the FAT we will be reading from.  This is so GetExtentListManuallyFat can
		//1.0E00 load in sections of the FAT at it's discretion.
		if(VolData.FileSystem == FS_FAT){
			//1.0E00 On FAT, we'll just use the FAT -- all the data is mirrored.
			VolData.FatOffset = (LONGLONG)(ReservedSectors * (DWORD)VolData.BytesPerSector);
			VolData.FatMirrOffset = (LONGLONG)((ReservedSectors+SectorsPerFat) * (DWORD)VolData.BytesPerSector);
		}
		else if(VolData.FileSystem == FS_FAT32){
			//1.0E00 On FAT32, if mirroring is enabled, then we use the first FAT since all FAT's are identical.
			if(bMirroring){
				//1.0E00 The first FAT comes right after the reserved sectors.
				VolData.FatOffset = (LONGLONG)(ReservedSectors * (DWORD)VolData.BytesPerSector);
				VolData.FatMirrOffset = (LONGLONG)((ReservedSectors+SectorsPerFat) * (DWORD)VolData.BytesPerSector);
			}
			//1.0E00 If mirroring is disabled, then we have to use whichever FAT is the active FAT.
			else{
				//1.0E00 Use the active FAT as specified by the boot sector.
				VolData.FatOffset = (LONGLONG)((ReservedSectors + (ActiveFat * SectorsPerFat)) * VolData.BytesPerSector);
				VolData.FatMirrOffset = 0;
			}
		}

		//Initialize the TreeData structure
		ZeroMemory(&TreeData, sizeof(TREE_DATA));
		TreeData.bProcessingFiles = TRUE;

		//0.0E00 alloc mem for and read the root dir's clusters
		EF(VolData.BytesPerSector != 0);

		if(VolData.FileSystem == FS_FAT){

			//1.0E00 Read in the root directory.
			EF((TreeData.FatTreeHandles[0] = 
					DasdLoadSectors(
					VolData.hVolume,
					//The root dir resides right after the FATs.
					ReservedSectors + (NumberOfFats * SectorsPerFat),
					(NumberOfRootEntries * sizeof(DIRSTRUC)) / VolData.BytesPerSector,
					VolData.BytesPerSector)) != NULL);

			//0.0E00 get a pointer to the root dir's clusters
			EF((TreeData.pCurrentFatDir = TreeData.pCurrentEntry = (DIRSTRUC*)GlobalLock(TreeData.FatTreeHandles[0])) != NULL);
			TreeData.llCurrentFatDirLcn[0] = 0xFFFFFFFF;
		}

		//1.0E00 For FAT32 we have to create an extent list for the root directory and load it in.
		else{
			//1.0E00 Open the root directory.
			VolData.vFileName = VolData.cVolumeName;

			// put a trailing backslash to open the root dir
			VolData.vFileName += L"\\";
			VolData.bDirectory = TRUE;
			EF(OpenFatFile());

			//1.0E00 Get the extent list for the root directory.
			EF(GetExtentList(DEFAULT_STREAMS, NULL));
			pExtentList = (EXTENT_LIST*)((char*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER) + sizeof(STREAM_EXTENT_HEADER));
			pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((char*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));

			//1.0E00 Allocate the memory where we'll hold the root directory.  This will be the first entry in FatTreeHandles.
			AllocateMemory((DWORD)(VolData.NumberOfClusters*VolData.BytesPerCluster)+(DWORD)VolData.BytesPerSector, 
							&(TreeData.FatTreeHandles[0]), (void**)&(TreeData.pCurrentEntry));
			EF(TreeData.FatTreeHandles[0] != NULL);
			TreeData.pCurrentFatDir = TreeData.pCurrentEntry;
			TreeData.llCurrentFatDirLcn[0] = pExtentList->StartingLcn;

			//1.0E00 Loop through the extents of the root dir and read in each series of clusters.
			Cluster = 0;
			for(Extent=0; Extent<pStreamExtentHeader->ExtentCount; Extent++){
				EF(DasdReadClusters(VolData.hVolume,
									pExtentList[Extent].StartingLcn,
									pExtentList[Extent].ClusterCount,
									((PUCHAR)TreeData.pCurrentEntry) + (Cluster * VolData.BytesPerCluster),
									VolData.BytesPerSector,
									VolData.BytesPerCluster));
				Cluster += pExtentList[Extent].ClusterCount;
			}
		}
		wsprintf(TreeData.DirName[0], TEXT("%s\\"), VolData.cVolumeName);
	}
	__finally{
	
		if(hBoot != NULL){
            while (GlobalUnlock(hBoot)){
				;
			}
			EH_ASSERT(GlobalFree(hBoot) == NULL);
		}
	}

	return TRUE;
}							  
/*****************************************************************************************************************

This is a comment for a defunct function (no pun intended), but it contains useful data about the format of the
FAT file system.  So, I'm leaving it in here.  Zack Gainsforth 7 April 1997

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

	In order to use our hooks to get a file's extent list it is necessary to get a handle to the file.
	It is not possible to get a handle to an active pagefile.
	This makes it necessary to acquire active pagefile extent lists manually.
	To manually acquire the extent list of a FAT file requires knowing the starting cluster of the file.
	The only way to get the starting cluster of a FAT file is to look at the file's directory entry.
	Active pagefiles are always in the root directory.
	There is no directory entry anywhere for the root directory.
	The location of the root directory's clusters is indicated from fields in the boot sector.
	GetFatBootSector extracts the location of the root directory from the boot sector and loads the
	root directory's clusters.
	This routine must be called after GetFatBootSector is called and before any calls are made to
	NextFatFile.

	This routine scans through the root directory's entries looking for a file named "pagefile.sys"
	using case insensitive compares. When such a file is found an attempt is made to open the file.
	If the open succeeds it is not an active pagefile and can therefore be processed the same way as
	all the other files on the volume.
	If the open fails it is an active pagefile (hopefully) so manual acquisition of the file's 
	extent list begins.

	The FAT (File Allocation Table) contains one entry for each data cluster on the disk plus 2 
	entries at the beginning which are actually used to indicate the volume type: Floppy, fixed, etc.
	FAT entry 2 references the first data cluster on the disk, entry 3 the 2nd, etc.
	The first data cluster on the disk is located by adding the number of boot sectors (always 1) 
	to the number of FATS (always 2) times sectors per FAT (varies) and number of root directory 
	sectors. The first sector of the first data cluster is NOT always a multiple of the sectors per 
	cluster for the volume.
	FAT entries are either 12 or 16-bits each and all FAT entries on a volume are are the same size. 
	Most volumes have 16-bit FATs since only VERY small volumes (about 10 mb or less) have 12-bit FATs.
	A 16-bit FAT uses 2 bytes to represent each cluster on the volume and a 12-bit FAT shares each
	3-byte set with 2 clusters or one byte and one nibble of another byte per volume cluster.
	All volumes with less than 4087 total clusters have 12-bit FATs and all others are 16-bit.

	Each FAT entry contains either a code or the cluster number of the next cluster of the file.
	The codes are: 0 = free cluster (since the first data cluster is FAT entry 2 [cluster 2] there 
	is no cluster 0); FFF8-FFFF (or FF8-FFF in 12-bit FATS) is last cluster in a file; xxx through xxx are
	bad clusters.
	Files are recorded as "cluster chains" with the first cluster of the file in the file's directory
	entry, the FAT entry for the file's first cluster containing the cluster number of the file's 
	second cluster, the FAT entry for the file's second cluster containing the cluster number of the 
	file's third cluster, etc. and the FAT entry for the file's last cluster containing FFF8-FFFF (or FF8-FFF 
	in 12-bit FATS).
	
	To manually build an extent list for a FAT file the file's cluster chain is scanned and all clusters
	that are adjacent to each other are considered an extent.

	The extent list will be used by the Windows NT OS and filesystems. Although NT and DOS both are
	products of Microsoft, DOS (and FAT volume dir entries and the FATs) views the first data cluster
	on a FAT volume as cluster number 2 but NT views it as cluster number 0 (for compatibility with NTFS).
	So after the extent list is built 2 is subtracted from all cluster numbers in the list.

*/

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This function steps through the directory tree of the FAT disk and returns a new filename each time
	it is called.  It automatically remembers its position in the tree between calls.

INPUT + OUTPUT:
	None.

GLOBALS:
	IN OUT TreeData			- Holds all the current data necessary to traverse the tree.
	IN VolData.FileSystem	- Whether this is a FAT or FAT32
	OUT VolData.bDirectory	- Whether the file found was a directory or not.
	OUT VolData.FileSize	- The size in bytes of the file found.
	OUT VolData.StartingLcn	- The first LCN of the file found.

RETURN:
	Success - TRUE
	Failure - FALSE

	On Success:
		VolData.vFileName contains the filename of the next file, or a zero-length string if no more files.
*/

BOOL
NextFatFile(
	)
{	   
	//0.0E00 Until we've found a file or hit the end of the disk
	while(TRUE){
		if(TreeData.bProcessingFiles){
			//0.0E00 Step through each entry in the current FAT dir.
			while(TRUE){
				//0.0E00 IF no more entries,
				if(TreeData.pCurrentEntry->Name[0] == EndOfDirectory){
					//0.0E00 Strip FAT dir of anything except subdir entries. (StripDir)
					EF(StripDir(&TreeData, KEEP_DIRECTORIES));
					//0.0E00 Set bProcessingFiles = FALSE so we will process directories.
					TreeData.bProcessingFiles = FALSE;
					TreeData.pCurrentEntry = TreeData.pCurrentFatDir;
					break;
				}
				if(TreeData.pCurrentEntry->Name[0] == Deleted){
					TreeData.pCurrentEntry++;
					continue;
				}
				//0.0E00 IF this entry is a file
				if(!(TreeData.pCurrentEntry->Attribute & LabelAttribute) &&
					TreeData.pCurrentEntry->Attribute != UnicodeAttribute){
					//0.0E00 Fill in VolData + return
					VolData.bDirectory = (TreeData.pCurrentEntry->Attribute & DirAttribute) ? TRUE : FALSE;
					VolData.FileSize = TreeData.pCurrentEntry->FileSize;
					//0.0E00 If this is a FAT volume.
					if(VolData.FileSystem == FS_FAT){
						VolData.StartingLcn = TreeData.pCurrentEntry->ClusterLow;
					}
					//1.0E00 Otherwise it is FAT32
					else{
						VolData.StartingLcn = (LONGLONG)((DWORD)TreeData.pCurrentEntry->ClusterLow | (DWORD)(TreeData.pCurrentEntry->ClusterHigh << 16));
					}
#ifdef OFFLINEDK
					//If the StartingLcn is set to zero, then this is a small file (no clusters).
					if(VolData.StartingLcn == 0){
						//Set the StartingLcn to an invalid cluster number.
						VolData.StartingLcn = 0xFFFFFFFF;
					}
					else{
						//Otherwise change the StartingLcn to the correct Lcn (handle the FAT cluster number offset of 2).
						VolData.StartingLcn -= 2;
					}
					//0.0E00 Store the Lcn of the parent directory to this file (so other code can load the directory and read the entry if it likes).
					VolData.MasterLcn = TreeData.llCurrentFatDirLcn[TreeData.dwCurrentLevel];
#endif

#ifndef OFFLINEDK
					//0.0E00 If the StartingLcn is past the end of the disk, or the file size is greater than the disk, the disk is corrupt.
					//0.0E00 +2 because the FAT LCNs start from 2.  So if there are 10 cluster #'s, the highest possible is 12.
					if (VolData.StartingLcn > VolData.TotalClusters+2 || 
						VolData.FileSize > (VolData.TotalClusters+2) * VolData.BytesPerCluster){

						VString formatString(IDMSG_CORRUPT_DISK, GetDfrgResHandle());
						TCHAR szMsg[500];
						DWORD_PTR dwParams[2];
						dwParams[0] = (DWORD_PTR)VolData.cDisplayLabel;
						dwParams[1] = 0;

						//0.0E00 Print out a user friendly message.
						//0.0E00 IDMSG_CORRUPT_DISK - "Diskeeper has detected corruption on drive %s:\nPlease run chkdsk /f"
						EF(FormatMessage(
							FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
							formatString.GetBuffer(),
							0,
							0,
							szMsg,
							sizeof(szMsg)/sizeof(TCHAR),
							(va_list*)dwParams));

						SendErrData(szMsg, ENGERR_GENERAL);
						EF(LogEvent(MSG_ENGINE_ERROR, szMsg));

						//0.0E00 Also print out a techie message.
						EF(FALSE);
					}
#endif
					EF(GetUnicodePath(&TreeData, VolData.vFileName));
					TreeData.pCurrentEntry++;
					return TRUE;
				}
				//0.0E00 ELSE ignore the entry -- point to the next.
				TreeData.pCurrentEntry++;
			}
		}
		else { //if(!TreeData.bProcessingFiles){
			//0.0E00 Step through each entry in the current FAT dir.
			while(TRUE){
				//0.0E00 IF no more entries,
				if(TreeData.pCurrentEntry->Name[0] == EndOfDirectory){
					//0.0E00 IF in root dir, return finished code.
					if(TreeData.dwCurrentLevel == 0){
						VolData.vFileName.Empty();
                        EF(TreeData.FatTreeHandles[TreeData.dwCurrentLevel] != NULL);
						// this one is sometimes locked more than once
						while (GlobalUnlock(TreeData.FatTreeHandles[TreeData.dwCurrentLevel])){
							;
						}
						EH_ASSERT(GlobalFree(TreeData.FatTreeHandles[TreeData.dwCurrentLevel]) == NULL);
						TreeData.FatTreeHandles[TreeData.dwCurrentLevel] = NULL;
						TreeData.DirName[TreeData.dwCurrentLevel][0] = 0;
						TreeData.llCurrentFatDirLcn[TreeData.dwCurrentLevel] = 0;
						return TRUE;
					}
					//0.0E00 ELSE Step up one directory in the chain.
					else{
                        EF(TreeData.FatTreeHandles[TreeData.dwCurrentLevel] != NULL);
                        EH_ASSERT(GlobalUnlock(TreeData.FatTreeHandles[TreeData.dwCurrentLevel]) == FALSE);
						EH_ASSERT(GlobalFree(TreeData.FatTreeHandles[TreeData.dwCurrentLevel]) == NULL);
						TreeData.FatTreeHandles[TreeData.dwCurrentLevel] = NULL;
						TreeData.DirName[TreeData.dwCurrentLevel][0] = 0;
						TreeData.llCurrentFatDirLcn[TreeData.dwCurrentLevel] = 0;
						TreeData.dwCurrentLevel--;
                        EF(TreeData.FatTreeHandles[TreeData.dwCurrentLevel] != NULL);
						TreeData.pCurrentEntry = TreeData.pCurrentFatDir = (DIRSTRUC*)GlobalLock(TreeData.FatTreeHandles[TreeData.dwCurrentLevel]);
						TreeData.pCurrentEntry += TreeData.CurrentEntryPos[TreeData.dwCurrentLevel];
						TreeData.bMovedUp = TRUE;
					}
					continue;
				}
				//0.0E00 IF this entry is a directory
				if(TreeData.pCurrentEntry->Attribute & DirAttribute){
					//0.0E00 Step into it.
					EF(LoadDir(&TreeData));
					if(VolData.vFileName.GetLength() == 0){
						TreeData.pCurrentEntry++;
						continue;
					}
					break;
				}
				//0.0E00 ELSE ignore the entry -- point to the next.
				TreeData.pCurrentEntry++;
			}
		}
	}
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	Removes undesired entries in a FAT directory.  It does this by scooting desired entries up over undesired entries.

INPUT + OUTPUT:
	IN OUT pTreeData	- Contains the FAT directory to strip.
	IN dwFlags			- Indicates flags for which type of entries to keep,  The flags are KEEP_DIRECTORIES and KEEP_FILES.

GLOBALS:
	None.

RETURN:
	Success - TRUE
	Failure - FALSE
*/

BOOL
StripDir(
	IN OUT TREE_DATA* pTreeData,
	IN DWORD dwFlags
	)
{
	CHAR * pDest;		//0.0E00 Where the MoveMemory will move to.
	CHAR * pStart;		//0.0E00 The start of where we're moving from (the first unicode entry, for example)
	CHAR * pEnd;		//0.0E00 The end of where we're moving from (just after the normal fat entry, for example)

	//0.0E00 Set everything to point to the beginning of the FAT dir.
	pTreeData->pCurrentEntry = pTreeData->pCurrentFatDir;
	pDest = (CHAR*)pTreeData->pCurrentEntry;
	pStart = pEnd = pDest;

	//0.0E00 Step through each entry in the current FAT dir
	while(pTreeData->pCurrentEntry->Name[0] != EndOfDirectory){
		//0.0E00 Keep track of the last entry we are keeping per dwFlags.
		//0.0E00 If this is an entry to keep per dwFlags, MoveMemory it just below the last entry.

		//0.0E00 IF it's deleted, and we are not keeping deleted files strip it.
		if((!(dwFlags & KEEP_DELFILES)) &&
           (!(dwFlags & KEEP_DELDIRECTORIES)) &&
           (TreeData.pCurrentEntry->Name[0] == Deleted) ) {
			//0.0E00 Look at the next entry next.
			pTreeData->pCurrentEntry++;
			pEnd += sizeof(DIRSTRUC);
			pStart = pEnd;
		}
		//0.0E00 IF it's a unicode entry update the pEnd pointer, we don't know yet whether or not to keep it.
		else if(pTreeData->pCurrentEntry->Attribute == UnicodeAttribute){
			//0.0E00 Look at the next entry next.
			pTreeData->pCurrentEntry++;
			pEnd += sizeof(DIRSTRUC);
		}
		//0.0E00 IF it's a dir attribute and we're supposed to keep dirs per dwFlags, keep it.
		else if(pTreeData->pCurrentEntry->Attribute & DirAttribute &&
			dwFlags & KEEP_DIRECTORIES &&
			pTreeData->pCurrentEntry->Name[0] != TEXT('.')){		//Don't keep the . and .. directories.
			//0.0E00 Look at the next entry next.
			pTreeData->pCurrentEntry++;
			pEnd += sizeof(DIRSTRUC);
			//0.0E00 Do the MoveMemory as long as we're not moving it to the same place it already is.
			if(pDest != pStart){
				MoveMemory(pDest, pStart, pEnd-pStart);
			}
			pDest += pEnd-pStart;
			pStart = pEnd;
		}
		//0.0E00 IF it's a file attribute and we're supposed to keep files per dwFlags, keep it.
		else if(!(TreeData.pCurrentEntry->Attribute & LabelAttribute) &&
				!(TreeData.pCurrentEntry->Attribute & DirAttribute) &&
				TreeData.pCurrentEntry->Attribute != UnicodeAttribute &&
			    ((dwFlags & KEEP_FILES) || (dwFlags & KEEP_DELFILES))) {

            //0.0E01 Check if we want to skip Deleted files or Active Files.
            if ( (!(dwFlags & KEEP_DELFILES) && (TreeData.pCurrentEntry->Name[0] == Deleted)) ||
                (!(dwFlags & KEEP_FILES) && !(TreeData.pCurrentEntry->Name[0] == Deleted)) ) {
                // Yes, skip this entry
        		pTreeData->pCurrentEntry++;
	        	pEnd += sizeof(DIRSTRUC);
    	    	pStart = pEnd;
            }
            else {
                //0.0E01 No, Save this entry
                //0.0E00 Look at the next entry next.
        		pTreeData->pCurrentEntry++;
	        	pEnd += sizeof(DIRSTRUC);
                // Save this entry
		    	//0.0E00 Do the MoveMemory as long as we're not moving it to the same place it already is.
			    if(pDest != pStart){
				    MoveMemory(pDest, pStart, pEnd-pStart);
                }
    		    pDest += pEnd-pStart;
    	    	pStart = pEnd;
    	    }
		}
		//0.0E00 This is an entry that we strip, so just update the pointers.
		else{
			//0.0E00 Look at the next entry next.
			pTreeData->pCurrentEntry++;
			pEnd += sizeof(DIRSTRUC);
			pStart = pEnd;
		}
	}
	//0.0E00 When the whole FAT dir is done, copy the null entry at the end.
	if(pDest != pStart){
		pEnd += sizeof(DIRSTRUC);
		MoveMemory(pDest, pStart, pEnd-pStart);
		pDest += pEnd-pStart;
	}
	//0.0E00 Reset pointers and variables in pTreeData.
	pTreeData->pCurrentEntry = pTreeData->pCurrentFatDir;
	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	Goes down one level in the directory tree.  It takes the current directory entry and
	opens it up and sets all the pointers and variables to point there.

INPUT + OUTPUT:
	IN OUT pTreeData		- Holds all the pointers and variable changes.

GLOBALS:
	OUT VolData.vFileName	- The name of the directory found.

RETURN:
	Success - TRUE
	Failure - FALSE
*/

BOOL
LoadDir(
	IN TREE_DATA* pTreeData
	)
{
	LONGLONG				Cluster;
	PEXTENT_LIST			pExtentList;
	DWORD					Extent;
	VString					fileName;
	STREAM_EXTENT_HEADER*	pStreamExtentHeader = NULL;

	//0.0E00 Loop through the current directory until a directory entry that can be opened pops up.
	while(TRUE){
		//0.0E00 If this is the end of the directory, return
		if(pTreeData->pCurrentEntry->Name[0] == EndOfDirectory){
			VolData.vFileName.Empty();
			return TRUE;
		}
			
		//#DK183_008
		//0.0E00 IF this entry is a file
    	if(!(pTreeData->pCurrentEntry->Attribute & LabelAttribute) &&
			pTreeData->pCurrentEntry->Attribute != UnicodeAttribute){	

			GetUnicodeName(pTreeData, fileName);

			//#Dk183_008
		    //0.0E00 Skip this directory if it is the . or .. directory since we can't open them.
		    if(fileName != L"." && fileName != L"..") {
		    	break;
		    }
        }

		//0.0E00 Go to the next entry.
		pTreeData->pCurrentEntry++;
	}

	//0.0E00 Get the pull path for this directory.
	GetUnicodePath(pTreeData, VolData.vFileName);

	//0.0E00 Put this directory's name in the next level in the TreeData structure.
	lstrcpy(pTreeData->DirName[pTreeData->dwCurrentLevel+1], fileName.GetBuffer());
	lstrcat(pTreeData->DirName[pTreeData->dwCurrentLevel+1], TEXT("\\"));

	//0.0E00 Note that this is a directory.
	VolData.bDirectory = TRUE;

#ifndef OFFLINEDK
	//0.0E00 Open the directory.
	if(!OpenFatFile()){

		//0.0E00 If it won't open, error out...
		EH(FALSE);

		//0.0E00 And clean up so that other directories can be loaded in the future.
		VolData.vFileName.Empty();
		pTreeData->DirName[pTreeData->dwCurrentLevel+1][0] = 0;		//Don't leave this directory's name in the TreeData.
		return TRUE;
	}

	//0.0E00 Get the extent list for this directory.
	EF(GetExtentList(DEFAULT_STREAMS, NULL));
#else
	//0.0E00 If this is a FAT volume.
	//0.0E00 Load the starting Lcn for this directory file.
	if(VolData.FileSystem == FS_FAT){
		VolData.StartingLcn = TreeData.pCurrentEntry->ClusterLow;
	}
	//1.0E00 Otherwise it is FAT32
	else{
		VolData.StartingLcn = (LONGLONG)((DWORD)TreeData.pCurrentEntry->ClusterLow | (DWORD)(TreeData.pCurrentEntry->ClusterHigh << 16));
	}
	VolData.StartingLcn -= 2;

	//0.0E00 Get the extent list for this directory.
	EF(GetExtentListManuallyFat());
#endif

	pExtentList = (EXTENT_LIST*)((char*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER) + sizeof(STREAM_EXTENT_HEADER));
	pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((char*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));

	//0.0E00 Set the pTreeData variables to point one level down.
	pTreeData->CurrentEntryPos[pTreeData->dwCurrentLevel] = (ULONG)(pTreeData->pCurrentEntry - pTreeData->pCurrentFatDir) + 1;
	GlobalUnlock(pTreeData->FatTreeHandles[pTreeData->dwCurrentLevel]);
	pTreeData->dwCurrentLevel++;
	pTreeData->bMovedUp = FALSE;
	pTreeData->bProcessingFiles = TRUE;
	pTreeData->pCurrentEntry = pTreeData->pCurrentFatDir = 0;
	pTreeData->FatTreeHandles[pTreeData->dwCurrentLevel] = NULL;
	pTreeData->llCurrentFatDirLcn[pTreeData->dwCurrentLevel] = pExtentList->StartingLcn;

	//0.0E00 Allocate memory for the FAT dir.
	EF(AllocateMemory((DWORD)((VolData.NumberOfClusters * VolData.BytesPerCluster) + VolData.BytesPerSector),
					  &pTreeData->FatTreeHandles[pTreeData->dwCurrentLevel],
					  (void**)&pTreeData->pCurrentFatDir));
	pTreeData->pCurrentEntry = pTreeData->pCurrentFatDir;

	//0.0E00 Load the FAT dir from disk, extent by extent.
	Cluster = 0;
	for(Extent = 0; Extent < pStreamExtentHeader->ExtentCount; Extent ++){

#ifndef OFFLINEDK
		//0.0E00 If the StartingLcn is past the end of the disk, or the file size is greater than the disk, the disk is corrupt.
		//0.0E00 +2 because the FAT LCNs start from 2.  So if there are 10 cluster #'s, the highest possible is 12.
		if (VolData.StartingLcn > VolData.TotalClusters+2 || 
			VolData.FileSize > (VolData.TotalClusters+2) * VolData.BytesPerCluster) {
			TCHAR cString[500];
			TCHAR szMsg[500];
			DWORD_PTR dwParams[10];

			//0.0E00 Print out a user friendly message.
			//0.0E00 IDMSG_CORRUPT_DISK - "Diskeeper has detected corruption on drive %s:  Please run chkdsk /f"
			dwParams[0] = (DWORD_PTR)VolData.cDisplayLabel;
			dwParams[1] = 0;
			EF(FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					GetString(szMsg, sizeof(szMsg)/sizeof(TCHAR), IDMSG_CORRUPT_DISK, GetDfrgResHandle()),
					0,
					0,
					cString,
					sizeof(cString)/sizeof(TCHAR),
					(va_list*)dwParams));

			SendErrData(cString, ENGERR_GENERAL);
			EF(LogEvent(MSG_ENGINE_ERROR, cString));

			//0.0E00 Also print out a techie message.
			EF(FALSE);
		}
#endif

		EF(DasdReadClusters(VolData.hVolume,
							pExtentList[Extent].StartingLcn,
							pExtentList[Extent].ClusterCount,
							((PUCHAR)pTreeData->pCurrentFatDir) + (Cluster * VolData.BytesPerCluster),
							VolData.BytesPerSector,
							VolData.BytesPerCluster));
		Cluster += pExtentList[Extent].ClusterCount;
	}

	//0.0E00 Strip unused entries (keep files and directories).
	EF(StripDir(pTreeData, KEEP_FILES|KEEP_DIRECTORIES));

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	Gets the complete unicode name from the FAT entries.

INPUT + OUTPUT:
	IN OUT pTreeData - Holds pointers to the FAT entries.
	OUT pUnicodeName - Where we store the file name when done.	

GLOBALS:
	None.

RETURN:
	Success - TRUE
	Failure - FALSE
*/

BOOL
GetUnicodeName(
	IN OUT TREE_DATA* pTreeData,
	IN VString &unicodeName
	)
{
	DWORD s, d;
	TCHAR Dest[2*MAX_PATH + 2];		//0.0E00 Use local buffer before conversion
	char * Source;
	int i, j;

	//0.0E00 Check to see if there are unicode entries before this entry.
	//#DK188_063 and if the previous entry is deleted. 
	if(pTreeData->pCurrentEntry > pTreeData->pCurrentFatDir &&
		pTreeData->pCurrentEntry[-1].Attribute == UnicodeAttribute &&
		pTreeData->pCurrentEntry[-1].Name[0] != Deleted) {

		//0.0E00 i is the offset from the normal FAT entry to the current unicode entry.
		i = -1;
		//0.0E00 is the offset in dest, for our current unicode name.
		j = 0;
		//0.0E00 Do while there are more unicode entries before the current entry.
		do{
			//0.0E00 Read the unicode out of one entry into a local buffer.
			//0.0E00 These are the bytes used out of the FAT entries.  Not all bytes in an entry
			//hold unicode for the filename.
			CopyMemory(Dest+j, pTreeData->pCurrentEntry[i].Name+1, 10);
			j += 10 / sizeof(TCHAR);
			CopyMemory(Dest+j, &(pTreeData->pCurrentEntry[i].Reserved)+2, 12);
			j += 12 / sizeof(TCHAR);
			CopyMemory(Dest+j, (char*)&(pTreeData->pCurrentEntry[i].FileSize), 4);
			j += 4 / sizeof(TCHAR);
			//0.0E00 Backup one entry.
			i--;
		//#DK186_053 Fixed so that it does not loop infinitely.
		//Check to see if there are unicode entries before this entry.
		//#DK188_063 check to see if the previous entry is deleted.
		}while( (&pTreeData->pCurrentEntry[i] >= pTreeData->pCurrentFatDir) &&
                (pTreeData->pCurrentEntry[i].Attribute == UnicodeAttribute) &&
                ((pTreeData->pCurrentEntry[i+1].Name[0] & 0xF0) != 0x40) &&
				(pTreeData->pCurrentEntry[i].Name[0] != Deleted) );

		//0.0E00 Add a terminator to the end of the unicode string in case there isn't one already.
		Dest[j++] = 0;
		Dest[j] = 0;

		//0.0E00 When all entries have been loaded into our local buffer.
		unicodeName = Dest;
	}
	//0.0E00 If no unicode entries then just use the 8.3 name.
	else{
		Source = (char*)pTreeData->pCurrentEntry;

		//0.0E00 copy each filename char except for spaces
		for(s = d = 0; s < 8; s ++){
			if(Source[s] != ' '){
				Dest[d ++] = Source[s];
			}
		}
		//0.0E00 if file extension doesn't start with space, add "." between name and ext
		//0.0E00 then copy each extension char except for spaces
		if(Source[s] != ' '){
			for(Dest[d ++] = TEXT('.'); s < 11; s ++){
				if(Source[s] != ' '){
					Dest[d ++] = Source[s];
				}
			}
		}
		//0.0E00 terminate the string
		Dest[d] = 0;			
	
		unicodeName = Dest;
	}

	//0.0E00 Return ASCII string.
	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	Gets the complete unicode path and filename from the FAT entries.
	The path is derived from pTreeData structures.

INPUT + OUTPUT:
	IN pTreeData		- Holds pointers to the FAT entries.
	OUT pUnicodeName	- Where we store the file name when done.	

GLOBALS:
	None.

RETURN:
	Success - TRUE
	Failure - FALSE
*/

BOOL
GetUnicodePath(
	IN TREE_DATA* pTreeData,
	OUT VString &unicodePath
	)
{
	VString unicodeName;

	// Get the unicode name first.
	EF(GetUnicodeName(pTreeData, unicodeName));

	// Build the full path\name for the dir
	unicodePath.Empty();
	for(int i = 0; wcslen(pTreeData->DirName[i]); i ++){
		unicodePath += pTreeData->DirName[i];
	}
	if (unicodeName.IsEmpty() == FALSE) {
		unicodePath += unicodeName;
	}
		  	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\fatsubs.cpp ===
/****************************************************************************************************************

File Name: FatSubs.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

Description: FAT file system interfaces

/***************************************************************************************************************/

#include "stdafx.h"
extern "C"{
#include <stdio.h>
}

#ifdef BOOTIME
    #include "Offline.h"
#else
    #include <Windows.h>
#endif

#include <winioctl.h>

extern "C"{
    #include "SysStruc.h"
}

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"

#include "ErrMacro.h"
#include "DasdRead.h"
#include "ErrMsg.h"
#include "Alloc.h"
#include "IntFuncs.h"
#include "FatSubs.h"
#include "DevIo.h"
#include "FsSubs.h"
#include "GetDfrgRes.h"
#include "getreg.h"

extern HWND hWndMain;

#define BOOT_OPTIMIZE_REGISTRY_PATH             TEXT("SOFTWARE\\Microsoft\\Dfrg\\BootOptimizeFunction")
#define BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION TEXT("LcnStartLocation")
#define BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION   TEXT("LcnEndLocation")
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
  Gets the parameters of a volume and puts them into the VolData.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
GetFatVolumeStats(
    )
{
    //TCHAR cVolume[8] = TEXT("\\\\.\\");
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD FreeClusters;
    DWORD TotalNumberOfClusters;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus = {0};
    FILE_FS_SIZE_INFORMATION FsSizeBuf = {0};

    VolData.hVolume = INVALID_HANDLE_VALUE;
    VolData.hFile = INVALID_HANDLE_VALUE;

#ifdef OFFLINEDK
    //0.1E00 Get the file system on this drive.
    EF(GetFileSystem(VolData.cVolumeName, &VolData.FileSystem));

    if(VolData.FileSystem == FS_FAT32){
        wprintf(L"\nError - FAT32 is not supported.\n"); // todo Is this still true?
        return FALSE;
    }
#else
    //0.1E00 Get the file system on this drive.
    EF(GetFileSystem(VolData.cVolumeName, &VolData.FileSystem, VolData.cVolumeLabel));
#endif

    //1.0E00 Check to see if this is anything other than FAT or FAT32, and if so, bail out.
    if(VolData.FileSystem != FS_FAT && VolData.FileSystem != FS_FAT32){
        return FALSE;
    }

    //0.0E00 Get handle to volume
    VolData.hVolume = CreateFile(
        VolData.cVolumeName,
        GENERIC_READ,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
        NULL);
        
    EF_ASSERT(VolData.hVolume != INVALID_HANDLE_VALUE);

    //bug #120872 sks
    TCHAR tmpVolumeName[GUID_LENGTH+1];
    _stprintf(tmpVolumeName,TEXT("%s%s"),VolData.cVolumeName,TEXT("\\"));

    if(!GetDiskFreeSpace(
        tmpVolumeName,
        &SectorsPerCluster,
        &BytesPerSector,
        &FreeClusters,
        &TotalNumberOfClusters
        ))
    {

        EF_ASSERT(FALSE);
    }

    //0.0E00 Fill volume statistics structure
    VolData.BytesPerSector      = BytesPerSector;
    VolData.SectorsPerCluster   = SectorsPerCluster;
    VolData.TotalSectors        = TotalNumberOfClusters * SectorsPerCluster;
    VolData.BytesPerCluster     = BytesPerSector * SectorsPerCluster;
    VolData.TotalClusters       = TotalNumberOfClusters;
    VolData.MftZoneStart        = 0;
    VolData.MftZoneEnd          = 0;
    VolData.bCompressed         = FALSE;
    VolData.bFragmented         = FALSE;
    VolData.UsedClusters        = TotalNumberOfClusters - FreeClusters;
    VolData.CenterOfDisk        = TotalNumberOfClusters / 2;

    //0.0E00 Compute number of bits needed for bitmap
    //bug 120782 SKS
    VolData.BitmapSize = (((VolData.TotalClusters /32) +
                         ((VolData.TotalClusters  % 32) ? 1 : 0)) + 1) * 32;


    VolData.BootOptimizeBeginClusterExclude = 0;
    VolData.BootOptimizeEndClusterExclude = 0;
    if (IsBootVolume(VolData.cDrive)) {
        //get the registry value for BootOptimizeBeginClusterExclude
        HKEY hValue = NULL;
        DWORD dwRegValueSize = 0;
        long ret = 0;
        TCHAR cRegValue[100];


        // get Boot Optimize Begin Cluster Exclude from registry
        dwRegValueSize = sizeof(cRegValue);
        ret = GetRegValue(
            &hValue,
            BOOT_OPTIMIZE_REGISTRY_PATH,
            BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION,
            cRegValue,
            &dwRegValueSize);

        RegCloseKey(hValue);
        //check to see if the key exists, else exit from routine
        if (ret == ERROR_SUCCESS) {
            VolData.BootOptimizeBeginClusterExclude = _ttoi(cRegValue);
        }
        
        // get Boot Optimize End Cluster Exclude from registry
        hValue = NULL;
        dwRegValueSize = sizeof(cRegValue);
        ret = GetRegValue(
            &hValue,
            BOOT_OPTIMIZE_REGISTRY_PATH,
            BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION,
            cRegValue,
            &dwRegValueSize);

        RegCloseKey(hValue);
        //check to see if the key exists, else exit from routine
        if (ret == ERROR_SUCCESS) {
            VolData.BootOptimizeEndClusterExclude = _ttoi(cRegValue);
        }
    }

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
  Gets the extent list for a file.

DATA STRUCTURES:
    //0.1E00 The following is the format for each retrieval pointer in the retrieval pointer buffer.
    //0.1E00 See winioctl.h RETRIEVAL_POINTERS_BUFFER for complete definition.
    //struct {
    //  LARGE_INTEGER NextVcn;  //Vcn for *next* extent.
    //  LARGE_INTEGER Lcn;      //Lcn for this extent.
    /};

GLOBAL VARIABLES:

INPUT:
    TypeCode - Contains a value of $DATA or $INDEX_ALLOCATION depending on whether this file is a data file or a directory.
                NOTE - TYPECODE IS NO LONGER USED!!!    But it is left in so as to not invalidate
                                                        old calls to GetExtentList.
RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
GetExtentList(
    DWORD dwEnabledStreams,
    FILE_RECORD_SEGMENT_HEADER* pFrs
    )
{
    STARTING_VCN_INPUT_BUFFER       StartingVcnInputBuffer;
    HANDLE                          hRetrievalPointersBuffer = NULL;
    PRETRIEVAL_POINTERS_BUFFER      pRetrievalPointersBuffer = NULL;
    PLARGE_INTEGER                  pRetrievalPointers = NULL;
    LONGLONG                        Extent;
    LONGLONG                        Vcn = 0;
    ULONG                           BytesReturned = 0;
    EXTENT_LIST_DATA                ExtentData;
    ULONG                           RetrievalPointers = 0x100;
    EXTENT_LIST*                    pExtentList = NULL;

    //Set up the Extent pointers structure to fill in the extent list in VolData.
    ZeroMemory(&ExtentData, sizeof(EXTENT_LIST_DATA));
    ExtentData.hExtents = VolData.hExtentList;
    ExtentData.pExtents = VolData.pExtentList;
    ExtentData.ExtentListAlloced = (DWORD)VolData.ExtentListAlloced;
    ExtentData.ExtentListSize = 0;
    ExtentData.dwEnabledStreams = dwEnabledStreams;
    ExtentData.BytesRead = 0;
    ExtentData.TotalClusters = 0;

    //Note that on FAT and FAT32, files may only have either one or no streams.

    //Initialize the FILE_EXTENT_HEADER structure.
    ExtentData.pFileExtentHeader = (FILE_EXTENT_HEADER*)ExtentData.pExtents;
    ExtentData.pFileExtentHeader->FileRecordNumber = 0;     //There is no FileRecordNumber on FAT.
    ExtentData.pFileExtentHeader->NumberOfStreams = 0;      //Contains the number of streams with extents.
    ExtentData.pFileExtentHeader->TotalNumberOfStreams = 0; //Contains the total number of streams.
    ExtentData.pFileExtentHeader->ExcessExtents = 0;

    //Initialize the FILE_STREAM_HEADER structure.
    ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((char*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));
    ExtentData.pStreamExtentHeader->StreamNumber = 0;
    ExtentData.pStreamExtentHeader->ExtentCount = 0;
    ExtentData.pStreamExtentHeader->ExcessExtents = 0;
    ExtentData.pStreamExtentHeader->AllocatedLength = 0;
    ExtentData.pStreamExtentHeader->FileSize = 0;

    //Initialize the pointer to the extent list itself.
    pExtentList = (EXTENT_LIST*)((char*)ExtentData.pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

    //Initialize the VolData fields.
    //The file size is predetermined by the time this routine is called.  Therefore, we
    VolData.bFragmented = FALSE;
    VolData.bCompressed = FALSE;
    VolData.NumberOfClusters = 0;
    VolData.NumberOfRealClusters = 0;
    VolData.NumberOfFragments = 0;
    VolData.FileSize = 0;

    __try{

        ZeroMemory(&StartingVcnInputBuffer, sizeof(STARTING_VCN_INPUT_BUFFER));
        
        //0.1E00 Read the retrieval pointers into a buffer in memory.
        while(TRUE){
        
            //0.0E00 Allocate a RetrievalPointersBuffer.
            EF(AllocateMemory(sizeof(RETRIEVAL_POINTERS_BUFFER) + (RetrievalPointers * 2 * sizeof(LARGE_INTEGER)),
                              &hRetrievalPointersBuffer,
                              (void**)(PCHAR*)&pRetrievalPointersBuffer));

            //0.0E00 Get extent list / determine extent count.
            if(ESDeviceIoControl(VolData.hFile,
                                 FSCTL_GET_RETRIEVAL_POINTERS,
                                 &StartingVcnInputBuffer,
                                 sizeof(STARTING_VCN_INPUT_BUFFER),
                                 pRetrievalPointersBuffer,
                                 (DWORD)GlobalSize(hRetrievalPointersBuffer),
                                 &BytesReturned,
                                 NULL)){
                break;
            }

            //This occurs on a zero length file (no clusters allocated).
            if(GetLastError() == ERROR_HANDLE_EOF){
                //Clean out the extent list.
                ZeroMemory(VolData.pExtentList, (DWORD)VolData.ExtentListAlloced);
                break;
            }

            //0.0E00 Check to see if the error is not because the buffer is too small.
            EF(GetLastError() == ERROR_MORE_DATA);

            //0.1E00 Double the buffer size until it's large enough to hold the file's extent list.
            RetrievalPointers *= 2;
        }

        //0.0E00 Check to ensure that extent list starts at the begining.
        if(pRetrievalPointersBuffer->StartingVcn.QuadPart != 0) {
            TCHAR cExtentVcn[64];
            SetLastError(0x20000001);
            wsprintf(cExtentVcn, TEXT("%d"), pRetrievalPointersBuffer->StartingVcn.QuadPart);
            Message(TEXT("GetExtentList - pRetrievalPointersBuffer->StartingVcn.QuadPart"),
                    0x20000001,
                    cExtentVcn);
            return FALSE;
        }
        
        //0.1E00 Store a pointer to the retrieval pointers within the retrieval pointer buffer.
        pRetrievalPointers = (PLARGE_INTEGER)&pRetrievalPointersBuffer->Extents;

        //If there aren't any extents in this file, then we're done.
        if(!pRetrievalPointersBuffer->ExtentCount){
            return TRUE;
        }

        ExtentData.pFileExtentHeader->NumberOfStreams = 1;
        ExtentData.pFileExtentHeader->TotalNumberOfStreams =1;
        ExtentData.pFileExtentHeader->ExcessExtents = pRetrievalPointersBuffer->ExtentCount - 1;

        ExtentData.pStreamExtentHeader->ExtentCount = pRetrievalPointersBuffer->ExtentCount;
        ExtentData.pStreamExtentHeader->ExcessExtents = pRetrievalPointersBuffer->ExtentCount - 1;
/**/
        // Extend the extent list buffer as necessary to hold that many extents.
        if(ExtentData.pStreamExtentHeader->ExtentCount * sizeof(EXTENT_LIST) > (size_t) VolData.ExtentListAlloced) {

            // Allocate to the new size.
            EF(AllocateMemory((DWORD)(ExtentData.pStreamExtentHeader->ExtentCount * sizeof(EXTENT_LIST)*2),
                                      &VolData.hExtentList,
                                      (void**)&VolData.pExtentList));

            // Update our pointers.
            ExtentData.hExtents = VolData.hExtentList;
            ExtentData.pExtents = VolData.pExtentList;
            ExtentData.pFileExtentHeader = (FILE_EXTENT_HEADER*)ExtentData.pExtents;
            ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((char*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));
            pExtentList = (EXTENT_LIST*)((char*)ExtentData.pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

            VolData.ExtentListAlloced = ExtentData.pStreamExtentHeader->ExtentCount * sizeof(EXTENT_LIST);

//          pExtentList = (EXTENT_LIST*)VolData.pExtentList;
        }
/**/
/** /
        //0.0E00 Extend the extent list buffer as necessary to hold that many extents.
        if(VolData.NumberOfExtents*sizeof(EXTENT_LIST) > VolData.ExtentListAlloced){
            //0.1E00 Allocate to the new size.
            EF(AllocateMemory((DWORD)(VolData.NumberOfExtents * sizeof(EXTENT_LIST)), &VolData.hExtentList, (void**)&VolData.pExtentList));
            VolData.ExtentListAlloced = VolData.NumberOfExtents * sizeof(EXTENT_LIST);

            //0.1E00 Update our pointer to the buffer.
            pExtentList = VolData.pExtentList;
        }
/**/
        //0.0E00 Convert retrieval pointers into an extent list
        for(Extent = 0; Extent < pRetrievalPointersBuffer->ExtentCount; Extent ++){
            
            //0.1E00 Pull the starting lcn out of the retrieval pointer.
            pExtentList[Extent].StartingLcn = pRetrievalPointers[1].QuadPart;
            //0.1E00 The cluster count is the starting Vcn of the next retrieval pointer minus the Vcn we're at.  That is, if the last extent was at
            //Vcn 10, and the next extent starts at Vcn 20, then the extent must be 10 clusters long.
            pExtentList[Extent].ClusterCount = pRetrievalPointers[0].QuadPart - Vcn;
            //0.1E00 Keep a running total of the number of clusters in this file.
            VolData.NumberOfClusters += pExtentList[Extent].ClusterCount;
            VolData.NumberOfRealClusters = VolData.NumberOfClusters;
            //0.1E00 The Vcn can be read directly out of the retrieval pointer.
            Vcn = pRetrievalPointers[0].QuadPart;
            //0.1E00 Go to the next retrieval pointer (2 LARGE_INTEGERS per retrieval pointer).
            pRetrievalPointers += 2;
        }

        //0.0E00 Put extent list handle and number of extents into volume's structure.
        VolData.NumberOfFragments = pRetrievalPointersBuffer->ExtentCount;
        VolData.StartingLcn = pExtentList->StartingLcn;

        //Get the file's size.
        if(VolData.bDirectory){
            //GetFileSize returns zero bytes for directories.
            VolData.FileSize = VolData.NumberOfClusters * VolData.BytesPerCluster;
        }
        else{
            EF(OpenFatFile());
            EF_ASSERT((VolData.FileSize = GetFileSize(VolData.hFile, NULL)) != 0xFFFFFFFF);
        }
        ExtentData.pStreamExtentHeader->FileSize = VolData.FileSize;
        ExtentData.pStreamExtentHeader->AllocatedLength = VolData.NumberOfClusters * VolData.BytesPerCluster;

        //0.1E00 Make sure the extent list doesn't list extents that are actually contiguous, as sometimes happens.
        //       Also, eliminate extents defining virtual cluster counts for fragmented files.
        EF(CollapseExtentList(&ExtentData));
        return TRUE;
    }
    __finally{

        if(hRetrievalPointersBuffer){
            EH_ASSERT(GlobalUnlock(hRetrievalPointersBuffer) == FALSE);
            EH_ASSERT(GlobalFree(hRetrievalPointersBuffer) == NULL);
        }
    }
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Gets the extent list for a file by manually traversing the FAT chain for that file.  I load
    in the appropriate chunks of the FAT on the fly rather than load the whole FAT into memory, since the
    whole FAT could be quite large.

    This function doesn't replace GetExtentList() above for FAT since this requires that you know the StartingLcn
    of the file.  GetExtentList() requires the file name.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN VolData.StartingLcn - The first LCN of the file.
    OUT VolData.NumberOfExtents - The number of extents in the extent list for this file.
    OUT VolData.NumberOfFragments - Same as NumberOfExtents on FAT and FAT32 (not on NTFS).
    OUT VolData.NumberOfClusters - The number of clusters allocated for this file.
    OUT VolData.hExtentList - Handle to the extent list I allocate an fill in here.
    OUT VolData.pExtentList - The pointer.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

//0.0E00 This may not be the ideal number.  This will use a maximum of 32K on even the largest FAT drive
//since that's the largest cluster size.  I didn't see any performance gain on my computer by reading
//multiple clusters.  So I saved memory instead.
#define CLUSTERS_PER_FAT_CHUNK 1

BOOL
GetExtentListManuallyFat(
    )
{
    LONGLONG            Cluster = 0;
    DWORD               FatChunkNum = 0;
    DWORD               LastFatChunkNum = 0;
    DWORD               EntriesPerChunk = 0;
    HANDLE              hFat = NULL;
    BYTE*               pFat = NULL;
    EXTENT_LIST*        pExtentList = NULL;
    DWORD               Extent = 0;
    USHORT              uEntry = 0;
    DWORD               dwEntry = 0;
    LONGLONG            llNumOfClusters = 0;
    EXTENT_LIST_DATA    ExtentData;
    DWORD               NumberOfExtents = 0;

    //Set up the Extent pointers structure to fill in the extent list in VolData.
    ZeroMemory(&ExtentData, sizeof(EXTENT_LIST_DATA));
    ExtentData.hExtents = VolData.hExtentList;
    ExtentData.pExtents = VolData.pExtentList;
    ExtentData.ExtentListAlloced = (DWORD)VolData.ExtentListAlloced;
    ExtentData.ExtentListSize = 0;
    ExtentData.dwEnabledStreams = FALSE;
    ExtentData.BytesRead = 0;
    ExtentData.TotalClusters = 0;

    //Note that on FAT and FAT32, files may only have either one or no streams.

    //Initialize the FILE_EXTENT_HEADER structure.
    ExtentData.pFileExtentHeader = (FILE_EXTENT_HEADER*)ExtentData.pExtents;
    ExtentData.pFileExtentHeader->FileRecordNumber = 0;     //There is no FileRecordNumber on FAT.
    ExtentData.pFileExtentHeader->NumberOfStreams = 0;      //Contains the number of streams with extents.
    ExtentData.pFileExtentHeader->TotalNumberOfStreams = 0; //Contains the total number of streams.
    ExtentData.pFileExtentHeader->ExcessExtents = 0;

    //Initialize the FILE_STREAM_HEADER structure.
    ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((char*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));
    ExtentData.pStreamExtentHeader->StreamNumber = 0;
    ExtentData.pStreamExtentHeader->ExtentCount = 0;
    ExtentData.pStreamExtentHeader->ExcessExtents = 0;
    ExtentData.pStreamExtentHeader->AllocatedLength = 0;
    ExtentData.pStreamExtentHeader->FileSize = 0;

    //Initialize the pointer to the extent list itself.
    pExtentList = (EXTENT_LIST*)((char*)ExtentData.pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

    //0.0E00 Initialize output variables.
    VolData.bFragmented = FALSE;
    VolData.bCompressed = FALSE;
    VolData.NumberOfFragments = 0;
    VolData.NumberOfClusters = 0;
    VolData.NumberOfRealClusters = 0;

    //If this file is a small file -- it has an invalid starting Lcn number to indicate there are no
    //allocated clusters.  Don't scan the FAT for clusters.
    if(VolData.StartingLcn == 0xFFFFFFFF){
        goto SmallFile;
    }

    //0.0E00 Note the number of FAT entries in CLUSTERS_PER_FAT_CHUNK clusters of the FAT.
    //0.0E00 We will be reading in CLUSTERS_PER_FAT_CHUNK clusters of the FAT at a time.
    switch(VolData.FileSystem){
    case FS_FAT:
        EntriesPerChunk = (DWORD)(CLUSTERS_PER_FAT_CHUNK * VolData.BytesPerCluster / 2);    //2 bytes per entry.
        break;
    case FS_FAT32:
        EntriesPerChunk = (DWORD)(CLUSTERS_PER_FAT_CHUNK * VolData.BytesPerCluster / 4);    //4 bytes per entry.
        break;
    default:
        EF(FALSE);
    }

    EF_ASSERT(EntriesPerChunk);

    //0.0E00 Begin with the assumption that the number of extents for this file is 1, I will can increment it as I find more.
    NumberOfExtents = 1;

    //0.0E00 Count the file's extents by counting non-adjacent clusters

    //0.0E00 Loop through each Lcn of the file -- ending at the terminating cluster number.
    //+2 because Lcn 0 is offset 2 in the FAT.
    for(Cluster = (DWORD)VolData.StartingLcn+2; TRUE; ){
        //0.0E00 Figure out which chunk of the FAT to read in to look at the next entry.
        FatChunkNum = (DWORD)(Cluster / EntriesPerChunk);       //Zero based number.
        //0.0E00 Check to see if I've already loaded this chunk.  If not, or if I haven't yet read in any chunk, read in the chunk.
        if((FatChunkNum != LastFatChunkNum) || (!hFat)){
            //0.0E00 Free up the previous chunk.
            if(hFat){
                while(GlobalUnlock(hFat))
                    ;
                EH_ASSERT(GlobalFree(hFat) == NULL);
            }
            //0.0E00 Read in the new chunk.
            EF((hFat = DasdLoadSectors(VolData.hVolume,
                        ((DWORD)(VolData.FatOffset)/VolData.BytesPerSector)                     //VolData.FatOffset contains the byte offset
                                                                                                //of the FAT on the drive.
                        + (FatChunkNum * CLUSTERS_PER_FAT_CHUNK * VolData.SectorsPerCluster),   //Which chunk in the FAT to read.
                        CLUSTERS_PER_FAT_CHUNK * VolData.SectorsPerCluster,                     //Read one chunk of the FAT.
                        VolData.BytesPerSector)) != INVALID_HANDLE_VALUE);
            EF((pFat = (BYTE*)GlobalLock(hFat)) != NULL);
            LastFatChunkNum = FatChunkNum;
        }
        //0.0E00 Filter out the correct entry from the FAT.
        //0.0E00 Compare that entry with the next to see if it is adjacent or not, and if not increment the extent count.
        llNumOfClusters++;
        if(VolData.FileSystem == FS_FAT){
            //0.0E00 First use a USHORT* since this is a 16 bit FAT, then extract the correct entry from the FAT which is
            //the modulus of the cluster number (how far into the chunk I look).
            uEntry = ((USHORT*)pFat)[Cluster%EntriesPerChunk];
            //0.0E00 If that entry is zero, then this is a small file (no allocated clusters
            if(uEntry == 0){
                NumberOfExtents = 0;
                //0.0E00 Can all you programmers ever forgive me for using a goto?
                goto SmallFile;
            }
            //0.0E00 If that entry points to the next contiguous entry, then this is not a new fragment.
            if(uEntry == Cluster + 1){
                //0.0E00 Go on to the next cluster.
                Cluster++;
                continue;
            }
            //0.0E00 Otherwise, check to see if this is the terminator:
            if((0xFFF8 <= uEntry) && (uEntry <= 0xFFFF)){
                //0.0E00 If so, we're done looking for fragments.
                break;
            }
            //0.0E00 Otherwise, this is a new fragment, so increment the count.
            Cluster = uEntry;
            NumberOfExtents++;
        }
        else{
            //0.0E00 Same as above only with DWORD for a 32 bit FAT.
            //0.0E00 Also, mask out the top four bits per the FAT32 spec -- They are undefined and not part of the number.
            dwEntry = ((DWORD*)pFat)[Cluster%EntriesPerChunk] & 0x0FFFFFFF;
            if(dwEntry == 0){
                NumberOfExtents = 0;
                //0.0E00 Can all you programmers ever forgive me for using a goto?
                goto SmallFile;
            }
            if(dwEntry == Cluster + 1){
                Cluster++;
                continue;
            }
            //0.0E00 The terminator on FAT32 can be any number in this range.
            if((0x0FFFFFF8 <= dwEntry) && (dwEntry <= 0x0FFFFFFF)){
                break;
            }
            Cluster = dwEntry;
            NumberOfExtents++;
        }
    }

//  //0.0E00 Extend the extent list buffer as necessary to hold that many extents.
//  if(NumberOfExtents*sizeof(EXTENT_LIST) > VolData.ExtentListBytes){
//      //0.1E00 Allocate to the new size.
//      EF(AllocateMemory((DWORD)(NumberOfExtents * sizeof(EXTENT_LIST)), &VolData.hExtentList, (void**)&VolData.pExtentList));
//      VolData.ExtentListBytes = NumberOfExtents * sizeof(EXTENT_LIST);
//  }

    ExtentData.pFileExtentHeader->NumberOfStreams = 1;
    ExtentData.pFileExtentHeader->TotalNumberOfStreams =1;
    ExtentData.pFileExtentHeader->ExcessExtents = NumberOfExtents - 1;

    ExtentData.pStreamExtentHeader->ExtentCount = NumberOfExtents;
    ExtentData.pStreamExtentHeader->ExcessExtents = NumberOfExtents - 1;

    Extent = 0;
    //0.0E00 Note the starting lcn of the first extent (i.e. beginning of file).
    pExtentList->StartingLcn = VolData.StartingLcn;

    //0.0E00 Go though the FAT chain again, now filling in the extents.  End at the terminating cluster number.
    for(Cluster = (DWORD)VolData.StartingLcn+2; TRUE; ){
        //0.0E00 Figure out which chunk of the FAT to read in to look at the next entry.
        FatChunkNum = (DWORD)(Cluster / EntriesPerChunk);   //Zero based number.
        //0.0E00 Check to see if I've already loaded this chunk.  If not, read in the chunk.
        //0.0E00 I don't have to check to see if I haven't loaded any chunk here, because one was loaded in the last loop.
        if(FatChunkNum != LastFatChunkNum){
            //0.0E00 Free up the previous chunk.
            if(hFat){
                while (GlobalUnlock(hFat))
                    ;
                EH_ASSERT(GlobalFree(hFat) == NULL);
            }
            //0.0E00 Read in the new chunk.
            EF((hFat = DasdLoadSectors(VolData.hVolume,
                        ((DWORD)(VolData.FatOffset)/VolData.BytesPerSector)                     //VolData.FatOffset contains the byte offset
                                                                                                //of the FAT on the drive.
                        + (FatChunkNum * CLUSTERS_PER_FAT_CHUNK * VolData.SectorsPerCluster),   //Which chunk in the FAT to read.
                        CLUSTERS_PER_FAT_CHUNK * VolData.SectorsPerCluster,                     //Read one chunk of the FAT.
                        VolData.BytesPerSector)) != INVALID_HANDLE_VALUE);
            EF((pFat = (BYTE*)GlobalLock(hFat)) != NULL);
            LastFatChunkNum = FatChunkNum;
        }
        //0.0E00 Filter out the correct entry from the FAT.
        //0.0E00 Compare that entry with the next to see if it is adjacent or not, and if not increment the extent count.
        if(VolData.FileSystem == FS_FAT){
            //0.0E00 First use a USHORT* since this is a 16 bit FAT, then extract the correct entry from the FAT which is
            //0.0E00 the modulus of the cluster number (how far into the chunk I look).
            uEntry = ((USHORT*)pFat)[Cluster%EntriesPerChunk];
            //0.0E00 If that entry points to the next contiguous entry, then this is not a new fragment.
            if(uEntry == Cluster + 1){
                //0.0E00 Go on to the next cluster.
                Cluster++;
                continue;
            }
            //0.0E00 Otherwise, check to see if this is the terminator:
            if((0xFFF8 <= uEntry) && (uEntry <= 0xFFFF)){
                //0.0E00 If so, we're done looking for fragments.
                break;
            }
            //0.0E00 Otherwise, this is a new fragment, so...
            // 1) Update the clustercount for the last extent.
            //The cluster count is the total number of clusters between the last Lcn and the current position.
            pExtentList[Extent].ClusterCount = Cluster + 1 - (pExtentList[Extent].StartingLcn+2);
            // 2) Set the Lcn for the next extent.
            pExtentList[++Extent].StartingLcn = uEntry - 2;
            // 3) Update the cluster value to the new starting extent
            Cluster = uEntry;
        }
        else{
            //0.0E00 Same as above only with DWORD for a 32 bit FAT.
            //0.0E00 Also, mask out the top four bits per the FAT32 spec -- They are undefined and not part of the number.
            dwEntry = ((DWORD*)pFat)[Cluster%EntriesPerChunk] & 0x0FFFFFFF;
            if(dwEntry == Cluster + 1){
                Cluster++;
                continue;
            }
            //0.0E00 The terminator on FAT32 can be any number in this range.
            if((0x0FFFFFF8 <= dwEntry) && (dwEntry <= 0x0FFFFFFF)){
                break;
            }
            pExtentList[Extent].ClusterCount = Cluster + 1 - (pExtentList[Extent].StartingLcn+2);
            pExtentList[++Extent].StartingLcn = dwEntry - 2;
            Cluster = dwEntry;
        }
    }

    //0.0E00 Set the clustercount for the last extent.
    pExtentList[Extent].ClusterCount = Cluster + 1 - (pExtentList[Extent].StartingLcn+2);

//If the first FAT loop detects that this is a small file, it will immediately jump here.
SmallFile:

    //If there are no extents, then zero out the extent list.
    if(NumberOfExtents == 0){
        ZeroMemory(VolData.pExtentList, (DWORD)VolData.ExtentListAlloced);
        VolData.FileSize = 0;
    }

    //0.0E00 Record the number of fragments in the file.
    VolData.NumberOfFragments = NumberOfExtents;

    //Note the number of clusters in the file.
    VolData.NumberOfRealClusters = VolData.NumberOfClusters = llNumOfClusters;

    //0.0E00 If this is a directory, round it's filesize up to the nearest cluster.
    if(VolData.bDirectory){
        VolData.FileSize = VolData.NumberOfClusters * VolData.BytesPerCluster;
    }

    //0.1E00 If there is only one fragments, then the file is contiguous, otherwise it is fragmented.
    if (VolData.NumberOfFragments < 2) {
        VolData.bFragmented = FALSE;
    }
    else {
        VolData.bFragmented = TRUE;
    }

    //0.0E00 Free up the FAT chunk.
    if(hFat){
        while(GlobalUnlock(hFat))
            ;
        EH_ASSERT(GlobalFree(hFat) == NULL);
    }

    //Too Cool! :-)
    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Opens a file on a FAT volume.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
OpenFatFile(
    )
{
    DWORD_AND_LONGLONG  FunkyFileSize;
    DWORD Error;

    if(VolData.hFile != INVALID_HANDLE_VALUE){
        CloseHandle(VolData.hFile);
        VolData.hFile = INVALID_HANDLE_VALUE;
    }
    
    if (VolData.vFileName.IsEmpty()) {
        return FALSE;
    }

    //0.0E00 Get a transparent handle to the file.
    if((VolData.hFile = CreateFile((LPTSTR)VolData.vFileName.GetBuffer(),
                                    FILE_READ_ATTRIBUTES | SYNCHRONIZE, //sks bug #184735 
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    (!VolData.bDirectory) ? FILE_ATTRIBUTE_NORMAL : FILE_FLAG_BACKUP_SEMANTICS,
                                    NULL)) == INVALID_HANDLE_VALUE) {

        //0.0E00 Try later.
        Error = GetLastError();
        Message(TEXT("OpenFatFile - CreateFile"), GetLastError(), ESICompressFilePath(VolData.vFileName.GetBuffer()));
        SetLastError(Error);
        return FALSE;
    }
#ifndef OFFLINEDK
    FunkyFileSize.Dword.Low = GetFileSize(VolData.hFile, &FunkyFileSize.Dword.High);
    VolData.FileSize = FunkyFileSize.LongLong;
    VolData.NumberOfFragments = (VolData.FileSize == 0) ? 0 : 1;
#endif
    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Gets the next Fat file from the moveable file list.

INPUT:
    dwMoveFlags - MOVE_FRAGMENTED - moves fragmented files.
                - MOVE_CONTIGUOUS - moves contiguous files.

OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - File Found.
    FALSE - No file found.
*/

BOOL
GetNextFatFile(
    DWORD dwMoveFlags
    )
{
    FILE_LIST_ENTRY* pFileListEntry = NULL;
    LONGLONG NextLcn;
    LONGLONG LastStartingLcn;
    LONGLONG LowestIndex;
    LONGLONG TempStartingLcn;
    LONGLONG i;

    BOOL bMoveContiguous = (dwMoveFlags & MOVE_CONTIGUOUS) ? TRUE : FALSE;
    BOOL bMoveFragmented = (dwMoveFlags & MOVE_FRAGMENTED) ? TRUE : FALSE;

// This is here because if a file is deleted, then we
// want to call this function again until we either
// hit the end of the list, or get a file.
Top_Of_GetNextFatFile:

    // Here is the function initialization.
    pFileListEntry = NULL;
    NextLcn = 0xFFFFFFFFFFFFFFFF;
    LastStartingLcn = VolData.LastStartingLcn;
    LowestIndex = 0xFFFFFFFFFFFFFFFF;
    TempStartingLcn = 0;
    i = 0;

    // The NextLcn specifies which Lcn is the next
    // one to write to, and it's location therefore
    // depends on which direction this pass is going.
    NextLcn = (VolData.ProcessFilesDirection == FORWARD) ? VolData.SourceEndLcn : VolData.SourceStartLcn;

    // Get a pointer to the file list.  We do
    // this for the performance benefit of 
    // losing the indirection via VolData.
    pFileListEntry = VolData.pMoveableFileList;

    // Find the next file in the list
    for(i = 0; i < VolData.MoveableFileListEntries; i ++, pFileListEntry++) {

        // If we've hit the end of filled in data
        // in the file list, we're done checking this list.
        if(pFileListEntry->FileRecordNumber == 0) {
            break;
        }
        // If this file is set to not be moved - next.
        // If we're not supposed to move contiguous files on this pass and this file is contiguous - next.
        // If we're not supposed to move fragmented files on this pass and this file is fragmented - next.
        if((pFileListEntry->Flags & (FLE_NEXT_PASS | FLE_DISABLED))
           || (!bMoveContiguous && !(pFileListEntry->Flags & FLE_FRAGMENTED))
           || (!bMoveFragmented && pFileListEntry->Flags & FLE_FRAGMENTED)) {

            continue;
        }
        // Don't move directories on FAT or FAT32 since the hooks will not move the first cluster.
        if(pFileListEntry->Flags & FLE_DIRECTORY) {
            Message(L"Cannot defrag directories on FAT or FAT32 volumes.", -1, ESICompressFilePath(VolData.vFileName.GetBuffer()));
            continue;
        }
        // Offload the StartingLcn into a memory variable for faster access.
        TempStartingLcn = pFileListEntry->StartingLcn;

        // See if this file is the next in sequence
        if( ( (VolData.ProcessFilesDirection == FORWARD) &&
              (TempStartingLcn > LastStartingLcn) &&
              (TempStartingLcn < NextLcn) )
                                ||
            ( (VolData.ProcessFilesDirection == BACKWARD) &&
              (TempStartingLcn < LastStartingLcn) &&
              (TempStartingLcn > NextLcn) ) ){

            NextLcn = TempStartingLcn;
            LowestIndex = i;
        }
    }
    // If LowestIndex still is -1, then that means we didn't find any files.
    if(LowestIndex == 0xFFFFFFFFFFFFFFFF){
        return FALSE;
    }
    // Get a pointer to the file in the list.
    pFileListEntry = &VolData.pMoveableFileList[LowestIndex];

    // Mark it as moved, so it doesn't get moved again until the next pass.
    pFileListEntry->Flags |= FLE_NEXT_PASS;

    // Since a file was found in one of these lists, set the return values accordingly.
    VolData.LastStartingLcn = VolData.StartingLcn = NextLcn;

    // Get the file record number of the file from the list.
    VolData.FileRecordNumber = pFileListEntry->FileRecordNumber;

    // Note whether this file is a directory or not.
    VolData.bDirectory = (pFileListEntry->Flags & FLE_DIRECTORY) ? TRUE : FALSE;

    // Note whether this file is fragmented or not.
    VolData.bFragmented = (pFileListEntry->Flags & FLE_FRAGMENTED) ? TRUE : FALSE;

    // Note this file's index in the list so it can be updated later.
    VolData.MoveableFileListIndex = (UINT)LowestIndex;
    
    //Get the file's name.
    VolData.vFileName = &VolData.pNameList[pFileListEntry->FileRecordNumber];
    
    // Check to see if the file has been deleted out from under us.
    if(!OpenFatFile()) {

        //Note not to move this file again.
        pFileListEntry->Flags |= FLE_DISABLED;

        //Since we didn't find a file, try again. (Use forbidden goto command!)
        goto Top_Of_GetNextFatFile;
    }
    return TRUE;
}






/*****************************************************************************************************************

ROUTINE: AddFileToList

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Given an extent list it adds it to a file list.

INPUT + OUTPUT:
    OUT pList       - A pointer to the file list.
    IN pListIndex   - An index of how far the list has been written into.
    IN ListEntries  - The number of entries in the extent list.

GLOBALS:
    IN VolData.bDirectory       - Whether or not this file a directory.
    IN VolData.NumberOfExtents  - The number of extents in this file.
    IN VolData.FileSize         - The size of the file.
    IN VolData.vFileName        - The name of the file.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
AddFileToListFat(
    OUT FILE_LIST_ENTRY* pList,
    IN OUT ULONG* pListIndex,
    IN ULONG ListSize,
    IN UCHAR* pExtentList
    )
{
    LONGLONG EarliestStartingLcn = 0xFFFFFFFFFFFFFFFF;
    FILE_LIST_ENTRY* pFileListEntry;
    FILE_EXTENT_HEADER* pFileExtentHeader;

    EF_ASSERT(pList);
    EF_ASSERT(pListIndex);
    EF_ASSERT(pExtentList);
    EF_ASSERT(*pListIndex <= ListSize);     //Make sure there is room for another entry in the list.

    //We need to start the NameListIndex one byte into the name list so that we can use it's value which will be put
    //into FileRecordNumber as an indication that the file list entry contains a valid file.  We'll do a test for zero,
    //and if the NameListIndex starts at zero then the algorithm will think the first file record is the end of the list.
    if(!VolData.NameListIndex){
        VolData.NameListIndex = 1;
    }

    //1.0E00 Check for an overflow of the name list.
    EF_ASSERT((VolData.NameListIndex + (ULONG) VolData.vFileName.GetLength() + 1) * sizeof(TCHAR) < VolData.NameListSize);

#ifdef OFFLINEDK
    TCHAR cString[200];
    //1.0E00 Print out data for the developer.
    wsprintf(cString,
             TEXT("Adding to %s list; 0x%lX extents, %ld bytes - %s"),
             (VolData.bDirectory) ? TEXT("Dir") : TEXT("File"),
             (ULONG)VolData.NumberOfExtents,
             (ULONG)VolData.FileSize,
             (ULONG)ESICompressFilePath(VolData.vFileName));
    Message(ESICompressFilePath(VolData.vFileName), -1, cString);
#endif

    //Get a pointer to the file extent header.
    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;

    //Get the earliest starting lcn for the file which we'll use in our algorithms to determine which file to move next.
    EF(GetLowestStartingLcn(&EarliestStartingLcn, pFileExtentHeader));

    //Get a pointer to the end of the file list.
    pFileListEntry = &pList[*pListIndex];

    //Fill in this file into the file list.
    pFileListEntry->FileRecordNumber = (UINT)VolData.NameListIndex;
    pFileListEntry->StartingLcn = EarliestStartingLcn;
    pFileListEntry->ExcessExtentCount = (UINT)VolData.NumberOfFragments - pFileExtentHeader->NumberOfStreams;       //Only count *excess* extents since otherwise files with multiple streams would be "fragmented".

    //Set or clear the fragmented flag depending on whether the file is fragmented or not.
    if(VolData.bFragmented){
        //Set the fragmented flag.
        pFileListEntry->Flags |= FLE_FRAGMENTED;
    }
    else{
        //Clear the fragmented flag.
        pFileListEntry->Flags &= ~FLE_FRAGMENTED;
    }

    //Set or clear the directory flag depending on whether the file is a directory or not.
    if(VolData.bDirectory){
        //Set the directory flag.
        pFileListEntry->Flags |= FLE_DIRECTORY;
    }
    else{
        //Clear the directory flag.
        pFileListEntry->Flags &= ~FLE_DIRECTORY;
    }

    if (VolData.vFileName.GetLength() > 0) {
        //1.0E00 Put the filename into the file list and update the file list index.
        lstrcpy((PTCHAR)(VolData.pNameList + VolData.NameListIndex), VolData.vFileName.GetBuffer());
        pFileListEntry->FileRecordNumber = VolData.NameListIndex;
        VolData.NameListIndex += VolData.vFileName.GetLength() + 1;

        //Set the index to point to the new end of the list.
        (*pListIndex)++;

    }
    return TRUE;
}

BOOL
UpdateInFileList(
    )
{
    LONGLONG EarliestStartingLcn = 0xFFFFFFFFFFFFFFFF;
    FILE_EXTENT_HEADER* pFileExtentHeader;
    FILE_LIST_ENTRY* pFileListEntry;

    //Sanity check this value.  CurrentFileListIndex must fall inside the file list.
    EF(VolData.MoveableFileListIndex <= VolData.MoveableFileListEntries);

    //Get a pointer to the entry.
    pFileListEntry = &VolData.pMoveableFileList[VolData.MoveableFileListIndex];

    //Sanity check the file record number.  They should be the same.
    EF(pFileListEntry->FileRecordNumber == (UINT)VolData.FileRecordNumber);

    //Get a pointer to the file extent header.
    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;

    //Get the earliest starting lcn for the file which we'll use in our algorithms to determine which file to move next.
    EF(GetLowestStartingLcn(&EarliestStartingLcn, pFileExtentHeader));

    //Update the information on this file.
    pFileListEntry->StartingLcn = EarliestStartingLcn;
    pFileListEntry->ExcessExtentCount = (UINT)VolData.NumberOfFragments - pFileExtentHeader->NumberOfStreams;       //Only count *excess* extents since otherwise files with multiple streams would be "fragmented".

    //Set or clear the fragmented flag depending on whether the file is fragmented or not.
    if(VolData.bFragmented){
        //Set the fragmented flag.
        pFileListEntry->Flags |= FLE_FRAGMENTED;
    }
    else{
        //Clear the fragmented flag.
        pFileListEntry->Flags &= ~FLE_FRAGMENTED;
    }

    //Set or clear the directory flag depending on whether the file is a directory or not.
    if(VolData.bDirectory){
        //Set the directory flag.
        pFileListEntry->Flags |= FLE_DIRECTORY;
    }
    else{
        //Clear the directory flag.
        pFileListEntry->Flags &= ~FLE_DIRECTORY;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\freespace.cpp ===
/*****************************************************************************************************************

FILENAME: FreeSpac.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
  Contains routines for finding free clusters using the volume's bitmap.
*/

#include "stdafx.h"

#ifdef OFFLINEDK
    extern "C"{
        #include <stdio.h>
    }
#endif

#ifdef BOOTIME
    #include "Offline.h"
#else
    #include "Windows.h"
#endif

#include <winioctl.h>
#include <math.h>

extern "C" {
    #include "SysStruc.h"
}
#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"
#include "GetDfrgRes.h"
#include "GetReg.h"

#include "Devio.h"

#include "FreeSpace.h"

#include "Alloc.h"
#include "Message.h"

#define THIS_MODULE 'F'
#include "logfile.h"

// macros to speed up LONGLONG math (multiplication and division)
// based on profiling data by Mark Patton
// set OPTLONGLONGMATH as follows:
// 1=optimize with shift and &
// 0=use / and %
#define OPTLONGLONGMATH     1

#if OPTLONGLONGMATH
#define DIVIDELONGLONGBY32(num)        Int64ShraMod32((num), 5)
#define MODULUSLONGLONGBY32(num)       ((num) & 0x1F)
#else
#define DIVIDELONGLONGBY32(num)        ((num) / 32)
#define MODULUSLONGLONGBY32(num)       ((num) % 32)
#endif




//
//  This structure is the header for a generic table entry.
//  Align this structure on a 8 byte boundary so the user
//  data is correctly aligned.
//

typedef struct _TABLE_ENTRY_HEADER {

    RTL_BALANCED_LINKS BalancedLinks;
    LONGLONG UserData;

} TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;



PVOID
RealPredecessor (
    IN PRTL_BALANCED_LINKS Links
    )

/*++

Routine Description:

    The RealPredecessor function takes as input a pointer to a balanced link
    in a tree and returns a pointer to the predecessor of the input node
    within the entire tree.  If there is not a predecessor, the return value
    is NULL.

Arguments:

    Links - Supplies a pointer to a balanced link in a tree.

Return Value:

    PRTL_BALANCED_LINKS - returns a pointer to the predecessor in the entire tree

--*/

{
    PRTL_BALANCED_LINKS Ptr;

    /*
      first check to see if there is a left subtree to the input link
      if there is then the real predecessor is the right most node in
      the left subtree.  That is find and return P in the following diagram

                  Links
                   /
                  .
                   .
                    .
                     P
                    /
    */

    if ((Ptr = Links->LeftChild) != NULL) {

        while (Ptr->RightChild != NULL) {
            Ptr = Ptr->RightChild;
        }

        return ((PVOID)&((PTABLE_ENTRY_HEADER)Ptr)->UserData);

    }

    /*
      we do not have a left child so check to see if have a parent and if
      so find the first ancestor that we are a right decendent of. That
      is find and return P in the following diagram

                       P
                        \
                         .
                        .
                       .
                    Links

        Note that this code depends on how the BalancedRoot is initialized, which is
        Parent points to self, and the RightChild points to an actual node which is
        the root of the tree.
    */

    Ptr = Links;
    while (RtlIsLeftChild(Ptr)) {
        Ptr = Ptr->Parent;
    }

    if (RtlIsRightChild(Ptr) && (Ptr->Parent->Parent != Ptr->Parent)) {
        return ((PVOID)&((PTABLE_ENTRY_HEADER)(Ptr->Parent))->UserData);
    }

    //
    //  otherwise we are do not have a real predecessor so we simply return
    //  NULL
    //

    return NULL;

}


PVOID
PreviousEntry(
    IN PVOID pCurrentEntry
    )
{
    if (!pCurrentEntry) {
        return NULL;
    }

    PTABLE_ENTRY_HEADER q = (PTABLE_ENTRY_HEADER) CONTAINING_RECORD(
        pCurrentEntry,
        TABLE_ENTRY_HEADER,
        UserData);

    return RealPredecessor(&(q->BalancedLinks));

}

PVOID
LastEntry(
    IN PRTL_AVL_TABLE Table
    )
{
    if (!Table) {
        return NULL;
    }
    
    PRTL_BALANCED_LINKS NodeToExamine = Table->BalancedRoot.RightChild;
    PRTL_BALANCED_LINKS Child;

    while (Child = NodeToExamine->RightChild) {
        NodeToExamine = Child;
    }

    if (NodeToExamine) {
        return ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToExamine)->UserData);
    }
    else {
        return NULL;
    }
}


#if 0
void
DumpFreeSpace(
    IN PRTL_GENERIC_TABLE pTable
    )
{
    PFREE_SPACE_ENTRY pFreeSpaceEntry;
    BOOLEAN bNext = FALSE;
    WCHAR szTemp[256];

    PVOID pRestartKey = NULL;
    ULONG ulDeleteCount = 0;
    int iCount = 0;

    FREE_SPACE_ENTRY entry;
    
    ZeroMemory(&entry, sizeof(FREE_SPACE_ENTRY));

    do {
        pFreeSpaceEntry = (PFREE_SPACE_ENTRY) RtlEnumerateGenericTableLikeADirectory(
            pTable, 
            NULL,
            NULL,
            bNext,
            &pRestartKey,
            &ulDeleteCount,
            &entry);

        bNext = TRUE;
        if (!pFreeSpaceEntry) {
            // No free space left
            OutputDebugString(L"No free space left\n\n");
            break;
        }

        wsprintf(szTemp, L">> Free space \t Start:%I64u, \t ClusterCount:%I64u\n",
            pFreeSpaceEntry->StartingLcn,
            pFreeSpaceEntry->ClusterCount);
        OutputDebugString(szTemp);

    } while ((pFreeSpaceEntry) && (++iCount < 20));

}
#endif


BOOL
BuildFreeSpaceList(
    IN OUT PRTL_GENERIC_TABLE pFreeSpaceTable,
    IN CONST LONGLONG MinClusterCount,
    IN CONST BOOL bSortBySize,
    OUT LONGLONG *pBiggestFreeSpaceClusterCount,
    OUT LONGLONG *pBiggestFreeSpaceStartingLcn,
    IN CONST BOOL bIgnoreMftZone
    )
{
    LONGLONG Lcn = 0,
        StartingLcn = 0,
        EndingLcn = 0,
        ClusterCount = 0;
    FREE_SPACE_ENTRY FreeSpaceEntry;
    PVOID p = NULL;
    BOOL bResult = TRUE;
    BOOLEAN bNewElement = FALSE;
    PULONG pBitmap = NULL;

    GetVolumeBitmap();

    //0.0E00 Get a pointer to the free space bitmap 
    PVOLUME_BITMAP_BUFFER pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
    if (!pVolumeBitmap){
        Trace(warn, "BuildFreeSpaceList.  Unable to get VolumeBitmap");
        return FALSE;   // no need to Unlock--the lock failed
    }

    pBitmap = (PULONG)&pVolumeBitmap->Buffer;
    
    //0.0E00 Scan thru the entire bitmap looking for free space extents
    for(Lcn = 0; Lcn < VolData.TotalClusters; ) {

        //0.0E00 Find the next free space extent 
        FindFreeExtent(pBitmap, VolData.TotalClusters, &Lcn, &StartingLcn, &ClusterCount);

        if (0 == ClusterCount) {
            // No more free spaces, we're done
            break;
        }

        if (ClusterCount < MinClusterCount) {
            continue;
        }

        EndingLcn = StartingLcn + ClusterCount;

        //0.0E00 If NTFS clip the free space extent to exclude the MFT zone 
        if(VolData.FileSystem == FS_NTFS)  {

            if (!bIgnoreMftZone) {
                if((StartingLcn < VolData.MftZoneEnd) &&
                   (EndingLcn > VolData.MftZoneStart)) {

                    if(StartingLcn < VolData.MftZoneStart) {
                        EndingLcn = VolData.MftZoneStart;
                    } 
                    else if(EndingLcn <= VolData.MftZoneEnd) {
                        continue;   // this zone is fully within the MFT zone
                    } 
                    else {                  
                        //0.0E00 Handle the case of EndingLcn > pVolData->MftZoneEnd.
                        StartingLcn = VolData.MftZoneEnd;
                    }
                }
            }

            if((StartingLcn < VolData.BootOptimizeEndClusterExclude) &&
               (EndingLcn > VolData.BootOptimizeBeginClusterExclude)) {

                if(StartingLcn < VolData.BootOptimizeBeginClusterExclude) {
                    EndingLcn = VolData.BootOptimizeBeginClusterExclude;
                } 
                else if(EndingLcn <= VolData.BootOptimizeEndClusterExclude) {
                    continue;   // this zone is fully within the boot-opt zone
                } 
                else {                  
                    //0.0E00 Handle the case of EndingLcn > pVolData->bootoptZoneEnd.
                    StartingLcn = VolData.BootOptimizeEndClusterExclude;
                }
            }
            
        }

        FreeSpaceEntry.StartingLcn = StartingLcn;
        FreeSpaceEntry.ClusterCount = EndingLcn - StartingLcn;
        FreeSpaceEntry.SortBySize = bSortBySize;

        if (pBiggestFreeSpaceClusterCount) {
            if (FreeSpaceEntry.ClusterCount > *pBiggestFreeSpaceClusterCount) {
                *pBiggestFreeSpaceClusterCount = FreeSpaceEntry.ClusterCount;
                if (pBiggestFreeSpaceStartingLcn) {
                    *pBiggestFreeSpaceStartingLcn = StartingLcn;
                }
            }
        }
            
        p = RtlInsertElementGenericTable(
            pFreeSpaceTable,
            (PVOID) &FreeSpaceEntry,
            sizeof(FREE_SPACE_ENTRY),
            &bNewElement);

        if (!p) {
            //
            // An allocation failed
            //
            bResult = FALSE;
            break;
        };

    }

    if (VolData.hVolumeBitmap) {
        GlobalUnlock(VolData.hVolumeBitmap);
    }

    //DumpFreeSpace(pFreeSpaceTable);
    return bResult;
}   



BOOL
BuildFreeSpaceListWithExclude(
    IN OUT PRTL_GENERIC_TABLE pFreeSpaceTable,
    IN CONST LONGLONG MinClusterCount,
    IN CONST LONGLONG ExcludeZoneStart,
    IN CONST LONGLONG ExcludeZoneEnd,
    IN CONST BOOL bSortBySize,
    IN CONST BOOL bExcludeMftZone
    )
{
    LONGLONG Lcn = 0,
        StartingLcn = 0,
        EndingLcn = 0,
        ClusterCount = 0;
    FREE_SPACE_ENTRY FreeSpaceEntry;
    PVOID p = NULL;
    BOOL bResult = TRUE;
    BOOLEAN bNewElement = FALSE;
    PULONG pBitmap = NULL;

    GetVolumeBitmap();

    //0.0E00 Get a pointer to the free space bitmap 
    PVOLUME_BITMAP_BUFFER pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
    if (!pVolumeBitmap){
        Trace(warn, "BuildFreeSpaceList.  Unable to get VolumeBitmap");
        return FALSE;   // no need to Unlock--the lock failed
    }

    pBitmap = (PULONG)&pVolumeBitmap->Buffer;
    
    //0.0E00 Scan thru the entire bitmap looking for free space extents
    for(Lcn = 0; Lcn < VolData.TotalClusters; ) {

        //0.0E00 Find the next free space extent 
        FindFreeExtent(pBitmap, VolData.TotalClusters, &Lcn, &StartingLcn, &ClusterCount);

        if (0 == ClusterCount) {
            // No more free spaces, we're done
            break;
        }

        if (ClusterCount < MinClusterCount) {
            continue;
        }

        EndingLcn = StartingLcn + ClusterCount;

        //0.0E00 If NTFS clip the free space extent to exclude the MFT zone 
        if ((bExcludeMftZone) && (VolData.FileSystem == FS_NTFS))  {

            if((StartingLcn < VolData.MftZoneEnd) && 
                (EndingLcn > VolData.MftZoneStart)) {

                if(StartingLcn < VolData.MftZoneStart) {
                    EndingLcn = VolData.MftZoneStart;
                } 
                else if(EndingLcn <= VolData.MftZoneEnd) {
                    continue;   // this zone is fully within the MFT zone
                } 
                else {                  
                    //0.0E00 Handle the case of EndingLcn > pVolData->MftZoneEnd.
                    StartingLcn = VolData.MftZoneEnd;
                }
            }
            
            if((StartingLcn < VolData.BootOptimizeEndClusterExclude) &&
               (EndingLcn > VolData.BootOptimizeBeginClusterExclude)) {

                if(StartingLcn < VolData.BootOptimizeBeginClusterExclude) {
                    EndingLcn = VolData.BootOptimizeBeginClusterExclude;
                } 
                else if(EndingLcn <= VolData.BootOptimizeEndClusterExclude) {
                    continue;   // this zone is fully within the boot-opt zone
                } 
                else {                  
                    //0.0E00 Handle the case of EndingLcn > pVolData->bootoptZoneEnd.
                    StartingLcn = VolData.BootOptimizeEndClusterExclude;
                }
            }
        }


        if((StartingLcn < ExcludeZoneEnd) && 
            (EndingLcn > ExcludeZoneStart)) {

            if(StartingLcn < ExcludeZoneStart) {
                EndingLcn = ExcludeZoneStart;
            } 
            else if(EndingLcn <= ExcludeZoneEnd) {
                continue;   // this zone is fully within the MFT zone
            } 
            else {                  
                //0.0E00 Handle the case of EndingLcn > pVolData->MftZoneEnd.
                StartingLcn = ExcludeZoneEnd;
            }
        }
        

        FreeSpaceEntry.StartingLcn = StartingLcn;
        FreeSpaceEntry.ClusterCount = EndingLcn - StartingLcn;
        FreeSpaceEntry.SortBySize = bSortBySize;

        p = RtlInsertElementGenericTable(
            pFreeSpaceTable,
            (PVOID) &FreeSpaceEntry,
            sizeof(FREE_SPACE_ENTRY),
            &bNewElement);

        if (!p) {
            //
            // An allocation failed
            //
            bResult = FALSE;
            break;
        };

    }

    if (VolData.hVolumeBitmap) {
        GlobalUnlock(VolData.hVolumeBitmap);
    }

    return bResult;
}   


BOOL
BuildFreeSpaceListWithMultipleTrees(
    OUT LONGLONG *pBiggestFreeSpaceClusterCount,
    IN CONST LONGLONG IncludeZoneStartingLcn,
    IN CONST LONGLONG IncludeZoneEndingLcn
    )
{
    LONGLONG Lcn = 0,
        StartingLcn = 0,
        EndingLcn = 0,
        ClusterCount = 0;
    FREE_SPACE_ENTRY FreeSpaceEntry;
    PRTL_GENERIC_TABLE pFreeSpaceTable = NULL;
    PVOID p = NULL;
    BOOL bResult = TRUE;
    BOOLEAN bNewElement = FALSE;
    PULONG pBitmap = NULL;
    DWORD dwTableIndex = 0;

    GetVolumeBitmap();

    //0.0E00 Get a pointer to the free space bitmap 
    PVOLUME_BITMAP_BUFFER pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
    if (!pVolumeBitmap){
        Trace(warn, "BuildFreeSpaceList.  Unable to get VolumeBitmap");
        return FALSE;   // no need to Unlock--the lock failed
    }

    pBitmap = (PULONG)&pVolumeBitmap->Buffer;
    
    //0.0E00 Scan thru the entire bitmap looking for free space extents
    for(Lcn = 0; Lcn < VolData.TotalClusters; ) {

        //0.0E00 Find the next free space extent 
        FindFreeExtent(pBitmap, VolData.TotalClusters, &Lcn, &StartingLcn, &ClusterCount);

        if (0 == ClusterCount) {
            // No more free spaces, we're done
            break;
        }

        EndingLcn = StartingLcn + ClusterCount;

        //0.0E00 If NTFS clip the free space extent to exclude the MFT zone 
        if ((VolData.FileSystem == FS_NTFS)  && (0 == IncludeZoneEndingLcn)) {

            if((StartingLcn < VolData.MftZoneEnd) &&
               (EndingLcn > VolData.MftZoneStart)) {

                if(StartingLcn < VolData.MftZoneStart) {
                    EndingLcn = VolData.MftZoneStart;
                } 
                else if(EndingLcn <= VolData.MftZoneEnd) {
                    continue;   // this zone is fully within the MFT zone
                } 
                else {                  
                    //0.0E00 Handle the case of EndingLcn > pVolData->MftZoneEnd.
                    StartingLcn = VolData.MftZoneEnd;
                }
            }

            if((StartingLcn < VolData.BootOptimizeEndClusterExclude) &&
               (EndingLcn > VolData.BootOptimizeBeginClusterExclude)) {

                if(StartingLcn < VolData.BootOptimizeBeginClusterExclude) {
                    EndingLcn = VolData.BootOptimizeBeginClusterExclude;
                } 
                else if(EndingLcn <= VolData.BootOptimizeEndClusterExclude) {
                    continue;   // this zone is fully within the boot-opt zone
                } 
                else {                  
                    //0.0E00 Handle the case of EndingLcn > pVolData->bootoptZoneEnd.
                    StartingLcn = VolData.BootOptimizeEndClusterExclude;
                }
            }
        }

        // 
        // Trim it down to the interesting zone.  If this zone starts beyond 
        // the zone we're interested in, or ends before it, we ignore it.
        //
        if (IncludeZoneEndingLcn) {
            if ((StartingLcn < IncludeZoneEndingLcn) &&
                (EndingLcn > IncludeZoneStartingLcn)) {

                if (StartingLcn < IncludeZoneStartingLcn) {
                    StartingLcn = IncludeZoneStartingLcn;
                }
                if (EndingLcn > IncludeZoneEndingLcn) {
                    EndingLcn = IncludeZoneEndingLcn;
                }
            }
            else {
                continue;
            }
        }
        
        FreeSpaceEntry.StartingLcn = StartingLcn;
        FreeSpaceEntry.ClusterCount = EndingLcn - StartingLcn;
        FreeSpaceEntry.SortBySize = FALSE;

        if (pBiggestFreeSpaceClusterCount) {
            if (FreeSpaceEntry.ClusterCount > *pBiggestFreeSpaceClusterCount) {
                *pBiggestFreeSpaceClusterCount = FreeSpaceEntry.ClusterCount;
            }
        }
            
        // 
        // Add this entry to the appropriate table.  We have ten free space
        // tables, and they contain entries of the following sizes:
        // 
        // dwTableIndex         Free space size
        // ------------         ---------------
        //      0                      1
        //      1                      2
        //      2                     3-4 
        //      3                     5-8 
        //      4                     9-16
        //      5                    17-32
        //      6                    33-64
        //      7                    65-256
        //      8                   257-4096 
        //      9                    4097+ 
        //
        //
        //  Entries in each table are sorted by StartingLcn.
        //

        if (FreeSpaceEntry.ClusterCount <= 1) {
            dwTableIndex = 0;
        }
        else if (FreeSpaceEntry.ClusterCount == 2) {
            dwTableIndex = 1;
        }
        else if (FreeSpaceEntry.ClusterCount <= 4) {
            dwTableIndex = 2;
        }
        else if (FreeSpaceEntry.ClusterCount <= 8) {
            dwTableIndex = 3;
        }
        else if (FreeSpaceEntry.ClusterCount <= 16) {
            dwTableIndex = 4;
        }
        else if (FreeSpaceEntry.ClusterCount <= 32) {
            dwTableIndex = 5;
        }
        else if (FreeSpaceEntry.ClusterCount <= 64) {
            dwTableIndex = 6;
        }
        else if (FreeSpaceEntry.ClusterCount <= 256) {
            dwTableIndex = 7;
        }
        else if (FreeSpaceEntry.ClusterCount <= 4096) {
            dwTableIndex = 8;
        }
        else {
            dwTableIndex = 9;
        }

        pFreeSpaceTable = &VolData.MultipleFreeSpaceTrees[dwTableIndex];

        p = RtlInsertElementGenericTable(
            pFreeSpaceTable,
            (PVOID) &FreeSpaceEntry,
            sizeof(FREE_SPACE_ENTRY),
            &bNewElement);

        if (!p) {
            //
            // An allocation failed
            //
            bResult = FALSE;
            break;
        };

    }

    if (VolData.hVolumeBitmap) {
        GlobalUnlock(VolData.hVolumeBitmap);
    }

    return bResult;
}   





BOOL 
FindFreeSpaceWithMultipleTrees(
    IN CONST LONGLONG ClusterCount,
    IN CONST LONGLONG MaxStartingLcn
    )
{
    PRTL_GENERIC_TABLE pFreeSpaceTable = NULL;
    DWORD dwTableIndex = 0;
    BOOL done = FALSE;
    PFREE_SPACE_ENTRY pFreeSpaceEntry;
    BOOLEAN bRestart = TRUE;
    LONGLONG CurrentBest = VolData.TotalClusters;
    // 
    // Find out which table we want to start our search from.  We have ten free 
    // space tables, and they contain entries of the following sizes:
    // 
    // dwTableIndex         Free space size
    // ------------         ---------------
    //      0                      1
    //      1                      2
    //      2                     3-4 
    //      3                     5-8 
    //      4                     9-16
    //      5                    17-32
    //      6                    33-64
    //      7                    65-256
    //      8                   257-4096 
    //      9                    4097+ 
    //
    //
    //  Entries in each table are sorted by StartingLcn.
    //
    if (ClusterCount <= 1) {
        dwTableIndex = 0;
    }
    else if (ClusterCount == 2) {
        dwTableIndex = 1;
    }
    else if (ClusterCount <= 4) {
        dwTableIndex = 2;
    }
    else if (ClusterCount <= 8) {
        dwTableIndex = 3;
    }
    else if (ClusterCount <= 16) {
        dwTableIndex = 4;
    }
    else if (ClusterCount <= 32) {
        dwTableIndex = 5;
    }
    else if (ClusterCount <= 64) {
        dwTableIndex = 6;
    }
    else if (ClusterCount <= 256) {
        dwTableIndex = 7;
    }
    else if (ClusterCount <= 4096) {
        dwTableIndex = 8;
    }
    else {
        dwTableIndex = 9;
    }

    // Assume no free space left
    VolData.pFreeSpaceEntry = NULL;
    VolData.FoundLcn = VolData.TotalClusters;
    VolData.FoundLen = 0;

    //
    // Search through the entries in this table, till we come across the first
    // entry that is big enough.
    //
    
    pFreeSpaceTable = &VolData.MultipleFreeSpaceTrees[dwTableIndex];
    do {
        pFreeSpaceEntry = (PFREE_SPACE_ENTRY) RtlEnumerateGenericTableAvl(pFreeSpaceTable, bRestart);
        bRestart = FALSE;

        if ((!pFreeSpaceEntry) || (pFreeSpaceEntry->StartingLcn > MaxStartingLcn)) {
            break;
        }

        if (pFreeSpaceEntry->ClusterCount >= ClusterCount) {
            VolData.pFreeSpaceEntry = pFreeSpaceEntry;
            VolData.FoundLcn = pFreeSpaceEntry->StartingLcn;
            VolData.FoundLen = pFreeSpaceEntry->ClusterCount;
            CurrentBest = pFreeSpaceEntry->StartingLcn;
            break;
        }
    } while (TRUE);


    //
    // For the remaining tables, search through to see if any of them 
    // have entries that start before our current best.
    //
    while (++dwTableIndex < 10) {
        pFreeSpaceTable = &VolData.MultipleFreeSpaceTrees[dwTableIndex];

        pFreeSpaceEntry = (PFREE_SPACE_ENTRY) RtlEnumerateGenericTableAvl(pFreeSpaceTable, TRUE);

        if ((pFreeSpaceEntry) &&
            (pFreeSpaceEntry->ClusterCount >= ClusterCount) &&
            (pFreeSpaceEntry->StartingLcn < MaxStartingLcn) &&
            (pFreeSpaceEntry->StartingLcn < CurrentBest)
            ) {
            VolData.pFreeSpaceEntry = pFreeSpaceEntry;
            VolData.FoundLcn = pFreeSpaceEntry->StartingLcn;
            VolData.FoundLen = pFreeSpaceEntry->ClusterCount;
            CurrentBest = pFreeSpaceEntry->StartingLcn;
        }

    } 

    if (VolData.pFreeSpaceEntry) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


BOOL
UpdateInMultipleTrees(
    IN PFREE_SPACE_ENTRY pOldEntry,
    IN PFREE_SPACE_ENTRY pNewEntry
    )
{
    PRTL_GENERIC_TABLE pFreeSpaceTable = NULL;
    PVOID p = NULL;
    BOOL bResult = TRUE;
    BOOLEAN bNewElement = FALSE;
    LONGLONG ClusterCount = pOldEntry->ClusterCount;
    DWORD dwTableIndex = 0;

    // 
    // Find out which table we want to delete from.  We have ten free 
    // space tables, and they contain entries of the following sizes:
    // 
    // dwTableIndex         Free space size
    // ------------         ---------------
    //      0                      1
    //      1                      2
    //      2                     3-4 
    //      3                     5-8 
    //      4                     9-16
    //      5                    17-32
    //      6                    33-64
    //      7                    65-256
    //      8                   257-4096 
    //      9                    4097+ 
    //
    //
    //  Entries in each table are sorted by StartingLcn.
    //
    if (ClusterCount <= 1) {
        dwTableIndex = 0;
    }
    else if (ClusterCount == 2) {
        dwTableIndex = 1;
    }
    else if (ClusterCount <= 4) {
        dwTableIndex = 2;
    }
    else if (ClusterCount <= 8) {
        dwTableIndex = 3;
    }
    else if (ClusterCount <= 16) {
        dwTableIndex = 4;
    }
    else if (ClusterCount <= 32) {
        dwTableIndex = 5;
    }
    else if (ClusterCount <= 64) {
        dwTableIndex = 6;
    }
    else if (ClusterCount <= 256) {
        dwTableIndex = 7;
    }
    else if (ClusterCount <= 4096) {
        dwTableIndex = 8;
    }
    else {
        dwTableIndex = 9;
    }
    pFreeSpaceTable = &VolData.MultipleFreeSpaceTrees[dwTableIndex];
    bNewElement = RtlDeleteElementGenericTable(pFreeSpaceTable, (PVOID)pOldEntry);
    if (!bNewElement) {
        Trace(warn, "Could not find Element in Free Space Table!");
        assert(FALSE);
        bResult = FALSE;
    }

    // 
    // Find out which table we want to add to.
    //
    if (pNewEntry) {
        
        ClusterCount = pNewEntry->ClusterCount;
        if (ClusterCount > 0) {
            if (ClusterCount <= 1) {
                dwTableIndex = 0;
            }
            else if (ClusterCount == 2) {
                dwTableIndex = 1;
            }
            else if (ClusterCount <= 4) {
                dwTableIndex = 2;
            }
            else if (ClusterCount <= 8) {
                dwTableIndex = 3;
            }
            else if (ClusterCount <= 16) {
                dwTableIndex = 4;
            }
            else if (ClusterCount <= 32) {
                dwTableIndex = 5;
            }
            else if (ClusterCount <= 64) {
                dwTableIndex = 6;
            }
            else if (ClusterCount <= 256) {
                dwTableIndex = 7;
            }
            else if (ClusterCount <= 4096) {
                dwTableIndex = 8;
            }
            else {
                dwTableIndex = 9;
            }

            pFreeSpaceTable = &VolData.MultipleFreeSpaceTrees[dwTableIndex];
            p = RtlInsertElementGenericTable(
                pFreeSpaceTable,
                (PVOID) pNewEntry,
                sizeof(FREE_SPACE_ENTRY),
                &bNewElement);

            if (!p) {
                //
                // An allocation failed
                //
                bResult = FALSE;
            };
        }
    }
    return bResult;
}



BOOL 
FindFreeSpace(
    IN PRTL_GENERIC_TABLE pTable,
    IN BOOL DeleteUnusedEntries,
    IN LONGLONG MaxStartingLcn
    )
{
    BOOL done = FALSE;
    PFREE_SPACE_ENTRY pFreeSpaceEntry;
    BOOLEAN bNext = FALSE;

    PVOID pRestartKey = NULL;
    ULONG ulDeleteCount = 0;
    FREE_SPACE_ENTRY entry;
    ZeroMemory(&entry, sizeof(FREE_SPACE_ENTRY));


    do {
        pFreeSpaceEntry = (PFREE_SPACE_ENTRY) RtlEnumerateGenericTableLikeADirectory(
            pTable, 
            NULL,
            NULL,
            bNext,
            &pRestartKey,
            &ulDeleteCount,
            &entry);

        bNext = TRUE;
        if (!pFreeSpaceEntry) {
            // No free space left
            VolData.pFreeSpaceEntry = NULL;
            VolData.FoundLcn = 0;
            VolData.FoundLen = 0;
            break;
        }

        if (pFreeSpaceEntry->StartingLcn > MaxStartingLcn) {
            break;
        }

        if (pFreeSpaceEntry->ClusterCount < VolData.NumberOfClusters) {
            // This space is of no use to us--it's too small.
            if ((0 == pFreeSpaceEntry->ClusterCount) || (DeleteUnusedEntries)) {
                RtlDeleteElementGenericTable(pTable, pFreeSpaceEntry);
            }
        
        }
       else {
            VolData.pFreeSpaceEntry = pFreeSpaceEntry;
            VolData.FoundLcn = pFreeSpaceEntry->StartingLcn;
            VolData.FoundLen = pFreeSpaceEntry->ClusterCount;
            done = TRUE;
        }

    } while (!done);

    return done;
}




BOOL
FindSortedFreeSpace(
    IN PRTL_GENERIC_TABLE pTable
    )
{
    BOOL bFound = FALSE;
    PFREE_SPACE_ENTRY pFreeSpaceEntry;

    PVOID pRestartKey = NULL;
    ULONG ulDeleteCount = 0;
    FREE_SPACE_ENTRY entry;
    ZeroMemory(&entry, sizeof(FREE_SPACE_ENTRY));

    entry.ClusterCount = VolData.NumberOfClusters;
    entry.SortBySize = TRUE;

    pFreeSpaceEntry = (PFREE_SPACE_ENTRY) RtlEnumerateGenericTableLikeADirectory(
        pTable, 
        NULL,
        NULL,
        FALSE,
        &pRestartKey,
        &ulDeleteCount,
        &entry);

    if (!pFreeSpaceEntry) {
        // No free space left
        VolData.pFreeSpaceEntry = NULL;
        VolData.FoundLcn = 0;
        VolData.FoundLen = 0;
        bFound = FALSE;

    }
   else {
        VolData.pFreeSpaceEntry = pFreeSpaceEntry;
        VolData.FoundLcn = pFreeSpaceEntry->StartingLcn;
        VolData.FoundLen = pFreeSpaceEntry->ClusterCount;
        bFound = TRUE;
    }

    return bFound;
}


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	Common routine for most requests to locate free space.

	This routine searches the area of the volume delimited by 
	the variables VolData.DestStartLcn and VolData.DestEndLcn.

	Input parm Type specifies which type of free space to find:
		FIRST_FIT			Find earliest free space extent large enough to hold the entire file
		BEST_FIT			Find smallest free space extent large enough to hold the entire file
		LAST_FIT			Find latest free space extent large enough to hold the entire file
		EARLIER				Locate the start of the free space extent adjacent to the start of this file
		FIND_FIRST			Find earliest free space extent
		FIND_LAST			Find latest free space extent
		FIND_LARGEST		Find largest free space extent
		AT_END				Find the Lcn to position the data at the end of the found free space extent
		COUNT_FREE_SPACES	Count the nuumber of free spaces

INPUT + OUTPUT:
	IN Type - Which type of free space to find

GLOBALS:
	IN OUT Various VolData fields.

RETURN:
	TRUE - Success
	FALSE - Failure
*/

BOOL
FindFreeSpace(
	IN int Type
	)
{
	BOOL						bRetStatus = TRUE;
	LONGLONG					StartingLcn;
	LONGLONG					EndingLcn;
	LONGLONG					ClusterCount;
	TCHAR						cString[500];
	LONGLONG					Lcn;
	PULONG						pBitmap = NULL;
	LONGLONG					BestFitStart = 0;
	LONGLONG					BestFitLength = 0x7fffffffffffffff;
    LONGLONG					RunLength = VolData.NumberOfClusters;
	LONGLONG					LargestFound = 0;
	LONGLONG					RangeStart = VolData.DestStartLcn;
	LONGLONG					RangeEnd = VolData.DestEndLcn;

	switch(Type) {

	case FIRST_FIT:
		Message(TEXT("FindFreeSpace - FIRST_FIT"), -1, NULL);
		break;

	case BEST_FIT:
		Message(TEXT("FindFreeSpace - BEST_FIT"), -1, NULL);
		break;

	case LAST_FIT:
		Message(TEXT("FindFreeSpace - LAST_FIT"), -1, NULL);
		break;

	case EARLIER:
		Message(TEXT("FindFreeSpace - EARLIER"), -1, NULL);
		break;

	case FIND_FIRST:
		Message(TEXT("FindFreeSpace - FIND_FIRST"), -1, NULL);
		break;

	case FIND_LAST:
		Message(TEXT("FindFreeSpace - FIND_LAST"), -1, NULL);
		break;

	case FIND_LARGEST:
		Message(TEXT("FindFreeSpace - FIND_LARGEST"), -1, NULL);
		break;

	case AT_END:
		Message(TEXT("FindFreeSpace - AT_END"), -1, NULL);
		break;

	case COUNT_FREE_SPACES:
		Message(TEXT("FindFreeSpace - COUNT_FREE_SPACES"), -1, NULL);
		break;

	default:
		Message(TEXT("FindFreeSpace - ERROR"), -1, NULL);
		return FALSE;
	}
	__try {

		//0.0E00 Preset return values for failure 
		VolData.Status = NEXT_ALGO_STEP;
		VolData.FoundLen = 0;
		VolData.FreeSpaces = 0;
		VolData.LargestFound = 0;

		//0.0E00 If find earlier than file is requested set the end of the search range to start of file 
		if(Type & EARLIER) {
			RangeStart = 0;
			RangeEnd = VolData.LastStartingLcn;
		}
		//0.0E00 If find largest is requested preset best found so far to smallest value 
		if(Type & FIND_LARGEST) {
			BestFitLength = 0;
		}

#ifndef OFFLINEDK
		//0.0E00 If find earliest requested preset size of minimum free space extent to search for.
		if(Type & FIND_FIRST) {
			RunLength = 1;
		}
#endif
		//0.0E00 Get a pointer to the free space bitmap 
		PVOLUME_BITMAP_BUFFER pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
		if (pVolumeBitmap == (PVOLUME_BITMAP_BUFFER) NULL){
			bRetStatus = FALSE;
			EH_ASSERT(FALSE);
			__leave;
		}

		pBitmap = (PULONG)&pVolumeBitmap->Buffer;

		//0.0E00 Scan thru the specified range looking for the specified type of free space extent 
		for(Lcn = RangeStart; Lcn < RangeEnd; ) {

			//0.0E00 Find the next free space extent within the range 
			FindFreeExtent(pBitmap, RangeEnd, &Lcn, &StartingLcn, &ClusterCount);
				
			//0.0E00 Stop if there are no more free space extents within the range 
			if(ClusterCount == 0) {
				break;
			}
			//0.0E00 Calc the end of this free space extent 
			EndingLcn = StartingLcn + ClusterCount;

			//0.0E00 Stop if earlier than file requested and this free space later than file 
			if((Type & EARLIER) && (EndingLcn > VolData.LastStartingLcn)) {
				break;
			}
			//0.0E00 If NTFS and range is outside MFT zone then clip the free space extent to exclude the MFT zone 
    		if((VolData.FileSystem == FS_NTFS) && (VolData.DestEndLcn != VolData.MftZoneEnd)) {

			    if((StartingLcn < VolData.MftZoneEnd) &&
				   (EndingLcn > VolData.MftZoneStart)) {

				    if(StartingLcn < VolData.MftZoneStart) {
					    EndingLcn = VolData.MftZoneStart;

				    } 
					else if(EndingLcn <= VolData.MftZoneEnd) {
					    continue;

    				//0.0E00 Handle the case of EndingLcn > pVolData->MftZoneEnd.
				    } 
					else {
					    StartingLcn = VolData.MftZoneEnd;
				    }
			    }
            }
			if(ClusterCount >= LargestFound) {
				LargestFound = ClusterCount;
			}

			//0.0E00 If we are only counting free space just bump the count and skip to the next free space extent 
			if(Type & COUNT_FREE_SPACES) {
				VolData.FreeSpaces ++;
				continue;
			}
			//0.0E00 Record this free space extent if any of the following conditions are met: 
			//0.0E00 Find earliest or find latest requested 
			//0.0E00 Find first fit or find last fit or find earlier  and the free space extent large enough 
			//0.0E00 Find largest and the free space extent largest so far 
			//0.0E00 Find best fit and the free space extent smallest so far that is large enough 
			if( (Type & (FIND_FIRST | FIND_LAST)) ||
				((Type & (LAST_FIT | FIRST_FIT | EARLIER)) && (ClusterCount >= RunLength)) ||
				((Type & FIND_LARGEST) && (ClusterCount > BestFitLength)) ||
				((Type & BEST_FIT) && (ClusterCount >= RunLength) && (ClusterCount < BestFitLength)) ) {

				BestFitStart = StartingLcn;
				BestFitLength = ClusterCount;
			}
			//0.0E00 Stop if find first...it has been found 
			if(Type & FIND_FIRST) {
				break;
			}
			//0.0E00 If find last fit and large enough skip to next free space extent
			if((Type & LAST_FIT) && (ClusterCount >= RunLength)) {
				continue;
			}
			//0.0E00 Stop if first fit or earlier and large enough 
			if( (Type & (FIRST_FIT | EARLIER)) &&
				(ClusterCount >= RunLength) ) {
				break;
			}
		}
		//0.0E00 If count free spaces exit now...that has been done
		if(Type & COUNT_FREE_SPACES) {
			bRetStatus = TRUE;
			__leave;
		}

		VolData.LargestFound = LargestFound;

		//0.0E00 If none were found that match the requirements then exit 
		if(BestFitLength == 0x7fffffffffffffff) {

			VolData.FoundLen = 0;
			wsprintf(cString,TEXT("No free space on disk for 0x%lX clusters."), (ULONG)RunLength);
			Message(cString, -1, NULL);
			bRetStatus = FALSE;
			__leave;
		}

		//0.0E00 If at end then calc Lcn to position at end of the free space extent
		if(Type & AT_END) {
			
			BestFitStart = (BestFitStart + BestFitLength) - RunLength;
			BestFitLength = RunLength;
		}
		//0.0E00 Pass back the free space extent's location and length
		VolData.FoundLcn = BestFitStart;
		VolData.FoundLen = BestFitLength;

		wsprintf(cString, TEXT("Found contiguous free space at LCN 0x%lX"), (ULONG)BestFitStart);
		wsprintf(cString+lstrlen(cString), TEXT(" for Cluster Count of 0x%lX"), (ULONG)BestFitLength);
   		Message(cString, -1, NULL);
		bRetStatus = TRUE;
	}
	__finally {
		if (VolData.hVolumeBitmap) {
			GlobalUnlock(VolData.hVolumeBitmap);
		}
	}

	return bRetStatus;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the volume bitmap and fill the MFT zone and all the buffer beyond the end of the bitmap with not-free.
    The volume bitmap is stored in the Buffer field of the VOLUME_BITMAP_BUFFER structure.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success
    FALSE - Failure
*/

BOOL
GetVolumeBitmap(
    )
{
    STARTING_LCN_INPUT_BUFFER   StartingLcnInputBuffer;
    PVOLUME_BITMAP_BUFFER       pVolumeBitmap = NULL;
    PULONG                      pBitmap = NULL;
    ULONG                       BytesReturned = 0;
    LONGLONG                    Cluster;
    BOOL                        bRetStatus = FALSE; // assume an error

    __try {

        //0.0E00 Lock and clear the bitmap buffer
        pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
        if (pVolumeBitmap == (PVOLUME_BITMAP_BUFFER) NULL){
            bRetStatus = FALSE;
            EH_ASSERT(FALSE);
            __leave;
        }

        ZeroMemory(pVolumeBitmap, (DWORD)(sizeof(VOLUME_BITMAP_BUFFER) + (VolData.BitmapSize / 8)));

        //0.0E00 Load the bitmap
        StartingLcnInputBuffer.StartingLcn.QuadPart = 0;
        pVolumeBitmap->BitmapSize.QuadPart = VolData.BitmapSize;

        BOOL ret = ESDeviceIoControl(
            VolData.hVolume,
            FSCTL_GET_VOLUME_BITMAP,
            &StartingLcnInputBuffer,
            sizeof(STARTING_LCN_INPUT_BUFFER),
            pVolumeBitmap,
            (DWORD)GlobalSize(VolData.hVolumeBitmap),
            &BytesReturned,
            NULL);

        if (!ret){
            bRetStatus = FALSE;
            EH_ASSERT(FALSE);
            __leave;
        }

        pBitmap = (PULONG)&pVolumeBitmap->Buffer;

        //0.0E00 Fill the MFT zone with not-free
/*        if(VolData.FileSystem == FS_NTFS) {

            Cluster = VolData.MftZoneStart;
            while((MODULUSLONGLONGBY32(Cluster) != 0) && (Cluster < VolData.MftZoneEnd)) {
                
                pBitmap[DIVIDELONGLONGBY32(Cluster)] |= (1 << (ULONG) MODULUSLONGLONGBY32(Cluster));
                Cluster ++;
            }

            if(Cluster < VolData.MftZoneEnd) {
                while(VolData.MftZoneEnd - Cluster >= 32) {

                    pBitmap[DIVIDELONGLONGBY32(Cluster)] = 0xffffffff;
                    Cluster += 32;
                }

                while(Cluster < VolData.MftZoneEnd) {

                    pBitmap[DIVIDELONGLONGBY32(Cluster)] |= (1 << (ULONG) MODULUSLONGLONGBY32(Cluster));
                    Cluster ++;
                }
            }
        }
*/        //0.0E00 Fill the end of bitmap with not-free
        for(Cluster = VolData.TotalClusters; Cluster < VolData.BitmapSize; Cluster ++) {
            pBitmap[DIVIDELONGLONGBY32(Cluster)] |= (1 << (ULONG) MODULUSLONGLONGBY32(Cluster));
        }
        // #DK312_083 JLJ 20May99
        // Make sure there's a zero bit in the fill-space (to stop the
        // used space/free space optimizations)
        Cluster = VolData.TotalClusters + 1;
        pBitmap[DIVIDELONGLONGBY32(Cluster)] &= ~(1 << (ULONG) MODULUSLONGLONGBY32(Cluster));

        bRetStatus = TRUE;
    }

    __finally {
        if(VolData.hVolumeBitmap) {
            GlobalUnlock(VolData.hVolumeBitmap);
        }
    }

    return bRetStatus;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Fills the MFT zone with not-free. (This is an ham-handed way of ensuring we
    don't move files into the MFT zone.)  The volume bitmap is stored in the Buffer
    field of the VOLUME_BITMAP_BUFFER structure.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success
    FALSE - Failure
*/

BOOL
MarkMFTUnavailable(void)
{
    //0.0E00 Lock the bitmap buffer and get a pointer to it...
    PVOLUME_BITMAP_BUFFER pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
    EF(pVolumeBitmap != NULL);
    
    //0.0E00 Get a pointer to the actual bitmap portion
    PULONG pBitmap = (PULONG)&pVolumeBitmap->Buffer;
    
    //0.0E00 Mark the MFT zone as "not free"
    if(VolData.FileSystem == FS_NTFS) {

        LONGLONG Cluster = VolData.MftZoneStart;

        // this loop marks the bits of the first DWORD in the bitmap
        // for the first few clusters of the MFT zone
        while (MODULUSLONGLONGBY32(Cluster) != 0 && Cluster < VolData.MftZoneEnd) {
            
            pBitmap[DIVIDELONGLONGBY32(Cluster)] |= (1 << (ULONG) MODULUSLONGLONGBY32(Cluster));
            Cluster++;
        }

        // this section gets the rest of the clusters
        if(Cluster < VolData.MftZoneEnd) {
            
            // mark out the groups of 32 cluster sections
            while(VolData.MftZoneEnd - Cluster >= 32) {
                
                pBitmap[DIVIDELONGLONGBY32(Cluster)] = 0xffffffff;
                Cluster += 32;
            }

            // mark out the remaining bits of the last section of the MFT zone
            while(Cluster < VolData.MftZoneEnd) {

                pBitmap[DIVIDELONGLONGBY32(Cluster)] |= (1 << (ULONG) MODULUSLONGLONGBY32(Cluster));
                Cluster++;
            }
        }
    }
    
    //0.0E00 Finally, unlock the bitmap...
    if(VolData.hVolumeBitmap) {
        GlobalUnlock(VolData.hVolumeBitmap);
    }
    
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Check the clusters adjacent to the start of this file to see if they are free.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success
    FALSE - Failure
*/

BOOL
IsFreeSpaceAtHeadOfFile(
    )
{
    BOOL                        bRetStatus = FALSE;
    PVOLUME_BITMAP_BUFFER       pVolumeBitmap = NULL;
    PULONG                      pBitmap = NULL;
    ULONG                       Mask = 1;
    LONGLONG                    Word = 0;
    LONGLONG                    Bit = 0;
    LONGLONG                    StartingLcn = VolData.StartingLcn;
    LONGLONG                    EndingLcn = VolData.StartingLcn;
    LONGLONG                    ClusterCount;
    TCHAR                       cString[500];

    __try {

        //0.0E00 Preset status in case an error occurs
        VolData.Status = NEXT_ALGO_STEP;
        VolData.FoundLen = 0;

        //0.0E00 Lock the bitmap and get a pointer to it
        pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
        if (pVolumeBitmap == (PVOLUME_BITMAP_BUFFER) NULL){
            bRetStatus = FALSE;
            EH_ASSERT(FALSE);
            __leave;
        }

        pBitmap = (PULONG)&pVolumeBitmap->Buffer;

        //0.0E00 Setup bitmap indexes
        Word = DIVIDELONGLONGBY32(StartingLcn - 1);
        Mask = 1 << (((ULONG)StartingLcn - 1) & 31);

        //0.0E00 Check for file against start of disk or one of the MFT zones
        if((StartingLcn == 0) || 
           (StartingLcn == VolData.MftZoneEnd) ||
           (StartingLcn == VolData.CenterOfDisk) ||
           ((pBitmap[Word] & Mask) != 0)) {

            Message(TEXT("No free space before this file"), -1, NULL);
            bRetStatus = TRUE;
            __leave;
        }

        //0.0E00 On FAT volumes any space before the file is enough
        if(VolData.FileSystem != FS_NTFS) {
            VolData.FoundLen = 1;
            Message(TEXT("Found free space before this file"), -1, NULL);     
            bRetStatus = TRUE;
            __leave;
        }
        //0.0E00 Find the start of the free space preceding this file
        while((Word >= 0) && ((pBitmap[Word] & Mask) == 0)) {

            Mask >>= 1;

            if(Mask == 0) {
                Mask = 0x80000000;

                for (Word--; (Word >= 0) && (pBitmap[Word] == 0); Word--)
                    ;
            }
        }
        Mask <<= 1;
        if(Mask == 0) {
            Mask = 1;
            Word ++;
        }
        for(Bit = -1; Mask; Mask >>= 1, Bit ++);
        
        //0.0E00 Convert the indexes into an Lcn
        StartingLcn = (Word * 32) + Bit;

        //0.0E00 Adjust for free space that spans the center of the disk
        if((VolData.StartingLcn >= VolData.CenterOfDisk) && (StartingLcn < VolData.CenterOfDisk)) {
            StartingLcn = VolData.CenterOfDisk;
        }                                       
        //0.0E00 Adjust for free space that spans the MFT zone
        if(VolData.FileSystem == FS_NTFS) {
        
            if((StartingLcn < VolData.MftZoneEnd) &&
               (EndingLcn > VolData.MftZoneStart)) {

                if(StartingLcn < VolData.MftZoneStart) {
                    EndingLcn = VolData.MftZoneStart;
                } 
                else if(EndingLcn <= VolData.MftZoneEnd) {
                    StartingLcn = VolData.MftZoneEnd;
                    EndingLcn = VolData.MftZoneEnd;
                } 
                //0.0E00 Handle the case of EndingLcn > VolData.MftZoneEnd.
                else {  
                    StartingLcn = VolData.MftZoneEnd;
                }
            }
        }
        ClusterCount = EndingLcn - StartingLcn;

        //0.0E00 Return the location and size of the free space found
        VolData.FoundLcn = StartingLcn;
        VolData.FoundLen = ClusterCount;

        wsprintf(cString, TEXT("Free space before file at LCN 0x%X"), VolData.FoundLcn);
        wsprintf(cString+lstrlen(cString), TEXT(" for Cluster Count of 0x%lX\n"), VolData.FoundLen);
        Message(cString, -1, NULL);
        bRetStatus = TRUE;
    }

    __finally {
        if (VolData.hVolumeBitmap) {
            GlobalUnlock(VolData.hVolumeBitmap); 
        }
    }

    return bRetStatus;
}

/*********************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Find the next run of un-allocated clusters.
    Bits set to '1' in the volume bitmap are allocated or "used".
    Bits set to '0' in the volume bitmap are un-allocated or "free".
    A bit set to '1' is considered "set".
    A bit set to '0' is considered "clear".

INPUT + OUTPUT:
    IN pClusterBitmap - Volume cluster bitmap
    IN RangeEnd - End of the area of the volume to search in
    IN OUT pLcn - Where to start searching and returns where search stopped
    OUT pStartingLcn - Returns where the free run starts
    OUT pClusterCount - Returns the length of the free run

GLOBALS:
    None.

RETURN:
    None
*/
VOID
FindFreeExtent(
    IN PULONG pClusterBitmap,
    IN LONGLONG RangeEnd,
    IN OUT PLONGLONG pLcn,
    OUT PLONGLONG pStartingLcn,
    OUT PLONGLONG pClusterCount
    )
{
    // default returns to 0
    *pStartingLcn = 0;
    *pClusterCount = 0;

    // check for bad LCN input
    if (pLcn == NULL) {
        Message(TEXT("FindFreeExtent called with NULL arg"), -1, NULL);
        assert(pLcn != NULL);
        return;
    }

    // check for bad RangeEnd
    if (RangeEnd > VolData.TotalClusters) {
        Message(TEXT("FindFreeExtent called with RangeEnd > TotalClusters"), -1, NULL);
        assert(RangeEnd <= VolData.TotalClusters);
        return;
    }

    // if requester asks for extent past end of volume, don't honor it.
    if (*pLcn >= RangeEnd) {
        Message(TEXT("FindFreeExtent called with LCN > RangeEnd"), -1, NULL);
        return;
    }

    // iBitmapWord - index into the cluster bitmap array (array of ULONGs)
    // divide lcn by word size (word index) = Lcn / 32 (same as shift right 5)
    ULONG iBitmapWord = (ULONG) DIVIDELONGLONGBY32(*pLcn);

    // iBit - index of the bit in the current word
    // remainder (bit index in current word) = Lcn % 32 (same as and'ing lowest 5 bits)
    ULONG iBit = (ULONG) MODULUSLONGLONGBY32(*pLcn);

    // LCN should always be the cluster array index times 32 plus the bit index
    assert(*pLcn == (iBitmapWord * 32) + iBit);

    // an empty word except for the starting Lcn bit
    ULONG Mask = (ULONG) (1 << iBit);
    
    // find the start of the next free space extent
    while (*pLcn < RangeEnd && *pStartingLcn == 0) {

        // checks
        assert(*pLcn == (iBitmapWord * 32) + iBit);
        assert(Mask != 0);
        assert(iBit >= 0 && iBit < 32);

        // if there are no free bits in the entire word we can jump ahead
        // we can only check this on a word boundary when iBit = 0
        if (iBit == 0 && pClusterBitmap[iBitmapWord] == 0xFFFFFFFF) {
            (*pLcn) += 32;
            iBitmapWord++;
            Mask = 1;
            continue;
        }

        // otherwise, check for a free cluster: bit = 0
        else if (!(pClusterBitmap[iBitmapWord] & Mask)) {
            *pStartingLcn = *pLcn;      // mark start of free space extent
        }

        // go to the next cluster
        (*pLcn)++;
        iBit++;
        Mask <<= 1;

        // check for crossing into the next word of the cluster array
        if (iBit >= 32) {
            iBit = 0;
            iBitmapWord++;
            Mask = 1;
        }
    }

    // LCN should always be the cluster array index times 32 plus the bit index
    assert(*pLcn == (iBitmapWord * 32) + iBit);

    // if we found a free cluster
    if (*pStartingLcn > 0) {

        // find the next used cluster
        // and count the free clusters
        while (*pLcn < RangeEnd) {

            // checks
            assert(*pLcn == (iBitmapWord * 32) + iBit);
            assert(Mask != 0);
            assert(iBit >= 0 && iBit < 32);

            // if the entire word is free space we can jump ahead
            // we can only check this on a word boundary when iBit = 0
            if (iBit == 0 && pClusterBitmap[iBitmapWord] == 0) {
                (*pLcn) += 32;
                iBitmapWord++;
                Mask = 1;
                continue;
            }

            // otherwise, check for a used cluster: bit = 1
            else if (pClusterBitmap[iBitmapWord] & Mask) {
                break;                      // we're done
            }

            // go to the next cluster
            (*pLcn)++;
            iBit++;
            Mask <<= 1;

            // check for crossing into the next word of the cluster array
            if (iBit >= 32) {
                iBit = 0;
                iBitmapWord++;
                Mask = 1;
            }
        }
    }

    // set cluster count
    if (*pStartingLcn > 0) {
        *pClusterCount = *pLcn - *pStartingLcn;
    }

    // sanity check of outputs
    assert(*pClusterCount == 0 && *pStartingLcn == 0 || 
           *pClusterCount > 0 && *pStartingLcn > 0);
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine is part of the so-called "partial defrag" code.  So called because
    in its current incarnation it really works on the whole file, not part of the file.

	This routine is called because there was no contiguous run of free space on the
    volume long enough to hold the entire file.  This routine uses the current size 
    of the file to estimate how many freespace extents might be needed to hold the 
    file (different if FAT or NTFS) and uses that data to fill an allocated array
    with free space extents.  This array is then used in the Partial Defrag routine
    to move the file around.

	The purpose of this routine is find free space that will get the file out of the
    way so that the rest of the volume can be defragmented.  It is not always clear 
    how one should accomplish this, however, so the routine gathers the data in different
    ways: toward the front of the partition, toward the back of the partition, or just
    using the largest available free extents.
    
	
INPUT + OUTPUT:
	None.

GLOBALS:
	IN OUT Various VolData fields.
    Allocated and initialized in this routine:
        pVolData->hFreeExtents = free space extent list, 
        pVolData->FreeExtents = number of free space extents.
    Updated in this routine:
        VolData.Pass = NEXT_FILE if return=false
        VolData.Pass = NEXT_ALGO_STEP if return=true

RETURN:
	TRUE - Success
	FALSE - Failure
*/

BOOL
FindLastFreeSpaceChunks(
                        )
{
	//the next item is static so it can be used to ping-pong the 
	//selection of the sort algorithm.	Just didn't seem worth 
	//it to add it to Voldata right now.
	BOOL						bRetStatus = FALSE;
	LONGLONG					FirstLcn = VolData.StartingLcn;
	LONGLONG					LastLcn = VolData.DestEndLcn;
	LONGLONG					RunLength = VolData.NumberOfClusters;
	EXTENT_LIST*				pExtentList = NULL;
	LONGLONG					FreeExtent = 0;
	TCHAR						cString[500];
	LONGLONG					SearchStartLcn = 0;
	LONGLONG					FreeStartLcn;
	LONGLONG					FreeCount;
	LONG						iii,jjj;
	
	Message(TEXT("FindLastFreeSpaceChunks"), -1, NULL);
	
	//0.0E00 Preset clusters found to none in case not enough are found
	VolData.Status = NEXT_ALGO_STEP;
	VolData.FoundLen = 0;
	
	__try {
		
		//0.0E00 Lock the volume bitmap, and get a pointer to it
		VOLUME_BITMAP_BUFFER *pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
		if (pVolumeBitmap == (PVOLUME_BITMAP_BUFFER) NULL){
			EH_ASSERT(FALSE);
			__leave;
		}
		
		//get a pointer that points to the bitmap part of the bitmap
		//(past the header)
		ULONG *pBitmap = (PULONG)&pVolumeBitmap->Buffer;
		
		//estimate the extent list entries needed to hold the file's new extent list
		//(Note, this is purely speculative jlj 15Apr99)
		if(VolData.FileSystem == FS_NTFS) {

			VolData.FreeExtents = 2 * (VolData.NumberOfClusters / 16);
		}
		else {
			VolData.FreeExtents = VolData.NumberOfClusters;
		}
		
		// limit the estimate to 2000 extents (at least for now)
		//(Note, this is purely speculative jlj 15Apr99)
		if (VolData.FreeExtents > 2000) {
			VolData.FreeExtents = 2000;
		}
		//John Joesph change not approved yet
		//VolData.FreeExtents = VolData.currentnumberoffragments -1.
		//if VolData.FreeExtents == 0 do something


		
		//0.0E00 Allocate a buffer for the free space extent list
		if (!AllocateMemory((DWORD)(VolData.FreeExtents * sizeof(EXTENT_LIST)), &VolData.hFreeExtents, (void**)&pExtentList)){
			VolData.Status = NEXT_FILE;
			EH_ASSERT(FALSE);
			__leave;
		}
		
		// This section of code scans the free space bitmap and finds the largest
		// chunks, but no more than VolData.FreeExtents chunks 
		// This code basically loops through the free space, gathering
		// the statistics for each fragment of free space, starting with
		// cluster zero
		SearchStartLcn = 0;

		while (SearchStartLcn != -1) {
			
			// go get a the next chunk of free space
			FindFreeExtent((PULONG) pBitmap,			// pointer to the volume bitmap gotten from locking 												 
				VolData.TotalClusters,					// end of range 
				&SearchStartLcn,						// where to start 
				&FreeStartLcn,							// where the free block starts 
				&FreeCount);							// how big the block is (zero if done) 
			
			//a return value of zero means the end of the partition has
			//been hit, so if we hit the end of the partition, stop the 
			//loop.
			if (FreeCount == 0) {
				SearchStartLcn = -1;
			} 
			else {
				
				//if there's space in the array, just insert it into the array			
				if (FreeExtent< (VolData.FreeExtents-1))  {
					//0.0E00 Add this extent to the free space extent list
					pExtentList[FreeExtent].StartingLcn = FreeStartLcn;
					pExtentList[FreeExtent].ClusterCount = FreeCount;
					FreeExtent++;
					continue;
				}

				// replace the current min with a bigger min
				UINT uMinIndex = 0;
				LONGLONG llMinClusterCount = 99999;
				for (iii=0; iii<FreeExtent; iii++) {
					if (pExtentList[iii].ClusterCount < llMinClusterCount) {
						uMinIndex = iii;
						llMinClusterCount = pExtentList[iii].ClusterCount;
					}
				}

				if (FreeCount > llMinClusterCount){
					pExtentList[iii].StartingLcn = FreeStartLcn;
					pExtentList[iii].ClusterCount = FreeCount;
				}
			}			//end else (i.e. FoundCount != 0)
		}				// end while searchstartlcn != -1
		
		// add up the clusters found
		LONGLONG FoundClusterCount = 0;
		for (iii=0; iii<FreeExtent; iii++) {
			FoundClusterCount = FoundClusterCount + pExtentList[iii].ClusterCount;
		}

		// not enough room to hold the file
		if (FoundClusterCount < VolData.NumberOfClusters) { 			
			Message(TEXT("FLFSC:Couldn't find enough free space for this file"), -1, NULL);
			VolData.Status = NEXT_FILE;
			__leave;
		}
		
		if (FreeExtent <= 1) {				
			Message(TEXT("FLFSC: NO FREE SPACE CHUNKS FOUND ON THIS VOLUME!!!"), -1, NULL);
			VolData.Status = NEXT_FILE;
			__leave;
		}
		
		//sort from big to small
		EXTENT_LIST tmpExtentList;
		BOOL bSwitched = TRUE;
		for (iii=0; iii<(FreeExtent-1) && bSwitched; iii++) {
			bSwitched = FALSE;
			for (jjj=0; jjj<(FreeExtent-1); jjj++) {
				if (pExtentList[jjj].ClusterCount < pExtentList[jjj+1].ClusterCount) {
					tmpExtentList = pExtentList[jjj];
					pExtentList[jjj] = pExtentList[jjj+1];
					pExtentList[jjj+1] = tmpExtentList;
					bSwitched = TRUE;
				}
			}
		}
		
		//0.0E00 If we found extents larger than the minimum we may have less extents than expected
		VolData.FreeExtents = FreeExtent-1;
		
		//0.0E00 Reallocate the free space entent list
		if (!AllocateMemory((DWORD)(VolData.FreeExtents * sizeof(EXTENT_LIST)), &VolData.hFreeExtents, (void**)&pExtentList)){
			bRetStatus = FALSE;
			EH_ASSERT(FALSE);
			__leave;
		}

		wsprintf(cString,TEXT("FLFSC: Found 0x%lX free extents for 0x%lX Clusters"), 
			(ULONG)VolData.FreeExtents, (ULONG)FoundClusterCount);
		Message(cString, -1, NULL);
		
		//0.0E00 Flag that we were successful
		VolData.FoundLcn = pExtentList->StartingLcn;
		VolData.FoundLen = FoundClusterCount;

		bRetStatus = TRUE;
	}
	
	__finally {
		if (VolData.hVolumeBitmap) {
			GlobalUnlock(VolData.hVolumeBitmap); 
		}
		if (VolData.hFreeExtents) { 
			GlobalUnlock(VolData.hFreeExtents); 
		}
	}
	
	return bRetStatus;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

REVISION HISTORY: 
	0.0E00 - 26 February 1996 - Chuck Tingley - created
	1.0E00 - 24 April 1997 - Zack Gainsforth - Reworked module for Dfrg engine.

ROUTINE DESCRIPTION:
	Partial defrag code.
	There is no contiguous run of free space on the volume long enough to hold the entire file.
	So we gonna move the file anyaway and in such a way that we hope will increase our chances 
	to defragment the drive. We gonna take the square root of the number of clusters in the file.
	Then we look for that many runs (or less) of that many free clusters per run (or more).
	This routine finds this set of free cluster runs and builds an extent list to describe the set.
	Then Another routine is called to move the file into these free space extents.
	Since the purpose here is to get this file out of the way so the rest of the volume can be 
	defragmented, the search is done from the end of the volume backward.
	pVolData->hFreeExtents = free space extent list, pVolData->FreeExtents = number of free space extents.

INPUT + OUTPUT:
	None.

GLOBALS:
	IN OUT Various VolData fields.

RETURN:
	TRUE - Success
	FALSE - Failure
*/
/*
BOOL
FindLastFreeSpaceChunks(
	)
{
	BOOL						bRetStatus = TRUE;
	VOLUME_BITMAP_BUFFER*		pVolumeBitmap = NULL;
	ULONG*						pBitmap = NULL;
	LONGLONG					FirstLcn = VolData.StartingLcn;
	LONGLONG					LastLcn = VolData.DestEndLcn;
	LONGLONG					Lcn;
	LONGLONG					StartingLcn;
	LONGLONG					ClusterCount;
    LONGLONG					RunLength = VolData.NumberOfClusters;
	EXTENT_LIST*				pExtentList = NULL;
	LONGLONG					ExtentLength;
	LONGLONG					FreeExtent = 0;
	LONGLONG					Extent;
	LONGLONG					LastStartingLcn;
	LONGLONG					LastClusterCount;
	LONGLONG					FoundClusterCount = 0;
	TCHAR						cString[500];

	Message(TEXT("FindLastFreeSpaceChunks"), -1, NULL);

	//0.0E00 Preset clusters found to none in case not enough are found
	VolData.Status = NEXT_ALGO_STEP;
	VolData.FoundLen = 0;
	
	__try {
		
#ifndef OFFLINEDK
		//0.0E00 Round file's total cluster size up to the nearest 16.
		if((VolData.FileSystem == FS_NTFS) && ((RunLength & 0x0F) != 0)) {
			RunLength = (RunLength & 0xFFFFFFFFFFFFFFF0) + 0x10;
		}
#endif
		//0.0E00 Use the square root of the file's cluster count for number of extents and size of each extent
		ExtentLength = (LONGLONG)sqrt((double)RunLength);

#ifndef OFFLINEDK
		//0.0E00 Round cluster length of extents up to the nearest 16.
		if((VolData.FileSystem == FS_NTFS) && ((ExtentLength & 0x0F) != 0)) {
			ExtentLength = (ExtentLength & 0xFFFFFFFFFFFFFFF0) + 0x10;
		}
#endif
		//0.0E00 Number of extents = total clusters / minimum extent length
		if (ExtentLength == 0){
			bRetStatus = FALSE;
			EH_ASSERT(FALSE);
			__leave;
		}

		VolData.FreeExtents = (VolData.NumberOfClusters / ExtentLength) + ((VolData.NumberOfClusters % ExtentLength) ? 1 : 0);

		//0.0E00 Allocate a buffer for the free space extent list
		if (!AllocateMemory((DWORD)(VolData.FreeExtents * sizeof(EXTENT_LIST)), &VolData.hFreeExtents, (void**)&pExtentList)){
			bRetStatus = FALSE;
			EH_ASSERT(FALSE);
			__leave;
		}

		//0.0E00 Lock the volume bitmap
		pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
		if (pVolumeBitmap == (PVOLUME_BITMAP_BUFFER) NULL){
			bRetStatus = FALSE;
			EH_ASSERT(FALSE);
			__leave;
		}
			
		pBitmap = (PULONG)&pVolumeBitmap->Buffer;

		//0.0E00 Find the set of the last free space extents of minimum size to hold the file
		for(FoundClusterCount = 0, FreeExtent = 0; 
			FoundClusterCount < RunLength; 
			FoundClusterCount += LastClusterCount, FreeExtent ++) {

			//0.0E00 Find the last extent that is long enough and not in the list yet
			for(LastClusterCount = 0, Lcn = FirstLcn; Lcn < LastLcn; ) {

				//0.0E00 Find the next extent
				FindFreeExtent(pBitmap, LastLcn, &Lcn, &StartingLcn, &ClusterCount);
				
				if(ClusterCount == 0) {
					break;
				}
				//0.0E00 If this extent is long enough...
				if(ClusterCount >= ExtentLength) {

					//0.0E00 ...And not already in the list...
					for(Extent = 0; 
						(Extent < FreeExtent) &&
						(pExtentList[Extent].StartingLcn != StartingLcn);
						Extent ++)
							;

					//0.0E00 ...Remember it
					if(Extent >= FreeExtent) {
						LastStartingLcn = StartingLcn;
						LastClusterCount = ClusterCount;
					}
				}
			}

			if(LastClusterCount == 0) {
				break;
			}

#ifndef OFFLINEDK
			//0.0E00 Round this extent's length down to the nearest 16.
			if(VolData.FileSystem == FS_NTFS) {
				LastClusterCount = LastClusterCount & 0xFFFFFFFFFFFFFFF0;
			}
#endif
			//0.0E00 Add this extent to the free space extent list
			pExtentList[FreeExtent].StartingLcn = LastStartingLcn;
			pExtentList[FreeExtent].ClusterCount = LastClusterCount;
		}
		//0.0E00 If we found extents larger than the minimum we may have less extents than expected
		if(FreeExtent < VolData.FreeExtents) {
			VolData.FreeExtents = FreeExtent;

			if(VolData.FreeExtents == 0){

				wsprintf(cString,TEXT("0x%lX free extents found for 0x%lX Clusters"), (ULONG)VolData.FreeExtents, (ULONG)RunLength);
				Message(cString, -1, NULL);

				VolData.Status = NEXT_FILE;
				return FALSE;
			}

			//0.0E00 Reallocate the free space entent list
			if (!AllocateMemory((DWORD)(VolData.FreeExtents * sizeof(EXTENT_LIST)), &VolData.hFreeExtents, (void**)&pExtentList)){
				bRetStatus = FALSE;
				EH_ASSERT(FALSE);
				__leave;
			}
		}
		wsprintf(cString,TEXT("Found 0x%lX free extents for 0x%lX Clusters"), (ULONG)VolData.FreeExtents, (ULONG)RunLength);
		Message(cString, -1, NULL);

		//0.0E00 Flag that we were successful
		VolData.FoundLcn = pExtentList->StartingLcn;
		VolData.FoundLen = FoundClusterCount;
		bRetStatus = TRUE;
	}

	__finally {
		if (VolData.hVolumeBitmap) {
			GlobalUnlock(VolData.hVolumeBitmap); 
		}
		if (VolData.hFreeExtents) { 
			GlobalUnlock(VolData.hFreeExtents); 
		}
	}

	return bRetStatus;
}
*/

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Counts the number of free spaces in the bitmap, and calculates stats about the free spaces.

INPUT + OUTPUT:

GLOBALS:
    LONGLONG NumFreeSpaces;                         //The number of free spaces on the volume.
    LONGLONG SmallestFreeSpaceClusters;             //The size of the smallest free space in clusters.
    LONGLONG LargestFreeSpaceClusters;              //The size of the largest free space in clusters.
    LONGLONG AveFreeSpaceClusters;                  //The average size of the free spaces in clusters.

RETURN:
    TRUE - Success
    FALSE - Failure
*/

BOOL
CountFreeSpaces(
    )
{
    PULONG pBitmap;
    LONGLONG LastLcn = 0;
    LONGLONG Lcn = 0;
    LONGLONG StartingLcn = 0;
    LONGLONG ClusterCount = 0;
    VOLUME_BITMAP_BUFFER* pVolumeBitmap = NULL;

    //Initialize the VolData fields.
    VolData.NumFreeSpaces = 0;
    VolData.SmallestFreeSpaceClusters = 0x7FFFFFFFFFFFFFFF;
    VolData.LargestFreeSpaceClusters = 0;
    VolData.AveFreeSpaceClusters = 0;

    //0.0E00 Lock the volume bitmap
    pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
    EF_ASSERT(pVolumeBitmap);

    //Get a pointer to the bitmap.
    pBitmap = (PULONG)&pVolumeBitmap->Buffer;

    //Get the length of the bitmap.
    LastLcn = VolData.TotalClusters;

    //This loop will cycle until the end of the volume.
    do{
        //Find the next extent
        FindFreeExtent(pBitmap, LastLcn, &Lcn, &StartingLcn, &ClusterCount);
        
        //Check to make sure a free space was found.
        if(ClusterCount == 0) {
            break;
        }

        //Note the running total of free space extents.
        VolData.NumFreeSpaces++;

        //Keep track of the smallest free space extent.
        if(VolData.SmallestFreeSpaceClusters > ClusterCount){
            VolData.SmallestFreeSpaceClusters = ClusterCount;
        }

        //Keep track of the largest free space extent.
        if(VolData.LargestFreeSpaceClusters < ClusterCount){
            VolData.LargestFreeSpaceClusters = ClusterCount;
        }

        //Reset StartingLcn to point to the next position to check from.
        StartingLcn += ClusterCount;

        //Reset ClusterCount.
        ClusterCount = 0;

    }while(StartingLcn < VolData.TotalClusters);

    //Calculate the average free space extent size.
    if(VolData.NumFreeSpaces){
        VolData.AveFreeSpaceClusters = (VolData.TotalClusters - VolData.UsedClusters) / VolData.NumFreeSpaces;
    }
    else{
        VolData.AveFreeSpaceClusters = 0;
    }

    GlobalUnlock(VolData.hVolumeBitmap);

    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Examines the freespace map of the volume and does statistical breakdown on it for
    debugging purposes.

    29Apr99 - Also summarizes "truly usable freespace" so that user can be informed if
    volume is getting too full for defragmentation.

OUTPUT:
    LONGLONG * llUsableFreeClusters - clusters that are actually usable

RETURN:
    TRUE - Success
    FALSE - Failure
*/
BOOL
DetermineUsableFreespace(
                        LONGLONG *llUsableFreeClusters
                        )
{
    const MAX_BUCKET = 16;
    struct {
        UINT uLowerBound;
        UINT uUpperBound;
        LONGLONG llFragCount;
        LONGLONG llTotalFragSize;
    }  freeBuckets[MAX_BUCKET] = {0};

    LONGLONG llPercentOfFreeFragments;
    LONGLONG llPercentOfFreeSpace;
    LONGLONG llTotalFreeClusters = 0;
    LONGLONG llTotalFreeFragments = 0;
    LONGLONG SearchStartLcn = 0;
    LONGLONG FreeStartLcn;
    LONGLONG FreeCount;
    TCHAR cOutline[1024];
    TCHAR cTemp[20];
    UINT iBucket;

    LONGLONG llSumTotalFreeClusters = 0;
    LONGLONG llSumUsableFreeClusters = 0;
    LONGLONG llSumUnusableFreeClusters = 0;

    Trace(log, " ");
    Trace(log, "Start:  Determine UsableFreeSpace");

    //clear return
    *llUsableFreeClusters = 0;

    //1.0E00 Load the volume bitmap. (MFT-excluded)
    EF(MarkMFTUnavailable());

    //0.0E00 Lock and grab a pointer to the volume bitmap
    PVOLUME_BITMAP_BUFFER pVolumeBitmap = (PVOLUME_BITMAP_BUFFER) GlobalLock(VolData.hVolumeBitmap);
    EF(pVolumeBitmap);

    //set up the first bucket's bounds
    freeBuckets[0].uLowerBound = 0;
    freeBuckets[0].uUpperBound = 2;

    //then fill in the parameters for the remainder of the buckets
    for (iBucket=1; iBucket<MAX_BUCKET; iBucket++) {
        //ensure the low bound of the bucket is the last bucket's high side plus one
        freeBuckets[iBucket].uLowerBound = freeBuckets[iBucket-1].uUpperBound + 1;
        //make the high bound of the bucket 2x the last bucket's high bound
        freeBuckets[iBucket].uUpperBound = freeBuckets[iBucket-1].uUpperBound * 2;
    }
        
    //last bucket dump headers
    Trace(log, "    last bucket detail:");
    Trace(log, "    LCN       LEN");
    Trace(log, "    --------  --------");
    
    //this is just a copy of the loop that "prints the freespace clusters"
    //above.  Basically, it just loops through the free space, gathering
    //the statistics for each fragment of free space, starting with cluster zero
    SearchStartLcn = 0;

    while (SearchStartLcn != -1) {
        
        // go get a the next chunk of free space
        FindFreeExtent((PULONG) pVolumeBitmap->Buffer, // pointer to the volume bitmap gotten from locking                                                  
            VolData.TotalClusters,                  // end of range 
            &SearchStartLcn,                        // where to start 
            &FreeStartLcn,                          // where the free block starts 
            &FreeCount);                            // how big the block is (zero if done) 

        llSumTotalFreeClusters += FreeCount;
        llSumUsableFreeClusters += FreeCount;

        //a return value of zero means the end of the bitmap has
        //been hit, so if we hit the end of the bitmap, stop the 
        //loop.
        if (FreeCount == 0) {
            SearchStartLcn = -1;
        } 
        else { //we got a value, so do the statistics on it.

            *llUsableFreeClusters += FreeCount;

            //see if the free space fragment fits in a bucket
            //(I guess this could have been done with a binary search
            //method, but why bother for 16 items?)
            BOOL bFoundTheBucket = FALSE;
            for (iBucket=0; iBucket < MAX_BUCKET && !bFoundTheBucket; iBucket++) {
                if (FreeCount >= freeBuckets[iBucket].uLowerBound &&
                    FreeCount <= freeBuckets[iBucket].uUpperBound) {

                    //if it fits in this bucket:
                    //(a) increment the fragment count for this bucket
                    freeBuckets[iBucket].llFragCount++;
                    //(b) add up the size of the fragments in this bucket
                    freeBuckets[iBucket].llTotalFragSize += FreeCount;
                    //(c) add it into the total free space count 
                    llTotalFreeClusters += FreeCount;
                    //(d) and count it on the total fragment count
                    llTotalFreeFragments++;

                    //then set the flag saying the buck for this 
                    //free space was found. (the loop will then end)
                    bFoundTheBucket = TRUE;
                }
            }

            //if we got here and it didn't fit in a bucket, just put it
            //in the last bucket
            if (!bFoundTheBucket) {
                iBucket = MAX_BUCKET - 1;
                freeBuckets[iBucket].llFragCount++;
                freeBuckets[iBucket].llTotalFragSize += FreeCount;
                llTotalFreeClusters += FreeCount;
                llTotalFreeFragments++;
            }

            //dump the last bucket
            if (iBucket == MAX_BUCKET - 1) {
                Trace(log, "    %8lu  %8lu", (ULONG) FreeStartLcn, (ULONG) FreeCount);
            }
        } //end else (i.e. FoundCount != 0)
    } // end while searchstartlcn != -1

    //last bucket dump footers
    Trace(log, "    --------  --------", -1, NULL);
    Trace(log, "    total:    %8lu", (ULONG) freeBuckets[MAX_BUCKET - 1].llTotalFragSize);

    //ensure no division by zero
    if (llTotalFreeClusters == 0) llTotalFreeClusters = 1;
    if (llTotalFreeFragments == 0) llTotalFreeFragments = 1;

    //print the statistics header
    Trace(log, " ");
    Trace(log, "                       Occurs x   Totalled  %% of      %% of ");
    Trace(log, "    Freespace of sizes  times     clusters  Fragments Free Space ");
    Trace(log, "    ------------------ --------   --------- --------- ----------- ");

    //dump the data
    for (iBucket = 0; iBucket<MAX_BUCKET; iBucket++) {      

        //compute the percentage this bucket is of the free fragments
        llPercentOfFreeFragments = (1000000 * freeBuckets[iBucket].llFragCount) / llTotalFreeFragments;
        //compute the percentage this bucket is of the free clusters
        llPercentOfFreeSpace = (1000000 * freeBuckets[iBucket].llTotalFragSize) / llTotalFreeClusters;
        
        //special case; if the bucket is the last one, just say "maximum" instead of the
        //value as the upper bound, since that's how the code above works
        if (iBucket == (MAX_BUCKET - 1)) {
            wsprintf (cTemp, TEXT(" maximum"));
        }
        else {
            wsprintf (cTemp, TEXT("%8lu"), (ULONG)freeBuckets[iBucket].uUpperBound);
        }

        //now we can print the detail line; note the quad percent signs, this
        //is what we need in the boot-time code; it may not be needed elsewhere
        Trace(log, "    %8lu-%8s %8lu   %8lu  %3ld.%04ld%%   %3ld.%04ld%% ",
            (ULONG) freeBuckets[iBucket].uLowerBound,
            cTemp,
            (ULONG) freeBuckets[iBucket].llFragCount,
            (ULONG) freeBuckets[iBucket].llTotalFragSize,
            (LONG)  llPercentOfFreeFragments/10000,
            (LONG)  llPercentOfFreeFragments%10000,
            (LONG)  llPercentOfFreeSpace/10000,
            (LONG)  llPercentOfFreeSpace%10000);
    }       //end the loop (iBucket=0->MAX_BUCKET-1)
    
    // print some summary data
    Trace(log, "    ------------------ --------   --------- --------- -----------");

    //such as the total clusters and fragments; this is a bit redundant, but if
    //it's all printed, some self-consistency checks can be done (and bugs located)
    Trace(log, "    Totals:           %8lu   %8lu  ",
        (ULONG) llTotalFreeFragments,
        (ULONG)llTotalFreeClusters);
    //compute the percentage this bucket is of the free fragments
    LONGLONG llUsableFreePercent = 100;
    if (VolData.TotalClusters != 0) {
        llUsableFreePercent = (1000000 * *llUsableFreeClusters) / VolData.TotalClusters;
    }
        
    //additionally, report the free space truly usable by the defragmenter
    Trace(log, "  ");
    Trace(log, "    Usable free space: %8lu clusters (%3ld.%04ld%% of volume space)",
        (ULONG) *llUsableFreeClusters, 
        (LONG)   llUsableFreePercent / 10000,
        (LONG)   llUsableFreePercent % 10000);

    LONGLONG llCalcFreeClusters;
    LONGLONG llCalcFreePercent = 100;

    Trace(log, "    Sum usable free space: %I64d clusters", llSumUsableFreeClusters);
    Trace(log, "    Sum unusable free space: %I64d clusters", llSumUnusableFreeClusters);
    Trace(log, "    Sum total free space: %I64d clusters", llSumTotalFreeClusters);
    Trace(log, " ");
    Trace(log, "      Total free space: %I64d clusters", VolData.TotalClusters - VolData.UsedClusters);
    Trace(log, "    - MFT zone: %I64d clusters", VolData.MftZoneEnd - VolData.MftZoneStart);
    Trace(log, "    - sum unusable free space: %I64d clusters", llSumUnusableFreeClusters);

    llCalcFreeClusters = VolData.TotalClusters - VolData.UsedClusters - 
                         (VolData.MftZoneEnd - VolData.MftZoneStart) - llSumUnusableFreeClusters;
    if (VolData.TotalClusters != 0) {
        llCalcFreePercent = (1000000 * llCalcFreeClusters) / VolData.TotalClusters;
    }

    Trace(log, "    = Usable free space: %I64d clusters (%3ld.%02ld%%)", 
              llCalcFreeClusters, (LONG) llCalcFreePercent / 10000, (LONG) llCalcFreePercent % 10000);
    Trace(log, " ");

    assert(llSumTotalFreeClusters == llSumUsableFreeClusters + llSumUnusableFreeClusters);
    assert(llSumUsableFreeClusters == *llUsableFreeClusters);

    if(VolData.hVolumeBitmap) {
        GlobalUnlock(VolData.hVolumeBitmap);
    }

    Trace(log, "End:  Determine UsableFreeSpace");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\fssubs.cpp ===
/****************************************************************************************************************

File Name: FsSubs.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

Description: Common file system routines.

/***************************************************************************************************************/

#include "stdafx.h"

#ifdef OFFLINEDK
    extern "C"{
        #include <stdio.h>
    }
#endif

#ifdef BOOTIME
    #include "Offline.h"
#else
    #include "Windows.h"
#endif

#include <winioctl.h>

extern "C" {
    #include "SysStruc.h"
}

#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"

#include "FsSubs.h"
#include "Alloc.h"
#include "Message.h"
#include "Devio.h"
#include "IntFuncs.h"
#include "ErrMsg.h"
#include "Message.h"
#include "Logging.h"
#include "GetDfrgRes.h"
#include "getreg.h"
#include "Exclude.h"
#include "FreeSpace.h"

#include "UiCommon.h"

#define THIS_MODULE 'S'
#include "logfile.h"

#ifdef DFRGNTFS
    #include "NtfsSubs.h"
#else
    #include "FatSubs.h"
#endif


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This gets the file system for a drive and returns a numeric value giving which file system it is.
    The second version also returns the volume name too.

    There are two versions, one for offline DK and one for online and DKMS.

INPUT + OUTPUT:
    IN DriveLetter - The drive letter to get the file system of.
    OUT pFileSystem - Where to put the ULONG identifying the file system.
    OUT pVolumeName - The name of the volume.  Must be MAX_PATH length or greater. (only on second version).

GLOBALS:
    None.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

#ifdef OFFLINEDK
BOOL
GetFileSystem(
    IN TCHAR DriveLetter,
    OUT PULONG pFileSystem
    )
{
    TCHAR                           cDrive[8];
    HANDLE                          hVolume;
    NTSTATUS                        Status;
    IO_STATUS_BLOCK                 IoStatus = {0};
    HANDLE                          hFsAttrInfo = NULL;
    FILE_FS_ATTRIBUTE_INFORMATION*  pFsAttrInfo = NULL;
    BOOL                            bReturnValue = FALSE; // assume error

    EF(AllocateMemory(sizeof(FILE_FS_ATTRIBUTE_INFORMATION)+MAX_PATH, &hFsAttrInfo, (void**)&pFsAttrInfo));

    __try {
        //0.0E00 Get handle to volume
        _stprintf(cDrive, TEXT("\\\\.\\%c:"), DriveLetter);
        hVolume = CreateFile(
            cDrive, 
            0,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
            NULL);

        if (hVolume == INVALID_HANDLE_VALUE){
            EH(FALSE);
            __leave;
        }
            
        Status = NtQueryVolumeInformationFile(
            hVolume,
            &IoStatus,
            pFsAttrInfo,
            sizeof(FILE_FS_ATTRIBUTE_INFORMATION)+50,
            FileFsAttributeInformation);

        CloseHandle(hVolume);

        if (!NT_SUCCESS(Status)){
            EH(FALSE);
            __leave;
        }

        //Add a null terminator.
        pFsAttrInfo->FileSystemName[pFsAttrInfo->FileSystemNameLength] = 0;

        //1.0E00 Compare the file system name against the known types and return an appropriate value.
        //       Note: FileSystemName in this structure is always WideChar

        if(_tcscmp(pFsAttrInfo->FileSystemName, TEXT("NTFS")) == 0){
            *pFileSystem = FS_NTFS;
        }
        else if(_tcscmp(pFsAttrInfo->FileSystemName, TEXT("FAT")) == 0){
            *pFileSystem = FS_FAT;
        }
        else if(_tcscmp(pFsAttrInfo->FileSystemName, TEXT("FAT32")) == 0){
            *pFileSystem = FS_FAT32;
        }
        else {
            *pFileSystem = FS_NONE;

        }

        bReturnValue = TRUE; // all is ok
    }

    __finally {
        if (hFsAttrInfo) {
            EH_ASSERT(GlobalUnlock(hFsAttrInfo) == FALSE);
            EH_ASSERT(GlobalFree(hFsAttrInfo) == NULL);
        }
    }

    return bReturnValue;
}

#else

BOOL
GetFileSystem(
    IN PTCHAR volumeName,
    OUT PULONG pFileSystem,
    OUT TCHAR* pVolumeLabel
    )
{
    TCHAR cVolumeLabelBuffer[100];
    TCHAR cFileSystemNameBuffer[16];
    TCHAR cTmpVolumeName[GUID_LENGTH+1];
    //TCHAR cDrive[8];

    //1.0E00 Get the file system name in text.
    //_stprintf(cDrive, TEXT("%c:\\"), DriveLetter);

    // the UNC version of the vol name needs an additional backslash
    // GUID version must look like: "\\?\Volume{06bee7c1-82cf-11d2-afb2-000000000000}\\"
    _stprintf(cTmpVolumeName, TEXT("%s\\"), volumeName);

    BOOL retCode = GetVolumeInformation(
        cTmpVolumeName,
        cVolumeLabelBuffer,
        sizeof(cVolumeLabelBuffer) / sizeof(TCHAR),
        NULL,
        NULL,
        NULL,
        cFileSystemNameBuffer,
        15);

    if (!retCode){
        Message(TEXT("GetFileSystem() failed"), GetLastError(), volumeName);
        EF(FALSE);
    }

    //Store the name of the volume.
    _tcscpy(pVolumeLabel, cVolumeLabelBuffer);

    //1.0E00 Compare the file system name against the known types and return an appropriate value.


    if(lstrcmp(cFileSystemNameBuffer, TEXT("NTFS")) == 0){
        *pFileSystem = FS_NTFS;
    }
    else if(lstrcmp(cFileSystemNameBuffer, TEXT("FAT")) == 0){
        *pFileSystem = FS_FAT;
    }
    else if(lstrcmp(cFileSystemNameBuffer, TEXT("FAT32")) == 0){
        *pFileSystem = FS_FAT32;
    }
    else{
        *pFileSystem = FS_NONE;
    }
    return TRUE;
}

#endif

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Sometimes retrieval pointers are stored that list two extents that are in fact contiguous.  This function spots
    this occurrence and "collapses" the extent list so it only shows one large extent in place of two smaller
    extents.  Also, compressed files have two retrieval pointers per extent.  The first contains the actual extent
    on the disk, the second contains the virtual extent, which contains only a count of how many clusters the
    extent would be if it weren't compressed.  The second extents are called virtual extents and contain a starting
    Lcn of 0xFFFFFFFFFFFFFFFF to identify them as virtual.  While these virtual extents are not removed from our
    extent list, they aren't counted as separate extents in the file.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT VolData.NumberOfExtents - The number of extents in the extent list.
    IN OUT VolData.pExtentList - The extent list.
    OUT VolData.NumberOfFragments - The number of fragments in this file.
    OUT VolData.ExtentsState - Whether or not the file is contiguous or fragmented.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
CollapseExtentList(
    EXTENT_LIST_DATA* pExtentData
    )
{
    LONGLONG Extent = 0;
    LONGLONG Dest;
    UINT i;
    FILE_EXTENT_HEADER* pFileExtentHeader;
    STREAM_EXTENT_HEADER* pStreamExtentHeader;
    STREAM_EXTENT_HEADER* pNextStreamExtentHeader;
    UCHAR* pThisStreamEnd;
    EXTENT_LIST* pExtents;
    UCHAR* pExtentListEnd;

    pFileExtentHeader = (FILE_EXTENT_HEADER*)pExtentData->pExtents;
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pExtentData->pExtents + sizeof(FILE_EXTENT_HEADER));
    pNextStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST));
    pExtentListEnd = (UCHAR*)pExtentData->pExtents + pExtentData->ExtentListSize;

    //Note that the old excess extents count might be invalid when we recount the extents after collapsing them.
    pFileExtentHeader->ExcessExtents = 0;

    //Loop through each stream.  We're going collapse extents stream by stream.
    for(i=0; i<pFileExtentHeader->NumberOfStreams; i++){

        pStreamExtentHeader->ExcessExtents = 0;

        //This count will only include normal extents.  It will not count virtual extents as separate.
        if(pStreamExtentHeader->ExtentCount){
            //This stream has an extent in it, therefore it has at least one fragment.
            VolData.NumberOfFragments = pFileExtentHeader->NumberOfStreams;
        }

        //Get a pointer to this stream's extents.
        pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

        //0.1E00 Collapse the extent list by combining adjacent extents
        //0.1E00 Go through each extent and see if it is really adjacent to the next and combine them if they are.
        for(Dest = Extent = 1; Extent < pStreamExtentHeader->ExtentCount; Extent ++){
        
            //0.1E00 If this extent is adjacent to the last extent
            if(pExtents[Extent - 1].StartingLcn + 
               pExtents[Extent - 1].ClusterCount ==
               pExtents[Extent].StartingLcn){

                //0.1E00 Combine this extent into the last and don't move the dest index
                pExtents[Dest - 1].ClusterCount += pExtents[Extent].ClusterCount;
            
            }else{

                //0.1E00 Copy this extent to the dest index and bump the dest index
                pExtents[Dest].StartingLcn = pExtents[Extent].StartingLcn;
                pExtents[Dest ++].ClusterCount = pExtents[Extent].ClusterCount;
            }
        }

        //0.1E00 If we found some adjacent extents, the Dest count will be less than the previous count for the number of extents.
        //0.1E00 Update the number of extents in this file.
        if(Dest != pStreamExtentHeader->ExtentCount){
            pStreamExtentHeader->ExtentCount = (DWORD)Dest;
        }

        //0.1E00 Determine the number of fragments in this file
        
        //0.1E00 The while loop below will count the number of fragments in this file by excluding the virtual extents, and not counting adjacent extents.

        //0.1E00 First get the first extent that isn't virtual -- Viz, break out of this loop as soon as we find an extent
        //0.1E00 whose starting lcn is not 0xFFFFFFFFFFFFFFFF.  
        for(Extent = 0; 
            (Extent < pStreamExtentHeader->ExtentCount) &&
            (pExtents[Extent].StartingLcn == 0xFFFFFFFFFFFFFFFF); 
            Extent ++);

        //0.1E00 Find the second extent that isn't virtual.
        for(Dest = Extent ++; 
            (Extent < pStreamExtentHeader->ExtentCount) &&
            (pExtents[Extent].StartingLcn == 0xFFFFFFFFFFFFFFFF); 
            Extent ++);

        //0.1E00 Count all the extents as fragments if they are not adjacent and non-virtual.
        while(Extent < pStreamExtentHeader->ExtentCount){

            if ((VolData.BootOptimizeEndClusterExclude) &&
                (pExtents[Extent].StartingLcn < VolData.BootOptimizeEndClusterExclude) &&
                ((pExtents[Extent].StartingLcn + pExtents[Extent].ClusterCount) > VolData.BootOptimizeBeginClusterExclude)
                ) {
                //
                // Set the flag to indicate that this file is in the region
                // marked for boot-optimise files.  Note that if                 
                // VolData.BootOptimizeEndClusterExclude is 0, we don't care
                // about this flag and don't perform the rest of the check to
                // see if this is in the boot-optimise region
                //
                VolData.bInBootExcludeZone = TRUE;
            }
            
            //0.1E00 If these two extents are not adjacent, count the fragment.
            if(pExtents[Extent].StartingLcn != 
               pExtents[Dest].StartingLcn + 
               pExtents[Dest].ClusterCount){

                pFileExtentHeader->ExcessExtents++;
                pStreamExtentHeader->ExcessExtents++;
                VolData.NumberOfFragments ++;
            }

            //0.1E00 Look for the next non-virtual extent.
            for(Dest = Extent ++; 
                (Extent < pStreamExtentHeader->ExtentCount) &&
                (pExtents[Extent].StartingLcn == 0xFFFFFFFFFFFFFFFF); 
                Extent ++);
        }

        //Note the end of this stream.
        pThisStreamEnd = (UCHAR*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST));

        //Note how much the whole extent list is shrinking. (If the size of this stream didn't change, this is a simple -= 0).
        pExtentData->ExtentListSize -= (DWORD)((UCHAR*)pNextStreamExtentHeader - (UCHAR*)pThisStreamEnd);

        //If there is another stream after the current one, then move it up against this stream.
        //Don't do this move if nothing has been changed in the previous stream: the dest and source for the move are equal.
        if(i < pFileExtentHeader->NumberOfStreams-1 && (char*)pThisStreamEnd != (char*)pNextStreamExtentHeader){
            //Move the later streams up to butt against the new end of the extent list.
            MoveMemory(pThisStreamEnd, (UCHAR*)pNextStreamExtentHeader, (DWORD)((UCHAR*)pExtentListEnd-(UCHAR*)pNextStreamExtentHeader));

            //Reset the pointer to the end of the extent list to point to the new end of the extent list.
            pExtentListEnd = (UCHAR*)pExtentData->pExtents + pExtentData->ExtentListSize;
        }

        //Go to the next stream.
        pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST));
        if((ULONG_PTR)pStreamExtentHeader < (ULONG_PTR)pExtentListEnd){
            //Only get a pointer to the next next stream if we haven't gone off the end of the known extent list yet.
            pNextStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST));
        }
    }

    //0.1E00 If there is only one fragment per stream, then the file is contiguous, otherwise it is fragmented.
    VolData.bFragmented = (VolData.NumberOfFragments <= pFileExtentHeader->NumberOfStreams) ? FALSE : TRUE;

    //0.1E00 Get the lowest Lcn of the file.  This is used in our algorithms to determine which files to move.
    EF(GetLowestStartingLcn(&VolData.StartingLcn, pFileExtentHeader));
    return TRUE;
}

BOOL
CountStreamExtentsAndClusters(
    DWORD dwStreamNumber,
    LONGLONG* pExcessExtents,
    LONGLONG* pClusters
    )
{
/*  LONGLONG Extent = 0;
    LONGLONG Dest;
    UINT i;
    FILE_EXTENT_HEADER* pFileExtentHeader;
    STREAM_EXTENT_HEADER* pStreamExtentHeader;
    EXTENT_LIST* pExtents;

    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));

    //Check for a valid stream number.
    EF_ASSERT(dwStreamNumber<pFileExtentHeader->TotalNumberOfStreams);

    *pExcessExtents = 0;
    *pClusters = 0;
//  *pRealClusters = 0;

    //Find the stream we were working on before.
    //Loop through until we hit the one we were on, each time bumping the stream header to the next stream.
    for(i=0; i<pFileExtentHeader->NumberOfStreams; i++){
        if(pStreamExtentHeader->StreamNumber != dwStreamNumber){
            pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST));
        }
    }

    //Get a pointer to this stream's extents.
    pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

    //0.1E00 Determine the number of fragments and real clusters in this file
    
    //0.1E00 The while loop below will count the number of fragments in this file by excluding the virtual extents, and not counting adjacent extents.

    //0.1E00 First get the first extent that isn't virtual -- Viz, break out of this loop as soon as we find an extent
    //0.1E00 whose starting lcn is not 0xFFFFFFFFFFFFFFFF.  
    for(Extent = 0; 
        (Extent < pStreamExtentHeader->ExtentCount) &&
        (pExtents[Extent].StartingLcn == 0xFFFFFFFFFFFFFFFF); 
        Extent ++);

    //0.1E00 Find the second extent that isn't virtual.
    for(Dest = Extent ++; 
        (Extent < pStreamExtentHeader->ExtentCount) &&
        (pExtents[Extent].StartingLcn == 0xFFFFFFFFFFFFFFFF); 
        Extent ++);

    //0.1E00 Count all the extents as fragments if they are not adjacent and non-virtual.
    while(Extent < pStreamExtentHeader->ExtentCount){

//      //Keep a running total of the number of real clusters.
//      *pRealClusters += pExtents[Dest].ClusterCount;

        //0.1E00 If these two extents are not adjacent, count the fragment.
        if(pExtents[Extent].StartingLcn != 
           pExtents[Dest].StartingLcn + 
           pExtents[Dest].ClusterCount){

            pExcessExtents++;
        }

        //0.1E00 Look for the next non-virtual extent.
        for(Dest = Extent ++; 
            (Extent < pStreamExtentHeader->ExtentCount) &&
            (pExtents[Extent].StartingLcn == 0xFFFFFFFFFFFFFFFF); 
            Extent ++);
    }

//  //Don't forget to add the last extent's cluster count to the total of real clusters.
//  *pRealClusters += pExtents[Extent].ClusterCount;

    //Now loop through and count the number of virtual clusters in the file.
    for(Extent=0; Extent<pStreamExtentHeader->ExtentCount; Extent++){
        *pClusters += pExtents[Extent].ClusterCount;
    }

*/  return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Determine which is the lowest Lcn in the file, but not one that's in the MFT zone unless the entire
    file is in the MFT zone.  Make sense?

INPUT + OUTPUT:
    OUT pStartingLcn - The lowest Lcn in the file

GLOBALS:
    IN VolData.pExtentList - The extent list for the file.
    IN VolData.NumberOfExtents - The number of extents in the extent list.
    IN VolData.NumberOfFragments - The number of fragments in the file.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
GetLowestStartingLcn(
    OUT LONGLONG* pStartingLcn,
    FILE_EXTENT_HEADER* pFileExtentHeader
    )
{
    LONGLONG Extent = 1;
    LONGLONG LowestStartingLcn;
    LONGLONG Lcn;
    UINT i;
    STREAM_EXTENT_HEADER* pStreamExtentHeader;
    EXTENT_LIST* pExtents;

    EF_ASSERT(pStartingLcn);

    //Initialize the return StartingLcn.
    *pStartingLcn = 0;

    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pFileExtentHeader + sizeof(FILE_EXTENT_HEADER));

    //Loop through each stream.  We're going to return the lowest starting lcn for any stream.
    for(i=0; i<pFileExtentHeader->NumberOfStreams; i++){
        //Get a pointer to this stream's extents.
        pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

        //0.0E00 Find the first non-virtual extent 
        for(Extent = 0; 
            (Extent < pStreamExtentHeader->ExtentCount) && 
            (pExtents[Extent].StartingLcn == 0xFFFFFFFFFFFFFFFF); 
            Extent ++);

        //0.0E00 Don't suicide on compressed files of all zeros which use no clusters on the volume
        if(Extent >= pStreamExtentHeader->ExtentCount){
            //Go to the next stream.
            continue;
        }

        //0.0E00 Use first extent as reference Lcn
        LowestStartingLcn = pExtents[Extent ++].StartingLcn;

        //0.1E00 Only flip through the extents of the file if it's fragmented.
        if(pStreamExtentHeader->ExtentCount > 1){
            //0.0E00 Scan the entire extent list
            for(; Extent < pStreamExtentHeader->ExtentCount; Extent ++){
                //0.0E00 Ignore virtual extents
                if(pExtents[Extent].StartingLcn != 0xFFFFFFFFFFFFFFFF){
                    
                    Lcn = pExtents[Extent].StartingLcn;

                    //0.1E00 The following only records the Lcn if it is the lowest number unless the first Lcn is in the MFT zone.
                    //0.0E00 If this extent is the lowest so far, record it
                    //Or if this extent is in the MFT zone.
                    if((Lcn < LowestStartingLcn) ||
                       ((VolData.FileSystem == FS_NTFS) && (LowestStartingLcn >= VolData.MftZoneStart) &&
                        (LowestStartingLcn < VolData.MftZoneEnd))){
                        
                        //If this Lcn is not in the MFT zone, then record it as the earliest Starting Lcn.
                        if((Lcn < VolData.MftZoneStart) ||
                           (Lcn >= VolData.MftZoneEnd)){
                            LowestStartingLcn = Lcn;
                        }
                    }
                }
            }
        }

        //Go to the next stream.
        pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST));
    }
    //0.1E00 Return the Lcn we found.
    *pStartingLcn = LowestStartingLcn;
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:
    None.

GLOBALS:
    VolData

RETURN:
    TRUE = Success
    FALSE = Failure
*/



#if defined(DFRGFAT) || defined(DFRGNTFS)
BOOL
FillMostFraggedList(CFraggedFileList &fraggedFileList, IN CONST BOOL fAnalyseOnly)
{
    UINT Index = 0;
    LONGLONG LeastExtents = 0;
    LONGLONG Extents = 0;

#ifdef DFRGNTFS
    // start with the first entry in the moveable file list
    PFILE_LIST_ENTRY pFileListEntry = NULL;
    ULONG numFragmentedFiles = 0;

    if (fAnalyseOnly) {

        if (RtlNumberGenericTableElementsAvl(&VolData.FragmentedFileTable) > 0) {
            pFileListEntry = (PFILE_LIST_ENTRY) LastEntry(&VolData.FragmentedFileTable);
        }

        while ((pFileListEntry) && (numFragmentedFiles < 30)) {

            // Get the file record so we can get the file name.
            VolData.FileRecordNumber = pFileListEntry->FileRecordNumber;
            if (!GetInUseFrs(VolData.hVolume,
                &VolData.FileRecordNumber,
                (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord,
                (ULONG)VolData.BytesPerFRS)) {

                pFileListEntry = (PFILE_LIST_ENTRY) PreviousEntry(pFileListEntry);
                continue;
            }

            // Ensure that it is the correct file record
            // if not, spit out a message and continue
            if (VolData.FileRecordNumber != pFileListEntry->FileRecordNumber){
                
                pFileListEntry = (PFILE_LIST_ENTRY) PreviousEntry(pFileListEntry);
                continue;
            }
            
            // Ensure that it is the correct file record
            if (VolData.FileRecordNumber == pFileListEntry->FileRecordNumber){

                // Get the file name to add to the list
                if (GetNtfsFilePath() && (VolData.vFileName.GetLength() > 0)){
                    // Get the extent list in a new unit of time to get its size.
                    if (GetExtentList(DEFAULT_STREAMS, NULL)){

                        // add the file to the fragged file list
                        fraggedFileList.Add(
                            VolData.vFileName.GetBuffer(),
                            VolData.FileSize,
                            pFileListEntry->ExcessExtentCount+1);

                        ++numFragmentedFiles;
                    }
                }
            }

            pFileListEntry = (PFILE_LIST_ENTRY) PreviousEntry(pFileListEntry);
        }

        return TRUE;
    }




    // Search through the moveable filelist for most fragmented files.
    for(pFileListEntry = (PFILE_LIST_ENTRY) RtlEnumerateGenericTableAvl(&VolData.FragmentedFileTable, TRUE);
        pFileListEntry;
        pFileListEntry = (PFILE_LIST_ENTRY) RtlEnumerateGenericTableAvl(&VolData.FragmentedFileTable, FALSE)) {

        // Check to see if this file is more fragmented than the least "most fragged" file.
        // Directories okay on VER 5
        if (pFileListEntry->ExcessExtentCount+1 > fraggedFileList.GetMinExtentCount()) {

            // Get the file record so we can get the file name.
            VolData.FileRecordNumber = pFileListEntry->FileRecordNumber;
            if (!GetInUseFrs(VolData.hVolume,
                &VolData.FileRecordNumber,
                (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord,
                (ULONG)VolData.BytesPerFRS)) {
                continue;
            }
                           

            // Ensure that it is the correct file record
            // if not, spit out a message and continue
            if (VolData.FileRecordNumber != pFileListEntry->FileRecordNumber){
                continue;
            }

            // Get the NTFS file's name.
            if (GetNtfsFilePath()&& (VolData.vFileName.GetLength() > 0)){
                // Get the extent list in a new unit of time to get its size.
                if (GetExtentList(DEFAULT_STREAMS, NULL)){

                    // add the file to the fragged file list
                    fraggedFileList.Add(
                        VolData.vFileName.GetBuffer(),
                        VolData.FileSize,
                        pFileListEntry->ExcessExtentCount+1);
                }

            }
        }
#elif DFRGFAT
    // start with the first entry in the moveable file list
    FILE_LIST_ENTRY *pFileListEntry = VolData.pMoveableFileList;

    BOOL VolFragmented = FALSE;

    // Search through the moveable filelist for most fragmented files.
    for(UINT i = 0; i < VolData.MoveableFileListEntries; i++){
    
        // end of list?
        if(pFileListEntry->FileRecordNumber == 0){
            break;
        }

#ifdef VER4
        // Check to see if this file is more fragmented than the 
        // least most fragged file, and not a directory.
        if((!(pFileListEntry->Flags & FLE_DIRECTORY) && 
             (pFileListEntry->ExcessExtentCount+1 > LeastExtents)) &&
             (pFileListEntry->ExcessExtentCount > 0)) {
#else
        // Check to see if this file is more fragmented than the least "most fragged" file.
        // Directories okay on VER 5
        if(pFileListEntry->ExcessExtentCount+1 > LeastExtents &&
           pFileListEntry->ExcessExtentCount > 0) {
#endif          


            VolData.FileRecordNumber = pFileListEntry->FileRecordNumber;

            VolData.vFileName = &VolData.pNameList[pFileListEntry->FileRecordNumber];

            // open the file to see if it still exists!
            if(OpenFatFile()){
                // Get the extent list in a new unit of time to get its size.
                if (GetExtentList(DEFAULT_STREAMS, NULL)){

                    // add the file to the fragged file list

                    fraggedFileList.Add(
                        &VolData.pNameList[pFileListEntry->FileRecordNumber],
                        VolData.FileSize,
                        pFileListEntry->ExcessExtentCount+1);
                }
            }
        }
        pFileListEntry++;
#endif
    }

    return TRUE;
}
#endif // #if defined(DFRGFAT) || defined(DFRGNTFS)


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:
    None.

GLOBALS:

RETURN:
    TRUE = The volume is dirty.
    FALSE = The volume is not dirty.
*/

BOOL
IsVolumeDirty(
    void
    )
{
    ULONG uDirty=0;
    DWORD BytesReturned = 0;

#if defined(DFRGFAT) || defined(DFRGNTFS) // get a good link when used with the UI
    EF(ESDeviceIoControl(VolData.hVolume,
        FSCTL_IS_VOLUME_DIRTY,
        NULL,
        0,
        &uDirty,
        sizeof(uDirty),
        &BytesReturned,
        NULL));
#endif

    if (uDirty & (VOLUME_DIRTY | VOLUME_UPGRADE_ON_MOUNT)) {
        return TRUE;
    }

    return FALSE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:
    None.

GLOBALS:

RETURN:
    TRUE = Drive letter was found
    FALSE = Drive letter was not found
*/

#ifndef VER4
BOOL GetDriveLetterByGUID(
    PTCHAR volumeName, 
    TCHAR &driveLetter
)
{
    TCHAR   cDrive[10];
    TCHAR   tmpVolumeName[GUID_LENGTH];
    TCHAR   drive;
    BOOL    isOk;

    cDrive[1] = L':';
    cDrive[2] = L'\\';
    cDrive[3] = 0;
    for (drive = L'A'; drive <= L'Z'; drive++) {
        cDrive[0] = drive;
        // get the VolumeName based on the mount point or drive letter
        isOk = GetVolumeNameForVolumeMountPoint(cDrive, tmpVolumeName, GUID_LENGTH);
        if (isOk) {
            // did we get a match on the GUID?
            if (_tcsncmp(tmpVolumeName, volumeName, 48) == 0) { // ignore whether backslash is there
                driveLetter = drive;
                return TRUE;
            }
        }
    }

    return FALSE;
}
#endif // #ifndef VER4

//////////////////////////////////////////////////////////////////////////
// Finds all the spots where a volume is mounted
// by searching all the drive letters for mount points that they support
// and comparing the volume GUID that is mounted there to the volume GUID we are
// interested in. When the GUIDs match, we have found a mount point for this volume.
// Is that clear?
//
#ifndef VER4
void GetVolumeMountPointList(
    PWSTR volumeName, // guid
    VString mountPointList[MAX_MOUNT_POINTS],
    UINT  &mountPointCount
)
{   
    VString cDrive = TEXT("x:\\");
    BOOL    mountPointFound = FALSE;
    TCHAR   drive;

    // clear out the mount point list
    for (UINT i=0; i<MAX_MOUNT_POINTS; i++){
        mountPointList[i].Empty();
    }

    mountPointCount = 0;
    for (drive = L'A'; drive <= L'Z'; drive++) {
        if (IsValidVolume(drive)){
            cDrive.GetBuffer()[0] = drive;
            mountPointFound = 
                (GetMountPointList(cDrive, volumeName, mountPointList, mountPointCount) || mountPointFound);
        }
    }
}
#endif // #ifndef VER4

//////////////////////////////////////////////////////////////////////////
// gets all the points where the drive is mounted
//
#ifndef VER4
#define MAX_UNICODE_PATH 32000
BOOL GetMountPointList(
    VString Name, // path to a mount point (start with a drive letter)
    PWSTR   VolumeName, // guid of volume in question
    VString mountPointList[MAX_MOUNT_POINTS],
    UINT    &mountPointCount
    )
{
    BOOL    b;
    HANDLE  h;
    TCHAR   tmpVolumeName[GUID_LENGTH];
    PWSTR   volumeMountPoint;
    VString mountPointPath;
    BOOL    r = FALSE;

    if (mountPointCount == MAX_MOUNT_POINTS)
        return FALSE; // FALSE = no mount points found

    // get the VolumeName based on the mount point or drive letter
    b = GetVolumeNameForVolumeMountPoint(Name.GetBuffer(), tmpVolumeName, GUID_LENGTH);
    if (!b) {
        return r;
    }

    // Is this volume mounted at this mount point (compare the GUIDs)?
    if (!_tcsncmp(tmpVolumeName, VolumeName, 48)) { // only 48 incase of a trailing backslash
        r = TRUE;
        mountPointList[mountPointCount++] = Name; // save this as a mount point
        if (mountPointCount == MAX_MOUNT_POINTS)
            return TRUE;
    }

    // create a buffer large enough to hold a really huge moint point path
    // in case the FindFirstVolumeMountPoint() function is changed to return
    // long mount point names
    volumeMountPoint = (PWSTR) new TCHAR[MAX_UNICODE_PATH]; // 32000
    EF_ASSERT(volumeMountPoint);

    // find out where else this volume is mounted (other than at a drive letter)
    // as of 9/28/98, this function does not return mount points that are longer than MAX_PATH
    h = FindFirstVolumeMountPoint(tmpVolumeName, volumeMountPoint, MAX_UNICODE_PATH);
    if (h == INVALID_HANDLE_VALUE) {
        delete [] volumeMountPoint;
        return r;
    }

    for (;;) {

        mountPointPath = Name;
        mountPointPath += volumeMountPoint;

        if (mountPointPath.IsEmpty() == FALSE && 
            GetMountPointList(mountPointPath, VolumeName, mountPointList, mountPointCount)) {
            r = TRUE;
        }

        b = FindNextVolumeMountPoint(h, volumeMountPoint, MAX_UNICODE_PATH);
        if (!b) {
            break;
        }
    }

    delete [] volumeMountPoint;
    FindVolumeMountPointClose(h);

    return r;
}
#endif // #ifndef VER4


#ifndef VER4
void FormatDisplayString(
    TCHAR driveLetter, 
    PTCHAR volumeLabel,
    VString mountPointList[MAX_MOUNT_POINTS],
    UINT  mountPointCount,
    PTCHAR displayLabel
    )
{   
    // create the volume label display string
    if (driveLetter){
        if(_tcslen(volumeLabel) == 0){
            _stprintf(displayLabel, TEXT("(%c:)"), driveLetter);
        }
        else{
            // "<volume label> (C:)"
            _stprintf(displayLabel, TEXT("%s (%c:)"), volumeLabel, driveLetter);
        }
    }
    else if (_tcslen(volumeLabel) > 0){  // use the label only if that's what we have
        _tcscpy(displayLabel, volumeLabel);
    }
    else if (mountPointCount > 0){  // no drive letter or label, use the first mount point
        // start off with "Mounted Volume: "
        LoadString(GetDfrgResHandle(), IDS_MOUNTED_VOLUME, displayLabel, 50);
        _tcscat(displayLabel, TEXT(": "));

        // concat the first mount point
        if (mountPointList[0].GetLength() > 50) {
            _tcsnccat(displayLabel, mountPointList[0].GetBuffer(), 50);
            _tcscat(displayLabel, TEXT("..."));
        }
        else {
            _tcscat(displayLabel, mountPointList[0].GetBuffer());
        }
    }
    else {  // no drive letter or label or mount point
        LoadString(GetDfrgResHandle(), IDS_UNMOUNTED_VOLUME, displayLabel, 50);
    }
}
#endif // #ifndef VER4

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
  Detemines if a volume is FAT12 or not (ok to send the a NTFS volume name)

INPUT + OUTPUT:
    Volume name (UNC or GUID format)

GLOBALS:
    None.

RETURN:
    TRUE - Volume is a FAT12
    FALSE - Volume is not a FAT12
*/

BOOL
IsFAT12Volume(
    PTCHAR volumeName
    )
{
    DWORD fileSystem;
    TCHAR volumeLabel[100];
    DWORD SectorsPerCluster = 0;
    DWORD BytesPerSector = 0;
    DWORD FreeClusters = 0;
    DWORD TotalNumberOfClusters = 0;


    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus = {0};
    FILE_FS_SIZE_INFORMATION FsSizeBuf = {0};

#ifdef OFFLINEDK
    //0.1E00 Get the file system on this drive.
    EF(GetFileSystem(volumeName, &fileSystem));

    if (fileSystem== FS_FAT32){
        _tprintf(TEXT("\nError - FAT32 is not supported.\n")); // todo Is this still true?
        return FALSE;
    }
#else
    //0.1E00 Get the file system on this drive.
    EF(GetFileSystem(volumeName, &fileSystem, volumeLabel));
#endif

    //1.0E00 Check to see if this is anything other than FAT or FAT32, and if so, bail out.
    if(fileSystem != FS_FAT && fileSystem != FS_FAT32){
        return FALSE;
    }

    // if the last char is a \, null it out
    TCHAR tmpVolumeName[GUID_LENGTH+1];
    _tcscpy(tmpVolumeName, volumeName);
    if (tmpVolumeName[_tcslen(tmpVolumeName)-1] == L'\\'){
        tmpVolumeName[_tcslen(tmpVolumeName)-1] = NULL;
    }

    //bug #120872 sks
    _stprintf(tmpVolumeName,TEXT("%s%s"),VolData.cVolumeName,TEXT("\\"));

    if(!GetDiskFreeSpace(
        tmpVolumeName,
        &SectorsPerCluster,
        &BytesPerSector,
        &FreeClusters,
        &TotalNumberOfClusters
        ))
    {
        EF_ASSERT(FALSE);
    }

    if(TotalNumberOfClusters < 4087){
        return TRUE;
    }

    return FALSE;
}

BOOL IsVolumeRemovable(PTCHAR volumeName)
{
    if (GetDriveType(volumeName) == DRIVE_REMOVABLE){
        return TRUE;
    }

    return FALSE;
}

// overloaded version for non-guid versions
void FormatDisplayString(
    TCHAR driveLetter, 
    PTCHAR volumeLabel,
    PTCHAR displayLabel
)
{   
    // create the volume label display string
    if(_tcslen(volumeLabel) == 0){
        _stprintf(displayLabel, TEXT("(%c:)"), driveLetter);
    }
    else{
        // "<volume label> (C:)"
        _stprintf(displayLabel, TEXT("%s (%c:)"), volumeLabel, driveLetter);
    }
}

// This strips the volume ID prefix (guid or drive letter)
// and compressed the file name down to 50 characters
BOOL ESICompressFilePath(
    IN PTCHAR inFilePath,
    OUT PTCHAR outFilePath
)
{
    PTCHAR pStartPath = NULL;
    PTCHAR pFileNameStart = NULL;
    const UINT MAXWIDTH = 50;

    if (inFilePath == NULL){
        _tcscpy(outFilePath, TEXT("(NULL)"));
        return FALSE;
    }

    // assume that we are prefixed with a GUID
    pStartPath = _tcschr(inFilePath, L'}');

    if (pStartPath){
        pStartPath++; // bump by one to get past the "}"
    }
    else {
        // if that failed, then we will strip off the drive letter
        // stuff (e.g. \\.\x:\)
        pStartPath = &inFilePath[6];
    }

    // file name starts at last backslash
    pFileNameStart = _tcsrchr(inFilePath, L'\\');

    if (pFileNameStart == NULL){
        pFileNameStart = pStartPath;
    }

    // length of file name after the last backslash
    UINT fileNameLen = _tcslen(pFileNameStart);

    if (fileNameLen > MAXWIDTH-3){
        _tcsncpy(outFilePath, pFileNameStart, MAXWIDTH - 3); // 3 spaces for the ellipses
        outFilePath[MAXWIDTH - 3] = (TCHAR) NULL;
        _tcscat(outFilePath, TEXT("..."));
    }
    else if (_tcslen(pStartPath) > MAXWIDTH){
        _tcsncpy(outFilePath, pStartPath, MAXWIDTH - fileNameLen - 3); // 3 spaces for the ellipses
        outFilePath[MAXWIDTH - fileNameLen - 3] = (TCHAR) NULL;
        _tcscat(outFilePath, TEXT("..."));
        _tcscat(outFilePath, pFileNameStart);
    }
    else{
        _tcscpy(outFilePath, pStartPath);
    }

    return TRUE;
}

// This strips the volume ID prefix (guid or drive letter)
// and compressed the file name down to 50 characters
// THIS VERSION COMPRESSES IN PLACE
TCHAR * ESICompressFilePath(
    IN PTCHAR inFilePath
)
{
    const UINT MAXWIDTH = 50;
    static TCHAR squishedFileName[MAXWIDTH+1];
    PTCHAR pStartPath = NULL;
    PTCHAR pFileNameStart = NULL;

    // assume that we are prefixed with a GUID
    pStartPath = _tcschr(inFilePath, L'}');

    if (pStartPath){
        pStartPath++; // bump by one to get past the "}"
    }
    else {
        // if that failed, then we will strip off the drive letter
        // stuff (e.g. \\.\x:\)
        pStartPath = &inFilePath[6];
    }

    // file name starts at last backslash
    pFileNameStart = _tcsrchr(inFilePath, L'\\');

    if (pFileNameStart == NULL){
        pFileNameStart = pStartPath;
    }

    // length of file name (after the last backslash)
    UINT fileNameLen = _tcslen(pFileNameStart);

    // if the file name is longer than MAXWIDTH
    if (fileNameLen > MAXWIDTH - 6){
        _tcscpy(squishedFileName, TEXT("..."));
        _tcsncat(squishedFileName, pFileNameStart, MAXWIDTH - 6); // for the ellipses
        squishedFileName[MAXWIDTH - 6] = (TCHAR) NULL;
        _tcscat(squishedFileName, TEXT("..."));
    }
    // if the whole string is longer than MAXWIDTH
    else if (_tcslen(pStartPath) > MAXWIDTH - 3){
        _tcsncpy(squishedFileName, pStartPath, MAXWIDTH - fileNameLen - 3); // 3 spaces for the ellipses
        squishedFileName[MAXWIDTH - fileNameLen - 3] = (TCHAR) NULL;
        _tcscat(squishedFileName, TEXT("..."));
        _tcscat(squishedFileName, pFileNameStart);
    }
    // if the whole string will fit
    else{
        _tcscpy(squishedFileName, pStartPath);
    }

    return squishedFileName;
}


 
/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
  check if enough free space exists to defrag

INPUT + OUTPUT:
    buf is the string for the display message, 
    bCommandLineMode whether we are in command line mode or not


RETURN:
    TRUE - free space exceeds the registry setting
    FALSE - not enough free space 
*/

BOOL ValidateFreeSpace(BOOL bCommandLineMode, LONGLONG llFreeSpace, LONGLONG llUsableFreeSpace, 
                       LONGLONG llDiskSize, TCHAR *VolLabel, TCHAR *returnMsg, UINT returnMsgLen)
{
    // get threshold percent from registry
    TCHAR cRegValue[100];
    HKEY hValue = NULL;
    DWORD dwRegValueSize = sizeof(cRegValue);
    DWORD dwFreeSpaceErrorLevel = 15;

    LONGLONG llFreeSpacePercent = 100 * llFreeSpace / llDiskSize;
    LONGLONG llUsableFreeSpacePercent = 100 * llUsableFreeSpace / llDiskSize;

    // clear return message string
    _tcscpy(returnMsg, TEXT(""));

    // get the free space error threshold from the registry
    long ret = GetRegValue(
        &hValue,
        TEXT("SOFTWARE\\Microsoft\\Dfrg"),
        TEXT("FreeSpaceErrorLevel"),
        cRegValue,
        &dwRegValueSize);

    RegCloseKey(hValue);

    // convert it and apply range limits
    if (ret == ERROR_SUCCESS) 
    {
        dwFreeSpaceErrorLevel = (DWORD) _ttoi(cRegValue);

        // > 50 does not make sense!
        if (dwFreeSpaceErrorLevel > 50)
            dwFreeSpaceErrorLevel = 50;

        // < 0 does not either!
        if (dwFreeSpaceErrorLevel < 1)
            dwFreeSpaceErrorLevel = 0;
    }


    Trace(log, "Validating free space.  FreeSpace: %I64d (%I64d%%)  UsableFreeSpace: %I64d (%I64d%%)  ErrorLevel: %lu%%", 
        llFreeSpace, llFreeSpacePercent, llUsableFreeSpace, llUsableFreeSpacePercent, dwFreeSpaceErrorLevel);

    // check usable freespace vs. the threshold
    if (llFreeSpacePercent < dwFreeSpaceErrorLevel)
    {
        TCHAR         buf[800];
        TCHAR         buf2[800];
        DWORD_PTR     dwParams[10];

        // if usable free space is less than reported free space...
        if (llUsableFreeSpacePercent < llFreeSpacePercent) 
        {
            //I did it this way because we store UsableFreeSpacePercent as a LONGLONG
            //by Scott K. Sipe
            if (llUsableFreeSpace / llDiskSize > 0 && llUsableFreeSpace / llDiskSize < 1)
            {
                dwParams[0] = (DWORD_PTR) VolLabel;
                dwParams[1] = (DWORD_PTR) llFreeSpacePercent;
                dwParams[2] = dwFreeSpaceErrorLevel;
                dwParams[3] = NULL;
                LoadString(GetDfrgResHandle(), IDS_NO_USABLE_FREE_SPACE_LESS_1, buf, sizeof(buf) / sizeof(TCHAR));
                if (!bCommandLineMode)
                {
                    LoadString(GetDfrgResHandle(), IDS_DEFRAG_NOW_ANYWAY, buf2, sizeof(buf2) / sizeof(TCHAR));
                    _tcscat(buf, buf2);
                }
                int len = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                    buf, 0, 0, returnMsg, returnMsgLen, (va_list*) dwParams);

            } 
            else
            {
                dwParams[0] = (DWORD_PTR) VolLabel;
                dwParams[1] = (DWORD_PTR) llFreeSpacePercent;
                dwParams[2] = (DWORD_PTR) llUsableFreeSpacePercent;
                dwParams[3] = dwFreeSpaceErrorLevel;
                LoadString(GetDfrgResHandle(), IDS_NO_USABLE_FREE_SPACE, buf, sizeof(buf) / sizeof(TCHAR));
                if (!bCommandLineMode)
                {
                    LoadString(GetDfrgResHandle(), IDS_DEFRAG_NOW_ANYWAY, buf2, sizeof(buf2) / sizeof(TCHAR));
                    _tcscat(buf, buf2);
                }
                int len = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                    buf, 0, 0, returnMsg, returnMsgLen, (va_list*) dwParams);
            }
        }
        // if usable freespace is not less than reported free space...
        else 
        {
            if (llUsableFreeSpace / llDiskSize > 0 && llUsableFreeSpace / llDiskSize < 1)
            {
                dwParams[0] = (DWORD_PTR) VolLabel;
                dwParams[1] = dwFreeSpaceErrorLevel;
                dwParams[2] = NULL;
                dwParams[3] = NULL;
                LoadString(GetDfrgResHandle(), IDS_NO_FREE_SPACE_LESS_1, buf, sizeof(buf) / sizeof(TCHAR));
                if (!bCommandLineMode)
                {
                    LoadString(GetDfrgResHandle(), IDS_DEFRAG_NOW_ANYWAY, buf2, sizeof(buf2) / sizeof(TCHAR));
                    _tcscat(buf, buf2);
                }
                int len = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                    buf, 0, 0, returnMsg, returnMsgLen, (va_list*) dwParams);
            } 
            else
            {
                dwParams[0] = (DWORD_PTR) VolLabel;
                dwParams[1] = (DWORD_PTR) llUsableFreeSpacePercent;
                dwParams[2] = dwFreeSpaceErrorLevel;
                dwParams[3] = NULL;
                LoadString(GetDfrgResHandle(), IDS_NO_FREE_SPACE, buf, sizeof(buf) / sizeof(TCHAR));
                if (!bCommandLineMode)
                {
                    LoadString(GetDfrgResHandle(), IDS_DEFRAG_NOW_ANYWAY, buf2, sizeof(buf2) / sizeof(TCHAR));
                    _tcscat(buf, buf2);
                }
                int len = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                    buf, 0, 0, returnMsg, returnMsgLen, (va_list*) dwParams);
            }
        }

        return FALSE;
    }   

    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Finds out if this is the boot volume.

INPUT:
        TCHAR tDrive            The drive letter we are defragmenting
RETURN:
        Returns TRUE if this is boot value, else FALSE if it is not.
*/
BOOL IsBootVolume(
        IN TCHAR tDrive
        )
{
    
    TCHAR tExpandedSystemRoot[MAX_PATH + 2];     //the expanded system root string
    TCHAR tExpandedSystemRootDrive;

    //I get the environment variable and expand it to get what the current boot
    //drive is. The first character will be the system boot drive. compare this 
    //with the drive that is selected, and test is we are boot optimizing the 
    //boot drive
    
    if (GetSystemWindowsDirectory(tExpandedSystemRoot, MAX_PATH + 1) == 0)
    {
        return FALSE;
    }
    tExpandedSystemRoot[MAX_PATH + 1] = TEXT('\0');

    //convert the characters to upper case before comparison
    tExpandedSystemRootDrive = towupper(tExpandedSystemRoot[0]);

    //test to see if the drive letters match
    if(tDrive == tExpandedSystemRootDrive)          //first two characters are equal
    {
        return TRUE;
    } else
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\fraggedfilelist.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  FraggedFileList.cpp
//=============================================================================*

#include "stdafx.h"
#include <windows.h>

#include "ErrMacro.h"
#include "alloc.h"
#include "GetDfrgRes.h" // to use the GetDfrgResHandle()
#include "TextBlock.h" // to use the FormatNumber function
#include "FraggedFileList.h"

//-------------------------------------------------------------------*
//  function:   CFraggedFile::CFraggedFile
//
//  returns:    None
//-------------------------------------------------------------------*
CFraggedFile::CFraggedFile(
    PTCHAR   cFileName,
    LONGLONG fileSize,
    LONGLONG extentCount)
{
    // check for null pointer
    require(cFileName);
    require(fileSize);
    require(extentCount);

    // allocate memory for the name string (it could be really long!)
    m_cFileName = (PTCHAR) new TCHAR[wcslen(cFileName) + 1];

    //fix put in for 55985 prefix bug to prevent dereferencing NULL pointer
    if(m_cFileName == NULL)         //memory allocation failed
    {
        m_FileSize = 0;
//      m_cFileSize = NULL;
        m_ExtentCount = 0;
//      m_cExtentCount = NULL;
        return;
    }
    // now grab a copy of the name string
    wcscpy(m_cFileName, cFileName);
    m_FileSize = fileSize;
    m_ExtentCount = extentCount;

    // formats the number in Bytes, KB, MB or GB and puts in commas
    FormatNumber(GetDfrgResHandle(), m_FileSize, m_cFileSize);
    CommafyNumber(m_ExtentCount, m_cExtentCount, sizeof(m_cExtentCount) / sizeof(TCHAR));
}

//-------------------------------------------------------------------*
//  function:   CFraggedFile::CFraggedFile
//
//  desc:       Version used to create an empty object
//  returns:    None
//-------------------------------------------------------------------*
CFraggedFile::CFraggedFile(void)
{
    m_cFileName = NULL;
    m_FileSize = 0;
    m_ExtentCount = 0;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFile::~CFraggedFile
//
//  returns:    None
//-------------------------------------------------------------------*
CFraggedFile::~CFraggedFile(void)
{
    // deallocate memory for the name string
    if (m_cFileName){
        delete m_cFileName;
    }
}

//-------------------------------------------------------------------*
//  function:   CFraggedFile::FileNameLen
//
//  returns:    length of FileName
//-------------------------------------------------------------------*
UINT CFraggedFile::FileNameLen()
{
    if (m_cFileName == NULL) {
        return 0;
    }
    else {
        return wcslen(m_cFileName);
    }
}


//-------------------------------------------------------------------*
//  function:   CFraggedFile::FileNameTruncated
//
//  returns:    FileName truncated to MaxLen
//-------------------------------------------------------------------*
PTCHAR CFraggedFile::FileNameTruncated(UINT MaxLen)
{
    PTCHAR   cStart = m_cFileName;
    PTCHAR   cPtr = m_cFileName;

    // nothing to do if no filename or already within length limit
    if (m_cFileName != NULL && wcslen(m_cFileName) > MaxLen) {

        // find the starting point that gives a MaxLen string
        UINT len = wcslen(m_cFileName);
        cStart += len - MaxLen;

        // jump ahead to the next path separator
        cPtr = wcschr(cStart, TEXT('\\'));

        // make sure we got one
        if (cPtr == NULL) {
            cPtr = cStart;
        }
    }

    return cPtr;
}

LONGLONG CFraggedFile::FileSize(void)
{

    return m_FileSize;
}


LONGLONG CFraggedFile::ExtentCount(void)
{

    return m_ExtentCount;
}


//-------------------------------------------------------------------*
//  function:   CFraggedFileList::CFraggedFileList
//
//  returns:    None
//-------------------------------------------------------------------*
CFraggedFileList::CFraggedFileList(PTCHAR cVolumeName)
{
    // check for null pointer
    require(cVolumeName);
    
    wcscpy(m_cVolumeName, cVolumeName);
    m_FraggedFileList.RemoveAll();
    m_hTransferBuffer = NULL;
    m_pTransferBuffer = NULL;
    m_TransferBufferSize = 0;
    m_MinExtentCount = -1;
    m_MinIndex = 0;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::CFraggedFileList
//
//  desc:       Version when the volume name is not known yet
//  returns:    None
//-------------------------------------------------------------------*
CFraggedFileList::CFraggedFileList(void)
{
    m_FraggedFileList.RemoveAll();
    m_hTransferBuffer = NULL;
    m_pTransferBuffer = NULL;
    m_TransferBufferSize = 0;
    m_MinExtentCount = -1;
    m_MinIndex = 0;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::~CFraggedFileList
//
//  returns:    None
//-------------------------------------------------------------------*
CFraggedFileList::~CFraggedFileList(void)
{
    // Clear out the list
    CFraggedFile *pFraggedFile;
    for (int i=0; i<m_FraggedFileList.Size(); i++){
        pFraggedFile = (CFraggedFile *) m_FraggedFileList[i];
        if (pFraggedFile)
            delete pFraggedFile;
    }
    m_FraggedFileList.RemoveAll();
    DeleteTransferBuffer();
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::GetAt(based on index)
//
//  returns:    Address of object at an index (used for looping)
//  note:       
//-------------------------------------------------------------------*
CFraggedFile * CFraggedFileList::GetAt(UINT i)
{
    if (i >= (UINT) m_FraggedFileList.Size())
        return (CFraggedFile *) NULL;

    if (m_FraggedFileList.Size() > -1){
        return (CFraggedFile *) m_FraggedFileList[i];
    }

    return (CFraggedFile *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::RemoveAt(based on index)
//
//  returns:    TRUE if this worked, otherwise FALSE
//  note:       
//-------------------------------------------------------------------*
BOOL CFraggedFileList::RemoveAt(UINT i)
{
    if (i >= (UINT) m_FraggedFileList.Size())
        return FALSE;

    if (m_FraggedFileList.Size() > -1){
        CFraggedFile *pFraggedFile = (CFraggedFile *) m_FraggedFileList[i];
        if (pFraggedFile){
            delete pFraggedFile;
        }
        return m_FraggedFileList.RemoveAt(i);
    }

    return FALSE;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::Add(...)
//
//  returns:    Index of new element, -1 if it failed
//  note:       
//-------------------------------------------------------------------*
int CFraggedFileList::Add(PTCHAR cFileName, LONGLONG fileSize, LONGLONG extentCount)
{

    // if it's not fragged, don't bother
    if (extentCount < 2){
        return -1;
    }

    // filter out the meta-files - they confuse the users!
    if (_tcsstr(cFileName, TEXT("\\$Extend")) != (PTCHAR) NULL){
        return -1;
    }


    CFraggedFile *pFraggedFile;

    // if the list is full, delete the smallest guy
    if (m_FraggedFileList.Size() >= MAX_MOST_FRAGGED_FILES){

        // dont bother if this is as small as the smallest extent count
        if (extentCount <= m_MinExtentCount){
            return -1;
        }

        // delete the current min to make room for the new entry
        RemoveAt(m_MinIndex);

        // calculate who the new minimum is and where he is located
        pFraggedFile = (CFraggedFile *) m_FraggedFileList[0];
        m_MinExtentCount = pFraggedFile->ExtentCount();
        m_MinIndex = 0;

        // find the file with the min extent count
        for (UINT i=1; i<(UINT)m_FraggedFileList.Size(); i++){
            // get a pointer to the object
            pFraggedFile = (CFraggedFile *) m_FraggedFileList[i];
            if (pFraggedFile->ExtentCount() < m_MinExtentCount){
                m_MinExtentCount = pFraggedFile->ExtentCount();
                m_MinIndex = i;
            }
        }
    }


    // strip the volume name (guid) off the prefix of the file name
    PTCHAR pTmp = cFileName;
    // only if the first 2 character are a double whack

    if (wcslen(cFileName) > wcslen(m_cVolumeName) && wcsncmp(cFileName, L"\\\\", 2) == 0){
        pTmp += wcslen(m_cVolumeName);
    }

    // if we are below the limit, then just add the file
    pFraggedFile = (CFraggedFile *) new CFraggedFile(
        pTmp,
        fileSize,
        extentCount);
    

    if (pFraggedFile == (CFraggedFile *) NULL)
    {
        return -1;
    }

    // add the new object to the list
    int newIndex =  m_FraggedFileList.Add(pFraggedFile);

    // if this guy has the new min, save the min and his location in the list
    if ((-1 == m_MinExtentCount) || (extentCount <= m_MinExtentCount)){
        m_MinExtentCount = extentCount;
        m_MinIndex = newIndex;
    }
    return newIndex;
}



//-------------------------------------------------------------------*
//  function:   CFraggedFileList::CreateTransferBuffer(void)
//
//  returns:    pointer to the transfer buffer
//  note:       
//-------------------------------------------------------------------*
BOOL CFraggedFileList::CreateTransferBuffer(void)
{

    // the number of files in the list goes first
    m_TransferBufferSize = sizeof(UINT);


    // this get the Byte count, not the char count
    m_TransferBufferSize += sizeof(m_cVolumeName);

    CFraggedFile *pFraggedFile;
    for (int i=0; i<m_FraggedFileList.Size(); i++){
        // get a pointer to the object
        pFraggedFile = (CFraggedFile *) m_FraggedFileList[i];

        // add the size of the object
        m_TransferBufferSize += sizeof(CFraggedFile);

        // add the length of the name string (+1 for the null)
        m_TransferBufferSize += (1 + _tcslen(pFraggedFile->FileName())) * sizeof(TCHAR);
    }

    EF(AllocateMemory(m_TransferBufferSize, &m_hTransferBuffer, (PVOID *)&m_pTransferBuffer));

    // use a temp pointer to walk thru the transfer buffer
    PCHAR pTB = (PCHAR) m_pTransferBuffer;

    // copy the frag file list count into the buffer
    UINT fileListSize = m_FraggedFileList.Size();
    CopyMemory(pTB, (PVOID)&fileListSize, sizeof(UINT));
    pTB += sizeof(UINT);

    // copy the volume name into the buffer.
    // this is a fixed length buffer, so we can just slam it in
    CopyMemory(pTB, m_cVolumeName, sizeof(m_cVolumeName));
    pTB += sizeof(m_cVolumeName);

    // now put the data into the buffer
    for (i=0; i<m_FraggedFileList.Size(); i++){
        // get a pointer to the object
        pFraggedFile = (CFraggedFile *) m_FraggedFileList[i];

        // copy the object into the buffer
        CopyMemory(pTB, pFraggedFile, sizeof(CFraggedFile));
        pTB += sizeof(CFraggedFile);

        // copy the file name into the buffer (and a null)
        _tcscpy((PTCHAR) pTB, pFraggedFile->FileName());
        pTB += (1 + _tcslen(pFraggedFile->FileName())) * sizeof(TCHAR);
    }

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::DeleteTransferBuffer(void)
//
//  returns:    TRUE if it worked, otherwise FALSE
//  note:       
//-------------------------------------------------------------------*
BOOL CFraggedFileList::DeleteTransferBuffer(void)
{
    if (m_hTransferBuffer){
        EH_ASSERT(GlobalUnlock(m_hTransferBuffer) == FALSE)
        EH_ASSERT(GlobalFree(m_hTransferBuffer) == NULL);
    }
    m_hTransferBuffer = NULL;
    m_pTransferBuffer = NULL;
    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::ParseTransferBuffer(PVOID pTransferBuffer)
//
//  returns:    TRUE if it worked, otherwise FALSE
//  note:       Builds the CFraggedFileList from scratch out of a buffer
//-------------------------------------------------------------------*
BOOL CFraggedFileList::ParseTransferBuffer(PTCHAR pTransferBuffer)
{
//  EF_ASSERT(pTransferBuffer);

    LONGLONG lFileSize = 0;
    LONGLONG lExtentCount = 0;
    PTCHAR tmpString;
    PCHAR pTB;
    UINT fileListSize;

    RemoveAll();
    m_TransferBufferSize = 0;

    // use a temp pointer to walk thru the transfer buffer
    pTB = (PCHAR) pTransferBuffer;

    // first: get the number of fragged files in the list
    CopyMemory(&fileListSize, pTB, sizeof(UINT));
    pTB += sizeof(UINT);
    m_TransferBufferSize = sizeof(UINT);

    // then get the volume name
    wcsncpy(m_cVolumeName, (PTCHAR)pTB, GUID_LENGTH);
    pTB += GUID_LENGTH * sizeof(TCHAR);
    m_TransferBufferSize += sizeof(m_cVolumeName);

    // create a temp object to hold data as we parse the transfer buffer
    // the rest of the transfer buffer is a stack of CFraggedFile objects/FileName pairs
    //  CFraggedFile objects
    //  File name (null terminated) that goes with the previous object
    //  CFraggedFile objects
    //  File name (null terminated) that goes with the previous object
    //  CFraggedFile objects
    //  File name (null terminated) that goes with the previous object
    //  CFraggedFile objects
    //  File name (null terminated) that goes with the previous object
    //  and so on...

    for (UINT i=0; i<fileListSize; i++){
        
        // the next CFraggedFile object is next in the buffer

        memcpy(&lExtentCount, pTB, sizeof(LONGLONG));
        memcpy(&lFileSize, pTB+sizeof(LONGLONG), sizeof(LONGLONG));


        pTB += sizeof(CFraggedFile);
        // the file name for that object is after that
        tmpString = (PTCHAR) pTB;

        Add(tmpString, lFileSize, lExtentCount);

        // increment the counter
        m_TransferBufferSize += sizeof(CFraggedFile) + (1 + wcslen(tmpString)) * sizeof(TCHAR);

        // move the transfer buffer pointer to the next object-file name pair
        pTB += (1 + wcslen(tmpString)) * sizeof(TCHAR);

    }

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::GetTransferBuffer(void)
//
//  returns:    TRUE if it worked, otherwise FALSE
//  note:       returns pointer to transfer buffer, builds it if needed
//-------------------------------------------------------------------*
PTCHAR CFraggedFileList::GetTransferBuffer(void)
{
    return m_pTransferBuffer;
}

//-------------------------------------------------------------------*
//  function:   CFraggedFileList::GetTransferBuffer(void)
//
//  returns:    TRUE if it worked, otherwise FALSE
//  note:       returns pointer to transfer buffer, builds it if needed
//-------------------------------------------------------------------*
void CFraggedFileList::RemoveAll(void)
{
    // Clear out the list
    CFraggedFile *pFraggedFile;
    for (int i=0; i<m_FraggedFileList.Size(); i++){
        pFraggedFile = (CFraggedFile *) m_FraggedFileList[i];
        if (pFraggedFile)
            delete pFraggedFile;
    }
    m_FraggedFileList.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\getreg.cpp ===
/****************************************************************************************************************

FILENAME: GetReg.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"
#ifndef SNAPIN
#include <windows.h>
#endif
#include <stdio.h>

#include "ErrMacro.h"
#include "Message.h"

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine gets a value from the registry.
 
INPUT + OUTPUT:
    IN OUT phKey            - Handle to where to store the registry key if NULL, or a valid key if otherwise.
    IN cRegKey              - If phKey is NULL, this specifies the name of the key to open.
    IN cRegValueName        - The name of the value to get from phKey.
    OUT cRegValue           - Where to write the value.
    IN OUT pdwRegValueSize  - The size of the cRegValue buffer in bytes on entry; the number of bytes written on return.

GLOBALS:
    None.

RETURN:
    ERROR_SUCCESS - Success
    ERROR_... - Failure
*/

LONG
GetRegValue(
    IN OUT PHKEY phKey,
    IN PTCHAR cRegKey,
    IN PTCHAR cRegValueName,
    OUT PTCHAR cRegValue,
    IN OUT PDWORD pdwRegValueSize
    )
{
    LONG lReturn;
    DWORD dwKeyType;

    //0.0E00 If no handle passed in then open the registry key and get a handle.
    if (*phKey == NULL) {

        //0.0E00 Open the registry
        if((lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   cRegKey,
                                   0,
                                   KEY_QUERY_VALUE,
                                   &*phKey
                                   )) != ERROR_SUCCESS) {

            Message(TEXT("GetRegValue - RegOpenKeyEx"), lReturn, cRegKey);
            return lReturn;
        }   
    }
    //0.0E00 Query the registry for the value
    if((lReturn = RegQueryValueEx(*phKey,
                                   cRegValueName,
                                   0,
                                   &dwKeyType,
                                   (PUCHAR)cRegValue,
                                   &*pdwRegValueSize
                                   )) != ERROR_SUCCESS) {

        Message(TEXT("GetRegValue - RegQueryValueEx"), lReturn, cRegValueName);
        return lReturn;
    }

    if (*pdwRegValueSize > 1) {
        //0.0E00 Zero terminate the return string value.
        cRegValue[(*pdwRegValueSize)/sizeof(TCHAR) - 1] = 0;
    }
    else {
        cRegValue[0] = 0;
        lReturn = ERROR_BADKEY;
    }
    return lReturn;
}

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine gets a value from the registry.
 
INPUT + OUTPUT:
    IN OUT phKey            - Handle to where to store the registry key if NULL, or a valid key if otherwise.
    IN cRegKey              - If phKey is NULL, this specifies the name of the key to open.
    IN cRegValueName        - The name of the value to get from phKey.
    OUT cRegValue           - Where to write the value.
    IN OUT pdwRegValueSize  - The size of the cRegValue buffer in bytes on entry; the number of bytes written on return.

GLOBALS:
    None.

RETURN:
    ERROR_SUCCESS - Success
    ERROR_... - Failure
*/

LONG
GetRegValue(
    IN OUT PHKEY phKey,
    IN PTCHAR cRegKey,
    IN PTCHAR cRegValueName,
    OUT PLONGLONG cRegValue,
    IN OUT PDWORD pdwRegValueSize
    )
{
    LONG lReturn;
    DWORD dwKeyType;

    //0.0E00 If no handle passed in then open the registry key and get a handle.
    if (*phKey == NULL) {

        //0.0E00 Open the registry
        if((lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   cRegKey,
                                   0,
                                   KEY_QUERY_VALUE,
                                   &*phKey
                                   )) != ERROR_SUCCESS) {

            Message(TEXT("GetRegValue - RegOpenKeyEx"), lReturn, cRegKey);
            return lReturn;
        }   
    }
    //0.0E00 Query the registry for the value
    if((lReturn = RegQueryValueEx(*phKey,
                                   cRegValueName,
                                   0,
                                   &dwKeyType,
                                   (LPBYTE)&*cRegValue,
                                   &*pdwRegValueSize
                                   )) != ERROR_SUCCESS) {

        Message(TEXT("GetRegValue - RegQueryValueEx"), lReturn, cRegValueName);
        return lReturn;
    }
    return lReturn;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine gets the NT registry subkey to the key and index value passed in.
 
INPUT + OUTPUT:
    IN OUT phKey            - Handle to where to store the registry key if NULL, or a valid key if otherwise.
    IN cRegKey              - If phKey is NULL, this specifies the name of the key to open.
    IN dwIndex              - The zero based index number of the sub key to enumerate. 
    OUT cRegSubKey          - A string to return the value in. (Must be at least MAX_PATH length).
    IN OUT dwRegSubKeySize  - Size of the sub key register. On return this holds the size of the subkey returned.

GLOBALS:
    None.

RETURN:
    ERROR_SUCCESS or ERROR_NO_MORE_ITEMS - Success
    ERROR_... - Failure
*/

LONG 
GetRegSubKey(
    IN OUT PHKEY phKey,
    IN PTCHAR cRegKey,
    IN DWORD dwIndex,
    OUT PTCHAR cRegSubKey,
    IN OUT PDWORD pdwRegSubKeySize
    )
{
    LONG lReturn;
    FILETIME ftLastWriteTime;
    
    //0.0E00 If no handle passed in then open the registry key and get a handle.
    if (*phKey == NULL) {

        if((lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   cRegKey,
                                   0,
                                   KEY_ENUMERATE_SUB_KEYS,
                                   &*phKey
                                  )) != ERROR_SUCCESS) {

            Message(TEXT("GetRegSubKey - RegOpenKeyEx"), lReturn, cRegKey);
            return lReturn;
        }   
    }
    //0.0E00 Get the sub key.
    if((lReturn = RegEnumKeyEx(*phKey,
                               dwIndex,
                               cRegSubKey,
                               &*pdwRegSubKeySize,
                               NULL,
                               NULL,
                               NULL,
                               &ftLastWriteTime
                               )) != ERROR_SUCCESS && lReturn != ERROR_NO_MORE_ITEMS) {

        Message(TEXT("GetRegSubKey - RegEnumKeyEx"), lReturn, cRegSubKey);
    }
    return lReturn;
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine sets a value in the registry. And creates the registry key if it does not
    already exist.
 
INPUT + OUTPUT:
    IN OUT phKey - Handle to where to store the registry key if NULL, or a valid key if otherwise.
    IN cRegKey - If phKey is NULL, this specifies the name of the key to open.
    IN cRegValueName - The name of the value to save under phKey.
    OUT cRegValue - Contains the value to write.
    IN OUT pdwRegValueSize  - The number of bytes to write.
    IN dwKeyType - The type of value to write (e.g. REG_SZ).

GLOBALS:
    None.

RETURN:
    ERROR_SUCCESS - Success
    ERROR_... - Failure
*/

LONG
SetRegValue(
    IN OUT PHKEY phKey,
    IN PTCHAR cRegKey,
    IN PTCHAR cRegValueName,
    OUT PTCHAR cRegValue,
    IN DWORD dwRegValueSize,
    IN DWORD dwKeyType
    )
{
    LONG lReturn;
    TCHAR cClass[] = TEXT("");
    DWORD dwDisposition;

    //0.0E00 If no handle passed in then open the registry key and get a handle.
    if (*phKey == NULL) {

        // 1.0E00 Create the key if it does not exist otherwise open it.
        if((lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,        // handle of an open key
                                     cRegKey,                   // address of subkey name
                                     0,                         // reserved
                                     cClass,                    // address of class string
                                     REG_OPTION_NON_VOLATILE,   // special options flag 
                                     KEY_ALL_ACCESS,            // desired security access 
                                     NULL,                      // address of key security structure 
                                     &*phKey,                   // address of buffer for opened handle 
                                     &dwDisposition             // address of disposition value buffer
                                     )) != ERROR_SUCCESS) {

            Message(TEXT("SetRegValue - RegOpenKeyEx"), lReturn, cRegKey);
            return lReturn;
        }   
    }
    //0.0E00 Query the registry for the value
    if((lReturn = RegSetValueEx(*phKey,
                                cRegValueName,
                                0,
                                dwKeyType,
                                (PUCHAR)cRegValue,
                                dwRegValueSize
                                )) != ERROR_SUCCESS) {

        Message(TEXT("SetRegValue - RegSetValueEx"), lReturn, cRegValueName);
    }
    return lReturn;
}

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine sets a value in the registry. And creates the registry key if it does not
    already exist.
 
INPUT + OUTPUT:
    IN OUT phKey - Handle to where to store the registry key if NULL, or a valid key if otherwise.
    IN cRegKey - If phKey is NULL, this specifies the name of the key to open.
    IN cRegValueName - The name of the value to save under phKey.
    OUT cRegValue - Contains the value to write.
    IN OUT pdwRegValueSize  - The number of bytes to write.
    IN dwKeyType - The type of value to write (e.g. REG_SZ).

GLOBALS:
    None.

RETURN:
    ERROR_SUCCESS - Success
    ERROR_... - Failure
*/

LONG
SetRegValue(
    IN OUT PHKEY phKey,
    IN PTCHAR cRegKey,
    IN PTCHAR cRegValueName,
    IN LONGLONG cRegValue,
    IN DWORD dwRegValueSize,
    IN DWORD dwKeyType
    )
{
    LONG lReturn;
    TCHAR cClass[] = TEXT("");
    DWORD dwDisposition;

    //0.0E00 If no handle passed in then open the registry key and get a handle.
    if (*phKey == NULL) {

        // 1.0E00 Create the key if it does not exist otherwise open it.
        if((lReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,        // handle of an open key
                                     cRegKey,                   // address of subkey name
                                     0,                         // reserved
                                     cClass,                    // address of class string
                                     REG_OPTION_NON_VOLATILE,   // special options flag 
                                     KEY_ALL_ACCESS,            // desired security access 
                                     NULL,                      // address of key security structure 
                                     &*phKey,                   // address of buffer for opened handle 
                                     &dwDisposition             // address of disposition value buffer
                                     )) != ERROR_SUCCESS) {

            Message(TEXT("SetRegValue - RegOpenKeyEx"), lReturn, cRegKey);
            return lReturn;
        }   
    }
    //0.0E00 Query the registry for the value
    if((lReturn = RegSetValueEx(*phKey,
                                cRegValueName,
                                0,
                                dwKeyType,
                                (LPBYTE)&cRegValue,
                                dwRegValueSize
                                )) != ERROR_SUCCESS) {

        Message(TEXT("SetRegValue - RegSetValueEx"), lReturn, cRegValueName);
    }
    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\gettime.cpp ===
/****************************************************************************************************************

FILENAME: GetTime.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"

#include <windows.h>

#include "ErrMacro.h"

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine gets the current system time in the FILETIME format.
 
INPUT + OUTPUT:
	pFileTime - Where to write the current time.

GLOBALS:
	None.

RETURN:
	TRUE - Success.
	FALSE - Fatal error.
*/

BOOL
GetTime(
	FILETIME* pFileTime
	)
{
	SYSTEMTIME SystemTime;

	GetLocalTime(&SystemTime);
	EF(SystemTimeToFileTime(&SystemTime, pFileTime));

	return TRUE;
}

/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine returns a formatted time string for output.
	The string is overwritten on each call.

INPUT:
	pTime - system time struct.

RETURN:
	Formatted time string: "mm/dd/yyyy hh:mm:ss.ms"
*/

PTCHAR
GetTmpTimeString(
	SYSTEMTIME & pTime
	)
{
	static TCHAR cTimeStr[100];

	wsprintf(cTimeStr, TEXT("%02d/%02d/%04d %02d:%02d:%02d.%03d"), 
		pTime.wMonth, pTime.wDay, pTime.wYear, 
		pTime.wHour, pTime.wMinute, pTime.wSecond, pTime.wMilliseconds);

	return cTimeStr;
}


/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine returns the number of seconds between two system times.

INPUT:
	pStartTime - start time
	pEndTime - end time

OUTPUT:
	pdwSeconds - number of elapsed seconds

RETURN:
	TRUE - Success.
	FALSE - Fatal error.
*/

BOOL
GetDeltaTime(
	SYSTEMTIME * pStartTime, 
	SYSTEMTIME * pEndTime, 
	DWORD * pdwSeconds
	)
{
	FILETIME            ftStartTime;
	FILETIME            ftEndTime;
	LARGE_INTEGER       liStartTime;
	LARGE_INTEGER       liEndTime;
	LONGLONG            llDeltaTime;

	// clear returned seconds
	*pdwSeconds = 0;

	// It is not recommended that you add and subtract values from the SYSTEMTIME 
	//	structure to obtain relative times. Instead, you should 


	// Convert the SYSTEMTIME structures to FILETIME structures. 
	EF(SystemTimeToFileTime(pStartTime, &ftStartTime));
	EF(SystemTimeToFileTime(pEndTime, &ftEndTime));
 
	// Copy the resulting FILETIME structures to LARGE_INTEGER structures. 
	liStartTime.LowPart = ftStartTime.dwLowDateTime;
	liStartTime.HighPart = ftStartTime.dwHighDateTime;
	liEndTime.LowPart = ftEndTime.dwLowDateTime;
	liEndTime.HighPart = ftEndTime.dwHighDateTime;

	// Use normal 64-bit arithmetic on the LARGE_INTEGER value. 
	llDeltaTime = liEndTime.QuadPart - liStartTime.QuadPart;

	// convert to seconds
	*pdwSeconds = (DWORD) (llDeltaTime / 10000000);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\graphix.cpp ===
/*****************************************************************************************************************

FILENAME: Graphix.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"

#ifndef SNAPIN
#include <windows.h>
#endif

#include "ErrMacro.h"
#include "Graphix.h"

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine draws a one line border with given dimensions in the given HDC.

INPUT:
	OutputDC - The HDC to draw into.
	pRect - The rect for the border -- it'll be drawn just on the inside edge.
	BorderType - 1 means indented border, 2 means raised border.

RETURN:
	TRUE - Success.
	FALSE - Failure.
*/

BOOL DrawBorder(
	HDC OutputDC, 
	RECT * pRect, 
	int BorderType)
{
	HPEN hPen1, hPen2;
	HGDIOBJ hOld;

	//Depending whether it is a raised or sunken border, just swap
	//white and black pens.
	switch(BorderType){
	case 1:
		hPen1 = (HPEN)GetStockObject(BLACK_PEN);
		EF_ASSERT(hPen1);
		hPen2 = (HPEN)GetStockObject(WHITE_PEN);
		EF_ASSERT(hPen2);
		break;
	case 2:
		hPen1 = (HPEN)GetStockObject(WHITE_PEN);
		EF_ASSERT(hPen1);
		hPen2 = (HPEN)GetStockObject(BLACK_PEN);
		EF_ASSERT(hPen2);
		break;
	default:
		return FALSE;
	}

	//Draw the left and upper edges.
	if (hPen1)
		hOld = SelectObject(OutputDC, hPen1);
	MoveToEx(OutputDC, pRect->right, pRect->top, NULL);
	LineTo(OutputDC, pRect->left, pRect->top);
	LineTo(OutputDC, pRect->left, pRect->bottom);

	//Draw the lower and right edges.
	if (hPen2)
		SelectObject(OutputDC, hPen2);
	LineTo(OutputDC, pRect->right, pRect->bottom);
	LineTo(OutputDC, pRect->right, pRect->top);

	SelectObject(OutputDC, hOld);

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine draws a one line box with given dimensions in the given HDC.

INPUT:
	OutputDC - The HDC to draw into.
	pRect - The rect for the border -- it'll be drawn just on the inside edge.
	crColor - The color of the box.

RETURN:
	TRUE - Success.
	FALSE - Failure.
*/

BOOL ESIDrawEdge(
	HDC OutputDC, 
	int startX,
	int startY,
	int endX,
	int endY)
{
	// Highlight color for three-dimensional display elements (white)
	// (for edges facing the light source.) 
	HPEN pen3DHilight = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DHILIGHT));
	EF_ASSERT(pen3DHilight);

	// Light color for three-dimensional display elements
	// (for edges facing the light source.) (grey)
	HPEN pen3DLight = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DLIGHT));
	EF_ASSERT(pen3DLight);
	
	// Face color for three-dimensional display elements (grey)
	HPEN pen3DFace = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DFACE));
	EF_ASSERT(pen3DFace);
	
	// Shadow color for three-dimensional display elements
	// (for edges facing away from the light source).  (dark grey)
	HPEN pen3DShadow = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DSHADOW));
	EF_ASSERT(pen3DShadow);

	// Dark shadow for three-dimensional display elements (black)
	HPEN pen3DDKShadow = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DDKSHADOW));
	EF_ASSERT(pen3DDKShadow);

	HGDIOBJ hOld = SelectObject(OutputDC, pen3DLight);
	MoveToEx(OutputDC, startX, startY++, NULL);
	LineTo(OutputDC, endX, endY++);

	SelectObject(OutputDC, pen3DHilight);
	MoveToEx(OutputDC, startX, startY++, NULL);
	LineTo(OutputDC, endX, endY++);

	for (int i=0; i<3; i++){
		hOld = SelectObject(OutputDC, pen3DLight);
		MoveToEx(OutputDC, startX, startY++, NULL);
		LineTo(OutputDC, endX, endY++);
	}

	SelectObject(OutputDC, pen3DShadow);
	MoveToEx(OutputDC, startX, startY++, NULL);
	LineTo(OutputDC, endX, endY++);

	SelectObject(OutputDC, pen3DDKShadow);
	MoveToEx(OutputDC, startX, startY++, NULL);
	LineTo(OutputDC, endX, endY++);
	
	SelectObject(OutputDC, hOld);
	DeleteObject(pen3DHilight);
	DeleteObject(pen3DLight);
	DeleteObject(pen3DFace);
	DeleteObject(pen3DShadow);
	DeleteObject(pen3DDKShadow);

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine draws a one line border of given types with given dimensions
    and given colors in the given HDC. The colors are light and dark for 3D
    effect except for the PLAIN_BORDER which uses the crLight color.

    NOTE: There is NO error checking on the MoveToEx() and LineTo() routines.
          This is to maximize performance.

INPUT:
	hdcOutput - HDC to draw into.
	prect - rect for the border - it'll be drawn just on the inside edge.
	iBorderType - PLAIN_BORDER  - 2D
                  SUNKEN_BORDER - 3D
                  RAISED_BORDER - 3D
                  SUNKEN_BOX    - 3D
                  RAISED_BOX    - 3D

HRESULT:
	S_OK
    ERROR_INVALID_PARAMETER
*/

HRESULT
DrawBorderEx(
    IN HDC hdcOutput,
    IN RECT rect,
    IN int iBorderType
    )
{
    // Validate input.
    if(hdcOutput == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

	// Highlight color for three-dimensional display elements (white)
	// (for edges facing the light source.) 
	HPEN pen3DHilight = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DHILIGHT));
	EE_ASSERT(pen3DHilight);

	// Light color for three-dimensional display elements
	// (for edges facing the light source.) (grey)
	HPEN pen3DLight = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DLIGHT));
	EE_ASSERT(pen3DLight);
	
	// Face color for three-dimensional display elements (grey)
	HPEN pen3DFace = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DFACE));
	EE_ASSERT(pen3DFace);
	
	// Shadow color for three-dimensional display elements
	// (for edges facing away from the light source).  (dark grey)
	HPEN pen3DShadow = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DSHADOW));
	EE_ASSERT(pen3DShadow);

	// Dark shadow for three-dimensional display elements (black)
	HPEN pen3DDKShadow = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DDKSHADOW));
	EE_ASSERT(pen3DDKShadow);

	HGDIOBJ hOld = SelectObject(hdcOutput, pen3DLight);

    // Move to the top-right corner to start.
    MoveToEx(hdcOutput, rect.right, rect.top, NULL);

	// Depending whether it is a raised or sunken, swap the Dark and Light colors.
	switch(iBorderType) {

    case SUNKEN_BOX:
	    //Draw the top and left sides with black
	    SelectObject(hdcOutput, pen3DDKShadow);
	    LineTo(hdcOutput, rect.left, rect.top);
	    LineTo(hdcOutput, rect.left, rect.bottom);

	    //Draw the right and bottom sides with white
	    SelectObject(hdcOutput, pen3DHilight);
	    LineTo(hdcOutput, rect.right, rect.bottom);
	    LineTo(hdcOutput, rect.right, rect.top);
		break;

	case SUNKEN_BORDER:
	    //Draw the top, left, right and bottom sides with dark grey
        SelectObject(hdcOutput, pen3DShadow);
	    LineTo(hdcOutput, rect.left, rect.top);
	    LineTo(hdcOutput, rect.left, rect.bottom);
	    LineTo(hdcOutput, rect.right, rect.bottom);
	    LineTo(hdcOutput, rect.right, rect.top);

	    //Draw the top and left sides with white
        SelectObject(hdcOutput, pen3DHilight);
	    MoveToEx(hdcOutput, rect.right-1, rect.top+1, NULL);
	    LineTo(hdcOutput, rect.left+1, rect.top+1);
	    LineTo(hdcOutput, rect.left+1, rect.bottom);

	    //Draw the bottom and right sides with white
	    MoveToEx(hdcOutput, rect.left, rect.bottom+1, NULL);
	    LineTo(hdcOutput, rect.right+1, rect.bottom+1);
	    LineTo(hdcOutput, rect.right+1, rect.top-1);
		break;

	case PLAIN_BORDER:
	    //Draw the top, left, right and bottom sides black
	    SelectObject(hdcOutput, pen3DDKShadow);
	    LineTo(hdcOutput, rect.left, rect.top);
	    LineTo(hdcOutput, rect.left, rect.bottom);
	    LineTo(hdcOutput, rect.right, rect.bottom);
	    LineTo(hdcOutput, rect.right, rect.top);
		break;

	case RAISED_BORDER:
	    //Draw the top, left, right and bottom sides
        SelectObject(hdcOutput, pen3DHilight);
	    LineTo(hdcOutput, rect.left, rect.top);
	    LineTo(hdcOutput, rect.left, rect.bottom);
	    LineTo(hdcOutput, rect.right, rect.bottom);
	    LineTo(hdcOutput, rect.right, rect.top);

	    //Draw the top and left sides
        SelectObject(hdcOutput, pen3DShadow);
	    MoveToEx(hdcOutput, rect.right-1, rect.top+1, NULL);
	    LineTo(hdcOutput, rect.left+1, rect.top+1);
	    LineTo(hdcOutput, rect.left+1, rect.bottom);

	    //Draw the bottom and right sides
	    MoveToEx(hdcOutput, rect.left, rect.bottom+1, NULL);
	    LineTo(hdcOutput, rect.right+1, rect.bottom+1);
	    LineTo(hdcOutput, rect.right+1, rect.top-1);
		break;

	case RAISED_BOX:
		//Draw the top and left sides with black
		SelectObject(hdcOutput, pen3DDKShadow);
		LineTo(hdcOutput, rect.left, rect.top);
		LineTo(hdcOutput, rect.left, rect.bottom);

		//Draw the right and bottom sides
		SelectObject(hdcOutput, pen3DShadow);
		LineTo(hdcOutput, rect.right, rect.bottom);
		LineTo(hdcOutput, rect.right, rect.top);
		break;

	default:
		return ERROR_INVALID_PARAMETER;

	}

    // Replace the saved object.
	SelectObject(hdcOutput, hOld);
	DeleteObject(pen3DHilight);
	DeleteObject(pen3DLight);
	DeleteObject(pen3DFace);
	DeleteObject(pen3DShadow);
	DeleteObject(pen3DDKShadow);

	return S_OK;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine draws a progress display of the specified size, color and percent done value.

    NOTE: There is NO error checking on the MoveToEx() and LineTo() routines.
          This is to maximize perfromance.

GLOBAL DATA:
  
INPUT:
	hdcOutput - HDC to draw into.
	prect - rect for the border - it'll be drawn just on the inside edge.
	hFont - The font to write text in.
    iWidth - width of the bars in pixels
	iSpace - the space between the bars in pixels - can be zero for a solid progress dsiplay
	iPercent - the percent done between 0 - 100.

RETURN:
	HRESULT - S_OK
	HRESULT - ERROR_INVALID_PARAMETER
*/

HRESULT
ProgressBar(
    IN HDC hdcOutput,
    IN RECT* prect,
	IN HFONT hFont,
    IN int iWidth,
	IN int iSpace,
	IN int iPercent
    )
{
	// Validate input - note if iPercent is the same as previously do nothing.
	if(iPercent > 100 || iWidth < 1 || hdcOutput == NULL || prect == NULL) {
		return ERROR_INVALID_PARAMETER;
	}

	int i, iStart, iEnd;

	////////////////////////////////////
	// Set the progress bar back to zero
	////////////////////////////////////

	// the null bar color
	HPEN hBlankBar = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_INACTIVECAPTION));

   // if can't do it, use a stock object (this can't fail)
    if (hBlankBar == NULL)
	{
        hBlankBar = (HPEN)GetStockObject(WHITE_PEN);
	}

	// Select the new pen and save the current pen
	HGDIOBJ hOld;
	if (hBlankBar)
		hOld = SelectObject(hdcOutput, hBlankBar);

	// Get the start and end
	iStart = prect->left;
	iEnd = prect->right;

	while(iStart < iEnd) {

		// Draw a bar
		for(i=0; i<iWidth && iStart < iEnd; i++, iStart++) {

			// Move to the top-left corner to start.
			MoveToEx(hdcOutput, iStart, prect->top, NULL);
			// Draw the one vertical line.
			LineTo(hdcOutput, iStart, prect->bottom);
		}
		// Make the space between the bars
		iStart += iSpace;
	}
	// Replace the previous pen
	SelectObject(hdcOutput, hOld);

	// delete the new pen
	DeleteObject(hBlankBar);

	if (iPercent < 0)
		iPercent = 0;

	// We are done if iPercent is zero.
	if (iPercent == 0)
		return S_OK;

	////////////////////////////////////
	// Now draw the progress
	////////////////////////////////////

	// Adjust iPercent for decimal point
	//iPercent = 1000 / iPercent;

	// Calculate the end based on iPercent
	//iEnd = (10 * (prect->right - prect->left - 30)) / iPercent) + prect->left + 30;
	iEnd = prect->left + 30 + (prect->right - prect->left - 30) * iPercent / 100;

	// Get the start.
	iStart = prect->left;

	// Save the old pen and set the new one
	// the colored bar color
	HPEN hColorBar = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_ACTIVECAPTION));

	   // if can't do it, use a stock object (this can't fail) bug 455614
    if (hColorBar == NULL)
	{
        hColorBar = (HPEN)GetStockObject(BLACK_PEN);
	}

	if (hColorBar)
		hOld = SelectObject(hdcOutput, hColorBar);

	while(iStart < iEnd) {

		// Draw a solid bar of iWidth pixels in size
		for(i=0; i<iWidth && iStart < iEnd; i++, iStart++) {

			// Move to the top-left corner to start.
			MoveToEx(hdcOutput, iStart, prect->top, NULL);
			// Draw the one vertical line.
			LineTo(hdcOutput, iStart, prect->bottom);
		}
		// Make the space
		iStart += iSpace;
	}

    // Go back to the old pen
	SelectObject(hdcOutput, hOld);

	// delete the progress bar pen
	DeleteObject(hColorBar);

	return S_OK;
}

/*****************************************************************************************************************

CLASS:	CBMP

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

CLASS DESCRIPTION:
	CBmp is a bitmap class.  It will draw the bitmap and do various actions
	on the bitmap automatically.

*/

// This is the constructor for a single bitmap.

CBmp::CBmp(HINSTANCE hInstance, LPTSTR BitmapResource)
{
	hInst = hInstance;

	// So as not to confuse the rest of the class that is built for multiple bitmaps, 
	// set this bitmap into a single bitmap array.
	BitmapArray = new HBITMAP [1];

	// load it
	if (BitmapArray != NULL) {

		iNumBitmaps = 1;

		if ((BitmapArray[0] = LoadBitmap((HINSTANCE) hInst, BitmapResource)) == NULL) {
			DeleteBitmaps();
			EH(BitmapArray);
		}
	}

	// unless memory allocation failed
	else {
		iNumBitmaps = 0;
	}
}

// Constructor for loading multiple bitmaps.

CBmp::CBmp(HINSTANCE hInstance, INT_PTR * piBitmapsToLoadArray, int iNumBitmapsToLoad)
{
	hInst = hInstance;
	iNumBitmaps = 0;
	BitmapArray = NULL;

	// The person may not know what bitmaps to load yet -- if not he'll have to call
	// CBmp::LoadBitmaps() below and pass in 0 for iNumBitmapsToLoad.
	if (iNumBitmapsToLoad > 0) {
		LoadBitmaps(piBitmapsToLoadArray, iNumBitmapsToLoad);
	}
}

void CBmp::DeleteBitmaps()
{
	if (BitmapArray != NULL) {

		for (int ii = 0; ii < iNumBitmaps; ii++) {
			DeleteObject(BitmapArray[ii]);
		}

		delete [] BitmapArray;
		BitmapArray = NULL;
	}

	iNumBitmaps = 0;
}

CBmp::~CBmp()
{
	DeleteBitmaps();
}

// If the user did't know what bitmaps he wanted when calling the class 
// he can call the multiple bitmap constructor and feed it a value of 0 bitmaps to load.
// Then he must call this function before continuing.

void CBmp::LoadBitmaps(INT_PTR * piBitmapsToLoadArray, int iNumBitmapsToLoad)
{
	// If bitmaps are already loaded, then deallocate them and load again.
	DeleteBitmaps();

	// load new stuff
	if (iNumBitmapsToLoad > 0) {

		BitmapArray = new HBITMAP [iNumBitmapsToLoad];

		// load 'em
		if (BitmapArray != NULL) {

			iNumBitmaps = iNumBitmapsToLoad;

			// Load each bitmap the user requested in his array: piBitmapsToLoadArray.
			for (int ii = 0; ii < iNumBitmapsToLoad; ii++) {

				BitmapArray[ii] = LoadBitmap((HINSTANCE) hInst, 
											(LPCTSTR) piBitmapsToLoadArray[ii]);

				// abort on failure
				if (BitmapArray[ii] == NULL) {
					DeleteBitmaps();
					EH(BitmapArray);
					break;
				}
			}
		}

		// unless memory allocation failed
		else {
			iNumBitmaps = 0;
		}
	}
}

// Shell for the multiple version of ChangeColor -- allows user to use this class 
// for single bitmaps without the complexity of dealing with the bitmap number.

BOOL CBmp::ChangeColor(int iOldColor, int iNewColor)
{
	return ChangeColor(0, iOldColor, iNewColor);
}

// Changes the a color in the bitmap.
// All iOldColor colored pixels are replaced with iNewColor.

BOOL CBmp::ChangeColor(int iBitmap, int iOldColor, int iNewColor)
{
	if (BitmapArray != NULL) {

		require(iBitmap < iNumBitmaps);

		BITMAP  bmData;
		HBITMAP hBitmap = BitmapArray[iBitmap];

		GetObject(hBitmap, sizeof(BITMAP), &bmData);

		// Must be one byte per pixel.
		// This function is only implemented for 256 color bitmaps.
		if ((bmData.bmPlanes != 1) && (bmData.bmBitsPixel != 8)) {
			return FALSE;
		}

		// Get the bitmap data.
		int iNumBitmapBytes = bmData.bmWidth * bmData.bmHeight;
		char * cBitData = new char [iNumBitmapBytes];
		EF_ASSERT(cBitData);

		if (!GetBitmapBits(hBitmap, iNumBitmapBytes, cBitData)) {
			if (cBitData != NULL) {
				delete [] cBitData;
			}
			return FALSE;
		}

		// Swap colors.
		for (int ii = 0; ii < iNumBitmapBytes; ii++) {
			if (cBitData[ii] == (char) iOldColor) {
				cBitData[ii] = (char) iNewColor;
			}
		}

		// Replace the old bitmap with the one we just created.
		HBITMAP hNewBitmap = CreateBitmap(bmData.bmWidth, bmData.bmHeight, 1, 8, cBitData);
		if (hNewBitmap != NULL) {
			DeleteObject(BitmapArray[iBitmap]);
			BitmapArray[iBitmap] = hNewBitmap;
		}

		if (cBitData != NULL) {
			delete [] cBitData;
		}

		if (hNewBitmap != NULL) {
			return TRUE;
		}
	}

	return FALSE;
}

// Shell for multiple version of GetBmpSize.

BOOL CBmp::GetBmpSize(int * piX, int * piY)
{
	return GetBmpSize(0, piX, piY);
}

// Returns the size of the bitmap.

BOOL CBmp::GetBmpSize(int iBitmap, int * piX, int * piY)
{
	if (BitmapArray != NULL) {

		require(iBitmap < iNumBitmaps);

		BITMAP bmData;

		if (!GetObject(BitmapArray[iBitmap], sizeof(BITMAP), &bmData)) {
			return FALSE;
		}

		*piX = bmData.bmWidth;
		*piY = bmData.bmHeight;

		return TRUE;
	}

	return FALSE;
}

// Shell for multiple version of DrawBmpInHDC.

BOOL CBmp::DrawBmpInHDC(HDC OutputDC, int iX, int iY)
{
	return DrawBmpInHDC(OutputDC, 0, iX, iY);
}

// Draws the bitmap at location (iX, iY) in OutputDC.

BOOL CBmp::DrawBmpInHDC(HDC OutputDC, int iBitmap, int iX, int iY)
{
	if (BitmapArray != NULL) {

		require(iBitmap < iNumBitmaps);

		HBITMAP hBitmap = BitmapArray[iBitmap];

		// BitBlt the bitmap into the OutputDC
		BITMAP bmData;
		if (!GetObject(hBitmap, sizeof(BITMAP), &bmData)) {
			return FALSE;
		}

		HDC CommonDC = CreateCompatibleDC(OutputDC);
		EF_ASSERT(CommonDC);

		HGDIOBJ hOld = SelectObject(CommonDC, hBitmap);

		BOOL ok = BitBlt(OutputDC, iX, iY, bmData.bmWidth, bmData.bmHeight, 
						CommonDC, 0, 0, SRCCOPY);

		SelectObject(CommonDC, hOld);
		DeleteDC(CommonDC);

		if (ok) {
			return TRUE;
		}
	}

	return FALSE;
}


// Shell for multiple version of DrawBmpInHDCTruncate.

BOOL CBmp::DrawBmpInHDCTruncate(HDC OutputDC, RECT * Rect)
{
	return DrawBmpInHDCTruncate(OutputDC, 0, Rect);
}

// Draws the bitmap within RECT in OutputDC.

BOOL CBmp::DrawBmpInHDCTruncate(HDC OutputDC, int iBitmap, RECT * Rect)
{
	if (BitmapArray != NULL) {

		require(iBitmap < iNumBitmaps);

		HBITMAP hBitmap = BitmapArray[iBitmap];

		// BitBlt the bitmap into the OutputDC
		BITMAP bmData;
		if (!GetObject(hBitmap, sizeof(BITMAP), &bmData)) {
			return FALSE;
		}

		int nWidth = (bmData.bmWidth > (Rect->right - Rect->left)) ? 
										(Rect->right - Rect->left) : bmData.bmWidth;
		int nHeight = (bmData.bmHeight > (Rect->bottom - Rect->top)) ? 
										(Rect->bottom - Rect->top) : bmData.bmHeight;

		HDC CommonDC = CreateCompatibleDC(OutputDC);
		EF_ASSERT(CommonDC);

		HGDIOBJ hOld = SelectObject(CommonDC, hBitmap);
		EH_ASSERT(hOld);

		BOOL ok = BitBlt(OutputDC, Rect->left, Rect->top, nWidth, nHeight, CommonDC, 
						0, 0, SRCCOPY);

		SelectObject(CommonDC, hOld);
		DeleteDC(CommonDC);

		if (ok) {
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\getdfrgres.cpp ===
#include "stdafx.h"

#ifndef SNAPIN
#include <windows.h>
#endif

#include <tchar.h>
#include "getreg.h"
#include "expand.h"
#include "GetDfrgRes.h"

HINSTANCE GetDfrgResHandle(BOOL fReset)
{
    // no need to keep getting this handle
    static HINSTANCE hInstRes = NULL;

    if (fReset) {
        hInstRes = NULL;
        return NULL;
    }

    if (hInstRes == NULL) {

        HKEY    hValue = NULL;
        TCHAR   cRegValue[MAX_PATH+1];
        DWORD   dwRegValueSize = sizeof(cRegValue);

        //0.0E00 Get the name of the resource DLL.
        if(GetRegValue(&hValue,
                       TEXT("SOFTWARE\\Microsoft\\Dfrg"),
                       TEXT("ResourceDllName"),
                       cRegValue,
                       &dwRegValueSize) != ERROR_SUCCESS){

            // We couldn't get the resource DLL location from the registry--
            // let's fall back to the default
            _tcscpy(cRegValue, TEXT("%systemroot%\\system32\\dfrgres.dll"));
        }

        RegCloseKey(hValue);

        //Translate any environment variables in the string.
        if(!ExpandEnvVars(cRegValue)){
            hInstRes = NULL;
            return NULL;
        }

        //0.0E00 Open the resource DLL.
        hInstRes = LoadLibrary(cRegValue);
    }

    return hInstRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\intfuncs.cpp ===
/*****************************************************************************************************************

FILENAME: Intfuncs.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"
#ifndef SNAPIN
#include <windows.h>
#endif

#include "ErrMacro.h"

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This retrieves a string from the string table and writes it into a buffer.

INPUT + OUTPUT:
	OUT TCHAR* cOutString - The buffer to write the string into.
	IN DWORD dwOutStringLen - The number of bytes in that buffer.
	IN DWORD dwResourceId - The resource id of the desired string.
	IN HINSTANCE hInst - The instance so we can access the resources.

GLOBALS:
	None.

RETURN:
	NULL - Fatal error.
	TCHAR* - cOutString

*/

TCHAR*
GetString(
	OUT TCHAR* ptOutString,
	IN DWORD dwOutStringLen,
	IN DWORD dwResourceId,
	IN HINSTANCE hInst
	)
{
	EF(LoadString(hInst, dwResourceId, ptOutString, dwOutStringLen));
	return ptOutString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\loadfile.cpp ===
/*****************************************************************************************************************

 FILE: LoadFile.cpp

 COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

 FUNCTION:
	This module reads the specified file from the disk and loads it into memory returning
	a handle to the memory

 INPUT + OUTPUT:
	IN cFileName - is a valid file name
	IN pdwFileSize - specifies how many bytes to read - if zero then the size of the memory
				 is checked and this value is calculated
	IN dwSharing - is the DWORD to pass to CreateFile about file sharing
	IN dwCreate - is the DWORD to pass to CreateFile about file creation

 GLOBALS:
	None.

 RETURN: 
	Valid handle to the memory which holds the specified file
	NULL if not succesful
*/
 
#include "stdafx.h"
#include <windows.h>
#include "ErrMacro.h"


HANDLE
LoadFile(
	IN PTCHAR cLoadFileName,
	IN PDWORD pdwFileSize,
	IN DWORD dwSharing,
	IN DWORD dwCreate
	)
{
	HANDLE hFileHandle = INVALID_HANDLE_VALUE;	// File handle
	DWORD dwFileSizeHi; 						// Hi word of file size
	DWORD dwFileSizeLo = 0xFFFFFFFF;			// Lo word of file size and initialize 
	DWORD dwReadTotal = 0;						// Total bytes read during ReadFile
	HANDLE hMemory = NULL;						// Memory handle
	LPVOID pMemory = NULL;						// Memory pointer
	DWORD dwLastError = 0;
	BOOL bReturn = FALSE;

	__try{

		// Get the file handle.
		if((hFileHandle = CreateFile(cLoadFileName,
									 0,
									 dwSharing,
									 NULL,
									 dwCreate,
									 FILE_ATTRIBUTE_NORMAL,
									 NULL)) == INVALID_HANDLE_VALUE) {

			// No error handling here!	The calling function may wish
			// to handle different situations in different ways. Save the error.
			dwLastError = GetLastError();
			__leave;
		}

		// Get the file size.
		if (*pdwFileSize != 0) {
			dwFileSizeLo = *pdwFileSize;
		}
		else{
			// File size not passed in so calculate it
			dwFileSizeLo = GetFileSize(hFileHandle,&dwFileSizeHi);
			if (dwFileSizeLo == 0xFFFFFFFF){
				EH_ASSERT(FALSE);
				__leave;
			}
		}
		// Set the file size to the actual size of the file for the calling function.
		*pdwFileSize = dwFileSizeLo;

		// Return a NULL pointer if the file size is 0.
		if(dwFileSizeLo == 0){
			__leave;
		}

		// Allocate memory for the file.
		hMemory = GlobalAlloc(GHND, dwFileSizeLo);

		if (!hMemory){
			EH_ASSERT(FALSE);
			__leave;
		}

		// Lock the memory and get pointer to the memory.
		pMemory = GlobalLock(hMemory);
		if (!pMemory){
			EH_ASSERT(FALSE);
			__leave;
		}

		// Read the file into memory.
		if (!ReadFile(hFileHandle, pMemory, dwFileSizeLo, &dwReadTotal,0)){
			__leave;
		}

		bReturn = TRUE;  // all is ok
	}

	__finally {

		// Close the file handle.
		if(hFileHandle != INVALID_HANDLE_VALUE){
			CloseHandle(hFileHandle);
		}
 
		// Success so unlock the memory and return the memory handle.
		if(bReturn) {
			GlobalUnlock(hMemory);
		}
		else { // had an error
			// So cleanup and return NULL.
			if(hMemory){
				EH_ASSERT(GlobalUnlock(hMemory) == FALSE);
				EH_ASSERT(GlobalFree(hMemory) == NULL);
				hMemory = NULL;
			}

			// Recover the error if any since another API may have cleared it.
			if(dwLastError){
				SetLastError(dwLastError);
			}
		}
	}

	return hMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\listview.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  ListView.cpp
//=============================================================================*

#include "stdafx.h"

#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif
#include <commctrl.h>

#include "Message.h"
#include "resource.h"
#include "DfrgRes.h"
#include "GetDfrgRes.h"
extern "C" {
	#include "SysStruc.h"
}
#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgUI.h"
#include "DfrgCtl.h"
#include "ErrMacro.h"
#include "ErrMsg.h"
#include "VolList.h"
#include "ListView.h"
#include "uicommon.h"

#define NUM_COLUMNS 6

static isDescending = FALSE; // for sort function

static int CALLBACK ListViewCompareFunc(IN LPARAM lParam1, IN LPARAM lParam2, IN LPARAM lParamSort);


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:
    HINSTANCE hInst:

INPUT:
    None;

RETURN:
	None.
*/

CESIListView::CESIListView(CDfrgCtl *pDfrgCtl)
{
	// the list view gets a pointer to his parent OCX
	m_pDfrgCtl = pDfrgCtl;

	m_hwndListView = NULL;
	m_himlLarge = NULL;   // image list for icon view 
	m_himlSmall = NULL;   // image list for other views 
	m_pVolumeList = NULL;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:
    None.

RETURN:
	None.
*/

CESIListView::~CESIListView()
{

	//These destroys are erroring and not freeing the memory.  This is creating a memory leak.
	// I think this is caused by the fact that the Listview is being destroyed early because 
	// it is a child of the main OCX, and when we try to destroy the ImageLists, they are no 
	// longer associated with a active window.

	if(m_himlSmall) { 
		ImageList_RemoveAll(m_himlSmall);
		ImageList_Destroy(m_himlSmall);
	}

	if(m_himlLarge) { 
		ImageList_RemoveAll(m_himlLarge);
		ImageList_Destroy(m_himlLarge);

	}
	DeleteAllListViewItems();

	if (IsWindow(m_hwndListView)) {
		DestroyWindow(m_hwndListView);
	}
}


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:
    HINSTANCE hInst:

INPUT:
    None;

RETURN:
	None.
*/
BOOL CESIListView::EnableWindow(BOOL bIsEnabled)
{
	if (bIsEnabled){
		ListView_SetTextColor(m_hwndListView, ::GetSysColor(COLOR_BTNTEXT));
	}
	else{
		ListView_SetTextColor(m_hwndListView, ::GetSysColor(COLOR_GRAYTEXT));
	}

	return ::EnableWindow(m_hwndListView, bIsEnabled);
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:
    HINSTANCE hInst:

INPUT:
    None;

RETURN:
	None.
*/

BOOL
CESIListView::InitializeListView(
	IN CVolList* pVolumeList,
	IN HWND hwndMain,
	IN HINSTANCE hInstance
	)
{
	require(pVolumeList != NULL);
	require(hwndMain != NULL);
	require(hInstance != NULL);

	// save the address of the volume comtainer class object
	m_pVolumeList = pVolumeList;
	
	TCHAR cTemp[200];

	// Create the list view window. 
	if((m_hwndListView = CreateWindowEx(
		WS_EX_WINDOWEDGE, //WS_EX_CLIENTEDGE, WS_EX_DLGMODALFRAME,	// extended window style
		WC_LISTVIEW,			// pointer to registered class name
		TEXT("DEFRAG_LISTVIEW"), 			// pointer to window name
		WS_CHILD | LVS_REPORT |
		LVS_SHAREIMAGELISTS |				//share the image list so we can delete it later and not cause a leak
		LVS_SHOWSELALWAYS | LVS_SINGLESEL,	// window style (see help on "CListCtrl::Create")
		0,						// hor position of window
		0,						// ver position of window
		CW_USEDEFAULT,			// window width
		CW_USEDEFAULT,			// window height
		hwndMain,				// handle to parent or owner
		NULL,					// handle to menu, or child-window identifier 
		hInstance,				// handle to application instance
		NULL					// pointer to window-creation data
		)) == NULL) {

		Message(TEXT("InitializeListView - CreateWindow."), GetLastError(), TEXT("m_hwndListView"));
		return FALSE; 
	}

	// Initialize the image lists.
	if (!InitListViewImageLists(m_hwndListView, hInstance)) {
		Message(TEXT("InitializeListView - InitListViewImageLists."), E_FAIL, 0);
	} 

	// make the listview hilite the entire row
	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	// Define the initial default width of each column entry.
	// 0 = Volume
	// 1 = Session Status
	// 2 = File System
	// 3 = Capacity
	// 4 = Free Space
	// 5 = %Free Space
	int iColumnWidth[NUM_COLUMNS] = {120, 120, 90, 80, 100, 100};
	int iColumnFormat[NUM_COLUMNS] = {
		LVCFMT_LEFT, 
		LVCFMT_LEFT, 
		LVCFMT_LEFT, 
		LVCFMT_RIGHT, 
		LVCFMT_RIGHT, 
		LVCFMT_RIGHT
	};
	int iColumnID[NUM_COLUMNS] = {
		IDS_FIRST_COLUMN,
		IDS_SECOND_COLUMN,
		IDS_THIRD_COLUMN,
		IDS_FOURTH_COLUMN,
		IDS_FIFTH_COLUMN,
		IDS_SIXTH_COLUMN
	};

	// Initialize the LVCOLUMN structure. 
	LVCOLUMN lvc = {0};
	lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM; 
	lvc.pszText = cTemp; // column header (loaded from resources in loop below)

	// Prepare for font calculations.
	int tmpStrWidth;

	// Add the columns. 
	for (int col = 0; col < NUM_COLUMNS; col++) {
	
		lvc.iSubItem = col;
		lvc.fmt = iColumnFormat[col];

		// Get the names from the main defrag resource string table.
		LoadString(
			GetDfrgResHandle(), 
			iColumnID[col], 
			cTemp, 
			sizeof(cTemp)/sizeof(TCHAR));

//		_tcscpy(lvc.pszText, cTemp);
//		_tcsnccpy(lvc.pszText, cTemp);

		// Insert the columns into the ListView.
		if (ListView_InsertColumn(m_hwndListView, col, &lvc) == -1) {
			Message(TEXT("InitializeListView - ListView_InsertColumn."), E_FAIL, 0);
			break;
		}

		// Size column to header text.
		if (!ListView_SetColumnWidth(m_hwndListView, col, LVSCW_AUTOSIZE_USEHEADER)) {
			Message(TEXT("InitializeListView - ListView_SetColumnWidth."), E_FAIL, 0);
		}

		// Grow width if needed.
		tmpStrWidth = ListView_GetColumnWidth(m_hwndListView, col);
		if (tmpStrWidth < iColumnWidth[col]) {
			if (!ListView_SetColumnWidth(m_hwndListView, col, iColumnWidth[col])) {
				Message(TEXT("InitializeListView - 2nd ListView_SetColumnWidth."), E_FAIL, 0);
			}
		}

	}

	::ShowWindow(m_hwndListView, TRUE);
	return TRUE;
} 
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Creates image lists for a list view.  

GLOBAL VARIABLES:

INPUT:
    HWND m_hwndListView - handle of the list view window. 

RETURN:
    TRUE = success
    FALSE = error
*/

BOOL
CESIListView::InitListViewImageLists(
    IN HWND m_hwndListView,
    IN HINSTANCE hInstance
    ) 
{ 
    // Create the full-sized and small icon image lists. 
    m_himlLarge = ImageList_Create(GetSystemMetrics(SM_CXICON), 
                                 GetSystemMetrics(SM_CYICON),
                                 ILC_MASK, //TRUE,
                                 2,
                                 1); 
    
    m_himlSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
                                 GetSystemMetrics(SM_CYSMICON),
                                 ILC_MASK, //TRUE,
                                 2,
                                 1); 

    // Add an icon to each image list. 
    HICON hiconItem = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_DISK)); 
	if (hiconItem){
		ImageList_AddIcon(m_himlLarge, hiconItem); 
		ImageList_AddIcon(m_himlSmall, hiconItem); 
	}

    hiconItem = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_REMDISK)); 
	if (hiconItem){
		ImageList_AddIcon(m_himlLarge, hiconItem); 
		ImageList_AddIcon(m_himlSmall, hiconItem); 
	}

    // Assign the image lists to the list view control. 
    ListView_SetImageList(m_hwndListView, m_himlLarge, LVSIL_NORMAL);



    ListView_SetImageList(m_hwndListView, m_himlSmall, LVSIL_SMALL); 

    return TRUE; 
} 
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Sizes the list view window

GLOBAL VARIABLES:
    HWND m_hwndListView - handle of the list view window. 

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/

BOOL CESIListView::SizeListView(
    IN int iHorizontal,
    IN int iVertical,
    IN int iWidth,
    IN int iHeight
    ) 
{ 
	// Size and position the List View.
	MoveWindow(
		m_hwndListView,	// handle of window
		iHorizontal,	// horizontal position
		iVertical,		// vertical position
		iWidth,			// width
		iHeight,		// height
		TRUE			// repaint
		);

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Repaint the list view.

GLOBAL VARIABLES:
    HWND m_hwndListView - handle of the list view window. 

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/
BOOL CESIListView::RepaintListView(void)
{
	ListView_RedrawItems(m_hwndListView, 0, ListView_GetItemCount(m_hwndListView)-1);

	BOOL isOk = UpdateWindow(m_hwndListView);
	if (!isOk) {
		Message(L"RepaintListView", GetLastError(), NULL);
		return FALSE;
	}
	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Repaint a single list view row

GLOBAL VARIABLES:
    none

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/
BOOL CESIListView::Update(CVolume *pVolume)
{
	LV_ITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;

	// Find that drive in the list
	for (lvi.iItem=0; lvi.iItem < ListView_GetItemCount(m_hwndListView); lvi.iItem++) {

		// Get the data structure associated with this drive
		ListView_GetItem(m_hwndListView, &lvi);

		// lparam is a pointer to the data struct
		// if a match, update that row
		if (pVolume == (CVolume *) lvi.lParam){
			ListView_Update(m_hwndListView, lvi.iItem);
			break;
		}
	}

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    handles notification messages for the list view window

GLOBAL VARIABLES:
    HWND m_hwndListView - handle of the list view window. 

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/

void CESIListView::NotifyListView(IN LPARAM lParam)
{
    NM_LISTVIEW *pnm = (NM_LISTVIEW *)lParam;

    // Branch depending on the specific notification message. 
    switch (pnm->hdr.code) {
 
		case NM_KILLFOCUS: // when the listview loses the focus
			//Message(TEXT("NotifyListView: NM_KILLFOCUS"), -1, NULL);
			break;

		case NM_DBLCLK:
			//Message(TEXT("NotifyListView: NM_DBLCLK"), -1, NULL);
            break;

		case LVN_ITEMCHANGED:
		//case NM_RCLICK:
		//case NM_CLICK:
		{
			Message(TEXT("NotifyListView: LVN_ITEMCHANGED"), -1, NULL);
			CVolume *pSelectedVolume = NULL;

			// Get the current number of items in the list view window
			UINT iItemCount = ListView_GetItemCount(pnm->hdr.hwndFrom);

			// loop through list and find who's selected now
			for (UINT index=0; index < iItemCount; index++) {

				// Check if the item is selected.
				if(ListView_GetItemState(pnm->hdr.hwndFrom, index, LVIS_SELECTED) == LVIS_SELECTED ) {

					// Get the destination path & file name.
					LV_ITEM lvi;
					lvi.mask = LVIF_PARAM;
					lvi.iItem = index;
					lvi.iSubItem = 0;

					// get the lparam, it is a pointer to the data struct
					ListView_GetItem(pnm->hdr.hwndFrom, &lvi);

					pSelectedVolume = (CVolume *) lvi.lParam;
					break;
				}
			}

			// Bail if no selected item was found.
			if (index >= iItemCount){
				break;
			}

			//check the volume and change if it is not the current volume
			if (pSelectedVolume != NULL) {
				// make this the current volume
				m_pVolumeList->SetCurrentVolume(pSelectedVolume);

				// this call will resend the graphic well size to the engines
				// in case the windows was resized 
				m_pDfrgCtl->SizeGraphicsWindow();

				// tell the user of this listview that it's time to redraw
				m_pDfrgCtl->InvalidateGraphicsWindow();
#ifdef ESI_PROGRESS_BAR
				m_pDfrgCtl->InvalidateProgressBar();
#endif
				m_pDfrgCtl->SetButtonState();
			}
		}
		break;

        // Process LVN_GETDISPINFO to supply information about callback items. 
        case LVN_GETDISPINFO: 
		{
//			Message(TEXT("NotifyListView: LVN_GETDISPINFO"), -1, NULL);
            LV_DISPINFO *plvdi = (LV_DISPINFO *)lParam;
			CVolume *pVolume = (CVolume *)(plvdi->item.lParam);

            // Provide the item or subitem's text, if requested. 
            if (plvdi->item.mask & LVIF_TEXT) {

				// copy the text from the array into the list column
				switch (plvdi->item.iSubItem)
				{
				case 0:
					_tcsnccpy(plvdi->item.pszText, pVolume->DisplayLabel(), 
							plvdi->item.cchTextMax);
					break;

				case 1:
					_tcsnccpy(plvdi->item.pszText, pVolume->sDefragState(), 
							plvdi->item.cchTextMax);
					break;

				case 2:
					_tcsnccpy(plvdi->item.pszText, pVolume->FileSystem(), 
							plvdi->item.cchTextMax);
					break;

				case 3:
					_tcsnccpy(plvdi->item.pszText, pVolume->sCapacity(), 
							plvdi->item.cchTextMax);
					break;

				case 4:
					_tcsnccpy(plvdi->item.pszText, pVolume->sFreeSpace(), 
							plvdi->item.cchTextMax);
					break;
				
				case 5:
					_tcsnccpy(plvdi->item.pszText, pVolume->sFreeSpacePercent(), 
							plvdi->item.cchTextMax);
					break;
				
				}
            } 
            break; 
		}

        // Process LVN_COLUMNCLICK to sort items by column. 
        case LVN_COLUMNCLICK:
		{
			//Message(TEXT("NotifyListView: LVN_COLUMNCLICK"), -1, NULL);
            ListView_SortItems(
				pnm->hdr.hwndFrom, 
				ListViewCompareFunc, 
				pnm->iSubItem);
			isDescending = !isDescending;
            break;
		}

		/*
		default:
		{
			TCHAR msg[200];
			wsprintf(msg, L"message Number %d in list view", pnm->hdr.code);
			Message(msg, -1, NULL);
		}
		*/

    } 
} 
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

DATA STRUCTURES:
    None.

GLOBAL VARIABLES:
    HWND m_hwndListView - handle to the List View window.

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/

BOOL
CESIListView::AddListViewItem(
	IN CVolume *pVolume
    ) 
{
    if(m_hwndListView == NULL) {
        return TRUE;
    }
    
	// Get the current number of items in the list view window
	UINT iItemCount = ListView_GetItemCount(m_hwndListView);

	// Initialize LV_ITEM members. 
	LV_ITEM lvi;
	lvi.mask		= LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
	lvi.iItem		= iItemCount; 
	lvi.iSubItem	= 0;
	lvi.state		= 0;
	lvi.stateMask	= 0;
	lvi.pszText		= LPSTR_TEXTCALLBACK; // will be populated by the callback
	lvi.cchTextMax	= 0;
	if (pVolume->RemovableVolume()){
		lvi.iImage = 1; // removable vol icon
	}
	else {
		lvi.iImage = 0; // fixed vol icon
	}

	lvi.lParam = (LPARAM) pVolume; // store pointer to volume object

	if (ListView_InsertItem(m_hwndListView, &lvi) == -1)
		return FALSE;

//	for (UINT iSubItem = 1; iSubItem < NUM_COLUMNS; iSubItem++)
//	{
//		ListView_SetItemText(m_hwndListView,
//							lvi.iItem, 
//							iSubItem, 
//							LPSTR_TEXTCALLBACK);
//	}

	ListView_RedrawItems(m_hwndListView, 0, ListView_GetItemCount(m_hwndListView)-1);

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:
    HINSTANCE hInst:

INPUT:
    HWND hWnd

RETURN:
	None.
*/

BOOL
CESIListView::DeleteAllListViewItems(void) 
{
    if (IsWindow(m_hwndListView)) {

        // Delete all the current ListView items.
        if(!ListView_DeleteAllItems(m_hwndListView)) {
            Message(TEXT("DeleteAllListViewItems - ListView_DeleteAllItems."), E_FAIL, 0);
        }
    }
    return TRUE;
}
/*****************************************************************************************************************

  Specific ListView Functions

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:
    None;

RETURN:
	True is drives were added to the list, otherwise false.
*/

BOOL CESIListView::GetDrivesToListView(void)
{
	CVolume *pVolume;
	BOOL bDrivesAdded = FALSE;

	if (!m_pVolumeList->Refresh()){
		return FALSE;
	}

	//////////////////////////////////////////////////////////////
	// loop through all the volumes
	//////////////////////////////////////////////////////////////
	for(UINT i=0; i<m_pVolumeList->GetVolumeCount(); i++){

		pVolume = m_pVolumeList->GetVolumeAt(i);
		if (pVolume == (CVolume *) NULL)
			continue;

		// Is this volume no longer available
		// (m_pVolumeList->Refresh() will leave deleted drives for one pass)
		if (pVolume->Deleted()){
			// Find the item and delete.
			int index = FindListViewItem(pVolume);
			if (index > -1) {
				// is the currently selected drive the one we are deleting?
				BOOL bSelectAnotherDrive = FALSE;  // in case we delete the current drive
				if(ListView_GetItemState(m_hwndListView, index, LVIS_SELECTED) == LVIS_SELECTED)
					bSelectAnotherDrive = TRUE;

				// delete this drive
				ListView_DeleteItem(m_hwndListView, index);

				// select the first drive in the list
				if (bSelectAnotherDrive){
					SelectInitialListViewDrive(NULL);
				}
			}

			// go to next volume
			continue;
		}

		// update the display of this volume (this will be TRUE for new volumes)
		if (pVolume->Changed()){

			// new volume, so add a drive letter to the list
			if (pVolume->New()){
				AddListViewItem(pVolume);
				bDrivesAdded = TRUE;
				//pVolume->New(FALSE); will be set during the next refresh()
			}

			// Find the item and update the ListView
			int index = FindListViewItem(pVolume);
			if (index > -1){
				ListView_Update(m_hwndListView, index);
				pVolume->Changed(FALSE);
			}
		}

		// If this volume is being defragged, prompt the user to restart or stop the engine
		if (pVolume->FileSystemChanged() && pVolume->EngineState() == ENGINE_STATE_RUNNING){
			pVolume->AbortEngine();
		}
	}

	return bDrivesAdded;
} 

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:
    None;

RETURN:
	None.
*/

void CESIListView::SelectInitialListViewDrive(BOOL * needFloppyWarn)
{
	LV_ITEM lvi;
	lvi.mask = LVIF_PARAM;
	lvi.iSubItem = 0;
	CVolume *pVolume;

	// default don't need to show illegal volume warning
	if (needFloppyWarn != NULL) {
		*needFloppyWarn = FALSE;
	}

	////////////////////////////////////////////////////////////////
	// What drive letter, if any, was passed in on the command line?
	// The drive letter and a colon are the last 2 chars in the string
	////////////////////////////////////////////////////////////////

	// Get the command line string
	TCHAR *pCommandLine = GetCommandLine();
	Message(TEXT("Command Line:"), -1, pCommandLine);

	// find the last ":" in the string
	TCHAR *pDriveLetter = wcsrchr(pCommandLine, L':');

	// was a ":" found?, and was this the last char in the string?
	if (pDriveLetter && *(pDriveLetter+1) == NULL){

		// move back one character to get the drive letter
		pDriveLetter--;

		// If not null, then we found a ":"
		if (IsCharAlpha(*pDriveLetter)){

			TCHAR cDrive = towupper(*pDriveLetter);

			if (IsValidVolume(cDrive)){

				// Find that drive in the list
				for (lvi.iItem=0; lvi.iItem < ListView_GetItemCount(m_hwndListView); lvi.iItem++) {

					// Get the data structure associated with this drive
					ListView_GetItem(m_hwndListView, &lvi);

					// lparam is a pointer to the data struct
					pVolume = (CVolume *) lvi.lParam;

					// if a match, hilite that item and set to current drive
					if(cDrive == pVolume->Drive()){
						ListView_SetItemState(m_hwndListView, lvi.iItem, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
						m_pVolumeList->SetCurrentVolume(pVolume);
						return;
					}
				}
			}
			// must be an illegal volume - probably a floppy
			else if (needFloppyWarn != NULL) {
				*needFloppyWarn = TRUE;
			}
		}
	}

	////////////////////////////////////////////////////////////////
	// no command line argument, or drive not found
	// so set current drive to first one in the list
	////////////////////////////////////////////////////////////////

	// Get the first item in the list
	lvi.iItem=0;
	ListView_GetItem(m_hwndListView, &lvi);

	// lparam is a pointer to the data struct
	// use it to set the CurrentDrive index
	pVolume = (CVolume *) lvi.lParam;
	m_pVolumeList->SetCurrentVolume(pVolume);

	// make that drive the selected drive
	ListView_SetItemState(m_hwndListView, lvi.iItem,
		LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:
    Address of Volume to find in list

RETURN:
	Index of item in list.
*/

int CESIListView::FindListViewItem(CVolume *pVolume)
{
	// Find the item and update the ListView
	// base the search on the address of the data structure
	// stored in the lParam field
	LV_FINDINFO lvfi;
	lvfi.flags = LVFI_PARAM;
	lvfi.lParam = (LPARAM) pVolume;

	return ListView_FindItem(m_hwndListView, /*start at beginnig=*/-1, &lvfi);
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	Sets the focus to the list view

GLOBAL VARIABLES:

INPUT:

RETURN:
*/

void CESIListView::SetFocus()
{
	::SetFocus( m_hwndListView );
}

/****************************************************************************************************************/

// ListViewCompareFunc - sorts the list view control. It is a comparison function. 
// Returns a negative value if the first item should precede the 
//     second item, a positive value if the first item should 
//     follow the second item, and zero if the items are equivalent. 
// lParam1 and lParam2 - pointers to the VOLUME_TEXT struct for that item (row)
// lParamSort - value specified by the LVM_SORTITEMS message 
//     (in this case, the index of the column to sort) 
static int CALLBACK ListViewCompareFunc( 
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort) 
{ 
    LPTSTR lpString1 = NULL, lpString2 = NULL;
	LONGLONG number1, number2;
    int iResult = 1;
	BOOL isNumber = FALSE;

    CVolume *pVol1 = (CVolume *)lParam1;
    CVolume *pVol2 = (CVolume *)lParam2;

    if (pVol1 && pVol2)
    {
        switch (lParamSort)
        {
            case 0:
				if (pVol1->Drive())
	                number1 = pVol1->Drive();
				else
					number1 = (pVol1->VolumeLabel())[0];

				if (pVol2->Drive())
	                number2 = pVol2->Drive();
				else
					number2 = (pVol2->VolumeLabel())[0];

				isNumber = TRUE;
                break;             

            case 1:
                lpString1 = pVol1->sDefragState();
                lpString2 = pVol2->sDefragState();
				isNumber = FALSE;
                break;

            case 2:
                lpString1 = pVol1->FileSystem();
                lpString2 = pVol2->FileSystem();
				isNumber = FALSE;
                break;

            case 3:
                number1 = pVol1->Capacity();
                number2 = pVol2->Capacity();
				isNumber = TRUE;
                break;

            case 4:
                number1 = pVol1->FreeSpace();
                number2 = pVol2->FreeSpace();
				isNumber = TRUE;
                break;

            case 5:
                number1 = (LONGLONG) pVol1->FreeSpacePercent();
                number2 = (LONGLONG) pVol2->FreeSpacePercent();
				isNumber = TRUE;
                break;

            default:
	            Message(TEXT("ListViewCompareFunc: Unrecognized column number"), E_FAIL, 0);
                break;
        }

		if (isNumber){
			if (number1 < number2)
				iResult = -1;
			else if (number1 > number2)
				iResult = 1;
			else
				iResult = 0;
		}
		else{
			iResult = lstrcmpi(lpString1, lpString2);
		}

        //Now, if the strings are equal, compare the cDisplayLabel fields
        if (!iResult)
           iResult = lstrcmpi(pVol1->DisplayLabel(), pVol2->DisplayLabel());

		if (isDescending)
			iResult = -iResult;
    }

    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\logfile.cpp ===
/**************************************************************************************************

FILENAME: LogFile.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"
#include <windows.h>

#define THIS_MODULE 'L'
#include "LogFile.h"
#include "stdio.h"

#define g_szInitialHeader "\r\n------------------------ New Log ---------------------\r\n"

static HANDLE hLog = NULL;
#include "secattr.h"

/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBALS:

INPUT:

RETURN:
    TRUE - Success
    FALSE - Failure (indicates that the error log could not be created)

*/
BOOL
InitializeLogFile(
    IN TCHAR* pLogName
    )
{
    DWORD dwBytes = 0;
    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;

    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
 
    if (!pLogName) {
        return FALSE;
    }
    
    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = FALSE;

    if (!ConstructSecurityAttributes(&saSecurityAttributes, esatFile, FALSE)) {
        return FALSE;
    }


    // Make sure that we can Create/Open the Log file
    hLog = CreateFile(
        pLogName, 
        GENERIC_READ|GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        &saSecurityAttributes,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    CleanupSecurityAttributes(&saSecurityAttributes);
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
    
    if (hLog == INVALID_HANDLE_VALUE){
        hLog = NULL;
        return FALSE;
    }

    //
    // Add our error string
    //
    WriteFile(hLog,
        g_szInitialHeader,
        (strlen(g_szInitialHeader) * sizeof(char)),
        &dwBytes,
        NULL
        );


    return TRUE;
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBALS:

INPUT:
    None

RETURN:
    None

*/
void
ExitLogFile(
    )
{
    if(hLog){
//       CloseHandle(hLog);
        hLog = NULL;
    }

    return;
}

BOOL
IsLoggingAvailable()
{
    return (hLog ? TRUE : FALSE);
}


//
// Logs the message to the Defrag log file.  
//
VOID
LogMessage(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN CONST PCSTR Message
    )
{
    LARGE_INTEGER Counter;
    DWORD dwBytes = 0;
    char buffer[4196];

    if (hLog) {
        if (!QueryPerformanceCounter(&Counter)) {
            Counter.QuadPart = 0;
        }
        sprintf(buffer, "[%I64d:%d%c%04lu] %s\r\n",
            Counter.QuadPart, MesgLevel, Module, Line, Message);

        //
        // Move to the end of file
        //
        SetFilePointer(hLog, 0L, NULL, FILE_END);

        //
        // Add our error string
        //
        WriteFile(hLog,
            buffer,
            (strlen(buffer) * sizeof(char)),
            &dwBytes,
            NULL
            );

//        DbgPrintEx(DPFLTR_SETUP_ID, MesgLevel, buffer);
        OutputDebugStringA(buffer);

    }
}

BOOL
DebugMessage(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN PCSTR FormatString,
    ...)
/*++
Description:
    This prints a debug message AND makes the appropriate entries in
    the log and error files.

Arguments:
    Line            pass in __LINE__
    MesgLevel       DPFLTR_ levels
    FormatString    Formatted Message String to be printed.

Returns:

--*/
{
    char str[4096];     // the message better fit in this
    va_list arglist;

    if (hLog) {
        va_start(arglist, FormatString);
        wvsprintfA(str, FormatString, arglist);
        va_end(arglist);

        LogMessage(Module, Line, MesgLevel, str);
    }
    return TRUE;
}



/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:
    IN LPTSTR pMessage - message string.

RETURN:
    TRUE if success, otherwise false

*/
BOOL
WriteStringToLogFileFunction(
    IN TCHAR* pMessage
    )
{
	//If the log isn't enabled, don't write to it.
	if(!hLog){
		return FALSE;
	}

    DWORD dwNumBytesWritten;
    char cString[1024];

#ifdef _UNICODE
	int numBytes = WideCharToMultiByte(CP_OEMCP,
			0,
			pMessage,
			-1,
			cString,
			sizeof(cString),
			NULL,
			NULL);

	if (numBytes == 0){
		strcpy(cString, "WideCharToMultiByte() failed in WriteStringToLogFile()\r\n");
		WriteFile(hLog, cString, strlen(cString), &dwNumBytesWritten, NULL);
	}

#else
	strcpy(cString, pMessage);
#endif

    // Write data out to file
	strcat(cString, "\r\n");

#ifdef DFRGNTFS
    Trace(log, cString);
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\ntfssubs.cpp ===
/*****************************************************************************************************************

FILENAME: NtfsSubs.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

    Contains routines for manipulating the NTFS filesystem.
*/

#include "stdafx.h"

extern "C"{
#include <stdio.h>
}

#ifdef BOOTIME
    #include "Offline.h"
#else
    #include <Windows.h>
#endif

//#include <winioctl.h>

extern "C" {
    #include "SysStruc.h"
}
#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"

#include "DasdRead.h"
#include "Devio.h"
#include "FsSubs.h"
#include "NtfsSubs.h"
#include "Alloc.h"
#include "IntFuncs.h"
#include "ErrMsg.h"
#include "Message.h"
#include "Logging.h"
#include "GetDfrgRes.h"
#include "vString.hpp"
#include "getreg.h"

#define THIS_MODULE 'T'
#include "logfile.h"

#ifdef OFFLINEDK
#include "OffNtfs.h"
#include "OffLog.h"
#endif

#define BOOT_OPTIMIZE_REGISTRY_PATH             TEXT("SOFTWARE\\Microsoft\\Dfrg\\BootOptimizeFunction")
#define BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION TEXT("LcnStartLocation")
#define BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION   TEXT("LcnEndLocation")

//Whew!  I love this code.  Take good care of it for me.        Zack :-)

/***************************************************************************************************************

FORMAT OF NTFS FILE RECORDS:

    An NTFS file is referenced by an entry in the MFT (Master File Table) called a filerecord
    (or FileRecordSegment) which is a header and a variable number of structures called Attributes.
    For each file there is a Base filerecord (refered to as THE filerecord) and may be one or more
    secondary filerecords. The attributes come in different types such as $FILE_NAME, $DATA, etc.
    
    The structure of filerecord attributes contains a FormCode field which indicates RESIDENT_FORM or
    NONRESIDENT_FORM. If the attribute is RESIDENT_FORM then the attribute's information is contained
    within the attribute. If the attribute is NONRESIDENT_FORM then the attribute contains a list of
    extent data (called MappingPairs) which describe a set of clusters on the volume that contain the
    attribute's information.

    There are four file types: Small, Large, Huge and Mega. These types refer to levels of fragmentation,
    not file size. These classifications refer to the complexity in accessing the file's data.
    A contiguous file of enormous size only requires location of the file's first cluster and total
    clusters in the file to access the file. A much smaller file that is heavily fragmented requires the
    same amount of information for each fragment. Once the level of fragmentation reaches the point that
    the methodology of the file's current type can no longer describe the file's data the file graduates
    to the next file type. Increasing the size of other attributes (thus reducing the amount of space
    available for the data information) can also cause a file to graduate to the next file type. Examples
    of increasing the size of other attributes are renaming the file with a longer filename or adding
    more security information.

    Mega File =             A non-resident $ATTRIBUTE_LIST attribute in the FRS contains a mapping pairs set
                    for the clusters that contain resident $ATTRIBUTE_LIST attributes
    Small files have a RESIDENT_FORM $DATA attribute containing the file's data.
    
    Large file's have a NONRESIDENT_FORM $DATA attribute containing MappingPairs that describe a set of
    clusters which contain the file's data.

    Huge files have a RESIDENT_FORM $ATTRIBUTE_LIST attribute which contains a list of secondary file
    records containing NONRESIDENT_FORM $DATA attributes.

    Mega files have a NONRESIDENT_FORM $ATTRIBUTE_LIST attribute containing MappingPairs that describe
    a set of clusters which contain RESIDENT_FORM $ATTRIBUTE_LIST attributes holding a list of secondary
    file records containing NONRESIDENT_FORM $DATA attributes.

    Once the MappingPairs in the NONRESIDENT_FORM $ATTRIBUTE_LIST attribute exceeds the capacity of the
    base filerecord the file system gives up.

    A file with a RESIDENT_FORM $DATA attribute is a Small type file.
    A file with a NONRESIDENT_FORM $DATA attribute is a Large type file.
    A file with a RESIDENT_FORM $ATTRIBUTE_LIST attribute is a Huge type file.
    A file with a NONRESIDENT_FORM $ATTRIBUTE_LIST attribute is a Mega type file.
    
    This routine locates all the MappingPairs for a file and converts them into an extent list.
    First the filerecord is scanned for a $STANDARD_INFORMATION attribute to determine if the file is
    compressed.
    Then the filerecord is scanned for an $ATTRIBUTE_LIST or $DATA attribute and looks at the FormCode
    of whichever attribute it finds to determine which file type the file is and calls the appropriate
    routine to build the extent list.
    Finally: It is possible for a single extent to be described with multiple MappingPairs making it
    appear to be more than one extent. Also, compressed files are compressed in blocks with a
    MappingPair describing each block which also makes it appear that the file has more extents than it
    actually does. CollapseExtentList consolidates adjacent extents and derives a true count of extents
    and fragments in the file. CollapseExtentList also calls GetLowestStartingLcn to determine the
    earliest cluster in the file for the purpose of processing the files on the disk in sequential order.
*/
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Build an extent list for a file.
    If TypeCode != 0 then the file's filerecord should already be in VolData.pFileRecord.
    If TypeCode = 0 then GetExtentList will load the filerecord.

INPUT + OUTPUT:
    IN TypeCode - which attribute in the file's filerecord to look in for the file's extent data.  See also description above.
    IN pFrs - The FRS for the file go get the extent list of.  Set to NULL if GetExtentList has to load the FRS from disk.

GLOBALS:
    IN OUT VolData.pFileRecord - The file record for the file.
    IN OUT VolData.FileRecordNumber - The file record number to use.

    OUT VolData.hExtentList         - HANDLE to buffer of EXTENT_LIST structure
    OUT VolData.pExtentList         - file's extent list
    OUT VolData.NumberOfExtents     - extents in the list
    OUT VolData.NumberOfFragments   - fragments in the file
    OUT VolData.NumberOfClusters    - clusters in the file
    OUT VolData.FileSize            - bytes in the file
    OUT VolData.bFragmented         - whether the file is contiguous or fragmented
    OUT VolData.bCompressed         - whether the file is compressed or not
    OUT VolData.bDirectory          - whether the file is a directoty or not
    OUT VolData.StartingLcn         - earliest cluster in the file

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
GetExtentList(
    DWORD dwEnabledStreams,
    FILE_RECORD_SEGMENT_HEADER* pFrs
    )
{
    ATTRIBUTE_RECORD_HEADER*    pArh = NULL;            //The specific attribute we're looking at now.
    ATTRIBUTE_LIST_ENTRY*       pAle = NULL;            //The attribute entry we're looking at now (only used for huge and mega files).
    ATTRIBUTE_LIST_ENTRY*       pAleStart = NULL;       //The start of the attribute list (only used for huge and mega files).
    HANDLE                      hAle = NULL;            //Handle to memory for attribute list if it was nonresident and had to be read off the disk.
    LONGLONG                    SaveFrn = 0;            //Used to compare the FRN before and after getting a new FRS to make sure we got the one we want.
    DWORD                       dwAttrListLength = 0;   //The length of the attribute list in a huge or mega file.
    EXTENT_LIST_DATA            ExtentData;
    UINT                        i;
    BOOL                        fRC;

    // Set up the Extent pointers structure to fill in the extent list in VolData.
    ZeroMemory(&ExtentData, sizeof(EXTENT_LIST_DATA));
    ExtentData.hExtents = VolData.hExtentList;
    ExtentData.pExtents = VolData.pExtentList;
    ExtentData.ExtentListAlloced = (DWORD)VolData.ExtentListAlloced;
    ExtentData.ExtentListSize = 0;
    ExtentData.dwEnabledStreams = dwEnabledStreams;
    ExtentData.BytesRead = 0;
    ExtentData.TotalClusters = 0;

    // Initialize the VolData fields.
    VolData.FileSize = 0;
    VolData.bFragmented = FALSE;
    VolData.bCompressed = FALSE;
    VolData.bDirectory = FALSE;
    VolData.bInBootExcludeZone = FALSE;
    VolData.bBootOptimiseFile = FALSE;
    VolData.NumberOfClusters = 0;
    VolData.NumberOfRealClusters = 0;
    VolData.NumberOfFragments = 0;

    // Get the FRS if it wasn't already loaded.
    if(!pFrs) {

        // Set the pFrs to point to a buffer to hold the FRS.
        pFrs = (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord;    //A shortcut to reduce code + cycles when accessing the frs.
        
        // Save the FRN so we know if we get the wrong FRS later.   
        SaveFrn = VolData.FileRecordNumber;

        //Read in the FRS for the attribute.
        // Get the next file record.
        EF(GetInUseFrs(VolData.hVolume, &VolData.FileRecordNumber, pFrs, (ULONG)VolData.BytesPerFRS));
        // Make sure we got the FRS we requested.
        EF_ASSERT(VolData.FileRecordNumber == SaveFrn);
    }

    // Detect if it is a directory and set the flag
    if (pFrs->Flags & FILE_FILE_NAME_INDEX_PRESENT) {
        VolData.bDirectory = TRUE;
    }
    else {
        VolData.bDirectory = FALSE;
    }

    // Find $STANDARD_INFORMATION attribute -- if there is none then don't use this FRS.
    if(!FindAttributeByType($STANDARD_INFORMATION, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)) {
        return FALSE;
    }
    
    // Note if the file is compressed or not.
    VolData.bCompressed = (((STANDARD_INFORMATION*)((UCHAR*)pArh+pArh->Form.Resident.ValueOffset))->FileAttributes
                           & FILE_ATTRIBUTE_COMPRESSED) ? TRUE : FALSE;

    // Initialize the FILE_EXTENT_HEADER structure.
    ExtentData.pFileExtentHeader = (FILE_EXTENT_HEADER*)ExtentData.pExtents;
    ExtentData.pFileExtentHeader->FileRecordNumber = VolData.FileRecordNumber;
    ExtentData.pFileExtentHeader->NumberOfStreams = 0;          //Contains the number of streams with extents.
    ExtentData.pFileExtentHeader->TotalNumberOfStreams = 0;     //Contains the total number of streams.
    ExtentData.pFileExtentHeader->ExcessExtents = 0;

    // Initialize the FILE_STREAM_HEADER structure.
    ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((char*)VolData.pExtentList
                                     + sizeof(FILE_EXTENT_HEADER));
    ExtentData.pStreamExtentHeader->StreamNumber = 0;
    ExtentData.pStreamExtentHeader->ExtentCount = 0;
    ExtentData.pStreamExtentHeader->ExcessExtents = 0;
    ExtentData.pStreamExtentHeader->AllocatedLength = 0;
    ExtentData.pStreamExtentHeader->FileSize = 0;

    __try {

        // Get non-data stream extents.
        EF(GetNonDataStreamExtents());

        // Look for an $ATTRIBUTE_LIST
        if(!FindAttributeByType($ATTRIBUTE_LIST, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)) {

            // If no $ATTRIBUTE_LIST was found, move to the first stream in the FRS.
            if(!FindStreamInFrs(pFrs, &pArh, &ExtentData)) {

                // If no stream was found, then there is no extent list for this file.
                VolData.TotalSmallDirs++;
                return TRUE;
            }

            do{
                // If this is a nonresident stream, then get its extents, and add it to the extent list.
                if(pArh->FormCode == NONRESIDENT_FORM) {

                    // Set the data in the stream header since we've found a stream;
                    ExtentData.pStreamExtentHeader->StreamNumber = ExtentData.pFileExtentHeader->TotalNumberOfStreams;
                    ExtentData.pStreamExtentHeader->ExtentCount = 0;
                    ExtentData.pStreamExtentHeader->ExcessExtents = 0;
                    ExtentData.pStreamExtentHeader->AllocatedLength = 0;
                    ExtentData.pStreamExtentHeader->FileSize = 0;

                    // Load the stream extents from the attributes in this FRS.
                    GetLargeStreamExtentList(pFrs, pArh, &ExtentData);

                    // Reset this variable for the next stream.
                    ExtentData.BytesRead = 0;

                    // Keep track of the number of streams with extent lists.
                    ExtentData.pFileExtentHeader->NumberOfStreams++;

                    // Bump up the file stream header pointer to the beginning of
                    // where the next stream will be if it's found.
                    ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pStreamExtentHeader
                                                      + sizeof(STREAM_EXTENT_HEADER)
                                                      + ExtentData.pStreamExtentHeader->ExtentCount
                                                      * sizeof(EXTENT_LIST));

                    // Check to see if the extent list is going to overrun with the
                    // addition of another stream header.
                    if(((UCHAR*)ExtentData.pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER))
                        > (ExtentData.pExtents + ExtentData.ExtentListAlloced)) {

                        UCHAR* pLastExtentList = ExtentData.pExtents;

                        // If so, realloc it larger, 64K at a time.
                        EF(AllocateMemory(ExtentData.ExtentListAlloced + 0x10000,
                                          &ExtentData.hExtents,
                                          (void**)&ExtentData.pExtents));

                        ExtentData.ExtentListAlloced += 0x10000;

                        // Reset the VolData fields which are dependent on pExtentList.
                        if(pLastExtentList != ExtentData.pExtents)  {
                            ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pStreamExtentHeader
                                                              - pLastExtentList
                                                              + ExtentData.pExtents);

                            ExtentData.pFileExtentHeader = (FILE_EXTENT_HEADER*)((UCHAR*)ExtentData.pFileExtentHeader
                                                            - pLastExtentList
                                                            + ExtentData.pExtents);
                        }
                    }
                }
                // Keep track of the fact the stream exists so they can be numbered correctly.
                ExtentData.pFileExtentHeader->TotalNumberOfStreams++;

            // Go to the next stream.
            }
            while(FindNextStreamInFrs(pFrs, &pArh, &ExtentData));
        }
        //If an $ATTRIBUTE_LIST was found
        else {

            // If the $ATTRIBUTE_LIST is nonresident get the entire
            // attribute list from the disk before proceeding.
            if(pArh->FormCode == NONRESIDENT_FORM) {

                // Load the attribute extents from the disk.
                LoadExtentDataToMem(pArh, &hAle, &dwAttrListLength);

                // Get a pointer to the allocated memory.
                EF_ASSERT(pAleStart = (ATTRIBUTE_LIST_ENTRY*)GlobalLock(hAle));

                VolData.NumberOfClusters = 0;
            }
            // If it was a resident attribute list, then the length of
            // the attribute list can be determined from the attribute.
            else {
                pAleStart = (ATTRIBUTE_LIST_ENTRY*)(pArh->Form.Resident.ValueOffset + (UCHAR*)pArh);
                dwAttrListLength = pArh->Form.Resident.ValueLength;
            }
            // Start at the beginning of the attribute list.
            pAle = pAleStart;

            // Move to the first stream.
            if(!FindStreamInAttrList(pAleStart, &pAle, dwAttrListLength, &ExtentData)) {
                // If no stream was found, then there is no extent list for this file.
                return TRUE;
            }
            do {
                // If this is a nonresident stream, then get it's extents, and add it to the extent list.
                if(AttributeFormCode(pAle, &ExtentData) == NONRESIDENT_FORM) {

                    // Set the data in the stream header since we've found a stream;
                    ExtentData.pStreamExtentHeader->StreamNumber = ExtentData.pFileExtentHeader->TotalNumberOfStreams;
                    ExtentData.pStreamExtentHeader->ExtentCount = 0;
                    ExtentData.pStreamExtentHeader->ExcessExtents = 0;
                    ExtentData.pStreamExtentHeader->AllocatedLength = 0;
                    ExtentData.pStreamExtentHeader->FileSize = 0;

                    // Load the stream extents from the attributes in the various FRS's.
                    GetHugeStreamExtentList(pAleStart, &pAle, dwAttrListLength, &ExtentData);

                    // Reset this variable for the next stream.
                    ExtentData.BytesRead = 0;

                    // Keep track of the number of streams with extent lists.
                    ExtentData.pFileExtentHeader->NumberOfStreams++;

                    // Bump up the file stream header pointer to the beginning of where
                    // the next stream will be if it's found.
                    ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER)
                                                     + ExtentData.pStreamExtentHeader->ExtentCount
                                                     * sizeof(EXTENT_LIST));

                    // Check to see if the extent list is going to overrun with the addition of another stream header.
                    if(((UCHAR*)ExtentData.pStreamExtentHeader+sizeof(STREAM_EXTENT_HEADER))
                        > (ExtentData.pExtents + ExtentData.ExtentListAlloced)) {

                        UCHAR* pLastExtentList = ExtentData.pExtents;

                        // If so, realloc it larger, 64K at a time.
                        EF(AllocateMemory(ExtentData.ExtentListAlloced + 0x10000,
                                          &ExtentData.hExtents,
                                          (void**)&ExtentData.pExtents));

                        ExtentData.ExtentListAlloced += 0x10000;

                        // Reset the VolData fields which are dependent on pExtentList.
                        if(pLastExtentList != ExtentData.pExtents) {

                            ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pStreamExtentHeader
                                                             - pLastExtentList
                                                             + ExtentData.pExtents);

                            ExtentData.pFileExtentHeader = (FILE_EXTENT_HEADER*)((UCHAR*)ExtentData.pFileExtentHeader
                                                            - pLastExtentList
                                                            + ExtentData.pExtents);
                        }
                    }
                }
                // Keep track of the fact the stream exists
                // so they can be numbered correctly.
                ExtentData.pFileExtentHeader->TotalNumberOfStreams++;

            // Find the next stream.
            }
            while(FindNextStreamInAttrList(pAleStart, &pAle, dwAttrListLength, &ExtentData));
        }
        // Reset the stream extent header to the first stream.
        ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pFileExtentHeader
                                         + sizeof(FILE_EXTENT_HEADER));

        // Loop through the streams to get a pointer to the end of the extent list.
        for(i=0; i<ExtentData.pFileExtentHeader->NumberOfStreams; i++) {

            // Set the stream extent header pointer to the next stream
            // (current position + header + # extents * sizeof each extent).
            ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pStreamExtentHeader
                                             + sizeof(STREAM_EXTENT_HEADER)
                                             + ExtentData.pStreamExtentHeader->ExtentCount
                                             * sizeof(EXTENT_LIST));
        }
        // Since pStreamExtentHeader now points to just after the last stream,
        // we can use it to determine the size of the extent list.
        ExtentData.ExtentListSize = (DWORD)((UCHAR*)ExtentData.pStreamExtentHeader
                                    - (UCHAR*)ExtentData.pFileExtentHeader);

        // Concatenate adjacent extents and keep track of the number of fragments.
        EF(CollapseExtentList(&ExtentData));
    }

    __finally {
        // Count the total number of excess extents for the file in all the streams.

        // First set the excess extents to zero.
        ExtentData.pFileExtentHeader->ExcessExtents = 0;

        // Reset the stream extent header to the first stream.
        ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pFileExtentHeader
                                         + sizeof(FILE_EXTENT_HEADER));
        
        // Loop through the streams counting excess extents.
        for(i=0; i<ExtentData.pFileExtentHeader->NumberOfStreams; i++) {

            // Add this stream's excess extents (those after the the first extent)
            // to the total excess extents count.
            ExtentData.pFileExtentHeader->ExcessExtents += ExtentData.pStreamExtentHeader->ExcessExtents;

            // Set the stream extent header pointer to the next stream
            // (current position + header + # extents * sizeof each extent).
            ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pStreamExtentHeader
                                             + sizeof(STREAM_EXTENT_HEADER)
                                             + ExtentData.pStreamExtentHeader->ExtentCount
                                             * sizeof(EXTENT_LIST));
        }
        // Since pStreamExtentHeader now points to just after the last stream,
        // we can use it to determine the size of the extent list.
        ExtentData.ExtentListSize = (DWORD)((UCHAR*)ExtentData.pStreamExtentHeader
                                    - (UCHAR*)ExtentData.pFileExtentHeader);

        // Now that we have the full extent list, put it back into VolData.
        VolData.hExtentList = ExtentData.hExtents;
        VolData.pExtentList = ExtentData.pExtents;
        VolData.ExtentListAlloced = ExtentData.ExtentListAlloced;

        // Free memory.
        if (hAle) {
            EH_ASSERT(GlobalUnlock(hAle) == FALSE);
            EH_ASSERT(GlobalFree(hAle) == NULL);
        }

        // Note how much memory is actually used by the extent list.

        // First get a pointer to the end.
        ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((char*)VolData.pExtentList
                                         + sizeof(FILE_EXTENT_HEADER));

        // As long as we've got a pointer to the first stream, get the file size
        // (which is the allocated length for this stream.) The file size is
        // considered to the the file size for only the first stream.
        VolData.FileSize = ExtentData.pStreamExtentHeader->FileSize;

        // Loop through the streams.
        fRC = TRUE;
        for(i=0; i<ExtentData.pFileExtentHeader->NumberOfStreams; i++) {

            // If we hit a stream with a header but no extents, ERROR.
            if (!(ExtentData.pStreamExtentHeader->ExtentCount)) {
                LOG_ERR();              
                fRC = FALSE;
                goto EndFinally;
            }                           

            // Set the stream extent header pointer to the next stream
            // (current position + header + # extents * sizeof each extent).
            ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)ExtentData.pStreamExtentHeader
                                             + sizeof(STREAM_EXTENT_HEADER)
                                             + ExtentData.pStreamExtentHeader->ExtentCount
                                             * sizeof(EXTENT_LIST));
        }
        // Now that pStreamExtentHeader points to just after the last stream,
        // we can use it's position to determine the size of the whole extent list.
        VolData.ExtentListSize = (UINT_PTR)ExtentData.pStreamExtentHeader - (UINT_PTR)ExtentData.pExtents;

        // Keep track of the number of clusters and real clusters in all streams of the file.
        VolData.NumberOfClusters = ExtentData.TotalClusters;
        VolData.NumberOfRealClusters = ExtentData.TotalRealClusters;

        // If there are any excess extents then this file is fragmented.
        if(ExtentData.pFileExtentHeader->ExcessExtents) {
            VolData.bFragmented = TRUE;
        }
EndFinally:;
    }
    return fRC;
}

//Loops through the attributes in an FRS looking for a valid stream.
//A valid stream is a $DATA or $INDEX_ALLOCATION attribute.  $BITMAP is also valid if pExtentData->dwEnabledStreams is TRUE;

BOOL
FindStreamInFrs(
    IN PFILE_RECORD_SEGMENT_HEADER  pFrs,
    OUT PATTRIBUTE_RECORD_HEADER*   ppArh,
    EXTENT_LIST_DATA* pExtentData
    )
{
    PATTRIBUTE_RECORD_HEADER pArh;
    
    //Check validitity of input parameters.
    EF_ASSERT(pFrs);
    EF_ASSERT(ppArh);

    //Initialize this to zero.
    *ppArh = 0;

    //Point to the first attribute in the FRS.
    pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + pFrs->FirstAttributeOffset);

    //Look for a $DATA, $INDEX_ALLOCATION, or $BITMAP attribute, as these are the valid stream types.
    //  Don't go beyond the end of the FRS.
    //  Look or $DATA, $INDEX_ALLOCATION, or $BITMAP.
    //  Another check to not go beyond the end of the valid data in the FRS.
    while(pArh < (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + VolData.BytesPerFRS) &&
          pArh->TypeCode != $DATA &&
          pArh->TypeCode != $INDEX_ALLOCATION &&
          (pExtentData->dwEnabledStreams ? pArh->TypeCode != $BITMAP : TRUE) &&
          pArh->TypeCode != $END){

        //That wasn't a valid attribute.  Go to the next.
        pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pArh + pArh->RecordLength);
    }

    //If no attribute was found, return FALSE since we didn't find a stream.
    if((pArh >= (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + VolData.BytesPerFRS)) 
        || (pArh->TypeCode != $DATA && 
            pArh->TypeCode != $INDEX_ALLOCATION && 
            (pExtentData->dwEnabledStreams ? pArh->TypeCode != $BITMAP : TRUE))
        ){
        return FALSE;
    }

    //If found, but not unnamed, report a corrupt disk.
    //The unnamed stream must always exist and must always precede the named streams,
    //hence we must find one if any streams are found since we proceed from the beginning of the FRS.
    //$INDEX_ALLOCATIONS may exist and may have any name (usually $I30 or $O).

    //Found an unnamed stream.  Success!
    *ppArh = pArh;

    return TRUE;
}

//Finds the next valid stream in an FRS.  This will continue the loop which FindStreamInFrs started until it finds another, or none.

BOOL
FindNextStreamInFrs(
    IN PFILE_RECORD_SEGMENT_HEADER  pFrs,
    OUT PATTRIBUTE_RECORD_HEADER*   ppArh,
    EXTENT_LIST_DATA* pExtentData
    )
{
    PATTRIBUTE_RECORD_HEADER pArh;
    BOOL bNewStreamFound = FALSE;
    
    //Check validitity of input parameters.
    EF_ASSERT(pFrs);
    EF_ASSERT(ppArh);
    EF_ASSERT(*ppArh);
    EF_ASSERT(pExtentData);

    //Set the pointer to the next attribute from the one currently pointed to.
    pArh = (ATTRIBUTE_RECORD_HEADER*)((char*)*ppArh + (*ppArh)->RecordLength);

    do{
        //Look for a $DATA, $INDEX_ALLOCATION or $BITMAP attribute after the last one found
        //  Don't go beyond the end of the FRS.
        //  Look or $DATA, $INDEX_ALLOCATION, or $BITMAP.
        //  Another check to not go beyond the end of the valid data in the FRS.
        while(pArh < (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + VolData.BytesPerFRS) &&
              pArh->TypeCode != $DATA &&
              pArh->TypeCode != $INDEX_ALLOCATION &&
              (pExtentData->dwEnabledStreams ? pArh->TypeCode != $BITMAP : TRUE) &&
              pArh->TypeCode != $END){

            //That wasn't a valid attribute.  Go to the next.
            pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pArh + pArh->RecordLength);
        }

        //If no attribute was found, return FALSE since we didn't find a stream.
        if((pArh >= (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + VolData.BytesPerFRS)) || (pArh->TypeCode != $DATA && pArh->TypeCode != $INDEX_ALLOCATION && (pExtentData->dwEnabledStreams ? pArh->TypeCode != $BITMAP : TRUE))){
            return FALSE;
        }

        //Check to see if this attribute is part of the last attribute's stream.
        //First compare TypeCodes.
        if(pArh->TypeCode == ((PATTRIBUTE_RECORD_HEADER)*ppArh)->TypeCode){
            //Then compare the streamnames.
            //  Check to see if both attribs are unnamed.
            //  Check to see if both attribs are named and the same name.
            if((pArh->NameLength == 0 && (*ppArh)->NameLength == 0) ||
                ((pArh->NameLength == (*ppArh)->NameLength) && !memcmp((UCHAR*)pArh+pArh->NameOffset, (UCHAR*)(*ppArh)+(*ppArh)->NameOffset, pArh->NameLength*sizeof(WCHAR)))){
                
                //The two stream names matched, so this attribute is part of the same stream as the previous attribute.  Keep looking for another attribute.
                continue;
            }
        }

        //Found an another stream.  Success!
        bNewStreamFound = TRUE;

    }while(!bNewStreamFound);

    //Return a pointer to the stream.
    *ppArh = pArh;

    return TRUE;
}

//Given an non-resident attribute, AddMappingPointersToStream will extract the mapping pointers, convert then to EXTENT_LISTs and
//append them to the extent list.

BOOL
AddMappingPointersToStream(
    IN PATTRIBUTE_RECORD_HEADER pArh,
    EXTENT_LIST_DATA* pExtentData
    )
{
    PUCHAR pMappingPairs = 0;
    LONGLONG ExtentLengthFieldSize = 0;
    LONGLONG ExtentOffsetFieldSize = 0;
    LONGLONG ExtentLength = 0;
    LONGLONG ExtentOffset = 0;
    LONGLONG ThisExtentStart = 0;
    LONGLONG BytesReadMax = 0;
    LONGLONG BytesRead = 0;
    LONGLONG LastExtentEnd = 0;
    EXTENT_LIST* pExtentList = NULL;
    ULONG Extent;

    //Make sure we have a stream header to add extents to.
    EF_ASSERT(pArh);
    EF_ASSERT(pExtentData->pStreamExtentHeader);

    //Make sure this is a non resident attribute.
    EF_ASSERT(pArh->FormCode == NONRESIDENT_FORM);

    //Get an extent list pointer that points to the current end of the stream.
    pExtentList = (EXTENT_LIST*)((UCHAR*)pExtentData->pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pExtentData->pStreamExtentHeader->ExtentCount * sizeof(EXTENT_LIST));

    //Note the end of the last extent so that future contiguous extents won't be counted as separate extents.
    //If there are no extents in this stream yet, then de facto there is not an end to the previous extent.
    if(pExtentData->pStreamExtentHeader->ExtentCount == 0){
        LastExtentEnd = 0xFFFFFFFFFFFFFFFF;
    }
    else{
        LastExtentEnd = pExtentList[-1].StartingLcn + pExtentList[-1].ClusterCount;
    }

    //0.0E00 Get a pointer to the mapping pairs in this attribute.
    pMappingPairs = (PUCHAR)pArh + pArh->Form.Nonresident.MappingPairsOffset;

    //Note how many bytes are allocated in the stream for data.
    //Sometimes an extent list will contain garbage pointers at the end beyond the last allocated cluster, so don't add these to the extent list.
    BytesReadMax = pExtentData->pStreamExtentHeader->AllocatedLength;

    //Note how many bytes have already been read from this stream.
    BytesRead = pExtentData->BytesRead;

    //Loop through each mapping pair in the attribute.  The last mapping pair is filled with zeros, if there are not enough extents to go to AllocatedLength.
    //      Initialize ThisExtentStart.
    //      Don't go beyond the number of bytes allocated to the stream and into invalid extent data.
    //      Don't go beyond the end of the record.
    //      Don't go past a zero extent which indicates an end of extent list -- sometimes.  (Sometimes it's determined by alloced size, or end of frs.)
    //      Go to the next extent.
    for(    ThisExtentStart=0, Extent=0;
            (BytesRead<BytesReadMax) &&
            (pMappingPairs < (PUCHAR)((char*)pArh + pArh->RecordLength)) &&
            (*pMappingPairs!=0);
            Extent ++){

        //Check to see if the extent list is going to overrun with the addition of another extent.
        if((UCHAR*)&pExtentList[Extent+1] > (pExtentData->pExtents + pExtentData->ExtentListAlloced)){
            UCHAR* pLastExtentList = pExtentData->pExtents;

            //If so, realloc it larger, 64K at a time.
            EF(AllocateMemory(pExtentData->ExtentListAlloced + 0x10000, &pExtentData->hExtents, (void**)&pExtentData->pExtents));
            pExtentData->ExtentListAlloced += 0x10000;

            //Reset the fields which are dependent on pExtents.
            if(pLastExtentList != pExtentData->pExtents){
                pExtentData->pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pExtentData->pStreamExtentHeader - pLastExtentList + pExtentData->pExtents);
                pExtentData->pFileExtentHeader = (FILE_EXTENT_HEADER*)((UCHAR*)pExtentData->pFileExtentHeader - pLastExtentList + pExtentData->pExtents);
                pExtentList = (EXTENT_LIST*)((UCHAR*)pExtentList - pLastExtentList + pExtentData->pExtents);
            }
        }

        //First, get the size of the field that stores the length of the run of clusters,
        //Then, get the size of the field that stores the length of the offset field.
        //0.1E00 The lower 4 bits hold a number from 0-15 that specifies how many bytes the length field is.
        ExtentLengthFieldSize = *pMappingPairs & 0x0F;
        //0.1E00 The upper bits of the UCHAR hold a number that specifies how many bytes the offset field is.
        ExtentOffsetFieldSize = *(pMappingPairs++) / 16;

        //0.1E00 Check for virtual extents.  (Extents indicating clusters not on disk because the file is compressed and doesn't need all the clusters on disk that it occupies in memory.)
        ExtentLength = (*(pMappingPairs + ExtentLengthFieldSize - 1) & 0x80) ? -1 : 0;

        EF_ASSERT(ExtentLengthFieldSize);

        //0.1E00 Get the length of this extent from the extent length field.
        CopyMemory(&ExtentLength, pMappingPairs, (DWORD)ExtentLengthFieldSize);
        pMappingPairs += ExtentLengthFieldSize;

        //0.1E00 If the offset field has a value -- i.e. it isn't a virtual extent, then copy it over.
        if(ExtentOffsetFieldSize != 0){
            
            //0.1E00 Check for virtual extents.
            ExtentOffset = (*(pMappingPairs + ExtentOffsetFieldSize - 1) & 0x80) ? -1 : 0;

            //0.1E00 Get the length of this extent from the extent length field.
            CopyMemory(&ExtentOffset, pMappingPairs, (DWORD)ExtentOffsetFieldSize);
            pMappingPairs += ExtentOffsetFieldSize;

            //0.1E00 Since the offset field holds an offset from the last extent, translate this into an absolute offset from the
            //beginning of the disk.  The first extent has an absolute offset, and each subsequent extent has a relative offset.
            ThisExtentStart += ExtentOffset;

            //0.0E00 If this extent is not adjacent to last extent, bump fragment count.
            //If this is the first extent the fragment count will not be incremented because LastExtentEnd = 0xFFFFFFFFFFFFFFFF.
            if((LastExtentEnd != 0xFFFFFFFFFFFFFFFF) && (ThisExtentStart != LastExtentEnd)){
                VolData.NumberOfFragments ++;
            }

            //0.1E00 Keep track of the last cluster of this extent so we can know if the next extent is adjacent or not.
            LastExtentEnd = ThisExtentStart + ExtentLength;

            //0.0E00 Update extent list
            pExtentList[Extent].StartingLcn = ThisExtentStart;
        
        }
        //0.1E00 If this was a virtual extent, then fill the starting lcn field with F's
        else{
        
            pExtentList[Extent].StartingLcn = 0xFFFFFFFFFFFFFFFF;
        }

        //0.1E00 Copy in the cluster count we calculated earlier.
        pExtentList[Extent].ClusterCount = ExtentLength;

        //Note that we added an extent to the stream.
        pExtentData->pStreamExtentHeader->ExtentCount++;

        //Keep track of the number of bytes we've read.
        pExtentData->BytesRead += ExtentLength*VolData.BytesPerCluster;

        //Keep track of the total number of clusters in the file.
        pExtentData->TotalClusters += ExtentLength;

        //Keep track of the total number of real clusters in the file.
        if(pExtentList[Extent].StartingLcn != 0xFFFFFFFFFFFFFFFF){
            pExtentData->TotalRealClusters += ExtentLength;
        }
    }

    return TRUE;
}

//Given the first attribute for a valid stream, GetLargeStreamExtentList will get the extent list for the stream.
//This will also include other attributes that immediately follow which are part of the same stream.

BOOL
GetLargeStreamExtentList(
    IN PFILE_RECORD_SEGMENT_HEADER pFrs,
    IN PATTRIBUTE_RECORD_HEADER pArh,
    EXTENT_LIST_DATA* pExtentData
    )
{
    PATTRIBUTE_RECORD_HEADER pPreviousArh = NULL;

    //check validity of input,
    EF_ASSERT(pFrs);
    EF_ASSERT(pArh);

    //Check the validity of the attribute passed in.
    EF_ASSERT(pArh->TypeCode == $DATA || pArh->TypeCode == $INDEX_ALLOCATION || (pExtentData->dwEnabledStreams ? pArh->TypeCode == $BITMAP : TRUE));

    //Note the number of bytes allocated to the stream so we don't overwrite it.
    pExtentData->pStreamExtentHeader->AllocatedLength = pArh->Form.Nonresident.AllocatedLength;

    //Note the file size for the stream for statistics for the user.
    pExtentData->pStreamExtentHeader->FileSize = pArh->Form.Nonresident.FileSize;

    while(TRUE){
        //Get the attribute's extent list.
        EF(AddMappingPointersToStream(pArh, pExtentData));

        //See if the next attribute is part of the same stream, and if so, count its extents too.

        //Remember which attribute this is.
        pPreviousArh = pArh;

        //Set the pointer to the next attribute from the one currently pointed to.
        pArh = (ATTRIBUTE_RECORD_HEADER*)((char*)pArh + pArh->RecordLength);

        //Look at the next attribute after the last one found and see if it is the same type.
        //  Don't go beyond the end of the FRS.
        //  Look for an attribute of the same type as the last.
        //  Another check to not go beyond the end of the valid data in the FRS.
        if(pArh < (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + VolData.BytesPerFRS) &&
              pArh->TypeCode == pPreviousArh->TypeCode &&
              pArh->TypeCode != $END){

            //We found another attribute of the same type.  Now compare the names to see if they're the same stream.

            //If both attributes have name lengths of zero they are both part of the unnamed stream.
            if(pArh->NameLength == 0 && pPreviousArh == 0){
                continue;
            }

            //If both attribs have the same name length, and the names match, they are part of the same named stream.
            if(pArh->NameLength == pPreviousArh->NameLength && !memcmp((char*)pArh+pArh->NameOffset, (char*)pPreviousArh+pPreviousArh->NameOffset, pArh->NameLength*sizeof(WCHAR))){
                continue;
            }
        }

        //The next attribute is not part of the same stream, so we're done.
        break;
    }

    return TRUE;
}

//Identical to FindStreamInFrs only it is fed an $ATTRIBUTE_LIST attribute instead of an FRS.

BOOL
FindStreamInAttrList(
    ATTRIBUTE_LIST_ENTRY* pAleStart,
    ATTRIBUTE_LIST_ENTRY** ppAle,
    LONGLONG ValueLength,
    EXTENT_LIST_DATA* pExtentData
    )
{
        UCHAR* pAleEnd = NULL;
    ATTRIBUTE_LIST_ENTRY* pAle = NULL;

    //Check validitity of input parameters.
    EF_ASSERT(pAleStart);
    EF_ASSERT(ppAle);
    EF_ASSERT(ValueLength);
    EF_ASSERT(pExtentData);

    //Initialize this to zero.
    *ppAle = 0;

    //Initialize this to the start of the attribute list.
    pAle = pAleStart;

    //Note the end of the attribute list.
    pAleEnd = (UCHAR*)pAleStart + ValueLength;

    //Look for a $DATA, $INDEX_ALLOCATION, or $BITMAP attribute, as these are the valid stream types.
    //  Don't go beyond the end of the attribute list.
    //  Look for $DATA, $INDEX_ALLOCATION or $BITMAP
    while((UCHAR*)pAle < pAleEnd &&
        pAle->AttributeTypeCode != $DATA &&
        pAle->AttributeTypeCode != $INDEX_ALLOCATION &&
        pAle->AttributeTypeCode != $UNUSED &&
        (pExtentData->dwEnabledStreams ? pAle->AttributeTypeCode != $BITMAP : TRUE)){

        if (pAle->RecordLength == 0) {
            // This better have a Record Length > 0; else we're going to loop
            // around indefinitely
            VolData.bMFTCorrupt = TRUE;
            return FALSE;
        }
        
        pAle = (ATTRIBUTE_LIST_ENTRY*)((UCHAR*)pAle + pAle->RecordLength);
    }

    //If no attribute was found, return FALSE since we didn't find a stream.
    if(((UCHAR*)pAle >= pAleEnd) || (pAle->AttributeTypeCode == $UNUSED)){
            return FALSE;
    }

    //If found, but not unnamed, report a corrupt disk.
    //The unnamed stream must always exist and must always precede the named streams,
    //hence we must find one if any streams are found since we proceed from the beginning of the FRS.
    //$INDEX_ALLOCATIONS may exist and may have any name (usually $I30 or $O).

    //Found an unnamed stream.  Success!
    *ppAle = pAle;

    return TRUE;
}

//Same as FindNextStreamInFrs only it is fed an $ATTRIBUTE_LIST attribute instead of an FRS.

BOOL
FindNextStreamInAttrList(
    ATTRIBUTE_LIST_ENTRY* pAleStart,
    ATTRIBUTE_LIST_ENTRY** ppAle,
    LONGLONG ValueLength,
    EXTENT_LIST_DATA* pExtentData
    )
{
    UCHAR* pAleEnd = NULL;
    ATTRIBUTE_LIST_ENTRY* pAle = NULL;
    BOOL bNewStreamFound = FALSE;

    //Check validitity of input parameters.
    EF_ASSERT(pAleStart);
    EF_ASSERT(ppAle);
    EF_ASSERT(*ppAle);
    EF_ASSERT(ValueLength);
    EF_ASSERT(pExtentData);

    //Initialize this to the attribute after this stream in the attribute list.
    pAle = (ATTRIBUTE_LIST_ENTRY*)((UCHAR*)(*ppAle) + (*ppAle)->RecordLength);

    //Note the end of the attribute list.
    pAleEnd = (UCHAR*)pAleStart + ValueLength;

    do{
        //Look for a $DATA, $INDEX_ALLOCATION, or $BITMAP attribute, as these are the valid stream types.
        //  Don't go beyond the end of the attribute list.
        //  Look or $DATA, $INDEX_ALLOCATION, or $BITMAP
        while((UCHAR*)pAle < pAleEnd &&
            pAle->AttributeTypeCode != $DATA &&
            pAle->AttributeTypeCode != $INDEX_ALLOCATION &&
            pAle->AttributeTypeCode != $UNUSED &&
            (pExtentData->dwEnabledStreams ? pAle->AttributeTypeCode != $BITMAP : TRUE)){

            pAle = (ATTRIBUTE_LIST_ENTRY*)((UCHAR*)pAle + pAle->RecordLength);
        }

        //If no attribute was found, return FALSE since we didn't find a stream.
        if(((UCHAR*)pAle >= pAleEnd) || (pAle->AttributeTypeCode == $UNUSED)){
            return FALSE;
        }

        //Check to see if this attribute is part of the last attribute's stream.
        //First compare TypeCodes.
        if(pAle->AttributeTypeCode == (*ppAle)->AttributeTypeCode){
            //Then compare the streamnames.
            //  Check to see if both attribs are unnamed.
            //  Check to see if both attribs are named and the same name.
            if((pAle->AttributeNameLength == 0 && (*ppAle)->AttributeNameLength == 0) ||
                ((pAle->AttributeNameLength == (*ppAle)->AttributeNameLength) && !memcmp((UCHAR*)pAle+pAle->AttributeNameOffset, (UCHAR*)(*ppAle)+(*ppAle)->AttributeNameOffset, pAle->AttributeNameLength*sizeof(WCHAR)))){
                
                //The two stream names matched, so this attribute is part of the same stream as the previous attribute.  Keep looking for another attribute.
                pAle = (ATTRIBUTE_LIST_ENTRY*)((UCHAR*)pAle + pAle->RecordLength);
                continue;
            }
        }

        //Found an another stream.  Success!
        bNewStreamFound = TRUE;

    }while(!bNewStreamFound);

    //Return a pointer to the stream.
    (*ppAle) = pAle;

    return TRUE;
}

//Will get the actual attribute out of an FRS when given the pointer to it from an $ATTRIBUTE_LIST.

ATTRIBUTE_RECORD_HEADER*
FindAttributeByInstanceNumber(
    HANDLE* phFrs,
    ATTRIBUTE_LIST_ENTRY* pAle,
    EXTENT_LIST_DATA* pExtentData
    )
{
    HANDLE hFrs = NULL;
    FILE_RECORD_SEGMENT_HEADER* pFrs = NULL;
    LONGLONG FileRecordNumber = 0;
    LONGLONG FileRecordNumberStore = 0;
    PATTRIBUTE_RECORD_HEADER pArh = NULL;

    EF_ASSERT(phFrs);
    EF_ASSERT(pAle);

#ifdef OFFLINEDK

    //0.0E00 Get a pointer to the MFT bitmap
    UCHAR* pMftBitmap = (UCHAR*) GlobalLock(VolData.hMftBitmap);
    if (pMftBitmap) {
        BOOL isLocked = GlobalUnlock(VolData.hMftBitmap);
        EH(!isLocked);
    }

#endif

    __try {

        // If a buffer for the FRS isn't already loaded, load it.
        if(!*phFrs){
            // Allocate a buffer to hold the file records, one at a time. (this locks the memory)
            if (!AllocateMemory((DWORD)(VolData.BytesPerFRS + VolData.BytesPerSector), phFrs, (void**)&pFrs)){
                EH(FALSE);
                __leave;
            }
        }
        else{
            // memory already exists, so lock it
            pFrs = (FILE_RECORD_SEGMENT_HEADER*) GlobalLock(*phFrs);
            if (!pFrs){
                EH_ASSERT(FALSE);
                __leave;
            }
        }

        //The file record number = the segment ref low part bitwise anded with the high part shifted left as many bits as the low part.
        FileRecordNumber = (pAle->SegmentReference.LowPart | (pAle->SegmentReference.HighPart << (sizeof(ULONG)*8)));
        FileRecordNumberStore = FileRecordNumber;

        //Read in the FRS for the attribute.
#ifdef OFFLINEDK
        //0.1E00 Get an FRS.
        if (!GetFrs(&FileRecordNumber, VolData.pMftExtentList, pMftBitmap, VolData.pMftBuffer, pFrs)){
            EH(FALSE);
            __leave;
        }
#else
        //0.1E00 Get the next file record. (does not lock the memory)
        if (!GetInUseFrs(VolData.hVolume, &FileRecordNumber, pFrs, (ULONG)VolData.BytesPerFRS)){
            EH(FALSE);
            __leave;
        }
#endif

        //Make sure we got the FRS we requested.
        if (FileRecordNumber != FileRecordNumberStore){
            EH_ASSERT(FALSE);
            __leave;
        }

        //Find the attribute indicated by the attribute list entry.

        //Set pArh to the first attribute in the FRS.
        pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + pFrs->FirstAttributeOffset);

        // Look for a $DATA, $INDEX_ALLOCATION, or $BITMAP attribute, as these are the valid stream types.
        // Don't go beyond the end of the FRS.
        // Check for a match of the instance numbers.
        // Another check to not go beyond the end of the valid data in the FRS.
        while(pArh < (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + VolData.BytesPerFRS) &&
            pArh->Instance != pAle->Instance &&
            pArh->TypeCode != $END){

            //That wasn't a the attribute.  Go to the next.
            pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pArh + pArh->RecordLength);
        }
        //If the attribute wasn't found, return NULL since we didn't find a stream.
        if((pArh >= (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + VolData.BytesPerFRS)) || (pArh->Instance != pAle->Instance) || (pArh->TypeCode == $END)){
            pArh = NULL;
            __leave;
        }
        //Error if the attribute doesn't match what was expected.
        if (pArh->TypeCode != pAle->AttributeTypeCode){
            EH_ASSERT(FALSE);
            __leave;
        }

        //Make sure the form code field is valid.
        if (pArh->FormCode != RESIDENT_FORM && pArh->FormCode != NONRESIDENT_FORM){
            EH_ASSERT(FALSE);
            __leave;
        }
    }

    __finally {
        // unlock the memory (it will be freed later)
        if(*phFrs){
            BOOL isLocked = GlobalUnlock(*phFrs);
            EH(!isLocked);
        }
    }

    //Return the attribute.
    return pArh;
}

//Given an ATTRIBUTE_LIST_ENTRY, will find out the form code of the attribute
//(which requires reading the actual attribute out of the FRS, since that data is not stored in the ATTRIBUTE_LIST_ENTRY.)

UCHAR
AttributeFormCode(
    ATTRIBUTE_LIST_ENTRY* pAle,
    EXTENT_LIST_DATA* pExtentData
    )
{
    HANDLE hFrs = NULL;
//  FILE_RECORD_SEGMENT_HEADER* pFrs = NULL;
    ATTRIBUTE_RECORD_HEADER* pArh = NULL;       //The specific attribute we're looking at now.
    UCHAR uFormCode = 0; // assumes an error condition

    EF_ASSERT(pAle);
    EF_ASSERT(pExtentData);

    __try {

        // Get the attribute.
        //EF(pArh = FindAttributeByInstanceNumber(&hFrs, pAle, pExtentData));
        pArh = FindAttributeByInstanceNumber(&hFrs, pAle, pExtentData);
        if (!pArh){
            EH(FALSE);
            __leave;
        }

        // Error if the attribute doesn't match what was expected.
        //EF_ASSERT(pArh->TypeCode == pAle->AttributeTypeCode);
        if (pArh->TypeCode != pAle->AttributeTypeCode){
            EH(FALSE);
            __leave;
        }

        // Make sure the form code field is valid.
        //EF_ASSERT(pArh->FormCode == RESIDENT_FORM || pArh->FormCode == NONRESIDENT_FORM);
        if (pArh->FormCode != RESIDENT_FORM && pArh->FormCode != NONRESIDENT_FORM){
            EH(FALSE);
            __leave;
        }

        // Return its FormCode field.
        uFormCode = pArh->FormCode;
    }

    __finally {
        if(hFrs){
            //  it is already unlocked EH_ASSERT(GlobalUnlock(hFrs) == FALSE);
            EH_ASSERT(GlobalFree(hFrs) == NULL);
        }
    }

    return uFormCode;
}

//Given an ATTRIBUTE_LIST_ENTRY, will find out the AllocatedLength of the attribute
//(which requires reading the actual attribute out of the FRS, since that data is not stored in the ATTRIBUTE_LIST_ENTRY.)

LONGLONG
AttributeAllocatedLength(
    ATTRIBUTE_LIST_ENTRY* pAle,
    EXTENT_LIST_DATA* pExtentData
    )
{
    HANDLE hFrs = NULL;
//  FILE_RECORD_SEGMENT_HEADER* pFrs = NULL;
    ATTRIBUTE_RECORD_HEADER* pArh = NULL;       //The specific attribute we're looking at now.
    LONGLONG lReturnValue = (LONGLONG) -1;

    EM_ASSERT(pAle);
    EM_ASSERT(pExtentData);

    __try {

        //Get the attribute.
        //EM(pArh = FindAttributeByInstanceNumber(&hFrs, pAle, pExtentData));
        pArh = FindAttributeByInstanceNumber(&hFrs, pAle, pExtentData);
        if (!pArh){
            EH(FALSE);
            __leave;
        }

        //Error if the attribute doesn't match what was expected.
        //EM_ASSERT(pArh->TypeCode == pAle->AttributeTypeCode);
        if (pArh->TypeCode != pAle->AttributeTypeCode){
            EH(FALSE);
            __leave;
        }

        //Make sure the form code field is valid.
        EM_ASSERT(pArh->FormCode == NONRESIDENT_FORM);
        if (pArh->FormCode != NONRESIDENT_FORM){
            EH(FALSE);
            __leave;
        }

        // Return its AllocatedLength field.
        lReturnValue = pArh->Form.Nonresident.AllocatedLength;
    }

    __finally {
        if(hFrs){
            // it is already unlocked EH_ASSERT(GlobalUnlock(hFrs) == FALSE);
            EH_ASSERT(GlobalFree(hFrs) == NULL);
        }
    }

    // Return its AllocatedLength field.
    return lReturnValue;
}

//Given an ATTRIBUTE_LIST_ENTRY, will find out the FileSize field in the attribute
//(which requires reading the actual attribute out of the FRS, since that data is not stored in the ATTRIBUTE_LIST_ENTRY.)

LONGLONG
AttributeFileSize(
    ATTRIBUTE_LIST_ENTRY* pAle,
    EXTENT_LIST_DATA* pExtentData
    )
{
    HANDLE hFrs = NULL;
//  FILE_RECORD_SEGMENT_HEADER* pFrs = NULL;
    ATTRIBUTE_RECORD_HEADER* pArh = NULL;       //The specific attribute we're looking at now.
    LONGLONG lReturnValue = -1;

    EM_ASSERT(pAle);
    EM_ASSERT(pExtentData);

    __try {

        //Get the attribute.
        //EM(pArh = FindAttributeByInstanceNumber(&hFrs, pAle, pExtentData));
        pArh = FindAttributeByInstanceNumber(&hFrs, pAle, pExtentData);
        if (!pArh){
            EH(FALSE);
            __leave;
        }

        //Error if the attribute doesn't match what was expected.
        //EM_ASSERT(pArh->TypeCode == pAle->AttributeTypeCode);
        if (pArh->TypeCode != pAle->AttributeTypeCode){
            EH(FALSE);
            __leave;
        }

        //Make sure the form code field is valid.
        //EM_ASSERT(pArh->FormCode == NONRESIDENT_FORM);
        if (pArh->FormCode != NONRESIDENT_FORM){
            EH(FALSE);
            __leave;
        }

        //Return its FileSize field.
        lReturnValue = pArh->Form.Nonresident.FileSize;
    }

    __finally {
        if(hFrs){
            // it is already unlocked EH_ASSERT(GlobalUnlock(hFrs) == FALSE);
            EH_ASSERT(GlobalFree(hFrs) == NULL);
        }
    }

    // Return its FileSize field.
    return lReturnValue;
}

//Given an ATTRIBUTE_LIST_ENTRY pointing to the primary attribute in a stream, GetHugeStreamExtentList will build the extent list
//by querying all attributes in all FRS's in order that are a part of the stream.

BOOL
GetHugeStreamExtentList(
    ATTRIBUTE_LIST_ENTRY* pAleStart,
    ATTRIBUTE_LIST_ENTRY** ppAle,
    LONGLONG ValueLength,
    EXTENT_LIST_DATA* pExtentData
    )
{
    UCHAR* pAleEnd = NULL;
    ATTRIBUTE_LIST_ENTRY* pAle = NULL;
    HANDLE hFrs = NULL;
    ATTRIBUTE_RECORD_HEADER* pArh = NULL;
    BOOL bReturnValue = FALSE;

    //Check validitity of input parameters.
    EF_ASSERT(pAleStart);
    EF_ASSERT(ppAle);
    EF_ASSERT(*ppAle);
    EF_ASSERT(ValueLength);
    EF_ASSERT(pExtentData);

    //Initialize this to the start of the stream in the attribute list.
    pAle = *ppAle;

    //Note the end of the attribute list.
    pAleEnd = (UCHAR*)pAleStart + ValueLength;

    //Get the type of this attribute and make sure it's a valid stream beginning.
    EF_ASSERT(pAle->AttributeTypeCode == $DATA || pAle->AttributeTypeCode == $INDEX_ALLOCATION || (pExtentData->dwEnabledStreams ? pAle->AttributeTypeCode == $BITMAP : TRUE));

    //Note the number of bytes allocated to the stream so we don't overwrite it.
    //EF((pExtentData->pStreamExtentHeader->AllocatedLength = AttributeAllocatedLength(pAle, pExtentData)) != -1);
    pExtentData->pStreamExtentHeader->AllocatedLength = AttributeAllocatedLength(pAle, pExtentData);
    EF(pExtentData->pStreamExtentHeader->AllocatedLength != -1);

    //Note the file size for user statistics.
    //EF((pExtentData->pStreamExtentHeader->FileSize = AttributeFileSize(pAle, pExtentData)) != -1);
    pExtentData->pStreamExtentHeader->FileSize = AttributeFileSize(pAle, pExtentData);
    EF(pExtentData->pStreamExtentHeader->FileSize != -1);

    __try {

        //Go through the attribute list and the extents from all the attributes that belong to this stream in order.
        do{
            //Look for a $DATA, $INDEX_ALLOCATION, or $BITMAP attribute, as these are the valid stream types.
            //  Don't go beyond the end of the attribute list.
            //  Look or $DATA, $INDEX_ALLOCATION, or $BITMAP
            while((UCHAR*)pAle < pAleEnd &&
                pAle->AttributeTypeCode != $DATA &&
                pAle->AttributeTypeCode != $INDEX_ALLOCATION &&
                pAle->AttributeTypeCode != $UNUSED &&
                (pExtentData->dwEnabledStreams ? pAle->AttributeTypeCode != $BITMAP : TRUE)
                ){

                pAle = (ATTRIBUTE_LIST_ENTRY*)((UCHAR*)pAle + pAle->RecordLength);
            }

            //If no attribute was found, break out of the loop.
            if(((UCHAR*)pAle >= pAleEnd) || (pAle->AttributeTypeCode == $UNUSED)){
                break;
            }

            //Check to see if this attribute is part of the stream.
            //First compare TypeCodes.
            if(pAle->AttributeTypeCode == (*ppAle)->AttributeTypeCode){
                //Then compare the streamnames.
                //Check to see if both attribs are unnamed.
                //Check to see if both attribs are named and the same name.
                if((pAle->AttributeNameLength == 0 && (*ppAle)->AttributeNameLength == 0) ||
                    (pAle->AttributeNameLength == (*ppAle)->AttributeNameLength && !memcmp((UCHAR*)pAle+pAle->AttributeNameOffset, (UCHAR*)(*ppAle)+(*ppAle)->AttributeNameOffset, pAle->AttributeNameLength*sizeof(WCHAR)))){
                    
                    //The two stream names matched, so this attribute is part of the same stream as the previous attribute.
                    //Get the attribute from its FRS.
                    //EF_ASSERT(pArh = FindAttributeByInstanceNumber(&hFrs, pAle, pExtentData));
                    pArh = FindAttributeByInstanceNumber(&hFrs, pAle, pExtentData);
                    if (!pArh){
                        EH_ASSERT(FALSE);
                        __leave;
                    }

                    //Add this FRS and attribute to the stream's attribute list.
                    //EF(AddMappingPointersToStream(pArh, pExtentData));
                    if (!AddMappingPointersToStream(pArh, pExtentData)){
                        EH(FALSE);
                        __leave;
                    }
                }
            }

            //Go to the next attribute.
            pAle = (ATTRIBUTE_LIST_ENTRY*)((UCHAR*)pAle + pAle->RecordLength);

        //Loop until no more attributes in the stream are found.
        } while(TRUE);

        //Success.
        bReturnValue = TRUE;
    }

    __finally {
        if(hFrs){
            // it is already unlocked EH_ASSERT(GlobalUnlock(hFrs) == FALSE);
            EH_ASSERT(GlobalFree(hFrs) == NULL);
        }
    }

    return bReturnValue;
}

//Given an non-resident attribute, LoadExtentDataToMem will get the extent list for the attribute, and read
//the extents themselves contiguously into memory.

BOOL
LoadExtentDataToMem(
    ATTRIBUTE_RECORD_HEADER* pArh,
    HANDLE* phAle,
    DWORD* pdwByteLen
    )
{
    DWORD i;
    LONGLONG NumClusters;
    EXTENT_LIST_DATA ExtentData;
    EXTENT_LIST* pExtents;
    UCHAR* pAle = NULL;
    BOOL bReturn = FALSE; // assume an error

    //Zero out our local ExtentData structure.
    ZeroMemory(&ExtentData, sizeof(EXTENT_LIST_DATA));

    //Make sure the inputs match.  Either hAle was already alloced, or it wasn't.
    EF_ASSERT((*phAle && *pdwByteLen) || (!*phAle && !*pdwByteLen));

    //Allocate some memory for the extent list.  64K should do the trick.
    ExtentData.ExtentListAlloced = 0x10000;
    EF(AllocateMemory(ExtentData.ExtentListAlloced, &ExtentData.hExtents, (void**)&ExtentData.pExtents));

    __try{
        //There will be no FILE_EXTENT_HEADER for this extent list since we're just getting a single set of extents which might be data or non-data. (Only need a stream header, either way.)
        ExtentData.pFileExtentHeader = NULL;

        //Initialize the FILE_STREAM_HEADER structure.
        ExtentData.pStreamExtentHeader = (STREAM_EXTENT_HEADER*)ExtentData.pExtents;
        ExtentData.pStreamExtentHeader->StreamNumber = 0;
        ExtentData.pStreamExtentHeader->ExtentCount = 0;
        ExtentData.pStreamExtentHeader->ExcessExtents = 0;
        ExtentData.pStreamExtentHeader->AllocatedLength = 0;
        ExtentData.pStreamExtentHeader->FileSize = 0;

        //Note the number of bytes allocated to the stream so we don't overwrite it.
        ExtentData.pStreamExtentHeader->AllocatedLength = pArh->Form.Nonresident.AllocatedLength;
        ExtentData.BytesRead = 0;

        //Note the file size for the stream for statistics data for the user.
        ExtentData.pStreamExtentHeader->FileSize = pArh->Form.Nonresident.FileSize;

        //This returns the size of the data.
        *pdwByteLen = (DWORD)ExtentData.pStreamExtentHeader->FileSize;

        //Get the extents of the non-res attribute to read to memory.
        if (!AddMappingPointersToStream(pArh, &ExtentData)){
            EH(FALSE);
            __leave;
        }

        //Get a pointer to the extents themselves.
        pExtents = (EXTENT_LIST*)((UCHAR*)ExtentData.pExtents + sizeof(STREAM_EXTENT_HEADER));

        //Count the number of clusters in all the extents so we know how much mem to alloc for the attribute list.
        for(i=0, NumClusters=0; i<ExtentData.pStreamExtentHeader->ExtentCount; i++){
            NumClusters += pExtents[i].ClusterCount;
        }

        //If there wasn't already memory allocated by the calling function, or if it was a different size, allocate/reallocate the memory to the correct size.
        if(*pdwByteLen != (DWORD)(NumClusters * VolData.BytesPerCluster)){
            //0.0E00 Allocate a buffer for the next extent
            if (!AllocateMemory((DWORD)((NumClusters * VolData.BytesPerCluster) + VolData.BytesPerSector),
                              phAle,
                              (void**)&pAle)){
                EH(FALSE);
                __leave;
            }
        }
        //bug #181935
        //added 8/22/2000 by Scott Sipe, fix that was added some time ago in Glendale
        //by John Joesph to fix the problem where pAle is NULL sometimes
        //If there still isn't an I/O buffer, allocate one the correct size.
        if(pAle == NULL){
            //0.0E00 Allocate a buffer for the next extent
            if (!AllocateMemory((DWORD)((NumClusters * VolData.BytesPerCluster) + VolData.BytesPerSector),
                              phAle,
                              (void**)&pAle)){
                EH(FALSE);
                __leave;
            }
        }

        //Read in each of those extents.
        for(i=0; i<ExtentData.pStreamExtentHeader->ExtentCount; i++){

                //0.0E00 Read the next extent
                if (!DasdReadClusters(VolData.hVolume,
                                    pExtents[i].StartingLcn,
                                    pExtents[i].ClusterCount,
                                    pAle,
                                    VolData.BytesPerSector,
                                    VolData.BytesPerCluster)){
                    EH(FALSE);
                    __leave;
                }

                //Make pAle point to the memory block to write the next extent.
                pAle += pExtents[i].ClusterCount * VolData.BytesPerCluster;
        }

        bReturn = TRUE; // everything is OK
    }

    __finally {

        //Unlock our pointer to the attribute list memory.
        if(*phAle){
            BOOL isLocked = GlobalUnlock(*phAle);
            EH(!isLocked);
        }

        //Free up our extent list.
        if(ExtentData.hExtents){
            EH_ASSERT(GlobalUnlock(ExtentData.hExtents) == FALSE);
            EH_ASSERT(GlobalFree(ExtentData.hExtents) == NULL);
            ExtentData.pExtents = NULL;
            ExtentData.hExtents = NULL;
        }
    }

    return bReturn;
}

//Given the name and type of a stream, GetStreamExtentsByNameAndType will track down the stream and build
//the extent list for it.

BOOL
GetStreamExtentsByNameAndType(
    TCHAR* StreamName,
    ATTRIBUTE_TYPE_CODE StreamType,
    FILE_RECORD_SEGMENT_HEADER* pFrs
    )
{
    ULONG StreamNumber = 0;
    FILE_EXTENT_HEADER* pFileExtentHeader;
    STREAM_EXTENT_HEADER* pStreamExtentHeader;
    EXTENT_LIST* pExtents;
    BOOL bExtentFound = FALSE;
    UINT i;

    //validate input not null
    EF_ASSERT(pFrs);

    //Validate the input criteria to make sure it could represent a valid stream.
    //($DATA, $INDEX_ALLOCATION, $ATTRIBUTE_LIST, $BITMAP).
    EF_ASSERT(StreamType == $DATA || $INDEX_ALLOCATION || $BITMAP);

    EF(GetStreamNumberFromNameAndType(&StreamNumber, StreamName, StreamType, pFrs));

    EF(GetExtentList(ALL_STREAMS, pFrs));

    //Pull out that number of stream.

    //First set the file extent header to the beginning of the extent list.
    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;

    //Set the stream extent header to point to the first stream.
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((char*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));

    //Make sure he's asking for a valid stream number for this file.  Error out if not.
    EF(StreamNumber < pFileExtentHeader->TotalNumberOfStreams);

    //Loop through each of the streams in the file.
    //Check against both NumberOfStreams and TotalNumberOfStreams to ensure we don't go beyond the end of the list.
    for(i=0; i<pFileExtentHeader->NumberOfStreams; i++){
        //If the stream number matches the one we're looking for, move the memory to the beginning of the extents list.
        if(StreamNumber == pStreamExtentHeader->StreamNumber){
            //Note that we found the stream and break;
            bExtentFound = TRUE;
            break;
        }

        //Set the pointer to the next stream header.
        pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST));

        //Check to make sure that we haven't gone beyond the stream number the user was asking for.
        if(pStreamExtentHeader->StreamNumber > StreamNumber){
            break;
        }
    }

    //If we didn't find the stream number the user was asking for, that means it doesn't have any extents.
    if(!bExtentFound){
        //Fill in a stream header for an empty stream for the return.
        pStreamExtentHeader = (STREAM_EXTENT_HEADER*)VolData.pExtentList;
        pStreamExtentHeader->StreamNumber = StreamNumber;
        pStreamExtentHeader->ExtentCount = 0;
    }
    //Otherwise a stream was found, so move it to the top of the extent list buffer for the return.
    else{
        //Move the stream extent header and it's extents to the beginning and overwrite the file extent header and anything else.
        MoveMemory(pFileExtentHeader, pStreamExtentHeader, UINT(sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST)));
    }

    //Note how much memory is actually used by the extent list.

    //First get a pointer to the end.
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)(char*)VolData.pExtentList;
    //If we hit a stream with a header but no extents, error.
    EF(pStreamExtentHeader->ExtentCount);
    //Set the stream extent header pointer to the next stream (current position + header + # extents * sizeof each extent).
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount * sizeof(EXTENT_LIST));
    //Now that pStreamExtentHeader points to just after the stream, we can use it's position to determine the size of the whole extent list.
    VolData.ExtentListSize = (UINT_PTR)pStreamExtentHeader - (UINT_PTR)pFileExtentHeader;

    //Count the number of clusters in the stream.
    VolData.NumberOfClusters = 0;
    VolData.NumberOfRealClusters = 0;
    //First get a pointer to the end.
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)(char*)VolData.pExtentList;
    pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));
    for(i=0; i<pStreamExtentHeader->ExtentCount; i++){
        //Count the number of virtual clusters in the file.
        VolData.NumberOfClusters += pExtents[i].ClusterCount;

        //Count the number of real clusters in the file.
        if(pExtents[i].StartingLcn != 0xFFFFFFFFFFFFFFFF){
            VolData.NumberOfRealClusters += pExtents[i].ClusterCount;
        }
    }

    //Get the file size for the stream.
    VolData.FileSize = pStreamExtentHeader->FileSize;

    //If there are any excess extents then this file is fragmented.
    if(pStreamExtentHeader->ExtentCount > 1){
        VolData.bFragmented = TRUE;
    }

    //Keep track of the number of extents in this stream.
    VolData.NumberOfFragments = pStreamExtentHeader->ExcessExtents + 1;

    return TRUE;
}

//Given the name and type of a stream, GetStreamNumberFromNameAndType finds which stream number corresponds.

BOOL
GetStreamNumberFromNameAndType(
    ULONG* pStreamNumber,
    TCHAR* StreamName,
    ATTRIBUTE_TYPE_CODE TypeCode,
    FILE_RECORD_SEGMENT_HEADER* pFrs
    )
{
    ATTRIBUTE_RECORD_HEADER*        pArh = NULL;                                                //The specific attribute we're looking at now.
    ATTRIBUTE_LIST_ENTRY*           pAle = NULL;                                                //The attribute entry we're looking at now (only used for huge and mega files).
    HANDLE                          hAle = NULL;                                                //Handle to memory for attribute list if it was nonresident and had to be read off the disk.
    LONGLONG                        SaveFrn = 0;                                                //Used to compare the FRN before and after getting a new FRS to make sure we got the one we want.
    DWORD                           dwAttrListLength = 0;                                       //The length of the attribute list in a huge or mega file.
    EXTENT_LIST_DATA                ExtentData;
    DWORD                           TotalNumberOfStreams;

    //Validate the input criteria to make sure it could represent a valid stream.
    //($DATA, $INDEX_ALLOCATION, $ATTRIBUTE_LIST, $BITMAP).
    EF_ASSERT(TypeCode == $DATA || $INDEX_ALLOCATION || $BITMAP);

    //Set up the Extent pointers structure to fill in the extent list in VolData.
    ZeroMemory(&ExtentData, sizeof(EXTENT_LIST_DATA));
    ExtentData.hExtents = VolData.hExtentList;
    ExtentData.pExtents = VolData.pExtentList;
    ExtentData.ExtentListAlloced = (ULONG)VolData.ExtentListAlloced;
    ExtentData.dwEnabledStreams = TRUE;     //Since the user is asking for the stream by name and type, it's valid to accept a request for a $BITMAP stream.

#ifdef OFFLINEDK
    //Do initializtion to get the FRS if it wasn't already loaded.
    if(!pFrs){
        UCHAR* pMftBitmap = NULL;
        FILE_RECORD_SEGMENT_HEADER* pFileRecord = (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord;

        //0.0E00 Get a pointer to the MFT bitmap since we will be reading from the disk directly rather than via a hook.
        EF((pMftBitmap = (UCHAR*)GlobalLock(VolData.hMftBitmap)) != NULL);
        if (pMftBitmap != NULL) {
            BOOL isLocked = GlobalUnlock(VolData.hMftBitmap);
            EH(!isLocked);
        }
    }
#endif

    //Initialize the VolData fields.
    VolData.FileSize = 0;
    VolData.bFragmented = FALSE;
    VolData.bCompressed = FALSE;
    VolData.bDirectory = FALSE;

    //Get the FRS if it wasn't already loaded.
    if(!pFrs){
        //Set the pFrs to point to a buffer to hold the FRS.
        pFrs = (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord;    //A shortcut to reduce code + cycles when accessing the frs.

        //Save the FRN so we know if we get the wrong FRS later.    
        SaveFrn = VolData.FileRecordNumber;

        //Read in the FRS for the attribute.
#ifdef OFFLINEDK
        //0.1E00 Get an FRS.
        EF(GetFrs(&VolData.FileRecordNumber, VolData.pMftExtentList, pMftBitmap, VolData.pMftBuffer, pFileRecord));
#else
        //0.1E00 Get the next file record.
        EF(GetInUseFrs(VolData.hVolume, &VolData.FileRecordNumber, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, (ULONG)VolData.BytesPerFRS));
#endif

        //Make sure we got the FRS we requested.
        EF_ASSERT(VolData.FileRecordNumber == SaveFrn);
    }

    //Detect if it is a directory and set flag
    if(pFrs->Flags & FILE_FILE_NAME_INDEX_PRESENT){
        VolData.bDirectory = TRUE;
    }
    else{
        VolData.bDirectory = FALSE;
    }

    //Find $STANDARD_INFORMATION attribute -- if there is none then don't use this FRS.
    if(!FindAttributeByType($STANDARD_INFORMATION, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)){
        return FALSE;
    }
    
    //Note if the file is compressed or not.
    VolData.bCompressed = (((PSTANDARD_INFORMATION)((UCHAR*)pArh+pArh->Form.Resident.ValueOffset))->FileAttributes & FILE_ATTRIBUTE_COMPRESSED) ? TRUE : FALSE;

    //Note that there were no streams found yet.
    TotalNumberOfStreams = 0;

    __try{

        //Look for an $ATTRIBUTE_LIST
        if(!FindAttributeByType($ATTRIBUTE_LIST, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)){
            //If no $ATTRIBUTE_LIST was found, move to the first stream in the FRS.
            if(!FindStreamInFrs(pFrs, &pArh, &ExtentData)){
                //If no stream was found, then there is no extent list for this file.
                return TRUE;
            }

            do{
                //Check for a match on the stream.
                //  If the type code matches and
                //  Either they are both nonamed or
                //  They are the same namelength, and the text in the names compare, then they are the stream we're looking for.
                if(pArh->TypeCode == TypeCode &&
                    ((!pArh->NameLength && !lstrlen(StreamName)) ||
                    ((pArh->NameLength == lstrlen(StreamName)) && !memcmp((UCHAR*)pArh+pArh->NameOffset, StreamName, lstrlenW(StreamName)*sizeof(WCHAR))))){

                    *pStreamNumber = TotalNumberOfStreams;
                    return TRUE;
                }

                //Keep track of the fact the stream exists so they can be numbered correctly.
                TotalNumberOfStreams++;

            //Go to the next stream.
            }while(FindNextStreamInFrs(pFrs, &pArh, &ExtentData));
        }
        //If an $ATTRIBUTE_LIST was found
        else{
            //If the $ATTRIBUTE_LIST is nonresident get the entire attribute list from the disk before proceeding.
            if(pArh->FormCode == NONRESIDENT_FORM){
                //Load the attribute extents from the disk.
                LoadExtentDataToMem(pArh, &hAle, &dwAttrListLength);

                //Get a pointer to the allocated memory.
                EF_ASSERT(pAle = (ATTRIBUTE_LIST_ENTRY*)GlobalLock(hAle));
            }
            //If it was a resident attribute list, then the length of the attribute list can be determined from the attribute.
            else{
                pAle = (ATTRIBUTE_LIST_ENTRY*)(pArh->Form.Resident.ValueOffset + (UCHAR*)pArh);
                dwAttrListLength = pArh->Form.Resident.ValueLength;
            }

            //Move to the first stream.
            if(!FindStreamInAttrList(pAle, &pAle, dwAttrListLength, &ExtentData)){
                //If no stream was found, then there is no extent list for this file.
                return TRUE;
            }

            do{
                //Check for a match on the stream.
                //  If the type code matches and
                //  Either they are both unnamed or
                //  They are the same namelength, and the text in the names compare, then they are the stream we're looking for.
                if(pAle->AttributeTypeCode == TypeCode &&
                    ((!pAle->AttributeNameLength && !lstrlen(StreamName)) ||
                    ((pAle->AttributeNameLength == lstrlen(StreamName)) && !memcmp((UCHAR*)pAle+pAle->AttributeNameOffset, StreamName, lstrlenW(StreamName)*sizeof(WCHAR))))){

                    *pStreamNumber = TotalNumberOfStreams;
                    return TRUE;
                }

                //Keep track of the fact the stream exists so they can be numbered correctly.
                TotalNumberOfStreams++;

            //Go to the next stream.
            }while(FindNextStreamInAttrList(pAle, &pAle, dwAttrListLength, &ExtentData));
        }

        //Invalid stream number because no stream was found.
        *pStreamNumber = 0xFFFFFFFF;
    }

    __finally{
        //If hAle was allocated, then it needs to be unlocked and freed.
        if(hAle){
            EH_ASSERT(GlobalUnlock(hAle) == FALSE);
            EH_ASSERT(GlobalFree(hAle) == NULL);
        }
    }

    return FALSE;
}

//Given the number of a stream, GetStreamNameAndTypeFromNumber finds what the stream's name and type are.

BOOL
GetStreamNameAndTypeFromNumber(
    ULONG StreamNumber,
    TCHAR* StreamName,
    ATTRIBUTE_TYPE_CODE* pTypeCode,
    FILE_RECORD_SEGMENT_HEADER* pFrs
    )
{
    ATTRIBUTE_RECORD_HEADER*        pArh = NULL;                                                //The specific attribute we're looking at now.
    ATTRIBUTE_LIST_ENTRY*           pAle = NULL;                                                //The attribute entry we're looking at now (only used for huge and mega files).
    HANDLE                          hAle = NULL;                                                //Handle to memory for attribute list if it was nonresident and had to be read off the disk.
    LONGLONG                        SaveFrn = 0;                                                //Used to compare the FRN before and after getting a new FRS to make sure we got the one we want.
    DWORD                           dwAttrListLength = 0;                                       //The length of the attribute list in a huge or mega file.
    EXTENT_LIST_DATA                ExtentData;
    DWORD                           TotalNumberOfStreams;

    //Validate the input criteria to make sure it could represent a valid stream.
    //($DATA, $INDEX_ALLOCATION, $ATTRIBUTE_LIST, $BITMAP).
    EF_ASSERT(*pTypeCode == $DATA || $INDEX_ALLOCATION || $BITMAP);

    //Set up the Extent pointers structure to fill in the extent list in VolData.
    ZeroMemory(&ExtentData, sizeof(EXTENT_LIST_DATA));
    ExtentData.hExtents = VolData.hExtentList;
    ExtentData.pExtents = VolData.pExtentList;
    ExtentData.ExtentListAlloced = (UINT)VolData.ExtentListAlloced;

#ifdef OFFLINEDK
    //Do initializtion to get the FRS if it wasn't already loaded.
    if(!pFrs){
        UCHAR* pMftBitmap = NULL;
        FILE_RECORD_SEGMENT_HEADER* pFileRecord = (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord;

        //0.0E00 Get a pointer to the MFT bitmap since we will be reading from the disk directly rather than via a hook.
        EF((pMftBitmap = (UCHAR*)GlobalLock(VolData.hMftBitmap)) != NULL);
        if (pMftBitmap != NULL) {
            BOOL isLocked = GlobalUnlock(VolData.hMftBitmap);
            EH(!isLocked);
        }
    }
#endif

    //Initialize the VolData fields.
    VolData.FileSize = 0;
    VolData.bFragmented = FALSE;
    VolData.bCompressed = FALSE;
    VolData.bDirectory = FALSE;

    //Get the FRS if it wasn't already loaded.
    if(!pFrs){
        //Set the pFrs to point to a buffer to hold the FRS.
        pFrs = (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord;    //A shortcut to reduce code + cycles when accessing the frs.

        //Save the FRN so we know if we get the wrong FRS later.    
        SaveFrn = VolData.FileRecordNumber;

        //Read in the FRS for the attribute.
#ifdef OFFLINEDK
        //0.1E00 Get an FRS.
        EF(GetFrs(&VolData.FileRecordNumber, VolData.pMftExtentList, pMftBitmap, VolData.pMftBuffer, pFileRecord));
#else
        //0.1E00 Get the next file record.
        EF(GetInUseFrs(VolData.hVolume, &VolData.FileRecordNumber, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, (ULONG)VolData.BytesPerFRS));
#endif

        //Make sure we got the FRS we requested.
        EF_ASSERT(VolData.FileRecordNumber == SaveFrn);
    }

    //Detect if it is a directory and set the flag
    if(pFrs->Flags & FILE_FILE_NAME_INDEX_PRESENT){
        VolData.bDirectory = TRUE;
    }
    else{
        VolData.bDirectory = FALSE;
    }

    //Find $STANDARD_INFORMATION attribute -- if there is none then don't use this FRS.
    if(!FindAttributeByType($STANDARD_INFORMATION, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)){
        return FALSE;
    }
    
    //Note if the file is compressed or not.
    VolData.bCompressed = (((PSTANDARD_INFORMATION)((UCHAR*)pArh+pArh->Form.Resident.ValueOffset))->FileAttributes & FILE_ATTRIBUTE_COMPRESSED) ? TRUE : FALSE;

    //Note that there were no streams found yet.
    TotalNumberOfStreams = 0;

    __try{

        //Look for an $ATTRIBUTE_LIST
        if(!FindAttributeByType($ATTRIBUTE_LIST, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)){
            //If no $ATTRIBUTE_LIST was found, move to the first stream in the FRS.
            if(!FindStreamInFrs(pFrs, &pArh, &ExtentData)){
                //If no stream was found, then there is no extent list for this file.
                return TRUE;
            }

            do{
                //Check for a match on the stream.
                if(StreamNumber == TotalNumberOfStreams){
                    *pTypeCode = pArh->TypeCode;
                    if(pArh->NameLength){
                        CopyMemory(StreamName, (UCHAR*)pArh+pArh->NameOffset, pArh->NameLength*sizeof(TCHAR));
                        StreamName[pArh->NameLength] = 0;
                    }
                    else{
                        StreamName[0] = 0;
                    }
                    return TRUE;
                }

                //Keep track of the fact the stream exists so they can be numbered correctly.
                TotalNumberOfStreams++;

            //Go to the next stream.
            }while(FindNextStreamInFrs(pFrs, &pArh, &ExtentData));
        }
        //If an $ATTRIBUTE_LIST was found
        else{
            //If the $ATTRIBUTE_LIST is nonresident get the entire attribute list from the disk before proceeding.
            if(pArh->FormCode == NONRESIDENT_FORM){
                //Load the attribute extents from the disk.
                LoadExtentDataToMem(pArh, &hAle, &dwAttrListLength);

                //Get a pointer to the allocated memory.
                EF_ASSERT(pAle = (ATTRIBUTE_LIST_ENTRY*)GlobalLock(hAle));
            }
            //If it was a resident attribute list, then the length of the attribute list can be determined from the attribute.
            else{
                pAle = (ATTRIBUTE_LIST_ENTRY*)(pArh->Form.Resident.ValueOffset + (UCHAR*)pArh);
                dwAttrListLength = pArh->Form.Resident.ValueLength;
            }

            //Move to the first stream.
            if(!FindStreamInAttrList(pAle, &pAle, dwAttrListLength, &ExtentData)){
                //If no stream was found, then there is no extent list for this file.
                return TRUE;
            }

            do{
                //Check for a match on the stream.
                if(StreamNumber == TotalNumberOfStreams){
                    *pTypeCode = pAle->AttributeTypeCode;
                    if(pAle->AttributeNameLength){
                        CopyMemory(StreamName, (UCHAR*)pAle+pAle->AttributeNameOffset, pAle->AttributeNameLength*sizeof(TCHAR));
                        StreamName[pAle->AttributeNameLength] = 0;
                    }
                    else{
                        StreamName[0] = 0;
                    }
                    return TRUE;
                }

                //Keep track of the fact the stream exists so they can be numbered correctly.
                TotalNumberOfStreams++;

            //Go to the next stream.
            }while(FindNextStreamInAttrList(pAle, &pAle, dwAttrListLength, &ExtentData));
        }

        //Invalid stream number because no stream was found.
        StreamNumber = 0xFFFFFFFF;
    }
    __finally {

        //If hAle was allocated, then it needs to be unlocked and freed.
        if(hAle){
            EH_ASSERT(GlobalUnlock(hAle) == FALSE);
            EH_ASSERT(GlobalFree(hAle) == NULL);
        }
    }
    return FALSE;
}

//Reads in the extents which are not part of the file's data.  (I.E. extents which are contained in non-resident
//ATTRIBUTE_LIST's or other non-resident attributes other than $DATA and $INDEX_ALLOCATION.)

//Note that this function operates nearly identical to GetExtentList only it is looking for any attribute other than
//$DATA and $INDEX_ALLOCATION.  The code can be copied and revised from GetExtentlist.
//Even cooler, see if you can integrate them into one.  I'm not sure that's reasonably possible because:

//The most major difference between GetNonDataStreamExtents and GetExtentList is that GetNonDataStreamExtents should
//concatenate extent lists from all non-data attributes.  Therefore, this function will create only one "stream" in the
//extent list.  The reason for this is so that Offline can simply defrag all the non-data stream stuff in one shibang.
//Online won't be defragging it and will be simply coloring it system space color, so having only one stream simplifies
//the process for both Offline and Online and DKMS.

BOOL
GetNonDataStreamExtents(
    )
{
//Look for an $ATTRIBUTE_LIST
//If not found
//Move to the first stream in the FRS.

    //If this attribute is not a $DATA or $INDEX_ALLOCATION and it is nonresident
        //Load the extents from the attribute.

    //Go to the next stream.

//If an $ATTRIBUTE_LIST was found
    //If the $ATTRIBUTE_LIST is resident
        //Move to the first stream.

        //If the attribute is not a $DATA or $INDEX_ALLOCATION
            //Load its FRS.
            //Go to the attribute.
            //If the attribute is nonresident
                //Load the extents from the attribute.

        //Find the next stream.

    //If the $ATTRIBUTE_LIST is non-resident
        //Load the attribute extents from the disk.

        //Move to the first stream.

        //If the attribute is not a $DATA or $INDEX_ALLOCATION
            //Load its FRS.
            //Go to the attribute.
            //If the attribute is nonresident
                //Load the extents from the attribute.

        //Find the next stream.

    return TRUE;
}

//A really quickie version of GetExtentList which only does enough work to identify whether the file has an extent list or not.
//This function is used only to identify how many entries to make in the file lists.

BOOL
IsNonresidentFile(
    DWORD dwEnabledStreams,
    FILE_RECORD_SEGMENT_HEADER* pFrs
    )
{
    EXTENT_LIST_DATA ExtentData;
    ATTRIBUTE_RECORD_HEADER*        pArh = NULL;                                                //The specific attribute we're looking at now.

    //bug occurred during stress. We do not test for NULL condition.
    if(pFrs == NULL)
    {
        return FALSE;
    }
    //Set up the Extent pointers structure to fill in the extent list in VolData.
    ZeroMemory(&ExtentData, sizeof(EXTENT_LIST_DATA));
    ExtentData.dwEnabledStreams = dwEnabledStreams;

    //Look for an $ATTRIBUTE_LIST
    if(!FindAttributeByType($ATTRIBUTE_LIST, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)){

        if (VolData.bMFTCorrupt) {
            return FALSE;
        }

        //If no $ATTRIBUTE_LIST was found, move to the first stream in the FRS.
        if(!FindStreamInFrs(pFrs, &pArh, &ExtentData)){
            //If no stream was found, then there is no extent list for this file -- therefore it is resident.
            return FALSE;
        }

        do{
            //If this is a nonresident stream, then this is a nonresident file.
            if(pArh->FormCode == NONRESIDENT_FORM){
                return TRUE;
            }

        //Go to the next stream.
        }while(FindNextStreamInFrs(pFrs, &pArh, &ExtentData));
    }
    else{
        //An attribute list was found, therefore, this is a nonresident file.
        return TRUE;
    }

    //No nonresident attributes were found.  Therefore this is a resident file.
    return FALSE;
}

//Here is an alternate algorithm for IsNonresidentFile which would be more efficient.  Check for robustness before implementing.
//      //0.0E00 Skip this filerecord if it has no attribute list or data attribute
//      if(!FindAttributeByType($ATTRIBUTE_LIST, pFileRecord, &pArh, (ULONG)VolData.BytesPerFRS)){
//
//          //0.0E00 If there are no $DATA or $INDEX_ALLOCATION attributes then this is a small file and has no extents.  Ignore it.
//          if((!FindAttributeByType($DATA, pFileRecord, &pArh, (ULONG)VolData.BytesPerFRS) &&
//              !FindAttributeByType($INDEX_ALLOCATION, pFileRecord, &pArh, (ULONG)VolData.BytesPerFRS))){
//              continue;
//          }
//
//          //0.0E00 Skip small files -- there's no defragmentation to do.
//          //That is, resident files, or nonresident files with no data on disk.
//          if(pArh->FormCode == RESIDENT_FORM || (pArh->FormCode == NONRESIDENT_FORM && pArh->Form.Nonresident.TotalAllocated == 0)){
//              continue;
//          }
//      }

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Directories can't really have their extent lists collapsed.  But, we would
    like to know if they need defragmenting, so the fragmentation state has to
    be verified or denied, so we know what to do later.  This was scavenged from
    CollapseExtents, which calls GetLowestStartingLcn; that routine does its
    thing based on the number of fragments, not the number of extents (??) so
    we can't use that, either.

    This routine is only used by OFFLINE.

INPUT + OUTPUT:
    None.

GLOBALS:
    OUT VolData.ExtentsState - Whether or not the file is contiguous or fragmented.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/
#ifdef OFFLINEDK

//This function needs to be rewritten to fit the new extents scheme.
//This is Offline code, aka. John's.

/*
BOOL
CheckFragged(
             )
{
    LONGLONG NumberOfExtents = VolData.NumberOfExtents;
    LONGLONG Extent = 0;
    EXTENT_LIST* pExtentList = VolData.pExtentList;
    LONGLONG MinCluster = 0;
    BOOL bSetMin =FALSE;
    LONGLONG LastRealExtent;


    //0.1E00 say it isn't fragmented to start with (innocent till proven guilty...)
    VolData.bFragmented = FALSE;
    VolData.NumberOfFragments = 1;

    //Don't bother looping if nothing to loop on...
    if(VolData.NumberOfExtents < 2){
        VolData.StartingLcn = pExtentList[0].StartingLcn;
        return TRUE;
    }

    //0.1E00 Go through each extent and see if it is really adjacent to the next
    for(Extent = 0; Extent < NumberOfExtents; Extent ++){

        //Ensure we skip virtual extents
        if (pExtentList[Extent].StartingLcn >= 0) {

            //ensure we get a valid minimum starting spot
            if (!bSetMin) {
                bSetMin = TRUE;
                MinCluster = pExtentList[Extent].StartingLcn;
                LastRealExtent = Extent;
                continue;
            }

            //1.0E00 If this Lcn is lower than whatever was lowest so far...
            if (pExtentList[Extent].StartingLcn < MinCluster) {

                //Record it so it can be returned
                MinCluster = pExtentList[Extent].StartingLcn;
            }

            //1.0E00 If this extent is adjacent to the last extent
            if(pExtentList[LastRealExtent].StartingLcn +
                pExtentList[LastRealExtent].ClusterCount !=
                pExtentList[Extent].StartingLcn){   

                //Okay, it's not contiguous...
                VolData.bFragmented = TRUE;
                VolData.NumberOfFragments++;

            }           //end "if not adjacent" test

            LastRealExtent = Extent;
        }               //end if Lcn >= 0

    }                   //end "for Extent" loop


    //0.1E00 Set the lowest Lcn of the file.  This is used in our algorithms to determine which files to move.
    VolData.StartingLcn = MinCluster;
    return TRUE;
}
*/
#endif
/*****************************************************************************************************************

FORMAT OF MAPPING PAIRS:

    The first byte contains the sizes of the mapping pair fields.  The low nibble contains the number of bytes
    in the extent length field, and the high nibble contains the number of bytes in the extent offset field.
    The next bytes are the extent length field, whose length is determined by the first byte.
    The next bytes are the extent offset field, whoese length is determined by the first byte.
    The extent offset field contains an offset in clusters from the previous extent, not an absolute value on the
    disk.  If this is the first extent, its offset is from zero.

    The list of mapping pairs is null terminated -- the first byte describing the length of the fields will
    contain a zero, and the extent length value will be zero.

    If the size of the extent offset field is zero (and the extent length is not) then this is a virtual extent:
        Virtual extents are used in compressed files; each block of a compressed file is represented by a
        physical extent and a virtual extent (if the block did not compress there is no virtual extent).
        The physical extent describes the clusters actually used on the disk by the block in it's compressed
        form; the virtual extent only indicates the difference between the uncompressed block size and the
        compressed block size.  ie: if the uncompressed block is 16 clusters and the block compresses down to
        8 clusters then the block will have 2 mapping pairs: the physical extent length will be 8, the virtual
        extent length will be 8, and the block will use 8 clusters of disk space.

/*****************************************************************************************************************/
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the basic statistics for an NTFS volume.

INPUT + OUTPUT:
    None.

GLOBALS:
        The VolData structure should be zeroed out with the exception of any fields already filled in before calling this function.

        IN VolData.cDrive - The drive letter for the volume we wish to access.
        
        OUT VolData.hVolume                             - Handle to the volume.
        OUT VolData.FileSystem                  - FS_NTFS.
        OUT VolData.MftStartLcn                 - First cluster of the MFT.
        OUT VolData.Mft2StartLcn                - First cluster of the MFT Mirror.
        OUT VolData.BytesPerSector              - Bytes Per Sector.
        OUT VolData.BytesPerCluster             - Bytes Per Cluster.
        OUT VolData.BytesPerFRS                 - Bytes Per FileRecord.
        OUT VolData.ClustersPerFRS              - Clusters Per FileRecord.
        OUT VolData.TotalSectors                - Total Sectors on the volume.
        OUT VolData.TotalClusters               - Total Clusters on the volume.
        OUT VolData.MftZoneStart                - Mft Zone Start.
        OUT VolData.MftZoneEnd                  - Mft Zone End.
        OUT VolData.FreeSpace                   - Free Space on the volume.
        OUT VolData.UsedSpace                   - Used Space on the volume.
        OUT VolData.UsedClusters                - Used Clusters on the volume.
        OUT VolData.SectorsPerCluster   - Sectors Per Cluster.
        OUT VolData.MftStartOffset              - Byte offset into the volume of the MFT.
        OUT VolData.TotalFileRecords    - Total FileRecords on the volume.
        OUT VolData.FileRecordNumber    - End of the MFT; where we start scanning filerecords.
        OUT VolData.CenterOfDisk                - Cluster at the center of the disk.
        OUT VolData.CenterOfBitmap              - Word at the Center Of the Bitmap.
        OUT VolData.CenterMask                  - Mask for the bit in the word at the Center Of the Bitmap.
        OUT VolData.CenterBit                   - Bit in the word at the Center Of the Bitmap.
        OUT VolData.BitmapSize                  - Bitmap Size.
        OUT VolData.hFile                               - INVALID_HANDLE_VALUE.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
GetNtfsVolumeStats(
    )
{
    //TCHAR cVolume[10];
    ULONG BytesReturned = 0;
    NTFS_VOLUME_DATA_BUFFER VolumeData = {0};

    //0.1E00 Fill in the handle values which aren't zero.
    VolData.hVolume = INVALID_HANDLE_VALUE;
    VolData.hFile = INVALID_HANDLE_VALUE;

    //0.1E00 Get the file system on this drive.
    EF(GetFileSystem(VolData.cVolumeName, &VolData.FileSystem, VolData.cVolumeLabel));

    //0.1E00 If this volume is not NTFS, error out.
    if(VolData.FileSystem != FS_NTFS){
        return FALSE;
    }

    //0.0E00 Get handle to volume
    VolData.hVolume = CreateFile(
        VolData.cVolumeName,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
        NULL);

    EF_ASSERT(VolData.hVolume != INVALID_HANDLE_VALUE);

    //0.0E00 Get the volume data
    EF(ESDeviceIoControl(VolData.hVolume,
                         FSCTL_GET_NTFS_VOLUME_DATA,
                         NULL,
                         0,
                         &VolumeData,
                         sizeof(VolumeData),
                         &BytesReturned,
                         NULL));

    //0.1E00 Copy over the values from the volume data that belong in the VolData as well.
    VolData.MftStartLcn             = VolumeData.MftStartLcn.QuadPart;                      //First cluster of the MFT.
    VolData.Mft2StartLcn            = VolumeData.Mft2StartLcn.QuadPart;                     //First Cluster of the MFT2.
    VolData.BytesPerSector          = VolumeData.BytesPerSector;                            //# of bytes per sector on the disk.
    VolData.BytesPerCluster         = VolumeData.BytesPerCluster;                           //# of bytes per cluster on the disk.
    VolData.BytesPerFRS             = VolumeData.BytesPerFileRecordSegment;                 //# of bytes in a file record in the MFT.
    VolData.ClustersPerFRS          = VolumeData.ClustersPerFileRecordSegment;              //# of clusters in a file record in the MFT.
    VolData.TotalSectors            = VolumeData.NumberSectors.QuadPart;                    //# of sectors on the disk.
    VolData.TotalClusters           = VolumeData.TotalClusters.QuadPart;                    //# of clusters on the disk.
    VolData.MftZoneStart            = VolumeData.MftZoneStart.QuadPart;                     //Cluster # the MFT Zone starts on.
    VolData.MftZoneEnd              = VolumeData.MftZoneEnd.QuadPart;                       //Cluster # the MFT Zone ends on.

    //0.1E00 Check for invalid values.
    EF(VolData.BytesPerSector != 0);
    EF(VolData.BytesPerFRS != 0);

    //It turns out that the MFTZone values can be outside the boundaries of the disk
    //this in turn causes the volume bitmap manipulators to fail with access vio's
    //so we will ensure that this cannot happen   JLJ 21Apr98 6June98
    if(VolData.MftZoneStart > VolData.TotalClusters-1){
        VolData.MftZoneStart = VolData.TotalClusters-1;
    }
    if(VolData.MftZoneEnd < VolData.MftZoneStart){
        VolData.MftZoneEnd = VolData.MftZoneStart;
    }
    if(VolData.MftZoneEnd > VolData.TotalClusters-1){
        VolData.MftZoneEnd = VolData.TotalClusters-1;
    }

    //0.1E00 Calulate a few values in VolData from the volume data.
    VolData.FreeSpace               = VolumeData.FreeClusters.QuadPart * VolData.BytesPerCluster;               //Number of free bytes on the drive.
    VolData.UsedSpace               = (VolData.TotalClusters * VolData.BytesPerCluster) - VolData.FreeSpace;    //Number of used bytes on the drive.
    VolData.UsedClusters            = VolData.TotalClusters - VolumeData.FreeClusters.QuadPart;                 //Number of used clusters on the disk.
    VolData.SectorsPerCluster       = VolData.BytesPerCluster / VolData.BytesPerSector;                         //Number of Sectors per cluster
    VolData.MftStartOffset          = VolData.MftStartLcn * VolData.BytesPerCluster;                            //How many bytes into the disk the MFT starts on.
    VolData.TotalFileRecords        = VolumeData.MftValidDataLength.QuadPart / VolData.BytesPerFRS;             //Total number of flie records in use.
    VolData.FileRecordNumber        = VolData.TotalFileRecords;                                                 //Start at the last file record on the disk.
    VolData.CenterOfDisk            = VolData.TotalClusters / 2;                                                //Find the center cluster on the disk.

    //0.0E00 Compute number of bits needed for bitmap, rounded up to the nearest 32-bit number.
    VolData.BitmapSize = (((VolData.TotalClusters /32) +
        ((VolData.TotalClusters  % 32) ? 1 : 0)) + 1) * 32;


    VolData.BootOptimizeBeginClusterExclude = 0;
    VolData.BootOptimizeEndClusterExclude = 0;

    if (IsBootVolume(VolData.cDrive)) {
        //get the registry value for BootOptimizeBeginClusterExclude
        HKEY hValue = NULL;
        DWORD dwRegValueSize = 0;
        long ret = 0;
        TCHAR cRegValue[100];


        // get Boot Optimize Begin Cluster Exclude from registry
        dwRegValueSize = sizeof(cRegValue);
        ret = GetRegValue(
            &hValue,
            BOOT_OPTIMIZE_REGISTRY_PATH,
            BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION,
            cRegValue,
            &dwRegValueSize);

        RegCloseKey(hValue);
        //check to see if the key exists, else exit from routine
        if (ret == ERROR_SUCCESS) {
            VolData.BootOptimizeBeginClusterExclude = _ttoi(cRegValue);
        }
        
        // get Boot Optimize End Cluster Exclude from registry
        hValue = NULL;
        dwRegValueSize = sizeof(cRegValue);
        ret = GetRegValue(
            &hValue,
            BOOT_OPTIMIZE_REGISTRY_PATH,
            BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION,
            cRegValue,
            &dwRegValueSize);

        RegCloseKey(hValue);
        //check to see if the key exists, else exit from routine
        if (ret == ERROR_SUCCESS) {
            VolData.BootOptimizeEndClusterExclude = _ttoi(cRegValue);
        }
    }
    
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the next file record that is in use..

INPUT + OUTPUT:
    IN hVolume              - The handle to the volume we're getting the FRS from.
    IN OUT pFileRecordNumber - What file record number is desired.  It's a pointer so we can write in what
                    file record number is actually obtained.
    OUT pFrs                - Where to write the file record after it is read.
    IN uBytesPerFRS - The number of bytes per FRS.

GLOBALS:
    None.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
GetInUseFrs(
    IN HANDLE                       hVolume,
    IN OUT LONGLONG*                pFileRecordNumber,
    OUT FILE_RECORD_SEGMENT_HEADER* pFrs,
    IN ULONG                        uBytesPerFRS
    )
{
    NTFS_FILE_RECORD_INPUT_BUFFER   NtfsFileRecordInputBuffer;
    PNTFS_FILE_RECORD_OUTPUT_BUFFER pNtfsFileRecordOutputBuffer;
    PUCHAR                          pFileRecord;
    ULONG                           BytesReturned = 0;

    require(hVolume);
    require(uBytesPerFRS);

    //0.1E00 Make a pointer to a global buffer for the file records.
    pNtfsFileRecordOutputBuffer = (PNTFS_FILE_RECORD_OUTPUT_BUFFER)&FileRecordOutputBuffer;

    //0.1E00 Get a pointer to the file record in it.
    pFileRecord = (PUCHAR)&pNtfsFileRecordOutputBuffer->FileRecordBuffer;

    //0.1E00 Set the number of the file record we wish to read.
    NtfsFileRecordInputBuffer.FileReferenceNumber.QuadPart = *pFileRecordNumber;

    //0.1E00 Set the number of bytes to read.
    pNtfsFileRecordOutputBuffer->FileRecordLength = (ULONG)uBytesPerFRS;

    //0.1E00 Do the read via our hooks in the OS.
    EF(ESDeviceIoControl(
            hVolume,
            FSCTL_GET_NTFS_FILE_RECORD,
            &NtfsFileRecordInputBuffer,
            sizeof(NtfsFileRecordInputBuffer),
            pNtfsFileRecordOutputBuffer,
            sizeof(FileRecordOutputBuffer),
            &BytesReturned,
            NULL));

    //0.1E00 Copy the memory out of the file record buffer.
    CopyMemory(pFrs, pFileRecord, (ULONG)uBytesPerFRS);

    //0.1E00 Copy out the file record number that was actually obtained.
    *pFileRecordNumber = (LONGLONG)pNtfsFileRecordOutputBuffer->FileReferenceNumber.QuadPart;

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine builds the full path for a file from its file record

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE = Success
    FALSE = Failure
*/
BOOL
GetNtfsFilePath(
    )
{
    TCHAR                           cName[MAX_PATH+1];
    LONGLONG                        SaveFileRecordNumber;
    LONGLONG                        ParentFileRecordNumber;
    HANDLE                          hFrs = NULL;
    FILE_RECORD_SEGMENT_HEADER*     pFrs = NULL;
    static LONGLONG                 LastPathFrs = 0;

#ifdef OFFLINEDK
    // todo max_path UCHAR* pMftBitmap = NULL;
    FILE_RECORD_SEGMENT_HEADER* pFileRecord = (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord;
#endif

    //0.0E00 Get file's name and file record number of its parent directory-
    EF(GetNameFromFileRecord((FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, cName, &ParentFileRecordNumber));
    if (VolData.bMFTCorrupt) {
        return FALSE;
    }

    //0.0E00 If this file is in the same dir as the last file was, use the last file's path
    if ((ParentFileRecordNumber == LastPathFrs) && (VolData.vFileName.GetLength() != 0)){
        //0.1E00 Find the last slash in the previous file name.
        TCHAR *pFileName = wcsrchr(VolData.vFileName.GetBuffer(), L'\\');

        //0.1E00 Error if no slash.
        EF_ASSERT(pFileName);

        // move past the backslash and put a NULL
        pFileName++;
        *pFileName = (TCHAR) NULL;

        // append the new file name
        VolData.vFileName += cName;

        //0.1E00 We have our path so return.
        return TRUE;
    }

    // Save the parent's FRS # in case we can
    // detect in the above if-block that we are in the same sub-directory
    LastPathFrs = ParentFileRecordNumber;
    
    //0.0E00 If this file's dir is the root, tack the drive letter to the beginning and return
    if(ParentFileRecordNumber == ROOT_FILE_NAME_INDEX_NUMBER){
        //0.1E00 Save our name.
        // start with the volume name (guid or UNC)
        VolData.vFileName = VolData.cVolumeName;

        //0.1E00 Reformat our name with the drive letter.
        // tack on the file name
        VolData.vFileName.AddChar(L'\\');

        // 
        // Append the file name.  Note that for the root directory, we don't 
        // want to append the filename ("."), since we won't be able to get 
        // a handle to the directory then.
        //
        if (VolData.FileRecordNumber != ROOT_FILE_NAME_INDEX_NUMBER) {
            VolData.vFileName += cName;
        }

        //0.1E00 We have our path so return.
        return TRUE;
    }

    // we need to rebuild the entire path, so start off with the file name
    VolData.vFileName = cName;

    //0.0E00 Allocate and lock a buffer for the parent directory's file record
    EF(AllocateMemory((DWORD)(VolData.BytesPerFRS + VolData.BytesPerSector), &hFrs, (void**)&pFrs));

    BOOL bReturnValue = FALSE; // assume an error


    VString tmpPath;

    //0.0E00 Loop while moving up the tree until we hit the root.
    while(ParentFileRecordNumber != ROOT_FILE_NAME_INDEX_NUMBER){

        //0.1E00 Save the parent's file record number.
        SaveFileRecordNumber = ParentFileRecordNumber;

#if OFFLINEDK
        //0.0E00 Get parent dir's File Record Segment
        if (!GetFrs(&ParentFileRecordNumber, VolData.pMftExtentList, pMftBitmap, VolData.pMftBuffer, pFrs)){
            EH(FALSE);
            //__leave;
            goto END;
        }
#else
        //0.0E00 Get parent dir's File Record Segment
        if (!GetInUseFrs(VolData.hVolume, &ParentFileRecordNumber, pFrs, (ULONG)VolData.BytesPerFRS)){
            EH(FALSE);
            //__leave;
            goto END;
        }
#endif

        //0.1E00 Error out if we didn't get the parent's File Record Segment
        if (ParentFileRecordNumber != SaveFileRecordNumber){
            EH_ASSERT(FALSE);
            //__leave;
            goto END;
        }

        //0.0E00 Get parent dir's name and its parent's file record number
        if (!GetNameFromFileRecord(pFrs, cName, &ParentFileRecordNumber)){

            if (VolData.bMFTCorrupt) {
                bReturnValue = FALSE;
            }
            
            EH(FALSE);
            //__leave;
            goto END;
        }

        //0.0E00 Append prior path to current dir name
        wcscat(cName, L"\\");
        // start off with the dir we just got
        tmpPath = cName;
        // add the existing path to create a complete path
        tmpPath += VolData.vFileName;
        // assign that back to the final resting place
        VolData.vFileName = tmpPath;
    }

    // pre-pend the volume name
    tmpPath = VolData.cVolumeName;
    tmpPath.AddChar(L'\\');
    tmpPath += VolData.vFileName;

    // assign that back to the final resting place
    VolData.vFileName = tmpPath;

    bReturnValue = TRUE;  // no errors

END:
    if(hFrs) {
        EH_ASSERT(GlobalUnlock(hFrs) == FALSE);
        EH_ASSERT(GlobalFree(hFrs) == NULL);
    }
        
    return bReturnValue;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.


ROUTINE DESCRIPTION:
    This routine gets the wide character NTFS long name from a file record, and returns it as a character string.
    This also returns it's parent file record number.

INPUT + OUTPUT:
    IN pFrs                                         - Pointer to buffer containing file's file record
    OUT pcName                                      - Pointer to character buffer to hold the name from this file record
    IN pParentFileRecordNumber      - pointer to file record number of parent dir

GLOBALS:
    IN VolData.BytesPerFRS          - The number of bytes in a file record segment.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
GetNameFromFileRecord(
                      IN FILE_RECORD_SEGMENT_HEADER* pFrs,
                      OUT TCHAR* pcName,
                      IN LONGLONG* pParentFileRecordNumber
                      )
{
    PATTRIBUTE_RECORD_HEADER pArh = NULL;
    PFILE_NAME pFileNameStruc = NULL;
    PFILE_NAME pLastFileNameStruc = NULL;
    PWCHAR pwName = NULL;
    int i;
    ATTRIBUTE_LIST_ENTRY*           pAle = NULL;            //The attribute entry we're looking at now (only used for huge and mega files).
    ATTRIBUTE_LIST_ENTRY*           pAleStart = NULL;       //The start of the attribute list (only used for huge and mega files).
    HANDLE                          hAle = NULL;            //Handle to memory for attribute list if it was nonresident and had to be read off the disk.
    LONGLONG                        SaveFrn = 0;            //Used to compare the FRN before and after getting a new FRS to make sure we got the one we want.
    DWORD                           dwAttrListLength = 0;   //The length of the attribute list in a huge or mega file.
    HANDLE                          hLocalFRS=NULL;
    FILE_RECORD_SEGMENT_HEADER*     pLocalFRS=NULL;
    FILE_RECORD_SEGMENT_HEADER*     pLocalFRSSave=NULL;
    LONGLONG                        llLocalFRN = 0;
    BOOL                            bReturnValue = FALSE;   // assume an error condition
    
    //1.0E00 The pointer to the current MFT record better not be NULL...
    EF_ASSERT(pFrs);
        
    __try {
        
        //1.1E00 Look for an $ATTRIBUTE_LIST first
        if(!FindAttributeByType($ATTRIBUTE_LIST, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)){
            
            //1.1E00 This paragraph handles the minimal case; this is where
            //both $FILE_NAME attributes are in the base MFT record
            
            //1.1E00 Find the filename attribute; error if it can't be found
            if (!FindAttributeByType($FILE_NAME, pFrs, &pArh, (ULONG)VolData.BytesPerFRS)){
                EH(FALSE);
                __leave;
            }
            
            //1.1E00 Find the NTFS long name attribute
            while(TRUE){
                
                //1.1E00 Get pointer to name structure in name attribute
                pFileNameStruc = (PFILE_NAME)((char*)pArh+pArh->Form.Resident.ValueOffset);
                
                //1.1E00 If this is the NTFS name attribute then we found it, so break
                //Only bits 1 and 2 have meaning in the Flags:
                // Neither bits set:    Long Name Only, use this one
                // Bit 0x01 only:       Long file name, but 8.3 is also available, keep looking and you'll find it
                // Bit 0x02 only:       8.3 name, but long file name is also available, keep looking
                // Both bits:           This is both the NTFS and 8.3 name (long name IS 8.3 format)
                if(pFileNameStruc->Flags & FILE_NAME_NTFS || pFileNameStruc->Flags == 0){
                    break;
                }

                //1.1E00 if we didn't get the NTFS filename, null the pointer
                //so we realize it at the end of the loop
                pFileNameStruc = NULL;
                
                //1.1E00 Update our pointer to the next attribute.
                pArh = (PATTRIBUTE_RECORD_HEADER)((char*)pArh + pArh->RecordLength);
                
                //1.1E00 find the next name attribute
                while(pArh < (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + (ULONG)VolData.BytesPerFRS) &&
                    pArh->TypeCode != $FILE_NAME &&
                    pArh->TypeCode != $END){
                    
                    //1.1E00 We did not find our attribute, so go to the next.
                    pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pArh + pArh->RecordLength);
                }
                
                //1.1E00 Error if attribute not found
                if(pArh->TypeCode != $FILE_NAME){
                    EH(FALSE);
                    __leave;
                }
            }           // end while (TRUE)
        }               // end if no $ATTRIBUTE_LIST found
        
        // 1.1E00 we come here if an $ATTRIBUTE_LIST was found
        // (resident or non-resident)
        else{
            
            //1.1E00 This (much longer) paragraph handles the case where
            //either $FILE_NAME attribute is not within the base MFT record.
            //Where it actually can be found depends on whether the
            //ATTRIBUTE_LIST attribute lists are resident (within the base
            //MFT record) or non-resident (within external randomly-allocated
            //clusters).
            
            //1.1E00 If the $ATTRIBUTE_LIST is nonresident get the entire
            //attribute list from the disk before proceeding.
            if(pArh->FormCode == NONRESIDENT_FORM){
                //1.1E00 Load the attribute extents from the disk (this allocate memory)
                LoadExtentDataToMem(pArh, &hAle, &dwAttrListLength);
                
                //1.1E00 Get a pointer to the allocated memory.
                pAleStart = (ATTRIBUTE_LIST_ENTRY *) GlobalLock(hAle);
                if (!pAleStart){
                    EH(FALSE);
                    __leave;
                }
            }
            //1.1E00 If it was a resident attribute list, then the length
            //of the attribute list can be determined from the attribute.
            else{
                pAleStart = (ATTRIBUTE_LIST_ENTRY*)(pArh->Form.Resident.ValueOffset + (UCHAR*)pArh);
                dwAttrListLength = pArh->Form.Resident.ValueLength;
            }
            
            //1.1E00 Start at the beginning of the attribute list.
            pAle = pAleStart;
            
            while(TRUE) {
                //1.1E00 find the next name attribute
                while(pAle < (ATTRIBUTE_LIST_ENTRY*)((PUCHAR)pAleStart + (ULONG)dwAttrListLength) &&
                    pAle->AttributeTypeCode != $FILE_NAME &&
                    pAle->AttributeTypeCode != $END){
                    
                    //1.1E00 We did not find our attribute, so go to the next.
                    pAle = (ATTRIBUTE_LIST_ENTRY*)((PUCHAR)pAle + pAle->RecordLength);
                }

                //The attribute list must end with a $END.
                if (pAle >= (ATTRIBUTE_LIST_ENTRY*)((PUCHAR)pAleStart + (ULONG)dwAttrListLength)) {
                    VolData.bMFTCorrupt = TRUE;
                    bReturnValue = FALSE;
                    __leave;
                }

                //1.1E00 Error if attribute not found
                if(pAle->AttributeTypeCode != $FILE_NAME){
                    __leave;
                }
                
                //1.1E00 grab the FRS# out of the attribute list
                llLocalFRN = (pAle->SegmentReference.LowPart | (pAle->SegmentReference.HighPart << (sizeof(ULONG)*8)));
                
                
                //1.1E00 if we make it this far, we'll need a buffer for
                //examining MFT records so, only get the buffer if we haven't
                //already gotten one
                if (hLocalFRS == NULL) {
                    //1.1E00 Allocate and lock a buffer for the file record
                    if (!AllocateMemory((DWORD)(VolData.BytesPerFRS + VolData.BytesPerSector),
                        &hLocalFRS, (void**)&pLocalFRS)){
                        EH(FALSE);
                        __leave;
                    }

                    //1.1E00 Save the pointer to we can ensure the right
                    //pointer is always passed to the MFT record get routine
                    pLocalFRSSave = pLocalFRS;
                }
                else {
                    //1.1E00  if we already got the buffer, refresh the pointer
                    pLocalFRS = pLocalFRSSave;
                }
                
#if OFFLINEDK
                //1.1E00 Get the filename's File Record Segment
                EF(GetFrs(&llLocalFRN, VolData.pMftExtentList, pMftBitmap, VolData.pMftBuffer, pLocalFrs));
#else
                //1.1E00 Get the filename's File Record Segment
                if (!GetInUseFrs(VolData.hVolume, &llLocalFRN, pLocalFRS, (ULONG)VolData.BytesPerFRS)){
                    EH(FALSE);
                    __leave;
                }
#endif
                //1.1E00 if we didn't get the NTFS filename, null the pointer
                //so we realize we didn't get it at the end of the loop
                pFileNameStruc = NULL;
                
                //1.1E00 Find the filename attribute; error if it can't be found
                if (!FindAttributeByType($FILE_NAME, pLocalFRS, &pArh, (ULONG)VolData.BytesPerFRS)) {                   
                    EH(FALSE);
                    __leave;
                }
                                
                //1.1E00 Find the NTFS long name attribute
                while(TRUE){
                    
                    //1.1E00 Get pointer to name structure in name attribute
                    pFileNameStruc = (PFILE_NAME)((char*)pArh+pArh->Form.Resident.ValueOffset);
                    
                    //1.1E00 If this is the NTFS name attribute then we found it, so break
                    //Only bits 1 and 2 have meaning in the Flags:
                    // Neither bits set:    Long Name Only, use this one
                    // Bit 0x01 only:       Long file name, but 8.3 is also available, keep looking and you'll find it
                    // Bit 0x02 only:       8.3 name, but long file name is also available, keep looking
                    // Both bits:           This is both the NTFS and 8.3 name (long name IS 8.3 format)
                    if(pFileNameStruc->Flags & FILE_NAME_NTFS || pFileNameStruc->Flags == 0){
                        break;
                    }
                    
                    //1.1E00 if we didn't get the NTFS filename, null the
                    //pointer so we realize it at the end of the loop
                    pFileNameStruc = NULL;
                    
                    //1.1E00 Update our pointer to the next attribute.
                    pArh = (PATTRIBUTE_RECORD_HEADER)((char*)pArh + pArh->RecordLength);
                    
                    //1.1E00 find the next name attribute
                    while(pArh < (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pLocalFRS + (ULONG)VolData.BytesPerFRS) &&
                        pArh->TypeCode != $FILE_NAME &&
                        pArh->TypeCode != $END){
                        
                        //1.1E00 We did not find our attribute, so go to the next.
                        pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pArh + pArh->RecordLength);
                    }
                    
                    //1.1E00 Error if attribute not found
                    if(pArh->TypeCode != $FILE_NAME){
                        break;
                    }
                }   // end while (TRUE)
                
                
                //1.1E00 break out of loop if we found a NTFS filename
                if (pFileNameStruc != NULL) {
                    break;
                }
                
                
                //1.1E00 We did not find our attribute, so go to the next.
                pAle = (ATTRIBUTE_LIST_ENTRY*)((PUCHAR)pAle + pAle->RecordLength);
                
            }   // end while (TRUE)
        }   // end else (if $ATTRIBUTE_LIST present)
        
        //1.1E00 This is the main point of this routine...we should never get
        //here with a NULL pointer to the FileName in the MFT record
        if (!pFileNameStruc){
            EH_ASSERT(FALSE);
            __leave;
        }
        
        //0.0E00 Get pointer to wide character name field
        pwName = (PWCHAR)&pFileNameStruc->FileName;
        
        //0.0E00 Copy the filename over.
        for(i=0; (i<pFileNameStruc->FileNameLength) && (i<MAX_PATH) && (*pwName!=TEXT('\\'));pcName[i++] = (TCHAR)*pwName++)
            ;

        //EF_ASSERT(*pwName!=TEXT('\\'));
        if (*pwName == TEXT('\\')){
            EH_ASSERT(FALSE);
            __leave;
        }

        //EF_ASSERT(i<MAX_PATH);
        if (i >= MAX_PATH){
            EH_ASSERT(FALSE);
            __leave;
        }

        //0.0E00 Null terminate the string
        pcName[i] = 0;
        
        //0.0E00 Return the parent's file record number
        *pParentFileRecordNumber = pFileNameStruc->ParentDirectory.LowPart + (pFileNameStruc->ParentDirectory.HighPart<<32);
        
        //0.0E00 Success!
        bReturnValue = TRUE;
    }

    //1.1E00  on exit, make sure we've released any memory fetched.
    __finally {
        
        if(pLocalFRS) {
            EH_ASSERT(GlobalUnlock(hLocalFRS) == FALSE);
            EH_ASSERT(GlobalFree(hLocalFRS) == NULL);
        }

        if(hAle) {
            EH_ASSERT(GlobalUnlock(hAle) == FALSE);
            EH_ASSERT(GlobalFree(hAle) == NULL);
        }
    }

    return bReturnValue;
}

BOOL
GetNextNtfsFile(
    IN CONST PRTL_GENERIC_TABLE pTable,
    IN CONST BOOLEAN Restart,
    IN CONST LONGLONG ClusterCount,
    IN CONST PFILE_LIST_ENTRY pEntry
    )
{
    LONGLONG fileRecordNumber = 0;
    PFILE_LIST_ENTRY pFileListEntry = NULL;
    BOOLEAN bNext = (Restart ? FALSE : TRUE),
        done = TRUE;

    static PVOID pRestartKey = NULL;    
    static ULONG ulDeleteCount = 0;
    static FILE_LIST_ENTRY entry;

    if (Restart) {
        if (pEntry) {
            CopyMemory(&entry, pEntry, sizeof(FILE_LIST_ENTRY));
        }
        else {
            pFileListEntry = (PFILE_LIST_ENTRY) RtlEnumerateGenericTableAvl(pTable, TRUE);

            if (pFileListEntry) {
                CopyMemory(&entry, pFileListEntry, sizeof(FILE_LIST_ENTRY));
            }
            else {
                ZeroMemory(&entry, sizeof(FILE_LIST_ENTRY));
            }
        }
        pRestartKey = NULL;
    }

    do {
        done = TRUE;
        //
        // Find the next entry in the table
        //
        do {

            pFileListEntry = (PFILE_LIST_ENTRY) RtlEnumerateGenericTableLikeADirectory(
                pTable, 
                NULL,
                NULL,
                bNext,
                &pRestartKey,
                &ulDeleteCount,
                &entry);
            bNext = TRUE;
        } while ((ClusterCount) && (pFileListEntry) && (pFileListEntry->ClusterCount >= ClusterCount));


        VolData.pFileListEntry = pFileListEntry;
        if (!pFileListEntry) {
            //
            // We're done with this enumeration
            //
            return FALSE;
        }
        
        //
        // Keep a copy of this entry around, in case it gets deleted and we need
        // to carry on with our enumeration.  (Usually, the enumeration will
        // continue on the basis of pRestartKey, but if that key is deleted, 
        // it continues based on this).
        //
        CopyMemory(&entry, pFileListEntry, sizeof(FILE_LIST_ENTRY));

        //1.0E00 Since a file was found in one of these lists, set the return values accordingly.
        VolData.LastStartingLcn = VolData.StartingLcn = pFileListEntry->StartingLcn;
        VolData.NumberOfClusters = pFileListEntry->ClusterCount;

        //Get the file record number of the file from the list.
        VolData.FileRecordNumber = pFileListEntry->FileRecordNumber;

        // Set the flags
        VolData.bDirectory = (pFileListEntry->Flags & FLE_DIRECTORY) ? TRUE : FALSE;
        VolData.bFragmented = (pFileListEntry->Flags & FLE_FRAGMENTED) ? TRUE : FALSE;
        VolData.bBootOptimiseFile = (pFileListEntry->Flags & FLE_BOOTOPTIMISE) ? TRUE : FALSE;

        //1.0E00 This is used to compare with the FileRecordNumber returned by GetInUseFrs below to see if a file was deleted.
        fileRecordNumber = VolData.FileRecordNumber;

        //Check to see if the file record number is out of range.
        if(fileRecordNumber > VolData.TotalFileRecords){
            Trace(log, "GetNextNtfsFile:  Invalid File Record Number: %x  (TotalFileRecords:%x)", 
                fileRecordNumber, VolData.FileRecordNumber);
            return FALSE;
        }
    
        EF(GetInUseFrs(VolData.hVolume, &VolData.FileRecordNumber, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, (ULONG)VolData.BytesPerFRS));
        
        //0.0E00 Check to see if the file has been deleted out from under us.
        if (VolData.FileRecordNumber != fileRecordNumber) {
            //If GetInUseFrs doesn't find the file record number, then it has been deleted.
            //Remove this file from our list
            RtlDeleteElementGenericTable(pTable,  pFileListEntry);
            done = FALSE;
        } 
    } while (!done);

    return TRUE;

}


BOOL
UpdateFileTables(
    IN OUT PRTL_GENERIC_TABLE pFragmentedTable,
    IN OUT PRTL_GENERIC_TABLE pContiguousTable
    )
{
    FILE_EXTENT_HEADER* pFileExtentHeader;
    
    PFREE_SPACE_ENTRY pFreeSpaceEntry = VolData.pFreeSpaceEntry;
    PFILE_LIST_ENTRY pFileListEntry = VolData.pFileListEntry;
    FILE_LIST_ENTRY NewEntry;
    PVOID p = NULL;
    BOOLEAN bNewElement = TRUE;

    //Update the information on this file.
    pFileListEntry->StartingLcn = pFreeSpaceEntry->StartingLcn;

    memcpy(&NewEntry, pFileListEntry, sizeof(FILE_LIST_ENTRY));
    NewEntry.Flags &= ~FLE_FRAGMENTED;

    // 1. Update the FreeSpaceEntry's count
    pFreeSpaceEntry->StartingLcn += VolData.NumberOfClusters;
    pFreeSpaceEntry->ClusterCount -= VolData.NumberOfClusters;

    // 2. Add this file to the contiguous-files table
    p = RtlInsertElementGenericTable(
        pContiguousTable,
        (PVOID) &NewEntry,
        sizeof(FILE_LIST_ENTRY),
        &bNewElement);

    if (!p) {
        // An allocation failed
        return FALSE;
    };

    // 3. Remove this file from the fragmented-files table
    bNewElement = RtlDeleteElementGenericTable(pFragmentedTable, pFileListEntry);
    if (!bNewElement) {
        assert(FALSE);
    }
    VolData.pFileListEntry = NULL;

    return TRUE;
}

BOOL
UpdateInFileList(
    )
{
    LONGLONG EarliestStartingLcn = 0xFFFFFFFFFFFFFFFF;
    FILE_EXTENT_HEADER* pFileExtentHeader;
    FILE_LIST_ENTRY* pFileListEntry;


    //Get a pointer to the entry.
    pFileListEntry = VolData.pFileListEntry;

    //Sanity check the file record number.  They should be the same.
    EF(pFileListEntry->FileRecordNumber == (UINT)VolData.FileRecordNumber);

    //Get a pointer to the file extent header.
    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;

    //Get the earliest starting lcn for the file which we'll use in our algorithms to determine which file to move next.
    EF(GetLowestStartingLcn(&EarliestStartingLcn, pFileExtentHeader));

    //Update the information on this file.
    pFileListEntry->StartingLcn = EarliestStartingLcn;
    pFileListEntry->ExcessExtentCount = (UINT)VolData.NumberOfFragments - pFileExtentHeader->NumberOfStreams;       //Only count *excess* extents since otherwise files with multiple streams would be "fragmented".

    //Set or clear the fragmented flag depending on whether the file is fragmented or not.
    if(VolData.bFragmented){
        //Set the fragmented flag.
        pFileListEntry->Flags |= FLE_FRAGMENTED;
    }
    else{
        //Clear the fragmented flag.
        pFileListEntry->Flags &= ~FLE_FRAGMENTED;
    }

    //Set or clear the directory flag depending on whether the file is a directory or not.
    if(VolData.bDirectory){
        //Set the directory flag.
        pFileListEntry->Flags |= FLE_DIRECTORY;
    }
    else{
        //Clear the directory flag.
        pFileListEntry->Flags &= ~FLE_DIRECTORY;
    }

    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Opens a file on an NTFS volume.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
OpenNtfsFile(
    )
{
    TCHAR cPath[MAX_PATH] = {0};
    DWORD Error;

//      TCHAR cString[300];

    //0.0E00 Display the File path and name.
//  Message(TEXT("NtfsSubs::OpenNtfsFile"), -1, VolData.cFileName);

    //0.0E00 Display File Number, number of extents and number of fragments.
//      wsprintf(cString,
//                       TEXT("                             FileNumber = 0x%lX Extents = 0x%lX Fragments = 0x%lX"),
//                       (ULONG)VolData.FileRecordNumber,
//                       (ULONG)VolData.NumberOfExtents,
//                       (ULONG)VolData.NumberOfFragments);
//  Message(TEXT("NtfsSubs::OpenNtfsFile"), -1, cString);

//      wsprintf(cString, TEXT("                             %s file at Lcn 0x%lX for Cluster Count of 0x%lX"),
//                       (VolData.bFragmented == TRUE) ? TEXT("Fragmented") : TEXT("Contiguous"),
//                       (ULONG)VolData.StartingLcn,
//                       (ULONG)VolData.NumberOfClusters);
//  Message(TEXT("NtfsSubs::OpenNtfsFile"), -1, cString);

    if(VolData.bDirectory){
        Error = 0;
    }

    if(VolData.hFile != INVALID_HANDLE_VALUE){
        CloseHandle(VolData.hFile);
    }

    if (VolData.vFileName.IsEmpty()) {
        VolData.hFile = INVALID_HANDLE_VALUE;
        return FALSE;
    }

    DWORD dwCreationDisposition;
    dwCreationDisposition = FILE_FLAG_BACKUP_SEMANTICS | FILE_OPEN_REPARSE_POINT;   //sks createfile parameters

    // Get a transparent handle to the file.
    
    VolData.hFile = CreateFile(
        VolData.vFileName.GetBuffer(),
        FILE_READ_ATTRIBUTES | SYNCHRONIZE, //sks bug #184735
        0,
        NULL,
        OPEN_EXISTING,
        dwCreationDisposition,
        NULL);

    if(VolData.hFile == INVALID_HANDLE_VALUE) {
        //
        // Handle the special $Extend files:  see bug 303250
        //
        PWSTR pwszFileName = VolData.vFileName.GetBuffer();

        if (!pwszFileName) {
            return FALSE;
        }

        if (_tcsstr(pwszFileName, TEXT("\\$Extend")) != (PTCHAR) NULL){
            if (_tcsstr(pwszFileName, TEXT("\\$Quota")) != (PTCHAR) NULL){
                VolData.vFileName += L":$Q:$INDEX_ALLOCATION";
            }
            else if (_tcsstr(pwszFileName, TEXT("\\$ObjId")) != (PTCHAR) NULL){
                VolData.vFileName += L":$O:$INDEX_ALLOCATION";
            }
            else if (_tcsstr(pwszFileName, TEXT("\\$Reparse")) != (PTCHAR) NULL){
                VolData.vFileName += L":$R:$INDEX_ALLOCATION";
            }

            VolData.hFile = CreateFile(
                VolData.vFileName.GetBuffer(),
                FILE_READ_ATTRIBUTES | SYNCHRONIZE, //sks bug #184735
                0,
                NULL,
                OPEN_EXISTING,
                dwCreationDisposition,
                NULL);
        }
    }

    if(VolData.hFile == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        Message(TEXT("OpenNtfsFile - CreateFile"), GetLastError(), ESICompressFilePath(VolData.vFileName.GetBuffer()));
        SetLastError(Error);
        return FALSE; // Try later.
    }

    Message(ESICompressFilePath(VolData.vFileName.GetBuffer()), -1, NULL);

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Gets the extent list for the system files -- the MFT, MFT2, and the Uppercase file.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN VolData.hVolume                      - The handle to the volume.
    IN VolData.BytesPerFRS          - The number of bytes in a file record.
    IN OUT VolData.pExtentList      - Where to put the extents for all the system files.
    IN VolData.NumberOfExtents      - The number of extents in the extent list.
    IN VolData.ExtentListAlloced      - The number of bytes allocated for the extent list.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
GetSystemsExtentList(
    )
{
    LONGLONG                                        StartingLcn;
    LONGLONG                                        EndingLcn;
    LONGLONG                                        FileRecordNumber;
    STREAM_EXTENT_HEADER*                           pStreamExtentHeader;
    EXTENT_LIST*                                    pExtents;

    //1.0E00 Get the start of the Mft mirror
    //Get the FRS.
    FileRecordNumber = 1;
    EF(GetInUseFrs(VolData.hVolume, &FileRecordNumber, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, (ULONG)VolData.BytesPerFRS));
    EF_ASSERT(FileRecordNumber == 1);
    VolData.FileRecordNumber = FileRecordNumber;
    //Get the extent list.
    EF(GetStreamExtentsByNameAndType(TEXT(""), $DATA, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord));
    //Get a pointer to the stream header.
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)VolData.pExtentList;
    //Make sure this is the first stream.
    EF_ASSERT(pStreamExtentHeader->StreamNumber == 0);      
    //Make sure there are extents in this stream.
    EF_ASSERT(pStreamExtentHeader->ExtentCount);
    //Get a pointer to the extents in this stream.
    pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));
    //The first extent points to the beginning of the mft mirror.
    StartingLcn = pExtents->StartingLcn;

    //1.0E00 Get the end of the Upcase file
    //Get the FRS.
    FileRecordNumber = 0x0a;
    EF(GetInUseFrs(VolData.hVolume, &FileRecordNumber, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, (ULONG)VolData.BytesPerFRS));
    EF_ASSERT(FileRecordNumber == 0x0a);
    VolData.FileRecordNumber = FileRecordNumber;
    //Get the extent list.
    EF(GetStreamExtentsByNameAndType(TEXT(""), $DATA, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord));
    //Get a pointer to the stream header.
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)VolData.pExtentList;
    //Make sure this is the first stream.
    EF_ASSERT(pStreamExtentHeader->StreamNumber == 0);      
    //Make sure there are extents in this stream.
    EF_ASSERT(pStreamExtentHeader->ExtentCount);
    //Get a pointer to the extents in this stream.
    pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));
    //The first extent points to the whole upcase file which ends off the MFT mirror section.
    EndingLcn = pExtents->StartingLcn + pExtents->ClusterCount;

    //1.0E00 Get the Mft extent list
    //Get the FRS
    FileRecordNumber = 0;
    EF(GetInUseFrs(VolData.hVolume, &FileRecordNumber, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, (ULONG)VolData.BytesPerFRS));
    EF_ASSERT(FileRecordNumber == 0);
    VolData.FileRecordNumber = FileRecordNumber;

    //Get the extent list.
    EF(GetStreamExtentsByNameAndType(TEXT(""), $DATA, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord));
    //Get a pointer to the stream header.
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)VolData.pExtentList;
    //Make sure this is the first stream.
    EF_ASSERT(pStreamExtentHeader->StreamNumber == 0);      
    //Make sure there are extents in this stream.
    EF_ASSERT(pStreamExtentHeader->ExtentCount);
    //Get a pointer to the extents in this stream.
    pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

    //1.0E00 Extend the MFT extent list to add an extent for MFT2
    pStreamExtentHeader->ExtentCount ++;

    //0.0E00 Extend the extent list buffer as necessary
    if((sizeof(STREAM_EXTENT_HEADER) + pStreamExtentHeader->ExtentCount*sizeof(EXTENT_LIST)) > (size_t) VolData.ExtentListAlloced){
        //If so, realloc it larger, 64K at a time.
        EF(AllocateMemory((UINT)VolData.ExtentListAlloced + 0x10000, &VolData.hExtentList, (void**)&VolData.pExtentList));
        VolData.ExtentListAlloced += 0x10000;

        //Reset pointers that might have changed.
        pStreamExtentHeader = (STREAM_EXTENT_HEADER*)VolData.pExtentList;
        pExtents = (EXTENT_LIST*)((UCHAR*)VolData.pExtentList + sizeof(STREAM_EXTENT_HEADER));
    }
    //1.0E00 Add an extent for Mirror thru Upcase
    pExtents[pStreamExtentHeader->ExtentCount - 1].StartingLcn = StartingLcn;
    pExtents[pStreamExtentHeader->ExtentCount - 1].ClusterCount = EndingLcn - StartingLcn;

    //We do not increase ExcessExtents because the MFT2 region is not considered an excess fragment.
    //We do need to change the allocated length for the system extents, however, to encompass the second extent.
    pStreamExtentHeader->AllocatedLength += pExtents[pStreamExtentHeader->ExtentCount - 1].ClusterCount * VolData.BytesPerCluster;

    //Increase the file size for the system extents list since the purpose of the file size in this case is to tell the user how many bytes
    //the system files occupy, and there is no similar statistic that can be obtained from the file system to conform to.
    pStreamExtentHeader->FileSize += pExtents[pStreamExtentHeader->ExtentCount - 1].ClusterCount * VolData.BytesPerCluster;

    //The caller code will want to know how many extents there are here.
    VolData.MftNumberOfExtents = pStreamExtentHeader->ExtentCount;

    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Given an extent list it adds it to a file list.

INPUT + OUTPUT:
    OUT pList                       - A pointer to the file list.
    IN pListIndex           - An index of how far the list has been written into.
    IN ListEntries          - The number of entries in the extent list.
    IN FileRecordNumber     - The File Record Number for this file.
    IN pExtentList          - The extent list.

GLOBALS:
    IN VolData.bDirectory                   - Whether or not this file a directory.
    IN VolData.NumberOfFragments    - The number of fragments in this file.
    IN VolData.NumberOfExtents              - The number of extents in this file.
    IN VolData.FileSize                             - The size of the file.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
AddFileToListNtfs(
    IN PRTL_GENERIC_TABLE Table,
    IN LONGLONG FileRecordNumber
    )
{
    FILE_LIST_ENTRY FileListEntry;
    FILE_EXTENT_HEADER* pFileExtentHeader = NULL;
    BOOLEAN bNewElement = FALSE;
    PVOID p = NULL;

    //Get a pointer to the file extent header.
    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;
    //Fill in the file info
    FileListEntry.StartingLcn = VolData.StartingLcn;
    FileListEntry.FileRecordNumber = FileRecordNumber;
    FileListEntry.ExcessExtentCount = (UINT)VolData.NumberOfFragments - pFileExtentHeader->NumberOfStreams;		//Only count *excess* extents since otherwise files with multiple streams would be "fragmented".

    FileListEntry.ClusterCount = VolData.NumberOfClusters; 
    FileListEntry.Flags = 0;

    //Set or clear the fragmented flag depending on whether the file is fragmented or not.
    if(VolData.bFragmented){
        //Set the fragmented flag.
        FileListEntry.Flags |= FLE_FRAGMENTED;
    }
    else{
        //Clear the fragmented flag.
        FileListEntry.Flags &= ~FLE_FRAGMENTED;
    }

    //Set or clear the directory flag depending on whether the file is a directory or not.
    if(VolData.bDirectory){
        //Set the directory flag.
        FileListEntry.Flags |= FLE_DIRECTORY;
    }
    else{
        //Clear the directory flag.
        FileListEntry.Flags &= ~FLE_DIRECTORY;
    }


    if (VolData.bBootOptimiseFile) {
        FileListEntry.Flags |= FLE_BOOTOPTIMISE;
    }
    else {
        FileListEntry.Flags &= ~FLE_BOOTOPTIMISE;
    }

    p = RtlInsertElementGenericTable(
        Table,
        (PVOID) &FileListEntry,
        sizeof(FILE_LIST_ENTRY),
        &bNewElement);

    if (!p) {
        //
        // An allocation failed
        //
        return FALSE;
    };

    // This better be a recognised as a new element.  If it isn't, something's
    // wrong with our compare routine
//    ASSERT(bNewElement);

    return TRUE;
}



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Locate an attribute in a File Record Segment

INPUT + OUTPUT:
    IN TypeCode             - TypeCode of the attribute to find
    IN pFrs                 - Pointer to the File Record Segment
    OUT ppArh               - Returns the pointer to the attribute
    IN uBytesPerFrs - The number of bytes in an FRS.

GLOBALS:
    None.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
FindAttributeByType(
    IN ATTRIBUTE_TYPE_CODE TypeCode,
    IN PFILE_RECORD_SEGMENT_HEADER pFrs,
    OUT PATTRIBUTE_RECORD_HEADER* ppArh,
    IN ULONG uBytesPerFRS
    )
{
    PATTRIBUTE_RECORD_HEADER        pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + pFrs->FirstAttributeOffset);

    require(pFrs);
    require(ppArh);
    require(uBytesPerFRS);

    //0.0E00 Seach through the attributes in this file record for the first one of the requested type
    //0.1E00 Make sure our attribute pointer doesn't go beyond the end of the FRS and check if this is the attribute we're
    //looking for or the end of the record.
    while(pArh < (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + uBytesPerFRS) &&
          pArh->TypeCode != TypeCode &&
          pArh->TypeCode != $END){

        //0.1E00 We did not find our attribute, so go to the next.
        pArh = (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pArh + pArh->RecordLength);
    }

    if (pArh >= (ATTRIBUTE_RECORD_HEADER*)((PUCHAR)pFrs + uBytesPerFRS)) {
        VolData.bMFTCorrupt = TRUE;
        return FALSE;
    }

    //0.0E00 Error if attribute not found
    if(pArh->TypeCode != TypeCode){
        return FALSE;
    }

    //0.0E00 Return pointer to the attribute
    *ppArh = pArh;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\logging.cpp ===
/*****************************************************************************************************************

FILENAME: Logging.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

	How a program logs events:
	1) Init logging is called to set up logging for this process and get logging info from the registry.
	2) LogEvent is called each time you want to log something.
	3) CleanupLogging is called on exit.


	The following events are logged if the user has them selected to log in log options:
	See the LOG_OPTIONS structure in header file.

	Defragment Engine starts or stops				= bLogDefragStartStop	- logged by the Controller
	File was defragmented							= bLogFilesDefragged	- logged by the Engine.
	File was moved									= bLogFilesMoved		- logged by the Engine.
	Summary is logged after defragmentation pass	= bLogDefragSummary		- logged by the Controller


	The corresponding registry entries are Values within the standard Diskeeper directory tree \UserSettings\
	Type REG_SZ - a 1 means yes, log it, 0 means no don't log it.

	bLogDefragStartStop		- LogDefragStartStop
	bLogFilesDefragged		- LogFilesDefragged
	bLogFilesMoved			- LogFilesMoved
	bLogDefragSummary		- LogDefragSummary


REVISION HISTORY:
	0.0E00 - ? 1996 - Zack Gainsforth - created module.
	1.0E00 - 22 April 1997 - Zack Gainsforth - extracted module and nuked half so as not not have complexity
												of the communication methods used in the old diskeeper.

/****************************************************************************************************************/

#include "stdafx.h"

#ifndef NOEVTLOG
#include <windows.h>

#include "ErrMacro.h"
#include "Event.h"
#include "GetReg.h"
#include "Logging.h"

//This is the structure that contains the logging data - if any of these fields are true then that indicates
//that the appropriate message should be logged.
typedef struct{
	BOOL bLogDefragStartStop;
	BOOL bLogFilesDefragged;
	BOOL bLogFilesMoved;
	BOOL bLogDefragSummary;
	BOOL bLogServiceStartStop;
	BOOL bLogFileInformation;
	BOOL bLogDiskInformation;
	BOOL bLogPageFileInformation;
	BOOL bLogDirectoryInformation;
	BOOL bLogMFTInformation;
} LOG_OPTIONS;

static LOG_OPTIONS LogOptions;			//This is a global to this module only.
static HANDLE hEventSource;				//The Handle to the event log.

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine initializes logging for the current process.

INPUT + OUTPUT:
	cEventSource - a char string giving the event source to be passed into RegisterEventSource

GLOBALS:
	None.

RETURN:
	TRUE - Success
	FALSE - Fatal Error
*/
BOOL InitLogging(
    PTCHAR cEventSource
	)
{
	//0.0E00 Fill LogOptions structure (GetLogOptionsFromRegistry)
	EF(GetLogOptionsFromRegistry());

	//0.0E00 Open the Event Log (RegisterEventSource)
    if ((hEventSource = RegisterEventSource(NULL, cEventSource)) == NULL) {

        //0.0E00 RPC_S_UNKNOWN_IF is an error that happens on shut down, this is a kludge.
		EF(GetLastError() != RPC_S_UNKNOWN_IF);
		return FALSE;
	}

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine retrieves logging options from the registry.

INPUT + OUTPUT:
	None.

GLOBALS:
	LogOptions - Contains the options for what sort of messages to log.

RETURN:
	TRUE - Success
	FALSE - Fatal Error
*/
BOOL GetLogOptionsFromRegistry(
	)
{
	HKEY hKey = NULL;
	TCHAR cRegValue[10];
	DWORD dwRegValueSize;
	TCHAR *cLoggingRoot = L"SOFTWARE\\Microsoft\\Dfrg";

	//0.0E00 Fill out LogOptions structure with the various registry values.
	__try {
		//The first call gets handle to registry.
		dwRegValueSize = sizeof(cRegValue);
#ifdef DKMS
		EF(GetRegValue(&hKey,
				cLoggingRoot,
				TEXT("LogDefragStartStop"),
				cRegValue,
				&dwRegValueSize) == ERROR_SUCCESS);
#else
		EF(GetRegValue(&hKey,
				TEXT("SOFTWARE\\Executive Software\\Diskeeper\\UserSettings"),
				TEXT("LogServiceStartStop"),
				cRegValue,
				&dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogServiceStartStop = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;

		//Get all the other values now that the key is opened.
		dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogDefragStartStop"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
#endif
		LogOptions.bLogDefragStartStop = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;

		//0.0E00 Get all the other values now that the key is opened.
		dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogFilesDefragged"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogFilesDefragged = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;
		
		dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogFilesMoved"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogFilesMoved = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;

#ifdef DKMS
		dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogDefragSummary"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogDefragSummary = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;
#endif

#ifndef DKMS
	        dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogFileInformation"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogFileInformation = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;

	    	dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogDiskInformation"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogDiskInformation = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;

		dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogPageFileInformation"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogPageFileInformation = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;

		dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogDirectoryInformation"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogDirectoryInformation = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;
		
		dwRegValueSize = sizeof(cRegValue);
		EF(GetRegValue(&hKey, NULL, TEXT("LogMFTInformation"), cRegValue, &dwRegValueSize) == ERROR_SUCCESS);
		LogOptions.bLogMFTInformation = (cRegValue[0] == TEXT('1')) ? TRUE : FALSE;
#endif
	}
	__finally {

		//0.0E00 Close the registry.
		if(hKey){
			EF(RegCloseKey(hKey)==ERROR_SUCCESS);
		}
	}
	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This routine shuts down the logging and closes all handles.

INPUT + OUTPUT:
	None.

GLOBALS:
	hEventSource - The handle to the EventLog.

RETURN:
	TRUE - Success
	FALSE - Fatal Error
*/
BOOL CleanupLogging(
	)
{

	//0.0E00 Close the Event Log (DeregisterEventSource)
    EF(DeregisterEventSource(hEventSource));

	return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
	This module logs an event to the event log.

INPUT + OUTPUT:
	EventID	- DWORD ID for which message to log.
	cMsg	- A string to append to the end of the standard message text.

GLOBALS:
	LogOptions		- Contains the options for what sort of messages to log.
	hEventSource	- The handle to the EventLog.

RETURN:
	TRUE - Success
	FALSE - Fatal Error
*/
BOOL LogEvent(
    DWORD dwEventID,
    PTCHAR cMsg
	)
{
	BOOL bLogThisEvent = FALSE;
	LPCTSTR cStrings[1];

	//0.0E00 Check whether or not to log this dwEventID from the LogOptions structure.
	switch(dwEventID){

#ifndef DKMS
	case MSG_CONTROL_START:
	case MSG_CONTROL_CLOSE:
		if(LogOptions.bLogServiceStartStop){
			bLogThisEvent = TRUE;
		}
		break;
#endif

	case MSG_ENGINE_START:
	case MSG_ENGINE_CLOSE:
		if(LogOptions.bLogDefragStartStop){
			bLogThisEvent = TRUE;
		}
		break;

	case MSG_ENGINE_DEFRAGMENT:
		if(LogOptions.bLogFilesDefragged){
			bLogThisEvent = TRUE;
		}
		break;

	case MSG_ENGINE_FREE_SPACE:
		if(LogOptions.bLogFilesMoved){
			bLogThisEvent = TRUE;
		}
		break;

#ifdef DKMS
	case MSG_DEFRAG_SUMMARY:
		if(LogOptions.bLogDefragSummary){
			bLogThisEvent = TRUE;
		}
		break;
#endif

#ifndef DKMS
	case MSG_DISK_INFO:
		if(LogOptions.bLogDiskInformation){
				bLogThisEvent = TRUE;
		}
		break;

		
	case MSG_FILE_INFO:
		if(LogOptions.bLogFileInformation){
			bLogThisEvent = TRUE;
		}
		break; 

	case MSG_PAGE_FILE_INFO:
		if(LogOptions.bLogPageFileInformation){
				bLogThisEvent = TRUE;
		}
		break; 


	case MSG_DIRECTORIS_INFO:
		if(LogOptions.bLogDirectoryInformation){
				bLogThisEvent = TRUE;
		}
		break; 


	case MSG__MFT_INFO:
		if(LogOptions.bLogMFTInformation){
				bLogThisEvent = TRUE;
		}
		break;
#endif

	//Log all the following events.
	case MSG_CONTROL_EXCLUDE:
	case MSG_CONTROL_SCHEDULE:
	case MSG_CONTROL_ERROR:
	case MSG_ENGINE_ERROR:
		bLogThisEvent = TRUE;
		break;
	}
	//0.0E00 If this event should not be logged, don't log it.
	if(!bLogThisEvent){
		return TRUE;
	}

	//0.0E00 If we log this dwEventID - log it. (ReportEvent)
	cStrings[0] = cMsg;

	//0.0E00 Place the event in the event log
	ReportEvent(hEventSource,				// handle of event source
			EVENTLOG_INFORMATION_TYPE,		// event type
			0,								// event category
			dwEventID,						// event ID
			NULL,							// current user's SID
			1,								// strings in cStrings
			0,								// no bytes of raw data
			cStrings,						// array of error strings
			NULL);							// no raw data

	return TRUE;
}

#endif //NOEVTLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\priority.c ===
#include "stdafx.h"
#include <windows.h>



/* 
 * Priority.c
 * 
 * This module contains the following routines
 *      IsBelowNormalBasePriority : Checks is the current process is executing below Normal Base priority
 *      ResetToNormalPriority : Resets current process to Normal priority
 *      Main : Calling routine to test above 2 routines. 
 *
 * Here is some MSDN data on the base priority of a process.
 *
 * Thread Priority
 * ===============
 * Base Priority
 * 
 * The priority level of a thread is determined by both the priority class of 
 * its process and its priority level. The priority class and priority level are 
 * combined to form the base priority of each thread. The following table shows the 
 * base priority levels for combinations of priority class and priority value. 
 * 
 *   Process Priority Class				Thread Priority Level 
 * 1 IDLE_PRIORITY_CLASS				THREAD_PRIORITY_IDLE 
 * 1 BELOW_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_IDLE 
 * 1 NORMAL_PRIORITY_CLASS				THREAD_PRIORITY_IDLE 
 * 1 ABOVE_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_IDLE 
 * 1 HIGH_PRIORITY_CLASS				THREAD_PRIORITY_IDLE 
 * 2 IDLE_PRIORITY_CLASS				THREAD_PRIORITY_LOWEST 
 * 3 IDLE_PRIORITY_CLASS				THREAD_PRIORITY_BELOW_NORMAL 
 * 4 IDLE_PRIORITY_CLASS				THREAD_PRIORITY_NORMAL 
 * 4 BELOW_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_LOWEST 
 * 5 IDLE_PRIORITY_CLASS				THREAD_PRIORITY_ABOVE_NORMAL 
 * 5 BELOW_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_BELOW_NORMAL 
 * 5 Background NORMAL_PRIORITY_CLASS	THREAD_PRIORITY_LOWEST 
 * 6 IDLE_PRIORITY_CLASS				THREAD_PRIORITY_HIGHEST 
 * 6 BELOW_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_NORMAL 
 * 6 Background NORMAL_PRIORITY_CLASS	THREAD_PRIORITY_BELOW_NORMAL 
 * 7 BELOW_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_ABOVE_NORMAL 
 * 7 Background NORMAL_PRIORITY_CLASS	THREAD_PRIORITY_NORMAL 
 * 7 Foreground NORMAL_PRIORITY_CLASS	THREAD_PRIORITY_LOWEST 
 * 8 BELOW_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_HIGHEST 
 * 8 NORMAL_PRIORITY_CLASS				THREAD_PRIORITY_ABOVE_NORMAL 
 * 8 Foreground NORMAL_PRIORITY_CLASS	THREAD_PRIORITY_BELOW_NORMAL 
 * 8 ABOVE_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_LOWEST 
 * 9 NORMAL_PRIORITY_CLASS				THREAD_PRIORITY_HIGHEST 
 * 9 Foreground NORMAL_PRIORITY_CLASS	THREAD_PRIORITY_NORMAL 
 * 9 ABOVE_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_BELOW_NORMAL 
 * 10 Foreground NORMAL_PRIORITY_CLASS	THREAD_PRIORITY_ABOVE_NORMAL 
 * 10 ABOVE_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_NORMAL 
 * 11 Foreground NORMAL_PRIORITY_CLASS	THREAD_PRIORITY_HIGHEST 
 * 11 ABOVE_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_ABOVE_NORMAL 
 * 11 HIGH_PRIORITY_CLASS				THREAD_PRIORITY_LOWEST 
 * 12 ABOVE_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_HIGHEST 
 * 12 HIGH_PRIORITY_CLASS				THREAD_PRIORITY_BELOW_NORMAL 
 * 13 HIGH_PRIORITY_CLASS				THREAD_PRIORITY_NORMAL 
 * 14 HIGH_PRIORITY_CLASS				THREAD_PRIORITY_ABOVE_NORMAL 
 * 15 HIGH_PRIORITY_CLASS				THREAD_PRIORITY_HIGHEST 
 * 15 HIGH_PRIORITY_CLASS				THREAD_PRIORITY_TIME_CRITICAL 
 * 15 IDLE_PRIORITY_CLASS				THREAD_PRIORITY_TIME_CRITICAL  
 * 15 BELOW_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_TIME_CRITICAL 
 * 15 NORMAL_PRIORITY_CLASS				THREAD_PRIORITY_TIME_CRITICAL 
 * 15 ABOVE_NORMAL_PRIORITY_CLASS		THREAD_PRIORITY_TIME_CRITICAL 
 * 16 REALTIME_PRIORITY_CLASS			THREAD_PRIORITY_IDLE 
 * 22 REALTIME_PRIORITY_CLASS			THREAD_PRIORITY_LOWEST 
 * 23 REALTIME_PRIORITY_CLASS			THREAD_PRIORITY_BELOW_NORMAL 
 * 24 REALTIME_PRIORITY_CLASS			THREAD_PRIORITY_NORMAL 
 * 25 REALTIME_PRIORITY_CLASS			THREAD_PRIORITY_ABOVE_NORMAL 
 * 26 REALTIME_PRIORITY_CLASS			THREAD_PRIORITY_HIGHEST 
 * 31 REALTIME_PRIORITY_CLASS			THREAD_PRIORITY_TIME_CRITICAL 
 *
 */


//
//   ------------------------------
//  |  IsBelowNormalBasePriority() |
//   ------------------------------
//
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//
//  Description:
//    Determine whether the current thread running below the normal priority or not.
// 
//    Caller must have a PROCESS_QUERY_INFORMATION access to the process/ thread.
//
//    PDL
//
//		This routine taking normal base priority as "Base Priority level 7". ie
//		combination of NORMAL_PRIORITY_CLASS and THREAD_PRIORITY_NORMAL (background)
//
//		These are the conditions that we can use to determine whether the 
//		thread running at >= NORMAL priority or not. 
//
//		1) All the thread running under IDLE_PRIORITY_CLASS has got base priority of 1 except
//		the thread which has the priority of THREAD_PRIORITY_TIME_CRITICAL.
//
//		2) The thread belongs to a BELOW_NORMAL_PRIORITY_CLASS process should run at  
//		THREAD_PRIORITY_ABOVE_NORMAL or higher priority to get the NORMAL base priority.
//
//		3) All the Threads, which are running at THRED_PRIORITY_IDLE has a base priority of less than 7 
//		except those threads are in the REALTIME_PRIORITY_CLASS process.
//
//		4) If the process running at NORMAL_PRIORITY_CLASS then the thread should run  at 
//		THREAD_PRIORITY_NORMAL or above.
//  
//  Calling Sequence:
//		None.
//
//  Inputs:
//		None.
//
//  Outputs:
//		None.
//		Return TRUE if the current thread's Base priority is below normal.
//		otherwise return FALSE
//
//  Error Handling:
//		Error not handled, returns FALSE on error
//		
//
//  Global Effects:
//    None
BOOL
IsBelowNormalBasePriority()
{
	DWORD   PriorityClass, ThreadPriority;
	BOOL	bBelowNormal  = FALSE;


	do {
		//
		// get the Process Priority class and the thread priority
		//
		PriorityClass  = GetPriorityClass(GetCurrentProcess());
		if (!PriorityClass ) break;

		ThreadPriority = GetThreadPriority(GetCurrentThread());
		if (THREAD_PRIORITY_ERROR_RETURN == ThreadPriority) break;


		bBelowNormal = TRUE;

        //
        // Check for the 4 cases of running below Normal base priority
        //

        //
        // 1) Check for threads running under IDLE_PRIORITY_CLASS has got base priority of 1 except
        //	  the thread which has the priority of THREAD_PRIORITY_TIME_CRITICAL.
		if (IDLE_PRIORITY_CLASS				== PriorityClass &&
			THREAD_PRIORITY_TIME_CRITICAL   != ThreadPriority ) break;
        //
        // 2) Check threads that belongs to a BELOW_NORMAL_PRIORITY_CLASS process should run at  
        //    THREAD_PRIORITY_ABOVE_NORMAL or higher priority to get the NORMAL base priority.
		if (BELOW_NORMAL_PRIORITY_CLASS		== PriorityClass &&
			THREAD_PRIORITY_NORMAL			>= ThreadPriority ) break;
        //
        // 3) Check all the Threads, which are running at THREAD_PRIORITY_IDLE has a base priority of less than 7 
        //    except those threads are in the REALTIME_PRIORITY_CLASS process.
		if (THREAD_PRIORITY_IDLE			== ThreadPriority &&
			REALTIME_PRIORITY_CLASS			!= PriorityClass ) break;
        //
        // 4) Check if the process is running at NORMAL_PRIORITY_CLASS then the thread should run  at 
        //    THREAD_PRIORITY_NORMAL or above.
		if (NORMAL_PRIORITY_CLASS			== PriorityClass &&
			THREAD_PRIORITY_NORMAL			>= ThreadPriority ) break;

        // 
        // If it did not meet the above criteria, then it must be running at Normal base priority or above
		bBelowNormal = FALSE;

	}while(0);


	return bBelowNormal;
}


//
//   --------------------------
//  |  ResetToNormalPriority() |
//   --------------------------
//
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//
//  Description:
//    Sets Current Thread's Base priority to Normal
//
//	  Caller should have PROCESS_SET_INFORMATION and THREAD_SET_INFORMATION access right
//    for the current process / current thread..
//
//    PDL
//
//		Resetting base priority by setting Priority Class and Thread Priority 
//		to NORMAL.
//  
//  Calling Sequence:
//		None.
//
//  Inputs:
//		None.
//
//  Outputs:
//		None.
//		returns FALSE on error. return TRUE on success
//
//  Error Handling:
//    return FALSE on error
//
//  Global Effects:
//    The process priority will reset to NORMAL_PRIORITY_CLASS 
//    and current thread's  priority to THREAD_PRIORITY_NORMAL.
//
BOOL
ResetToNormalPriority()
{
	if (!SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS)) return FALSE;
	if (!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL)) return FALSE;
	return TRUE;
}





#ifdef TEST_PRIORITY_MODULE

int
main()
{
	for (;;) {
		Sleep(4000);
		if (IsBelowNormalBasePriority()) {
			ResetToNormalPriority();
		}
	}
	return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\movefile.cpp ===
/*****************************************************************************************************************

FILENAME: MoveFile.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"

#include <windows.h>
#include <winioctl.h>

extern "C" {
    #include "SysStruc.h"
}
#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"

#include "Devio.h"

#include "Extents.h"
#include "FreeSpace.h"
#include "MoveFile.h"
#include "NtfsSubs.h"

#include "Alloc.h"
#include "DiskView.h"
#include "Event.h"
#include "Logging.h"
#include "FsSubs.h"

#define THIS_MODULE 'O'
#include "logfile.h"

static void UpdatePostMoveStats(FILE_EXTENT_HEADER* pFileExtentHeader, LONGLONG llBeforeExtents);


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Moves a file to a new location on a disk (so as to defrag it).

GLOBALS:
    VolData

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
MoveFile(
    )
{
    TCHAR cString[500];
    UINT i, j;

    FILE_EXTENT_HEADER* pFileExtentHeader;
    STREAM_EXTENT_HEADER* pStreamExtentHeader;
    EXTENT_LIST* pExtents;

    LONGLONG VirtualFileClusters;
    LONGLONG llBeforeExtents;

    ATTRIBUTE_TYPE_CODE TypeCode = 0;

    LONGLONG Vcn = 0;
    LONGLONG Lcn = VolData.FoundLcn;
    LONGLONG RunLength = VolData.FoundLen;
    LONGLONG oldStartingLcn = 0;
    BOOL bReturnValue = FALSE; // assume error
    BOOL bFileStartedFragmented; // keeps track of the starting state of a file
    

    // Validate that we have a file system.
    if((VolData.FileSystem != FS_NTFS) 
       && (VolData.FileSystem != FS_FAT) 
       && (VolData.FileSystem != FS_FAT32)) {

        EF_ASSERT(FALSE);
    }
    // Debug
    //  ShowExtentList();

    // Set the status to move the next file. Therefore, unless this variable gets reset
    // to NEXT_ALGO_STEP within this function, it goes on to the next file by default.
#ifdef DFRGNTFS   
    VolData.Status = ERROR_SUCCESS;
#elif DFRGFAT
    VolData.Status = NEXT_FILE;
#endif

    // Set up the Extent pointers structure to fill in the extent list in VolData.
    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));
    pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));


    //Scott Sipe 5/1/2000 Boot Optimize
    //we now have the extents for the file, it the file is part of the files that have been
    //moved by the BootOptimize routine, then we do not want to move them, so just test to see
    //if the pExtents->StartingLcn is in the block of optimized files, then exit the routine and
    //return FALSE
#ifdef DFRGFAT
    if((VolData.BootOptimizeBeginClusterExclude != 0 ||
        VolData.BootOptimizeEndClusterExclude != 0) && IsBootVolume(VolData.cDrive))
    {
        if(pExtents->StartingLcn >= (LONGLONG)VolData.BootOptimizeBeginClusterExclude &&
            pExtents->StartingLcn < (LONGLONG)VolData.BootOptimizeEndClusterExclude)
        {
            return(FALSE);
        }
    }

#endif

    __try {

        // Mark the file as free space before we move it. After we move it,
        // the new blocks will be colored in with the correct color.
        if (!AddExtents(FreeSpaceColor)){
            EH(FALSE);
            __leave;
        }

        // Record the number of extents in the stream before we move it.
        llBeforeExtents = pFileExtentHeader->ExcessExtents;

        // Loop through each stream in the file and move them.
        for(i=0; i<pFileExtentHeader->NumberOfStreams; i++) {

            // If this is not the first stream, then get a handle to the current stream.
            // We already have a handle to the first stream when this function is called.
            if(i) {

#ifdef DFRGNTFS
                TCHAR StreamName[MAX_PATH];

                // Get this stream's streamname.
                if (!GetStreamNameAndTypeFromNumber(i, StreamName, &TypeCode, NULL)){
                    EH(FALSE);
                    __leave;
                }

                // save a copy of the file name so that we can reset it later
                PTCHAR strFileName = new TCHAR[VolData.vFileName.GetLength()+1];
                if ((strFileName == NULL) || VolData.vFileName.IsEmpty()) {

                    if (strFileName) {
                        delete [] strFileName;
                        strFileName = NULL;
                    }
                    EH(FALSE);
                    __leave;
                }
                _tcscpy(strFileName, VolData.vFileName.GetBuffer());

                // Append this stream's filename to the end of the file's name.
                // Note, if there was already another stream's name appended, then
                // this will simply overwrite it directly. This puts the colon
                // between the filename and the streamname.
                VolData.vFileName.AddChar(L':');

                // This copies streamname plus terminator to the end.
                VolData.vFileName += StreamName;
                                
                // Opens the stream.
                if (!OpenNtfsFile()){
                    delete [] strFileName;
                    strFileName = NULL;
                    EH(FALSE);
                    __leave;
                }
                // reset it (remove the stream name) so that the next stream will work ok
                VolData.vFileName = strFileName;

                delete [] strFileName;
                strFileName = NULL;
#else
                // If this is not NTFS, then there can't be multiple streams!
                EH_ASSERT(FALSE);
                __leave;
#endif
            }
            // Calculate how many clusters there are virtually in this stream
            // (more than there are on the disk if this is a compressed file).
            if (VolData.BytesPerCluster == 0){
                EH_ASSERT(FALSE);
                __leave;
            }

            VirtualFileClusters = pStreamExtentHeader->AllocatedLength / VolData.BytesPerCluster;
            if (pStreamExtentHeader->AllocatedLength % VolData.BytesPerCluster) {
                VirtualFileClusters++;
            }
            
            // Say where we're moving the file to.
            wsprintf(cString,
                    TEXT("Moving file %#lx at Vcn %#lx to Lcn %#lx for %#lx"),
                    (ULONG)VolData.FileRecordNumber,
                    (ULONG)Vcn,
                    (ULONG)Lcn,
                    (ULONG)VirtualFileClusters);

            Message(cString, -1, NULL);

            // stats for move attempts
            if (VolData.bFragmented){
                VolData.FragmentedFileMovesAttempted[VolData.Pass]++;
                bFileStartedFragmented = TRUE;
            }
            else{
                VolData.ContiguousFileMovesAttempted[VolData.Pass]++;
                bFileStartedFragmented = FALSE;
            }

            // Try to move the file - Don't use the physical cluster count, use the virtual.
            if (!MoveAPieceOfAFile(Vcn, Lcn, VirtualFileClusters)){
                __leave;
            }

            // capture the old starting lcn so that we can 
            // detect if it moved...
            // 'cause sometimes it moves, but not to where
            // we tell it to.  Bummer.
            oldStartingLcn = pExtents->StartingLcn;

            // Get the file's new extent list
            if (!GetExtentList(DEFAULT_STREAMS, NULL)){
                EH(FALSE);
                __leave;
            }

            // Reset the file, stream and extent pointers because VolData.pExtentList might
            // have been realloced in GetExtentList()
            pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;
            pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)VolData.pExtentList 
                                  + sizeof(FILE_EXTENT_HEADER));

            // Find the stream we were working on before.
            // Loop through until we hit the one we were on, each time 
            // bumping the stream header to the next stream.
            for(j=0; j<i; j++) {

                pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader 
                                      + sizeof(STREAM_EXTENT_HEADER)
                                      + pStreamExtentHeader->ExtentCount
                                      * sizeof(EXTENT_LIST));
            }
            // Make sure we didn't go off into never-never-land.
            if (j >= pFileExtentHeader->NumberOfStreams){
                EH(FALSE);
                __leave;
            }

            // We have to get a pointer to the extents again.
            pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

            // Confirm that the begining of the stream moved. 
            // If not the move failed, try the next algorithm.
            if(pExtents->StartingLcn == oldStartingLcn) {

                Message(TEXT("ERROR - MoveFile - Stream didn't move. Go to next file."), -1, NULL);

                //Since we had a problem, flush the volume.
                Message(TEXT("MoveFile - Flushing Volume"), -1, NULL);
                EH(FlushFileBuffers(VolData.hVolume));
                VolData.VolumeBufferFlushes[VolData.Pass]++;
#ifdef DFRGFAT
                VolData.Status = NEXT_FILE;
#endif
                __leave;
            }

            Lcn += VirtualFileClusters;

            // Move the stream header to the next stream.
            pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader 
                                  + sizeof(STREAM_EXTENT_HEADER) 
                                  + pStreamExtentHeader->ExtentCount
                                  * sizeof(EXTENT_LIST));
        }

        UpdatePostMoveStats(pFileExtentHeader, llBeforeExtents);

        bReturnValue = TRUE; // everything went just peachy
    }

    __finally {

        // Validate data and keep track of the percent of the disk that is fragmented.
        if (VolData.UsedSpace != 0) {
            VolData.PercentDiskFragged = 100 * VolData.FraggedSpace / VolData.UsedSpace;
        }
        else if (VolData.UsedClusters != 0 && VolData.BytesPerCluster != 0) {
            VolData.PercentDiskFragged = (100 * VolData.FraggedSpace) / 
                                         (VolData.UsedClusters * VolData.BytesPerCluster);
        }

        // Mark the file's new clusters on the disk in the diskview with the appropriate color.
        if(VolData.bDirectory) {
            AddExtents(DirectoryColor);
        }
        else {

            if(VolData.bFragmented){
                AddExtents(FragmentColor);
            }
            else{
                AddExtents(UsedSpaceColor);
            }
        }

#ifdef DFRGFAT
        // Update the file in its file list.
        if (!UpdateInFileList()){
            EH(FALSE);
        }
        else {

            // Load the volume bitmap. Go to the next pass if there is an error.
            if(!GetVolumeBitmap()) {
                Message(TEXT("ERROR - MoveFile - GetVolumeBitmap."), -1, NULL);
                VolData.Status = NEXT_PASS;
                bReturnValue = FALSE;
            }
        }
    }

    if (bReturnValue) { // move succeeded
        VolData.FilesMoved++;
        VolData.FilesMovedInLastPass++;

        // stats for move attempts that succeeded
        if (bFileStartedFragmented){
            VolData.FragmentedFileMovesSucceeded[VolData.Pass]++;
        }
        else{
            VolData.ContiguousFileMovesSucceeded[VolData.Pass]++;
        }
    }
    else {
        // stats for move attempts that failed
        if (bFileStartedFragmented){
            VolData.FragmentedFileMovesFailed[VolData.Pass]++;
        }
        else{
            VolData.ContiguousFileMovesFailed[VolData.Pass]++;
        }
#endif

    }

    // Debug
    //  ShowExtentList();

    return bReturnValue;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine will partially defragment a file.

GLOBALS:
    VolData

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
PartialDefrag(
              )
{
    TCHAR cString[500];
    UINT i;
    
    FILE_EXTENT_HEADER* pFileExtentHeader;
    STREAM_EXTENT_HEADER* pStreamExtentHeader;
    EXTENT_LIST* pExtents;
    LONGLONG llBeforeExtents;
    
    LONGLONG VirtualFileClusters;
    
    ATTRIBUTE_TYPE_CODE TypeCode = 0;
    
    
    LONGLONG llCurrentFreeCount   = 0xffffffffffffffff;
    LONGLONG llCurrentFreeLcn     = 0xffffffffffffffff;
    LONGLONG llStreamClusterTotal = 0xffffffffffffffff;
    LONGLONG llRemainingStreamClusters = 0xffffffffffffffff;
    LONGLONG llCurrentChunkClusters = 0xffffffffffffffff;
    
    LONGLONG Vcn = 0;
    LONGLONG ExcessStreamExtents = 0;
    LONGLONG StreamClusters = 0;
    EXTENT_LIST* pFreeExtents = NULL;
    ULONG ulFreeExtent = 0;
    BOOL bReturnValue = FALSE; // assume error
    
#ifdef DFRGFAT    
    // Set the status to move the next file.  Therefore, unless this variable gets reset
    // to NEXT_ALGO_STEP within this function, it goes on to the next file by default.
    VolData.Status = NEXT_FILE;
    
    // Validate that we have a file system.
    if((VolData.FileSystem != FS_NTFS) 
        && (VolData.FileSystem != FS_FAT) 
        && (VolData.FileSystem != FS_FAT32)) {
        
        EF_ASSERT(FALSE);
    }
    
    // Debug
    //ShowExtentList();
#endif

    //Set up the Extent pointers structure to fill in the extent list in VolData.
    pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;
    pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));
    pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));

    __try {

        // Get a pointer to the free space extents
        pFreeExtents = (EXTENT_LIST*)GlobalLock((void*)VolData.hFreeExtents);
        if (pFreeExtents == (EXTENT_LIST*) NULL) {
            EH(FALSE);
            __leave;
        }
               
        // check to see if the move gets you anywhere!
        // find out how many free space extents it takes to hold this file
        LONGLONG llClusterCount = 0;
        UINT uFreeSpaceExtentCount = 0;
        for(i=0; i < VolData.FreeExtents; i++) {
            llClusterCount += pFreeExtents[i].ClusterCount;
            uFreeSpaceExtentCount++;
            if (llClusterCount >= VolData.NumberOfClusters){
                break;
            }
        }

        // if it would fragment the file more or if it won't even fit in the existing free space, bag it!
        if (uFreeSpaceExtentCount >= VolData.NumberOfFragments || llClusterCount < VolData.NumberOfClusters){
            Message(TEXT("This PartialDefrag() would fragment the file more - return"), -1, NULL);
            __leave;
        }

        _stprintf(cString,
            TEXT("Partial Defrag is defragmenting from %I64d fragments down to %d fragments"),
            VolData.NumberOfFragments, uFreeSpaceExtentCount);
        Message(cString, -1, NULL);


        // Mark the file as free space before we move it. After we move it,
        // the new blocks will be colored in with the correct color.
        if (!AddExtents(FreeSpaceColor)){
            EH(FALSE);
            __leave;
        }
        
        // Record the number of extents in the stream before we move it.
        llBeforeExtents = pFileExtentHeader->ExcessExtents;
        
#ifdef ESI_MESSAGE_WINDOW
#ifdef DFRGNTFS
        /* DEBUG stuff...
        for(i=0; i < VolData.FreeExtents; i++) {
            // Say where we're moving the file to.
            wsprintf(cString,
                TEXT("#%i freespace extnt Lcn %#lx:%#lx"),
                (UINT)i,
                (ULONG) pFreeExtents[i].StartingLcn,
                (ULONG) pFreeExtents[i].ClusterCount);
            
            Message(cString, -1, NULL);
        }
        */
#endif
#endif
        
        //Make sure we start using up free space at the beginning of the 
        //freespace extent list
        ulFreeExtent = 0;
        
        // Loop through each stream in the file and move them.
        for(i=0; i<pFileExtentHeader->NumberOfStreams; i++) {
            
            // If this is not the first stream, then get a handle to the current stream.
            // We already have a handle to the first stream when this function is called.
            if(i>0) {
                
#ifdef DFRGNTFS
                TCHAR StreamName[MAX_PATH];
                
                //Get this stream's streamname.
                if (!GetStreamNameAndTypeFromNumber(i, StreamName, &TypeCode, NULL)){
                    EH(FALSE);
                    __leave;
                }
                
                // save a copy of the file name so that we can reset it later
                PTCHAR strFileName = new TCHAR[VolData.vFileName.GetLength()+1];
                if ((strFileName == NULL) || VolData.vFileName.IsEmpty()){
                    if (strFileName) {
                        delete [] strFileName;
                        strFileName = NULL;
                    }
                    
                    EH(FALSE);
                    __leave;
                }
                _tcscpy(strFileName, VolData.vFileName.GetBuffer());
                
                // Append this stream's filename to the end of the file's name.
                // Note, if there was already another stream's name appended, then
                // this will simply overwrite it directly. This puts the colon
                // between the filename and the streamname.
                VolData.vFileName.AddChar(L':');
                
                // This copies streamname plus terminator to the end.
                VolData.vFileName += StreamName;
                
                // Opens the stream.
                if (!OpenNtfsFile()){
                    delete [] strFileName;
                    strFileName = NULL;
                    EH(FALSE);
                    __leave;
                }
                // reset it (remove the stream name) so that the next stream will work ok
                VolData.vFileName = strFileName;

                delete [] strFileName;
                strFileName = NULL;
#else
                //If this is not NTFS, then there can't be multiple streams!
                EH_ASSERT(FALSE);
                __leave;
#endif
            }
            
            // Get the set of free space clusters to use next
            llCurrentFreeCount =  pFreeExtents[ulFreeExtent].ClusterCount;
            llCurrentFreeLcn = pFreeExtents[ulFreeExtent].StartingLcn;
            Vcn = 0;
            VirtualFileClusters = 0;
            
            // Make sure we know how many clusters comprise this stream
            llStreamClusterTotal = pStreamExtentHeader->AllocatedLength / VolData.BytesPerCluster;
            if ((pStreamExtentHeader->AllocatedLength % VolData.BytesPerCluster) != 0) {
                llStreamClusterTotal++;
            }
            
            //setup a variable we can count down until the stream is exhausted
            llRemainingStreamClusters = llStreamClusterTotal;
            
            //this loop gets performed until the stream is exhausted
            while (llRemainingStreamClusters > 0) {
                
                // Sleep if paused.
                while(VolData.EngineState == PAUSED){
                    Sleep(1000);
                }
                // Terminate if told to stop by the controller - this is not an error.
                if (VolData.EngineState == TERMINATE){
                    __leave;
                }

                //if the remaining clusters are greater than or equal to the current 
                //free space chunk, use up the whole chunk
                if (llRemainingStreamClusters >= llCurrentFreeCount) {
                    llCurrentChunkClusters = llCurrentFreeCount;
                }
                //if the remaining clusters is less than the current 
                //free space chunk, figure out how much of the chunk to use
                else {
                    llCurrentChunkClusters = llRemainingStreamClusters;
                    llCurrentChunkClusters = (llCurrentChunkClusters +15)&0xfffffffffffffff0;
                }
                
                //debug only
                // Say where we're moving the file to.
                wsprintf(cString,
                    TEXT("Moving file %#lx at Vcn %#lx to Lcn %#lx for %#lx"),
                    (ULONG)VolData.FileRecordNumber,
                    (ULONG)Vcn,
                    (ULONG)llCurrentFreeLcn,
                    (ULONG)llCurrentChunkClusters);
                Message(cString, -1, NULL);
                                
                // Try to move the file - Don't use the physical cluster count, use the virtual.
                if (!MoveAPieceOfAFile(Vcn, llCurrentFreeLcn, llCurrentChunkClusters)){
                    __leave;
                }
                
                //********************************************************************
                // Note: the previous incarnation of this code went to great lengths to
                // determine if a partial move was done.  By experiment this is totally
                // unnecessary. The "partial move" was always picked up in the call to
                // moveapieceofafile and we left, skipping to the next file anyway.  So
                // I didn't bother accounting for the partial move case in my rewrite.
                // jlj 15apr99 
                //********************************************************************

                // Update the Vcn to point after the clusters just moved.
                Vcn = Vcn + llCurrentChunkClusters;
                
                // Get the set of free space clusters to use next
                // (it's possible we didn't use all of them, so just decrement
                // until it's exhausted)
                llCurrentFreeCount =  llCurrentFreeCount - llCurrentChunkClusters;
                
                // Okay, was it exhausted?
                if (llCurrentFreeCount <= 0) {

                    // means we ran out of free spac in current chunk; get next one
                    ulFreeExtent++;
                    
                    //if we try to get more than we originally found (as stored in 
                    // VolData.FreeExtents) then bail out.  
                    if (ulFreeExtent > VolData.FreeExtents) {
                        Message(TEXT("ERROR: PartialDefrag Ran out of Free Exents"), -1, NULL);
                        EH_ASSERT(FALSE);
                        __leave;
                    }
                    
                    // Get the set of free space clusters to use next
                    llCurrentFreeCount =  pFreeExtents[ulFreeExtent].ClusterCount;
                    llCurrentFreeLcn = pFreeExtents[ulFreeExtent].StartingLcn;
                } 
                else {
                    //if space left in current free extent, then 
                    //just update the current pointer and continue
                    llCurrentFreeLcn = llCurrentFreeLcn + llCurrentChunkClusters;
                }
                
                //okay, it's all done, just countdown the remaining clusters and continue
                llRemainingStreamClusters = 
                    llRemainingStreamClusters - llCurrentChunkClusters;
            }
            
            // come here when done with the current stream

            //get the current extent list
            EF(GetExtentList(DEFAULT_STREAMS, NULL));
            
            //Set up the Extent pointers structure to fill in the extent list in VolData.
            pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;
            pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)VolData.pExtentList + sizeof(FILE_EXTENT_HEADER));
            pExtents = (EXTENT_LIST*)((UCHAR*)pStreamExtentHeader + sizeof(STREAM_EXTENT_HEADER));
                        
            // Move the stream header to the next stream.
            pStreamExtentHeader = (STREAM_EXTENT_HEADER*)((UCHAR*)pStreamExtentHeader 
                + sizeof(STREAM_EXTENT_HEADER) 
                + pStreamExtentHeader->ExtentCount
                * sizeof(EXTENT_LIST));
        }
        
        // come here when all the streams are exhausted (i.e. all done with file)

        //when we're all done with the file, do the stats
        UpdatePostMoveStats(pFileExtentHeader, llBeforeExtents);
        
        //and consider we finished with no errors
        bReturnValue = TRUE; 
    }
    
    __finally {

        //come here when all done with the file processing or if any 
        //error occurred.  Any "clean up the partial move" is accounted for
        //here.
        
        //get the current extent list
        if (GetExtentList(DEFAULT_STREAMS, NULL)){

            // Validate data and keep track of the percent of the disk that is fragmented.
            if (VolData.UsedSpace != 0) {
                VolData.PercentDiskFragged = 100 * VolData.FraggedSpace / VolData.UsedSpace;
            }
            else if (VolData.UsedClusters != 0 && VolData.BytesPerCluster != 0) {
                VolData.PercentDiskFragged = (100 * VolData.FraggedSpace) / 
                                             (VolData.UsedClusters * VolData.BytesPerCluster);
            }

            // Mark the file's new clusters on the disk in the diskview with the appropriate color.
            if(VolData.bDirectory) {
                AddExtents(DirectoryColor);
            }
            else {
                if(VolData.bFragmented) {
                    AddExtents(FragmentColor);
                }
                else {
                    AddExtents(UsedSpaceColor);
                }
            }
        
            //Update the file's spot in the file list.
            if (!UpdateInFileList()){
                bReturnValue = FALSE;
                EH(FALSE);
            }
            else {
                //0.0E00 Load the volume bitmap. Go to the next pass if there is an error.
                if(!GetVolumeBitmap()) {
                    Message(TEXT("ERROR - PartialDefrag - GetVolumeBitmap()"), -1, NULL);
#ifdef DFRGFAT
                    VolData.Status = NEXT_PASS;
#endif
                    bReturnValue = FALSE;
                }
            }
        }

        // do the stats for this if we figure we moved it in its entirety
        if (bReturnValue) {
            VolData.FilesMoved++;
            VolData.FilesMovedInLastPass++;
        }
    }
    
    return bReturnValue;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine moves a section (or all) of a file to a new location on the disk.

GLOBALS:
    VolData

RETURN:
    TRUE = Success
    FALSE = Failure
*/

BOOL
MoveAPieceOfAFile(
    IN LONGLONG FileVcn,
    IN LONGLONG FreeLcn,
    IN LONGLONG VirtualClustersToMove
    )
{
    MOVE_FILE_DATA MoveData;
    ULONG BytesReturned;
    LONGLONG ntStatus;
    DWORD dwError = ERROR_SUCCESS;

    // Three tries
    for (int i=0; i<3; i++) {

        // Initialize the call to the hook to move this file.
        MoveData.FileHandle = VolData.hFile;
        MoveData.StartingVcn.QuadPart = FileVcn;
        MoveData.StartingLcn.QuadPart = FreeLcn;
        MoveData.ClusterCount = (ULONG)VirtualClustersToMove;

        // Call the MoveFile hook.
        if(ESDeviceIoControl(VolData.hVolume,
                              FSCTL_MOVE_FILE,
                              &MoveData,
                              sizeof(MOVE_FILE_DATA),
                              &ntStatus,
                              sizeof(LONGLONG),
                              &BytesReturned,
                              NULL)) {

#ifdef DFRGNTFS
                    VolData.Status = ERROR_SUCCESS;
#elif DFRGFAT
                    VolData.Status = NEXT_FILE;
#endif
            return TRUE;
        }
        // Get the error and display.
        dwError = GetLastError();
#ifdef DFRGNTFS        
        VolData.Status = dwError;
#endif
        Message(TEXT("MoveAPieceOfAFile - GetLastError = "), dwError, NULL);
        Message(TEXT("MoveAPieceOfAFile - ntStatus = "), (DWORD)ntStatus, NULL);

        Trace(log, " FSCTL_MOVE_FILE failed. "
            "File FRN:%I64d StartingLcn:%I64d ClusterCount:%I64d.  " 
            "Free-space StartingLcn:%I64d ClusterCount:%I64d.  Error %lu", 
            VolData.FileRecordNumber, VolData.StartingLcn, VolData.NumberOfClusters,
            VolData.FoundLcn, VolData.FoundLen, dwError);

        // This is what is returned if the hook does not have directory move enabled. 
        if (dwError == ERROR_INVALID_PARAMETER) {

            // Go to the next file.
#ifdef DFRGFAT            
            VolData.Status = NEXT_FILE;
#endif
            return FALSE;
        }
        // We got an error-retry sleep and try again.
        else if (dwError == ERROR_RETRY) {
            Sleep(300); 
        }
        // Some other error, break from the loop and handle below.
        else {
            break;
        }
    }

    // In all other error cases flush the volume.
    Message(TEXT("Flushing Volume"), -1, NULL);
    VolData.VolumeBufferFlushes[VolData.Pass]++;
    EH(FlushFileBuffers(VolData.hVolume));

#ifdef DFRGNTFS
    VolData.Status = dwError;
#elif DFRGFAT
    // If an error occured go to the next algorithm step.
    VolData.Status = NEXT_ALGO_STEP;
#endif
    return FALSE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This routine can be used during debugging to display the extent list for a file.

GLOBALS:
    IN VolData.pExtentList - The extent list for the file to show.
    IN VolData.NumberOfFragments - The number of extents in the extent list.

RETURN:
    TRUE = Success
    FALSE = Failure
*/

VOID
ShowExtentList(
    )
{
    EXTENT_LIST* pExtentList;
    LONGLONG Extent;
    TCHAR cString[300];

    pExtentList = (EXTENT_LIST*)(VolData.pExtentList 
                                 + sizeof(STREAM_EXTENT_HEADER)
                                 + sizeof(FILE_EXTENT_HEADER)
                                 );

    for(Extent = 0; 
        Extent < VolData.NumberOfFragments;
        Extent ++) {

        wsprintf(cString, 
                 TEXT("StartingLcn = 0x%lx ClusterCount = 0x%lx"), 
                 (ULONG)((pExtentList[Extent].StartingLcn != 0xFFFFFFFFFFFFFFFF) ? 
                 pExtentList[Extent].StartingLcn : 0),
                 (ULONG)pExtentList[Extent].ClusterCount);

        Message(cString, -1, NULL);
    }
}
/**/


static void UpdatePostMoveStats(FILE_EXTENT_HEADER* pFileExtentHeader, LONGLONG llBeforeExtents)
{
    if (VolData.bDirectory) {

        // Update the number of excees directory fragments.
        VolData.NumExcessDirFrags -= llBeforeExtents - pFileExtentHeader->ExcessExtents;

        // Directory was defragmented.
        if(llBeforeExtents && !pFileExtentHeader->ExcessExtents) {

            VolData.NumFraggedDirs--;
            VolData.FraggedSpace -= VolData.NumberOfRealClusters * VolData.BytesPerCluster;

            Message(TEXT("The directory has been successfully defragmented."), -1, NULL);
            EH(LogEvent(MSG_ENGINE_DEFRAGMENT, ESICompressFilePath(VolData.cFileName)));
        }
        // Move of contiguous directory to consolidate free space.
        // This includes compressed directories with contiguous extents.
        else if(llBeforeExtents == pFileExtentHeader->ExcessExtents) {

            Message(TEXT("The directory has been successfully moved to consolidate free space."), -1, NULL);
            EH(LogEvent(MSG_ENGINE_FREE_SPACE, ESICompressFilePath(VolData.cFileName)));
        }
        // The directory was contiguous and was fragmented to consolidate free space.
        else if(!llBeforeExtents && pFileExtentHeader->ExcessExtents) {
            VolData.NumFraggedDirs++;
            VolData.FraggedSpace += VolData.NumberOfRealClusters * VolData.BytesPerCluster;

            Message(TEXT("The directory has been temporarily fragmented in order to consolidate free space."), -1, NULL);
            EH(LogEvent(MSG_ENGINE_FREE_SPACE, ESICompressFilePath(VolData.cFileName)));
        }
    }
    // Update the disk fragmentation and file fragmentation stats.
    else {

        // Update the number of excees file fragments.
        VolData.NumExcessFrags -= llBeforeExtents - pFileExtentHeader->ExcessExtents;

        // File was defragmented file.
        if(llBeforeExtents && !pFileExtentHeader->ExcessExtents) {

            VolData.NumFraggedFiles--;
            VolData.FraggedSpace -= VolData.NumberOfRealClusters * VolData.BytesPerCluster;

            Message(TEXT("The file has been successfully defragmented."), -1, NULL);
            EH(LogEvent(MSG_ENGINE_DEFRAGMENT, ESICompressFilePath(VolData.cFileName)));
        }
        // Move of contiguous file to consolidate free space.
        // This includes compressed files with contiguous extents.
        else if(llBeforeExtents == pFileExtentHeader->ExcessExtents) {

            Message(TEXT("The file has been successfully moved to consolidate free space."), -1, NULL);
            EH(LogEvent(MSG_ENGINE_FREE_SPACE, ESICompressFilePath(VolData.cFileName)));
        }
        // The directory was contiguous and was fragmented to consolidate free space.
        else if(!llBeforeExtents && pFileExtentHeader->ExcessExtents) {

            VolData.NumFraggedFiles++;
            VolData.FraggedSpace += VolData.NumberOfRealClusters * VolData.BytesPerCluster;

            Message(TEXT("The file has been temporarily fragmented in order to consolidate free space."), -1, NULL);
            EH(LogEvent(MSG_ENGINE_FREE_SPACE, ESICompressFilePath(VolData.cFileName)));
        }
        // Validate data - keep track of the average number of fragments per file.
        if((VolData.NumFraggedFiles != 0) && (VolData.CurrentFile != 0)) {

            VolData.AveFragsPerFile = 
                (pFileExtentHeader->ExcessExtents + VolData.CurrentFile) * 100 /
                VolData.CurrentFile;
        }
        else {
            VolData.AveFragsPerFile = 100;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\remmsg.cpp ===
/*****************************************************************************************************************

FILENAME: RemMsg.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"

#include <windows.h>
#include "ErrMacro.h"
#include "Message.h"

extern BOOL bPopups;
extern BOOL bIdentifiedErrorPath;

BOOL
RemoteMessageBox(
	TCHAR* cMsg,
	TCHAR* cTitle
	)
{


//If this is set for messageboxes (not IoStress) then pop up a messagebox too.
if(bPopups && !bIdentifiedErrorPath){
	MessageBox(NULL, cMsg, cTitle, MB_OK);
	//Once an error message has been printed, don't print another.
	bIdentifiedErrorPath = TRUE;
}

	return TRUE;
}

BOOL
PrintRemoteMessageBox(
	TCHAR* pText
	)
{
	TCHAR * pTemp = pText;

	//The first string is the message, the second string is the title.
	pTemp += lstrlen(pText) + 1;

	MessageBox(NULL, pText, pTemp, MB_OK);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\vdebugglobal.cpp ===
#include "stdafx.h"
#include "vStandard.h"

VWCL_API int VShowLastErrorMessage(HWND hWndParent)
{
	TCHAR	szString[4096] =	{_T('\0')};
	DWORD	dwLastError =		GetLastError();
	
	if ( dwLastError )
		FormatMessage(	FORMAT_MESSAGE_FROM_SYSTEM,
						NULL,
						dwLastError,
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						szString,
						sizeof(szString)/sizeof(TCHAR),
						NULL);

	if ( szString[0] != _T('\0') )
	{
		#ifdef _CONSOLE
			ODS(szString);
		#else
			#ifdef VGetAppTitle
				return MessageBox(hWndParent, szString, VGetAppTitle(), MB_ICONINFORMATION);
			#else
				return MessageBox(hWndParent, szString, _T("DEBUG MESSAGE"), MB_ICONINFORMATION);
			#endif
		#endif
	}
	
	return IDOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\secattr.cpp ===
/**************************************************************************************************

FILENAME: SecAttr.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Security attribute related routines
    
**************************************************************************************************/



#include "stdafx.h"

extern "C"{
    #include <string.h>
    #include <stdio.h>
    #include <stdlib.h>
}

#include "Windows.h"


#include <accctrl.h>    // EXPLICIT_ACCESS, ACL related stuff
#include <aclapi.h>     // SetEntriesInAcl

#include "secattr.h"

BOOL
ConstructSecurityAttributes(
    PSECURITY_ATTRIBUTES  psaSecurityAttributes,
    SecurityAttributeType eSaType,
    BOOL                  bIncludeBackupOperator
    )
{
    DWORD           dwStatus;
    DWORD           dwAccessMask         = 0;
    BOOL            bResult = TRUE;
    PSID            psidBackupOperators  = NULL;
    PSID            psidAdministrators   = NULL;
    PSID            psidLocalSystem      = NULL;
    PACL            paclDiscretionaryAcl = NULL;
    SID_IDENTIFIER_AUTHORITY    sidNtAuthority       = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS     eaExplicitAccess [3];

    switch (eSaType) {

    case esatMutex: 
        dwAccessMask = MUTEX_ALL_ACCESS; 
        break;
        
    case esatSemaphore:
        dwAccessMask = SEMAPHORE_ALL_ACCESS;
        break;

    case esatEvent:
        dwAccessMask = EVENT_ALL_ACCESS;
        break;
        
    case esatFile:  
        dwAccessMask = FILE_ALL_ACCESS;  
        break;

    default:
        bResult = FALSE;
        break;
    }


    /*
    ** Initialise the security descriptor.
    */
    if (bResult) {
        bResult = InitializeSecurityDescriptor(psaSecurityAttributes->lpSecurityDescriptor,
            SECURITY_DESCRIPTOR_REVISION
            );
    }

    if (bResult && bIncludeBackupOperator) {
        /*
        ** Create a SID for the Backup Operators group.
        */
        bResult = AllocateAndInitializeSid(&sidNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_BACKUP_OPS,
            0, 0, 0, 0, 0, 0,
            &psidBackupOperators
            );
    }

    if (bResult) {
        /*
        ** Create a SID for the Administrators group.
        */
        bResult = AllocateAndInitializeSid(&sidNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            );

    }

    if (bResult) {
        /*
        ** Create a SID for the Local System.
        */
        bResult = AllocateAndInitializeSid(&sidNtAuthority, 
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem
            );
    }

    if (bResult) {
        /*
        ** Initialize the array of EXPLICIT_ACCESS structures for an
        ** ACEs we are setting.
        **
            ** The first ACE allows the Backup Operators group full access
            ** and the second, allowa the Administrators group full
            ** access.
        */

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the Administrators group full access to the directory
        eaExplicitAccess[0].grfAccessPermissions = FILE_ALL_ACCESS;
        eaExplicitAccess[0].grfAccessMode = SET_ACCESS;
        eaExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        eaExplicitAccess[0].Trustee.pMultipleTrustee = NULL;
        eaExplicitAccess[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        eaExplicitAccess[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        eaExplicitAccess[0].Trustee.ptstrName  = (LPTSTR) psidLocalSystem;

        eaExplicitAccess[1].grfAccessPermissions             = dwAccessMask;
        eaExplicitAccess[1].grfAccessMode                    = SET_ACCESS;
        eaExplicitAccess[1].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        eaExplicitAccess[1].Trustee.pMultipleTrustee         = NULL;
        eaExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
        eaExplicitAccess[1].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
        eaExplicitAccess[1].Trustee.ptstrName                = (LPTSTR) psidAdministrators;


        if (bIncludeBackupOperator) {
            eaExplicitAccess[2].grfAccessPermissions             = dwAccessMask;
            eaExplicitAccess[2].grfAccessMode                    = SET_ACCESS;
            eaExplicitAccess[2].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            eaExplicitAccess[2].Trustee.pMultipleTrustee         = NULL;
            eaExplicitAccess[2].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            eaExplicitAccess[2].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
            eaExplicitAccess[2].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
            eaExplicitAccess[2].Trustee.ptstrName                = (LPTSTR) psidBackupOperators;
        }


        /*
        ** Create a new ACL that contains the new ACEs.
        */
        dwStatus = SetEntriesInAcl(bIncludeBackupOperator ? 3 : 2,
                    eaExplicitAccess,
                    NULL,
                    &paclDiscretionaryAcl);
        
        if (ERROR_SUCCESS != dwStatus) {
            bResult = FALSE;
        }
    }

    if (bResult) {
        /*
        ** Add the ACL to the security descriptor.
        */
        bResult = SetSecurityDescriptorDacl(psaSecurityAttributes->lpSecurityDescriptor,
            TRUE,
            paclDiscretionaryAcl,
            FALSE
            );
    }

    if (bResult) {
        paclDiscretionaryAcl = NULL;
    }

    /*
    ** Clean up any left over junk.
    */
    if (NULL != psidLocalSystem) {
        FreeSid (psidLocalSystem);
        psidLocalSystem = NULL;
    }

    if (NULL != psidAdministrators) {
        FreeSid (psidAdministrators);
        psidAdministrators = NULL;
    }

    if (NULL != psidBackupOperators) {
        FreeSid (psidBackupOperators);
        psidBackupOperators = NULL;
    }
    
    if (NULL != paclDiscretionaryAcl) {
        LocalFree (paclDiscretionaryAcl);
        paclDiscretionaryAcl = NULL;
    }

    return bResult;
} /* ConstructSecurityAttributes () */


VOID 
CleanupSecurityAttributes(
    PSECURITY_ATTRIBUTES psaSecurityAttributes
    )
{
    BOOL    bSucceeded;
    BOOL    bDaclPresent         = FALSE;
    BOOL    bDaclDefaulted       = TRUE;
    PACL    paclDiscretionaryAcl = NULL;

    bSucceeded = GetSecurityDescriptorDacl (psaSecurityAttributes->lpSecurityDescriptor,
                        &bDaclPresent,
                        &paclDiscretionaryAcl,
                        &bDaclDefaulted);


    if (bSucceeded && bDaclPresent && !bDaclDefaulted && (NULL != paclDiscretionaryAcl)) {
        LocalFree (paclDiscretionaryAcl);
    }

} /* CleanupSecurityAttributes () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\uicommon.cpp ===
#include "stdafx.h"

#ifdef OFFLINEDK
    extern "C"{
        #include <stdio.h>
    }
#endif

#ifdef BOOTIME
    #include "Offline.h"
#else
    #include "Windows.h"
#endif

#include <winioctl.h>

extern "C" {
    #include "SysStruc.h"
}

#include "ErrMacro.h"

#include "DfrgCmn.h"
#include "DfrgRes.h"

#include "Alloc.h"

#define THIS_MODULE 'U'
#include "logfile.h"

//
// start of helpers for IsValidVolume functions below
//

/////////////////////////////////////////
// Is this a valid drive type?
// Check if we have a drive that is even in the ball park.
//
static BOOL IsValidDriveType(UINT uDriveType)
{
    //sks bug #211782 take out CDROM and RAMDISK to allow for DVD-RAM drives
    if (uDriveType == DRIVE_UNKNOWN     ||
        uDriveType == DRIVE_NO_ROOT_DIR ||
        uDriveType == DRIVE_REMOTE 
        ) {
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////
// Get a handle to a volume
//
static HANDLE GetVolumeHandle(PTCHAR cVolume)
{
    HANDLE hVolume = INVALID_HANDLE_VALUE;

    // Get a handle to the volume
    UINT uiErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    hVolume = CreateFile(cVolume, 
                         0, 
                         FILE_SHARE_READ|FILE_SHARE_WRITE, 
                         NULL, 
                         OPEN_EXISTING, 
                         FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING, 
                         NULL);

    SetErrorMode(uiErrorMode);

    return hVolume;
}

/////////////////////////////////////////
// Is this volume valid (actual work routine)
//
// Note: volumeName is required to get volumeLabel and fileSystem
//
static BOOL IsValidVolumeCheck(HANDLE hVolume,          // IN volume handle
                               UINT uDriveType,         // IN drive type
                               PTCHAR volumeName,       // IN volume name
                               PTCHAR volumeLabel,      // OUT volume label
                               PTCHAR fileSystem)       // OUT file system
{
    require(hVolume != INVALID_HANDLE_VALUE && hVolume != NULL);
    require(volumeName != NULL);

    BOOL                         bReturn = FALSE;       // assume not valid
    HANDLE                       hFsDevInfo = NULL;
    FILE_FS_DEVICE_INFORMATION * pFsDevInfo = NULL;

    // clear return values
    if (volumeLabel != NULL) {
        _tcscpy(volumeLabel, TEXT(""));
    }
    if (fileSystem != NULL) {
        _tcscpy(fileSystem, TEXT(""));
    }

    __try {

        // read-only, network, etc. check

        if (!AllocateMemory(sizeof(FILE_FS_DEVICE_INFORMATION) + MAX_PATH, 
                                            &hFsDevInfo, (void**) &pFsDevInfo)) {
            EH(FALSE);
            __leave;
        }

        IO_STATUS_BLOCK IoStatus = {0};

        NTSTATUS Status = NtQueryVolumeInformationFile(hVolume, 
                                                       &IoStatus, 
                                                       pFsDevInfo, 
                                                       sizeof(FILE_FS_DEVICE_INFORMATION) + 50, 
                                                       FileFsDeviceInformation);

        if (NT_SUCCESS(Status)) {

            if (pFsDevInfo->Characteristics & 
                (FILE_READ_ONLY_DEVICE | FILE_WRITE_ONCE_MEDIA | FILE_REMOTE_DEVICE)) {
                __leave;
            }
        }
        else {
            __leave;
        }


        // media check

        if (uDriveType == DRIVE_REMOVABLE) {

            DISK_GEOMETRY medias[20];
            DWORD nummedias = 0;
            DWORD numbytes;

            if (DeviceIoControl(hVolume, IOCTL_STORAGE_GET_MEDIA_TYPES, 
                                NULL, 0, medias, 20 * sizeof(DISK_GEOMETRY), &numbytes, NULL)) {

                nummedias = numbytes / sizeof(DISK_GEOMETRY);

                for (UINT i=0; i<nummedias; i++) {

                    switch (medias[i].MediaType) {

                    // these are OK
                    case F3_20Pt8_512:  // 3.5",  20.8MB, 512   bytes/sector
                    case FixedMedia:    // Fixed hard disk media
                    case F3_120M_512:   // 3.5",   120M Floppy
                    case F3_128Mb_512:  // 3.5" MO 128Mb   512 bytes/sector
                    case F3_230Mb_512:  // 3.5" MO 230Mb   512 bytes/sector
                        break;

                    // but nothing else is
                    default:
                        __leave;
                        break;
                    }
                }
            }
            else {
                
                GetLastError(); // debug

                // TODO: figure out why JAZ drives fail on the above call
                // we should probably __leave here, but then JAZ drives are filtered out
                // maybe we should EH so at least it will register albeit every second or two
                // question: do or should every removable drive type report supported media?
//              EH(FALSE);
//              __leave;
            }
        }

        // file system check

        TCHAR tmpVolumeLabel[100];
        TCHAR tmpFileSystem[20];

        TCHAR tmpVolumeName[GUID_LENGTH];
        _tcscpy(tmpVolumeName, volumeName);
        if (volumeName[_tcslen(tmpVolumeName) - 1] != TEXT('\\')){
            _tcscat(tmpVolumeName, TEXT("\\"));
        }

        BOOL isOk = GetVolumeInformation(tmpVolumeName, 
                                         tmpVolumeLabel, 
                                         100, 
                                         NULL, 
                                         NULL, 
                                         NULL, 
                                         tmpFileSystem, 
                                         20);

        if (!isOk) {
            __leave;
        }

        if (volumeLabel != NULL) {
            _tcscpy(volumeLabel, tmpVolumeLabel);
        }
        if (fileSystem != NULL) {
            _tcscpy(fileSystem, tmpFileSystem);
        }

        // Only NTFS, FAT or FAT32
        if (_tcscmp(tmpFileSystem, TEXT("NTFS")) &&
            _tcscmp(tmpFileSystem, TEXT("FAT"))  &&
            _tcscmp(tmpFileSystem, TEXT("FAT32"))) {

            __leave;    // if none of the above, bail
        }

        bReturn = TRUE; // all the checks "passed"
    }

    __finally {

        if (hFsDevInfo) {

            EH_ASSERT(GlobalUnlock(hFsDevInfo) == FALSE);
            EH_ASSERT(GlobalFree(hFsDevInfo) == NULL);
        }
    }

    return bReturn;
}

/////////////////////////////////////////
// Is this volume valid (drive letter only version)
//
BOOL IsValidVolume(TCHAR cDrive)
{

    // Check if we have a drive that is even in the ball park.
    // If so, then continue on and gather more data (mostly for removable drives)
    TCHAR cRootPath[100];
    _stprintf(cRootPath, TEXT("%c:\\"), cDrive);

    UINT uDriveType = GetDriveType(cRootPath);
    if (!IsValidDriveType(uDriveType)) {
        return FALSE;
    }
    
    // Get a handle to the volume
    TCHAR cVolume[MAX_PATH];
    _stprintf(cVolume, TEXT("\\\\.\\%c:"), cDrive);
    HANDLE hVolume = GetVolumeHandle(cVolume);

    if (hVolume == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // check volume
    BOOL bReturn = IsValidVolumeCheck(hVolume, uDriveType, cVolume, NULL, NULL);

    CloseHandle(hVolume);

    return bReturn;
}

/////////////////////////////////////////
// Is this volume valid (version 2)
//
// INPUT:
//  volumeName
//
// OUTPUT:
//  volumeLabel
//  fileSystem
//
BOOL IsValidVolume(PTCHAR volumeName, PTCHAR volumeLabel, PTCHAR fileSystem)
{
    BOOL bReturn = FALSE; // assume error


    if(!volumeName) {
        assert(0);
        return FALSE;
    }

    // Check if we have a drive that is even in the ball park.
    // If so, then continue on and gather more data (mostly for removable drives)
    UINT uDriveType = GetDriveType(volumeName);
    if (!IsValidDriveType(uDriveType)) {
        return FALSE;
    }

    //sks 8/30/2000 fix for prefix bug #109657
    TCHAR tmpVolumeName[GUID_LENGTH + 1];
    _tcsncpy(tmpVolumeName, volumeName, GUID_LENGTH);
    tmpVolumeName[GUID_LENGTH] = (TCHAR) NULL;

    // strip off the trailing whack
    if (tmpVolumeName[_tcslen(tmpVolumeName)-1] == TEXT('\\')){
        tmpVolumeName[_tcslen(tmpVolumeName)-1] = (TCHAR) NULL;
    }

    // Get a handle to the volume
    HANDLE hVolume = GetVolumeHandle(tmpVolumeName);

    if (hVolume == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // check volume
    bReturn = IsValidVolumeCheck(hVolume, uDriveType, volumeName, volumeLabel, fileSystem);

    CloseHandle(hVolume);

    return bReturn;
}

// is the file system supported?
BOOL IsVolumeWriteable(PTCHAR volumeName, DWORD* dLastError)
{
    *dLastError = 0;
    // create a temp file name
    TCHAR cTempFile[MAX_PATH + 50];

    if (0 == GetTempFileName(volumeName, L"DFRG", 0, cTempFile)) {
        *dLastError = GetLastError();
        return FALSE;
    }

    // get rid of the temp file
    DeleteFile(cTempFile);

    // true means that we can write to it
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\textblock.cpp ===
/*****************************************************************************************************************

FILENAME: TextBlock.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#include "stdafx.h"
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdarg.h>
#include <locale.h>
#include <tchar.h>
#include "ErrMacro.h"
#include "DfrgRes.h"
#include "TextBlock.h"

#include "secattr.h"

#include <stdlib.h>

PTCHAR
CommafyNumberFloat(
     double number,
     BOOL bDecimal,
     PTCHAR stringBuffer,
     UINT stringBufferLength
    );

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Constructor for CTextBlock

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
CTextBlock::CTextBlock(void)
{
    // initialize
    m_isFixedWidth = m_isUseTabs = m_isUseCRLF = FALSE;
    m_colCount = m_currentCol = 0;
    m_hResource = NULL;
    m_pEndOfBuffer = m_pText = NULL;

    // Allocate 64K
    EV((m_hMemory = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, 0x10000)) != NULL);

    // Lock the memory and get the pointer
    m_pText = (PTCHAR) GlobalLock(m_hMemory);
    EV(m_pText);

    m_pEndOfBuffer = m_pText;
}

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
CTextBlock::~CTextBlock(void)
{
    if (m_hMemory){
        EH_ASSERT(GlobalUnlock(m_hMemory) == FALSE);
        EH_ASSERT(GlobalFree(m_hMemory) == NULL);
    }
}

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
__cdecl CTextBlock::WriteToBuffer(
    PTCHAR cFormat,
    ...
    )
{
    // cannot have fixed width with no columns defined
    assert((m_isFixedWidth == FALSE) || (m_isFixedWidth && m_colCount > 0));

    va_list argptr;
    va_start(argptr, cFormat);  // init the argument list

    if (m_isFixedWidth){
        TCHAR buffer[4 * MAX_PATH];
        int   num;
        // print the data into a temp buffer
        num = vswprintf(buffer, cFormat, argptr);
        assert(num < 4 * MAX_PATH);
        // concat and pad onto text buffer
        //m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, TEXT("%-*s"), m_colWidth[m_currentCol], buffer);
        WriteToBufferAndPad(buffer, m_colWidth[m_currentCol]);
    }
    else{
        m_pEndOfBuffer += vswprintf(m_pEndOfBuffer, cFormat, argptr);
    }
    
    va_end(argptr);

    // increment the column counter
    m_currentCol++;

}

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
CTextBlock::WriteToBufferLL(
    LONGLONG number
    )
{
    // cannot have fixed width with no columns defined
    assert((m_isFixedWidth == FALSE) || (m_isFixedWidth && m_colCount > 0));

    // convert to a string, putting commas in if needed
    TCHAR tmpBuffer[256];
    CommafyNumber(number, tmpBuffer, sizeof(tmpBuffer) / sizeof(TCHAR));

    if (m_isFixedWidth){
        // concat and pad onto text buffer
        WriteToBufferAndPad(tmpBuffer, m_colWidth[m_currentCol]);
        //m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, TEXT("%-*s"), m_colWidth[m_currentCol], tmpBuffer);
    }
    else{
        m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, tmpBuffer);
    }

    // increment the column counter
    m_currentCol++;

}
/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
CTextBlock::WriteToBuffer(
                          UINT resourceID
                          )
{
    // cannot have fixed width with no columns defined
    assert((m_isFixedWidth == FALSE) || (m_isFixedWidth && m_colCount > 0));

    // must have assigned a handle to the resource
    assert(m_hResource);

    TCHAR buffer[256];
    EH_ASSERT(LoadString(m_hResource, resourceID, buffer, sizeof(buffer)/sizeof(TCHAR)));

    if (m_isFixedWidth){
        WriteToBufferAndPad(buffer, m_colWidth[m_currentCol]);
    }
    else{
        m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, TEXT("%s"), buffer);
    }

    // increment the column counter
    m_currentCol++;
}

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
CTextBlock::SetColumnWidth(
               UINT col, 
               UINT colWidth
               )
{
    // cannot have fixed width with no columns defined
    assert(m_isFixedWidth);
    assert(m_colCount > 0);

    // the column number must be less than the column count
    assert(col < m_colCount);

    m_colWidth[col] = colWidth;
}

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
CTextBlock::WriteTab(
                     void
                     )
{
    // only write the tab if the tab feature has been turned on
    if (m_isUseTabs)
        m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, TEXT("\t"));
}

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
CTextBlock::WriteNULL(
                     void
                     )
{
    m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, TEXT("\0"));
}

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
CTextBlock::EndOfLine(
                      void
                     )
{
    // the first few lines here are to strip off trailing spaces
    PTCHAR pEOL = m_pEndOfBuffer-1;
    while (*pEOL == TEXT(' ') && pEOL != m_pText){
        pEOL--;
    }
    m_pEndOfBuffer = pEOL + 1;
    *m_pEndOfBuffer = NULL;

    // only write the tab if the tab feature has been turned on
    if (m_isUseCRLF)
        m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, TEXT("\r\n"));

    // reset the col counter to col 0 (start of next line)
    m_currentCol = 0;
}

/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
CTextBlock::WriteByteCount(
    LONGLONG number
    )
{
    TCHAR buffer[256];

    // formats the number and appends the units
    FormatNumber(m_hResource, number, buffer);

    // write the number and units to the text block
    WriteToBuffer(buffer);
}


void
CTextBlock::FormatNum(
             HINSTANCE hResource,
             LONGLONG number,
             PTCHAR buffer
    )
{
    FormatNumber(hResource, number, buffer);
}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:

DATA STRUCTURES:
    None.

GLOBALS:
    None.

INPUT:

RETURN:
    The number of characters written.
    0 on error.
*/

DWORD
FormatNumber(
             HINSTANCE hResource,
             LONGLONG number,
             PTCHAR buffer
    )
{
    UINT resourceID = IDS_UNITS_GB;
    double numberFloat = 0;
    BOOL bDecimal = FALSE;

    numberFloat = (double) number;

    __try{
        //Byte range.
        if (number < 1024){
            resourceID = IDS_UNITS_BYTES;
            __leave;
        }

        // KB range
        numberFloat = (double) number / 1024;
        if (numberFloat < 1024){
            resourceID = IDS_UNITS_KB;
            __leave;
        }

        // MB range
        numberFloat /= 1024;
        if (numberFloat < 1024){
            resourceID = IDS_UNITS_MB;
            __leave;
        }

        // GB range
        //This is the default range that we will display, so we dont need to test number
        numberFloat /= 1024;
        resourceID = IDS_UNITS_GB;
        if (numberFloat < 100) {
            bDecimal = TRUE;
        }
        __leave;

    }

    __finally {
        // load the "units" string from resources
        TCHAR units[30];
        EH_ASSERT(LoadString(hResource, resourceID, units, sizeof(units)/sizeof(TCHAR)));

        // convert to a string, putting commas in if needed
        TCHAR tmpBuffer[256];
        CommafyNumberFloat(numberFloat, bDecimal, tmpBuffer, sizeof(tmpBuffer) / sizeof(TCHAR));

        // concat a spacer
        _tcscat(tmpBuffer, TEXT(" "));

        // concat the units
        _tcscat(tmpBuffer, units);

        // write the number and units to the text block
        _tcscpy(buffer, tmpBuffer);

    }

    return _tcslen(buffer);
}

DWORD
FormatNumberMB(
             HINSTANCE hResource,
             LONGLONG number,
             PTCHAR buffer
    )
{
    // MB range
    double numberMB = (double) (number / 0x100000); // 1 MB
    UINT resourceID = IDS_UNITS_MB;
    BOOL decimal = FALSE;

    // if it turned out to be 0, switch over to KB
    if (numberMB < 1){
        numberMB = (double) number / 1024; // 1 KB
        resourceID = IDS_UNITS_KB;
    }
    else if (numberMB > 1024){ // if it is greater than 1024 MB, switch to GB
        numberMB /= 1024;
        resourceID = IDS_UNITS_GB;
        if (numberMB < 100) {
            decimal = TRUE;
        }
    }

    // load the "units" string from resources
    TCHAR units[30];
    EH_ASSERT(LoadString(hResource, resourceID, units, sizeof(units)/sizeof(TCHAR)));

    // convert to a string, putting commas in if needed
    TCHAR tmpBuffer[256];
    CommafyNumberFloat(numberMB, decimal, tmpBuffer, sizeof(tmpBuffer) / sizeof(TCHAR));

    // concat a spacer
    _tcscat(tmpBuffer, TEXT(" "));

    // concat the units
    _tcscat(tmpBuffer, units);

    // write the number and units to the text block
    _tcscpy(buffer, tmpBuffer);

    return _tcslen(buffer);
}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This takes the source string and works from right to left,
    copying chars from the source to the target, adding commas
    every third character

DATA STRUCTURES:
    None.

GLOBALS:
    None.

INPUT:

RETURN:
    Pointer to buffer with commafied number or NULL if error
*/


PTCHAR
CommafyNumber(
     LONGLONG number,
     PTCHAR stringBuffer,
     UINT stringBufferLength
    )
{
    EN_ASSERT(stringBuffer);
    EN_ASSERT(stringBufferLength);

    TCHAR sourceString[256];
    TCHAR targetString[256];
    TCHAR tcThousandsSep[2] = {TEXT(','), 0};

    struct lconv *locals = localeconv();
    if (locals && (locals->thousands_sep) && (*(locals->thousands_sep) != 0)) {
        _stprintf(tcThousandsSep, TEXT("%C"), *(locals->thousands_sep));
    }


    UINT uGrouping = 0;
    if (locals && (locals->grouping)) {
        uGrouping = atoi(locals->grouping);
    }
    if(uGrouping == 0)
    {
        uGrouping = 3;      //default value if its not supported
    }

    // convert LONGLONG number to a Unicode string
    _stprintf(sourceString, TEXT("%I64d"), number);

    // point the source pointer at the null terminator
    PTCHAR pSource = sourceString + _tcslen(sourceString);

    // put the target pointer at the end of the target buffer
    PTCHAR pTarget = targetString + sizeof(targetString) / sizeof(TCHAR) - 1;

    // write the null terminator
    *pTarget = NULL;

    for (UINT i=0; i<_tcslen(sourceString); i++) {
        if (i>0 && i%uGrouping == 0) {
            pTarget--;
            *pTarget = tcThousandsSep[0];
        }

        pTarget--;
        pSource--;
        *pTarget = *pSource;
    }

    if (stringBufferLength > _tcslen(pTarget)){
        _tcscpy(stringBuffer, pTarget);
    }
    else{
        _tcscpy(stringBuffer, TEXT(""));
    }
    return stringBuffer;
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This takes the source string and works from right to left,
    copying chars from the source to the target, adding commas
    every third character

DATA STRUCTURES:
    None.

GLOBALS:
    None.

INPUT:

RETURN:
    Pointer to buffer with commafied number or NULL if error
*/

PTCHAR
CommafyNumberFloat(
     double number,
     BOOL bDecimal,
     PTCHAR stringBuffer,
     UINT stringBufferLength
    )
{
    EN_ASSERT(stringBuffer);
    EN_ASSERT(stringBufferLength);

    TCHAR sourceString[256];
    TCHAR targetString[256];
    TCHAR tcThousandsSep[2] = {TEXT(','), 0};


    struct lconv *locals = localeconv();

    if (locals && (locals->thousands_sep) && (*(locals->thousands_sep) != 0)) {
        _stprintf(tcThousandsSep, TEXT("%C"), *(locals->thousands_sep));
    }

    UINT uGrouping = 0;
    if (locals && (locals->grouping)) {
        uGrouping = atoi(locals->grouping);
    }
    if(uGrouping == 0)
    {
        uGrouping = 3;      //default value if its not supported
    }


    if (bDecimal) {
        // convert double number to a Unicode string
        _stprintf(sourceString, TEXT("%0.02f"), number);
    }
    else {
        // convert double number to a Unicode string
        _stprintf(sourceString, TEXT("%0.0f"), number);
    }

    // point the source pointer at the null terminator
    PTCHAR pSource = sourceString + _tcslen(sourceString);

    // put the target pointer at the end of the target buffer
    PTCHAR pTarget = targetString + sizeof(targetString) / sizeof(TCHAR) - 1;

    // write the null terminator
    *pTarget = NULL;

    if (bDecimal) {
        for (UINT j = 0; j < 3; j++) {
            pTarget--;
            pSource--;
            *pTarget = *pSource;
        }
    }


    for (UINT i=0; i<_tcslen(sourceString)-(bDecimal ? 3 : 0); i++) {
        if (i>0 && i%uGrouping == 0) {
            pTarget--;
            *pTarget = tcThousandsSep[0];
        }

        pTarget--;
        pSource--;
        *pTarget = *pSource;
    }

    if (stringBufferLength > _tcslen(pTarget)){
        _tcscpy(stringBuffer, pTarget);
    }
    else{
        _tcscpy(stringBuffer, TEXT(""));
    }
    return stringBuffer;
}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:

DATA STRUCTURES:
    None.

GLOBALS:
    None.

INPUT:

RETURN:
*/

BOOL CTextBlock::StoreFile(
    IN TCHAR* cStoreFileName,
    IN DWORD dwCreate
    )
{

    HANDLE hFileHandle = NULL;
    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;
    
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = FALSE;

    if (!ConstructSecurityAttributes(&saSecurityAttributes, esatFile, FALSE)) {
        return FALSE;
    }

    // Create a new file for this text
    hFileHandle = CreateFile(
        cStoreFileName,
        GENERIC_WRITE,
        0, // no sharing
        &saSecurityAttributes,
        dwCreate,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    CleanupSecurityAttributes(&saSecurityAttributes);
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

    // No error handling here!  The calling function may wish
    // to handle different situations in different ways. Save the error.
    if(hFileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    DWORD dwWriteCount;     // Total bytes written during WriteFile
    DWORD dwByteCount = _tcslen(m_pText) * sizeof(TCHAR);

    // The hex pattern FFFE must be the first 2 characters of a Unicode text file
    char unicodeMarker[3];
    unicodeMarker[0] = '\xFF';
    unicodeMarker[1] = '\xFE';
    unicodeMarker[2] = NULL;

    // write the Unicode marker
    EF(WriteFile(hFileHandle, unicodeMarker, 2, &dwWriteCount, NULL));

    // write the rest of the text block
    EF(WriteFile(hFileHandle, m_pText, dwByteCount, &dwWriteCount, NULL));

    CloseHandle(hFileHandle);

    // Make sure we wrote the correct amount.
    if (dwByteCount == dwWriteCount)
        return TRUE;

    return FALSE;
}
/*****************************************************************************************************************
COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    

GLOBAL VARIABLES:
    None

INPUT:
    None

RETURN:
    None
*/
void
CTextBlock::WriteToBufferAndPad(
                                PTCHAR buffer, 
                                UINT length
                                )
{
    // concat and pad onto text buffer
    m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, TEXT("%s"), buffer);

    char outputBuffer[300];
    int ret = WideCharToMultiByte(
        GetACP(),
        //CP_ACP,
        0,
        buffer,
        -1,
        outputBuffer,
        sizeof(outputBuffer),
        NULL,
        NULL);

    if (((int)length - (int)strlen(outputBuffer)) > 0) {
        m_pEndOfBuffer += _stprintf(m_pEndOfBuffer, TEXT("%-*s"), length - strlen(outputBuffer), TEXT(""));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\vwindowappcore.cpp ===
#include "stdafx.h"
#include "vApplication.hpp"
#include "vWindow.hpp"

// If VWCL_WRAP_WINDOWS_ONLY is defined, there is no need to register window classes
#ifdef VWCL_WRAP_WINDOWS_ONLY
	#ifndef VWCL_NO_REGISTER_CLASSES
		#define VWCL_NO_REGISTER_CLASSES
	#endif
#endif

#ifndef VWCL_NO_GLOBAL_APP_OBJECT
	// The one and only VApplication object
	VApplication VTheApp;

	// Access function
	VWCL_API VApplication* VGetApp()
		{ return &VTheApp; }
#endif

// Return a static string buffer to the applications title, or name
LPCTSTR		VGetAppTitle()
	{ return VGetApp()->AppTitle(); }

// Return the show command (ShowWindow() SW_xxx constant passed on command line)
int			VGetCommandShow()
	{ return VGetApp()->GetCommandShow(); }

// Return the global instance handle of the application or DLL
HINSTANCE	VGetInstanceHandle()
	{ return VGetApp()->GetInstanceHandle(); }

// Return the instance handle where resources are held
HINSTANCE	VGetResourceHandle()
	{ return VGetApp()->ResourceHandle(); }

// ***** Global Function to translate dialog messages *****
#ifndef VWCL_WRAP_WINDOWS_ONLY
	VWCL_API BOOL VTranslateDialogMessage(LPMSG lpMsg)
	{
		HWND hWndTop = lpMsg->hwnd;

		// Obtain the top level window. All dialogs are typically defined as top level popups
		while ( hWndTop )
		{
			if ( GetWindowLong(hWndTop, GWL_STYLE) & WS_CHILD )
				hWndTop = GetParent(hWndTop);
			else
				break;
		}

		// Obtain the associated window pointer (if a VWCL window)
		VWindow* pWindow = (hWndTop) ? VGetApp()->VWindowFromHandle(hWndTop) : NULL;
    
		if ( !pWindow )
			return FALSE;

		BOOL bResult = FALSE;

		if ( pWindow->IsVDialogType() )
			bResult = IsDialogMessage(hWndTop, lpMsg);
		else if ( pWindow->RTTI() == VWindow::VWCL_RTTI_PROPERTY_SHEET )
		{
			if ( PropSheet_GetCurrentPageHwnd(hWndTop) )
				bResult = PropSheet_IsDialogMessage(hWndTop, lpMsg);
			else
				pWindow->DestroyWindow();
		}

		// Return result.
		return bResult;
	}
#endif

// ***** VWindow *****
#ifndef VWCL_WRAP_WINDOWS_ONLY
	BOOL VWindow::Attach(HWND hWnd)
		{ assert(hWnd && ::IsWindow(hWnd)); return VGetApp()->Attach(this, hWnd); }

	BOOL VWindow::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, LPRECT lpRect, HWND hWndParent, UINT nIDorMenu, BOOL bDontCallPostCreateWindow)
	{
		// Attemting to create a window for a VWindow object that already has a window attached to it!
		assert(!GetSafeWindow());

		CREATESTRUCT cs;
		ZeroMemory(&cs, sizeof(cs));

		cs.lpszClass =	(lpszClassName) ? lpszClassName : VWINDOWCLASS;
		cs.lpszName =	lpszWindowName;
		cs.style =		dwStyle;
		cs.hMenu =		(HMENU)IntToPtr(nIDorMenu);
		cs.hwndParent =	hWndParent;
		
		if ( lpRect )
		{
			cs.x =	lpRect->left;
			cs.y =	lpRect->top;
			cs.cx = lpRect->right - lpRect->left;
			cs.cy = lpRect->bottom - lpRect->top;
		}
		else
			cs.x = cs.y = cs.cx = cs.cy = CW_USEDEFAULT;

		return (VGetApp()->VCreateWindow(this, &cs, bDontCallPostCreateWindow)) ? TRUE : FALSE;
	}

	void VWindow::Detach()
		{ VGetApp()->Detach(this); }

	LRESULT	VWindow::WindowProc(HWND hWnd, UINT nMessage, WPARAM wParam, LPARAM lParam)
	{
		// Implement support for base class message overrides
		LRESULT lResult = 1;

		switch ( nMessage )
		{
			case WM_CLOSE:
				OnClose();
				return 0;

			case WM_COMMAND:
				lResult = OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
				break;

			case WM_CREATE:
				if ( OnCreate((LPCREATESTRUCT)lParam) == -1 )
				{
					if ( GetSafeWindow() )
					{
						DestroyWindow();
						m_hWindow = NULL;
					}
					return -1;
				}
				return 0;

			case WM_DESTROY:
				lResult = OnDestroy();
				break;

			case WM_NOTIFY:
			{
				LPNMHDR lpNMHDR = (LPNMHDR)lParam;
				
				// Support for reflected WM_NOTIFY messages. Derived class must
				// return 0 is message was handled, -1 if handled and parent should
				// NOT be notified, or 1 if message was not handled and parent should
				// be notified. If -1 is returned, derived classes must also set
				// the pointer in lpLParam to the return value expected by the common control
				VWindow* pChildWnd = VGetApp()->VWindowFromHandle(lpNMHDR->hwndFrom);

				LPARAM lCommonControlResult;

				if ( pChildWnd )
					lResult = pChildWnd->OnReflectedNotify(lpNMHDR, lCommonControlResult);
				
				// Return result code immediatly to common control if message
				// should not be sent to the parent and a return value is expected
				// by the common control
				if ( lResult == -1 )
					return lCommonControlResult;
				else
					lResult = OnNotify((int)wParam, (LPNMHDR)lParam);
				
				break;
			}

			case WM_PAINT:
				lResult = OnPaint();
				break;

			case WM_SIZE:
				lResult = OnSize(wParam, LOWORD(lParam), HIWORD(lParam));
				break;
		}

		// If lResult is 0 skip next check
		if ( lResult == 0 )
			return 0;

		// If intended for a dialog box, lResult should be 0
		if ( IsVDialogType() )
			return 0;

		// Call was not handled in any derived classes. If subclassed, call original WndProc
		return (m_lpfnOldWndProc) ? CallWindowProc(m_lpfnOldWndProc, m_hWindow, nMessage, wParam, lParam) : DefWindowProc(m_hWindow, nMessage, wParam, lParam);
	}
#endif // VWCL_WRAP_WINDOWS_ONLY

// ***** VApplication *****
#ifndef VWCL_WRAP_WINDOWS_ONLY
	LPVWCL_WINDOW_MAP VApplication::AllocWindowMap(VWindow* pWindow, HWND hWnd)
	{
		// This one must be known. hWnd is optional
		assert(pWindow);

		// Allocate new map
		LPVWCL_WINDOW_MAP lpMap = new VWCL_WINDOW_MAP;
		
		// Add to list of maps and return pMap
		if ( lpMap && m_listWindowMaps.Add(lpMap) != -1 )
		{
			// Initialize map
			lpMap->pWindow =	pWindow;
			lpMap->hWnd =		hWnd;
		}
		else
		{
			delete lpMap;
			lpMap = NULL;
		}

		return lpMap;
	}

	BOOL VApplication::Attach(VWindow* pWindow, HWND hWnd)
	{
		// pWindow and hWnd must be known and valid
		assert(pWindow && hWnd && ::IsWindow(hWnd));

		// If window proc is our own, Attach() was not needed
		// Return success if this is the case
		if ( GetWindowLongPtr(hWnd, GWLP_WNDPROC) == (LONG_PTR)&WindowProc )
			return TRUE;

		// Does a map entry for this object already exist? If not,
		// allocate one now
		int nIndex = m_listWindowMaps.Find(pWindow);
		LPVWCL_WINDOW_MAP lpMap = (nIndex == -1) ? AllocWindowMap(pWindow, hWnd) : (LPVWCL_WINDOW_MAP)m_listWindowMaps[nIndex];
		
		if ( lpMap )
		{
			// Verify handles in objects. This will have been already
			// set if we owned the WndProc, but not set yet if not
			// because the subclass has yet to come
			lpMap->hWnd =			hWnd;
			lpMap->pWindow =		pWindow;
			pWindow->m_hWindow =	hWnd;

			// Subclass window
			pWindow->m_lpfnOldWndProc = (WNDPROC)pWindow->SetWindowLongPtr(GWLP_WNDPROC, (LONG_PTR)WindowProc);

			// Call PostAttachWindow()
			pWindow->PostAttachWindow();
		}

		return (lpMap) ? TRUE : FALSE;
	}

	LPCTSTR VApplication::CurrentFile(LPCTSTR lpszFileName, BOOL bUpdateCaption)
	{
		// Save current filename string
		m_strCurrentFile.String(lpszFileName);

		#ifndef _CONSOLE
			if ( bUpdateCaption )
			{
				// The main window pointer and name must be known
				assert(MainWindow() && AppTitle());

				LPCTSTR lpszTitle = (lpszFileName) ? lpszFileName : _T("Untitled");

				// Allocate string large enough for app title, doc title, and dash
				VSimpleString s;

				if ( s.String(AppTitle(), lstrlen(lpszTitle) + 3) )
				{
					lstrcat(s, _T(" - "));
					lstrcat(s, lpszTitle);
					MainWindow()->SetWindowText(s);
				}
				else
					MainWindow()->SetWindowText(AppTitle());
			}
		#endif

		return m_strCurrentFile.String();
	}

	void VApplication::Detach(VWindow* pWindow)
	{
		// Must be known
		assert(pWindow && pWindow->GetSafeWindow());

		// If window is subclassed, VWindow::m_lpfnOldWndProc will be non-NULL
		// so we need to set this value back in the window object
		if ( pWindow->m_lpfnOldWndProc )
			SetWindowLongPtr(pWindow->m_hWindow, GWLP_WNDPROC, (LONG_PTR)pWindow->m_lpfnOldWndProc);

		// Find map and remove it
		int nSize = m_listWindowMaps.Size();

		for ( int i = 0; i < nSize; i++ )
		{
			LPVWCL_WINDOW_MAP lpMap = (LPVWCL_WINDOW_MAP)m_listWindowMaps[i];
			
			if ( lpMap->pWindow == pWindow )
			{
				FreeWindowMap(lpMap);
				break;
			}
		}
	}

	void VApplication::FreeWindowMap(LPVWCL_WINDOW_MAP lpMap)
	{
		// Must be known
		assert(lpMap);

		int nIndex = m_listWindowMaps.Find(lpMap);

		if ( nIndex != -1 )
		{
			m_listWindowMaps.RemoveAt(nIndex);
			delete lpMap;
		}
	}

	LRESULT VApplication::HandleMessage(HWND hWnd, UINT nMessage, WPARAM wParam, LPARAM lParam)
	{
		// Set current message struct items
		m_CurrentMessage.hwnd =		hWnd;
		m_CurrentMessage.message =	nMessage;
		m_CurrentMessage.wParam =	wParam;
		m_CurrentMessage.lParam =	lParam;

		LRESULT lResult =			0;
		LPVWCL_WINDOW_MAP lpMap =	NULL;

		// As an optimization, look at last known index into map to see if we get
		// a hit. Since windows messages usually come by the hundreds, don't waste
		// time looking them up in a map if we can get a hit here
		if ( m_nLastKnownMapIndex != - 1 && m_nLastKnownMapIndex < m_listWindowMaps.Size() )
		{
			LPVWCL_WINDOW_MAP lpThisMap = (LPVWCL_WINDOW_MAP)m_listWindowMaps[m_nLastKnownMapIndex];
			assert(lpThisMap);
		
			if ( lpThisMap->hWnd == hWnd )
				lpMap = lpThisMap;
		}

		if ( !lpMap )
		{
			// Lookup hWnd in map to find VWindow object and call object window procedure
			// There may be a window pointer but no HWND when a window is
			// being created, so if this is found assume the VWindow object
			// is valid, but that the hWnd is not
			int nSize = m_listWindowMaps.Size();

			for ( int i = 0; i < nSize; i++ )
			{
				LPVWCL_WINDOW_MAP lpThisMap = (LPVWCL_WINDOW_MAP)m_listWindowMaps[i];
				assert(lpThisMap);
		
				if ( lpThisMap->hWnd == hWnd || (lpThisMap->pWindow && !lpThisMap->hWnd) )
				{
					lpMap =					lpThisMap;
					m_nLastKnownMapIndex =	i;
					break;
				}
			}
		}

		if ( lpMap )
		{
			// Verify map and object settings
			lpMap->hWnd =				hWnd;
			lpMap->pWindow->m_hWindow =	hWnd;

			lResult = lpMap->pWindow->WindowProc(hWnd, nMessage, wParam, lParam);

			// If window destroyed, remove from map
			if ( nMessage == WM_DESTROY )
			{
				VWindow* pWindow = lpMap->pWindow;
				// Remove from list and free map memory
				FreeWindowMap(lpMap);
				// No more known index
				m_nLastKnownMapIndex = -1;
				// Set window handle in object to NULL
				pWindow->m_hWindow = NULL;
				// Possibly call PostNcDestroy() in derived object
				pWindow->PostNcDestroy();
			}
		}

		return lResult;
	}
#endif // VWCL_WRAP_WINDOWS_ONLY

BOOL VApplication::Initialize(HINSTANCE hInstance, int nCommandShow, UINT nIDMenu, UINT nIDIcon, HBRUSH hBackgroundBrush)
{
	assert(hInstance);

	// Global application object should be uninitialized, you are walking on it!
	assert(m_hInstance == NULL);
	m_hInstance = hInstance;
	
	// If resource handle was not previous set, set to same as application
	if ( !m_hResource )
		m_hResource = hInstance;

	// Initialize Component Object Model
	#ifdef VWCL_INIT_OLE
		m_hrOleInitialize = OleInitialize(NULL);
		
		if ( FAILED(m_hrOleInitialize) )
			return FALSE;
	#endif

	// Icon is loaded from application instance in almost all cases
	if ( nIDIcon )
	{
		Icon(LoadIcon(m_hInstance, MAKEINTRESOURCE(nIDIcon)));

		// If icon was not found in instance handle, try resources
		if ( !Icon() )
			Icon(LoadIcon(m_hResource, MAKEINTRESOURCE(nIDIcon)));

		// Icon was specified but not loaded!
		assert(Icon());
	}
	
	m_nCommandShow = nCommandShow;

	// Initialize common controls
	#ifdef VWCL_INIT_COMMON_CONTROLS
		InitCommonControls();
	#endif

	#ifndef VWCL_NO_REGISTER_CLASSES
		// Register window classes
		WNDCLASS wc;
		
		wc.style =			CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
		wc.lpfnWndProc =	WindowProc;
		wc.cbClsExtra =		0;
		wc.cbWndExtra =		0;
		wc.hInstance =		m_hInstance;
		wc.hCursor =		LoadCursor(NULL, IDC_ARROW);
		assert(wc.hCursor);
		wc.hbrBackground =	hBackgroundBrush;
		
		// Main window frame
		wc.hIcon =			Icon();
		wc.lpszMenuName =	(nIDMenu) ? MAKEINTRESOURCE(nIDMenu) : NULL;
		wc.lpszClassName =	VMAINWINDOWCLASS;
		
		if ( RegisterClass(&wc) == 0 )
			return FALSE;

		// Register standard window
		wc.hIcon =			NULL;
		wc.lpszMenuName =	NULL;
		wc.lpszClassName =	VWINDOWCLASS;

		if ( RegisterClass(&wc) != 0 )
			return TRUE;

		return FALSE;
	#endif	// VWCL_NO_REGISTER_CLASSES

	return TRUE;
}

#ifndef VWCL_WRAP_WINDOWS_ONLY
	BOOL VApplication::VCreateWindow(VWindow* pWindow, LPCREATESTRUCT lpCreateStruct, BOOL bDontCallPostCreateWindow)
	{
		// These must be known
		assert(pWindow && lpCreateStruct);

		// You have not called VApplication::Initialize() before creating window objects!");
		assert(m_hInstance && m_hResource);

		LPVWCL_WINDOW_MAP lpMap = AllocWindowMap(pWindow);

		// Possibly call derived class PreCreateWindow
		if ( lpMap && pWindow->PreCreateWindow(lpCreateStruct) )
		{
			#ifdef _DEBUG
				SetLastError(0);
			#endif

			// Create the window
			HWND hWnd = CreateWindowEx(	lpCreateStruct->dwExStyle,
										lpCreateStruct->lpszClass,
										lpCreateStruct->lpszName,
										lpCreateStruct->style,
										lpCreateStruct->x,
										lpCreateStruct->y,
										lpCreateStruct->cx,
										lpCreateStruct->cy,
										lpCreateStruct->hwndParent,
										lpCreateStruct->hMenu,
										m_hInstance,
										lpCreateStruct->lpCreateParams);

			#ifdef _DEBUG
				if ( hWnd == NULL || ::IsWindow(hWnd) == FALSE )
					VShowLastErrorMessage(NULL);
			#endif

			if ( hWnd && ::IsWindow(hWnd) )
			{
				// Verify map and window objects are initialized
				lpMap->hWnd =			hWnd;
				lpMap->pWindow =		pWindow;
				pWindow->m_hWindow =	hWnd;
				
				// Make sure window is subclassed
				if ( Attach(pWindow, hWnd) )
				{
					// Call PostCreateWindow() and destroy window if FALSE is returned
					if ( bDontCallPostCreateWindow || pWindow->PostCreateWindow() )
						return TRUE;
				}
			}
		}

		// If we made it this far, an error occurred

		// If pWindow->m_hWindow is valid, destroy it
		// Make sure handle in VWindow is NULL
		pWindow->DestroyWindow();
		pWindow->m_hWindow = NULL;

		// Window creation failed. Since our shared WndProc may not
		// have been called, and WM_DESTROY caught, we may need
		// to remove the map ourselves
		if ( lpMap )
			FreeWindowMap(lpMap);

		return FALSE;
	}

	VWindow* VApplication::VWindowFromHandle(HWND hWnd)
	{
		VWindow* pWindow = NULL;

		if ( hWnd && IsWindow(hWnd) )
		{
			// Find hWnd in window list and return VWindow object pointer
			int nSize = m_listWindowMaps.Size();
			
			for ( int i = 0; i < nSize; i++ )
			{
				LPVWCL_WINDOW_MAP lpMap = (LPVWCL_WINDOW_MAP)m_listWindowMaps[i];
				assert(lpMap);
				
				if ( lpMap->hWnd == hWnd )
				{
					pWindow = lpMap->pWindow;
					break;
				}
			}
		}

		return pWindow;
	}

	LRESULT CALLBACK VApplication::	WindowProc(HWND hWnd, UINT nMessage, WPARAM wParam, LPARAM lParam)
		{ assert(VGetApp()); return VGetApp()->HandleMessage(hWnd, nMessage, wParam, lParam); }
#endif // VWCL_WRAP_WINDOWS_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\defrag\defrag.h ===
// Defragment.h

#ifndef __DEFRAG_H_
#define __DEFRAG_H_


// prototypes
BOOL PostMessageLocal (
    IN  HWND    hWnd,
    IN  UINT    Msg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    );

// class Travis made up - used when launching the engines
class COleStr
{
public:
	COleStr()
	{
		m_pStr = NULL;
	}

	virtual ~COleStr()
	{
		if ( m_pStr != NULL )
			CoTaskMemFree( m_pStr );
	}

	operator LPOLESTR()
	{
		return( m_pStr );
	}

	operator LPOLESTR*()
	{
		return( &m_pStr );
	}

	long GetLength()
	{
		return( wcslen( m_pStr ) );
	}

	LPOLESTR m_pStr;
};


#endif //__DEFRAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\defrag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by defrag.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\defrag\defrag.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  Defrag.cpp
//=============================================================================*

#include "stdafx.h"

extern "C" {
    #include "SysStruc.h"
}


#include "AdminPrivs.h"
#include "DataIo.h"
#include "DataIoCl.h"

#include "DfrgCmn.h"
#include "DfrgRes.h"

#include "ErrMacro.h"
#include "GetDfrgRes.h"
#include "TextBlock.h"

#include "Defrag.h"
#include "resource.h"

#include "UiCommon.h"

#include <stdio.h>
#include <comdef.h>
#include <atlconv.h>
#include <locale.h>
#include <winnlsp.h>  // in public\internal\base\inc

#include "secattr.h"


// return code
static int                  RetCode = 0;

// resource DLL
static HINSTANCE            resdll = NULL;

// force defrag flag
static BOOL                 ForceDefrag = FALSE;

// analyse vs defrag flag 
BOOL AnalyzeOnly = FALSE;

// verbose vs concise output flag
BOOL VerboseOutput = FALSE;

// force Boot Optimize flag
static BOOL                 BootOptimize = FALSE;

// event engine signals to tell us it is finished
static HANDLE               hEngineDoneEvent = NULL;


// semaphore to prevent multiple defraggers (command line or UI)
static HANDLE               hIsOkToRunSemaphore = NULL;

// name of program
static PTCHAR               prog;

WCHAR g_szTempBuffer[1024];



// prototypes
static void DisplayHelp(PTCHAR prog);
static int  Defrag(PTCHAR cDriveGUIDString, PTCHAR fileSystem, HANDLE stopEvent);
static int  GetMISemaphore();
static void ReleaseMISemaphore();


BOOL 
PrintOnConsole(
    IN LPCWSTR  wszStr,
    IN HANDLE   hConsoleOutput,
    IN BOOL     bIsTrueConsoleOutput
    )
{
    DWORD dwCharsOutput = 0;

    if (bIsTrueConsoleOutput) {
        //
        //  Output to the console
        //
        if (!WriteConsoleW(hConsoleOutput, 
            (PVOID)wszStr, 
            (DWORD)wcslen(wszStr), 
            &dwCharsOutput, 
            NULL)
            ) {
            return FALSE;
        }                                      
    }
    else {
        //
        //  Output being redirected.  WriteConsoleW doesn't work for redirected output.  Convert
        //  UNICODE to the current output CP multibyte charset.
        //
        LPSTR lpszTmpBuffer;
        DWORD dwByteCount;

        //
        //  Get size of temp buffer needed for the conversion.
        //
        dwByteCount = WideCharToMultiByte(
            GetConsoleOutputCP(),
            0,
            wszStr,
            -1,
            NULL,
            0,
            NULL,
            NULL
            );

        if (0 == dwByteCount) {
            return FALSE;
        }
        
        lpszTmpBuffer = (LPSTR)malloc(dwByteCount);
        if (NULL == lpszTmpBuffer ) {
            return FALSE;
        }

        //
        //  Now convert it.
        //
        dwByteCount = WideCharToMultiByte(
            GetConsoleOutputCP(),
            0,
            wszStr,
            -1,
            lpszTmpBuffer,
            dwByteCount,
            NULL,
            NULL
            );
        if (0 == dwByteCount) {
            free(lpszTmpBuffer);
            return FALSE;
        }
        
        //  Finally output it.
        if (!WriteFile(
            hConsoleOutput,
            lpszTmpBuffer,
            dwByteCount - 1,  // Get rid of the trailing NULL char
            &dwCharsOutput,
            NULL) 
            ) {
            free(lpszTmpBuffer);
            return FALSE;
        }                                      

        free(lpszTmpBuffer);
    }

    return TRUE;
}


BOOL
PrintOnStdOut(
    IN  LPCWSTR wszStr
    )
{
    static BOOL bIsTrueConsoleOutput = TRUE;
    static HANDLE hConsoleOutput = INVALID_HANDLE_VALUE;
    DWORD fdwMode = 0;

    if (INVALID_HANDLE_VALUE == hConsoleOutput)  {
        
        hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE); 
        if (INVALID_HANDLE_VALUE == hConsoleOutput) {
            return FALSE;
        }
        
        //
        //  Stash away the results in static vars.  bIsTrueConsoleOutput is TRUE when the 
        //  standard output handle is pointing to a console character device.
        //
        bIsTrueConsoleOutput = (GetFileType( hConsoleOutput ) & FILE_TYPE_CHAR ) && 
                               GetConsoleMode( hConsoleOutput, &fdwMode  );
    }

    if (NULL == wszStr) {
        return FALSE;
    }

    return PrintOnConsole(wszStr, hConsoleOutput, bIsTrueConsoleOutput);
}



BOOL
PrintOnStdErr(
    IN  LPCWSTR wszStr
    )
{
    static BOOL bIsTrueConsoleOutput = TRUE;
    static HANDLE hConsoleOutput = INVALID_HANDLE_VALUE;
    DWORD fdwMode = 0;


    if (INVALID_HANDLE_VALUE == hConsoleOutput)  {
        
        hConsoleOutput = GetStdHandle(STD_ERROR_HANDLE); 
        if (INVALID_HANDLE_VALUE == hConsoleOutput) {
            return FALSE;
        }
        
        //
        //  Stash away the results in static vars.  bIsTrueConsoleOutput is TRUE when the 
        //  standard output handle is pointing to a console character device.
        //
        bIsTrueConsoleOutput = (GetFileType( hConsoleOutput ) & FILE_TYPE_CHAR ) && 
                               GetConsoleMode( hConsoleOutput, &fdwMode  );
    }
    

    if (NULL == wszStr) {
        return FALSE;
    }

    return PrintOnConsole(wszStr, hConsoleOutput, bIsTrueConsoleOutput);
}



//-------------------------------------------------------------------*
//  function:   main
//
//  returns:    0 if all is well, otherwise error code
//  note:       
//-------------------------------------------------------------------*
extern "C" int __cdecl _tmain(int argc, TCHAR* argv[])
{
    int         ret = 0;
    int         ii;
    DWORD_PTR   dwParams[10];
    DWORD       dLastError = 0;
    BOOL        bDriveEntered = FALSE;
    TCHAR       fileSystem[10];
    WCHAR       buf[400];
    UINT        lenbuf = sizeof(buf)/sizeof(WCHAR);     //135977 pass number of characters not number of bytes
    WCHAR       msg[400];
    UINT        lenmsg = sizeof(msg)/sizeof(WCHAR);     //135977 pass number of characters not number of bytes
    DWORD       len;
    HANDLE      parentProcessHandle = NULL;
    HANDLE      stopEventHandle = NULL;
    HANDLE      stopEventSourceHandle;
    DWORD       parentProcessId;
    BOOL        stopEventSpecified = FALSE;
    BOOL        parentProcessSpecified = FALSE;
    BOOL        success;
    TCHAR       cDriveGUIDString[GUID_LENGTH];
    VString     tmpVolumeArg;
    HRESULT     hr = E_FAIL;

    // Use the OEM code page ...
    setlocale(LC_ALL, ".OCP");

    // Use the console UI language
    SetThreadUILanguage( 0 );

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

/*
    // Initialize COM security
    hr = CoInitializeSecurity(
           NULL,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,       //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           (EOAC_SECURE_REFS | EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL ),
           NULL                                 //  IN void                        *pReserved3
           );

    if(FAILED(hr)) {
        return 0;
    }
*/
    // load resource DLL
    resdll = GetDfrgResHandle();
    if (resdll == NULL)  {
        PrintOnStdErr(L"Error: cannot load resource DLL.\r\nContact system administrator.\r\n");
        RetCode = ENGERR_SYSTEM;
        CoUninitialize();
        return RetCode;
    }

    // must be an administrator to run this
    if (!CheckForAdminPrivs()) {
        LoadString(resdll, IDS_NEED_ADMIN_PRIVS, buf, lenbuf);
        wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);

        PrintOnStdErr(g_szTempBuffer);
        RetCode = ENGERR_SYSTEM;
        CoUninitialize();
        return RetCode;
    }


    // check for multiple instances
    if (GetMISemaphore() != 0)
    {
        RetCode = 1;
        CoUninitialize();
        return RetCode;
    }

    // strip off path from prog name
    prog = _tcsrchr(argv[0], TEXT('\\'));
    if (prog == NULL) 
    {
        prog = argv[0];
    }
    else 
    {
        prog++;
    }

    // 
    dwParams[0] = (DWORD_PTR) prog;
    dwParams[1] = NULL;

    // process command line
    for (ii = 1; ii < argc; ii++) 
    {
        // command line switches start with a dash or slash
        if (argv[ii][0] == TEXT('-') || argv[ii][0] == TEXT('/')) 
        {
            // process command line switches
            switch (argv[ii][1]) 
            {
            // Analyse only
            case TEXT('A'):
            case TEXT('a'):
                AnalyzeOnly = TRUE;
                break;

            // force boot optimize only
            case TEXT('B'):
            case TEXT('b'):
                BootOptimize = TRUE;
                break;

            // force defragmentation, even if too little free space
            case TEXT('F'):
            case TEXT('f'):
                ForceDefrag = TRUE;
                break;

            // help request
            case TEXT('H'):
            case TEXT('h'):
            case TEXT('?'):
                DisplayHelp(prog);
                RetCode = ENGERR_BAD_PARAM;
                CoUninitialize();
                return RetCode;
                break;

            // parent process
            case TEXT('P'):
            case TEXT('p'):
                ii++;
                if (ii < argc) {
                    if (0 == _stscanf(argv[ii], TEXT("%x"), &parentProcessId)) {
                        RetCode = ENGERR_BAD_PARAM;
                        CoUninitialize();
                        return RetCode;
                    }
                    parentProcessSpecified = TRUE;
                }
                break;

            // stop event
            case TEXT('S'):
            case TEXT('s'):
                ii++;
                if (ii < argc) {
                    if (0 == _stscanf(argv[ii], TEXT("%p"), &stopEventSourceHandle)) {
                        RetCode = ENGERR_BAD_PARAM;
                        CoUninitialize();
                        return RetCode;
                    }
                    stopEventSpecified = TRUE;
                }
                break;

            // verbose output (full report)
            case TEXT('V'):
            case TEXT('v'):
                VerboseOutput = TRUE;
                break;

            // unknown option
            default:
                dwParams[0] = (DWORD_PTR) argv[ii];
                dwParams[1] = NULL;
                if(!BootOptimize)
                {
                    LoadString(resdll, IDS_ERR_BAD_OPTION, buf, lenbuf);
                    assert(wcslen(buf) < lenbuf);

                    len = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                    buf, 0, 0, msg, lenmsg, (va_list*) dwParams);
                    assert(wcslen(msg) < lenmsg);
                    PrintOnStdErr(msg);
                    DisplayHelp(prog);
                }
                RetCode = ENGERR_BAD_PARAM;
                CoUninitialize();
                return RetCode;
                break;
            }
        }
        // otherwise, assume it is a drive letter or mount point
        else 
        {
            // check to make sure we don't already have a volume
            if (bDriveEntered)      // error
            { 
                if(!BootOptimize)
                {
                    // multiple drive error
                    LoadString(resdll, IDS_ERR_2_DRIVES, buf, lenbuf);
                    wsprintf(g_szTempBuffer, L"\r\n%s\r\n\r\n", buf);
                    PrintOnStdErr(g_szTempBuffer);
                    DisplayHelp(prog);
                }
                RetCode = ENGERR_BAD_PARAM;
                CoUninitialize();
                return RetCode;
            }

            // get a copy of the parameter
            tmpVolumeArg = argv[ii];

            // make sure it has a trailing backslash
            len = tmpVolumeArg.GetLength();
            if (tmpVolumeArg.operator [](len - 1) != TEXT('\\'))
            {
                if (!tmpVolumeArg.AddChar(TEXT('\\'))) {
                    RetCode = ENGERR_BAD_PARAM;
                    CoUninitialize();
                    return RetCode;
                }
                    
            }

            // get GUID from system
            if (!GetVolumeNameForVolumeMountPoint(tmpVolumeArg.GetBuffer(), cDriveGUIDString, GUID_LENGTH))
            {
                if(!BootOptimize)
                {
                    // bad drive error
                    LoadString(resdll, IDS_CMDLINE_BAD_VOL, buf, lenbuf);
                    wsprintf(g_szTempBuffer, L"\r\n%s\r\n\r\n", buf);
                    PrintOnStdErr(g_szTempBuffer);
                    DisplayHelp(prog);
                }
                RetCode = ENGERR_BAD_PARAM;
                CoUninitialize();
                return RetCode;
            } 

            bDriveEntered = TRUE;
        }
    }

    if(!BootOptimize)
    {
        LoadString(resdll, IDS_COMMANDLINE_DESCRIPTION, buf, lenbuf);
        assert(wcslen(buf) < lenbuf);
        PrintOnStdOut(buf);
    }

    // no drive letter = help request
    if (bDriveEntered == FALSE) 
    {
        DisplayHelp(prog);
        RetCode = ENGERR_BAD_PARAM;
        CoUninitialize();
        return RetCode;
    }

    // error if not a valid volume
    if (IsValidVolume(cDriveGUIDString, NULL, fileSystem) == FALSE) 
    {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_VOLUME_TYPE_NOT_SUPPORTED, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
        RetCode = ENGERR_BAD_PARAM;
        CoUninitialize();
        return RetCode;
    }

    // error if non-writeable device
    //sks bug#205674 disk full error
    if (IsVolumeWriteable(cDriveGUIDString, &dLastError) == FALSE) 
    {
        if(!BootOptimize)
        {
            if(dLastError == ERROR_HANDLE_DISK_FULL)
            {
                LoadString(resdll, IDS_DISK_FULL, buf, lenbuf);

                wsprintf(g_szTempBuffer, L"\r\n%s.\r\n", buf);
                PrintOnStdErr(g_szTempBuffer);

            } else
            {
                LoadString(resdll, IDS_READONLY_VOLUME, buf, lenbuf);
                wsprintf(g_szTempBuffer, L"\r\n%s.\r\n", buf);
                PrintOnStdErr(g_szTempBuffer);
            }   
        }
        RetCode = ENGERR_BAD_PARAM;
        CoUninitialize();
        return RetCode;
    }

    // if both a parent process and a stop event has been specified, open
    // the parent process and duplicate the handle to the event that it 
    // may signal to stop/cancel us.
    if (parentProcessSpecified && stopEventSpecified) 
    {

        // open the parent process.
        parentProcessHandle = OpenProcess(PROCESS_DUP_HANDLE,
                          FALSE,
                          parentProcessId);

        if (!parentProcessHandle) 
        {
            RetCode = ENGERR_BAD_PARAM;
            CoUninitialize();
            return RetCode;
        }

        // duplicate the stop event.
        success = DuplicateHandle(parentProcessHandle,
                      stopEventSourceHandle,
                      GetCurrentProcess(),
                      &stopEventHandle,
                      0,
                      FALSE,
                      DUPLICATE_SAME_ACCESS);

        CloseHandle(parentProcessHandle);

        if (!success)
        {
            RetCode = ENGERR_BAD_PARAM;
            CoUninitialize();
            return RetCode;
        }
    }

    // defrag
    ret = Defrag(cDriveGUIDString, fileSystem, stopEventHandle);

    // if parent process passed in a stop event, close it.
    if (stopEventHandle) {
        CloseHandle(stopEventHandle);
    }

#ifdef _DEBUG
    if (RetCode == 0)
    {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_LABEL_DEFRAG_COMPLETE, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdOut(g_szTempBuffer);
        }
    }
    if(!BootOptimize)
    {
        wsprintf(g_szTempBuffer, L"ret code=%d\r\n", RetCode);
        PrintOnStdOut(g_szTempBuffer);
    }
#endif

    // unload resource DLL
    ::FreeLibrary(resdll);

    // free multi instance semaphore
    ReleaseMISemaphore();

    CoUninitialize();
    return RetCode;
}


//-------------------------------------------------------------------*
//  function:   DisplayHelp
//
//  returns:    
//  note:       
//-------------------------------------------------------------------*
static void DisplayHelp(PTCHAR prog)
{
    WCHAR       buf[400];
    UINT        lenbuf = sizeof(buf)/sizeof(WCHAR);     //135977 pass number of characters not number of bytes
    WCHAR       msg[400];
    UINT        lenmsg = sizeof(msg)/sizeof(WCHAR);     //135977 pass number of characters not number of bytes
    DWORD_PTR   dwParams[10];
    DWORD       len;

    dwParams[0] = (DWORD_PTR) prog;
    dwParams[1] = NULL;

    if(!BootOptimize)
    {

        LoadString(resdll, IDS_CMDLINE_USAGE, buf, lenbuf);
        assert(wcslen(buf) < lenbuf);
        len = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                        buf, 
                        0, 
                        0, 
                        msg, 
                        lenmsg, 
                        (va_list*) dwParams);
        assert(wslen(msg) < lenmsg);
        PrintOnStdOut(msg);
    }
}


//-------------------------------------------------------------------*
//  function:   ConsoleCtrlHandler
//
//  returns:    TRUE if handled, FALSE otherwise
//  note:
//-------------------------------------------------------------------*
BOOL WINAPI ConsoleCtrlHandler(DWORD CtrlType)
{
    BOOL        ret = FALSE;
    WCHAR       buf[400];
    UINT        lenbuf = sizeof(buf)/sizeof(WCHAR); //135975 pass number of characters not number of bytes

    switch(CtrlType) 
    {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
        // on these cases we want to acknowledge the user cancelled
        if(!BootOptimize)
        {
            // Use the OEM code page ...
            setlocale(LC_ALL, ".OCP");

            // Use the console UI language
            SetThreadUILanguage( 0 );

            LoadString(resdll, IDS_USER_CANCELLED, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
        // fall through on purpose

    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        SetEvent(hEngineDoneEvent);
        RetCode = ENG_USER_CANCELLED;
        ret = TRUE;
        break;
    }

    return ret;
}


//-------------------------------------------------------------------*
//  function:   GetMISemaphore
//
//  returns:    
//  note:       
//-------------------------------------------------------------------*
static int GetMISemaphore()
{
    int         ret = 1;
    WCHAR       buf[400];
    UINT        lenbuf = sizeof(buf)/sizeof(WCHAR); //135974 pass number of characters not number of bytes

    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;

    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = FALSE;

    if (!ConstructSecurityAttributes(&saSecurityAttributes, esatSemaphore, FALSE)) {
        return 1;
    }

#if 1

    hIsOkToRunSemaphore = CreateSemaphore(&saSecurityAttributes, 1, 1, IS_OK_TO_RUN_SEMAPHORE_NAME);

    CleanupSecurityAttributes(&saSecurityAttributes);
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
    
    if (hIsOkToRunSemaphore != NULL)
    {
        // is the semaphore signaled?
        DWORD retValue = WaitForSingleObject(hIsOkToRunSemaphore, 10);

        // if so, this process is the only one, and the semaphore count is decremented to 0
        if (retValue == WAIT_OBJECT_0)
        {
            ret = 0;
        }
    }

    if (ret != 0)
    {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_CMDLINE_MULTI_INSTANCE, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
    }

#else
    // try to create the multiple instance semaphore
    hIsOkToRunSemaphore = CreateSemaphore(&saSecurityAttributes, 0, 1, IS_OK_TO_RUN_SEMAPHORE_NAME);

    // check if someone else has it
    if (hIsOkToRunSemaphore != NULL && GetLastError() == ERROR_ALREADY_EXISTS)
    {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_CMDLINE_MULTI_INSTANCE, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
        ret = 1;
    }
#endif

    return ret;
}


//-------------------------------------------------------------------*
//  function:   ReleaseMISemaphore
//
//  returns:    
//  note:       
//-------------------------------------------------------------------*
static void ReleaseMISemaphore()
{
    // if the semaphore was created, nuke it
    if (hIsOkToRunSemaphore != NULL) 
    {
        ReleaseSemaphore(hIsOkToRunSemaphore, 1, NULL);
        CloseHandle(hIsOkToRunSemaphore);
        hIsOkToRunSemaphore = NULL;
    }
}

//-------------------------------------------------------------------*
//  function:   Defrag
//
//  returns:    0 if all is well, otherwise error code
//  note:       
//-------------------------------------------------------------------*
static int Defrag(PTCHAR cDriveGUIDString, PTCHAR fileSystem, HANDLE hStopEvent)
{
    int            ret = 0;
    TCHAR          cmd[200];
    LPDATAOBJECT   pDefragEngine = NULL;
    WCHAR          buf[400];
    UINT           lenbuf = sizeof(buf)/sizeof(WCHAR);  //135976 pass number of characters not number of bytes
    NOT_DATA       NotData = {0};
    BOOL           bReturn;
    ULONG          numEvents;
    HANDLE         hEvents[2];

    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;

    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = FALSE;

    if (!ConstructSecurityAttributes(&saSecurityAttributes, esatEvent, FALSE)) {
        RetCode = ENGERR_SYSTEM;
        return RetCode;
    }

    hEngineDoneEvent = CreateEvent(&saSecurityAttributes, TRUE, FALSE, DEFRAG_COMPLETE_EVENT_NAME);
    // create event
    if ((hEngineDoneEvent == NULL) || (ERROR_ALREADY_EXISTS == GetLastError())) {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_ERR_CREATE_EVENT, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
        CleanupSecurityAttributes(&saSecurityAttributes);
        ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
        RetCode = ENGERR_SYSTEM;
        return RetCode;
    }
    
    CleanupSecurityAttributes(&saSecurityAttributes);
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));
    

    // initialize
    DWORD dwInstanceRegister = InitializeDataIo(CLSID_DfrgCtlDataIo, REGCLS_MULTIPLEUSE);

    // build command string
    // is this an NTFS volume?
    if (_tcscmp(fileSystem, TEXT("NTFS")) == MATCH) 
    {
        // start the NTFS command string
        _tcscpy(cmd, TEXT("DfrgNtfs "));
    }

    // is this a FAT or FAT32 volume?
    else if (_tcscmp(fileSystem, TEXT("FAT")) == MATCH || 
             _tcscmp(fileSystem, TEXT("FAT32")) == MATCH) 
    {
        // start the FAT command string
        _tcscpy(cmd, TEXT("DfrgFat "));
    }

    else 
    {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_VOLUME_TYPE_NOT_SUPPORTED, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
        RetCode = ENGERR_BAD_PARAM;
        return RetCode;
    }

    // finish command line
    _tcscat(cmd, cDriveGUIDString);
    if (AnalyzeOnly) {
        _tcscat(cmd, TEXT(" ANALYZE CMDLINE"));
    }
    else {
        _tcscat(cmd, TEXT(" DEFRAG CMDLINE"));
    }

    // add boot optimize flag
    if (BootOptimize)
    {
        _tcscat(cmd, TEXT(" BOOT"));
    } else
    {   // add force flag
        if (ForceDefrag)
        {
            _tcscat(cmd, TEXT(" FORCE"));
        }
    }

#ifdef _DEBUG
    if(!BootOptimize)
    {
        wsprintf(g_szTempBuffer, L"command line: %s\r\n\r\n", cmd);
        PrintOnStdOut(g_szTempBuffer);

    }
#endif

    // Start the volume-oriented communication. Create a guid for communication first.
    CLSID volumeID;
    if (!SUCCEEDED(CoCreateGuid(&volumeID))) 
    {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_ERR_CONNECT_ENGINE, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
        RetCode = ENGERR_SYSTEM;
        return RetCode;
    }

    USES_CONVERSION;
    COleStr VolID;
    StringFromCLSID(volumeID, VolID);
    InitializeDataIo(volumeID, REGCLS_MULTIPLEUSE);

    // clear the event
    if (!ResetEvent(hEngineDoneEvent)) 
    {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_ERR_CREATE_EVENT, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
        RetCode = ENGERR_SYSTEM;
        return RetCode;
    }

    // install handler to make sure engine shuts down if we get killed
    BOOL ok = SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);

    // is this an NTFS volume?
    if (_tcscmp(fileSystem, TEXT("NTFS")) == MATCH) 
    {
        // get a pointer to the NTFS engine
        if (!InitializeDataIoClient(CLSID_DfrgNtfs, NULL, &pDefragEngine)) 
        {
            if(!BootOptimize)
            {
                LoadString(resdll, IDS_ERR_CONNECT_ENGINE, buf, lenbuf);
                wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
                PrintOnStdErr(g_szTempBuffer);
            }
            RetCode = ENGERR_SYSTEM;
            return RetCode;
        }
    }

    // is this a FAT or FAT32 volume?
    else 
    {
        // get a pointer to the FAT engine
        if (!InitializeDataIoClient(CLSID_DfrgFat, NULL, &pDefragEngine)) 
        {
            if(!BootOptimize)
            {
                LoadString(resdll, IDS_ERR_CONNECT_ENGINE, buf, lenbuf);
                wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
                PrintOnStdErr(g_szTempBuffer);
            }
            RetCode = ENGERR_SYSTEM;
            return RetCode;
        }
    }

    // defrag
    //
    // send the generated clsid to the engine
    DataIoClientSetData(ID_INIT_VOLUME_COMM,
                        OLE2T(VolID),
                        VolID.GetLength() * sizeof(TCHAR),
                        pDefragEngine);

    // send the command request to the Dfrg engine
    DataIoClientSetData(ID_INITIALIZE_DRIVE,
                        cmd,
                        _tcslen(cmd) * sizeof(TCHAR),
                        pDefragEngine);

    // wait for engine to signal it is finished
    BOOL bEngineNotDone = TRUE;                     // not done yet flag
    const DWORD dwWaitMilliSecs = 5000;             // milli-seconds to wait

    // setup the events that may be signaled to stop us.

    numEvents = 0;

    hEvents[numEvents] = hEngineDoneEvent;
    numEvents++;

    if (hStopEvent) {
        hEvents[numEvents] = hStopEvent;
        numEvents++;
    }

    while (bEngineNotDone)
    {
        // wait for engine to signal it is done, but timeout
        DWORD status = WaitForMultipleObjects(numEvents,
                              hEvents,
                              FALSE,
                              dwWaitMilliSecs);

        switch (status)
        {
        case WAIT_TIMEOUT:                          // wait timed out
            // ping engine to see if it is running still
            bReturn = DataIoClientSetData(ID_PING, (PTCHAR) &NotData, sizeof(NOT_DATA), pDefragEngine);

            // if we cannot ping it, assume it is dead
            if (!bReturn)
            {

                // to avoid a race condition, check the done event again.
                if (WAIT_OBJECT_0 == WaitForSingleObject(hEngineDoneEvent, 0))
                {
                    // engine signaled event and exit just when we timed out.
                    // loop and fall through to the "engine done" code path.
                    break;
                }

                if (RetCode == 0)
                {
                    RetCode = ENGERR_UNKNOWN;
                }

                // error message
                if ((ENGERR_UNKNOWN == RetCode) && (!BootOptimize)) {
                    LoadString(resdll, IDS_CMDLINE_UNKNOWN_ERR, buf, lenbuf);
                    wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
                    PrintOnStdErr(g_szTempBuffer);
                    DisplayHelp(prog);
                }

                bEngineNotDone = FALSE;
            }
            break;

        case WAIT_OBJECT_0:                         // engine signaled it is done
            bEngineNotDone = FALSE;
            break;

        case WAIT_OBJECT_0 + 1:                     // parent process asked us to stop
            bEngineNotDone = FALSE;
            RetCode = ENG_USER_CANCELLED;
            break;

        case WAIT_ABANDONED:                        // engine died
            // error message
            if(!BootOptimize)
            {
                LoadString(resdll, IDS_CMDLINE_UNKNOWN_ERR, buf, lenbuf);
                wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
                PrintOnStdErr(g_szTempBuffer);
                DisplayHelp(prog);
            }   
            RetCode = ENGERR_UNKNOWN;
            bEngineNotDone = FALSE;
            break;
        }
    }

    // kill engine
    BOOL bNoGui = TRUE;
    DataIoClientSetData(ID_ABORT, (PTCHAR) &bNoGui, sizeof(BOOL), pDefragEngine);

    // clean up
    ok = ExitDataIoClient(&pDefragEngine);
    pDefragEngine = NULL;

#ifdef _DEBUG
    if (!ok)
    {
        if(!BootOptimize)
        {
            LoadString(resdll, IDS_ERR_RELEASE_ENGINE, buf, lenbuf);
            wsprintf(g_szTempBuffer, L"\r\n%s\r\n", buf);
            PrintOnStdErr(g_szTempBuffer);
        }
    }
#endif

    // don't need event any more
    CloseHandle(hEngineDoneEvent);

    return RetCode;
}

TCHAR*
InsertCommaIntoText(
    IN TCHAR* stringBuffer
    )
{
    TCHAR targetString[256];
    TCHAR sourceString[256];
    TCHAR tcThousandsSep[2] = {TEXT(','), 0};

    _tcscpy(sourceString, stringBuffer);

    if(_tcslen(sourceString) == 0) {
        return TEXT("");
    }

    struct lconv *locals = localeconv();
    if (*(locals->thousands_sep) != 0) {
        _stprintf(tcThousandsSep, TEXT("%C"), *(locals->thousands_sep));
    }

    UINT uGrouping = atoi(locals->grouping);
    if(uGrouping == 0) {
        uGrouping = 3;      //default value if its not supported
    }

    // point the source pointer at the null terminator
    PTCHAR pSource = sourceString + _tcslen(sourceString);

    // put the target pointer at the end of the target buffer
    PTCHAR pTarget = targetString + sizeof(targetString) / sizeof(TCHAR) - 1;

    // write the null terminator
    *pTarget = NULL;

    for (UINT i=0; i<_tcslen(sourceString); i++){
        if (i>0 && i%uGrouping == 0){
            pTarget--;
            *pTarget = tcThousandsSep[0];
        }
        pTarget--;
        pSource--;
        *pTarget = *pSource;
    }

//  if (stringBufferLength > _tcslen(pTarget)){
        _tcscpy(stringBuffer, pTarget);
//  }
//  else{
//      _tcscpy(stringBuffer, TEXT(""));
//  }
    return stringBuffer;
}


LONGLONG checkForNegativeValues(LONGLONG lldatavalue)
{
    return ((lldatavalue > 0) ? lldatavalue : 0);
}

VOID
PrintToStdOut(
    IN UINT resourceIDText, 
    IN UINT resourceIDSeperator,
    IN TCHAR* pTextStr, 
    BOOL bIndentText,
    IN UINT resourceIDPercent = 0
    )
{
    TCHAR buffer[256];
    TCHAR tempBuffer[270];
    TCHAR buffer2[8];

    //load the resourceIDText   
    LoadString(GetDfrgResHandle(), resourceIDText, buffer, sizeof(buffer)/sizeof(TCHAR));
    if(bIndentText) {
        _stprintf(tempBuffer, TEXT("    %s"), buffer);
    } 
    else {
        _stprintf(tempBuffer, TEXT("\r\n%s"), buffer);
    }

    //
    // Add spaces so that this part occupies at least 35 chars
    //
    int uExtraStrLen = 35 - _tcslen(tempBuffer);
    if (uExtraStrLen > 0) {
        int i = 0; 
        for(i=0;i<uExtraStrLen;i++) {
            _tcscat(tempBuffer, TEXT(" "));
        }
    }


    //load the resourceIDSeperator
    LoadString(GetDfrgResHandle(), resourceIDSeperator, buffer, sizeof(buffer)/sizeof(TCHAR));

    if (resourceIDPercent) {
        LoadString(GetDfrgResHandle(), resourceIDPercent, buffer2, sizeof(buffer2)/sizeof(TCHAR));
        wsprintf(g_szTempBuffer, L"%s \t%s %s %s\r\n", tempBuffer, buffer, pTextStr, buffer2);
        PrintOnStdOut(g_szTempBuffer);

    }
    else {
        wsprintf(g_szTempBuffer, L"%s \t%s %s\r\n", tempBuffer, buffer, pTextStr);
        PrintOnStdOut(g_szTempBuffer);
    }


}

VOID
WriteTextReportToStdOut(
    IN TEXT_DATA *pTextData                            
    )
{
    TCHAR buffer[256];
    TCHAR tempBuffer[256];
    static int count  = 0;

    // Use the OEM code page ...
    setlocale(LC_ALL, ".OCP");

    // Use the console UI language
    SetThreadUILanguage( 0 );

    // check all the values of textdata to make sure no negative values
    //to fix bug number 35764
    pTextData->DiskSize = checkForNegativeValues(pTextData->DiskSize);
    pTextData->BytesPerCluster = checkForNegativeValues(pTextData->BytesPerCluster);
    pTextData->UsedSpace = checkForNegativeValues(pTextData->UsedSpace);
    pTextData->FreeSpace = checkForNegativeValues(pTextData->FreeSpace);
    pTextData->FreeSpacePercent = checkForNegativeValues(pTextData->FreeSpacePercent);
    pTextData->UsableFreeSpace = checkForNegativeValues(pTextData->UsableFreeSpace);
    pTextData->UsableFreeSpacePercent = checkForNegativeValues(pTextData->UsableFreeSpacePercent);
    pTextData->PagefileBytes = checkForNegativeValues(pTextData->PagefileBytes);
    pTextData->PagefileFrags = checkForNegativeValues(pTextData->PagefileFrags);
    pTextData->TotalDirectories = checkForNegativeValues(pTextData->TotalDirectories);
    pTextData->FragmentedDirectories = checkForNegativeValues(pTextData->FragmentedDirectories);
    pTextData->ExcessDirFrags = checkForNegativeValues(pTextData->ExcessDirFrags);
    pTextData->TotalFiles = checkForNegativeValues(pTextData->TotalFiles);
    pTextData->AvgFileSize = checkForNegativeValues(pTextData->AvgFileSize);
    pTextData->NumFraggedFiles = checkForNegativeValues(pTextData->NumFraggedFiles);
    pTextData->NumExcessFrags = checkForNegativeValues(pTextData->NumExcessFrags);
    pTextData->PercentDiskFragged = checkForNegativeValues(pTextData->PercentDiskFragged);
    pTextData->AvgFragsPerFile = checkForNegativeValues(pTextData->AvgFragsPerFile);
    pTextData->MFTBytes = checkForNegativeValues(pTextData->MFTBytes);
    pTextData->InUseMFTRecords = checkForNegativeValues(pTextData->InUseMFTRecords);
    pTextData->TotalMFTRecords = checkForNegativeValues(pTextData->TotalMFTRecords);
    pTextData->MFTExtents = checkForNegativeValues(pTextData->MFTExtents);
    pTextData->FreeSpaceFragPercent = checkForNegativeValues(pTextData->FreeSpaceFragPercent);



    if (!VerboseOutput) {

        TCHAR buffer1[24];

        if (AnalyzeOnly || !count) {
            PrintToStdOut(IDS_ANALYSIS_REPORT_TITLE, NULL, TEXT(""), FALSE);
        }
        else {
            PrintToStdOut(IDS_DEFRAG_REPORT_TITLE, NULL, TEXT(""), FALSE);
        }
        ++count;

        LoadString(GetDfrgResHandle(), IDS_CONCISE_OUTPUT_FORMAT, buffer, sizeof(buffer)/sizeof(TCHAR));

        // Volume Size
        _stprintf(buffer1, TEXT("%I64d"), pTextData->DiskSize);
        InsertCommaIntoText(buffer1);
        FormatNumber(GetDfrgResHandle(), pTextData->DiskSize, buffer1);

        // Free Space
        _stprintf(tempBuffer, TEXT("%I64d"), pTextData->FreeSpace);
        InsertCommaIntoText(tempBuffer);
        FormatNumber(GetDfrgResHandle(), pTextData->FreeSpace, tempBuffer);

        wsprintf(g_szTempBuffer,  
            buffer, 
            buffer1, 
            tempBuffer, 
            pTextData->FreeSpacePercent, 
            ((pTextData->PercentDiskFragged + pTextData->FreeSpaceFragPercent) / 2),
            pTextData->PercentDiskFragged
            );

        PrintOnStdOut(g_szTempBuffer);

        if (AnalyzeOnly) {
            if(((pTextData->PercentDiskFragged + pTextData->FreeSpaceFragPercent) / 2) > 10){
                //If the fragmentation on the disk exceeds 10% fragmentation, then recommend defragging.
                PrintToStdOut(IDS_LABEL_CHOOSE_DEFRAGMENT, NULL, TEXT(""), FALSE);
            }
            else{
                //Otherwise tell the user he doesn't need to defragment at this time.
                PrintToStdOut(IDS_LABEL_NO_CHOOSE_DEFRAGMENT, NULL, TEXT(""), FALSE);
            }
        }
        return;
    }

    if (AnalyzeOnly || !count) {
        PrintToStdOut(IDS_ANALYSIS_REPORT_TITLE, NULL, TEXT("\r\n"), FALSE);
    }
    else {
        PrintOnStdOut(L"\r\n\r\n");
        PrintToStdOut(IDS_DEFRAG_REPORT_TITLE, NULL, TEXT("\r\n"), FALSE);
    }
    ++count;

    ///////////////////////////////////////////////////////////////////////////
    // Volume Size
    _stprintf(buffer, TEXT("%I64d"), pTextData->DiskSize);
    InsertCommaIntoText(buffer);
    FormatNumber(GetDfrgResHandle(), pTextData->DiskSize, buffer);
    PrintToStdOut(IDS_LABEL_VOLUME_SIZE,IDS_LABEL_EQUAL_SIGN,
        buffer,TRUE);
    
    // Cluster Size
    _stprintf(buffer, TEXT("%I64d"), pTextData->BytesPerCluster);
    InsertCommaIntoText(buffer);
    FormatNumber(GetDfrgResHandle(), pTextData->BytesPerCluster, buffer);
    PrintToStdOut(IDS_LABEL_CLUSTER_SIZE,IDS_LABEL_EQUAL_SIGN,
        buffer,TRUE);

    // Used Space
    _stprintf(buffer, TEXT("%I64d"), pTextData->UsedSpace);
    InsertCommaIntoText(buffer);
    FormatNumber(GetDfrgResHandle(), pTextData->UsedSpace, buffer);
    PrintToStdOut(IDS_LABEL_USED_SPACE,IDS_LABEL_EQUAL_SIGN,
        buffer,TRUE);

    // Free Space
    _stprintf(buffer, TEXT("%I64d"), pTextData->FreeSpace);
    InsertCommaIntoText(buffer);
    FormatNumber(GetDfrgResHandle(), pTextData->FreeSpace, buffer);
    PrintToStdOut(IDS_LABEL_FREE_SPACE,IDS_LABEL_EQUAL_SIGN,
        buffer,TRUE);

    // % Free Space
    _stprintf(buffer, TEXT("%I64d"), pTextData->FreeSpacePercent);
    PrintToStdOut(IDS_LABEL_PERCENT_FREE_SPACE,
            IDS_LABEL_EQUAL_SIGN,buffer,TRUE,IDS_LABEL_PERCENT_SIGN);

        // Volume Fragmentation Header
    PrintToStdOut(IDS_LABEL_VOLUME_FRAGMENTATION_HEADING,NULL,TEXT(""),FALSE);

    // % Total Fragmentation
    _stprintf(buffer, TEXT("%I64d"), (pTextData->PercentDiskFragged + pTextData->FreeSpaceFragPercent) / 2);
    PrintToStdOut(IDS_LABEL_TOTAL_FRAGMENTATION,
            IDS_LABEL_EQUAL_SIGN,buffer,TRUE,IDS_LABEL_PERCENT_SIGN);

    // % File Fragmentation
    _stprintf(buffer, TEXT("%I64d"), pTextData->PercentDiskFragged);
    PrintToStdOut(IDS_LABEL_FILE_FRAGMENTATION,
            IDS_LABEL_EQUAL_SIGN,buffer,TRUE,IDS_LABEL_PERCENT_SIGN);

    // % Free Space Fragmentation
    _stprintf(buffer, TEXT("%I64d"), pTextData->FreeSpaceFragPercent);
    PrintToStdOut(IDS_LABEL_FREE_SPACE_FRAGMENTATION,
            IDS_LABEL_EQUAL_SIGN,buffer,TRUE,IDS_LABEL_PERCENT_SIGN);
    
    // File Fragmentation Header
    PrintToStdOut(IDS_LABEL_FILE_FRAGMENTATION_HEADING ,NULL,TEXT(""),FALSE);


    // Total Files
    _stprintf(buffer, TEXT("%I64d"), pTextData->TotalFiles);
    InsertCommaIntoText(buffer);
    PrintToStdOut(IDS_LABEL_TOTAL_FILES ,IDS_LABEL_EQUAL_SIGN,buffer,TRUE);

    // Average Files Size
    _stprintf(buffer, TEXT("%I64d"), pTextData->AvgFileSize);
    InsertCommaIntoText(buffer);
    FormatNumber(GetDfrgResHandle(), pTextData->AvgFileSize, buffer);
    PrintToStdOut(IDS_LABEL_AVERAGE_FILE_SIZE, IDS_LABEL_EQUAL_SIGN,buffer,TRUE);
    
    // Total fragmented files
    _stprintf(buffer, TEXT("%I64d"), pTextData->NumFraggedFiles);
    PrintToStdOut(IDS_LABEL_TOTAL_FRAGMENTED_FILES, IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE);

    // Total excess fragments
    _stprintf(buffer, TEXT("%I64d"), pTextData->NumExcessFrags);
    PrintToStdOut(IDS_LABEL_TOTAL_EXCESS_FRAGMENTS, IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE);

    // Average Fragments per File
    struct lconv *locals = localeconv();
    _stprintf(buffer, TEXT("%d%c%02d"), (UINT)pTextData->AvgFragsPerFile/100,
        ((locals && (locals->decimal_point)) ? *(locals->decimal_point) : '.'), 
        (UINT)pTextData->AvgFragsPerFile%100);
    PrintToStdOut(IDS_LABEL_AVERAGE_FRAGMENTS_PER_FILE, IDS_LABEL_EQUAL_SIGN,buffer,TRUE);

    // Pagefile Fragmentation Header
    PrintToStdOut(IDS_LABEL_PAGEFILE_FRAGMENTATION_HEADING, NULL,TEXT(""),FALSE);

    // Pagefile Size
    _stprintf(buffer, TEXT("%I64d"), pTextData->PagefileBytes);
    InsertCommaIntoText(buffer);
    FormatNumber(GetDfrgResHandle(), pTextData->PagefileBytes, buffer);
    PrintToStdOut(IDS_LABEL_PAGEFILE_SIZE, IDS_LABEL_EQUAL_SIGN,buffer,TRUE);

    // Total Fragments
    _stprintf(buffer, TEXT("%I64d"), pTextData->PagefileFrags);
    PrintToStdOut(IDS_LABEL_TOTAL_FRAGMENTS, IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE);

    // Directory Fragmentation Header
    PrintToStdOut(IDS_LABEL_DIRECTORY_FRAGMENTATION_HEADING,NULL,TEXT(""),FALSE);

    // Total Directories
    _stprintf(buffer, TEXT("%I64d"), pTextData->TotalDirectories);
    PrintToStdOut(IDS_LABEL_TOTAL_DIRECTORIES,
            IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE);


    // Fragmented Directories
    _stprintf(buffer, TEXT("%I64d"), pTextData->FragmentedDirectories);
    PrintToStdOut(IDS_LABEL_FRAGMENTED_DIRECTORIES,
            IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE);

    // Excess directory fragments
    _stprintf(buffer, TEXT("%I64d"), pTextData->ExcessDirFrags);
    PrintToStdOut(IDS_LABEL_EXCESS_DIRECTORY_FRAGMENTS, IDS_LABEL_EQUAL_SIGN,
        InsertCommaIntoText(buffer), TRUE);

    
    //Only display MFT data if this is an NTFS drive.
    if(_tcscmp(pTextData->cFileSystem, TEXT("NTFS")) == 0) {
        
        // MFT Fragmentation Header
        PrintToStdOut(IDS_LABEL_MFT_FRAGMENTATION_HEADING, NULL, TEXT(""), FALSE);

        // Total MFT Size
        _stprintf(buffer, TEXT("%I64d"), pTextData->MFTBytes);
        InsertCommaIntoText(buffer);
        FormatNumber(GetDfrgResHandle(), pTextData->MFTBytes, buffer);
        PrintToStdOut(IDS_LABEL_TOTAL_MFT_SIZE, IDS_LABEL_EQUAL_SIGN,
            buffer, TRUE);

        // Number of MFT records
        _stprintf(buffer, TEXT("%I64d"), pTextData->InUseMFTRecords);
        PrintToStdOut(IDS_LABEL_MFT_RECORD_COUNT, IDS_LABEL_EQUAL_SIGN,
            InsertCommaIntoText(buffer), TRUE);
        
        // Percent of MFT in use
        _stprintf(buffer, TEXT("%I64d"), 100*pTextData->InUseMFTRecords/pTextData->TotalMFTRecords);
        PrintToStdOut(IDS_LABEL_PERCENT_MFT_IN_USE, IDS_LABEL_EQUAL_SIGN,
            buffer, TRUE);

        // Total MFT fragments
        _stprintf(buffer, TEXT("%I64d"), pTextData->MFTExtents);
        PrintToStdOut(IDS_LABEL_TOTAL_MFT_FRAGMENTS, IDS_LABEL_EQUAL_SIGN,
            InsertCommaIntoText(buffer),TRUE);

    }

    if (AnalyzeOnly) {
        if(((pTextData->PercentDiskFragged + pTextData->FreeSpaceFragPercent) / 2) > 10){
            //If the fragmentation on the disk exceeds 10% fragmentation, then recommend defragging.
            PrintToStdOut(IDS_LABEL_CHOOSE_DEFRAGMENT, NULL, TEXT(""), FALSE);
        }
        else{
            //Otherwise tell the user he doesn't need to defragment at this time.
            PrintToStdOut(IDS_LABEL_NO_CHOOSE_DEFRAGMENT, NULL, TEXT(""), FALSE);
        }
    }

/*    // if there are >1 mount points, print them all out
    // yes, this will duplicate the same as the display label

    // refresh the mount point list
#ifndef VER4
    pLocalVolume->GetVolumeMountPointList();
    if (pLocalVolume->MountPointCount() > 1){
        for (UINT i=0; i<pLocalVolume->MountPointCount(); i++){
            LoadString(GetDfrgResHandle(), IDS_MOUNTED_VOLUME, tempBuffer, sizeof(tempBuffer)/sizeof(TCHAR));
            _stprintf(buffer, TEXT("%s  %s"), tempBuffer, pLocalVolume->MountPoint(i));
            PrintToStdOut(buffer,
                    NULL,TEXT(""),FALSE);
                }
    }
#endif

    // write out the display label (usually the drive letter/label)
    LoadString(GetDfrgResHandle(), IDS_LABEL_VOLUME, tempBuffer, sizeof(tempBuffer)/sizeof(TCHAR));
    _stprintf(buffer, TEXT("%s  %s"), tempBuffer,pLocalVolume->DisplayLabel());
    PrintToStdOut(buffer
        ,NULL,TEXT(""),FALSE);
*/
//  PrintToStdOut(IDS_PRODUCT_NAME,NULL,TEXT(""),FALSE);

}

/*-------------------------------------------------------------------*
ROUTINE DESCRIPTION:
    This routines handles the 're-routed' window posted command messages. The general DataIo (DCOM)
    routines that we use would normally call the PostMessage() routine to handle incoming data requests.
    But for console applications, there is NO windows application to handle the PostMessage() commands,
    so in DataIo.cpp (SetData() routine), it was modified to call a locally define PostMessageConsole()
    routine instead if the user defines "ConsoleApplication" at build time.
  
GLOBAL DATA:
    None

INPUT:
    hWnd   - Handle to the window - always NULL
    uMsg   - The message.
    wParam - The word parameter for the message.
    lParam - the long parameter for the message.

    Note: These are the same inputs that the WndProc() routine would handle for PostMessage() commands.

RETURN:
    TRUE

REVISION HISTORY: 
    0.0E00  23 September 1997 - Andy Staffer - modified for the DfrgSnap
    0.0E00  15 July 1997 - Gary Quan - Created

---------------------------------------------------------------------*/

BOOL PostMessageLocal (
    IN  HWND    hWnd,
    IN  UINT    Msg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    DATA_IO* pDataIo;

    switch (LOWORD(wParam)) 
    {
        // says that the engine is instantiated, but not defragging or analyzing
        case ID_ENGINE_START:
            {
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // defrag has actually started
        case ID_BEGIN_SCAN:
            {
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }


        // defrag has ended
        case ID_END_SCAN:
            {
            END_SCAN_DATA* pEndScanData;

            // Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pEndScanData = (END_SCAN_DATA*)&(pDataIo->cData);

            // Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(END_SCAN_DATA));
            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // engine died
        case ID_TERMINATING:
            {
            NOT_DATA* pNotData;

            // Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pNotData = (NOT_DATA*)&(pDataIo->cData);

            // Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(NOT_DATA));

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // engine error data
        case ID_ERROR:
            {
            ERROR_DATA* pErrorData;

            // Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pErrorData = (ERROR_DATA*)&(pDataIo->cData);

            // Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(ERROR_DATA));

            // Save error code
            RetCode = pErrorData->dwErrCode;
            if(!BootOptimize)
            {
                wsprintf(g_szTempBuffer, L"\r\n%s\r\n\r\n", pErrorData->cErrText);
                PrintOnStdErr(g_szTempBuffer);
            }

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // sends the progress bar setting and the status that is 
        // displayed in the list view
        case ID_STATUS:
            {
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // sends the list of most fragged files
        case ID_FRAGGED_DATA:
            {
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // sends the data displayed in the graphic wells (cluster maps)
        case ID_DISP_DATA:
            {
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // sends the text data that is displayed on the report
        case ID_REPORT_TEXT_DATA:
            {
            TEXT_DATA* pTextData = NULL;
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            
            pTextData = (TEXT_DATA*)&(pDataIo->cData);
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(TEXT_DATA));

            WriteTextReportToStdOut(pTextData);

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        case ID_PING:
            // Do nothing.  
            // This is just a ping sent by the engine to make sure the UI is still up.
            {
            NOT_DATA* pNotData;

            // Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pNotData = (NOT_DATA*)&(pDataIo->cData);

            // Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(NOT_DATA));

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        default:
            EF_ASSERT(FALSE);
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgfat\stdafx.h ===
#ifndef RTL_USE_AVL_TABLES 
#define RTL_USE_AVL_TABLES 0
#endif  // RTL_USE_AVL_TABLES

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include <windows.h>
#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgfat\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DfrgFat.rc
//
#define IDS_REGISTRY_ERROR              1
#define IDS_REGISTRY_ERROR_TITLE        2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\defrag\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Defragment.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\defrag\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F1950751_56A8_459C_96C5_37A9DEB2BD16__INCLUDED_)
#define AFX_STDAFX_H__F1950751_56A8_459C_96C5_37A9DEB2BD16__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define INC_OLE2

#ifndef RTL_USE_AVL_TABLES 
#define RTL_USE_AVL_TABLES 0
#endif  // RTL_USE_AVL_TABLES


#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>


#include <windows.h>

//#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F1950751_56A8_459C_96C5_37A9DEB2BD16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgfat\dfrgfat.cpp ===
/*****************************************************************************************************************

FILENAME: DfrgFat.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

  Scan Disk and/or defragment engine for FAT volumes.

  If Analyze is specified on the command line, this will execute an analysis of the disk.

  If Defragment is specified on the command line, this will execute an analysis of the disk
  and then defragment it.

*/


#ifndef INC_OLE2
    #define INC_OLE2
#endif

#include "stdafx.h"

#define GLOBAL_DATAHOME

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <commctrl.h>
#include <winioctl.h>
#include <shlobj.h> // for SHGetSpecialFolderLocation()

#include "DataIo.h"
#include "DataIoCl.h"

extern "C" {
    #include "SysStruc.h"
}
#include "ErrMacro.h"
#include "Message.h"
#include "ErrLog.h"
#include "Event.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"

#include "Extents.h"
#include "FreeSpace.h"
#include "FastFat2.h"
#include "FatSubs.h"
#include "FsSubs.h"
#include "MoveFile.h"

#include "Alloc.h"
#include "DiskView.h"
#include "Exclude.h"
#include "GetReg.h"
#include "GetTime.h"
#include "IntFuncs.h"
#include "Logging.h"
#include "ErrMsg.h"
#include "Expand.h"
#include "LogFile.h"
#include "GetDfrgRes.h"
#include "FraggedFileList.h"
extern "C" {
    #include "Priority.h"
}
#include "DfrgFat.h"
#include "resource.h"
#include "VString.hpp"
#include <atlconv.h>
#include "BootOptimizeFat.h"
#include "defragcommon.h"

static UINT DiskViewInterval = 1000;    // default to 1 sec
LONGLONG EnumeratedFatFiles = 0;

static HANDLE hDefragCompleteEvent = NULL;

// This is set to terminate until the initialize has been successfully run.
BOOL bTerminate = TRUE;
BOOL bOCXIsDead = FALSE;

BOOL bCommandLineUsed = FALSE;
BOOL bLogFile = FALSE;
BOOL bCommandLineMode = FALSE;
BOOL bCommandLineForceFlag = FALSE;
BOOL bCommandLineBootOptimizeFlag = FALSE;

//acs bug #101862//
static UINT uPass = 0;
static UINT uPercentDone = 0;
static UINT uEngineState = DEFRAG_STATE_NONE;

//acs//
static DWORD dwMoveFlags = MOVE_FRAGMENTED|MOVE_CONTIGUOUS;

LPDATAOBJECT pdataDfrgCtl = NULL;

TCHAR cWindow[100];

static const DISKVIEW_TIMER_ID = 1;
static const PING_TIMER_ID = 2;

DiskView AnalyzeView;
DiskView DefragView;


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This is the WinMain function for the FAT defragmention engine.

INPUT + OUTPUT:
    IN GetDfrgResHandle()ance       - The handle to this instance.
    IN hPrevInstance    - The handle to the previous instance.
    IN lpCmdLine        - The command line which was passed in.
    IN nCmdShow         - Whether the window should be minimized or not.

GLOBALS:
    OUT AnalyzeOrDefrag - Tells whether were supposed to to an analyze or an analyze and a defrag.
    OUT VolData.cDrive  - The drive letter with a colon after it.

RETURN:
    FALSE - Failure to initilize.
    other - Various values can return at exit.
*/

int APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    IN  LPSTR lpCmdLine,
    IN  int nCmdShow
    )
{
    TCHAR       cWindow[100];
    WNDCLASSEX  wc;
    MSG         Message;
    HRESULT     hr = E_FAIL;

    // Before we start using VolData, zero it out.
    ZeroMemory(&VolData, sizeof(VOL_DATA));
    CoInitializeEx(NULL, COINIT_MULTITHREADED);

/*  
    Commenting this call out to minimise registry changes for XP SP 1.

    // Initialize COM security
    hr = CoInitializeSecurity(
           (PVOID)&CLSID_DfrgFat,               //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,       //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           (EOAC_SECURE_REFS | EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL | EOAC_APPID),
           NULL                                 //  IN void                        *pReserved3
           );                            
    if(FAILED(hr)) {
        return 0;
    }
*/

#ifndef VER4
    OSVERSIONINFO   Ver;

    //This should only work on version 5 or later.  Do a check.
    Ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    EF(GetVersionEx(&Ver));
    if(Ver.dwMajorVersion < 5){
        //took out the display error message stuff from here because we needed to
        //not display error dialogs for the commandline, but here is the problem...
        //we have not got the information from InitializeDrive yet, so we don't 
        //know what mode we are in, so we can't either write to a log or display
        //a message box.  The likelyhood that this call will fail is very small, so
        //not doing anything is not a problem.  One other problem exist here that 
        //I am not even going to try and solve, and that is when this call fails,
        //since the COM server is not set up correctly, we go off into never never
        //land and cause a server busy dialog to be displayed by the system, not
        //from defrag. Scott K. Sipe
        return FALSE;
    }
#endif

    // Build the window name from the drive letter.
    lstrcpy(cWindow, DFRGFAT_WINDOW);

    // Initialize the window class.
    wc.style = CS_OWNDC;
    wc.lpfnWndProc = (WNDPROC) MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(PVOID);
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = DFRGFAT_CLASS;
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.hIconSm = NULL;

    // Register the window class.
    if(!RegisterClassEx(&wc)){
        //took out the display error message stuff from here because we needed to
        //not display error dialogs for the commandline, but here is the problem...
        //we have not got the information from InitializeDrive yet, so we don't 
        //know what mode we are in, so we can't either write to a log or display
        //a message box.  The likelyhood that this call will fail is very small, so
        //not doing anything is not a problem.  One other problem exist here that 
        //I am not even going to try and solve, and that is when this call fails,
        //since the COM server is not set up correctly, we go off into never never
        //land and cause a server busy dialog to be displayed by the system, not
        //from defrag. Scott K. Sipe
        return FALSE;
    }

    // Create the window.
    if((hwndMain = CreateWindow(DFRGFAT_CLASS,
                                cWindow,
                                WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL | WS_MINIMIZE,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                NULL,
                                NULL,
                                hInstance,
                                (LPVOID)IntToPtr(NULL))) == NULL){

        //took out the display error message stuff from here because we needed to
        //not display error dialogs for the commandline, but here is the problem...
        //we have not got the information from InitializeDrive yet, so we don't 
        //know what mode we are in, so we can't either write to a log or display
        //a message box.  The likelyhood that this call will fail is very small, so
        //not doing anything is not a problem.  One other problem exist here that 
        //I am not even going to try and solve, and that is when this call fails,
        //since the COM server is not set up correctly, we go off into never never
        //land and cause a server busy dialog to be displayed by the system, not
        //from defrag. Scott K. Sipe
        return FALSE;
    }

    // Make that window visible.
#ifdef VisibleWindow
    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);
#endif

    // PostMessage for ID_INITALIZE which will get data about the volume, etc.
    SendMessage (hwndMain, WM_COMMAND, ID_INITIALIZE, 0);

    // Pass any posted messages on to MainWndProc.
    while(GetMessage(&Message, NULL, 0, 0)){
        TranslateMessage(&Message);
        DispatchMessage(&Message);
    }
    return (int) Message.wParam;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This is the WndProc function for the FAT defragmentaion engine.

INPUT + OUTPUT:
    IN hWnd     - Handle to the window.
    IN uMsg     - The message.
    IN wParam   - The word parameter for the message.
    IN lParam   - the long parameter for the message.

GLOBALS:
    IN AnalyzeOrDefrag  - Used to determine whether this is an analysis or defragment run.
    IN OUT hThread      - Handle for the worker thread (either analyze or defragment).

RETURN:
    various.
*/

LRESULT CALLBACK
MainWndProc(
    IN  HWND hWnd,
    IN  UINT uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    DATA_IO* pDataIo;

    switch(uMsg){

        case WM_COMMAND:

            switch(LOWORD(wParam)){

            case ID_INIT_VOLUME_COMM:
                {
                    USES_CONVERSION;
                    CLSID clsidVolume;
                    HRESULT hr;

                    //
                    // Get the volume comm id out of the given data.
                    //
                    pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
                    EB_ASSERT( pDataIo );
                    
                    hr = CLSIDFromString( T2OLE( (PTCHAR) &pDataIo->cData ), &clsidVolume );
                    EB_ASSERT( SUCCEEDED( hr ) );

                    //
                    // Initialize the upstream communication given the
                    // guid.
                    //
                    InitializeDataIoClient( clsidVolume, NULL, &pdataDfrgCtl);
                    break;
                }

                case ID_INITIALIZE:
                {
                    Message(TEXT("ID_INITIALIZE"), -1, NULL);

                    Initialize();

                    Message(TEXT("calling GetCommandLine()"), -1, NULL);

#ifdef CMDLINE
#pragma message ("Information: CMDLINE defined.")

                    // Get the command line passed in.
                    PTCHAR pCommandLine = GetCommandLine();

                    Message(TEXT("CMDLINE defined"), -1, NULL);
                    Message(pCommandLine, -1, NULL);

                    // if "-Embed..." is NOT found in the string, then this was a command line
                    // submitted by the user and NOT by the OCX.  Package it up and send it to the
                    // message pump.  If -Embed was found, the OCX will send the command line in
                    // a ID_INITIALIZE_DRIVE message.
                    if (_tcsstr(pCommandLine, TEXT("-Embed")) == NULL){

                        HANDLE hCommandLine = NULL;
                        DATA_IO* pCmdLine = NULL;
                        //If this is not called by the MMC, use the command line typed in from the DOS window.
                        bCommandLineUsed = TRUE;
                        AllocateMemory((lstrlen(pCommandLine)+1)*sizeof(TCHAR)+sizeof(DATA_IO), &hCommandLine, (void**)&pCmdLine);
                        lstrcpy(&pCmdLine->cData, pCommandLine);
                        GlobalUnlock(hCommandLine);
                        PostMessage(hWnd, WM_COMMAND, ID_INITIALIZE_DRIVE, (LPARAM)hCommandLine);
                    }
#else
#pragma message ("Information: CMDLINE not defined.")

                    // Get the command line passed in.
                    PTCHAR pCommandLine = GetCommandLine();

                    Message(TEXT("CMDLINE not defined"), -1, NULL);
                    Message(pCommandLine, -1, NULL);

                    // if "-Embed..." is NOT found in the string, then this was a command line
                    // submitted by the user and NOT by the OCX and that is not supported.
                    // Raise an error dialog and send an ABORT to the engine
                    if (_tcsstr(pCommandLine, TEXT("-Embed")) == NULL){
                        VString msg(IDS_CMD_LINE_OFF, GetDfrgResHandle());
                        VString title(IDS_DK_TITLE, GetDfrgResHandle());
                        MessageBox(NULL, msg.GetBuffer(), title.GetBuffer(), MB_OK|MB_ICONSTOP);
                        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);
                    }
#endif
                    Message(TEXT("ID_INITIALIZE done"), -1, NULL);

                    break;
                }

                case ID_INITIALIZE_DRIVE:

                    Message(TEXT("ID_INITIALIZE_DRIVE"), -1, NULL);

                    pDataIo = (DATA_IO*)GlobalLock((void*)lParam);

                    if(!InitializeDrive((PTCHAR)&pDataIo->cData)){
                        // If initialize failed, pop up a message box, log an abort, and trigger an abort.
                        //IDS_SCANNTFS_INIT_ABORT - "ScanFAT: Initialize Aborted - Fatal Error"
                        VString msg(IDS_SCANFAT_INIT_ABORT, GetDfrgResHandle());
                        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

                        // Log an abort in the event log.
                        EF(LogEvent(MSG_ENGINE_ERROR, msg.GetBuffer()));

                        // Trigger an abort.
                        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

                        // set the event to signaled, allowing the UI to proceed
                        if (hDefragCompleteEvent){
                            SetEvent(hDefragCompleteEvent);
                        }
                    }
                    EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
                    EH_ASSERT(GlobalFree((void*)lParam) == NULL);
                    break;

                case ID_ANALYZE:
                    // Create an analyze thread.
                    {
                        DWORD ThreadId;
                        EB_ASSERT((hThread = CreateThread(NULL,
                                                       0,
                                                       (LPTHREAD_START_ROUTINE)AnalyzeThread,
                                                       NULL,
                                                       0,
                                                       &ThreadId)) != NULL);
                    }
                    break;

                case ID_DEFRAG:
                    // Create a defrag thread.
                    {
                        DWORD ThreadId;
                        EB_ASSERT((hThread = CreateThread(NULL,
                                                       0,
                                                       (LPTHREAD_START_ROUTINE)DefragThread,
                                                       NULL,
                                                       0,
                                                       &ThreadId)) != NULL);
                    }
                    break;

                case ID_STOP:
                    Message(TEXT("ID_STOP"), -1, NULL);
                    //Tell the worker thread to terminate.
                    VolData.EngineState = TERMINATE;

                    //Send status data to the UI.
                    SendStatusData();
                    break;

                case ID_PAUSE_ON_SNAPSHOT:
                {
#ifndef NOTIMER
                    KillTimer(hwndMain, PING_TIMER_ID);
#endif
                    NOT_DATA NotData;
                    wcscpy(NotData.cVolumeName, VolData.cVolumeName);

                    Message(TEXT("ID_PAUSE_ON_SNAPSHOT"), -1, NULL);
                    VolData.EngineState = PAUSED;

                    //Tell the UI we've paused.
                    DataIoClientSetData(ID_PAUSE_ON_SNAPSHOT, (PTCHAR)&NotData, sizeof(NOT_DATA), pdataDfrgCtl);
                    break;
                }
                case ID_PAUSE:
                {
#ifndef NOTIMER
                    KillTimer(hwndMain, PING_TIMER_ID);
#endif
                    NOT_DATA NotData;
                    wcscpy(NotData.cVolumeName, VolData.cVolumeName);

                    Message(TEXT("ID_PAUSE"), -1, NULL);
                    VolData.EngineState = PAUSED;

                    //Tell the UI we've paused.
                    DataIoClientSetData(ID_PAUSE, (PTCHAR)&NotData, sizeof(NOT_DATA), pdataDfrgCtl);
                    break;
                }

                case ID_CONTINUE:
                {
#ifndef NOTIMER
                    EF_ASSERT(SetTimer(hwndMain, PING_TIMER_ID, PINGTIMER, NULL) != 0);
#endif
                    NOT_DATA NotData;
                    wcscpy(NotData.cVolumeName, VolData.cVolumeName);

                    Message(TEXT("ID_CONTINUE"), -1, NULL);
                    VolData.EngineState = RUNNING;

                    //Tell the UI we've continued.
                    DataIoClientSetData(ID_CONTINUE, (PTCHAR)&NotData, sizeof(NOT_DATA), pdataDfrgCtl);
                    break;
                }

                case ID_ABORT_ON_SNAPSHOT:
                        if (hDefragCompleteEvent){
                            SetEvent(hDefragCompleteEvent);
                        }
                        // fall through;
                
                case ID_ABORT:
                {
                    Message(TEXT("ID_ABORT"), -1, NULL);
                    pDataIo = (DATA_IO*)GlobalLock((HANDLE)lParam);
                    if (pDataIo){
                        bOCXIsDead = *(BOOL *) &pDataIo->cData;
                    }
                    // Terminate this engine.
                    bTerminate = TRUE;
                    VolData.EngineState = TERMINATE;
                    PostMessage(hwndMain, WM_CLOSE, 0, 0);
                    break;
                }

                case ID_PING:
                    //Do nothing.  This is just a ping sent by the UI to make sure the engine is still up.
                    break;

                case ID_SETDISPDIMENSIONS:
                {
                    pDataIo = (DATA_IO*)GlobalLock((HANDLE)lParam);
                    BOOL bSendData = TRUE;

                    //Make sure this is a valid size packet.
                    EF_ASSERT(pDataIo->ulDataSize == sizeof(SET_DISP_DATA));
                    SET_DISP_DATA *pSetDispData = (SET_DISP_DATA *) &pDataIo->cData;

                    AnalyzeView.SetNumLines(pSetDispData->AnalyzeLineCount);
                    if (pSetDispData->bSendGraphicsUpdate == FALSE && AnalyzeView.IsDataSent() == TRUE){
                        bSendData = FALSE;
                    }

                    DefragView.SetNumLines(pSetDispData->DefragLineCount);
                    if (pSetDispData->bSendGraphicsUpdate == FALSE && DefragView.IsDataSent() == TRUE){
                        bSendData = FALSE;
                    }

                    EH_ASSERT(GlobalUnlock((HANDLE)lParam) == FALSE);
                    EH_ASSERT(GlobalFree((HANDLE)lParam) == NULL);

                    // if the UI wants a graphics update, send data
                    if (bSendData) {
                        SendGraphicsData();
                    }
                    break;
                }

                default:
                    return DefWindowProc(hWnd, uMsg, wParam, lParam);
            }
            break;

        case WM_TIMER:
            //
            // If we're running on battery power, make sure it isn't low, critical
            // or unknown
            //
            SYSTEM_POWER_STATUS SystemPowerStatus;
            if ( GetSystemPowerStatus(&SystemPowerStatus) ){
                if ((STATUS_AC_POWER_OFFLINE == SystemPowerStatus.ACLineStatus) &&
                    ((STATUS_BATTERY_POWER_LOW & SystemPowerStatus.BatteryFlag) ||
                     (STATUS_BATTERY_POWER_CRITICAL & SystemPowerStatus.BatteryFlag)
                    )) {
                    // abort all engines
                    TCHAR buf[256];
                    TCHAR buf2[256];
                    UINT buflen = 0;
                    DWORD_PTR     dwParams[1];

                    PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

                    dwParams[0] = (DWORD_PTR) VolData.cDisplayLabel;
                    LoadString(GetDfrgResHandle(), IDS_APM_FAILED_ENGINE, buf, sizeof(buf) / sizeof(TCHAR));
                    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                        buf, 0, 0, buf2, 256, (va_list*) dwParams)) {
                        break;
                    }
                    SendErrData(buf2, ENGERR_GENERAL);
                }
            } 
            if(wParam == DISKVIEW_TIMER_ID){ // graphics data

                //Send the graphical data to the UI.
                SendGraphicsData();
            }
            else if(wParam == PING_TIMER_ID && !bCommandLineUsed){
#ifndef NOTIMER
                NOT_DATA NotData;
                wcscpy(NotData.cVolumeName, VolData.cVolumeName);

                // Kill the timer until it's been processed so we don't get a backlog of timers.
                KillTimer(hwndMain, PING_TIMER_ID);

                // Ping the UI.
                Message(TEXT("ID_PING sent from FAT engine"), -1, NULL);
                if(!DataIoClientSetData(ID_PING, (PTCHAR)&NotData, sizeof(NOT_DATA), pdataDfrgCtl)){
                    //If the UI isn't there, abort.
                    PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);
                    break;
                }
                // Set the timer for the next ping.
                EF_ASSERT(SetTimer(hwndMain, PING_TIMER_ID, PINGTIMER, NULL) != 0);
#endif
            }
            break;

        case WM_CLOSE:
            END_SCAN_DATA EndScanData;
            NOT_DATA NotData;

            ZeroMemory(&EndScanData, sizeof(ENGINE_START_DATA));
            wcscpy(EndScanData.cVolumeName, VolData.cVolumeName);
            EndScanData.dwAnalyzeOrDefrag = AnalyzeOrDefrag;

            if (VolData.bFragmented) {
        	    EndScanData.dwAnalyzeOrDefrag |= DEFRAG_FAILED;
            }

            if(VolData.FileSystem == FS_FAT){
                lstrcpy(EndScanData.cFileSystem, TEXT("FAT"));
            }
            else if(VolData.FileSystem == FS_FAT32){
                lstrcpy(EndScanData.cFileSystem, TEXT("FAT32"));
            }

            // Cleanup and nuke the window.
            if(bMessageWindowActive && !bCommandLineUsed){
                if(!bTerminate){
                    //Tell the gui that the analyze and/or defrag are done.
                    DataIoClientSetData(ID_END_SCAN, (PTCHAR)&EndScanData, sizeof(END_SCAN_DATA), pdataDfrgCtl);
                    break;
                }
            }
            wcscpy(NotData.cVolumeName, VolData.cVolumeName);

            //Tell the gui that the engine is terminating. (unless it is DEAD!)
            if (!bOCXIsDead){
                DataIoClientSetData(ID_TERMINATING, (PTCHAR)&NotData, sizeof(NOT_DATA), pdataDfrgCtl);
            }

            Exit();
            DestroyWindow(hWnd);
            break;

        case WM_DESTROY:
            // Nuke the thread.
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return 0;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This module carries out all initialization before the Analyze or Defrag threads start.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN hwndMain         - Handle to the main window.
    OUT hPageFileNames  - The memory that holds the list of names of active pagefiles on this drive.
    OUT pPageFileNames  - The pointer.

    IN VolData.TotalClusters        - The total number of clusters on the disk -- can be used to determine if this is a FAT12 drive.
    OUT VolData.StartTime           - The time the engine is considered to have started.
    OUT VolData.AveFragsPerFile     - Set to 1 fragment per file initially.
    OUT VolData.hExtentList         - The memory for the buffer that holds the extent list for files as they are worked on.
    OUT VolData.pExtentList         - The pointer.
    OUT VolData.ExtentListBytes     - The size of the memory currently allocated for VolData.hExtentList.
    OUT VolData.cNodeName           - The name of the computer this is working on.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
Initialize(
    )
{
    // Note EF's before this point will not work if they are routed to Message
    // Initialize a message window.
    InitCommonControls(); // todo Help file says this function is obsolete

    // Initialize DCOM DataIo communication.
    InitializeDataIo(CLSID_DfrgFat, REGCLS_SINGLEUSE);

    Message(TEXT("Initialize"), S_OK, NULL);
    Message(TEXT(""), -1, NULL);

    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This module carries out all initialization before the Analyze or Defrag threads start.

INPUT + OUTPUT:
    None.

GLOBALS:
    OUT hPageFileNames  - Handle to the memory used to hold the names of all the pagefiles active on this drive.
    OUT pPageFileNames  - The pointer.

    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
InitializeDrive(
    IN PTCHAR pCommandLine
    )
{
    UCHAR* pUchar = NULL;
    DWORD dwComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    TCHAR cLoggerIdentifier[256];
    TCHAR pParam0[100];
    TCHAR pParam1[100];
    TCHAR pParam2[100];
    TCHAR pParam3[100];
    TCHAR pParam4[100];
    HKEY hValue = NULL;
    TCHAR cRegValue[MAX_PATH];
    DWORD dwRegValueSize = sizeof(cRegValue);

    Message(pCommandLine, -1, NULL);

    // Parse the command line.
    pParam0[0] = 0;
    pParam1[0] = 0;
    pParam2[0] = 0;
    pParam3[0] = 0;
    pParam4[0] = 0;


    swscanf(pCommandLine, TEXT("%99s %99s %99s %99s %99s"), pParam0, pParam1, pParam2, pParam3, pParam4);

    // Get the drive letter from the first parameter.

    // check for a x: format, sanity check on second character
    if (wcslen(pParam1) == 2 && pParam1[1] == L':'){
        wsprintf(VolData.cVolumeName, L"\\\\.\\%c:", pParam1[0]); // UNC format
        VolData.cDrive = pParam1[0];
        // Get a handle to the volume and fill in data
        EF(GetFatVolumeStats());
        // Format the VolData.DisplayLabel
        FormatDisplayString(VolData.cDrive, VolData.cVolumeLabel, VolData.cDisplayLabel);
        // create the tag
        wsprintf(VolData.cVolumeTag, L"%c", pParam1[0]); // the drive letter only
    }
    // check for \\.\x:\, sanity check on third character
    else if (wcslen(pParam1) == 7 && pParam1[2] == L'.'){
        wcscpy(VolData.cVolumeName, pParam1); // UNC format, copy it over
        VolData.cVolumeName[6] = (TCHAR) NULL; // get rid of trailing backslash
        VolData.cDrive = pParam1[4];
        // Get a handle to the volume and fill in data
        EF(GetFatVolumeStats());
        // Format the VolData.DisplayLabel
        FormatDisplayString(VolData.cDrive, VolData.cVolumeLabel, VolData.cDisplayLabel);
        // create the tag
        wsprintf(VolData.cVolumeTag, L"%c", pParam1[4]); // the drive letter only
    }
#ifndef VER4 // NT5 only:
    // check for \\?\Volume{12a926c3-3f85-11d2-aa0e-000000000000}\,
    // sanity check on third character
    else if (wcslen(pParam1) == 49 && pParam1[2] == L'?'){
        wcscpy(VolData.cVolumeName, pParam1); // GUID format, copy it over
        VolData.cVolumeName[48] = (TCHAR) NULL; // get rid of trailing backslash

        // Get a handle to the volume and fill in data
        EF(GetFatVolumeStats());

        VString mountPointList[MAX_MOUNT_POINTS];
        UINT  mountPointCount = 0;

        // get the drive letter
        if (!GetDriveLetterByGUID(VolData.cVolumeName, VolData.cDrive)){
            // if we didn't get a drive letter, get the mount point list
            // cause we need the list to create the DisplayLabel
            GetVolumeMountPointList(
                VolData.cVolumeName,
                mountPointList,
                mountPointCount);
        }

        // Format the VolData.DisplayLabel
        FormatDisplayString(
            VolData.cDrive,
            VolData.cVolumeLabel,
            mountPointList,
            mountPointCount,
            VolData.cDisplayLabel);

        // create the tag
        for (UINT i=0, j=0; i<wcslen(VolData.cVolumeName); i++){
            if (iswctype(VolData.cVolumeName[i],_HEX)){
                VolData.cVolumeTag[j++] = VolData.cVolumeName[i];
            }
        }
        VolData.cVolumeTag[j] = (TCHAR) NULL;
    }
#endif
    else {
        // invalid drive on command line
        VString msg(IDS_INVALID_CMDLINE_DRIVE, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    // Check to see if this is anything other than FAT or FAT32, and if so, bail out.
    if(VolData.FileSystem != FS_FAT && VolData.FileSystem != FS_FAT32){
        VString msg(IDMSG_ERR_NOT_FAT_PARTITION, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    // calculate the graphics refresh interval
    LONGLONG DiskSize = VolData.TotalClusters * VolData.BytesPerCluster;
    LONGLONG GigSize = 1024 * 1024 * 1024;

    if (DiskSize <= GigSize * 4) {
        DiskViewInterval = 2000;
    }
    else if (DiskSize <= GigSize * 9) {
        DiskViewInterval = 5000;
    }
    else if (DiskSize <= GigSize * 100) {
        DiskViewInterval = 10000;
    }
    else {
        DiskViewInterval = 30000;
    }

    // Get whether this is analyze or defrag from the second parameter
    if(wcscmp(pParam2, L"ANALYZE") == 0){
        AnalyzeOrDefrag = ANALYZE;
    }
    else if(wcscmp(pParam2, L"DEFRAG") == 0){
        AnalyzeOrDefrag = DEFRAG;
    }
    else{
        // Print out an error if neither analyze nor defrag were passed in.
        VString msg(IDS_INVALID_CMDLINE_OPERATION, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    //0.0E00 The third or fourth parameters might be set to Command Line
    // which would mean this was launched from the Command Line
    // I did the compare not case sensitive 
    if(wcslen(pParam3)){
        if(_wcsicmp(TEXT("CMDLINE"), pParam3) == 0){
            bCommandLineMode = TRUE;
            if(wcslen(pParam4)){                //Force flag check
                if(_wcsicmp(TEXT("BOOT"), pParam4) == 0){
                    bCommandLineBootOptimizeFlag = TRUE;
                } else
                {
                    bCommandLineBootOptimizeFlag = FALSE;
                }
                if(_wcsicmp(TEXT("FORCE"), pParam4) == 0){
                    bCommandLineForceFlag = TRUE;
                } else
                {
                    bCommandLineForceFlag = FALSE;
                }

            }
        } else
        {
            bCommandLineMode = FALSE;
        }
    }

    // open the event that was created by the UI.
    // this is only used for command line operation.
    // if this fails, that means there is no other process that is
    // trying to sync with the engine.
    Message(TEXT("Opening Event..."), -1, NULL);
    if (bCommandLineMode) {
        hDefragCompleteEvent = OpenEvent(EVENT_ALL_ACCESS, TRUE, DEFRAG_COMPLETE_EVENT_NAME);
        if (!hDefragCompleteEvent){
            Message(DEFRAG_COMPLETE_EVENT_NAME, GetLastError(), NULL);
        }
    }
    
    // Get the path name.
    dwRegValueSize = sizeof(cRegValue);
    if(GetRegValue(&hValue,
                   TEXT("SOFTWARE\\Microsoft\\Dfrg"),
                   TEXT("PathName"),
                   cRegValue,
                   &dwRegValueSize) != ERROR_SUCCESS){

        VString msg(IDS_CANT_CREATE_RESOURCE, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    if(RegCloseKey(hValue)!=ERROR_SUCCESS){
        VString msg(IDS_CANT_CREATE_RESOURCE, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }
    hValue = NULL;

    //Translate any environment variables in the string.
    if(!ExpandEnvVars(cRegValue)){
        VString msg(IDS_CANT_CREATE_RESOURCE, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    // get the My Documents path
    TCHAR cLogPath[300];
    LPITEMIDLIST pidl ;
    // this will get the path to My Documents for the current user
    SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl);
    SHGetPathFromIDList(pidl, cLogPath);

    // initialize the log files
    TCHAR cErrLogName[300];

    // put error log in My Docs folder
    _tcscpy(cErrLogName, cLogPath);
    _tcscat(cErrLogName, TEXT("\\DfrgError.log"));
    _stprintf(cLoggerIdentifier, TEXT("DfrgFat on Drive %s"), VolData.cDisplayLabel);
#ifdef _DEBUG
    InitializeErrorLog(cErrLogName, cLoggerIdentifier);
#endif

    // check registry setting for the stats log
    BOOL bStatLog = FALSE;
    dwRegValueSize = sizeof(cRegValue);
    if(GetRegValue(&hValue,
                   TEXT("SOFTWARE\\Microsoft\\Dfrg"),
                   TEXT("CreateLogFile"),
                   cRegValue,
                   &dwRegValueSize) == ERROR_SUCCESS){
        RegCloseKey(hValue);
        if(_tcscmp(cRegValue, TEXT("1")) == MATCH){
            bStatLog = TRUE;
        }
    }

    // if we want to log statistics to a file.
    if(bStatLog){
        // put error log in My Docs folder
        _tcscpy(cErrLogName, cLogPath);
        _tcscat(cErrLogName, TEXT("\\DfrgFATStats.log"));

        // initialize the log which will be used to tell variation success status to dfrgtest.
        if (InitializeLogFile(cErrLogName)){
            bLogFile = TRUE;
        }
    }

    // Default to 1 frag per file
    VolData.AveFragsPerFile = 100;

    // Initialize event logging.
    EF(InitLogging(TEXT("Diskeeper")));

    // Allocate an initial buffer to hold a file's extent list.
    VolData.ExtentListAlloced = INITIAL_EXTENT_LIST_BYTES;
    EF(AllocateMemory((DWORD)VolData.ExtentListAlloced, &VolData.hExtentList, (void**)&VolData.pExtentList));

    // Check for 12-bit FAT.
    if(VolData.TotalClusters < 4087){
        TCHAR cString[256];
        TCHAR szMsg[300];
        DWORD_PTR dwParams[2];

        // IDMSG_BITFAT_ERROR - "Error - Volume %s: has a 12-bit FAT.
        // Diskeeper does not support 12-bit FAT partitions."
        dwParams[0] = (DWORD_PTR)VolData.cDisplayLabel; // this error will not happen for mounted volumes
        dwParams[1] = 0;
        LoadString(GetDfrgResHandle(), IDMSG_BITFAT_ERROR, cString, sizeof(cString) / sizeof(TCHAR));
        if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
            cString, 0, 0, szMsg, 300, (va_list*) dwParams)) {

            GetLastError();
            return FALSE;
        }

        SendErrData(szMsg, ENGERR_GENERAL);
        EF(LogEvent(MSG_ENGINE_ERROR, cString));
        return FALSE;
    }

    // Get this computer's name.
    EF(GetComputerName(VolData.NodeName, &dwComputerNameSize));

    // Get the pagefile names.
    EF(GetPagefileNames(VolData.cDrive, &hPageFileNames, &pPageFileNames));

    EF(GetFatBootSector());

    //If this is a FAT32 volume and the disk version is greater than 0,
    //then bail out, because we don't support this version.
    if((VolData.FileSystem == FS_FAT32) && VolData.FatVersion){
        VString msg(IDS_UNSUPPORTED_FAT_VERSION, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    // Allocate buffer to hold the volume bitmap - don't lock
    EF(AllocateMemory((DWORD)(sizeof(VOLUME_BITMAP_BUFFER) + (VolData.BitmapSize / 8)),
                      &VolData.hVolumeBitmap,
                      NULL));

    //1.0E00 Load the volume bitmap.
    EF(GetVolumeBitmap());


    // Set the timer for updating the DiskView.
    EF(SetTimer(hwndMain, DISKVIEW_TIMER_ID, DiskViewInterval, NULL) != 0);

    // Set the timer that will ping the UI.
    // DO NOT set this timer is this is the command line version 'cause the engine will kill itself
#ifndef NOTIMER
    if (!bCommandLineMode){
        EF(SetTimer(hwndMain, PING_TIMER_ID, PINGTIMER, NULL) != 0);
    }
#endif
    //Ok don't terminate before closing the display window.
    bTerminate = FALSE;

    //Set the engine state to running.
    VolData.EngineState = RUNNING;

    //Send a message to the UI telling it that the process has started
    //and what type of pass this is.
    ENGINE_START_DATA EngineStartData = {0};

    wcscpy(EngineStartData.cVolumeName, VolData.cVolumeName);
    EngineStartData.dwAnalyzeOrDefrag = AnalyzeOrDefrag;

    if(VolData.FileSystem == FS_FAT){
        lstrcpy(EngineStartData.cFileSystem, TEXT("FAT"));
    }
    else if(VolData.FileSystem == FS_FAT32){
        lstrcpy(EngineStartData.cFileSystem, TEXT("FAT32"));
    }


    DataIoClientSetData(ID_ENGINE_START, (PTCHAR)&EngineStartData, sizeof(ENGINE_START_DATA), pdataDfrgCtl);

    Message(TEXT("Initialize"), S_OK, NULL);
    Message(TEXT(""), -1, NULL);

    // After Initialize, determine whether this is an analyze or defrag run,
    // and start the approriate one.
    switch(AnalyzeOrDefrag){

    case ANALYZE:
        PostMessage(hwndMain, WM_COMMAND, ID_ANALYZE, 0);
        break;
    case DEFRAG:
        PostMessage(hwndMain, WM_COMMAND, ID_DEFRAG, 0);
        break;
    default:
        EF(FALSE);
    }
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This module carries out initialization specific to defrag before the defrag thread starts.

INPUT + OUTPUT:
    None.

GLOBALS:
    OUT VolData.hVolumeBitmap   - Memory filled with the volume bitmap. (Will be filled upon return.)
    OUT VolData.hExcludeList    - Memory holding the exclusion list.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
InitializeDefrag(
    )
{
    // Load the volume bitmap.
    EF(GetVolumeBitmap());

    // Get the exclude list if any.
    TCHAR cExcludeFile[100];
    wsprintf(cExcludeFile, TEXT("Exclude%s.dat"), VolData.cVolumeTag);
    GetExcludeFile(cExcludeFile, &VolData.hExcludeList);

    // Copy the analyze cluster array (DiskView class)
    DefragView = AnalyzeView;
    SendGraphicsData();

    BEGIN_SCAN_INFO ScanInfo = {0};
    wcscpy(ScanInfo.cVolumeName, VolData.cVolumeName);
    wcscpy(ScanInfo.cDisplayLabel, VolData.cDisplayLabel);
    if(VolData.FileSystem == FS_FAT){
        lstrcpy(ScanInfo.cFileSystem, TEXT("FAT"));
    }
    else if(VolData.FileSystem == FS_FAT32){
        lstrcpy(ScanInfo.cFileSystem, TEXT("FAT32"));
    }
    //The defrag fields will equal zero since the structure is zero memoried above.  This means we're not sending defrag data.
    // Tell the UI that we're beginning the scan.
    DataIoClientSetData(ID_BEGIN_SCAN, (PTCHAR)&ScanInfo, sizeof(BEGIN_SCAN_INFO), pdataDfrgCtl);

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Thread routine for analysis.

INPUT + OUTPUT:
    None.

GLOBALS:
    OUT VolData.EngineState - To tell the main thread whether the prescan and scan are running.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
AnalyzeThread(
    )
{
    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    
    // Get the time that the engine started.
    GetLocalTime(&VolData.StartTime);

    AcquirePrivilege(SE_BACKUP_NAME);

    // Do the Prescan.
    uPercentDone = 10;
    uPass = 0;
    uEngineState = DEFRAG_STATE_ANALYZING;
    SendStatusData();

    if(!PreScanFat()){
        // IDMSG_SCANFAT_PRESCAN_ABORT - "ScanFat: PreScan Aborted - Fatal Error - File:"
        VString msg(IDMSG_SCANFAT_PRESCAN_ABORT, GetDfrgResHandle());
        msg.AddChar(L' ');
        PWSTR Temp = VolData.vFileName.GetBuffer();
        if (StartsWithVolumeGuid(Temp)) {
            
            if ((VolData.cDrive >= L'C') &&
                (VolData.cDrive <= L'Z')) {
                msg.AddChar(VolData.cDrive);
                msg.AddChar(L':');
            }

            msg += (PWSTR)(Temp + 48);
        }
        else {
            msg += VolData.vFileName;
        }

        // send error info to client
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

        // Log this into the EventLog.
        LogEvent(MSG_ENGINE_ERROR, msg.GetBuffer());

        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        ExitThread(0);
        return FALSE;
    }

    if(VolData.EngineState == TERMINATE){
        //1.0E00 We're done, close down now.
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        // Kill the thread.
        ExitThread(0);
    }

    //1.0E00 Allocate memory for the file lists.
    uPercentDone = 20;      //acs bug #101862//
    SendStatusData();

    if (!AllocateFileLists()) {

        VString msg(IDS_OUT_OF_MEMORY, GetDfrgResHandle());
        msg += TEXT("\r\n");
        VString line2(IDS_SCANFAT_INIT_ABORT, GetDfrgResHandle());
        msg += line2;

        // send error info to client
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

        // Log this into the EventLog.
        LogEvent(MSG_ENGINE_ERROR, msg.GetBuffer());

        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        ExitThread(0);
        return FALSE;
    }

    // Do the Scan.
    if(!ScanFat()){
        // IDMSG_SCANFAT_SCAN_ABORT - "ScanFAT: Scan Aborted - Fatal Error - File:"
        VString msg(IDMSG_SCANFAT_SCAN_ABORT, GetDfrgResHandle());
        msg.AddChar(L' ');
        PWSTR Temp = VolData.vFileName.GetBuffer();
        if (StartsWithVolumeGuid(Temp)) {
            
            if ((VolData.cDrive >= L'C') &&
                (VolData.cDrive <= L'Z')) {
                msg.AddChar(VolData.cDrive);
                msg.AddChar(L':');
            }

            msg += (PWSTR)(Temp + 48);
        }
        else {
            msg += VolData.vFileName;
        }

        // send error info to client
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

        // Log this into the EventLog.
        LogEvent(MSG_ENGINE_ERROR, msg.GetBuffer());

        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        ExitThread(0);
        return FALSE;
    }

    // If this engine has a visible window, write the basic statistics for this drive to the screen.
    //uPercentDone = 60;        //acs bug #101862//
    SendStatusData();

    // Note the end time for that pass.
    GetLocalTime(&VolData.EndTime);

    DisplayFatVolumeStats();

    //Send status data to the UI.
    uPercentDone = 100;
    uEngineState = DEFRAG_STATE_ANALYZED;
    SendStatusData();

    //Send the graphical data to the UI.
    SendGraphicsData();

    //Send the report text data to the UI.
    SendReportData();

    //Send the most fragged list to the UI.
    SendMostFraggedList();

    //1.0E00 We're done, close down now.
    PostMessage(hwndMain, WM_CLOSE, 0, 0);

    // set the event to signaled, allowing the UI to proceed
    if (hDefragCompleteEvent){
        SetEvent(hDefragCompleteEvent);
    }

    // Kill the thread.
    ExitThread(0);
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Scan the volume to determine the amount of memory which will be required for the file lists.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Multiple VolData fields are used by PreScanFat and the functions is calls.  There are to many to practically enumerate here.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
PreScanFat(
    )
{
    ULONG  NumDirs = 0;
    ULONG  NumFiles = 0;
    ULONG  NumMoveableFiles = 0;
    ULONG  SmallFiles = 0;

    Message(TEXT("PreScanFat"), -1, NULL);
    EnumeratedFatFiles = 0;

    while(TRUE){

        // Sleep if paused.
        while(VolData.EngineState == PAUSED){
            Sleep(1000);
        }
        // Terminate if told to stop by the controller - this is not an error.
        if(VolData.EngineState == TERMINATE){
            EH(PostMessage(hwndMain, WM_CLOSE, 0, 0));
            return TRUE;
        }

        // Get the next file to check.
        EF(NextFatFile());
        ++EnumeratedFatFiles;

        // Check to see if we have run out of files.
        if(VolData.vFileName.GetLength() == 0){
            break;
        }
        // Check to see if this is the pagefile.
        EF(CheckForPagefileFat());
        if(VolData.bPageFile){
            // If this is a pagefile, then set this var to FALSE so we don't automatically think
            //the next file is a pagefile too.
            VolData.bPageFile = FALSE;
            // Keep track of the total number of pagefiles.
            VolData.NumPagefiles++;
            // Don't process this file in this routine.
            continue;
        }

        if (!OpenFatFile()){
            continue;
        }

        // Handle dirs
        if(VolData.bDirectory){
            NumDirs++; //Count that we found a dir.
        }
        else{
            if(VolData.FileSize){
                NumFiles++; //Count that we found a file.
            }
            else {
                // Catch small files (don't do anything more than count them).
                // Don't deal with directories here because some directories
                // are marked in their root entry as zero length when in fact they are not.
                // We must get the extent list before we can know for sure about directories.
                SmallFiles++;
                continue;
            }
        }

        //This, of course, also inclues moveable directories.
        NumMoveableFiles++;

        // Increase the size of the list that will hold the names of all files and directories.
        VolData.NameListSize += (VolData.vFileName.GetLength() + 1) * sizeof(TCHAR);
    }

    //Note the total number of files on the disk for statistics purposes.
    VolData.TotalFiles = NumFiles;

    //Note the total number of dirs on the disk for statistics purposes.
    VolData.TotalDirs = NumDirs;

    // We've gone through every file on the disk, now compute the file list memory requirements
    VolData.MoveableFileListEntries = NumMoveableFiles;
    VolData.PagefileListEntries = (ULONG)VolData.NumPagefiles;

    //Now determine the sizes of each of the file list buffers.
    VolData.PagefileListSize            = (ULONG)VolData.NumPagefiles*sizeof(FILE_LIST_ENTRY);
    // Pad MoveableFileListSize by 1000 entries.  This covers the contingency that someone might add files between the end of this pass and the
    // beginning of the next.
    VolData.MoveableFileListSize    = (NumMoveableFiles+1000)*sizeof(FILE_LIST_ENTRY);

    // Determine the size the volume bitmap must be.
    EF_ASSERT(VolData.BitmapSize);

    // The name list size has already been determined directly,
    // but add 100 new file name spaces in case files are added.
    // Since this is * MAX_PATH it will actually go farther than 100 extra entries.
    // todo max_path - Does this get really huge?  Look at this method
    VolData.NameListSize += (100 * MAX_PATH);

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Do the scan of he volume, filling in the file lists with the extent data for each file on the volume.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Multiple VolData fields are used by PreScanFat and the functions is calls.  There are to many to practically enumerate here.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
ScanFat(
    )
{
    //acs bug #101862//
    double dFileRecordNumber = 0;
    UINT uPercentDoneMem = 0;
    uPass = 1;

    TCHAR* pNameList = VolData.pNameList;
    BEGIN_SCAN_INFO ScanInfo = {0};

    Message(TEXT("ScanFat"), -1, NULL);

    // Zero the memory buffers.
    if (VolData.MoveableFileListSize){
        ZeroMemory(VolData.pMoveableFileList, VolData.MoveableFileListSize);
    }

    if (VolData.NameListSize){
        ZeroMemory(VolData.pNameList, VolData.NameListSize);
    }

    // Reset the dir scanner for NextFatFile
    EF(GetFatBootSector());

    // Create a DiskView class cluster array for this volume
    AnalyzeView.SetClusterCount((int)VolData.TotalClusters);

    //1.0E00 Create a buffer to hold extent updates for DiskView.
    EF(CreateExtentBuffer());

    _tcscpy(ScanInfo.cVolumeName, VolData.cVolumeName);
    _tcscpy(ScanInfo.cDisplayLabel, VolData.cDisplayLabel);

    if(VolData.FileSystem == FS_FAT){
        _tcscpy(ScanInfo.cFileSystem, TEXT("FAT"));
    }
    else if(VolData.FileSystem == FS_FAT32){
        _tcscpy(ScanInfo.cFileSystem, TEXT("FAT32"));
    }

    // The defrag fields will equal zero since the structure is zero memoried above.
    // This means we're not sending defrag data.
    // Tell the UI that we're beginning the scan.
    DataIoClientSetData(ID_BEGIN_SCAN, (PTCHAR)&ScanInfo, sizeof(BEGIN_SCAN_INFO), pdataDfrgCtl);

    // Scan the disk for fragmented files, directories & pagefiles.
    while(TRUE){

        // Sleep if paused.
        while(VolData.EngineState == PAUSED){
            Sleep(1000);
        }

        // Terminate if told to stop by the controller - this is not an error.
        if(VolData.EngineState == TERMINATE){
            EH(PostMessage(hwndMain, WM_CLOSE, 0, 0));
            return TRUE;
        }

        // Get the next file to check.
        EF(NextFatFile());

        // Exit if done.
        if(VolData.vFileName.GetLength() == 0){
            break;
        }

        //acs bug #101862// Send progress bar status - max = 98%.
        dFileRecordNumber++;

        //acs// Upadate Percent done & progress bar.
        if(EnumeratedFatFiles != 0) {

            //acs bug #101862// Add 20% as we already got that from the prescan.
            uPercentDone = UINT(((dFileRecordNumber / EnumeratedFatFiles) *78)+20);

            //acs bug #101862// Only send it if there is a change - don't overload the SendStatusData
            if(uPercentDone > uPercentDoneMem) {
                SendStatusData();
                uPercentDoneMem = uPercentDone;
            }
        }

        // Check if this is a pagefile.
        EF(CheckForPagefileFat());

        if(VolData.bPageFile){

            // Reset this variable so the next file isn't automatically considered a pagefile.
            VolData.bPageFile = FALSE;

            // If this is the pagefile, set the pagefile stats.
            VolData.PagefileSize += VolData.FileSize;
            FILE_EXTENT_HEADER* pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;
            VolData.PagefileFrags += pFileExtentHeader->ExcessExtents + 1;

            // Put the pagefile's extents into shared memory
            EC(AddFileToListFat(
                VolData.pPagefileList,
                &VolData.PagefileListIndex,
                VolData.PagefileListSize,
                VolData.pExtentList));

            //Now add the file to the disk view map of disk clusters.
            EF(AddExtents(PageFileColor));

#ifndef DKMS // don't count the pagefile in the stats for the DKMS version
            //0.0E00 Keep track of fragged statistics.
            if (VolData.bFragmented){
                VolData.FraggedSpace += VolData.NumberOfClusters * VolData.BytesPerCluster;
                VolData.NumFraggedFiles++;
                VolData.NumExcessFrags += VolData.NumberOfFragments - 1;
            }
#endif
            continue;
        }

        // Get name, dir/file & size of next file
        if (!OpenFatFile()){
            continue;
        }

        // Check this BEFORE you get the extent list to save some time.
        // Catch small files (don't do anything with them in the scan).
        // Don't deal with directories here because some directories are marked in their root entry
        // as zero length when in fact they are not.  We must get the extent list before we can know for
        // sure about directories.
        if(VolData.FileSize == 0 && !VolData.bDirectory){
            continue;
        }

        // Get the file's extent list.
        EF(GetExtentList(DEFAULT_STREAMS, NULL));

        if (VolData.bDirectory){ // this is a directory.

            // If it's a small directory, don't do anything with it.
            if(VolData.FileSize == 0){
                continue;
            }

            //Now add the dir to the disk view map of disk clusters.
            EF(AddExtents(DirectoryColor));

            // If fragmented, update the appropriate statistics.
            if(VolData.bFragmented == TRUE){
                VolData.FraggedSpace += VolData.NumberOfClusters * VolData.BytesPerCluster;
                VolData.NumFraggedDirs++;
                VolData.NumExcessDirFrags += VolData.NumberOfFragments - 1;
            }
        }
        else { // Process files

            // Keep track of the total number of files so far.
            VolData.CurrentFile++;

            // Keep track of how many bytes there are in all files we've processed.
            VolData.TotalFileSpace += VolData.NumberOfClusters * VolData.BytesPerCluster;
            VolData.TotalFileBytes += VolData.FileSize;

            if(VolData.bFragmented) {
                EF(AddExtents(FragmentColor));

                // Keep track of the total amount of space on the disk containing fragmented files.
                VolData.FraggedSpace += VolData.NumberOfClusters * VolData.BytesPerCluster;

                // Keep track of the number of excess fragments.
                VolData.NumExcessFrags += VolData.NumberOfFragments - 1;

                // Keep track of the number of fragmented files.
                VolData.NumFraggedFiles ++;
            }
            else{ // NOT fragmented
                EF(AddExtents(UsedSpaceColor));
            }
        }

        // Add moveable files to the moveable file list.
        // we really can't move these, but put them there anyway, we filter them out later
        EF(AddFileToListFat(VolData.pMoveableFileList, &VolData.MoveableFileListIndex, VolData.MoveableFileListSize, VolData.pExtentList));

        // update cluster array
        PurgeExtentBuffer();
    }

    // Keep track of the average file size.
    if(VolData.CurrentFile != 0){
        VolData.AveFileSize = VolData.TotalFileBytes / VolData.CurrentFile;
    }

    // Make final computation of what percentage of the disk is fragmented.
    if (VolData.UsedSpace != 0) {
        VolData.PercentDiskFragged = 100 * VolData.FraggedSpace / VolData.UsedSpace;
    }
    else if (VolData.UsedClusters != 0 && VolData.BytesPerCluster != 0) {
        VolData.PercentDiskFragged = (100 * VolData.FraggedSpace) / 
                                     (VolData.UsedClusters * VolData.BytesPerCluster);
    }

    // Make final computation of the average fragments per file on the volume.
    if (VolData.NumFraggedFiles && VolData.CurrentFile){
        VolData.AveFragsPerFile = ((VolData.NumExcessFrags + VolData.CurrentFile) * 100) / VolData.CurrentFile;
    }

    //Send status data to the UI.
    SendStatusData();

    //Send the graphical data.
    SendGraphicsData();

    return TRUE;
}


DWORD
HandleBootOptimize()
{
    DWORD LayoutErrCode;

    LayoutErrCode = BootOptimize(VolData.hVolume, VolData.BitmapSize, VolData.BytesPerSector, 
                     VolData.TotalClusters, FALSE, 0, 
                     0, VolData.cDrive);         

    VolData.BootOptimizeBeginClusterExclude = 0;
    VolData.BootOptimizeEndClusterExclude = 0;

    if (IsBootVolume(VolData.cDrive)) {
        //update the voldata values for the new registry entries
        HKEY hValue = NULL;
        DWORD dwRegValueSize = 0;
        long ret = 0;
        TCHAR cRegValue[100];


        // get Boot Optimize Begin Cluster Exclude from registry
        dwRegValueSize = sizeof(cRegValue);
        ret = GetRegValue(
            &hValue,
            BOOT_OPTIMIZE_REGISTRY_PATH,
            BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION,
            cRegValue,
            &dwRegValueSize);

        RegCloseKey(hValue);
        //check to see if the key exists, else exit from routine
        if (ret == ERROR_SUCCESS) {
            VolData.BootOptimizeBeginClusterExclude = _ttoi(cRegValue);
        }
    
        // get Boot Optimize End Cluster Exclude from registry
        hValue = NULL;
        dwRegValueSize = sizeof(cRegValue);
        ret = GetRegValue(
            &hValue,
            BOOT_OPTIMIZE_REGISTRY_PATH,
            BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION,
            cRegValue,
            &dwRegValueSize);

        RegCloseKey(hValue);
        //check to see if the key exists, else exit from routine
        if (ret == ERROR_SUCCESS) {
            VolData.BootOptimizeEndClusterExclude = _ttoi(cRegValue);
        }
    }

    return LayoutErrCode;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Thread routine for defragmentation.

INPUT + OUTPUT:
    None.

GLOBALS:
    None.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
DefragThread(
    )
{
    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    
    // Get the time that the engine started.
    GetLocalTime(&VolData.StartTime);

    AcquirePrivilege(SE_BACKUP_NAME);

    // Do the Prescan.
    uEngineState = DEFRAG_STATE_REANALYZING;
    uPercentDone = 1;
    SendStatusData();
    if(!PreScanFat()){
        // IDMSG_SCANFAT_PRESCAN_ABORT - "ScanFAT: PreScan Aborted - Fatal Error - File "
        VString msg(IDMSG_SCANFAT_PRESCAN_ABORT, GetDfrgResHandle());
        msg.AddChar(L' ');
        PWSTR Temp = VolData.vFileName.GetBuffer();
        if (StartsWithVolumeGuid(Temp)) {
            
            if ((VolData.cDrive >= L'C') &&
                (VolData.cDrive <= L'Z')) {
                msg.AddChar(VolData.cDrive);
                msg.AddChar(L':');
            }

            msg += (PWSTR)(Temp + 48);
        }
        else {
            msg += VolData.vFileName;
        }

        // send error info to client
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

        // Log this into the EventLog.
        LogEvent(MSG_ENGINE_ERROR, msg.GetBuffer());

        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        ExitThread(0);
        return FALSE;
    }

    if(VolData.EngineState == TERMINATE){
        //1.0E00 We're done, close down now.
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        // Kill the thread.
        ExitThread(0);
    }

    //
    // Note whether updating the optimal layout was successful. Any errors 
    // will be ignored if we did not get launched just to optimize the layout.
    //

    // If command line was boot optimize -b /b, just do the boot optimize
    if(bCommandLineBootOptimizeFlag)
    {
        DWORD LayoutErrCode = HandleBootOptimize();
        //if we failed layout optimization, tell the client.
        if (LayoutErrCode != ENG_NOERR)
        {
            SendErrData(TEXT(""), LayoutErrCode);
        }

        //signal the client that we are done.
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        ExitThread(0);
        return TRUE;
    }
    // Allocate memory for the file lists.
    if (!AllocateFileLists()) {

        VString msg(IDS_OUT_OF_MEMORY, GetDfrgResHandle());
        msg += TEXT("\r\n");
        VString line2(IDS_SCANFAT_INIT_ABORT, GetDfrgResHandle());
        msg += line2;

        // send error info to client
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

        // Log this into the EventLog.
        LogEvent(MSG_ENGINE_ERROR, msg.GetBuffer());

        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        ExitThread(0);
        return FALSE;
    }

    // Do the Scan.
    if(!ScanFat()){
        // IDMSG_SCANFAT_SCAN_ABORT - "ScanFAT: Scan Aborted - Fatal Error - File:"
        VString msg(IDMSG_SCANFAT_SCAN_ABORT, GetDfrgResHandle());
        msg.AddChar(L' ');
        PWSTR Temp = VolData.vFileName.GetBuffer();
        if (StartsWithVolumeGuid(Temp)) {
            
            if ((VolData.cDrive >= L'C') &&
                (VolData.cDrive <= L'Z')) {
                msg.AddChar(VolData.cDrive);
                msg.AddChar(L':');
            }

            msg += (PWSTR)(Temp + 48);
        }
        else {
        	msg += VolData.vFileName;
        }

        // send error info to client
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

        // Log this into the EventLog.
        LogEvent(MSG_ENGINE_ERROR, msg.GetBuffer());

        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        ExitThread(0);
        return FALSE;
    }

    if(VolData.EngineState == TERMINATE){
        //1.0E00 We're done, close down now.
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        // Kill the thread.
        ExitThread(0);
    }

    //Send the report text data to the UI.
    SendReportData();

    // Defragment the Drive.
    uEngineState = DEFRAG_STATE_BOOT_OPTIMIZING;
    uPercentDone = 1;
    SendStatusData();
    HandleBootOptimize();
    //I moved this piece of code down here so that SendReportData() is executed
    //before ValidateFreeSpace() so that VolData is populated, else not all the 
    //calculations work.  I hope this doesn't cause any problems
    //add in the check for force flag in command line mode
    if(bCommandLineMode && !bCommandLineForceFlag)
    {
        TCHAR         msg[800];
    
        VolData.UsableFreeSpace = VolData.FreeSpace = (VolData.TotalClusters - VolData.UsedClusters) * 
                                                       VolData.BytesPerCluster;

        if(!ValidateFreeSpace(bCommandLineMode, VolData.FreeSpace, VolData.UsableFreeSpace, 
                              (VolData.TotalClusters * VolData.BytesPerCluster), 
                              VolData.cDisplayLabel, msg, sizeof(msg) / sizeof(TCHAR)))
        {
            //0.0E00 Log this into the EventLog.
            LogEvent(MSG_ENGINE_ERROR, msg);

            // send error info to client
            SendErrData(msg, ENGERR_LOW_FREESPACE);

            //0.0E00 Trigger an abort.
            PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

            // set the event to signaled, allowing the UI to proceed
            if (hDefragCompleteEvent){
                SetEvent(hDefragCompleteEvent);
            }

            ExitThread(0);
            return TRUE;
        }   
    }

    // Prepare to defragment.
	if (!InitializeDefrag()) {

		VString msg(IDS_SCANFAT_INIT_ABORT, GetDfrgResHandle());
		VString title(IDS_DK_TITLE, GetDfrgResHandle());
		ErrorMessageBox(msg.GetBuffer(), title.GetBuffer());

		// Trigger an abort.
		PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

		ExitThread(0);
		return FALSE;
	}

    // Defragment the Drive.
    uEngineState = DEFRAG_STATE_DEFRAGMENTING;
    SendStatusData();

    if(!DefragFat()){
        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        ExitThread(0);
        return FALSE;
    }

    // Note the end time for that pass.
    GetLocalTime(&VolData.EndTime);

    // mwp - Display the stats after the defrag.  Why was this left out
    DisplayFatVolumeStats();

    // If this engine has a visible window, write the basic statistics for this drive to the screen.
    Message(TEXT("Completed defragmentation - run analyze to see the results."), -1, NULL);

    // Now clean-up the extent buffer.  This will purge it as well, so we'll
    //have a fully up-to-date DiskView of the disk.
    EF(DestroyExtentBuffer());

    //Send status data to the UI.
    uEngineState = DEFRAG_STATE_DEFRAGMENTED;
    SendStatusData();

    //Send the graphical data to the UI.
    SendGraphicsData();

    //Send the report text data to the UI.
    SendReportData();

    //Send the most fragged list to the UI.
    SendMostFraggedList();

    // All done, close down now.
    PostMessage(hwndMain, WM_CLOSE, 0, 0);

    // set the event to signaled, allowing the UI to proceed
    if (hDefragCompleteEvent){
        SetEvent(hDefragCompleteEvent);
    }

    // Kill the thread.
    ExitThread(0);
    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
ROUTINE DESCRIPTION:
    Routine that carries out the defragmentation of a drive.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Multiple VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
DefragFatInitializePass(
    );

BOOL
DefragFatFiles(
    );

BOOL
DefragFat(
    )
{
    Message(TEXT("DefragFat"), -1, NULL);
    uPass = 0;
    VolData.Pass6Rep = 0;

    for(VolData.Pass = 1; VolData.Pass <= 6; VolData.Pass++) {

        uPass = VolData.Pass;
        
        switch(VolData.Pass){

        case 2:
        case 4:
            // If there are no fragmented files then Skip pass 2 & 4.
            if(VolData.NumFraggedFiles == 0) {
                VolData.Pass++;
            }
            break;

        case 6:
            // We are done if this is Pass 6 and we moved zero
            // files in the last pass or done Pass 5 five times.
            if(VolData.FilesMovedInLastPass == 0 || VolData.Pass6Rep > 5) {

                // WE ARE DONE.
                return TRUE;
            }
            // Do pass 5 again
            VolData.Pass = 5;
            VolData.Pass6Rep++;
            break;

        default:
            break;
        }
        // Initialize the next pass.
        if(!DefragFatInitializePass()) {
            return FALSE;
        }
        // Defragment the files for this pass.
        if(!DefragFatFiles()) {
            return FALSE;
        }

        //this does not work at all
        //bug # 101865
        //if the number of files moved in this pass for fragmented and contiguous
        //files is zero, then exit out of the defrag loop
//      if(VolData.FragmentedFileMovesSucceeded[VolData.Pass] == 0 &&
//         VolData.ContiguousFileMovesSucceeded[VolData.Pass] == 0)
//      {
//          return FALSE;
//      }
    }
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Routine initializes the required parameters based on the pass number.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal error.
*/

BOOL
DefragFatInitializePass(
    )
{
    TCHAR cString[300];
    FILE_LIST_ENTRY* pFileList = VolData.pMoveableFileList;

    // Note which stage this is.
    uPass = VolData.Pass;
    _stprintf(cString, TEXT("Pass %d"), VolData.Pass);
    Message(cString, -1, NULL);

    // After each pass, go through the fragged file list
    // and reset the high bit for each FRN. This means
    // we'll be able to defrag these files again on the next pass.
    for (UINT i = 0; i < VolData.MoveableFileListIndex; i ++) {

        if(pFileList[i].FileRecordNumber == 0){ 
            break; 
        }
        pFileList[i].Flags &= ~FLE_NEXT_PASS;
    }
    // Initialize the appropriate variables for the pass.
    switch(VolData.Pass){

    case 1:
        // Files can be moved from any point on the disk.
        VolData.SourceStartLcn = 0;
        VolData.SourceEndLcn = VolData.TotalClusters;

        // Files can be moved to any point on the disk.
        VolData.DestStartLcn = 0;
        VolData.DestEndLcn = VolData.TotalClusters;

        // Start at the end of the disk and move to the beginning.
        VolData.ProcessFilesDirection = BACKWARD;

        VolData.FilesMovedInLastPass = 0;

        dwMoveFlags = MOVE_CONTIGUOUS;
        break;

    case 2:
    case 4:
        // Files can be moved from any point on the disk.
        VolData.SourceStartLcn = 0;
        VolData.SourceEndLcn = VolData.TotalClusters;

        // Files can be moved to any point on the disk.
        VolData.DestStartLcn = 0;
        VolData.DestEndLcn = VolData.TotalClusters;

        // Start at the beginning of the disk and move to the end.
        VolData.ProcessFilesDirection = FORWARD;

        VolData.FilesMovedInLastPass = 0;

        dwMoveFlags = MOVE_FRAGMENTED;
        break;

    case 3:
    case 5:
        // Files can be moved from any point on the disk.
        VolData.SourceStartLcn = 0;
        VolData.SourceEndLcn = VolData.TotalClusters;

        // Files can be moved to any point on the disk.
        VolData.DestStartLcn = 0;
        VolData.DestEndLcn = VolData.TotalClusters;

        // Start at the end of the disk and move to the beginning.
        VolData.ProcessFilesDirection = BACKWARD;

        VolData.FilesMovedInLastPass = 0;

        dwMoveFlags = MOVE_FRAGMENTED|MOVE_CONTIGUOUS;
        break;

    default:
        EF_ASSERT(FALSE);
        VolData.Status = TERMINATE_ENGINE;
        return FALSE;
    }

    // Set which lcn to begin looking for files at depending on which direction on the disk the engine
    // is selecting files from. i.e. If the engine should start looking forward on the disk, LastStartingLcn
    // is just less than zero so that a file at the beginning of the disk gets moved first. i.e. If the
    // engine should start looking backward on the disk, LastStartingLcn is equivalent to the end of the
    // disk so that a file at the end of the disk gets moved first.
    VolData.LastStartingLcn = (VolData.ProcessFilesDirection == FORWARD) ? VolData.SourceStartLcn - 1 : VolData.SourceEndLcn;

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Defragments files on a volume based on the pass.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error or Terminate.
*/

BOOL
DefragFatFiles(
    )
{
    double dFileRecordNumber = 0;
    UINT uPercentDoneMem = 0;
    LONGLONG llNumFraggedFiles = VolData.NumFraggedFiles;
    LONGLONG llNumContiguousFiles = VolData.MoveableFileListEntries - VolData.NumFraggedFiles;

    //acs bug #101862// Upadate Percent done & progress bar.
    uPercentDone = 1;
    SendStatusData();

    VolData.Status = NEXT_FILE;

    // Do all the files on the disk.
    while(VolData.Status != NEXT_PASS && VolData.Status != TERMINATE_ENGINE) {

        // Sleep if paused.
        while(VolData.EngineState == PAUSED){
            Sleep(1000);
        }
        // Terminate if told to stop by the controller - this is not an error.
        if(VolData.EngineState == TERMINATE){
            PostMessage(hwndMain, WM_CLOSE, 0, 0);
            return FALSE;
        }
        // Get next file to process.
        if(!GetNextFatFile(dwMoveFlags)){
            VolData.Status = NEXT_PASS;
            continue;
        }
        //acs bug #101862// Increment for the Percent done & progress bar status.
        dFileRecordNumber++;

        // We have already opened thte file once during GetNextFatFile - we do not have to do it again.
        // Get the extent list & number of fragments in the file.
        if(!GetExtentList(DEFAULT_STREAMS, NULL)) {
            VolData.Status = NEXT_FILE;
            LOG_ERR();
            continue;
        }
        // Display the file data.
        DisplayFatFileSpecs();

        // Set the length of free space found to zero - We haven't found any yet.
        VolData.FoundLen = 0;
        VolData.Status = NEXT_ALGO_STEP;

        switch(VolData.Pass) {

        case 1:
            // Try to to consolidate some free space.

            //acs bug #101862// Upadate Percent done & progress bar.
            if(llNumContiguousFiles != 0) {

                //acs bug #101862// Calculate the Percent done.
                uPercentDone = UINT((dFileRecordNumber / llNumContiguousFiles) *100);

                //acs bug #101862// Only send it if there is a change - don't overload the SendStatusData
                if(uPercentDone != uPercentDoneMem) {
                    SendStatusData();
                    uPercentDoneMem = uPercentDone;

                    // Pause if the volume has a snapshot present
                    PauseOnVolumeSnapshot(VolData.cVolumeName);
                }
            }
            // Move contiguous files earlier.
            if(VolData.bFragmented == FALSE){

                // Put contiguous files earlier on the disk.
                if(FindFreeSpace(EARLIER)) {

                    Message(TEXT("MoveFatFile - EARLIER"), -1, NULL);
                    MoveFatFile();
                }
                else {
                    EndPassIfNoSpaces(); 
                }
            }
            break;

        case 2:
        case 4:
            // Defragment files on the disk. Move them earlier
            // but if necessary use the last half of the
            // disk as a temporary dumping zone.

            //acs bug #101862// Upadate Percent done & progress bar.
            if(llNumFraggedFiles != 0) {

                //acs bug #101862// Calculate the Percent done.
                uPercentDone = UINT((dFileRecordNumber / llNumFraggedFiles) *100);

                //acs bug #101862// Only send it if there is a change - don't overload the SendStatusData
                if(uPercentDone != uPercentDoneMem) {
                    SendStatusData();

                    uPercentDoneMem = uPercentDone;

                    //Pause if the volume has a snapshot present
                    PauseOnVolumeSnapshot(VolData.cVolumeName);
                }
            }
            // Do not move contiguous files on this pass.
            if(VolData.bFragmented == FALSE){
                VolData.Status = NEXT_FILE;
            }
            // Defrag fragmented files.
            else {

                // First, try to put them at the beginning of the disk.
                if(VolData.Status == NEXT_ALGO_STEP) {

                    if(FindFreeSpace(EARLIER)) {

                        if(VolData.Status == NEXT_ALGO_STEP){
                            Message(TEXT("MoveFatFile - EARLIER"), -1, NULL);
                            MoveFatFile();
                        }
                    }
                }
                // If that fails, try the last half of the disk.
                if(VolData.Status == NEXT_ALGO_STEP){

                    if(FindFreeSpace(FIRST_FIT)) {

                        if(VolData.Status == NEXT_ALGO_STEP){
                            Message(TEXT("MoveFatFile - LAST_FIT"), -1, NULL);
                            MoveFatFile();
                        }
                    }
                }
                // If that fails, defrag any way possible to get some change.
                if(VolData.Status == NEXT_ALGO_STEP){

                    if(FindLastFreeSpaceChunks()) {

                        if(VolData.Status == NEXT_ALGO_STEP){
                            Message(TEXT("PartialDefragFat"), -1, NULL);
                            PartialDefragFat();
                        }
                    }
                }
            }
            break;

        case 3:
        case 5:
            // Move all files working backwards from
            // the disk to the front of the disk.

            //acs bug #101862// Upadate Percent done & progress bar.
            if(EnumeratedFatFiles != 0) {

                //acs bug #101862// Calculate the Percent done.
                uPercentDone = UINT((dFileRecordNumber / EnumeratedFatFiles) *100);

                //acs bug #101862// Only send it if there is a change - don't overload the SendStatusData
                if(uPercentDone != uPercentDoneMem) {
                    SendStatusData();
                    uPercentDoneMem = uPercentDone;

                    //Pause if the volume has a snapshot present
                    PauseOnVolumeSnapshot(VolData.cVolumeName);
                }
            }
            // Move contiguous files earlier.
            if(VolData.bFragmented == FALSE){

                // Put contiguous files earlier on the disk.
                if(FindFreeSpace(EARLIER)) {

                    Message(TEXT("MoveFatFile - EARLIER"), -1, NULL);
                    MoveFatFile();
                }
                else {
                    EndPassIfNoSpaces(); 
                }
            }
            // Defrag fragmented files.
            else{
                // First, try to put them at the beginning of the disk.
                if(FindFreeSpace(EARLIER)) {

                    Message(TEXT("MoveFatFile - EARLIER"), -1, NULL);
                    MoveFatFile();
                }
//              else {
//                  EndPassIfNoSpaces(); 
//              }
            }
            break;

        default:
            EF_ASSERT(FALSE);
            VolData.Status = TERMINATE_ENGINE;
            return FALSE;
        }
        // Clean up resources.
        if(VolData.hFile != INVALID_HANDLE_VALUE) {

            // Send graphics display data only
            // if we moved a file. We know
            // because we have a file handle.
            PurgeExtentBuffer();

            CloseHandle(VolData.hFile);
            VolData.hFile = INVALID_HANDLE_VALUE;
        }
        if(VolData.hFreeExtents != NULL) {
            EH_ASSERT(GlobalUnlock(VolData.hFreeExtents) == FALSE);
            EH_ASSERT(GlobalFree(VolData.hFreeExtents) == NULL);
            VolData.hFreeExtents = NULL;
        }
    }
    TCHAR cString[300];
    _stprintf(cString, TEXT("Pass completed - FilesMovedInLastPass = %d"), (ULONG)VolData.FilesMovedInLastPass);
    Message(cString, -1, NULL);
    return TRUE;

}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    If there are no spaces found to move a file into, then set the variable to end the pass.
    Otherwise, just go on normally.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN VolData.LargestFound - The largest free space that was found.
    OUT VolData.Status      - Equals NEXT_PASS if there are no spaces, or NEXT_ALGO_STEP otherwise.

RETURN:
    TRUE - Success.
*/

BOOL
EndPassIfNoSpaces(
    )
{
    if(VolData.LargestFound == 0) {
        Message(TEXT(""), -1, NULL);
        Message(TEXT("Ending pass because no more spaces left to move files into."), -1, NULL);
        VolData.Status = NEXT_PASS;
    }
    else {
        VolData.Status = NEXT_ALGO_STEP;
    }

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    If the last bitmap routine didn't find any space, then go onto the next file.
    Otherwise, go onto the next algorithm step.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN VolData.FoundLen - The free space that was found to move this file into.
    OUT VolData.Status  - Equals NEXT_PASS if there are no spaces, or NEXT_ALGO_STEP otherwise.

RETURN:
    TRUE - Success.
*/

BOOL
NextFileIfFalse(
    )
{
    if(VolData.FoundLen == 0){
        VolData.Status = NEXT_FILE;
    }else{
        VolData.Status = NEXT_ALGO_STEP;
    }
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Partially defrags a FAT file.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN VolData.hFreeExtents - Used to determine if there is free space to move the file into.
    OUT VolData.Status      - Can be any of several values returned from CheckFileForExclude() or PartialDefrag().

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
PartialDefragFat(
    )
{
    // Check to see if there any free space.
    if(VolData.hFreeExtents == NULL) {
        return TRUE;
    }
    // Check if file is in exclude list
    if(!CheckFileForExclude()) {
        return VolData.Status;
    }
    // Move the file
    if(!PartialDefrag()) {
        return FALSE;
    }
    //1.0E00 Note that a file was moved (update the file moved counters).
    VolData.FilesMoved ++;
    VolData.FilesMovedInLastPass ++;
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    After a place has been found to move this file to, this function will move it there.

INPUT + OUTPUT:
    None.

GLOBALS:
    OUT VolData.Status - Can be any of several values returned from CheckFileForExclude() or MoveFile().

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
MoveFatFile(
    )
{
    LONGLONG RunLength = VolData.NumberOfClusters;

    // Check to see if there is enough free space.
    if(VolData.FoundLen < RunLength) {
        VolData.Status = NEXT_ALGO_STEP;
        return FALSE;
    }
    // Check if file is in exclude list
    if(!CheckFileForExclude()) {
        VolData.Status = NEXT_FILE;
        return FALSE;
    }

    // VolData.Status already set.
    return MoveFile();
}

void SendGraphicsData()
{
    char * pAnalyzeLineArray = NULL;
    char * pDefragLineArray = NULL;
    DISPLAY_DATA * pDispData = NULL;

    __try {

        // Kill the timer until we're done.
        KillTimer(hwndMain, DISKVIEW_TIMER_ID);

        // don't send the data unless the engine is running
        if (VolData.EngineState != RUNNING){
            return;
        }

        // if DiskView didn't get memory, forget it
        if (!AnalyzeView.HasMapMemory() || !DefragView.HasMapMemory()) {
            SendGraphicsMemoryErr();
            return;
        }

        DISPLAY_DATA DisplayData = {0};
        DWORD dwDispDataSize = 0;

        // get copies of line arrays for analyze and defrag
        // (delete copy when finished)
        AnalyzeView.GetLineArray(&pAnalyzeLineArray, &DisplayData.dwAnalyzeNumLines);
        DefragView.GetLineArray(&pDefragLineArray, &DisplayData.dwDefragNumLines);

        // Allocate enough memory to hold both analyze and defrag displays.
        // If only analyze or defrag is present, then the NumLines field for the
        // other one will equal zero -- hence no additional allocation.
        dwDispDataSize =
            DisplayData.dwAnalyzeNumLines +
            DisplayData.dwDefragNumLines +
            sizeof(DISPLAY_DATA);

        // If neither an analyze diskview nor a defrag diskview are present, don't continue.
        if (DisplayData.dwAnalyzeNumLines == 0 && DisplayData.dwDefragNumLines == 0) {
            return;
        }

        pDispData = (DISPLAY_DATA *) new char[dwDispDataSize];

        // If we can't get memory, don't continue.
        if (pDispData == NULL) {
            return;
        }

        wcscpy(pDispData->cVolumeName, VolData.cVolumeName);

        // Copy over the fields for the analyze and defrag data.
        // If only one or the other is present, the fields for the other will equal zero.
        pDispData->dwAnalyzeNumLines        = DisplayData.dwAnalyzeNumLines;
        pDispData->dwDefragNumLines         = DisplayData.dwDefragNumLines;

        // Get the line array for the analyze view if it exists.
        if (pAnalyzeLineArray) {
            CopyMemory((char*) &(pDispData->LineArray),
                        pAnalyzeLineArray,
                        DisplayData.dwAnalyzeNumLines);
        }

        // Get the line array for the defrag view if it exists
        if (pDefragLineArray) {
            CopyMemory((char*) ((BYTE*)&pDispData->LineArray) + DisplayData.dwAnalyzeNumLines,
                        pDefragLineArray,
                        DisplayData.dwDefragNumLines);
        }

        // If the gui is connected, send gui data to it
        DataIoClientSetData(ID_DISP_DATA, (TCHAR*) pDispData, dwDispDataSize, pdataDfrgCtl);
        Message(TEXT("engine sending graphics to UI"), -1, NULL);
    }
    __finally {

        // clean up
        if (pAnalyzeLineArray) {
            delete [] pAnalyzeLineArray;
        }

        if (pDefragLineArray) {
            delete [] pDefragLineArray;
        }

        if (pDispData) {
            delete [] pDispData;
        }

        // reset the next timer for updating the disk view
        if(SetTimer(hwndMain, DISKVIEW_TIMER_ID, DiskViewInterval, NULL) != 0)
        {
            LOG_ERR();
        }   
    }
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This is the exit routine which will clean up all the open handles, free up all unused memory etc.

INPUT + OUTPUT:
    None.

GLOBALS:
    Pointless to enumerate here -- all unhandled handles (pun intended) and allocated memories are closed/freed.

RETURN:
    None.

*/

VOID
Exit(
    )
{
    if (TERMINATE != VolData.EngineState) {
        VolData.EngineState = TERMINATE;
        Sleep(3000);    // give the other thread a few seconds to realise we're going away
    }

    // Delete the pointer to the GUI object.
    ExitDataIoClient(&pdataDfrgCtl);

    //If we were logging, then close the log file.
    if(bLogFile){
        ExitLogFile();
    }

    // If the gui is still connected, force a disconnection, error message and continue.  This shouldn't happen.
    // Cleanup our internal memory allocations and handles.
    if(hThread){
        DWORD dwExitCode = 0;
        //If the worker thread is still active, then terminate it.
        GetExitCodeThread(hThread, &dwExitCode);
        if(dwExitCode == STILL_ACTIVE){
            WaitForSingleObject(hThread, 10000);
        }
        CloseHandle(hThread);
        hThread = NULL;
    }

    CoUninitialize();

    
/*

    (guhans, cenke, 01/09/01)   
    Process is exiting. To exit fast we don't wait for the worker thread 
    to exit, or free the global memory it might be using. 
  
   
    if(GetDfrgResHandle() != NULL)
    {
        FreeLibrary(GetDfrgResHandle());
    }

    if(VolData.hVolume){
        CloseHandle(VolData.hVolume);
    }
    if(VolData.hFile != INVALID_HANDLE_VALUE){
        CloseHandle(VolData.hFile);
        VolData.hFile = INVALID_HANDLE_VALUE;
    }
    if(VolData.hExtentList){
        EH_ASSERT(GlobalUnlock(VolData.hExtentList) == FALSE);
        EH_ASSERT(GlobalFree(VolData.hExtentList) == NULL);
    }

    if(VolData.hVolumeBitmap){
        EH_ASSERT(GlobalFree(VolData.hVolumeBitmap) == NULL);
    }
    if(VolData.hExcludeList){
        EH_ASSERT(GlobalFree(VolData.hExcludeList) == NULL);
    }

    if(hPageFileNames){
        EH_ASSERT(GlobalUnlock(hPageFileNames) == FALSE);
        EH_ASSERT(GlobalFree(hPageFileNames) == NULL);
    }

    // Free up the file lists.
    DeallocateFileLists();
*/
    // Close event logging.
    CleanupLogging();
    //Close the error log.
    ExitErrorLog();
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the name of the pagefiles and store them in a double null-terminated list of null terminated strings.

INPUT + OUTPUT:
    IN cDrive           - The current drive so that this can tell which pagefile names to store. (Only the current drive.)
    OUT phPageFileNames - Where to store the handle for the allocated memory.
    OUT ppPageFileNames - Where to store the pointer for the pagefile names.

GLOBALS:
    None.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
GetPagefileNames(
    IN TCHAR cDrive,
    OUT HANDLE * phPageFileNames,
    OUT TCHAR ** ppPageFileNames
    )
{
    HKEY hKey = NULL;
    ULONG lRegLen = 0;
    int i;
    int iStrLen;
    int iNameStart;
    TCHAR * pTemp;
    TCHAR * pProcessed;
    DWORD dwRet = 0;
    DWORD dwType = 0;

    if (cDrive == NULL){
        //this is a mounted volume, and pagefiles cannot be placed on a mounted volumes
        EF(AllocateMemory(2, phPageFileNames, (void**)ppPageFileNames));
        ZeroMemory((PVOID) *ppPageFileNames, 2);
        return TRUE;
    }

    // Open the registry key to the pagefile.
    EF_ASSERT(ERROR_SUCCESS == RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
                0,
                KEY_QUERY_VALUE,
                &hKey));


    // Find out how much memory we need to hold the value pagefile names.
    EF_ASSERT(ERROR_SUCCESS == RegQueryValueEx(
                hKey,
                TEXT("PagingFiles"),
                0,
                &dwType,
                NULL,
                &lRegLen));

    // If there is no data then allocate enough for two bytes (a double termination).
    if(lRegLen<2){
        lRegLen = 2;
    }

    // Allocate enough memory.
    EF(AllocateMemory(lRegLen, phPageFileNames, (void**)ppPageFileNames));

    // Get the value.
    EF_ASSERT(ERROR_SUCCESS ==RegQueryValueEx(
                hKey,
                TEXT("PagingFiles"),
                0,
                &dwType,
                (LPBYTE)*ppPageFileNames,
                &lRegLen));

    // Strip out the numbers and drive letters so that we have only the pagefile names.
    //The REG_MULTI_SZ type has a series of null terminated strings with a double null termination at the end
    //of the list.
    //The format of each string is "c:\pagefile.sys 100 100".  The data after the slash and before the first space
    //is the page file name.  The numbers specify the size of the pagefile which we don't care about.
    //We extract the filename minus the drive letter of the pagefile (which must be in the root dir so we don't
    //need to worry about subdirs existing).  Therfore we put a null at the first space, and shift the pagefile
    //name earlier so that we don't have c:\ in there.  The end product should be a list of pagefile
    //names with a double null termination for example:  "pagefile.sys[null]pagefile2.sys[null][null]"  Furthermore,
    //we only take names for this drive, so the string may simply consist of a double null termination.
    //We use the same memory space for output as we use for input, so we just clip the pagefile.sys and bump it up
    //to the beginning of ppPageFileNames.  We keep a separate pointer which points to the next byte after
    //The previous outputed data.

    pProcessed = pTemp = *ppPageFileNames;

    // For each string...
    while(*pTemp!=0){

        iStrLen = lstrlen(pTemp);

        // If this pagefile is on the current drive.
        if((TCHAR)CharUpper((TCHAR*)pTemp[0]) == (TCHAR)CharUpper((TCHAR*)cDrive)){
            // Go through each character in this string.
            for(i=0; i<iStrLen; i++){
                // If this is a slash, then the next character is the first of the pagefile name.
                if(pTemp[i] == TEXT('\\')){
                    iNameStart = i+1;
                    continue;
                }
                // If this is a space then the rest of the string is numbers.  Null terminate it here.
                if(pTemp[i] == TEXT(' ')){
                    pTemp[i] = 0;
                    break;
                }
            }
            // Bump the string up so all the processed names are adjacent.
            MoveMemory(pProcessed, pTemp+iNameStart, (lstrlen(pTemp+iNameStart)+1)*sizeof(TCHAR));

            // Note where the next string should go.
            pProcessed += lstrlen(pProcessed) + 1;
        }
        // If this pagefile is not on this current drive then simply ignore it.
        else{
        }

        // Note where to search for the next string.
        pTemp += iStrLen + 1;
    }

    // Add double null termination.
    *pProcessed = 0;

    EF_ASSERT(RegCloseKey(hKey)==ERROR_SUCCESS);
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Check to see if a file is a pagefile and grab it's extent list if it is.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN pPageFileNames           - Pointer to the memory that holds the list of active pagefile names for this drive.
    IN VolData.cFileName        - The name of the file to check.
//  OUT VolData.PagefileFrags   - The number of fragments in the pagefile.
    OUT VolData.bPageFile       - TRUE if this is a pagefile, false otherwise.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
CheckForPagefileFat(
    )
{
    // find the last backslash in the path
    TCHAR *cFileName = NULL;

    if (VolData.vFileName.GetLength() > 0) {
        cFileName = wcsrchr(VolData.vFileName.GetBuffer(), L'\\');
    }
    
    if (cFileName == (TCHAR *) NULL){
        return TRUE;
    }

    cFileName++; // start at first character after the last backslash

    // Check it against the pagefile list.
    BOOL bIsPageFile = CheckPagefileNameMatch(cFileName, pPageFileNames);

    // return if not a pagefile
    if(bIsPageFile == FALSE){
        return TRUE; // TRUE means no error occurred
    }

    // Since we're getting the extent list manually, we have to offset the
    // starting lcn to account for the fact that
    // the first data cluster is cluster 2.
    VolData.StartingLcn -= 2;

    // Get the extent list for the pagefile.
    EF(GetExtentListManuallyFat());

    VolData.bPageFile = TRUE;

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Check a name against all the pagefile names to see if this name matches that of a pagefile.

INPUT + OUTPUT:
    IN pCompareName     - The name of that we are checking to see if it is a pagefile.
    IN pPageFileNames   - The list of pagefile names for this drive.

GLOBALS:
    None.

RETURN:
    TRUE - This file name is a pagefile
    FALSE - This file name is NOT a pagefile
*/

BOOL
CheckPagefileNameMatch(
    IN TCHAR * pCompareName,
    IN TCHAR * pPageFileNames
    )
{
    require(pCompareName);
    require(pPageFileNames);

    // Loop through all the pagefile names -- the list is double null terminated.
    while(*pPageFileNames!=0){
        // Check if these names match.
        if(!lstrcmpi(pCompareName, pPageFileNames)){
            return TRUE;
        }
        // If not then move to the next name.
        else{
            pPageFileNames+=lstrlen(pPageFileNames)+1;
        }
    }
    // No match with any of the names, so return FALSE.
    return FALSE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Prints out the disk statistics on screen.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN various VolData fields that get printed onto the screen.

RETURN:
    None.
*/

VOID
DisplayFatVolumeStats(
)
{
    TCHAR cString[200];
    ULONG iTmp;

    _stprintf(cString, TEXT("Total sectors on disk = %I64d"), VolData.TotalSectors);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Bytes per sector = %I64d"), VolData.BytesPerSector);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Bytes per cluster = %I64d"), VolData.BytesPerCluster);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Sectors per cluster = %I64d"), VolData.SectorsPerCluster);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Total clusters on disk = %I64d"), VolData.TotalClusters);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Volume Bitmap Size = %I64d"), VolData.BitmapSize);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Disk Size = %I64d"), VolData.TotalClusters * VolData.BytesPerCluster);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Cluster Size = %I64d"), VolData.BytesPerCluster);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Used Space = %I64d bytes"), VolData.UsedClusters * VolData.BytesPerCluster);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Free Space = %I64d bytes"), (VolData.TotalClusters - VolData.UsedClusters) * VolData.BytesPerCluster);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Pagefile Size = %I64d"), VolData.PagefileSize);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Pagefile Fragments = %I64d"), VolData.PagefileFrags);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Total Directories = %I64d"), VolData.TotalDirs);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Fragmented Dirs = %I64d"), VolData.NumFraggedDirs);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Excess Dir Frags = %I64d"), VolData.NumExcessDirFrags);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Total Files = %I64d"), VolData.TotalFiles);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Avg. File Size = %7ld.%ld kb"), (int)VolData.AveFileSize / 1024, (10 * (VolData.AveFileSize % 1024)) / 1024);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Fragmented Files = %I64d"), VolData.NumFraggedFiles);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Excess Fragments = %I64d"), VolData.NumExcessFrags);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    if (VolData.TotalClusters - VolData.UsedClusters){
        iTmp =  (ULONG)(100 * VolData.NumFreeSpaces /
                (VolData.TotalClusters - VolData.UsedClusters));
    }
    else {
        iTmp = -1;
    }
    _stprintf(cString, TEXT("Free Space Fragmention Percent = %ld"), iTmp);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("Fragged Space = %I64d bytes"), VolData.FraggedSpace);
    Message(cString, -1, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("File Fragmention Percent = %I64d"), VolData.PercentDiskFragged);
    Message(cString, S_OK, NULL);
    WriteStringToLogFile(cString);

    ULONG ulTotalFragFileMoves = 0;
    ULONG ulTotalFragFileFail = 0;
    ULONG ulTotalFragFilePass = 0;
    ULONG ulTotalContigFileMoves = 0;
    ULONG ulTotalContigFileFail = 0;
    ULONG ulTotalContigFilePass = 0;

    if (uEngineState == DEFRAG_STATE_DEFRAGMENTING){ // do not display the post-analysis stats (they're all 0)
        WriteStringToLogFile(TEXT("Statistics by Pass"));
        Message(TEXT("Statistics by Pass"), -1, NULL);
        for (UINT uPass=0; uPass<PASS_COUNT; uPass++){

            ulTotalFragFileMoves += VolData.FragmentedFileMovesAttempted[uPass];
            ulTotalFragFileFail += VolData.FragmentedFileMovesFailed[uPass];
            ulTotalFragFilePass += VolData.FragmentedFileMovesSucceeded[uPass];

            ulTotalContigFileMoves += VolData.ContiguousFileMovesAttempted[uPass];
            ulTotalContigFileFail += VolData.ContiguousFileMovesFailed[uPass];
            ulTotalContigFilePass += VolData.ContiguousFileMovesSucceeded[uPass];

            _stprintf(cString, TEXT("Pass %d:"), uPass+1);
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);

            _stprintf(cString, TEXT("   Total Volume Buffer Flushes     = %5d"), VolData.VolumeBufferFlushes[uPass]);
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);
            WriteStringToLogFile(TEXT(""));

            _stprintf(cString, TEXT("   Fragmented File Moves Attempted = %5d"),
                VolData.FragmentedFileMovesAttempted[uPass]);
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);

            if (VolData.FragmentedFileMovesAttempted[uPass]){
                _stprintf(cString, TEXT("   Fragmented File Moves Succeeded = %5d, %3d%%"),
                    VolData.FragmentedFileMovesSucceeded[uPass],
                    100 * VolData.FragmentedFileMovesSucceeded[uPass] / VolData.FragmentedFileMovesAttempted[uPass]);
                Message(cString, -1, NULL);
                WriteStringToLogFile(cString);

                _stprintf(cString, TEXT("   Fragmented File Moves Failed    = %5d, %3d%%"),
                    VolData.FragmentedFileMovesFailed[uPass],
                    100 * VolData.FragmentedFileMovesFailed[uPass] / VolData.FragmentedFileMovesAttempted[uPass]);
                Message(cString, -1, NULL);
                WriteStringToLogFile(cString);
            }

            WriteStringToLogFile(TEXT(""));
            _stprintf(cString, TEXT("   Contiguous File Moves Attempted = %5d"),
                VolData.ContiguousFileMovesAttempted[uPass]);
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);

            if (VolData.ContiguousFileMovesAttempted[uPass]){
                _stprintf(cString, TEXT("   Contiguous File Moves Succeeded = %5d, %3d%%"),
                    VolData.ContiguousFileMovesSucceeded[uPass],
                    100 * VolData.ContiguousFileMovesSucceeded[uPass] / VolData.ContiguousFileMovesAttempted[uPass]);
                Message(cString, -1, NULL);
                WriteStringToLogFile(cString);

                _stprintf(cString, TEXT("   Contiguous File Moves Failed    = %5d, %3d%%"),
                    VolData.ContiguousFileMovesFailed[uPass],
                    100 * VolData.ContiguousFileMovesFailed[uPass] / VolData.ContiguousFileMovesAttempted[uPass]);
                Message(cString, -1, NULL);
                WriteStringToLogFile(cString);
            }
        }

        Message(TEXT("Totals:"), -1, NULL);
        WriteStringToLogFile(TEXT("Totals:"));

        _stprintf(cString, TEXT("   Total File Moves Attempted =      %5d"), ulTotalFragFileMoves + ulTotalContigFileMoves);
        Message(cString, -1, NULL);
        WriteStringToLogFile(cString);

        if (VolData.TotalDirs + VolData.TotalFiles > 0){
            _stprintf(cString, TEXT("   File Moves Attempted/File =         %3d%%"),
                100 * (ulTotalFragFileMoves + ulTotalContigFileMoves) / (VolData.TotalDirs + VolData.TotalFiles));
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);
        }

        _stprintf(cString, TEXT("   Fragmented File Moves Attempted = %5d"), ulTotalFragFileMoves);
        Message(cString, -1, NULL);
        WriteStringToLogFile(cString);

        if (ulTotalFragFileMoves){
            _stprintf(cString, TEXT("   Fragmented File Moves Succeeded = %5d, %3d%%"),
                ulTotalFragFilePass,
                100 * ulTotalFragFilePass / ulTotalFragFileMoves);
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);

            _stprintf(cString, TEXT("   Fragmented File Moves Failed    = %5d, %3d%%"),
                ulTotalFragFileFail,
                100 * ulTotalFragFileFail / ulTotalFragFileMoves);
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);
        }

        WriteStringToLogFile(TEXT(""));
        _stprintf(cString, TEXT("   Contiguous File Moves Attempted = %5d"), ulTotalContigFileMoves);
        Message(cString, -1, NULL);
        WriteStringToLogFile(cString);

        if (ulTotalContigFileMoves){
            _stprintf(cString, TEXT("   Contiguous File Moves Succeeded = %5d, %3d%%"),
                ulTotalContigFilePass,
                100 * ulTotalContigFilePass / ulTotalContigFileMoves);
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);

            _stprintf(cString, TEXT("   Contiguous File Moves Failed    = %5d, %3d%%"),
                ulTotalContigFileFail,
                100 * ulTotalContigFileFail / ulTotalContigFileMoves);
            Message(cString, -1, NULL);
            WriteStringToLogFile(cString);
        }
    }
    // time data
    _stprintf(cString, TEXT("Start Time = %s"), GetTmpTimeString(VolData.StartTime));
    Message(cString, S_OK, NULL);
    WriteStringToLogFile(cString);

    _stprintf(cString, TEXT("End Time = %s"), GetTmpTimeString(VolData.EndTime));
    Message(cString, S_OK, NULL);
    WriteStringToLogFile(cString);

    DWORD dwSeconds;
    if (GetDeltaTime(&VolData.StartTime, &VolData.EndTime, &dwSeconds)){
        _stprintf(cString, TEXT("Delta Time = %d seconds"), dwSeconds);
        Message(cString, S_OK, NULL);
        WriteStringToLogFile(cString);
    }

    WriteStringToLogFile(L"------------- End of Log --------------");

    Message(TEXT(""), -1, NULL);
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Displays data about the current file for the developer.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN Various VolData fields.

RETURN:
    None.
*/

VOID
DisplayFatFileSpecsFunction(
    )
{
    TCHAR cString[200];

    Message(TEXT(""), -1, NULL);

    // Display File Name, number of extents and number of fragments.
    Message(ESICompressFilePath(VolData.vFileName), -1, NULL);
    wsprintf(cString, TEXT("Extents = 0x%lX "), ((FILE_EXTENT_HEADER*)VolData.pExtentList)->ExcessExtents);
    Message(cString, -1, NULL);

    wsprintf(cString,
             TEXT("%s %s at Lcn 0x%lX for Cluster Count of 0x%lX"),
             (VolData.bFragmented == TRUE) ? TEXT("Fragmented") : TEXT("Contiguous"),
             (VolData.bDirectory) ? TEXT("Directory") : TEXT("File"),
             (ULONG)VolData.StartingLcn,
             (ULONG)VolData.NumberOfClusters);
    Message(cString, -1, NULL);
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Allocates memory for the file lists.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN VolData.SysListSize          - System file list.
    OUT VolData.hSysList
    OUT VolData.pSysList
    IN VolData.DirListSize          - Directory file list.
    OUT VolData.hDirList
    OUT VolData.pDirList
    IN VolData.ContiguousListSize   - Contiguous file list.
    OUT VolData.hContiguousList
    OUT VolData.pContiguousList
    IN VolData.PagefileListSize     - Page file list.
    OUT VolData.hPagefileList
    OUT VolData.pPagefileList
    IN VolData.NameListSize         - The name list is only used by the FAT engine, but this is a common routine.
    OUT VolData.hNameList
    OUT VolData.pNameList

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
AllocateFileLists(
    )
{
    TCHAR cString[300];

    if(VolData.SysListSize>0){ // this is never > 0 for FAT
        wsprintf(cString, TEXT("SysList - Allocating %x bytes"), VolData.SysListSize);
        Message(cString, -1, NULL);
        if (!AllocateMemory(VolData.SysListSize, &VolData.hSysList,(void**)&VolData.pSysList)) {
            EF(FALSE);
        }
    }
    if(VolData.MoveableFileListSize>0){
        wsprintf(cString, TEXT("MoveableFileList - Allocating %x bytes"), VolData.MoveableFileListSize);
        Message(cString, -1, NULL);
        if (!AllocateMemory(VolData.MoveableFileListSize, &VolData.hMoveableFileList, (void**)&VolData.pMoveableFileList)) {
            EF(FALSE);
        }
    }
    if(VolData.PagefileListSize>0){
        wsprintf(cString, TEXT("PagefileList - Allocating %x bytes"), VolData.PagefileListSize);
        Message(cString, -1, NULL);
        if (!AllocateMemory(VolData.PagefileListSize, &VolData.hPagefileList, (void**)&VolData.pPagefileList)) {
            EF(FALSE);
        }
    }
    if(VolData.NameListSize>0){
        wsprintf(cString, TEXT("NameList - Allocating %x bytes"), VolData.NameListSize);
        Message(cString, -1, NULL);
        if (!AllocateMemory(VolData.NameListSize, &VolData.hNameList, (void**)&VolData.pNameList)) {
            EF(FALSE);
        }
    }
    wsprintf(cString, TEXT("File list memories alloced for Drive %s"), VolData.cDisplayLabel);
    Message(cString, S_OK, NULL);
    Message(TEXT(""), -1, NULL);

    return TRUE;
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Deallocates the mapping files for the file lists.

INPUT + OUTPUT:
    None.

GLOBALS:
    Similar to AllocateFileLists above.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
DeallocateFileLists(
    )
{
    TCHAR cString[200];

    if(VolData.hSysList){
        EH_ASSERT(GlobalUnlock(VolData.hSysList) == FALSE);
        EH_ASSERT(GlobalFree(VolData.hSysList) == NULL);
        VolData.hSysList = NULL;
        VolData.pSysList = NULL;
    }
    if(VolData.hMoveableFileList){
        EH_ASSERT(GlobalUnlock(VolData.hMoveableFileList) == FALSE);
        EH_ASSERT(GlobalFree(VolData.hMoveableFileList) == NULL);
        VolData.hMoveableFileList = NULL;
        VolData.pMoveableFileList = NULL;
    }
    if(VolData.hPagefileList){
        EH_ASSERT(GlobalUnlock(VolData.hPagefileList) == FALSE);
        EH_ASSERT(GlobalFree(VolData.hPagefileList) == NULL);
        VolData.hPagefileList = NULL;
        VolData.pPagefileList = NULL;
    }
    if(VolData.hNameList){
        EH_ASSERT(GlobalUnlock(VolData.hNameList) == FALSE);
        EH_ASSERT(GlobalFree(VolData.hNameList) == NULL);
        VolData.hNameList = NULL;
        VolData.pNameList = NULL;
    }
    wsprintf(cString, TEXT("Shared memory freed for Drive %s:"), VolData.cDisplayLabel);
    Message(cString, -1, NULL);
    return TRUE;
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:

GLOBALS:

RETURN:
    TRUE - Success.
    FALSE - Fatal error.
*/
BOOL
SendMostFraggedList(
    )
{
    CFraggedFileList fraggedFileList(VolData.cVolumeName);

    // Build the most fragged list.
    EF(FillMostFraggedList(fraggedFileList));

    // create the block of data to send to UI
    EF(fraggedFileList.CreateTransferBuffer());

    // Send the packet to the UI.
    DataIoClientSetData(
        ID_FRAGGED_DATA,
        fraggedFileList.GetTransferBuffer(),
        fraggedFileList.GetTransferBufferSize(),
        pdataDfrgCtl);

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:

RETURN:
    None.
*/

VOID
SendStatusData(
    )
{
    STATUS_DATA statusData = {0};

    //acs bug #101862//
    statusData.dwPass = uPass;
    _tcsncpy(statusData.cVolumeName, VolData.cVolumeName,GUID_LENGTH);
    statusData.dwPercentDone = (uPercentDone > 100 ? 100 : uPercentDone);
    statusData.dwEngineState = uEngineState;

    if(VolData.vFileName.GetLength() > 0)
    {
        _tcsncpy(statusData.vsFileName, VolData.vFileName.GetBuffer(),200);
    }

    //If the gui is connected, send gui data to it.
    DataIoClientSetData(ID_STATUS, (TCHAR*)&statusData, sizeof(STATUS_DATA), pdataDfrgCtl);
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:

RETURN:
    None.
*/

VOID
SendReportData(
    )
{
    TEXT_DATA textData = {0};

    _tcscpy(textData.cVolumeName, VolData.cVolumeName);
    _tcscpy(textData.cVolumeLabel, VolData.cVolumeLabel);
    if(VolData.FileSystem == FS_FAT32){
        _tcscpy(textData.cFileSystem, TEXT("FAT32"));
    }
    else{
        _tcscpy(textData.cFileSystem, TEXT("FAT"));
    }

    //Figure out how many free spaces there are on the drive.
    CountFreeSpaces();

    // get usable free space
    LONGLONG llUsableFreeClusters;
    if (DetermineUsableFreespace(&llUsableFreeClusters)){
        VolData.UsableFreeSpace = llUsableFreeClusters * VolData.BytesPerCluster;
    }
    else{
        VolData.UsableFreeSpace = VolData.FreeSpace;
    }

    //Fill in all the TEXT_DATA fields for the UI's text display.
    textData.DiskSize               = VolData.TotalClusters * VolData.BytesPerCluster;
    textData.BytesPerCluster        = VolData.BytesPerCluster;
    textData.UsedSpace              = VolData.UsedClusters * VolData.BytesPerCluster;
    textData.FreeSpace              = (VolData.TotalClusters - VolData.UsedClusters) * 
                                      VolData.BytesPerCluster;
    EV_ASSERT(VolData.TotalClusters);
    textData.FreeSpacePercent       = 100 * (VolData.TotalClusters - VolData.UsedClusters) / 
                                      VolData.TotalClusters;
    textData.UsableFreeSpace        = textData.FreeSpace;
    textData.UsableFreeSpacePercent = textData.FreeSpacePercent;
    textData.PagefileBytes          = VolData.PagefileSize;
    textData.PagefileFrags          = __max(VolData.PagefileFrags, 0);
    textData.TotalDirectories       = __max(VolData.TotalDirs, 1);
    textData.FragmentedDirectories  = __max(VolData.NumFraggedDirs, 1);
    textData.ExcessDirFrags         = __max(VolData.NumExcessDirFrags, 0);
    textData.TotalFiles             = VolData.TotalFiles;
    textData.AvgFileSize            = VolData.AveFileSize;
    textData.NumFraggedFiles        = __max(VolData.NumFraggedFiles, 0);
    textData.NumExcessFrags         = __max(VolData.NumExcessFrags, 0);
    textData.PercentDiskFragged     = VolData.PercentDiskFragged;

    if(VolData.TotalFiles){
        textData.AvgFragsPerFile    = (VolData.NumExcessFrags + VolData.TotalFiles) * 100 / 
                                      (VolData.TotalFiles);
    }
    textData.MFTBytes               = VolData.MftSize;
    textData.InUseMFTRecords        = VolData.InUseFileRecords;
    textData.MFTExtents             = VolData.MftNumberOfExtents;

    if(VolData.TotalClusters - VolData.UsedClusters){
        if(VolData.NumFreeSpaces){
            textData.FreeSpaceFragPercent = 100 * VolData.NumFreeSpaces /
                                            (VolData.TotalClusters - VolData.UsedClusters);
        }
    }

    //If the gui is connected, send gui data to it.
    DataIoClientSetData(ID_REPORT_TEXT_DATA, (TCHAR*)&textData, sizeof(TEXT_DATA), 
                        pdataDfrgCtl);
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:

RETURN:
    None.
*/

void SendGraphicsMemoryErr()
{
    // don't need to send any data
    NOT_DATA NotData;
    _tcscpy(NotData.cVolumeName, VolData.cVolumeName);

    // if the gui is connected, send gui data to it.
    Message(TEXT("engine sending ID_NO_GRAPHICS_MEMORY"), -1, NULL);
    DataIoClientSetData(ID_NO_GRAPHICS_MEMORY, (PTCHAR) &NotData, sizeof(NOT_DATA), 
                        pdataDfrgCtl);
}

// send error code to client
// (for command line mode)
VOID SendErrData(PTCHAR pErrText, DWORD ErrCode)
{
    static BOOL FirstTime = TRUE;

    // only send the first error
    if (FirstTime)
    {
        // prepare COM message for client
        ERROR_DATA ErrData = {0};

        _tcscpy(ErrData.cVolumeName, VolData.cVolumeName);
        ErrData.dwErrCode = ErrCode;
        if (pErrText != NULL) 
        {
            _tcsncpy(ErrData.cErrText, pErrText, 999);
            ErrData.cErrText[999] = TEXT('\0');
        }

        // send COM message to client
        DataIoClientSetData(ID_ERROR, (TCHAR*) &ErrData, sizeof(ERROR_DATA), pdataDfrgCtl);

        // write the error to the error log.
        if (bLogFile && pErrText != NULL) 
        {
            WriteErrorToErrorLog(pErrText, -1, NULL);
        }

        // only one error
        FirstTime = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgntfs\stdafx.h ===
#ifndef RTL_USE_AVL_TABLES 
#define RTL_USE_AVL_TABLES 0
#endif  // RTL_USE_AVL_TABLES

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include <windows.h>
#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgntfs\bootoptimizentfs.cpp ===
/**************************************************************************************************

FILENAME: BootOptimize.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Boot Optimize for NTFS.

**************************************************************************************************/
#include "stdafx.h"

extern "C"{
    #include <string.h>
    #include <stdio.h>
    #include <stdlib.h>
}
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>


#include "Windows.h"
#include <winioctl.h>
#include <math.h>
#include <fcntl.h>


extern "C" {
    #include "SysStruc.h"
}

#include "BootOptimizeNtfs.h"
#include "DfrgCmn.h"
#include "GetReg.h"
#include "defragcommon.h"
#include "Devio.h"

#include "movefile.h"
#include "fssubs.h"

#include "Alloc.h"

#define THIS_MODULE 'B'
#include "logfile.h"
#include "ntfssubs.h"
#include "dfrgengn.h"
#include "FreeSpace.h"
#include "extents.h"
#include "dfrgntfs.h"

//
// Hard-coded registry keys that we access to find the path to layout.ini,
// and other persisted data of interest (such as the boot optimise exclude
// zone beginning and end markers).
//
#define OPTIMAL_LAYOUT_KEY_PATH                  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OptimalLayout")
#define OPTIMAL_LAYOUT_FILE_VALUE_NAME           TEXT("LayoutFilePath")
#define BOOT_OPTIMIZE_REGISTRY_PATH              TEXT("SOFTWARE\\Microsoft\\Dfrg\\BootOptimizeFunction")
#define BOOT_OPTIMIZE_ENABLE_FLAG                TEXT("Enable")
#define BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION  TEXT("LcnStartLocation")
#define BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION    TEXT("LcnEndLocation")
#define BOOT_OPTIMIZE_REGISTRY_COMPLETE          TEXT("OptimizeComplete")
#define BOOT_OPTIMIZE_REGISTRY_ERROR             TEXT("OptimizeError")
#define BOOT_OPTIMIZE_LAST_WRITTEN_DATETIME      TEXT("FileTimeStamp")

#define BOOT_OPTIMIZE_MAX_FILE_SIZE_BYTES        (32 * 1024 * 1024)
#define BOOT_OPTIMIZE_MAX_ZONE_SIZE_MB           ((LONGLONG) (4 * 1024))
#define BOOT_OPTIMIZE_MAX_ZONE_SIZE_PERCENT      (50)
#define BOOT_OPTIMIZE_ZONE_EXTEND_PERCENT        (150)
#define BOOT_OPTIMISE_ZONE_RELOCATE_THRESHOLD    (90)
#define BOOT_OPTIMIZE_ZONE_EXTEND_MIN_SIZE_BYTES (100 * 1024 * 1024)

BOOL
UpdateInMultipleTrees(
    IN PFREE_SPACE_ENTRY pOldEntry,
    IN PFREE_SPACE_ENTRY pNewEntry
    );




/*****************************************************************************************************************


ROUTINE DESCRIPTION:
    Get a rough idea of how many records are in the file and triple it, to make an estimation
    of how many files are in the boot optimize file, and I triple it to account for multiple
    stream files.  Also make the assumption that the file count is atleast 300, so that I can
    allocate enough memory to hold all the records.

INPUT:
        full path name to the boot optimize file
RETURN:
        triple the number of records in the boot optimize file.
*/
DWORD CountNumberofRecordsinFile(
    IN LPCTSTR lpBootOptimzePath
    )
{
    DWORD dwNumberofRecords = 0;         //the number of records in the input file
    TCHAR tBuffer [MAX_PATH];          //temporary buffer to the input string
    ULONG ulLength;                    //length of the line read in by fgetts
    FILE* fBootOptimizeFile;           //File Pointer to fBootOptimizeFile

    //set read mode to binary
    _fmode = _O_BINARY;

    //open the file
    //if I can't open the file, return a record count of zero
    fBootOptimizeFile = _tfopen(lpBootOptimzePath,TEXT("r"));
    if(fBootOptimizeFile == NULL)
    {
        return 0;
    }

    //read the entire file and count the number of records
    while(_fgetts(tBuffer,MAX_PATH - 1,fBootOptimizeFile) != 0)
    {
        // check for terminating carriage return.
        ulLength = wcslen(tBuffer);
        if (ulLength && (tBuffer[ulLength - 1] == TEXT('\n'))) {
            dwNumberofRecords++;
        } 
    }

    fclose(fBootOptimizeFile);

    //triple the number of records we have
    if(dwNumberofRecords < 100)
    {
        dwNumberofRecords = 100;
    }
    
    return dwNumberofRecords;

}    



/******************************************************************************

ROUTINE DESCRIPTION:
    This allocates memory of size cbSize bytes.  Note that cbSize MUST be the
    size we're expecting it to be (based on the slab-allocator initialisation), 
    since our slab allocator can only handle packets of one size.

INPUT:
    pTable - The table that the comparison is being made for (not used)
    cbSize - The count in bytes of the memory needed

RETURN:
    Pointer to allocated memory of size cbSize;  NULL if the system is out
    of memory, or cbSize is not what the slab allocator was initialised with.
    
*/
PVOID
NTAPI
BootOptimiseAllocateRoutine(
    IN PRTL_GENERIC_TABLE   pTable,
    IN CLONG                cbSize
    )
{
    PVOID pMemory = NULL;

    //
    // Sanity-check to make sure that we're being asked for packets of the 
    // "correct" size, since our slab-allocator can only deal with packets 
    // of a given size
    //
    if ((cbSize + sizeof(PVOID)) == VolData.SaBootOptimiseFilesContext.dwPacketSize) {
        //
        // size was correct; call our allocator
        //
        pMemory = SaAllocatePacket(&VolData.SaBootOptimiseFilesContext);
    }
    else {
        //
        // Oops, we have a problem!  
        //
        Trace(error, "Internal Error.  BootOptimiseAllocateRoutine called with "
                         "unexpected size (%lu instead of %lu).",
                 cbSize, VolData.SaBootOptimiseFilesContext.dwPacketSize - sizeof(PVOID));
        assert(FALSE);
    } 

    return pMemory;
    
    UNREFERENCED_PARAMETER(pTable);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    This frees a packet allocated by BootOptimiseAllocateRoutine

INPUT:
    pTable -    The table that the comparison is being made for (not used)
    pvBuffer -  Pointer to the memory to be freed.  This pointer should not
                be used after this routine is called.

RETURN:
    VOID    
*/
VOID
NTAPI 
BootOptimiseFreeRoutine(
    IN PRTL_GENERIC_TABLE pTable,
    IN PVOID              pvBuffer
    )
{
    assert(pvBuffer);
    
    SaFreePacket(&VolData.SaBootOptimiseFilesContext, pvBuffer);

    UNREFERENCED_PARAMETER(pTable);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Comparison routine to compare the FileRecordNumber of two FILE_LIST_ENTRY
    records.

INPUT:
    pTable - the table that the comparison is being made for (not used)
    pNode1 - the first FILE_LIST_ENTRY to be compared
    pNode2 - the second FILE_LIST_ENTRY to be compared

RETURN:
    RtlGenericLessThan      if pNode1 < pNode2
    RtlGenericGreaterThan   if pNode1 > pNode2
    RtlGenericEqual         if pNode1 == pNode2
*/
RTL_GENERIC_COMPARE_RESULTS 
NTAPI 
BootOptimiseFrnCompareRoutine(
    IN PRTL_GENERIC_TABLE pTable,
    IN PVOID              pNode1,
    IN PVOID              pNode2
    )
{
    PFILE_LIST_ENTRY pEntry1 = (PFILE_LIST_ENTRY) pNode1;
    PFILE_LIST_ENTRY pEntry2 = (PFILE_LIST_ENTRY) pNode2;
    RTL_GENERIC_COMPARE_RESULTS result = GenericEqual;

    //
    // These shouldn't ever be NULL
    //
    assert(pNode1 && pNode2);

    if (pEntry1->FileRecordNumber < pEntry2->FileRecordNumber) {
        result = GenericLessThan;
    }
    else if (pEntry1->FileRecordNumber > pEntry2->FileRecordNumber) {
        result = GenericGreaterThan;
    }

    //
    // Default is GenericEqual
    //
    return result;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Comparison routine to compare the StartingLcn of two FILE_LIST_ENTRY
    records.

INPUT:
    pTable - the table that the comparison is being made for (not used)
    pNode1 - the first FILE_LIST_ENTRY to be compared
    pNode2 - the second FILE_LIST_ENTRY to be compared

RETURN:
    RtlGenericLessThan      if pNode1 < pNode2
    RtlGenericGreaterThan   if pNode1 > pNode2
    RtlGenericEqual         if pNode1 == pNode2
*/
RTL_GENERIC_COMPARE_RESULTS 
NTAPI 
BootOptimiseStartLcnCompareRoutine(
    IN PRTL_GENERIC_TABLE pTable,
    PVOID              pNode1,
    PVOID              pNode2
    )
{
    PFILE_LIST_ENTRY pEntry1 = (PFILE_LIST_ENTRY) pNode1;
    PFILE_LIST_ENTRY pEntry2 = (PFILE_LIST_ENTRY) pNode2;
    RTL_GENERIC_COMPARE_RESULTS result = GenericEqual;

    //
    // These shouldn't ever be NULL
    //
    assert(pNode1 && pNode2);
    
    if (pEntry1->StartingLcn < pEntry2->StartingLcn) {
        result = GenericLessThan;
    }
    else if (pEntry1->StartingLcn > pEntry2->StartingLcn) {
        result = GenericGreaterThan;
    }

    //
    // Default is GenericEqual
    //
    return result;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Initialisation routine for the BootOptimiseTables.
    
INPUT:
    pBootOptimiseTable - pointer to table that will contain a list of 
        files that are to be preferentially laid out at the start of the disk
        
    pFilesInExcludeZoneTable - pointer to the table that will contain a list
        of all the files that are in the boot-optimise zone but not in the
        boot-optimise table (i.e, this table containts the list of files that 
        need to be evicted)

RETURN:
    TRUE - Initialisation completed successfully
    FALSE - Fatal errors were encountered during initialisation
*/
BOOL
InitialiseBootOptimiseTables(
    IN PRTL_GENERIC_TABLE pBootOptimiseTable,
    IN PRTL_GENERIC_TABLE pFilesInExcludeZoneTable
    )
{
    PVOID pTableContext = NULL;
    BOOL bResult = FALSE;

    //
    // Initialise the Slab Allocator context that will be used to allocate
    // packets for these two tables.  The two tables will be holding 
    // FILE_LIST_ENTRYs.
    //
    bResult = SaInitialiseContext(&VolData.SaBootOptimiseFilesContext, 
        sizeof(FILE_LIST_ENTRY), 
        64*1024);

    //
    // And initialise the two tables
    //
    if (bResult) {
        RtlInitializeGenericTable(pBootOptimiseTable,
           BootOptimiseFrnCompareRoutine,
           BootOptimiseAllocateRoutine,
           BootOptimiseFreeRoutine,
           pTableContext);

        RtlInitializeGenericTable(pFilesInExcludeZoneTable,
           BootOptimiseStartLcnCompareRoutine,
           BootOptimiseAllocateRoutine,
           BootOptimiseFreeRoutine,
           pTableContext);
    }

    return bResult;

}

/******************************************************************************

ROUTINE DESCRIPTION:
    Routine to free all the packets belonging to the two tables, and re-init 
    them.
    
INPUT:
    pBootOptimiseTable - pointer to table that contains a list of files that 
        are to be preferentially laid out at the beginning of the disk
        
    pFilesInExcludeZoneTable - pointer to the table that contains a list
        of all the files that are in the boot-optimise zone but not in the
        boot-optimise table (i.e, files that need to be evicted)

RETURN:
    VOID
*/

VOID
UnInitialiseBootOptimiseTables(
    IN PRTL_GENERIC_TABLE pBootOptimiseTable,
    IN PRTL_GENERIC_TABLE pFilesInExcludeZoneTable
    )
{
    PVOID pTableContext = NULL;
    BOOL bResult = FALSE;

    RtlInitializeGenericTable(pBootOptimiseTable,
       BootOptimiseFrnCompareRoutine,
       BootOptimiseAllocateRoutine,
       BootOptimiseFreeRoutine,
       pTableContext);

    RtlInitializeGenericTable(pFilesInExcludeZoneTable,
       BootOptimiseStartLcnCompareRoutine,
       BootOptimiseAllocateRoutine,
       BootOptimiseFreeRoutine,
       pTableContext);
    
    SaFreeAllPackets(&VolData.SaBootOptimiseFilesContext);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Open the specified file with read and synchronize attributes, and return 
    a handle to it.

INPUT:
    lpFilePath - file to be opened

RETURN:
    HANDLE to the file or INVALID_HANDLE_VALUE
*/
HANDLE 
GetFileHandle(
    IN LPCTSTR lpFilePath
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;

    hFile = CreateFile(lpFilePath, 
        FILE_READ_ATTRIBUTES | SYNCHRONIZE, 
        0, 
        NULL, 
        OPEN_EXISTING, 
        FILE_FLAG_BACKUP_SEMANTICS | FILE_OPEN_REPARSE_POINT, 
        NULL
        );
    
    return hFile;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Get the FileRecordNumber for a file given a handle to it

INPUT:
    hFile - handle to the file of interest

RETURN:
    FRN for the given file, -1 if errors were encountered.
*/
LONGLONG
GetFileRecordNumber(
    IN CONST HANDLE hFile
    )
{
    FILE_INTERNAL_INFORMATION internalInformation;
    IO_STATUS_BLOCK ioStatusBlock;
    LONGLONG fileRecordNumber = -1;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    ZeroMemory(&internalInformation, sizeof(FILE_INTERNAL_INFORMATION));
    ZeroMemory(&ioStatusBlock, sizeof(IO_STATUS_BLOCK));

    //
    // The FileRecordNumber is the lower part of the InternalInformation
    // returned for the file
    //
    ntStatus = NtQueryInformationFile(hFile, 
        &ioStatusBlock, 
        &internalInformation, 
        sizeof(FILE_INTERNAL_INFORMATION), 
        FileInternalInformation
        );

    if (NT_SUCCESS(ntStatus) && (NT_SUCCESS(ioStatusBlock.Status))) {
        //
        // The FRN is the lower 48-bits of the value returned
        //
        fileRecordNumber = (LONGLONG) (internalInformation.IndexNumber.QuadPart & 0x0000FFFFFFFFFFFF);
    }

    return fileRecordNumber;
}



/******************************************************************************

ROUTINE DESCRIPTION:
    Get the size of the file in clusters from calling FSCL_GET_RETRIEVAL_POINTERS.

INPUT:
    hFile - The handle to the file of interest

RETURN:
    The size of the file in clusters
*/

LONGLONG 
GetFileSizeInfo(
        IN HANDLE hFile
        )
{
    ULONGLONG                   ulSizeofFileInClusters = 0;        //size of the file in clusters
    int                         i;
    ULONGLONG                   startVcn = 0;                      //starting VCN of the file, always 0
    STARTING_VCN_INPUT_BUFFER   startingVcn;                       //starting VCN Buffer
    ULONG                       BytesReturned = 0;                 //number of bytes returned by ESDeviceIoControl 
    HANDLE                      hRetrievalPointersBuffer = NULL;   //Handle to the Retrieval Pointers Buffer
    PRETRIEVAL_POINTERS_BUFFER  pRetrievalPointersBuffer = NULL;   //pointer to the Retrieval Pointer
    PLARGE_INTEGER              pRetrievalPointers = NULL;         //Pointer to retrieval pointers    
    ULONG                       RetrievalPointers = 0x100;         //Number of extents for the file, try 256 first
    BOOL                        bGetRetrievalPointersMore = TRUE;  //boolean to test the end of getting retrieval pointers

    if (INVALID_HANDLE_VALUE == hFile) {
        return 0;
    }

    // zero the memory of the starting VCN input buffer
    ZeroMemory(&startVcn, sizeof(STARTING_VCN_INPUT_BUFFER));


    // Read the retrieval pointers into a buffer in memory.
    while (bGetRetrievalPointersMore) {
    
        //0.0E00 Allocate a RetrievalPointersBuffer.
        if (!AllocateMemory(sizeof(RETRIEVAL_POINTERS_BUFFER) + (RetrievalPointers * 2 * sizeof(LARGE_INTEGER)),
                           &hRetrievalPointersBuffer,
                           (void**)(PCHAR*)&pRetrievalPointersBuffer)) {
            return 0;
        }

        startingVcn.StartingVcn.QuadPart = 0;
        if(ESDeviceIoControl(hFile,
                             FSCTL_GET_RETRIEVAL_POINTERS,
                             &startingVcn,
                             sizeof(STARTING_VCN_INPUT_BUFFER),
                             pRetrievalPointersBuffer,
                             (DWORD)GlobalSize(hRetrievalPointersBuffer),
                             &BytesReturned,
                             NULL)) {
            bGetRetrievalPointersMore = FALSE;
        } 
        else {

            //This occurs on a zero length file (no clusters allocated).
            if(GetLastError() == ERROR_HANDLE_EOF) {
                //file is zero lenght, so return 0
                //free the memory for the retrival pointers
                //the while loop makes sure all occurances are unlocked
                while (GlobalUnlock(hRetrievalPointersBuffer))
                {
                    ;
                }
                GlobalFree(hRetrievalPointersBuffer);
                hRetrievalPointersBuffer = NULL;
                return 0;
            }

            //0.0E00 Check to see if the error is not because the buffer is too small.
            if(GetLastError() == ERROR_MORE_DATA)
            {
                //0.1E00 Double the buffer size until it's large enough to hold the file's extent list.
                RetrievalPointers *= 2;
            } else
            {
                //some other error, return 0
                //free the memory for the retrival pointers
                //the while loop makes sure all occurances are unlocked
                while (GlobalUnlock(hRetrievalPointersBuffer))
                {
                    ;
                }
                GlobalFree(hRetrievalPointersBuffer);
                hRetrievalPointersBuffer = NULL;
                return 0;
            }
        }

    }

    //loop through the retrival pointer list and add up the size of the file
    startVcn = pRetrievalPointersBuffer->StartingVcn.QuadPart;
    for (i = 0; i < (ULONGLONG) pRetrievalPointersBuffer->ExtentCount; i++) 
    {
        ulSizeofFileInClusters += pRetrievalPointersBuffer->Extents[i].NextVcn.QuadPart - startVcn;
        startVcn = pRetrievalPointersBuffer->Extents[i].NextVcn.QuadPart;
    }

    if(hRetrievalPointersBuffer != NULL)
    {
        //free the memory for the retrival pointers
        //the while loop makes sure all occurances are unlocked
        while (GlobalUnlock(hRetrievalPointersBuffer))
        {
            ;
        }
        GlobalFree(hRetrievalPointersBuffer);
        hRetrievalPointersBuffer = NULL;
    }


    return ulSizeofFileInClusters; 

}


/******************************************************************************

ROUTINE DESCRIPTION:
    Checks if we have a valid file to be laid out at the beginning of the disk.  

INPUT:
    lpFilePath - The file name input from the list--typically, a line from
            layout.ini
    tcBootVolumeDriveLetter - Drive letter of the boot volume
    bIsNtfs - TRUE if the volume is NTFS, FALSE otherwise

OUTPUT:
     pFileRecordNumber - The FRN of the file, if it is a valid file
     pClusterCount - The file-size (in clusters), if it is a valid file
    
RETURN:
    TRUE if this is a valid file, 
    FALSE if it is not.
*/
BOOL IsAValidFile(
    IN LPTSTR       lpFilePath,
    IN CONST TCHAR  tcBootVolumeDriveLetter,
    IN CONST BOOL   bIsNtfs,
    OUT LONGLONG   *pFileRecordNumber OPTIONAL,
    OUT LONGLONG   *pClusterCount     OPTIONAL
    )
{
    TCHAR tcFileName[MAX_PATH+1];   // Just the file name portion of lpFilePath
    TCHAR tcFileDriveLetter;        // Drive letter for current file (lpFilePath)
    HANDLE hFile = NULL;            // Temporary handle to check file size, etc
    BOOL bFileIsDirectory = FALSE;  // Flag to check if current file is a dir
    LONGLONG FileSizeClusters = 0;  

    BY_HANDLE_FILE_INFORMATION FileInformation; // For checking if this is a directory

    // Ignore blank lines, and the root directory, in layout.ini
    if (!lpFilePath || _tcslen(lpFilePath) <= 2) {
        return FALSE;
    }

    // Ignore the group headers
    if (NULL != _tcsstr(lpFilePath, TEXT("[OptimalLayoutFile]"))) {
        return FALSE;
    }

    // Ignore the file = and version = lines
    if(NULL != _tcsstr(lpFilePath, TEXT("Version="))) {
        return FALSE;
    }

    //get the drive the file is on, if its not the boot drive, skip the file
    tcFileDriveLetter = towupper(lpFilePath[0]);
    if(tcFileDriveLetter != tcBootVolumeDriveLetter) {      //files are on boot drive else skip them
        return FALSE;
    }

    if ((lpFilePath[1] != TEXT(':')) ||
        (lpFilePath[2] != TEXT('\\'))) {
        return FALSE;
    }

    //get just the file name from the end of the path
    if(_tcsrchr(lpFilePath,TEXT('\\')) != NULL) {
        _tcscpy(tcFileName,_tcsrchr(lpFilePath,TEXT('\\'))+1);

    } 
    else {
        //not a valid name
        return FALSE;
    }

    if(_tcsicmp(tcFileName,TEXT("BOOTSECT.DOS")) == 0) {
        return FALSE;
    }

    if(_tcsicmp(tcFileName,TEXT("SAFEBOOT.FS")) == 0) {
        return FALSE;
    }
    
    if(_tcsicmp(tcFileName,TEXT("SAFEBOOT.CSV")) == 0) {
        return FALSE;
    }
    
    if(_tcsicmp(tcFileName,TEXT("SAFEBOOT.RSV")) == 0) {
        return FALSE;
    } 
    
    if(_tcsicmp(tcFileName,TEXT("HIBERFIL.SYS")) == 0) {
        return FALSE;
    }
    
    if(_tcsicmp(tcFileName,TEXT("MEMORY.DMP")) == 0) {
        return FALSE;
    }
    
    if(_tcsicmp(tcFileName,TEXT("PAGEFILE.SYS")) == 0) {
        return FALSE;
    } 

    // so far, so good.  Now, we need to check if the file exists, and is 
    // too big
    hFile = GetFileHandle(lpFilePath);
    if (INVALID_HANDLE_VALUE == hFile) {
        return FALSE;
    }

    // determine if directory file.
    bFileIsDirectory = FALSE;
    if (GetFileInformationByHandle(hFile, &FileInformation)) {
        bFileIsDirectory = (FileInformation.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
    }

    if ((bFileIsDirectory) && (!bIsNtfs)) {
        CloseHandle(hFile);
        return FALSE;
    }

    if (pFileRecordNumber) {
        *pFileRecordNumber = GetFileRecordNumber(hFile);
    }

    FileSizeClusters = GetFileSizeInfo(hFile);
    
    if (pClusterCount) {
        *pClusterCount = FileSizeClusters;
    }

    CloseHandle(hFile);
    
    // We won't move files that are bigger than BOOT_OPTIMIZE_MAX_FILE_SIZE_BYTES MB
    if (FileSizeClusters > (BOOT_OPTIMIZE_MAX_FILE_SIZE_BYTES / VolData.BytesPerCluster)) {
        return FALSE;
    }
    
    //file is OK, return TRUE
    return TRUE;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Reads the layout.ini at the given location, and builds a list of valid
    files that should be preferentially laid out at the start of the disk.
    
INPUT:
    lpLayoutIni - Fill path to the file (layout.ini) containing the  
        list of files to be preferentially laid out.
        
    tcBootVolumeDriveLetter - Drive letter of the boot volume
    
OUTPUT:
    pBootOptimiseTable - Table to contain the files of interest
    
    pClustersNeeded - The size (in clusters), that is needed for all the files
        in the list.
    
RETURN:
    TRUE if the list could successfully be built
    FALSE otherwise
*/
BOOL
BuildBootOptimiseFileList(
    IN OUT PRTL_GENERIC_TABLE pBootOptimiseTable,
    IN LPCTSTR lpLayoutIni,
    IN CONST TCHAR tcBootVolumeDriveLetter,
    IN CONST BOOL bIsNtfs,
    OUT LONGLONG *pClustersNeeded
    )
{
    PVOID pTableContext = NULL;     // Temporary value used for the AVL Tables
    BOOL  bResult = TRUE;           // The value to be returned
    
    TCHAR tBuffer [MAX_PATH+1];     // Temporary buffer to the input string
    ULONG ulLength = 0;             // Length of the line read in by fgetts
    FILE* fpLayoutIni = NULL;       // File pointer to layout.ini

    LONGLONG llClusterCount = 0,    // ClusterCount of current File
        llFileRecordNumber = -1;    // FRN of current file
    
    PVOID pvTemp = NULL;            // Temporary value used for AVL Tables
    BOOLEAN bNewElement = FALSE;    // Temporary value used for AVL Tables

    FILE_LIST_ENTRY FileEntry;      // Current File

    DWORD dwNumberofRecords = 0,
        dwIndex = 0;
    
    // Initialise out parameters
    *pClustersNeeded = 0;

    // Zero out local structs
    ZeroMemory(&FileEntry, sizeof(FILE_LIST_ENTRY));

    // 
    // Get a count of the number of entries in layout.ini, so that we can
    // allocate an array to keep track of the LayoutIniEntryIndex <-> FRN
    // mapping
    //
    dwNumberofRecords = 10 + CountNumberofRecordsinFile(lpLayoutIni);
    if (dwNumberofRecords <= 10) {
        bResult = FALSE;
        goto EXIT;
    }

    Trace(log, "Number of Layout.Ini entries: %d", dwNumberofRecords-10);

    if (!AllocateMemory(
        (DWORD) (sizeof(LONGLONG) * dwNumberofRecords), 
        &(VolData.hBootOptimiseFrnList), 
        (PVOID*) &(VolData.pBootOptimiseFrnList)
        )) {
        bResult = FALSE;
        goto EXIT;
    }

    // Set read mode to binary: layout.ini is a UNICODE file
    _fmode = _O_BINARY;

    // Open the file
    fpLayoutIni = _tfopen(lpLayoutIni,TEXT("r"));
    
    if (fpLayoutIni) {
        
        // Read the entire file and check each file to make sure its valid,
        // and then add to the list
        while (_fgetts(tBuffer,MAX_PATH,fpLayoutIni) != 0) {
            
            // Remove terminating carriage return.
            ulLength = wcslen(tBuffer);
            if (ulLength < 3) { 
                continue;
            }

            if (tBuffer[ulLength - 1] == TEXT('\n')) {
                tBuffer[ulLength - 1] = 0;
                ulLength--;
                if (tBuffer[ulLength - 1] == TEXT('\r')) {
                    tBuffer[ulLength - 1] = 0;
                    ulLength--;
                }
            } else {
                continue;
            }
            
            if (IsAValidFile(
                tBuffer, 
                tcBootVolumeDriveLetter, 
                bIsNtfs, 
                &llFileRecordNumber, 
                &llClusterCount)
                ) {

                // This is a valid file, copy the information of interest to
                // the FILE_LIST_ENTRY structure and add it to our list.
                //
                // We set the starting LCN to max value at first (since we
                // don't have this information at this time)--this will be
                // set to the correct value during the analysis phase.
                //
                FileEntry.StartingLcn = VolData.TotalClusters;
                FileEntry.ClusterCount = llClusterCount;
                FileEntry.FileRecordNumber = llFileRecordNumber;

                // Keep track of the total clusters needed
                (*pClustersNeeded) += llClusterCount;
                
                // And add this entry to our tree
                pvTemp = RtlInsertElementGenericTable(
                    pBootOptimiseTable,
                    (PVOID) &FileEntry,
                    sizeof(FILE_LIST_ENTRY),
                    &bNewElement);
                
                if (!pvTemp) {
                    // An allocation failed
                    bResult = FALSE;
                    assert(FALSE);
                    break;
                }

                if (dwIndex < dwNumberofRecords) {
                    VolData.pBootOptimiseFrnList[dwIndex] = llFileRecordNumber;
                    ++dwIndex;
                }
            }
        }

        // 
        // Make sure we have an FRN of -1, at the end of the list, even if it 
        // means wiping the last real FRN (which should never be the case)
        // 
        if (dwIndex >= dwNumberofRecords) {
            dwIndex = dwNumberofRecords - 1;
        }
        VolData.pBootOptimiseFrnList[dwIndex] = -1;
        
        //close the file at the end
        fclose(fpLayoutIni);
    }
    else {
        // Layout.Ini could not be opened for read access
        bResult = FALSE;
    }

EXIT:
    
    return bResult;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    If the current file is on the list of files to be preferentially laid out
    at the beginning of the disk, this routine updates the file record in our 
    AVL-tree with fields from VolData.
    
INPUT:
    (Global) Various VolData fields
    
OUTPUT:
    None;
    May change an entry in VolData.BootOptimiseFileTable
    
RETURN:
    TRUE if the file exists in our preferred list, and was updated
    FALSE if the file is not one we're interesed in preferentially laying out
*/
BOOL
UpdateInBootOptimiseList(
    IN PFILE_LIST_ENTRY pFileListEntry
    )
{
    FILE_LIST_ENTRY     FileEntryToSearchFor;
    PFILE_LIST_ENTRY    pClosestMatchEntry = NULL;
    PFILE_EXTENT_HEADER pFileExtentHeader = NULL;
    static ULONG        ulDeleteCount = 0;
    PVOID               pRestartKey = NULL;
    LONGLONG            FileRecordNumberToSearchFor = 0;

    ZeroMemory(&FileEntryToSearchFor, sizeof(FILE_LIST_ENTRY));
    if (pFileListEntry) {
        FileRecordNumberToSearchFor = pFileListEntry->FileRecordNumber;
    }
    else {
        FileRecordNumberToSearchFor = VolData.FileRecordNumber;
    }
    FileEntryToSearchFor.FileRecordNumber = FileRecordNumberToSearchFor;
    
    pClosestMatchEntry = (PFILE_LIST_ENTRY) RtlEnumerateGenericTableLikeADirectory(
        &VolData.BootOptimiseFileTable, 
        NULL,
        NULL,
        FALSE,
        &pRestartKey,
        &ulDeleteCount,
        &FileEntryToSearchFor
        );
    if (!pClosestMatchEntry) {
        //
        // We couldn't find the closest match?
        //
        return FALSE;
    }

    if (pClosestMatchEntry->FileRecordNumber == FileRecordNumberToSearchFor) {
        //
        // We found an exact match.  Update the fields of interest.
        //

        pClosestMatchEntry->StartingLcn = 
            (pFileListEntry ? pFileListEntry->StartingLcn : VolData.StartingLcn);
        pClosestMatchEntry->ClusterCount = VolData.NumberOfClusters;

        // Get a pointer to the file extent header.
        pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;

        // 
        // Fill in the file info.  We only count *excess* extents since 
        // otherwise files with multiple streams would be "fragmented".
        //
        pClosestMatchEntry->ExcessExtentCount = 
            (UINT)VolData.NumberOfFragments - pFileExtentHeader->NumberOfStreams; 
        
        pClosestMatchEntry->Flags = 0;

        // Set or clear the fragmented and directory flags as needed
        if(VolData.bFragmented){
            //Set the fragmented flag.
            pClosestMatchEntry->Flags |= FLE_FRAGMENTED;
        }
        else{
            //Clear the fragmented flag.
            pClosestMatchEntry->Flags &= ~FLE_FRAGMENTED;
        }

        if(VolData.bDirectory){
            //Set the directory flag.
            pClosestMatchEntry->Flags |= FLE_DIRECTORY;
        }
        else{
            //Clear the directory flag.
            pClosestMatchEntry->Flags &= ~FLE_DIRECTORY;
        }

        pClosestMatchEntry->Flags |= FLE_BOOTOPTIMISE;

        VolData.bBootOptimiseFile = TRUE;
        VolData.BootOptimiseFileListTotalSize += VolData.NumberOfClusters;

        if ((!VolData.bFragmented) && 
            (VolData.StartingLcn >= VolData.BootOptimizeBeginClusterExclude) &&
            ((VolData.StartingLcn + VolData.NumberOfClusters) <= VolData.BootOptimizeEndClusterExclude)
            ) {
            VolData.BootOptimiseFilesAlreadyInZoneSize += VolData.NumberOfClusters;
        }
        //
        // We found and udpated this entry
        //
        
        if (!VolData.bFragmented) {
            return TRUE;
        }
    }

     //
     // We didn't find an exact match, or the file is fragmented
     //
     return FALSE;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Moves the file referred to by VolData to a location outside the 
    BootOptimise zone, if possible
    
INPUT:
    (Global) Various VolData fields
    
OUTPUT:
    None
    File referred to by VolData is moved to a new location outside the 
    BootOptimise zone
    
RETURN:
    TRUE if the file could successfully be moved
    FALSE otherwise
*/
BOOL
EvictFile(
    ) 
{
    FILE_LIST_ENTRY     NewFileListEntry;       // entry for the file after the move
    FREE_SPACE_ENTRY    NewFreeSpaceEntry;      // entry for the free space after the move
    
    PRTL_GENERIC_TABLE  pMoveToTable = NULL;    // Table that will contain the file-entry after the move
    PRTL_GENERIC_TABLE  pMoveFromTable = NULL;  // Table that contains the file-entry before the move

    PVOID   pvTemp = NULL;      // Temporary pointer used for AVL-Tables
    BOOL    bDone = FALSE;
    BOOL    bResult = TRUE,
        bFragmented = VolData.bFragmented;

    BOOLEAN bNewElement = FALSE,
        bElementDeleted = FALSE;

    ZeroMemory(&NewFileListEntry, sizeof(FILE_LIST_ENTRY));
    ZeroMemory(&NewFreeSpaceEntry, sizeof(FREE_SPACE_ENTRY));

    // 
    // If the file is fragmented, the entry should be present in the
    // FragementedFilesTable.  If it isn't fragmented, the entry should be in 
    // the ContiguousFileTable
    //
    pMoveFromTable = (VolData.bFragmented ? 
        &VolData.FragmentedFileTable : &VolData.ContiguousFileTable);

    // Get the extent list & number of fragments in the file.
    if (GetExtentList(DEFAULT_STREAMS, NULL)) {

        bDone = FALSE;
        while (!bDone) {

            bDone = TRUE;
            if (FindSortedFreeSpace(&VolData.FreeSpaceTable)) {

                //
                // Found a free space chunk that was big enough.  If it's 
                // before the file, move the file towards the start of the disk
                //

                //
                // First, make a copy of the free-space and file-list entries,
                // and delete them from our tables.  We'll add in modified
                // entries after the move.
                //
                CopyMemory(&NewFreeSpaceEntry, 
                    VolData.pFreeSpaceEntry, 
                    sizeof(FREE_SPACE_ENTRY)
                    );
                bElementDeleted = RtlDeleteElementGenericTable(
                    &VolData.FreeSpaceTable, 
                    (PVOID) VolData.pFreeSpaceEntry
                    );
                if (!bElementDeleted) {
                    Trace(warn, "Errors encountered while moving file. "
                        "Could not find element in free space table.  "
                        "StartingLCN: %I64u ClusterCount: %I64u", 
                        NewFreeSpaceEntry.StartingLcn,
                        NewFreeSpaceEntry.ClusterCount
                        );
                    assert(FALSE);
                }

                VolData.pFreeSpaceEntry = &NewFreeSpaceEntry;

                CopyMemory(&NewFileListEntry, 
                    VolData.pFileListEntry, 
                    sizeof(FILE_LIST_ENTRY)
                    );
                bElementDeleted = RtlDeleteElementGenericTable(
                    pMoveFromTable, 
                    (PVOID) VolData.pFileListEntry
                    );
                
                if (bElementDeleted) {

                    VolData.pFileListEntry = &NewFileListEntry;
                    
                    if (MoveNtfsFile()) {
                        //
                        // The file was successfully moved!  Update our file-
                        // and free-space entries with the results of the move.
                        // We'll add these back to the appropriate trees in a bit.
                        //
                        NewFileListEntry.StartingLcn = VolData.pFreeSpaceEntry->StartingLcn;
                        VolData.pFreeSpaceEntry->StartingLcn += VolData.NumberOfClusters;
                        VolData.pFreeSpaceEntry->ClusterCount -= VolData.NumberOfClusters;
                        VolData.bFragmented = FALSE;
                        VolData.pFileListEntry->Flags &= ~FLE_FRAGMENTED;

                        //
                        // Since we successfully moved (defragmented) this file, 
                        // it needs to be added to the ContiguousFilesTable
                        //
                        pMoveToTable = &VolData.ContiguousFileTable; 


                        if (UpdateInBootOptimiseList(&NewFileListEntry)) {
                            //
                            // Prevent this file from being counted twice
                            //
                            VolData.BootOptimiseFileListTotalSize -= VolData.NumberOfClusters;
                        }
                        
                    }
                    else {
                        //
                        // We could not move this file.  Note that this could be
                        // because of a number of reasons, such as:
                        // 1. The free-space region is not really free
                        // 2. The file is on the list of unmoveable files, etc
                        //
                        GetNtfsFilePath();

                        Trace(warn, "Movefile failed.  File %ws "
                            "StartingLcn:%I64d ClusterCount:%I64d.  Free-space "
                            "StartingLcn:%I64d ClusterCount:%I64d Status:%lu",
                            VolData.vFileName.GetBuffer() + 48,
                            VolData.pFileListEntry->StartingLcn,
                            VolData.pFileListEntry->ClusterCount,
                            VolData.pFreeSpaceEntry->StartingLcn,
                            VolData.pFreeSpaceEntry->ClusterCount,
                            VolData.Status
                            );
                        
                        if (VolData.Status == ERROR_RETRY) {
                            //
                            // Free space isn't really free;  try again with
                            // a different free space
                            //
                            VolData.pFreeSpaceEntry->ClusterCount = 0;
                            bDone = FALSE;
                        }

                        //
                        // Since we didn't move this file, we should just add
                        // it back to the table it originally was in.
                        //
                        pMoveToTable = pMoveFromTable;
                    }

                    // 
                    // Add this file-entry back to the appropriate file-table
                    //
                    pvTemp = RtlInsertElementGenericTable(
                        pMoveToTable,
                        (PVOID) VolData.pFileListEntry,
                        sizeof(FILE_LIST_ENTRY),
                        &bNewElement);

                    if (!pvTemp) {
                        // 
                        // An allocation failed
                        //
                        Trace(warn, "Errors encountered while moving file: "
                            "Unable to add back file-entry to file table");
                        assert(FALSE);
                        bResult = FALSE;
                        break;
                    }

                }
                
                if (VolData.pFreeSpaceEntry->ClusterCount > 0) {
                    // 
                    // And also, add the (possibly updated) free-space region
                    // to the FreeSpace list.
                    //
                    pvTemp = RtlInsertElementGenericTable(
                        &VolData.FreeSpaceTable,
                        (PVOID) VolData.pFreeSpaceEntry,
                        sizeof(FREE_SPACE_ENTRY),
                        &bNewElement);

                    if (!pvTemp) {
                        // 
                        // An allocation failed
                        //
                        Trace(warn, "Errors encountered while moving file: "
                            "Unable to add back free-space to free-space table");
                        assert(FALSE);
                        bResult = FALSE;
                        break;
                    }
                }
            }
            else {
                //
                // We could not find a free-space region big enough to move 
                // this file.
                //
                bResult = FALSE;
            }
        }
    }
    else {
        //
        // We could not get the extents for this file
        //
        bResult = FALSE;
    }

    //
    // Clean-up
    //
    if(VolData.hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(VolData.hFile);
        VolData.hFile = INVALID_HANDLE_VALUE;
    }
    if(VolData.hFreeExtents != NULL) {
        while(GlobalUnlock(VolData.hFreeExtents))
            ;
        GlobalFree(VolData.hFreeExtents);
        VolData.hFreeExtents = NULL;
    }

    // update cluster array
    PurgeExtentBuffer();

    return bResult;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Moves the file referred to by VolData to a location closer to the start of
    the disk, if possible
    
INPUT:
    bForce - if the file is not currently in the boot-optimise zone, and has to 
            be moved forward.

    (Global) Various VolData fields
    
OUTPUT:
    None
    File referred to by VolData is moved to a new location if possible
    
RETURN:
    TRUE if the file could successfully be moved
    FALSE otherwise
*/

BOOL
MoveBootOptimiseFile(
    IN CONST BOOL bForce
    ) 
{
    FILE_LIST_ENTRY     NewFileListEntry;       // entry for the file after the move
    FREE_SPACE_ENTRY    NewFreeSpaceEntry;      // entry for the free space after the move
    
    PRTL_GENERIC_TABLE  pMoveToTable = NULL;    // Table that will contain the file-entry after the move
    PRTL_GENERIC_TABLE  pMoveFromTable = NULL;  // Table that contains the file-entry before the move

    PVOID   pvTemp = NULL;      // Temporary pointer used for AVL-Tables
    BOOL    bDone = FALSE;
    BOOL    bResult = TRUE;

    BOOLEAN bNewElement = FALSE,
        bElementDeleted = FALSE;

    ZeroMemory(&NewFileListEntry, sizeof(FILE_LIST_ENTRY));
    ZeroMemory(&NewFreeSpaceEntry, sizeof(FREE_SPACE_ENTRY));

    // 
    // If the file is fragmented, the entry should be present in the
    // FragementedFilesTable.  If it isn't fragmented, the entry should be in 
    // the ContiguousFileTable
    //
    pMoveFromTable = (VolData.bFragmented ? 
        &VolData.FragmentedFileTable : &VolData.ContiguousFileTable);

    pMoveToTable = &VolData.ContiguousFileTable;
    
    // Get the extent list & number of fragments in the file.
    if (GetExtentList(DEFAULT_STREAMS, NULL)) {

        bDone = FALSE;
        while (!bDone) {

            bDone = TRUE;

            if (FindFreeSpaceWithMultipleTrees(VolData.NumberOfClusters, 
                    (bForce ? VolData.TotalClusters : VolData.StartingLcn))
                ) {
                //
                // Found a free space chunk that was big enough.  If it's 
                // before the file, move the file towards the start of the disk
                //

                //
                // First, make a copy of the free-space and file-list entries,
                // and delete them from our tables.  We'll add in modified
                // entries after the move.
                //
                CopyMemory(&NewFileListEntry, 
                    VolData.pFileListEntry, 
                    sizeof(FILE_LIST_ENTRY)
                    );
                bElementDeleted = RtlDeleteElementGenericTable(
                    pMoveFromTable, 
                    (PVOID)VolData.pFileListEntry
                    );
                if (bElementDeleted) {

                    VolData.pFileListEntry = &NewFileListEntry;

                    if (MoveNtfsFile()) {

                        //
                        // The file was successfully moved!  Update our file-
                        // and free-space entries with the results of the move.
                        // We'll add these back to the appropriate trees in a bit.
                        //
                        NewFileListEntry.StartingLcn = VolData.pFreeSpaceEntry->StartingLcn;
                        NewFreeSpaceEntry.StartingLcn = VolData.pFreeSpaceEntry->StartingLcn + VolData.NumberOfClusters;
                        NewFreeSpaceEntry.ClusterCount = VolData.pFreeSpaceEntry->ClusterCount - VolData.NumberOfClusters;

                        //
                        // Since we successfully moved (defragmented) this file, 
                        // it needs to be added to the ContiguousFilesTable
                        //
                        pMoveToTable = &VolData.ContiguousFileTable; 
                        
                        //
                        // Update the free-space entry
                        //
                        UpdateInMultipleTrees(VolData.pFreeSpaceEntry, &NewFreeSpaceEntry);
                        VolData.pFreeSpaceEntry = NULL;
                    }
                    else {
                        //
                        // We could not move this file.  Note that this could be
                        // because of a number of reasons, such as:
                        // 1. The free-space region is not really free
                        // 2. The file is on the list of unmoveable files, etc
                        //
                        GetNtfsFilePath();

                        Trace(warn, "Movefile failed.  File %ws "
                            "StartingLcn:%I64d ClusterCount:%I64d.  Free-space "
                            "StartingLcn:%I64d ClusterCount:%I64d Status:%lu",
                            VolData.vFileName.GetBuffer() + 48,
                            VolData.pFileListEntry->StartingLcn,
                            VolData.pFileListEntry->ClusterCount,
                            VolData.pFreeSpaceEntry->StartingLcn,
                            VolData.pFreeSpaceEntry->ClusterCount,
                            VolData.Status
                            );
                        
                        if (VolData.Status == ERROR_RETRY) {
                            //
                            // Free space isn't really free;  try again with
                            // a different free space
                            //
                            NewFreeSpaceEntry.StartingLcn = VolData.pFreeSpaceEntry->StartingLcn;
                            NewFreeSpaceEntry.ClusterCount = 0;

                            UpdateInMultipleTrees(VolData.pFreeSpaceEntry, NULL);
                            VolData.pFreeSpaceEntry = NULL;
                            bDone = FALSE;
                        }

                        //
                        // Since we didn't move this file, we should just add
                        // it back to the table it originally was in.
                        //
                        pMoveToTable = pMoveFromTable;
                        
                    }

                    // 
                    // Add this file-entry back to the appropriate file-table
                    //
                    pvTemp = RtlInsertElementGenericTable(
                        pMoveToTable,
                        (PVOID) VolData.pFileListEntry,
                        sizeof(FILE_LIST_ENTRY),
                        &bNewElement);

                    if (!pvTemp) {
                        //
                        // An allocation failed
                        //
                        Trace(warn, "Errors encountered while moving file: "
                            "Unable to add back file-entry to file table");
                        assert(FALSE);
                        bResult = FALSE;
                        break;
                    };
                }
                else {

                    bResult = TRUE;
                }

            }
            else {
                //
                // We could not find a free-space region big enough to move 
                // this file.
                //
                if (bForce) {
                        GetNtfsFilePath();

                        Trace(warn, "Movefile failed:  Insufficient free space.  File %ws "
                            "StartingLcn:%I64d ClusterCount:%I64d FRN:%I64d Frag:%d Dir:%d",
                            VolData.vFileName.GetBuffer() + 48,
                            VolData.pFileListEntry->StartingLcn,
                            VolData.pFileListEntry->ClusterCount,
                            VolData.pFileListEntry->FileRecordNumber,
                            VolData.bFragmented, VolData.bDirectory
                            );
                }
                bResult = FALSE;
            }
        }
    }
    else {
        //
        // We could not get the extents for this file
        //
        if (bForce) {
            GetNtfsFilePath();

            Trace(warn, "Movefile failed:  Unable to get extents.  File %ws "
                "StartingLcn:%I64d ClusterCount:%I64d FRN:%I64d Frag:%d Dir:%d",
                VolData.vFileName.GetBuffer() + 48,
                VolData.pFileListEntry->StartingLcn,
                VolData.pFileListEntry->ClusterCount,
                VolData.pFileListEntry->FileRecordNumber,
                VolData.bFragmented, VolData.bDirectory
                );
        }
        bResult = FALSE;
    }

    //
    // Clean-up
    //
    if(VolData.hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(VolData.hFile);
        VolData.hFile = INVALID_HANDLE_VALUE;
    }
    if(VolData.hFreeExtents != NULL) {
        while(GlobalUnlock(VolData.hFreeExtents))
            ;
        GlobalFree(VolData.hFreeExtents);
        VolData.hFreeExtents = NULL;
    }

    // update cluster array
    PurgeExtentBuffer();

    return bResult;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Gets the start and end markers for the Boot-Optimise region from the 
    registry

INPUT:
    lpBootOptimiseKey - The key to read
    
RETURN:
    The value at the specified key, 0 if errors were encountered
*/
LONGLONG 
GetStartingEndLcnLocations(
    IN PTCHAR lpBootOptimiseKey
    )
{
    HKEY hValue = NULL;                //hkey for the registry value
    DWORD dwRegValueSize = 0;          //size of the registry value string
    long ret = 0;                      //return value from SetRegValue
    TCHAR cRegValue[100];              //string to hold the value for the registry

    LONGLONG lLcnStartEndLocation = 0;

    //get the LcnStartLocation from the registry
    dwRegValueSize = sizeof(cRegValue);
    ret = GetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        lpBootOptimiseKey,
        cRegValue,
        &dwRegValueSize);

    RegCloseKey(hValue);
    
    //check to see if the key exists, else exit from routine
    if (ret != ERROR_SUCCESS)  {
        hValue = NULL;
        _stprintf(cRegValue,TEXT("%d"),0);
        //add the LcnStartLocation to the registry
        dwRegValueSize = sizeof(cRegValue);
        ret = SetRegValue(
            &hValue,
            BOOT_OPTIMIZE_REGISTRY_PATH,
            lpBootOptimiseKey,
            cRegValue,
            dwRegValueSize,
            REG_SZ);

        RegCloseKey(hValue);
    } 
    else {
        lLcnStartEndLocation = _ttoi(cRegValue);
    }
    
    return lLcnStartEndLocation;
}


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Gets the registry entries at the beginning of the program

INPUT:
        Success - TRUE
        Failed - FALSE
RETURN:
        None
*/
BOOL GetRegistryEntries(
    OUT TCHAR lpLayoutIni[MAX_PATH]
    )
{
    HKEY hValue = NULL;                //hkey for the registry value
    DWORD dwRegValueSize = 0;          //size of the registry value string
    long ret = 0;                      //return value from SetRegValue
    TCHAR cEnabledString[2];           //holds the enabled flag

    // get Boot Optimize file name from registry
    dwRegValueSize = sizeof(cEnabledString);
    ret = GetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_ENABLE_FLAG,
        cEnabledString,
        &dwRegValueSize);

    RegCloseKey(hValue);
    //check to see if the key exists, else exit from routine
    if (ret != ERROR_SUCCESS) 
    {
        return FALSE;
    }
    //check to see that boot optimize is enabled
    if(cEnabledString[0] != TEXT('Y'))
    {
        return FALSE;
    }

    // get Boot Optimize file name from registry
    hValue = NULL;
    dwRegValueSize = MAX_PATH;
    ret = GetRegValue(
        &hValue,
        OPTIMAL_LAYOUT_KEY_PATH,
        OPTIMAL_LAYOUT_FILE_VALUE_NAME,
        lpLayoutIni,
        &dwRegValueSize);

    RegCloseKey(hValue);
    //check to see if the key exists, else exit from routine
    if (ret != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    return TRUE;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Initialisation routine for the BootOptimisation.
    
INPUT/OUTPUT:
    Various VolData fields

RETURN:
    TRUE - Initialisation completed successfully
    FALSE - Fatal errors were encountered during initialisation
*/
BOOL
InitialiseBootOptimise(
    IN CONST BOOL bIsNtfs
    )
{

    LONGLONG lLcnStartLocation = 0;              //the starting location of where the files were moved last
    LONGLONG lLcnEndLocation = 0;                //the ending location of where the files were moved last
    LONGLONG lLcnMinEndLocation = 0;             //the minimum size the BootOptimise zone needs to be
    TCHAR    lpLayoutIni[MAX_PATH];              //string to hold the path of the file 
    LONGLONG ClustersNeededForLayout = 0;        //size in clusters of how big the boot optimize files are
    BOOL bResult = FALSE;

    Trace(log, "Start: Initialising BootOptimise. Volume %c:", VolData.cDrive);

    // Initialise the tree to hold the layout.ini entries
    bResult = InitialiseBootOptimiseTables(&VolData.BootOptimiseFileTable,
        &VolData.FilesInBootExcludeZoneTable);
    if (!bResult) {
        SaFreeContext(&VolData.SaBootOptimiseFilesContext);
        Trace(log, "End: Initialising BootOptimise. Out of memory");
        SaveErrorInRegistry(TEXT("No"),TEXT("Insufficient Resources"));
        return FALSE;
    }

    //get the registry entries
    bResult = GetRegistryEntries(lpLayoutIni);
    if(!bResult) {
        Trace(log, "End: Initialising BootOptimise. Missing registry entries");
        SaveErrorInRegistry(TEXT("No"),TEXT("Missing Registry Entries"));
        return FALSE;            //must be some error in getting registry entries
    }

    // Get the start and end goalposts for our boot-optimize region
    lLcnStartLocation = GetStartingEndLcnLocations(BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION);
    lLcnEndLocation = GetStartingEndLcnLocations(BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION);

    // And build the list of files to be boot optimised
    bResult = BuildBootOptimiseFileList(
        &VolData.BootOptimiseFileTable, 
        lpLayoutIni, 
        VolData.cDrive, 
        bIsNtfs,
        &ClustersNeededForLayout);

    if (!bResult) {
        SaFreeContext(&VolData.SaBootOptimiseFilesContext);
        Trace(log, "End: Initialising BootOptimise. Out of memory");
        SaveErrorInRegistry(TEXT("No"),TEXT("Insufficient Resources"));
        return FALSE;
    }

    //
    // If there are files in the "boot optimise zone" that are not in our layout.ini
    // list, we shall evict them if possible.  
    //
    lLcnMinEndLocation = lLcnStartLocation + ClustersNeededForLayout;
    if (lLcnMinEndLocation > lLcnEndLocation) {
        lLcnEndLocation = lLcnMinEndLocation;
    }

    VolData.BootOptimizeBeginClusterExclude = lLcnStartLocation;
    VolData.BootOptimizeEndClusterExclude = lLcnEndLocation;

    Trace(log, "End: Initialising BootOptimise. Zone Begins %I64d, Ends %I64d (%I64d clusters, Minimum needed: %I64d clusters).", 
        VolData.BootOptimizeBeginClusterExclude,
        VolData.BootOptimizeEndClusterExclude,
        VolData.BootOptimizeEndClusterExclude - VolData.BootOptimizeBeginClusterExclude,
        ClustersNeededForLayout
        );
    return TRUE;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Routine for BootOptimisation.
    
INPUT/OUTPUT:
    Various VolData fields

RETURN:
    ENG_NOERR on success; appropriate ENGERR failure codes otherwise
*/

DWORD
ProcessBootOptimise(
    )    
{
    BOOLEAN bRestart = TRUE;
    BOOL bResult = FALSE;
    BOOL bForce = FALSE,
        bRelocateZone = FALSE;
    LONGLONG llBiggestFreeSpaceRegionStartingLcn = 0,
        llBiggestFreeSpaceRegionClusterCount = 0,
        llAdditionalClustersNeeded = 0,
        llMaxBootClusterEnd = 0;

    LONGLONG llTotalClustersToBeMoved = 0,
        llClustersSuccessfullyMoved = 0;
    
    FILE_LIST_ENTRY NextFileEntry;

    DWORD dwStatus = ENG_NOERR,
        dwIndex = 0;

    Trace(log, "Start: Processing BootOptimise");

    ZeroMemory(&NextFileEntry, sizeof(FILE_LIST_ENTRY));
    
    if (!VolData.BootOptimizeEndClusterExclude) {
        Trace(log, "End: Processing BootOptimise.  BootOptimise region "
            "uninitialised (not boot volume?)");
        return ENGERR_BAD_PARAM;
    }

    // Exit if the controller wants us to stop.
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        ExitThread(0);
    }
    
    //
    // At this point, VolData.BootOptimiseFileTable contains a copy of the file 
    // records for the files that need to be boot-optimised, and 
    // VolData.FilesInBootExcludeZoneTable contains the files that are in our
    // preferred boot-optimise zone that need to be evicted
    // 
    
    //
    // Build the free space list, excluding the zone that we are interested in.
    //
    bResult = BuildFreeSpaceList(
        &VolData.FreeSpaceTable, 
        0, 
        TRUE, 
        &llBiggestFreeSpaceRegionClusterCount, 
        &llBiggestFreeSpaceRegionStartingLcn, 
        TRUE
        );

    if (!bResult) {
        Trace(log, "End: Processing BootOptimise.  Errors encountered while determining free space");
        return ENGERR_NOMEM;
    }

    Trace(log, "BiggestCluster LCN %I64u (%I64u clusters).  "
        "BootOptimiseFilesTotalSize:%I64u AlreadyInZoneSize:%I64u (%d%%)",
        llBiggestFreeSpaceRegionStartingLcn, llBiggestFreeSpaceRegionClusterCount,
         VolData.BootOptimiseFileListTotalSize, 
         VolData.BootOptimiseFilesAlreadyInZoneSize,
         VolData.BootOptimiseFilesAlreadyInZoneSize * 100 / VolData.BootOptimiseFileListTotalSize
         );
    if (llBiggestFreeSpaceRegionClusterCount > VolData.BootOptimiseFileListTotalSize) {
        //
        // There is a free space region that is bigger than the total files
        // we want to move--so check if we want to relocate the boot-optimise
        // zone.
        //
        if ((VolData.BootOptimiseFilesAlreadyInZoneSize * 100 / VolData.BootOptimiseFileListTotalSize) < BOOT_OPTIMISE_ZONE_RELOCATE_THRESHOLD) {
            //
            // Less than 90% of the Boot-Optimise files are already in the zone.
            //
            Trace(log, "Relocating boot-optimise zone to LCN %I64u (%I64u clusters free).  "
                "BootOptimiseFilesTotalSize:%I64u AlreadyInZoneSize:%I64u (%d%%)",
                llBiggestFreeSpaceRegionStartingLcn, llBiggestFreeSpaceRegionClusterCount,
                 VolData.BootOptimiseFileListTotalSize, 
                 VolData.BootOptimiseFilesAlreadyInZoneSize,
                 VolData.BootOptimiseFilesAlreadyInZoneSize * 100 / VolData.BootOptimiseFileListTotalSize
                 );
                
            
            bRelocateZone = TRUE;
            VolData.BootOptimizeBeginClusterExclude = llBiggestFreeSpaceRegionStartingLcn;
            VolData.BootOptimizeEndClusterExclude = VolData.BootOptimizeBeginClusterExclude + VolData.BootOptimiseFileListTotalSize;
        }
    }

    if (!bRelocateZone) {
        //
        // Go through the VolData.FilesInBootExcludeZoneTable, and evict them.  
        //
        bRestart = TRUE;
        do {
            // Exit if the controller wants us to stop.
            if (TERMINATE == VolData.EngineState) {
                PostMessage(hwndMain, WM_CLOSE, 0, 0);
                return ENGERR_GENERAL;
            }
            
            bResult = GetNextNtfsFile(&VolData.FilesInBootExcludeZoneTable, bRestart);
            bRestart = FALSE;
            

            if (bResult) {
                llTotalClustersToBeMoved += VolData.NumberOfClusters;
                
                if (EvictFile()) {
                    llClustersSuccessfullyMoved += VolData.NumberOfClusters;
                }
            }
        } while (bResult);

    }

    Trace(log, "%I64d of %I64d clusters successfully evicted (%d%%)",
        llClustersSuccessfullyMoved, llTotalClustersToBeMoved,
            (llTotalClustersToBeMoved > 0 ? 
            (llClustersSuccessfullyMoved * 100 / llTotalClustersToBeMoved) : 0));

    llClustersSuccessfullyMoved = 0;
    llTotalClustersToBeMoved = VolData.BootOptimiseFileListTotalSize;
    
    //
    // The next step is to move files from layout.ini to the boot optimise 
    // region.  First build a new free-space list, sorted by startingLcn.
    //
    ClearFreeSpaceTable();
    AllocateFreeSpaceListsWithMultipleTrees();

    bResult = BuildFreeSpaceListWithMultipleTrees(
        &llBiggestFreeSpaceRegionClusterCount,
        VolData.BootOptimizeBeginClusterExclude, 
        VolData.BootOptimizeEndClusterExclude);
    if (!bResult) {
        Trace(log, "End: Processing BootOptimise.  Errors encountered while determining free space");
        return ENGERR_NOMEM;
    }
    
    //
    // Finally go through VolData.BootOptmiseFileTable, and move the files
    // to the boot-optimise region.  This will also move files forward if needed.
    //
    if (VolData.pBootOptimiseFrnList) {
        do {

            NextFileEntry.FileRecordNumber = VolData.pBootOptimiseFrnList[dwIndex];
            dwIndex++;

            if (NextFileEntry.FileRecordNumber < 0) {
                bResult = FALSE;
            }
            else {
                bResult = GetNextNtfsFile(&VolData.BootOptimiseFileTable, TRUE, 0, &NextFileEntry);
            }

            // Exit if the controller wants us to stop.
            if (TERMINATE == VolData.EngineState) {
                PostMessage(hwndMain, WM_CLOSE, 0, 0);
                return ENGERR_GENERAL;
            }

            if (bResult) {

                if (VolData.FileRecordNumber == 0) {
                    //
                    // Ignore the MFT
                    //
                    continue;
                }

                //
                // We should only move files less than BOOT_OPTIMIZE_MAX_FILE_SIZE_BYTES MB
                //
                if ((VolData.NumberOfClusters == 0) || 
                   (VolData.NumberOfClusters > (BOOT_OPTIMIZE_MAX_FILE_SIZE_BYTES / VolData.BytesPerCluster))) {
                    continue;
                }

                //
                // Ignore files that we couldn't find during the analyse phase
                //
                if (VolData.StartingLcn == VolData.TotalClusters) {
                    continue;
                }

                if (VolData.bFragmented == TRUE) {
                    bForce = TRUE;
                }
                else {
                    if ((!VolData.bFragmented) && 
                        (VolData.StartingLcn >= VolData.BootOptimizeBeginClusterExclude) &&
                        ((VolData.StartingLcn + VolData.NumberOfClusters) <= VolData.BootOptimizeEndClusterExclude)
                        ) {
                        //
                        // File is fully contained in the boot-optimise zone.  Let's just
                        // try to move it forward if possible, but no worries if we can't.
                        //
                        bForce = FALSE;
                    }
                    else {
                        bForce = TRUE;
                    }
                }
                        
                if (MoveBootOptimiseFile(bForce)) {
                    llClustersSuccessfullyMoved += VolData.NumberOfClusters;
                }
                else {
                    if (bForce) {
                        dwStatus = ENGERR_RETRY;
                        llAdditionalClustersNeeded += VolData.NumberOfClusters;
                    }
                }

                if ((VolData.StartingLcn + VolData.NumberOfClusters > llMaxBootClusterEnd) &&
                    (VolData.StartingLcn <= VolData.TotalClusters)){
                    
                    llMaxBootClusterEnd = VolData.StartingLcn + VolData.NumberOfClusters;
                }
            }
        } while (bResult);
    }
    else {
        dwStatus = ENGERR_NOMEM;
    }

    Trace(log, "%I64d of %I64d clusters successfully moved to zone (%d%%).",
        llClustersSuccessfullyMoved, llTotalClustersToBeMoved,
            (llTotalClustersToBeMoved > 0 ? 
                (llClustersSuccessfullyMoved * 100 / llTotalClustersToBeMoved) : 0)
        );

    //
    // Clean-up
    //
    ClearFreeSpaceListWithMultipleTrees();

    if (VolData.hBootOptimiseFrnList != NULL) {
        
        while (GlobalUnlock(VolData.hBootOptimiseFrnList)) {
            Sleep(1000);
        }
        GlobalFree(VolData.hBootOptimiseFrnList);
        VolData.hBootOptimiseFrnList = NULL;
        VolData.pBootOptimiseFrnList = NULL;
    }    

    if (ENGERR_RETRY == dwStatus) {
        //
        // Some files could not be moved--we need to grow the boot-optimise zone
        // and retry.  
        //

        //
        // Make sure the boot-optimise zone isn't more than 4GB, and 50% of the
        // disk, whichever is smaller
        //
        if (
            ((VolData.BootOptimizeEndClusterExclude - VolData.BootOptimizeBeginClusterExclude) > 
                ((LONGLONG) BOOT_OPTIMIZE_MAX_ZONE_SIZE_MB * ((LONGLONG) 1024 * 1024 / (LONGLONG) VolData.BytesPerCluster))) ||
            ((VolData.BootOptimizeEndClusterExclude  - VolData.BootOptimizeBeginClusterExclude) > 
                (VolData.TotalClusters * BOOT_OPTIMIZE_MAX_ZONE_SIZE_PERCENT / 100))
            ) {
            dwStatus = ENGERR_LOW_FREESPACE;           
        }
        else {

            if (llAdditionalClustersNeeded < (BOOT_OPTIMIZE_ZONE_EXTEND_MIN_SIZE_BYTES / VolData.BytesPerCluster)) {
                llAdditionalClustersNeeded = BOOT_OPTIMIZE_ZONE_EXTEND_MIN_SIZE_BYTES / VolData.BytesPerCluster;
            }

            VolData.BootOptimizeEndClusterExclude += (llAdditionalClustersNeeded * 
                BOOT_OPTIMIZE_ZONE_EXTEND_PERCENT / 100);
        }
    }
    else if (ENG_NOERR == dwStatus) {
        VolData.BootOptimizeEndClusterExclude = llMaxBootClusterEnd;
    }

    SetRegistryEntires(VolData.BootOptimizeBeginClusterExclude, 
        VolData.BootOptimizeEndClusterExclude);

    UnInitialiseBootOptimiseTables(&VolData.BootOptimiseFileTable,
        &VolData.FilesInBootExcludeZoneTable);

    if (ENG_NOERR == dwStatus) {
        SaveErrorInRegistry(TEXT("Yes"),TEXT(" "));
        Trace(log, "End: Processing BootOptimise.  Done");
    }
    else {
        SaveErrorInRegistry(TEXT("No"),TEXT("Insufficient free space"));
        Trace(log, "End: Processing BootOptimise.  Insufficient free space");
    }        

    return dwStatus;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Set the registry entries at the end

INPUT:
        None
RETURN:
        None
*/
VOID SetRegistryEntires(
        IN LONGLONG lLcnStartLocation,
        IN LONGLONG lLcnEndLocation
        )
{


    HKEY hValue = NULL;                //hkey for the registry value
    DWORD dwRegValueSize = 0;          //size of the registry value string
    long ret = 0;                      //return value from SetRegValue
    TCHAR cRegValue[100];              //string to hold the value for the registry


    _stprintf(cRegValue,TEXT("%I64d"),lLcnStartLocation);
    //set the LcnEndLocation from the registry
    dwRegValueSize = sizeof(cRegValue);
    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION,
        cRegValue,
        dwRegValueSize,
        REG_SZ);

    RegCloseKey(hValue);

    hValue = NULL;
    _stprintf(cRegValue,TEXT("%I64d"),lLcnEndLocation);

    //set the LcnEndLocation from the registry
    dwRegValueSize = sizeof(cRegValue);
    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION,
        cRegValue,
        dwRegValueSize,
        REG_SZ);

    RegCloseKey(hValue);

}



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Save the error that may have occured in the registry

INPUT:
        TCHAR tComplete                    Set to Y when everything worked, set to N when error                
        TCHAR* tErrorString                A description of what error occured.
RETURN:
        None
*/
VOID SaveErrorInRegistry(
            TCHAR* tComplete,
            TCHAR* tErrorString)
{


    HKEY hValue = NULL;                //hkey for the registry value
    DWORD dwRegValueSize = 0;          //size of the registry value string
    long ret = 0;                      //return value from SetRegValue

    
    //set the error code of the error in the registry
    dwRegValueSize = 2*(_tcslen(tErrorString));

    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_REGISTRY_ERROR,
        tErrorString,
        dwRegValueSize,
        REG_SZ);

    RegCloseKey(hValue);

    //set the error status in the registry
    hValue = NULL;
    dwRegValueSize = 2*(_tcslen(tComplete));
    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_REGISTRY_COMPLETE,
        tComplete,
        dwRegValueSize,
        REG_SZ);

    RegCloseKey(hValue);


}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the date/time stamp of the input file

INPUT:
        full path to the boot optimize file
RETURN:
        TRUE if file time does not match what is in the registry
        FALSE if the file time matches what is in the registry
*/
BOOL CheckDateTimeStampInputFile(
        IN TCHAR cBootOptimzePath[MAX_PATH]
        )
{
    WIN32_FILE_ATTRIBUTE_DATA   extendedAttr;    //structure to hold file attributes
    LARGE_INTEGER  tBootOptimeFileTime;          //holds the last write time of the file
    LARGE_INTEGER  tBootOptimeRegistryFileTime;  //holds the last write time of the file from registry
    HKEY hValue = NULL;                          //hkey for the registry value
    DWORD dwRegValueSize = 0;                    //size of the registry value string
    long ret = 0;                                //return value from SetRegValue

    tBootOptimeFileTime.LowPart = 0;
    tBootOptimeFileTime.HighPart = 0;
    tBootOptimeRegistryFileTime.LowPart = 0;
    tBootOptimeRegistryFileTime.HighPart = 0;

    //get the last write time of the file
    //if it fails, return FALSE
    if (GetFileAttributesEx (cBootOptimzePath,
                        GetFileExInfoStandard,
                            &extendedAttr))
    {
        tBootOptimeFileTime.LowPart = extendedAttr.ftLastWriteTime.dwLowDateTime;
        tBootOptimeFileTime.HighPart = extendedAttr.ftLastWriteTime.dwHighDateTime;
        
    } else
    {
        return TRUE;            //some error happened and we exit and say we cant get the file time
    }


    //get the time from the registry
    hValue = NULL;
    dwRegValueSize = sizeof(tBootOptimeFileTime.QuadPart);
    ret = GetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_LAST_WRITTEN_DATETIME,
        &(LONGLONG)tBootOptimeRegistryFileTime.QuadPart,
        &dwRegValueSize);

    RegCloseKey(hValue);
    //check to see if the key exists, if it does, check to see if the date/time stamp
    //matches, if it does, exit else write a registry entry
    if (ret == ERROR_SUCCESS) 
    {
        if(tBootOptimeFileTime.QuadPart == tBootOptimeRegistryFileTime.QuadPart)
        {
            return FALSE;        //the file times matched and we exit
        } 
    }
    
    hValue = NULL;
    //update the date and time of the bootoptimize file to the registry
    dwRegValueSize = sizeof(tBootOptimeFileTime.QuadPart);
    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_LAST_WRITTEN_DATETIME,
        (LONGLONG)tBootOptimeFileTime.QuadPart,
        dwRegValueSize,
        REG_QWORD);
    RegCloseKey(hValue);


    return TRUE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgfat\bootoptimizefat.cpp ===
/**************************************************************************************************

FILENAME: BootOptimize.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Boot Optimize for NTFS.

**************************************************************************************************/


#include "stdafx.h"
extern "C"{
    #include <string.h>
    #include <stdio.h>
    #include <stdlib.h>
}


#include "Windows.h"
#include <winioctl.h>
#include <math.h>
#include <fcntl.h>


extern "C" {
    #include "SysStruc.h"
}

#include "BootOptimizeFat.h"
#include "DfrgCmn.h"
#include "GetReg.h"
#include "defragcommon.h"
#include "Devio.h"

#include "movefile.h"
#include "fssubs.h"

#include "Alloc.h"


//This contains the list of Boot Optimize files that are loaded from the BootOptimize file provided by Microsoft
typedef struct{
    TCHAR tBootOptimizeFile[MAX_PATH+1];         //The path to the BootOptimizeFile.
    ULONGLONG dBootOptimizeFileLocationLcn;      //The location of the file its LCN on disk
    LONGLONG dBootOptimizeFileSize;              //The size of the file in clusters.
} BOOT_OPTIMIZE_LIST;

HANDLE hBootOptimizeFileList=NULL;               //Handle to the memory for the Boot Optimize File list.
BOOT_OPTIMIZE_LIST* pBootOptimizeFileList=NULL;  //pointer to the BootOptimize file list
UINT uBootOptimizeCount = 0;                     //count of how many files read into memory

#if OPTLONGLONGMATH
#define DIVIDELONGLONGBY32(num)        Int64ShraMod32((num), 5)
#define MODULUSLONGLONGBY32(num)       ((num) & 0x1F)
#else
#define DIVIDELONGLONGBY32(num)        ((num) / 32)
#define MODULUSLONGLONGBY32(num)       ((num) % 32)
#endif

#define OPTIMAL_LAYOUT_KEY_PATH                  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OptimalLayout")
#define OPTIMAL_LAYOUT_FILE_VALUE_NAME           TEXT("LayoutFilePath")
#define BOOT_OPTIMIZE_REGISTRY_PATH              TEXT("SOFTWARE\\Microsoft\\Dfrg\\BootOptimizeFunction")
#define BOOT_OPTIMIZE_ENABLE_FLAG                TEXT("Enable")
#define BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION  TEXT("LcnStartLocation")
#define BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION    TEXT("LcnEndLocation")
#define BOOT_OPTIMIZE_REGISTRY_COMPLETE          TEXT("OptimizeComplete")
#define BOOT_OPTIMIZE_REGISTRY_ERROR             TEXT("OptimizeError")
#define BOOT_OPTIMIZE_LAST_WRITTEN_DATETIME      TEXT("FileTimeStamp")

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    The main process of the Boot Optimize functionality
    Boot Optimize takes a list of files supplied by Microsoft and puts them in order
    on the disk unfragmented. The reason is that these files are what is loaded at
    boot time, and since the are contiguous, boot time is reduced 10 to 15 percent.

INPUT:
        HANDLE hVolumeHandle           Handle to the Volume 
        LONGLONG BitmapSize            The size of the bitmap, since its already known 
        LONGLONG BytesPerSector        The number of Bytes per Sector 
        LONGLONG TotalClusters         Total number of clusters on the drive
        BOOL IsNtfs                    If we are NTFS volume, this is set to TRUE
        ULONGLONG MftZoneStart         The Cluster Number of the start of the MFT Zone
        ULONGLONG MftZoneEnd           The Cluster Number of the end of the MFT Zone
        TCHAR tDrive                   The current drive letter
RETURN:
        Defrag engine error code.
*/
DWORD BootOptimize(
        IN HANDLE hVolumeHandle,
        IN LONGLONG BitmapSize, 
        IN LONGLONG BytesPerSector, 
        IN LONGLONG TotalClusters,
        IN BOOL IsNtfs,
        IN ULONGLONG MftZoneStart,
        IN ULONGLONG MftZoneEnd,
        IN TCHAR tDrive
        )
{

    LONGLONG lFirstAvailableFreeSpace = 0;       //the first available free space on the disk dig enough to move to
    LONGLONG lLcnStartLocation = 0;              //the starting location of where the files were moved last
    LONGLONG lLcnEndLocation = 0;                //the ending location of where the files were moved last
    LONGLONG ulBootOptimizeFileSize = 0;         //size in clusters of how big the boot optimize files are
    LONGLONG lFreeSpaceSize = 0;                 //size in clusters of found free space
    TCHAR cBootOptimzePath[MAX_PATH];            //string to hold the path of the file 
    DWORD ErrCode;

    //make sure the drive letter is upper case
    tDrive = towupper(tDrive);

    //check to see if this is the boot volume
    if(!IsBootVolume(tDrive))        //was not boot volume so return
    {
        SaveErrorInRegistry(TEXT("No"),TEXT("Not Boot Volume"));
        return ENGERR_BAD_PARAM;
    }

    //get the registry entries
    if(!GetRegistryEntires(cBootOptimzePath))
    {
        SaveErrorInRegistry(TEXT("No"),TEXT("Missing Registry Entries"));
        return ENGERR_BAD_PARAM;            //must be some error in getting registry entries
    }

    //check the date and time stamp of the file
    //the starting and ending lcn numbers are reset if the boot optimize input
    //file has changed since that last time boot optimize is run.  That means that
    //the file will go anywhere on the disk where a big enough space exists.
    if(CheckDateTimeStampInputFile(cBootOptimzePath))
    {
        lLcnStartLocation = 0;
        lLcnEndLocation = 0;
        //save the starting and end lcn numbers in the registry 
        SetRegistryEntires(lLcnStartLocation, lLcnEndLocation);
    } else
    {
        //if the file has not changed, use the locations out of the registry,
        //we will check to see if we can move them forward
        lLcnStartLocation = GetStartingEndLncLocations(BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION);
        lLcnEndLocation = GetStartingEndLncLocations(BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION);
    }
    
    //check to see if the boot optimize input file exists, if it does not
    //save an error in the registry and exit out 
    if(!OpenReadBootOptimeFileIntoList(cBootOptimzePath, IsNtfs, tDrive))
    {
        SaveErrorInRegistry(TEXT("No"),TEXT("Can't Open Boot Optimize file"));
        return ENGERR_BAD_PARAM;
    }

    //get the file sizes of the files in the list
    ulBootOptimizeFileSize = GetSizeInformationAboutFiles();

    //if the size of the files is different than the size of the registry entries
    //then set the registry entry settings to zero and it will be as if nothing was
    //optimized.  I do this because if the file sizes changed, they cannot be in the 
    //same spots, so optimize them
    if(ulBootOptimizeFileSize != (lLcnEndLocation - lLcnStartLocation))
    {
        lLcnStartLocation = 0;
        lLcnEndLocation = 0;
    }    

    //find the first available chunk of free space that is available

    for (lFreeSpaceSize = ulBootOptimizeFileSize;
         lFreeSpaceSize >= ulBootOptimizeFileSize/8;
         lFreeSpaceSize -= ulBootOptimizeFileSize/8) {

        lFirstAvailableFreeSpace = FindFreeSpaceChunk(BitmapSize, BytesPerSector, 
            TotalClusters, lFreeSpaceSize, IsNtfs, MftZoneStart, MftZoneEnd, hVolumeHandle);

        //break out with the first found largest free space chunk.
        if (0 != lFirstAvailableFreeSpace) {
            break;
        }

        //if the files are already in place, don't continue looking for
        //smaller free space chunks.
        if (0 != lLcnStartLocation) {
            break;
        }
    }

    if (0 == lFirstAvailableFreeSpace) {
        //do some clean up and exit out, we don't want to move the files
        //free the file list
        FreeFileList();
        SaveErrorInRegistry(TEXT("No"),TEXT("No free space"));
        return ENGERR_LOW_FREESPACE;
    }

    //check to see if the first available space is before where the files are now
    if(lLcnStartLocation != 0)        //this is true if we have not successfuly moved the files
    {
        if(lFirstAvailableFreeSpace > lLcnStartLocation)
        {    
            //do some clean up and exit out, we don't want to move the files
            //free the file list
            FreeFileList();
            SaveErrorInRegistry(TEXT("No"),TEXT("No space before current location"));
            return ENGERR_LOW_FREESPACE;
        }
    }

    //move the files to the proper memory location
    if(MoveFilesInOrder(lFirstAvailableFreeSpace, lFirstAvailableFreeSpace + lFreeSpaceSize, hVolumeHandle))
    {
        lLcnStartLocation = lFirstAvailableFreeSpace;
        lLcnEndLocation = lLcnStartLocation + lFreeSpaceSize;

        SaveErrorInRegistry(TEXT("Yes"),TEXT(" "));

        ErrCode = ENG_NOERR;
        
    } else
    {
        lLcnStartLocation = 0;
        lLcnEndLocation = 0;

        ErrCode = ENGERR_GENERAL;
    }

    //save the starting and end lcn numbers in the registry 
    SetRegistryEntires(lLcnStartLocation, lLcnEndLocation);

    //free the file list memory
    FreeFileList();

    return ErrCode;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Reads the boot optimize files from a file and loads then into a list.

INPUT:
        FILE *hBootOptimizeFile            Handle to the Boot Optimize File
        BOOL IsNtfs                        Boolean if this is a NTFS Volume
        TCHAR tDrive                       TCHAR Drive letter
    
RETURN:
        Returns TRUE if this is boot value, else FALSE if it is not.
*/
BOOL OpenReadBootOptimeFileIntoList(
        IN TCHAR* cBootOptimzePath,
        IN BOOL IsNtfs,
        IN TCHAR tDrive
        )
{
    UINT uNumberofRecords = 0;

    //count the number of records in the Boot Optimize File
    uNumberofRecords = CountNumberofRecordsinFile(cBootOptimzePath);

    //if the number of records is zero, return
    if(uNumberofRecords == 0)
    {
        return FALSE;
    }

    //create a list of files to optimize, if I run out of space, double the size of the list and
    //try again until I either run out of memory or Everything loads correctly.
    do
    {
        //allocate memory for the list of files in boot optimize
        //I am allocating for 100 files right now
        if (!AllocateMemory((DWORD) (sizeof(BOOT_OPTIMIZE_LIST) * uNumberofRecords), &hBootOptimizeFileList, (PVOID*) &pBootOptimizeFileList))
        {
            return FALSE;
        }
    
        //load the files that need to be optimized into memory
        if(!LoadOptimizeFileList(cBootOptimzePath, IsNtfs, tDrive, uNumberofRecords))
        {
            FreeFileList();
            uNumberofRecords = uNumberofRecords * 2;
        } else
        {
            break;
        }
    } while (1);

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get a rough idea of how many records are in the file and triple it, to make an estimation
    of how many files are in the boot optimize file, and I triple it to account for multiple
    stream files.  Also make the assumption that the file count is atleast 300, so that I can
    allocate enough memory to hold all the records.

INPUT:
        full path name to the boot optimize file
RETURN:
        triple the number of records in the boot optimize file.
*/
UINT CountNumberofRecordsinFile(
        IN TCHAR* cBootOptimzePath
        )
{
    UINT uNumberofRecords = 0;         //the number of records in the input file
    TCHAR tBuffer [MAX_PATH];          //temporary buffer to the input string
    ULONG ulLength;                    //length of the line read in by fgetts
    FILE* fBootOptimizeFile;           //File Pointer to fBootOptimizeFile

    //set read mode to binary
    _fmode = _O_BINARY;

    //open the file
    //if I can't open the file, return a record count of zero
    fBootOptimizeFile = _tfopen(cBootOptimzePath,TEXT("r"));
    if(fBootOptimizeFile == NULL)
    {
        return 0;
    }

    //read the entire file and count the number of records
    while(_fgetts(tBuffer,MAX_PATH - 1,fBootOptimizeFile) != 0)
    {
        // check for terminating carriage return.
        ulLength = wcslen(tBuffer);
        if (ulLength && (tBuffer[ulLength - 1] == TEXT('\n'))) {
            uNumberofRecords++;
        } 
    }

    fclose(fBootOptimizeFile);

    //triple the number of records we have
    if(uNumberofRecords < 100)
    {
        uNumberofRecords = 100;
    }
    uNumberofRecords *= 3;

    return uNumberofRecords;

}    
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Reads the boot optimize files from a file and loads then into a list.

INPUT:
        FILE *hBootOptimizeFile            Handle to the Boot Optimize File
        BOOL IsNtfs                        Boolean if this is a NTFS Volume
        TCHAR tDrive                        TCHAR Drive letter
    
RETURN:
        Returns TRUE if this is boot value, else FALSE if it is not.
*/
BOOL LoadOptimizeFileList(
        IN TCHAR* cBootOptimzePath,
        IN BOOL IsNtfs,
        IN TCHAR tDrive,
        IN UINT uNumberofRecords
        )
{
    BY_HANDLE_FILE_INFORMATION FileInformation;
    HANDLE hBootOptimizeFileHandle;               //temporary Handle to boot optimize files
    TCHAR tBuffer [MAX_PATH+1];                  //temporary buffer to the input string
    ULONG ulLength;                              //length of the line read in by fgetts
    FILE* fBootOptimizeFile;                     //File Pointer to fBootOptimizeFile
    BOOL FileIsDirectory;
    
    //set the number of records read to 0
    uBootOptimizeCount = 0;

    //set read mode to binary
    _fmode = _O_BINARY;

    //open the file
    fBootOptimizeFile = _tfopen(cBootOptimzePath,TEXT("r"));
    if(fBootOptimizeFile != NULL)
    {

        //read the entire file and check each file to make sure its valid
        //then add to the list
        while(_fgetts(tBuffer,MAX_PATH,fBootOptimizeFile) != 0)
        {
                // remove terminating carriage return.
                ulLength = wcslen(tBuffer);
                if (ulLength < 2) { 
                    continue;
                }

                if (tBuffer[ulLength - 1] == TEXT('\n')) {
                    tBuffer[ulLength - 1] = 0;
                    ulLength--;
                    if (tBuffer[ulLength - 1] == TEXT('\r')) {
                        tBuffer[ulLength - 1] = 0;
                        ulLength--;
                    }
                } else {
                    continue;
                }

            if(IsAValidFile(tBuffer, tDrive))
            {
                hBootOptimizeFileHandle = GetFileHandle(tBuffer);
                //if file handle is not NULL, count it, else skip the file, its not a valid file
                if(hBootOptimizeFileHandle != NULL)
                {
                    // determine if directory file.
                    FileIsDirectory = FALSE;
                    if (GetFileInformationByHandle(hBootOptimizeFileHandle, &FileInformation)) {
                        FileIsDirectory = (FileInformation.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
                    }

                    // on FAT skip directory files: we can't move them.
                    if (IsNtfs || (!FileIsDirectory))  {

                        _tcscpy(pBootOptimizeFileList[uBootOptimizeCount].tBootOptimizeFile,tBuffer);
                    
                        uBootOptimizeCount++;
                        //check to see if the number of records in the list is greater than the allocated size
                        //if it is, return FALSE , reallocate the list and try again
                        if(uBootOptimizeCount >= uNumberofRecords)
                        {
                            CloseFileHandle(hBootOptimizeFileHandle);
                            fclose(fBootOptimizeFile);
                            return FALSE;
                        }

                        if(IsNtfs)
                        {
                            //I fail from loading streams also if I run out of space
                            if(!GetBootOptimizeFileStreams(hBootOptimizeFileHandle, tBuffer, uNumberofRecords))
                            {
                                CloseFileHandle(hBootOptimizeFileHandle);
                                fclose(fBootOptimizeFile);
                                return FALSE;
                            }
                        }
                    }
                    
                    CloseFileHandle(hBootOptimizeFileHandle);
                }
            }
        }
        //close the file at the end
        fclose(fBootOptimizeFile);
    }
    return TRUE;
}


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Validates that we have a valid file name.

INPUT:
        TCHAR* phBootOptimizeFileName        The file name input from the list
        TCHAR tDrive                        TCHAR Drive letter
    
RETURN:
        Returns TRUE if this is boot value, else FALSE if it is not.
*/
BOOL IsAValidFile(
        IN TCHAR pBootOptimizeFileName[MAX_PATH+1],
        IN TCHAR tDrive
        )

{

    TCHAR tBootOptimizeFileDrive;                //holds the drive letter of the file name input
    TCHAR tFileName[MAX_PATH+1];

    //ignore blank lines
    if(_tcslen(pBootOptimizeFileName) == 0)
    {
        return FALSE;
    }

    //set the string to upper case to compare
    pBootOptimizeFileName = _tcsupr(pBootOptimizeFileName);

    //ignore the group headers
    if(_tcsstr(pBootOptimizeFileName,TEXT("[OPTIMALLAYOUTFILE]")) != NULL)
    {
        return FALSE;
    }

    //ignore the file = and version = lines
    if(_tcsstr(pBootOptimizeFileName,TEXT("VERSION=")) != NULL)
    {
        return FALSE;
    }

    //get the drive the file is on, if its not the boot drive, skip the file
    tBootOptimizeFileDrive = pBootOptimizeFileName[0];

    //convert the characters to upper case before comparison
    tBootOptimizeFileDrive = towupper(tBootOptimizeFileDrive);

    if(tBootOptimizeFileDrive != tDrive)        //files are on boot drive else skip them
    {
        return FALSE;
    }
    
    //get just the file name from the end of the path
    if(_tcsrchr(pBootOptimizeFileName,TEXT('\\')) != NULL)
    {
        _tcscpy(tFileName,_tcsrchr(pBootOptimizeFileName,TEXT('\\'))+1);

    } else
    {
        //not a valid name
        return FALSE;
    }

    //if string length is zero, must be directory, return
    if(_tcslen(tFileName) == 0)
    {
        return TRUE;
    }

    if(_tcsicmp(tFileName,TEXT("BOOTSECT.DOS")) == 0)
    {
        return FALSE;
    }

    if(_tcsicmp(tFileName,TEXT("SAFEBOOT.FS")) == 0)
    {
        return FALSE;
    }
    
    if(_tcsicmp(tFileName,TEXT("SAFEBOOT.CSV")) == 0)
    {
        return FALSE;
    }
    
    if(_tcsicmp(tFileName,TEXT("SAFEBOOT.RSV")) == 0)
    {
        return FALSE;
    } 
    
    if(_tcsicmp(tFileName,TEXT("HIBERFIL.SYS")) == 0)
    {
            return FALSE;
    }
    
    if(_tcsicmp(tFileName,TEXT("MEMORY.DMP")) == 0)
    {
        return FALSE;
    }
    
    if(_tcsicmp(tFileName,TEXT("PAGEFILE.SYS")) == 0)
    {
            return FALSE;
    } 

    //file is OK, return TRUE
    return TRUE;

}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    get the file handle for the files in the list

INPUT:
        TCHAR* tBootOptimizeFile                    TCHAR* to the boot optimize file name
RETURN:
        HANDLE to the file or NULL
*/
HANDLE GetFileHandle(
        IN TCHAR* tBootOptimizeFile
        )
{
    HANDLE hFile = NULL;                //HANDLE for the file to open, it is returned if is valid
    
    DWORD dwCreationDisposition;

    //sks bug #217428 change the parameters so that all files are moved
    dwCreationDisposition = FILE_FLAG_BACKUP_SEMANTICS | FILE_OPEN_REPARSE_POINT;

    hFile = CreateFile(tBootOptimizeFile, 
                       FILE_READ_ATTRIBUTES | SYNCHRONIZE, 
                       0, 
                       NULL, 
                       OPEN_EXISTING, 
                       dwCreationDisposition, 
                       NULL);
    
    if (hFile == INVALID_HANDLE_VALUE) 
    {
        return NULL;
    } else
    {    
        return hFile;
    }
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    get the file handle for the files in the list

INPUT:
        TCHAR* tBootOptimizeFile                    TCHAR* to the boot optimize file name
RETURN:
        HANDLE to the file or NULL
*/
BOOL CloseFileHandle(
        IN HANDLE hBootOptimizeFileHandle
        )
{
    if(hBootOptimizeFileHandle != NULL)
    {
        CloseHandle(hBootOptimizeFileHandle);
        return TRUE;
    }
    return FALSE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Gets all the streams for a file in NTFS and adds them to the file list, should not be called for FAT/FAT32

GLOBALS:
        uBootOptimizeCount
        pBootOptimizeFileList

INPUT:
        HANDLE hBootOptimizeFileHandle            HANDLE to the Boot Optimize File
RETURN:
        TRUE is all streams of all files was loaded correctly.
        FALSE is an error occured loading all the streams
*/
BOOL GetBootOptimizeFileStreams(
        IN HANDLE hBootOptimizeFileHandle,
        IN TCHAR* tBootOptimizeFile,
        IN UINT uNumberofRecords
        )
{
    HANDLE htempBootOptimizeFileHandle;                    //temporary Handle to the file
    // fixed size buffer for some API calls
    const  ULONG FixedBufferSize = 4096;                   //fixed buffer size for API Calls
    static UCHAR FixedBuffer[FixedBufferSize];             //fixed buffer for API Calls    
    
    // clear buffer
    memset(FixedBuffer, 0, FixedBufferSize);

    // query file system
    NTSTATUS                    status;                          //NTSTATUS 
    IO_STATUS_BLOCK             iosb;                            //IO status block 
    FILE_STREAM_INFORMATION*    StreamInfo = (FILE_STREAM_INFORMATION*) FixedBuffer;    //stream info
    FILE_STREAM_INFORMATION*    Stream;                          //info on the stream
    PTCHAR                      StreamName = NULL;               //TCHAR pointer to the stream name 
    TCHAR tTemporaryStreamName[MAX_PATH+1];                      //the name of the stream filename:stream

    if (hBootOptimizeFileHandle == INVALID_HANDLE_VALUE) 
    {
        return TRUE;
    } else
    {
        status = NtQueryInformationFile(hBootOptimizeFileHandle, 
                                        &iosb,
                                        FixedBuffer,
                                        FixedBufferSize,
                                        FileStreamInformation);
        // if this buffer was too small return
        if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL)
        {
            return TRUE;
        }
        // process the return data
        else
        {
            Stream = StreamInfo;

            // loop thru returned data
            while (Stream != NULL)
            {
                // handle stream name
                if (Stream->StreamNameLength > 0)
                {
                    // parse it
                    StreamName = ParseStreamName((PTCHAR) &Stream->StreamName);
                    if (StreamName != NULL)
                    {
                        //
                        // Make sure we don't go past MAX_PATH - 1, since our global array can only handle
                        // stuff up to MAX_PATH + 1 characters long  (don't forget the ":" and terminating 
                        // NULL)
                        //
                        if ((wcslen(tBootOptimizeFile) + wcslen(StreamName)) < (MAX_PATH-1)) {

                            //set the name of the file in the list and get a handle for the file
                            //append the stream name to the file name
                            _tcscpy(tTemporaryStreamName,tBootOptimizeFile);
                            _tcscat(tTemporaryStreamName,TEXT(":"));
                            _tcscat(tTemporaryStreamName,StreamName);

                            htempBootOptimizeFileHandle = GetFileHandle(tTemporaryStreamName);
                            if(htempBootOptimizeFileHandle != NULL)
                            {
                                _tcscpy(pBootOptimizeFileList[uBootOptimizeCount].tBootOptimizeFile,tTemporaryStreamName);
                                CloseFileHandle(htempBootOptimizeFileHandle);
                                uBootOptimizeCount++;
                                if(uBootOptimizeCount >= uNumberofRecords)
                                {
                                    return FALSE;    
                                }
                            }
                        }
                    }
                }

                // move on to next one or break
                if (Stream->NextEntryOffset > 0)
                {
                    Stream = (FILE_STREAM_INFORMATION *) (((UCHAR*) Stream) + Stream->NextEntryOffset);
                }
                else
                {
                    Stream = NULL;
                }
            }
        }
    }
    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    parses string name for streams
INPUT:
        PTCHAR StreamName            The stream name to parse
RETURN:
        PTCHAR StreamName            The parsed stream name
    
*/
static PTCHAR ParseStreamName(
        IN OUT PTCHAR StreamName
        )
{
    // nothing in, nothing out
    if (StreamName == NULL || _tcslen(StreamName) < 1)
    {
        return NULL;
    }

    // ignore the default stream
    if (_tcscmp(StreamName, TEXT("::$DATA")) == MATCH)
    {
        return NULL;
    }

    // parse it
    PTCHAR TmpStreamName = StreamName;

    // skip leading colons
    while (TmpStreamName[0] == TEXT(':'))
    {
        TmpStreamName++;
    }

    // take out ":$DATA"
    PTCHAR ptr = _tcsstr(TmpStreamName, TEXT(":$DATA"));

    if (ptr != NULL)
    {
        ptr[0] = TEXT('\0');
    }

    // see if we have anything left
    if (_tcslen(TmpStreamName) < 1)
    {
        return NULL;
    }

    return TmpStreamName;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Frees the memory allocated for the boot optimize files.

INPUT:
        None    
RETURN:
        None    
*/
VOID FreeFileList()
{

    if(hBootOptimizeFileList != NULL)
    {
        while (GlobalUnlock(hBootOptimizeFileList))
        {
            ;
        }
        GlobalFree(hBootOptimizeFileList);
        hBootOptimizeFileList = NULL;
    }    

    return;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the size of each file in the list of the Boot Optimize Files.
INPUT:
        None    
RETURN:
        None
*/
LONGLONG GetSizeInformationAboutFiles()
{
    HANDLE hBootOptimizeFileHandle;              //Handle to the boot optimize file
    LONGLONG ulBootOptimizeFileSize = 0;         //store the total size of the files
    //get the size of each file in the list

    for(UINT ii=0;ii<uBootOptimizeCount;ii++)
    {
        //get the handle to the file
        hBootOptimizeFileHandle = GetFileHandle(pBootOptimizeFileList[ii].tBootOptimizeFile);
        if(hBootOptimizeFileHandle != NULL)
        {    
            //set the size of the file in the list
            pBootOptimizeFileList[ii].dBootOptimizeFileSize = GetFileSizeInfo(hBootOptimizeFileHandle);
            //sum up the sizes of the files

            ulBootOptimizeFileSize += pBootOptimizeFileList[ii].dBootOptimizeFileSize;
            CloseFileHandle(hBootOptimizeFileHandle);
        } else    
        {
            //can't open the file, so set the size to zero.
            pBootOptimizeFileList[ii].dBootOptimizeFileSize = 0;
        }    
    }
    return ulBootOptimizeFileSize;
}


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the size of the file in clusters from calling FSCL_GET_RETRIEVAL_POINTERS.

INPUT:
        HANDLE hBootOptimizeFileHandle        The handle to the File to get the size of
RETURN:
        The size of the file in clusters
*/

ULONGLONG GetFileSizeInfo(
        IN HANDLE hBootOptimizeFileHandle
        )
{
    ULONGLONG                        ulSizeofFileInClusters = 0;        //size of the file in clusters
    int                                i;
    ULONGLONG                        startVcn = 0;                      //starting VCN of the file, always 0
    STARTING_VCN_INPUT_BUFFER        startingVcn;                       //starting VCN Buffer
    ULONG                            BytesReturned = 0;                 //number of bytes returned by ESDeviceIoControl 
    HANDLE                            hRetrievalPointersBuffer = NULL;  //Handle to the Retrieval Pointers Buffer
    PRETRIEVAL_POINTERS_BUFFER        pRetrievalPointersBuffer = NULL;  //pointer to the Retrieval Pointer
    PLARGE_INTEGER                    pRetrievalPointers = NULL;        //Pointer to retrieval pointers    
    ULONG                            RetrievalPointers = 0x100;         //Number of extents for the file, try 256 first
    BOOL                            bGetRetrievalPointersMore = TRUE;   //boolean to test the end of getting retrieval pointers

    if (hBootOptimizeFileHandle == INVALID_HANDLE_VALUE) 
    {
        return 0;
    }

    //zero the memory of the starting VCN input buffer
    ZeroMemory(&startVcn, sizeof(STARTING_VCN_INPUT_BUFFER));


    //0.1E00 Read the retrieval pointers into a buffer in memory.
    while(bGetRetrievalPointersMore){
    
        //0.0E00 Allocate a RetrievalPointersBuffer.
        if(!AllocateMemory(sizeof(RETRIEVAL_POINTERS_BUFFER) + (RetrievalPointers * 2 * sizeof(LARGE_INTEGER)),
                           &hRetrievalPointersBuffer,
                           (void**)(PCHAR*)&pRetrievalPointersBuffer))
        {
            return 0;
        }

        startingVcn.StartingVcn.QuadPart = 0;
        if(ESDeviceIoControl(hBootOptimizeFileHandle,
                             FSCTL_GET_RETRIEVAL_POINTERS,
                             &startingVcn,
                             sizeof(STARTING_VCN_INPUT_BUFFER),
                             pRetrievalPointersBuffer,
                             (DWORD)GlobalSize(hRetrievalPointersBuffer),
                             &BytesReturned,
                             NULL))
        {
            bGetRetrievalPointersMore = FALSE;
        } else
        {

            //This occurs on a zero length file (no clusters allocated).
            if(GetLastError() == ERROR_HANDLE_EOF)
            {
                //file is zero lenght, so return 0
                //free the memory for the retrival pointers
                //the while loop makes sure all occurances are unlocked
                while (GlobalUnlock(hRetrievalPointersBuffer))
                {
                    ;
                }
                GlobalFree(hRetrievalPointersBuffer);
                hRetrievalPointersBuffer = NULL;
                return 0;
            }

            //0.0E00 Check to see if the error is not because the buffer is too small.
            if(GetLastError() == ERROR_MORE_DATA)
            {
                //0.1E00 Double the buffer size until it's large enough to hold the file's extent list.
                RetrievalPointers *= 2;
            } else
            {
                //some other error, return 0
                //free the memory for the retrival pointers
                //the while loop makes sure all occurances are unlocked
                while (GlobalUnlock(hRetrievalPointersBuffer))
                {
                    ;
                }
                GlobalFree(hRetrievalPointersBuffer);
                hRetrievalPointersBuffer = NULL;
                return 0;
            }
        }

    }

    //loop through the retrival pointer list and add up the size of the file
    startVcn = pRetrievalPointersBuffer->StartingVcn.QuadPart;
    for (i = 0; i < (ULONGLONG) pRetrievalPointersBuffer->ExtentCount; i++) 
    {
        ulSizeofFileInClusters += pRetrievalPointersBuffer->Extents[i].NextVcn.QuadPart - startVcn;
        startVcn = pRetrievalPointersBuffer->Extents[i].NextVcn.QuadPart;
    }

    if(hRetrievalPointersBuffer != NULL)
    {
        //free the memory for the retrival pointers
        //the while loop makes sure all occurances are unlocked
        while (GlobalUnlock(hRetrievalPointersBuffer))
        {
            ;
        }
        GlobalFree(hRetrievalPointersBuffer);
        hRetrievalPointersBuffer = NULL;
    }


    return ulSizeofFileInClusters; 

}




/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
        Loops through the file list and moves the files
INPUT:
        ULONGLONG lMoveFileHere                    Cluster to move the files to    
        ULONGLONG lEndOfFreeSpace               Cluster where free space chunk ends.
RETURN:
        BOOL if the move completed, returns TRUE, else if a move failed, returns FALSE
*/
BOOL MoveFilesInOrder(
        IN ULONGLONG lMoveFileHere,
        IN ULONGLONG lEndOfFreeSpace,
        IN HANDLE hBootVolumeHandle
        )
{

    HANDLE hBootOptimizeFileHandle;                //Handle for the boot optimize file

    for(int ii=0;ii<(int)uBootOptimizeCount;ii++)
    {
        hBootOptimizeFileHandle = GetFileHandle(pBootOptimizeFileList[ii].tBootOptimizeFile);
        if(hBootOptimizeFileHandle != NULL)
        {
            // Try to move the files in the list into contiguous space
            MoveFileLocation(hBootOptimizeFileHandle, 
                             lMoveFileHere,
                             pBootOptimizeFileList[ii].dBootOptimizeFileSize, 
                             0, 
                             hBootVolumeHandle);

            CloseFileHandle(hBootOptimizeFileHandle);
        }
        //increase the move to location by the size of the file
        lMoveFileHere += pBootOptimizeFileList[ii].dBootOptimizeFileSize;    

        //have we gone past the end of free space chunk?
        if (lMoveFileHere > lEndOfFreeSpace) {
            break;
        }
    }

    return TRUE;
}



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Gets the registry entries at the beginning of the program

INPUT:
        Success - TRUE
        Failed - FALSE
RETURN:
        None
*/
BOOL GetRegistryEntires(
        OUT TCHAR cBootOptimzePath[MAX_PATH]
        )
{
    HKEY hValue = NULL;                //hkey for the registry value
    DWORD dwRegValueSize = 0;          //size of the registry value string
    long ret = 0;                      //return value from SetRegValue
    TCHAR cEnabledString[2];           //holds the enabled flag

    // get Boot Optimize file name from registry
    dwRegValueSize = sizeof(cEnabledString);
    ret = GetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_ENABLE_FLAG,
        cEnabledString,
        &dwRegValueSize);

    RegCloseKey(hValue);
    //check to see if the key exists, else exit from routine
    if (ret != ERROR_SUCCESS) 
    {
        return FALSE;
    }
    //check to see that boot optimize is enabled
    if(cEnabledString[0] != TEXT('Y'))
    {
        return FALSE;
    }

    // get Boot Optimize file name from registry
    hValue = NULL;
    dwRegValueSize = MAX_PATH;
    ret = GetRegValue(
        &hValue,
        OPTIMAL_LAYOUT_KEY_PATH,
        OPTIMAL_LAYOUT_FILE_VALUE_NAME,
        cBootOptimzePath,
        &dwRegValueSize);

    RegCloseKey(hValue);
    //check to see if the key exists, else exit from routine
    if (ret != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Gets the registry entries at the beginning of the program

INPUT:
        pointer to the registry key
RETURN:
        Success - TRUE
        Failed - FALSE
*/
LONGLONG GetStartingEndLncLocations(
        IN PTCHAR pRegKey
        )
{
    HKEY hValue = NULL;                //hkey for the registry value
    DWORD dwRegValueSize = 0;          //size of the registry value string
    long ret = 0;                      //return value from SetRegValue
    TCHAR cRegValue[100];              //string to hold the value for the registry

    LONGLONG lLcnStartEndLocation = 0;

    //get the LcnStartLocation from the registry
    dwRegValueSize = sizeof(cRegValue);
    ret = GetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        pRegKey,
        cRegValue,
        &dwRegValueSize);

    RegCloseKey(hValue);
    //check to see if the key exists, else exit from routine
    if (ret != ERROR_SUCCESS) 
    {
        hValue = NULL;
        _stprintf(cRegValue,TEXT("%d"),0);
        //add the LcnStartLocation to the registry
        dwRegValueSize = sizeof(cRegValue);
        ret = SetRegValue(
            &hValue,
            BOOT_OPTIMIZE_REGISTRY_PATH,
            pRegKey,
            cRegValue,
            dwRegValueSize,
            REG_SZ);

        RegCloseKey(hValue);
    } else
    {
        lLcnStartEndLocation = _ttoi(cRegValue);
    }
    
    return lLcnStartEndLocation;
}



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Set the registry entries at the end

INPUT:
        None
RETURN:
        None
*/
VOID SetRegistryEntires(
        IN LONGLONG lLcnStartLocation,
        IN LONGLONG lLcnEndLocation
        )
{


    HKEY hValue = NULL;                //hkey for the registry value
    DWORD dwRegValueSize = 0;          //size of the registry value string
    long ret = 0;                      //return value from SetRegValue
    TCHAR cRegValue[100];              //string to hold the value for the registry


    _stprintf(cRegValue,TEXT("%I64d"),lLcnStartLocation);
    //set the LcnEndLocation from the registry
    dwRegValueSize = sizeof(cRegValue);
    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION,
        cRegValue,
        dwRegValueSize,
        REG_SZ);

    RegCloseKey(hValue);

    hValue = NULL;
    _stprintf(cRegValue,TEXT("%I64d"),lLcnEndLocation);

    //set the LcnEndLocation from the registry
    dwRegValueSize = sizeof(cRegValue);
    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION,
        cRegValue,
        dwRegValueSize,
        REG_SZ);

    RegCloseKey(hValue);

}



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Save the error that may have occured in the registry

INPUT:
        TCHAR tComplete                    Set to Y when everything worked, set to N when error                
        TCHAR* tErrorString                A description of what error occured.
RETURN:
        None
*/
VOID SaveErrorInRegistry(
            TCHAR* tComplete,
            TCHAR* tErrorString)
{


    HKEY hValue = NULL;                //hkey for the registry value
    DWORD dwRegValueSize = 0;          //size of the registry value string
    long ret = 0;                      //return value from SetRegValue

    
    //set the error code of the error in the registry
    dwRegValueSize = 2*(_tcslen(tErrorString));

    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_REGISTRY_ERROR,
        tErrorString,
        dwRegValueSize,
        REG_SZ);

    RegCloseKey(hValue);

    //set the error status in the registry
    hValue = NULL;
    dwRegValueSize = 2*(_tcslen(tComplete));
    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_REGISTRY_COMPLETE,
        tComplete,
        dwRegValueSize,
        REG_SZ);

    RegCloseKey(hValue);


}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the date/time stamp of the input file

INPUT:
        full path to the boot optimize file
RETURN:
        TRUE if file time does not match what is in the registry
        FALSE if the file time matches what is in the registry
*/
BOOL CheckDateTimeStampInputFile(
        IN TCHAR cBootOptimzePath[MAX_PATH]
        )
{
    WIN32_FILE_ATTRIBUTE_DATA   extendedAttr;    //structure to hold file attributes
    LARGE_INTEGER  tBootOptimeFileTime;          //holds the last write time of the file
    LARGE_INTEGER  tBootOptimeRegistryFileTime;  //holds the last write time of the file from registry
    HKEY hValue = NULL;                          //hkey for the registry value
    DWORD dwRegValueSize = 0;                    //size of the registry value string
    long ret = 0;                                //return value from SetRegValue

    tBootOptimeFileTime.LowPart = 0;
    tBootOptimeFileTime.HighPart = 0;
    tBootOptimeRegistryFileTime.LowPart = 0;
    tBootOptimeRegistryFileTime.HighPart = 0;

    //get the last write time of the file
    //if it fails, return FALSE
    if (GetFileAttributesEx (cBootOptimzePath,
                        GetFileExInfoStandard,
                            &extendedAttr))
    {
        tBootOptimeFileTime.LowPart = extendedAttr.ftLastWriteTime.dwLowDateTime;
        tBootOptimeFileTime.HighPart = extendedAttr.ftLastWriteTime.dwHighDateTime;
        
    } else
    {
        return TRUE;            //some error happened and we exit and say we cant get the file time
    }


    //get the time from the registry
    hValue = NULL;
    dwRegValueSize = sizeof(tBootOptimeFileTime.QuadPart);
    ret = GetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_LAST_WRITTEN_DATETIME,
        &(LONGLONG)tBootOptimeRegistryFileTime.QuadPart,
        &dwRegValueSize);

    RegCloseKey(hValue);
    //check to see if the key exists, if it does, check to see if the date/time stamp
    //matches, if it does, exit else write a registry entry
    if (ret == ERROR_SUCCESS) 
    {
        if(tBootOptimeFileTime.QuadPart == tBootOptimeRegistryFileTime.QuadPart)
        {
            return FALSE;        //the file times matched and we exit
        } 
    }
    
    hValue = NULL;
    //update the date and time of the bootoptimize file to the registry
    dwRegValueSize = sizeof(tBootOptimeFileTime.QuadPart);
    ret = SetRegValue(
        &hValue,
        BOOT_OPTIMIZE_REGISTRY_PATH,
        BOOT_OPTIMIZE_LAST_WRITTEN_DATETIME,
        (LONGLONG)tBootOptimeFileTime.QuadPart,
        dwRegValueSize,
        REG_QWORD);
    RegCloseKey(hValue);


    return TRUE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgntfs\dfrgntfs.cpp ===
/*****************************************************************************************************************

FILENAME: DfrgNtfs.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

  Scan Disk and/or defragment engine for NTFS volumes.

  If Analyze is specified on the command line, this will execute an analysis of the disk.

  If Defragment is specified on the command line, this will execute an analysis of the disk
  and then defragment it.

*/

#ifndef INC_OLE2
    #define INC_OLE2
#endif

#include "stdafx.h"

#define THIS_MODULE 'N'

#define GLOBAL_DATAHOME

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <commctrl.h>
#include <winioctl.h>
#include <shlobj.h> // for SHGetSpecialFolderLocation()

#include "dfrgres.h"
#include "DataIo.h"
#include "DataIoCl.h"

extern "C" {
    #include "SysStruc.h"
}
#include "ErrMacro.h"
#include "Event.h"

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DfrgRes.h"

#include "DfrgNtfs.h"

#include "DasdRead.h"
#include "Extents.h"
#include "FreeSpace.h"
#include "FsSubs.h"
#include "MoveFile.h"
#include "NtfsSubs.h"
#include "FraggedFileList.h"

#include "Alloc.h"
#include "DiskView.h"
#include "Exclude.h"
#include "GetReg.h"
#include "GetTime.h"
#include "IntFuncs.h"
#include "Logging.h"
#include "ErrMsg.h"
#include "ErrLog.h"
#include "Expand.h"
#include "LogFile.h"
#include "GetDfrgRes.h"
extern "C" {
    #include "Priority.h"
}
#include "resource.h"
#include <atlconv.h>
#include "BootOptimizeNtfs.h"
#include "mftdefrag.h"
#include "defragcommon.h"

static UINT DiskViewInterval = 1000;    // default to 1 sec
static HANDLE hDefragCompleteEvent = NULL;

//This is set to terminate until the initialize has been successfully run.
BOOL bTerminate = TRUE;
BOOL bOCXIsDead = FALSE;

BOOL bCommandLineUsed = FALSE;
BOOL bLogFile = FALSE;
BOOL bCommandLineMode = FALSE;
BOOL bCommandLineForceFlag = FALSE;
BOOL bCommandLineBootOptimizeFlag = FALSE;


BOOL bDirtyVolume = FALSE;

LPDATAOBJECT pdataDfrgCtl = NULL;

static UINT uPass = 0;
static UINT uPercentDone = 0;
static UINT uLastPercentDone = 0;
static UINT uDefragmentPercentDone = 0;
static UINT uConsolidatePercentDone = 0;

static UINT uEngineState = DEFRAG_STATE_NONE;

TCHAR cWindow[100];

static const DISKVIEW_TIMER_ID = 1;
static const PING_TIMER_ID = 2;

DiskView AnalyzeView;
DiskView DefragView;

//
// --------------------- TABLE ALLOCATION/FREE ROUTINES ---------------------
//

/******************************************************************************

ROUTINE DESCRIPTION:
    This allocates memory of size cbSize bytes.  Note that cbSize MUST be the
    size we're expecting it to be (based on the slab-allocator initialisation), 
    since our slab allocator can only handle packets of one size.

INPUT:
    pTable - The table that the comparison is being made for (not used)
    cbSize - The count in bytes of the memory needed

RETURN:
    Pointer to allocated memory of size cbSize;  NULL if the system is out
    of memory, or cbSize is not what the slab allocator was initialised with.
    
*/
PVOID 
NTAPI 
FreeSpaceAllocateRoutine(
    IN PRTL_GENERIC_TABLE   pTable,
    IN CLONG                cbSize
    ) 
{
    PVOID pMemory = NULL;

    //
    // Sanity-check to make sure that we're being asked for packets of the 
    // "correct" size, since our slab-allocator can only deal with packets 
    // of a given size
    //
    if ((cbSize + sizeof(PVOID)) == VolData.SaFreeSpaceContext.dwPacketSize) {
        //
        // size was correct; call our allocator
        //
        pMemory = SaAllocatePacket(&VolData.SaFreeSpaceContext);
    }
    else {
        //
        // Oops, we have a problem!  
        //
        Trace(error, "Internal Error.  FreeSpaceAllocateRoutine called with "
                     "unexpected size (%lu instead of %lu).",
                     cbSize, VolData.SaFreeSpaceContext.dwPacketSize - sizeof(PVOID));
        assert(FALSE);
    } 

    return pMemory;

    UNREFERENCED_PARAMETER(pTable);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    This allocates memory of size cbSize bytes.  Note that cbSize MUST be the
    size we're expecting it to be (based on the slab-allocator initialisation), 
    since our slab allocator can only handle packets of one size.

INPUT:
    pTable - The table that the comparison is being made for (not used)
    cbSize - The count in bytes of the memory needed

RETURN:
    Pointer to allocated memory of size cbSize;  NULL if the system is out
    of memory, or cbSize is not what the slab allocator was initialised with.
    
*/
PVOID 
NTAPI 
FileEntryAllocateRoutine(
    IN PRTL_GENERIC_TABLE   pTable,
    IN CLONG                cbSize
    ) 
{
    PVOID pMemory = NULL;

    //
    // Sanity-check to make sure that we're being asked for packets of the 
    // "correct" size, since our slab-allocator can only deal with packets 
    // of a given size
    //
    if ((cbSize + sizeof(PVOID)) == VolData.SaFileEntryContext.dwPacketSize) {
        //
        // size was correct; call our allocator
        //
        pMemory = SaAllocatePacket(&VolData.SaFileEntryContext);
    }
    else {
        //
        // Oops, we have a problem!  
        //
        Trace(error, "Internal Error.  FileEntryAllocateRoutine called with "
                         "unexpected size (%lu instead of %lu).",
                 cbSize, VolData.SaFileEntryContext.dwPacketSize - sizeof(PVOID));
        assert(FALSE);
    } 

    return pMemory;

    UNREFERENCED_PARAMETER(pTable);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    This frees a packet allocated by BootOptimiseAllocateRoutine

INPUT:
    pTable -    The table that the comparison is being made for (not used)
    pvBuffer -  Pointer to the memory to be freed.  This pointer should not
                be used after this routine is called.

RETURN:
    VOID    
*/
VOID 
NTAPI 
FreeSpaceFreeRoutine(
    IN PRTL_GENERIC_TABLE pTable,
    IN PVOID              pvBuffer
    )
{
    assert(pvBuffer);
    
    SaFreePacket(&VolData.SaFreeSpaceContext, pvBuffer);

    UNREFERENCED_PARAMETER(pTable);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    This frees a packet allocated by BootOptimiseAllocateRoutine

INPUT:
    pTable -    The table that the comparison is being made for (not used)
    pvBuffer -  Pointer to the memory to be freed.  This pointer should not
                be used after this routine is called.

RETURN:
    VOID    
*/
VOID 
NTAPI 
FileEntryFreeRoutine(
    IN PRTL_GENERIC_TABLE pTable,
    IN PVOID              pvBuffer
    )
{
    assert(pvBuffer);
    
    return SaFreePacket(&VolData.SaFileEntryContext, pvBuffer);

    UNREFERENCED_PARAMETER(pTable);
}


//
// --------------------- TABLE COMPARE ROUTINES ---------------------
//
/******************************************************************************

ROUTINE DESCRIPTION:
    Comparison routine to compare the two FREE_SPACE_ENTRY records.  If
    the SortBySize flag is set to TRUE in either of the records, the comparison
    is based on the ClusterCount (with the StartingLcn as the secondary key), 
    else it is based on the StartingLcn.

INPUT:
    pTable - the table that the comparison is being made for (not used)
    pNode1 - the first FREE_SPACE_ENTRY to be compared
    pNode2 - the second FREE_SPACE_ENTRY to be compared

RETURN:
    RtlGenericLessThan      if pNode1 < pNode2
    RtlGenericGreaterThan   if pNode1 > pNode2
    RtlGenericEqual         if pNode1 == pNode2
*/
RTL_GENERIC_COMPARE_RESULTS 
NTAPI 
FreeSpaceCompareRoutine(
    PRTL_GENERIC_TABLE pTable,
    PVOID              pNode1,
    PVOID              pNode2
    )
{
    PFREE_SPACE_ENTRY pEntry1 = (PFREE_SPACE_ENTRY) pNode1;
    PFREE_SPACE_ENTRY pEntry2 = (PFREE_SPACE_ENTRY) pNode2;
    RTL_GENERIC_COMPARE_RESULTS result = GenericEqual;

    //
    // These shouldn't ever be NULL
    //
    assert(pNode1 && pNode2);


    if ((pEntry1->SortBySize) || (pEntry2->SortBySize)) {
        // 
        // If one of the nodes thinks that the table is sorted by
        // size, they better both think so!
        //
        assert(pEntry1->SortBySize && pEntry2->SortBySize);

        if (pEntry1->ClusterCount > pEntry2->ClusterCount) {
            //
            // The first node is bigger than the second
            //
            result = GenericGreaterThan;
        }
        else if (pEntry1->ClusterCount < pEntry2->ClusterCount) {
            //
            // The first node is smaller than the second
            //
            result = GenericLessThan;
        }
        else {
            //
            // Multiple freespaces may have the same length--so let's
            // use the StartingLcn as the unique key.
            // 
            if (pEntry1->StartingLcn > pEntry2->StartingLcn) {
                result = GenericGreaterThan;
            }
            else if (pEntry1->StartingLcn < pEntry2->StartingLcn) {
                result = GenericLessThan;
            }

        }
    }
    else {
        //
        // Sort by Starting LCN
        //
        if (pEntry1->StartingLcn > pEntry2->StartingLcn) {
            result = GenericGreaterThan;
        }
        else if (pEntry1->StartingLcn < pEntry2->StartingLcn) {

            result = GenericLessThan;
        }
    }

    //
    // Default is GenericEqual
    //
    return result;

    UNREFERENCED_PARAMETER(pTable);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Routine to compare two FILE_LIST_ENTRY records, based on the ClusterCount,
    with the FileRecordNumber as the secondary key.

INPUT:
    pTable - the table that the comparison is being made for (not used)
    pNode1 - the first FILE_LIST_ENTRY to be compared
    pNode2 - the second FILE_LIST_ENTRY to be compared

RETURN:
    RtlGenericLessThan      if pNode1 < pNode2
    RtlGenericGreaterThan   if pNode1 > pNode2
    RtlGenericEqual         if pNode1 == pNode2
*/

RTL_GENERIC_COMPARE_RESULTS 
NTAPI 
FileEntrySizeCompareRoutine(
    PRTL_GENERIC_TABLE pTable,
    PVOID              pNode1,
    PVOID              pNode2
    )
{
    PFILE_LIST_ENTRY pEntry1 = (PFILE_LIST_ENTRY) pNode1;
    PFILE_LIST_ENTRY pEntry2 = (PFILE_LIST_ENTRY) pNode2;
    RTL_GENERIC_COMPARE_RESULTS result = GenericEqual;

    //
    // These shouldn't ever be NULL
    //
    assert(pNode1 && pNode2);

    //
    // If the FRN is the same, this is the same record
    //
    if (pEntry1->FileRecordNumber != pEntry2->FileRecordNumber) {

        // Sort by ClusterCount
        if (pEntry1->ClusterCount < pEntry2->ClusterCount) {
            result = GenericLessThan;
        }
        else if (pEntry1->ClusterCount > pEntry2->ClusterCount) {
            result = GenericGreaterThan;
        }
        else {
            //
            // Multiple files may have the same cluster count--so let's
            // use the FileRecordNumber as the secondary key.
            // 
            if (pEntry1->FileRecordNumber > pEntry2->FileRecordNumber) {
                result = GenericGreaterThan;
            }
            else {
                result = GenericLessThan;
            }
        }
    }

    //
    // Default is GenericEqual
    //
    return result;
    
    UNREFERENCED_PARAMETER(pTable);
}

/******************************************************************************

ROUTINE DESCRIPTION:
    Comparison routine to compare the StartingLcn of two FILE_LIST_ENTRY
    records.

INPUT:
    pTable - the table that the comparison is being made for (not used)
    pNode1 - the first FILE_LIST_ENTRY to be compared
    pNode2 - the second FILE_LIST_ENTRY to be compared

RETURN:
    RtlGenericLessThan      if pNode1 < pNode2
    RtlGenericGreaterThan   if pNode1 > pNode2
    RtlGenericEqual         if pNode1 == pNode2
*/
RTL_GENERIC_COMPARE_RESULTS 
NTAPI 
FileEntryStartLcnCompareRoutine(
    PRTL_GENERIC_TABLE pTable,
    PVOID              pNode1,
    PVOID              pNode2
    )
{
    PFILE_LIST_ENTRY pEntry1 = (PFILE_LIST_ENTRY) pNode1;
    PFILE_LIST_ENTRY pEntry2 = (PFILE_LIST_ENTRY) pNode2;
    RTL_GENERIC_COMPARE_RESULTS result = GenericEqual;

    //
    // These shouldn't ever be NULL
    //
    assert(pNode1 && pNode2);

    //
    // If the FRN is the same, this is the same record
    //
    if (pEntry1->FileRecordNumber != pEntry2->FileRecordNumber) {

        //
        // FRN is different, compare based on starting LCN in REVERSE order
        //
        if (pEntry1->StartingLcn < pEntry2->StartingLcn) {
            result = GenericGreaterThan;
        }
        else if (pEntry1->StartingLcn > pEntry2->StartingLcn) {
            result = GenericLessThan;
        }
    }

    //
    // Default is GenericEqual
    //
    return result;
    
    UNREFERENCED_PARAMETER(pTable);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Comparison routine to compare the ExcessExtentCount of two FILE_LIST_ENTRY
    records, using StartingLcn as the secondary key.

INPUT:
    pTable - the table that the comparison is being made for (not used)
    pNode1 - the first FILE_LIST_ENTRY to be compared
    pNode2 - the second FILE_LIST_ENTRY to be compared

RETURN:
    RtlGenericLessThan      if pNode1 < pNode2
    RtlGenericGreaterThan   if pNode1 > pNode2
    RtlGenericEqual         if pNode1 == pNode2
*/
RTL_GENERIC_COMPARE_RESULTS 
NTAPI 
FileEntryNumFragmentsCompareRoutine(
    PRTL_GENERIC_TABLE pTable,
    PVOID              pNode1,
    PVOID              pNode2
    )
{
    PFILE_LIST_ENTRY pEntry1 = (PFILE_LIST_ENTRY) pNode1;
    PFILE_LIST_ENTRY pEntry2 = (PFILE_LIST_ENTRY) pNode2;
    RTL_GENERIC_COMPARE_RESULTS result = GenericEqual;

    //
    // These shouldn't ever be NULL
    //
    assert(pNode1 && pNode2);

    //
    // If the FRN is the same, this is the same record
    //
    if (pEntry1->FileRecordNumber != pEntry2->FileRecordNumber) {

        // 
        // FRN is different, compare based on number of fragments.  Note that
        // if the number of fragments are the same, we cannot return
        // GenericEqual (since these are different files (different FRN's)),
        // and we use the StartingLcn as the secondary key.
        //
        if (pEntry1->ExcessExtentCount > pEntry2->ExcessExtentCount) {
            result = GenericGreaterThan;
        }
        else if (pEntry1->ExcessExtentCount < pEntry2->ExcessExtentCount) {
            result = GenericLessThan;
        }
        else if (pEntry1->StartingLcn > pEntry2->StartingLcn) {
            result = GenericGreaterThan;
        }
        else {
            result = GenericLessThan;
        }
    }

    //
    // Default is GenericEqual
    //
    return result;

    UNREFERENCED_PARAMETER(pTable);
}


/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Allocates memory for the file lists.

INPUT + OUTPUT:
    fAnalyseOnly:  This flag indicates if the tree is being set up for analysis

GLOBALS:
    IN OUT VolData.NonMovableFileTable      - Nonmovable file list
    IN OUT VolData.FragmentedFileTable      - Fragmented file list
    IN OUT VolData.CongituousFileTable      - Congituous file list

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
AllocateFileLists(
    IN CONST BOOL fAnalyseOnly
    )
{
    PVOID pTableContext = NULL;

    Trace(log, "Initializing file tables for %s", (fAnalyseOnly ? "analysis" : "defragmentation"));

    if (!SaInitialiseContext(&VolData.SaFileEntryContext, sizeof(FILE_LIST_ENTRY), 64*1024)) {
        return FALSE;
    }

    if (fAnalyseOnly) {
        //
        // Analyse only:  Set up the AVL tree that will hold the fragmented file list
        // Note that we sort here by NumFragments
        //

        pTableContext = NULL;
        RtlInitializeGenericTable(&VolData.FragmentedFileTable,
           FileEntryNumFragmentsCompareRoutine,
           FileEntryAllocateRoutine,
           FileEntryFreeRoutine,
           pTableContext);

    }
    else {
        if (!SaInitialiseContext(&VolData.SaFreeSpaceContext, sizeof(FREE_SPACE_ENTRY), 64*1024)) {
            return FALSE;
        }

        //
        // Set up the AVL tree that will hold the non-movable file list
        //
        Trace(log, "Initializing file tables ");
        RtlInitializeGenericTable(&VolData.NonMovableFileTable,
           FileEntryStartLcnCompareRoutine,
           FileEntryAllocateRoutine,
           FileEntryFreeRoutine,
           pTableContext);

        //
        // Set up the AVL tree that will hold the fragmented file list
        //
        pTableContext = NULL;
        RtlInitializeGenericTable(&VolData.FragmentedFileTable,
           FileEntrySizeCompareRoutine,
           FileEntryAllocateRoutine,
           FileEntryFreeRoutine,
           pTableContext);

        //
        // Set up the AVL tree that will hold the contiguous file list
        //
        pTableContext = NULL;
        RtlInitializeGenericTable(&VolData.ContiguousFileTable,
           FileEntryStartLcnCompareRoutine,
           FileEntryAllocateRoutine,
           FileEntryFreeRoutine,
           pTableContext);

        //
        // Finally, set up the AVL tree that will hold the free-space list
        //
        pTableContext = NULL;
        RtlInitializeGenericTable(&VolData.FreeSpaceTable,
           FreeSpaceCompareRoutine,
           FreeSpaceAllocateRoutine,
           FreeSpaceFreeRoutine,
           pTableContext);

    }

    return TRUE;
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Routine to allocate the multiple free-space lists, that are sorted by
    StartingLcn (but grouped by size).
    
INPUT+OUTPUT:
    VolData.MultipleFreeSpaceTrees

RETURN:
    Void
*/
BOOL
AllocateFreeSpaceListsWithMultipleTrees() 
{
    DWORD dwTableIndex = 0;
    PVOID pTableContext = NULL;

    // Initialise the tables
    do {
        pTableContext = NULL;
        RtlInitializeGenericTable(&(VolData.MultipleFreeSpaceTrees[dwTableIndex]),
           FreeSpaceCompareRoutine,
           FreeSpaceAllocateRoutine,
           FreeSpaceFreeRoutine,
           pTableContext); 
        
    } while (++dwTableIndex < 10);

    return TRUE;
}

/******************************************************************************

ROUTINE DESCRIPTION:
    Routine to clear VolData.FreeSpaceTable.
    
INPUT+OUTPUT:
    VolData.FreeSpaceTable

RETURN:
    Void
*/
VOID
ClearFreeSpaceTable()
{
    PVOID pTableContext = NULL;

    // Release all references to allocated memory
    VolData.pFreeSpaceEntry = NULL;

    // Re-initialise the table
    RtlInitializeGenericTable(&VolData.FreeSpaceTable,
       FreeSpaceCompareRoutine,
       FreeSpaceAllocateRoutine,
       FreeSpaceFreeRoutine,
       pTableContext);

    // And free the allocated memory
    SaFreeAllPackets(&VolData.SaFreeSpaceContext);
}


/******************************************************************************

ROUTINE DESCRIPTION:
    Routine to clear VolData.MultipleFreeSpaceTrees.
    
INPUT+OUTPUT:
    VolData.MultipleFreeSpaceTrees

RETURN:
    Void
*/
VOID
ClearFreeSpaceListWithMultipleTrees()
{
    DWORD dwTableIndex = 0;
    PVOID pTableContext = NULL;

    // Release all references to allocated memory
    VolData.pFreeSpaceEntry = NULL;

    // Re-initialise each of the tables
    do {
        pTableContext = NULL;
        RtlInitializeGenericTable(&(VolData.MultipleFreeSpaceTrees[dwTableIndex]),
           FreeSpaceCompareRoutine,
           FreeSpaceAllocateRoutine,
           FreeSpaceFreeRoutine,
           pTableContext);

    } while (++dwTableIndex < 10);

    // And free the allocated memory
    SaFreeAllPackets(&VolData.SaFreeSpaceContext);
}



/*******************************************************************************

ROUTINE DESCRIPTION:
    This is the WinMain function for the NTFS defragmention engine.

INPUT + OUTPUT:
    IN hInstance - The handle to this instance.
    IN hPrevInstance - The handle to the previous instance.
    IN lpCmdLine - The command line which was passed in.
    IN nCmdShow - Whether the window should be minimized or not.

GLOBALS:
    OUT AnalyzeOrDefrag - Tells whether were supposed to to an analyze or an 
        analyze and a defrag.
    OUT VolData.cDrive - The drive letter with a colon after it.

RETURN:
    FALSE - Failure to initilize.
    other - Various values can return at exit.
*/

int APIENTRY
WinMain(
    IN  HINSTANCE hInstance,
    IN  HINSTANCE hPrevInstance,
    IN  LPSTR lpCmdLine,
    IN  int nCmdShow
    )
{
    WNDCLASS    wc;
    MSG         Message;
    HRESULT     hr = E_FAIL;

    //0.0E00 Before we start using VolData, zero it out.
    ZeroMemory(&VolData, sizeof(VOL_DATA));
    CoInitializeEx(NULL, COINIT_MULTITHREADED);

/*  
    Commenting this call out to minimise registry changes for XP SP 1.

    // Initialize COM security
    hr = CoInitializeSecurity(
           (PVOID)&CLSID_DfrgNtfs,              //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,       //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           (EOAC_SECURE_REFS | EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL | EOAC_APPID),
           NULL                                 //  IN void                        *pReserved3
           );                            
    if(FAILED(hr)) {
        return 0;
    }
*/

    // get the Instance to the resource DLL
    // error text is from the local resources
    if (GetDfrgResHandle() == NULL){
        //took out the display error message stuff from here because we needed to
        //not display error dialogs for the commandline, but here is the problem...
        //we have not got the information from InitializeDrive yet, so we don't 
        //know what mode we are in, so we can't either write to a log or display
        //a message box.  The likelyhood that this call will fail is very small, so
        //not doing anything is not a problem.  One other problem exist here that 
        //I am not even going to try and solve, and that is when this call fails,
        //since the COM server is not set up correctly, we go off into never never
        //land and cause a server busy dialog to be displayed by the system, not
        //from defrag. Scott K. Sipe
        return FALSE;
    }

    OSVERSIONINFO   Ver;

    //This should only work on version 5 or later.  Do a check.
    Ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    EF(GetVersionEx(&Ver));
    if(Ver.dwMajorVersion < 5){
        //took out the display error message stuff from here because we needed to
        //not display error dialogs for the commandline, but here is the problem...
        //we have not got the information from InitializeDrive yet, so we don't 
        //know what mode we are in, so we can't either write to a log or display
        //a message box.  The likelyhood that this call will fail is very small, so
        //not doing anything is not a problem.  One other problem exist here that 
        //I am not even going to try and solve, and that is when this call fails,
        //since the COM server is not set up correctly, we go off into never never
        //land and cause a server busy dialog to be displayed by the system, not
        //from defrag. Scott K. Sipe
        return FALSE;
    }

    //0.0E00 Build the window name from the drive letter.
    wcscpy(cWindow, DFRGNTFS_WINDOW);

    //0.0E00 Initialize the window class.
    wc.style = CS_OWNDC;
    wc.lpfnWndProc = (WNDPROC) MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(PVOID);
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = DFRGNTFS_CLASS;


    //0.0E00 Register the window class.
    if(!RegisterClass(&wc)){
        //took out the display error message stuff from here because we needed to
        //not display error dialogs for the commandline, but here is the problem...
        //we have not got the information from InitializeDrive yet, so we don't 
        //know what mode we are in, so we can't either write to a log or display
        //a message box.  The likelyhood that this call will fail is very small, so
        //not doing anything is not a problem.  One other problem exist here that 
        //I am not even going to try and solve, and that is when this call fails,
        //since the COM server is not set up correctly, we go off into never never
        //land and cause a server busy dialog to be displayed by the system, not
        //from defrag. Scott K. Sipe
        return FALSE;
    }

    //0.0E00 Create the window.
    if((hwndMain = CreateWindow(DFRGNTFS_CLASS,
                                cWindow,
                                WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL | WS_MINIMIZE,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                NULL,
                                NULL,
                                hInstance,
                                (LPVOID)IntToPtr(NULL))) == NULL){

        //took out the display error message stuff from here because we needed to
        //not display error dialogs for the commandline, but here is the problem...
        //we have not got the information from InitializeDrive yet, so we don't 
        //know what mode we are in, so we can't either write to a log or display
        //a message box.  The likelyhood that this call will fail is very small, so
        //not doing anything is not a problem.  One other problem exist here that 
        //I am not even going to try and solve, and that is when this call fails,
        //since the COM server is not set up correctly, we go off into never never
        //land and cause a server busy dialog to be displayed by the system, not
        //from defrag. Scott K. Sipe

        return FALSE;
    }

    //0.0E00 PostMessage for ID_INITALIZE which will get data about the volume, etc.
    SendMessage (hwndMain, WM_COMMAND, ID_INITIALIZE, 0);

    //0.0E00 Pass any posted messages on to MainWndProc.
    while(GetMessage(&Message, NULL, 0, 0)){
        TranslateMessage(&Message);
        DispatchMessage(&Message);
    }
    return (int) Message.wParam;
}


/*******************************************************************************

ROUTINE DESCRIPTION:
    This module carries out all initialization before the Analyze or Defrag 
    threads start.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/
BOOL
Initialize(
    )
{
    //0.0E00 Initialize a message window.
    InitCommonControls();

    // Initialize DCOM DataIo communication.
    InitializeDataIo(CLSID_DfrgNtfs, REGCLS_SINGLEUSE);

    return TRUE;
}


/*******************************************************************************

ROUTINE DESCRIPTION:
    Sends the status data (including percent complete and file being processed)
    to the GUI.

INPUT + OUTPUT:
    None

GLOBALS:
    This routine uses the following globals:
        uPass
        uPercentDone
        uEngineState
        
        VolData.cVolumeName
        VolData.vFileName

RETURN:
    None.
*/
VOID
SendStatusData(
    )
{
    STATUS_DATA statusData = {0};

    if (uPercentDone < uLastPercentDone) {
        uPercentDone = uLastPercentDone;
    }

    uLastPercentDone = uPercentDone;

    statusData.dwPass = uPass;
    statusData.dwPercentDone = (uPercentDone > 100 ? 100 : uPercentDone);
    statusData.dwEngineState = uEngineState;

    //pStatusData->cDrive = VolData.cDrive[0];
    _tcsncpy(statusData.cVolumeName, VolData.cVolumeName,GUID_LENGTH);

    if(VolData.vFileName.GetLength() > 0)
    {
        _tcsncpy(statusData.vsFileName, VolData.vFileName.GetBuffer(),200);
    }


    //If the gui is connected, send gui data to it.
    DataIoClientSetData(ID_STATUS, (TCHAR*)&statusData, sizeof(STATUS_DATA), pdataDfrgCtl);
}


/*******************************************************************************

ROUTINE DESCRIPTION:
    This is the WndProc function for the NTFS defragmentaion engine.

GLOBALS:
    IN AnalyzeOrDefrag  - Holds a define for whether the current run is an 
        analysis or defragmentation run.
    hThread             - Handle to the worker thread (either analyze or defrag).

INPUT:
    hWnd - Handle to the window.
    uMsg - The message.
    wParam - The word parameter for the message.
    lParam - the long parameter for the message.

RETURN:
    various.
*/
LRESULT CALLBACK
MainWndProc(
    IN  HWND hWnd,
    IN  UINT uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    DATA_IO* pDataIo;

    switch(uMsg) {

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case ID_INIT_VOLUME_COMM:
        {
            USES_CONVERSION;
            CLSID clsidVolume;
            HRESULT hr = E_FAIL;

            //
            // Get the volume comm id out of the given data.
            //
            pDataIo = (DATA_IO*) GlobalLock((void*)lParam);
            if (!pDataIo) {
                LOG_ERR();
                assert(FALSE);
                break;
            }
            hr = CLSIDFromString(T2OLE((PTCHAR)&pDataIo->cData), &clsidVolume);

            if (FAILED(hr)) {
                LOG_ERR();
                assert(FALSE);
                break;
            }

            //
            // Initialize the upstream communication given the
            // guid.
            //
            InitializeDataIoClient(clsidVolume, NULL, &pdataDfrgCtl);
            break;
        }

        case ID_INITIALIZE:
        {
            Initialize();

#ifdef CMDLINE
#pragma message ("Information: CMDLINE defined.")

            //0.0E00 Get the command line passed in.
            PTCHAR pCommandLine = GetCommandLine();

            // if "-Embed..." is NOT found in the string, then this was a command line
            // submitted by the user and NOT by the OCX.  Package it up and send it to the
            // message pump.  If -Embed was found, the OCX will send the command line in
            // a ID_INITIALIZE_DRIVE message.
            if (_tcsstr(pCommandLine, TEXT("-Embed")) == NULL){

                HANDLE hCommandLine = NULL;
                DATA_IO* pCmdLine = NULL;
                //If this is not called by the MMC, use the command line typed in from the DOS window.
                bCommandLineUsed = TRUE;
                AllocateMemory((lstrlen(pCommandLine)+1)*sizeof(TCHAR)+sizeof(DATA_IO), &hCommandLine, (void**)&pCmdLine);
                EB(hCommandLine);
                lstrcpy(&pCmdLine->cData, pCommandLine);
                GlobalUnlock(hCommandLine);
                PostMessage(hWnd, WM_COMMAND, ID_INITIALIZE_DRIVE, (LPARAM)hCommandLine);
            }
#else
#pragma message ("Information: CMDLINE not defined.")

            //0.0E00 Get the command line passed in.
            PTCHAR pCommandLine = GetCommandLine();

            // if "-Embed..." is NOT found in the string, then this was a command line
            // submitted by the user and NOT by the OCX and that is not supported.
            // Raise an error dialog and send an ABORT to the engine
            if (_tcsstr(pCommandLine, TEXT("-Embed")) == NULL){
                VString msg(IDS_CMD_LINE_OFF, GetDfrgResHandle());
                VString title(IDS_DK_TITLE, GetDfrgResHandle());
                if (msg.IsEmpty() == FALSE) {
                    MessageBox(NULL, msg.GetBuffer(), title.GetBuffer(), MB_OK|MB_ICONSTOP);
                }
                PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);
            }
#endif
            break;
        }

        case ID_INITIALIZE_DRIVE:

            Trace(log, "Received ID_INITIALIZE_DRIVE");
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);

            if(!InitializeDrive((PTCHAR)&pDataIo->cData)){

                //0.0E00 If initialize failed, pop up a message box, log an abort, and trigger an abort.
                //IDS_SCANNTFS_INIT_ABORT - "ScanNTFS: Initialize Aborted - Fatal Error"
                VString msg(IDS_SCANNTFS_INIT_ABORT, GetDfrgResHandle());
                SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

                //0.0E00 Log an abort in the event log.
                LogEvent(MSG_ENGINE_ERROR, msg.GetBuffer());

                //0.0E00 Trigger an abort.
                PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

                // set the event to signaled, allowing the UI to proceed
                if (hDefragCompleteEvent){
                    SetEvent(hDefragCompleteEvent);
                }
            }
            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;

        case ID_ANALYZE:
            //0.0E00 Create an analyze thread.
            {
                DWORD ThreadId;
                hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)AnalyzeThread,
                    NULL,
                    0,
                    &ThreadId);
                if (NULL == hThread) {
                    LOG_ERR();
                    assert(FALSE);
                    break;
                }
                    
            }
            break;

        case ID_DEFRAG:
            //0.0E00 Create a defrag thread.
            {
                DWORD ThreadId;
                hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)DefragThread,
                    NULL,
                    0,
                    &ThreadId);

                if (NULL == hThread) {
                    LOG_ERR();
                    assert(FALSE);
                    break;
                }
            }
            break;

        case ID_STOP:
        {
            Trace(log, "Received ID_STOP");
            //Tell the worker thread to terminate.
            VolData.EngineState = TERMINATE;

            //Send status data to the UI.
            SendStatusData();
            break;
        }

        case ID_PAUSE_ON_SNAPSHOT:
        {
#ifndef NOTIMER
            KillTimer(hwndMain, PING_TIMER_ID);
#endif
            NOT_DATA NotData;
            wcscpy(NotData.cVolumeName, VolData.cVolumeName);

            Trace(log, "Received ID_PAUSE_ON_SNAPSHOT");
            VolData.EngineState = PAUSED;

            // Tell the UI we've paused.
            DataIoClientSetData(
                ID_PAUSE_ON_SNAPSHOT, 
                (PTCHAR)&NotData, 
                sizeof(NOT_DATA), 
                pdataDfrgCtl
                );
            
            break;
        }

        case ID_PAUSE:
        {
#ifndef NOTIMER
            KillTimer(hwndMain, PING_TIMER_ID);
#endif
            NOT_DATA NotData;
            wcscpy(NotData.cVolumeName, VolData.cVolumeName);

            Trace(log, "Received ID_PAUSE");
            VolData.EngineState = PAUSED;

            // Tell the UI we've paused.
            DataIoClientSetData(
                ID_PAUSE, 
                (PTCHAR)&NotData, 
                sizeof(NOT_DATA), 
                pdataDfrgCtl
                );
            
            break;
        }

        case ID_CONTINUE:
        {
#ifndef NOTIMER
            EF_ASSERT(SetTimer(hwndMain, PING_TIMER_ID, PINGTIMER, NULL) != 0);
#endif
            NOT_DATA NotData;
            wcscpy(NotData.cVolumeName, VolData.cVolumeName);

            Trace(log, "Received ID_CONTINUE");
            VolData.EngineState = RUNNING;

            //Tell the UI we've continued.
            DataIoClientSetData(
                ID_CONTINUE, 
                (PTCHAR)&NotData, 
                sizeof(NOT_DATA), 
                pdataDfrgCtl
                );
            
            break;
        }

        case ID_ABORT_ON_SNAPSHOT:
            
                if (hDefragCompleteEvent){
                    SetEvent(hDefragCompleteEvent);
                }
                // fall through;
                
        case ID_ABORT:
        {
            Trace(log, "Received ID_ABORT");
            pDataIo = (DATA_IO*)GlobalLock((HANDLE)lParam);
            if (pDataIo){
                bOCXIsDead = *(BOOL *) &pDataIo->cData;
            }
            //0.0E00 Terminate this engine.
            bTerminate = TRUE;
            VolData.EngineState = TERMINATE;
            PostMessage(hwndMain, WM_CLOSE, 0, 0);
            if (pDataIo) {
                EH_ASSERT(GlobalUnlock((HANDLE)lParam) == FALSE);
                EH_ASSERT(GlobalFree((HANDLE)lParam) == NULL);
            }
            break;
        }

        case ID_PING:
            // 
            // Do nothing.  This is just a ping sent by the UI to make sure the 
            // engine is still up.
            //
            break;

        case ID_SETDISPDIMENSIONS:
        {
            pDataIo = (DATA_IO*)GlobalLock((HANDLE)lParam);
            BOOL bSendData = TRUE;

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize == sizeof(SET_DISP_DATA));
            SET_DISP_DATA *pSetDispData = (SET_DISP_DATA *) &pDataIo->cData;

            AnalyzeView.SetNumLines(pSetDispData->AnalyzeLineCount);

            if ((pSetDispData->bSendGraphicsUpdate == FALSE) && 
                (AnalyzeView.IsDataSent() == TRUE)) {
                bSendData = FALSE;
            }

            DefragView.SetNumLines(pSetDispData->DefragLineCount);

            if ((pSetDispData->bSendGraphicsUpdate == FALSE) && 
                (DefragView.IsDataSent() == TRUE)) {
                bSendData = FALSE;
            }

            EH_ASSERT(GlobalUnlock((HANDLE)lParam) == FALSE);
            EH_ASSERT(GlobalFree((HANDLE)lParam) == NULL);

            // if the UI wants a graphics update, send data
            if (bSendData) {
                SendGraphicsData();
            }
            break;
        }

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
        }
        break;

    case WM_TIMER:{
        //
        // If we're running on battery power, make sure it isn't low, critical
        // or unknown
        //
        SYSTEM_POWER_STATUS SystemPowerStatus;
        if ( GetSystemPowerStatus(&SystemPowerStatus) ){
            if ((STATUS_AC_POWER_OFFLINE == SystemPowerStatus.ACLineStatus) &&
                ((STATUS_BATTERY_POWER_LOW & SystemPowerStatus.BatteryFlag)  ||
                 (STATUS_BATTERY_POWER_CRITICAL & SystemPowerStatus.BatteryFlag)
                )) {
                // abort all engines
                TCHAR buf[256];
                TCHAR buf2[256];
                UINT buflen = 0;
                DWORD_PTR     dwParams[1];

                PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

                dwParams[0] = (DWORD_PTR) VolData.cDisplayLabel;
                LoadString(GetDfrgResHandle(), IDS_APM_FAILED_ENGINE, buf, sizeof(buf) / sizeof(TCHAR));
                if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                    buf, 0, 0, buf2, 256, (va_list*) dwParams)) {
                    break;
                }

                SendErrData(buf2, ENGERR_GENERAL);
            }
        } 
        if(wParam == DISKVIEW_TIMER_ID){ // graphics data

                // Update the DiskView.
                SendGraphicsData();

            }
            else if(wParam == PING_TIMER_ID && !bCommandLineUsed){
#ifndef NOTIMER
                NOT_DATA NotData;
                wcscpy(NotData.cVolumeName, VolData.cVolumeName);

                // Kill the timer until it's been processed so we don't get a backlog of timers.
                KillTimer(hwndMain, PING_TIMER_ID);

                // Ping the UI.
                if(!DataIoClientSetData(ID_PING, (PTCHAR)&NotData, sizeof(NOT_DATA), pdataDfrgCtl)){
                    //If the UI isn't there, abort.
                    PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);
                    break;
                }
                // Set the timer for the next ping.
                EF_ASSERT(SetTimer(hwndMain, PING_TIMER_ID, PINGTIMER, NULL) != 0);
#endif
        }
        break;
        }

    case WM_CLOSE:
        {
        END_SCAN_DATA EndScanData = {0};
        NOT_DATA NotData;

        wcscpy(EndScanData.cVolumeName, VolData.cVolumeName);

        EndScanData.dwAnalyzeOrDefrag = AnalyzeOrDefrag;

        if (VolData.bFragmented) {
            EndScanData.dwAnalyzeOrDefrag |= DEFRAG_FAILED;
        }

        wcscpy(EndScanData.cFileSystem, TEXT("NTFS"));

        //0.0E00 Cleanup and nuke the window.
        if(bMessageWindowActive && !bCommandLineUsed){
            if(!bTerminate){
                //Tell the gui that the analyze and/or defrag are done.
                DataIoClientSetData(
                    ID_END_SCAN, 
                    (PTCHAR)&EndScanData, 
                    sizeof(END_SCAN_DATA), 
                    pdataDfrgCtl
                    );
                break;
            }
        }

        wcscpy(NotData.cVolumeName, VolData.cVolumeName);

        //Tell the gui that the engine is terminating.
        if (!bOCXIsDead){
            DataIoClientSetData(
                ID_TERMINATING, 
                (PTCHAR)&NotData, 
                sizeof(NOT_DATA), 
                pdataDfrgCtl
                );
        }

        Exit();
        DestroyWindow(hWnd);
        break;
        }

    case WM_DESTROY:
        //0.0E00 Nuke the thread.

        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return 0;
}


/*****************************************************************************************************************

ROUTINE DESCRIPTION:
    This module carries out all initialization before the Analyze or Defrag threads start.

INPUT + OUTPUT:
    None.

GLOBALS:
    OUT hPageFileNames  - Handle to the memory used to hold the names of all the pagefiles active on this drive.
    OUT pPageFileNames  - The pointer.

    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
InitializeDrive(
    IN PTCHAR pCommandLine
    )
{
    UCHAR* pUchar = NULL;
    DWORD dwComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    TCHAR cLoggerIdentifier[256];
    TCHAR pParam0[100];             //NTFS or FAT
    TCHAR pParam1[100];             //volume
    TCHAR pParam2[100];             //Defrag or Analyze
    TCHAR pParam3[100];             //UI or Command Line
    TCHAR pParam4[100];             //Force Flag or Boot Optimize Flag

    HKEY hValue = NULL;
    TCHAR cRegValue[MAX_PATH];
    DWORD dwRegValueSize = sizeof(cRegValue);
    PUCHAR pMftBitmap = NULL;
    PATTRIBUTE_RECORD_HEADER pArh;
    VOLUME_INFORMATION* pVolInfo = NULL;

    //0.0E00 Parse the command line.
    pParam0[0] = 0;
    pParam1[0] = 0;
    pParam2[0] = 0;
    pParam3[0] = 0;
    pParam4[0] = 0;

    swscanf(pCommandLine, TEXT("%99s %99s %99s %99s %99s"), pParam0, pParam1, pParam2, pParam3, pParam4);

    //check the drive specification
    // check for a x: format, sanity check on second character
    if (wcslen(pParam1) == 2 && pParam1[1] == L':'){
        _stprintf(VolData.cVolumeName, L"\\\\.\\%c:", pParam1[0]); // UNC format
        VolData.cDrive = pParam1[0];
        // Get a handle to the volume and fill in data
        EF(GetNtfsVolumeStats());
        // Format the VolData.DisplayLabel
        FormatDisplayString(VolData.cDrive, VolData.cVolumeLabel, VolData.cDisplayLabel);
        // create the tag
        _stprintf(VolData.cVolumeTag, L"%c", pParam1[0]); // the drive letter only
    }
    // check for \\.\x:\, sanity check on third character
    else if (wcslen(pParam1) == 7 && pParam1[2] == L'.'){
        wcscpy(VolData.cVolumeName, pParam1); // UNC format, copy it over
        VolData.cVolumeName[6] = (TCHAR) NULL; // get rid of trailing backslash
        VolData.cDrive = pParam1[4];
        // Get a handle to the volume and fill in data
        EF(GetNtfsVolumeStats());
        // Format the VolData.DisplayLabel
        FormatDisplayString(VolData.cDrive, VolData.cVolumeLabel, VolData.cDisplayLabel);
        // create the tag
        _stprintf(VolData.cVolumeTag, L"%c", pParam1[4]); // the drive letter only
    }
#ifndef VER4 // NT5 only:
    // check for \\?\Volume{12a926c3-3f85-11d2-aa0e-000000000000}\,
    // sanity check on third character
    else if (wcslen(pParam1) == 49 && pParam1[2] == L'?'){
        wcscpy(VolData.cVolumeName, pParam1); // GUID format, copy it over
        VolData.cVolumeName[48] = (TCHAR) NULL; // get rid of trailing backslash

        // Get a handle to the volume and fill in data
        EF(GetNtfsVolumeStats());

        VString mountPointList[MAX_MOUNT_POINTS];
        UINT  mountPointCount = 0;

        // get the drive letter
        if (!GetDriveLetterByGUID(VolData.cVolumeName, VolData.cDrive)){
            // if we didn't get a drive letter, get the mount point list
            // cause we need the list to create the DisplayLabel
            GetVolumeMountPointList(
                VolData.cVolumeName,
                mountPointList,
                mountPointCount);
        }

        // Format the VolData.DisplayLabel
        FormatDisplayString(
            VolData.cDrive,
            VolData.cVolumeLabel,
            mountPointList,
            mountPointCount,
            VolData.cDisplayLabel);

        // create the tag
        for (UINT i=0, j=0; i<wcslen(VolData.cVolumeName); i++){
            if (iswctype(VolData.cVolumeName[i],_HEX)){
                VolData.cVolumeTag[j++] = VolData.cVolumeName[i];
            }
        }
        VolData.cVolumeTag[j] = (TCHAR) NULL;
    }
#endif
    else {
        // invalid drive on command line
        VString msg(IDS_INVALID_CMDLINE_DRIVE, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    //0.1E00 If this volume is not NTFS, error out.
    if(VolData.FileSystem != FS_NTFS){
        VString msg(IDMSG_ERR_NOT_NTFS_PARTITION, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    // calculate the graphics refresh interval
    LONGLONG DiskSize = VolData.TotalClusters * VolData.BytesPerCluster;
    LONGLONG GigSize = 1024 * 1024 * 1024;

    if (DiskSize <= GigSize * 4) {
        DiskViewInterval = 2000;
    }
    else if (DiskSize <= GigSize * 20) {
        DiskViewInterval = 4000;
    }
    else if (DiskSize <= GigSize * 100) {
        DiskViewInterval = 8000;
    }
    else {
        DiskViewInterval = 32000;
    }

    //0.0E00 Get whether this is analyze or defrag from the second parameter
    if(!lstrcmpi(pParam2, TEXT("ANALYZE"))){
        AnalyzeOrDefrag = ANALYZE;
    }
    else if(!lstrcmpi(pParam2, TEXT("DEFRAG"))){
        AnalyzeOrDefrag = DEFRAG;
    }
    else{
        
        VString msg(IDS_INVALID_CMDLINE_OPERATION, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);

        Trace(error, "Invalid command line specified: Aborting");
        return FALSE;
    }

    //0.0E00 The third or fourth parameters might be set to Command Line
    // which would mean this was launched from the Command Line
    // I did the compare not case sensitive 
    if(wcslen(pParam3)){
        if(_wcsicmp(TEXT("CMDLINE"), pParam3) == 0){
        bCommandLineMode = TRUE;
        if(wcslen(pParam4)){                //Force flag check
            if(_wcsicmp(TEXT("BOOT"), pParam4) == 0){
                bCommandLineBootOptimizeFlag = TRUE;
            } else
            {
                bCommandLineBootOptimizeFlag = FALSE;
            }

            if(_wcsicmp(TEXT("FORCE"), pParam4) == 0){
                bCommandLineForceFlag = TRUE;
            } else
            {
                bCommandLineForceFlag = FALSE;
            }

        }
    } else
        {
        bCommandLineMode = FALSE;
        }
    }

    // open the event that was created by the UI.
    // this is only used for command line operation.
    // if this fails, that means there is no other process that is
    // trying to sync with the engine.
    if (bCommandLineMode) {
        hDefragCompleteEvent = OpenEvent(EVENT_ALL_ACCESS, TRUE, DEFRAG_COMPLETE_EVENT_NAME);
        if (!hDefragCompleteEvent){
            Trace(warn, "Event %ws could not be opened (%lu)", DEFRAG_COMPLETE_EVENT_NAME, GetLastError());
        }
    }


    // get the My Documents path
    TCHAR cLogPath[300];
    LPITEMIDLIST pidl ;
    // this will get the path to My Documents for the current user
    SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl);
    SHGetPathFromIDList(pidl, cLogPath);

    // initialize the log files
    TCHAR cErrLogName[300];

    // put error log in My Docs folder
    _tcscpy(cErrLogName, cLogPath);
    _tcscat(cErrLogName, TEXT("\\DfrgError.log"));
    _stprintf(cLoggerIdentifier, TEXT("DfrgNtfs on Drive %s"), VolData.cDisplayLabel);
#ifdef _DEBUG
    InitializeErrorLog(cErrLogName, cLoggerIdentifier);
#endif

    // check registry setting for the stats log
    BOOL bStatLog = FALSE;
    dwRegValueSize = sizeof(cRegValue);
    if (ERROR_SUCCESS == GetRegValue(
        &hValue,
        TEXT("SOFTWARE\\Microsoft\\Dfrg"),
        TEXT("LogFilePath"),
        cRegValue,
        &dwRegValueSize) 
        ) {
        
        RegCloseKey(hValue);
        hValue = NULL;

        // initialize the log which will be used to tell variation success status to dfrgtest.
        if (InitializeLogFile(cRegValue)){
            bLogFile = TRUE;
        }
    }
    else {
        dwRegValueSize = sizeof(cRegValue);
        if (ERROR_SUCCESS == GetRegValue(
            &hValue,
            TEXT("SOFTWARE\\Microsoft\\Dfrg"),
            TEXT("CreateLogFile"),
            cRegValue,
            &dwRegValueSize) 
            ) {
        
            RegCloseKey(hValue);
            hValue = NULL;

            if(!_tcscmp(cRegValue, TEXT("1"))) {
                bStatLog = TRUE;
            }
        }

        // if we want to log statistics to a file.
        if (bStatLog) {
            // put error log in My Docs folder
            _tcscpy(cErrLogName, cLogPath);
            _tcscat(cErrLogName, TEXT("\\DfrgNTFSStats.log"));

            // initialize the log which will be used to tell variation success status to dfrgtest.
            if (InitializeLogFile(cErrLogName)){
                bLogFile = TRUE;
            }
        }
    }

    Trace(log, "-------------------------------------------------------");
    Trace(log, "Initializing Defrag engine.  Commandline: %ws", pCommandLine);
    Trace(log, "-------------------------------------------------------");

    //0.0E00 Default to 1 frag per file
    VolData.AveFragsPerFile = 100;

    //0.0E00 Initialize event logging.
    InitLogging(TEXT("Diskeeper"));

    //Check for a dirty volume.
    if (IsVolumeDirty()) {
        bDirtyVolume = TRUE;
        DWORD_PTR dwParams[2];
        TCHAR szMsg[500];
        TCHAR cString[500];

        //0.1E00 IDMSG_DIRTY_VOLUME - "The de-fragmentation utility has detected that drive %s is slated to have chkdsk run:  Please run chkdsk /f"
        dwParams[0] = (DWORD_PTR) VolData.cDisplayLabel;
        dwParams[1] = 0;

        if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    GetString(szMsg, sizeof(szMsg)/sizeof(TCHAR), IDMSG_DIRTY_VOLUME, GetDfrgResHandle()),
                    0,
                    0,
                    cString,
                    sizeof(cString)/sizeof(TCHAR),
                    (va_list*)dwParams)) {
            SendErrData(NULL, ENGERR_SYSTEM);
        }
        else {
            SendErrData(cString, ENGERR_SYSTEM);
        }

        // set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        //Abort the analyze/defrag.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);
        return TRUE;
    }

    //0.0E00 Allocate a buffer to hold a file record.
    EF(AllocateMemory((ULONG)VolData.BytesPerFRS+(ULONG)VolData.BytesPerSector, &VolData.hFileRecord, (void**)&VolData.pFileRecord));

    //0.0E00 Allocate an initial buffer to hold a file's extent list.
    VolData.ExtentListAlloced = INITIAL_EXTENT_LIST_BYTES;
    EF(AllocateMemory((DWORD)VolData.ExtentListAlloced, &VolData.hExtentList, (void**)&VolData.pExtentList));

    //0.0E00 Allocate a buffer to hold a chunk of the MFT.  We will use this in the prescan and scan.
    EF(AllocateMemory((DWORD)(MFT_BUFFER_BYTES + VolData.BytesPerSector), &VolData.hMftBuffer, (void**)&VolData.pMftBuffer));

    //0.0E00 Sector align the MFT buffer to speed up DASD reads.
    pUchar = (PUCHAR)VolData.pMftBuffer;
    //0.0E00 If any of the bits are set below the sizeof a sector (for example 512 byte sectors would be
    //0x200, or binary 100000000000.  Do a bitwise and with that number -1 (for example binary
    //011111111111).  That way, if any bits are set, this is not aligned on a sector.
    if(((DWORD_PTR)VolData.pMftBuffer & (VolData.BytesPerSector-1)) != 0){
        //0.0E00 pMftBuffer = pMftBuffer with all the lower bits cleared (as per the logic above) plus the number of bytes in a sector.
        VolData.pMftBuffer = (PFILE_RECORD_SEGMENT_HEADER)(((DWORD_PTR)pUchar&~(VolData.BytesPerSector-1))+VolData.BytesPerSector);
    }

    //0.0E00 Get the MFT bitmap and count the in use file records.
    EF(GetMftBitmap());

    //0.0E00 Get extent list for MFT & MFT2.
    EF(GetSystemsExtentList());

    //0.0E00 Save the MFT extent list for DASD scans of the MFT
    //Note that the MFT extent list hasn't got a stream header or anything except just the raw extents.
    VolData.MftSize = VolData.FileSize;
    EF(AllocateMemory((DWORD)(VolData.MftNumberOfExtents * sizeof(EXTENT_LIST)), &VolData.hMftExtentList, (void**)&VolData.pMftExtentList));
    CopyMemory(VolData.pMftExtentList, VolData.pExtentList + sizeof(STREAM_EXTENT_HEADER), (ULONG)VolData.MftNumberOfExtents * sizeof(EXTENT_LIST));

    //Do a version check on the NTFS volume.
    //Get the $VOLUME_INFORMATION FRS.
    EF((pMftBitmap = (UCHAR*)GlobalLock(VolData.hMftBitmap)) != NULL);
    VolData.FileRecordNumber = 3;
    if(!GetFrs(&VolData.FileRecordNumber, VolData.pMftExtentList, pMftBitmap, VolData.pMftBuffer, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord)){
        GlobalUnlock(VolData.hMftBitmap);
        return FALSE;
    }
    EF(VolData.FileRecordNumber == 3);

    // This gets a pointer to the correct attribute as pArh
    EF(FindAttributeByType($VOLUME_INFORMATION, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, &pArh, (ULONG)VolData.BytesPerFRS));

    GlobalUnlock(VolData.hMftBitmap);

    //0.0E00 Get pointer to the version number structure -- THIS FRS MUST BE RESIDENT PER THE FILE SYSTEM SPECIFICATION.
    pVolInfo = (VOLUME_INFORMATION*)((DWORD_PTR)pArh+pArh->Form.Resident.ValueOffset);

    //Check to make sure that this is NTFS major version 1 or 2.  3 is NTFS 5.0 which we don't support.
    if((pVolInfo->MajorVersion > 3) || (pVolInfo->MajorVersion < 1)){
        //IDS_UNSUPPORTED_NTFS_VERSION - The NTFS volume you are attempting to defrag is not a version supported by DfrgNtfs.  DfrgNtfs only supports versions of NTFS created by Windows NT 3.1 through Windows NT 5.0.
        VString msg(IDS_UNSUPPORTED_NTFS_VERSION, GetDfrgResHandle());
        SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        return FALSE;
    }

    //0.0E00 Get this computer's name.
    EF(GetComputerName((LPTSTR)VolData.NodeName, &dwComputerNameSize));

    //0.0E00 Get the pagefile names.
    // LEAVE THE DRIVE LETTER HERE - PAGEFILES CANNOT BE PUT ON A MOUNTED VOLUME
    EF(GetPagefileNames(VolData.cDrive, &hPageFileNames, &pPageFileNames));

    //1.0E00 Allocate buffer to hold the volume bitmap - don't lock
    //Header plus the number of bytes to fit the bitmap, plus one byte in case it's not an even division.
    EF_ASSERT(VolData.BitmapSize);
    EF(AllocateMemory((DWORD)(sizeof(VOLUME_BITMAP_BUFFER) + (VolData.BitmapSize / 8) + 1 + VolData.BytesPerSector),
                      &VolData.hVolumeBitmap,
                      NULL));

    //1.0E00 Load the volume bitmap.
    EF(GetVolumeBitmap());

    //0.0E00 Set the timer for updating the DiskView.
    EF_ASSERT(SetTimer(hwndMain, DISKVIEW_TIMER_ID, DiskViewInterval, NULL) != 0);

    //0.0E00 Set the timer that will ping the UI.
    // DO NOT set this timer is this is the command line version 'cause the engine will kill itself
#ifndef NOTIMER
    if (!bCommandLineMode){
        EF(SetTimer(hwndMain, PING_TIMER_ID, PINGTIMER, NULL) != 0);
    }
#endif
    //Ok don't terminate before closing the display window.
    bTerminate = FALSE;

    //Set the engine state to running.
    VolData.EngineState = RUNNING;

    //Send a message to the UI telling it that the process has started and what type of pass this is.
    ENGINE_START_DATA EngineStartData = {0};
    wcscpy(EngineStartData.cVolumeName, VolData.cVolumeName);
    EngineStartData.dwAnalyzeOrDefrag = AnalyzeOrDefrag;
    wcscpy(EngineStartData.cFileSystem, TEXT("NTFS"));
    DataIoClientSetData(ID_ENGINE_START, (PTCHAR)&EngineStartData, sizeof(ENGINE_START_DATA), pdataDfrgCtl);

    Trace(log, "Successfully finished initializing drive %ws", VolData.cDisplayLabel);

    //0.0E00 After Initialize, determine whether this is an analyze or defrag run, and start the approriate one.
    switch(AnalyzeOrDefrag){

    case ANALYZE:
        PostMessage(hwndMain, WM_COMMAND, ID_ANALYZE, 0);
        break;
    case DEFRAG:
        PostMessage(hwndMain, WM_COMMAND, ID_DEFRAG, 0);
        break;
    default:
        EF(FALSE);
    }
    return TRUE;
}
/*******************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This module carries out initialization specific to defrag before the defrag thread starts.

INPUT + OUTPUT:
    None.

GLOBALS:
    OUT bMoveDirs   - TRUE if the registry says to move directories.

    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
InitializeDefrag(
    )
{
    TCHAR       cExcludeFile[100];
    BEGIN_SCAN_INFO ScanInfo = {0};

    //1.0E00 Get the exclude list if any.

    // what is this stuff?!
    _stprintf(cExcludeFile, TEXT("Exclude%s.dat"), VolData.cVolumeTag);
    GetExcludeFile(cExcludeFile, &VolData.hExcludeList);

    // Copy the analyze cluster array (DiskView class)
    DefragView = AnalyzeView;
    SendGraphicsData();

    wcscpy(ScanInfo.cVolumeName, VolData.cVolumeName);
    wcscpy(ScanInfo.cFileSystem, TEXT("NTFS"));
    //The defrag fields will equal zero since the structure is zero memoried above.  This means we're not sending defrag data.
    // Tell the UI that we're beginning the scan.
    DataIoClientSetData(ID_BEGIN_SCAN, (PTCHAR)&ScanInfo, sizeof(BEGIN_SCAN_INFO), pdataDfrgCtl);

    return TRUE;
}


/*******************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Do the scan of the volume, filling in the file lists with the extent data for each file on the volume.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
ScanNtfs(
    IN CONST BOOL fAnalyseOnly
    )
{
    UCHAR*      pMftBitmap = NULL;
    UCHAR*      pUchar = NULL;

    BOOL        bResult = FALSE;

    BOOL        bBootOptimise = FALSE;
    UINT        uPercentDonePrevious = 0;
    ULONG       NumFiles = 0;
    ULONG       NumDirs = 0;
    ULONG       NumMoveableFiles = 0;
    LONGLONG    TotalFileRecords = VolData.TotalFileRecords;
    TCHAR                           cName[MAX_PATH+1];
    LONGLONG                        ParentFileRecordNumber;

    BEGIN_SCAN_INFO ScanInfo = {0};
    FILE_RECORD_SEGMENT_HEADER* pFileRecord = 
        (FILE_RECORD_SEGMENT_HEADER*) VolData.pFileRecord;

    FILE_EXTENT_HEADER* pFileExtentHeader = 
        (FILE_EXTENT_HEADER*) VolData.pExtentList;

    Trace(log, "Start: NTFS File Scan");

    VolData.bMFTCorrupt = FALSE;

    //0.0E00 Get a pointer to the MFT bitmap
    pMftBitmap = (UCHAR*)GlobalLock(VolData.hMftBitmap);
    if (NULL == pMftBitmap) {
        LOG_ERR();
        Trace(log, "End: NTFS File Scan.  Error encountered while getting "
                   "volume MFT bitmap");
        assert(FALSE);
        return FALSE;
    }
    
    __try {

        // Create a DiskView class cluster array for this volume
        AnalyzeView.SetClusterCount((int)VolData.TotalClusters);
        AnalyzeView.SetMftZone(
            (int)VolData.MftZoneStart, 
            (int)VolData.MftZoneEnd
            );

        // Create a buffer to hold extent updates for DiskView.
        bResult = CreateExtentBuffer();
        if (!bResult) {
            LOG_ERR();
            Trace(log, "End: NTFS File Scan.  Error encountered while creating "
                       "volume extent buffer");
            return FALSE;
        }
            
        //
        // The defrag fields will equal zero since the structure is zero 
        // memoried above.  This means we're not sending defrag data.
        // Tell the UI that we're beginning the scan.
        wcscpy(ScanInfo.cVolumeName, VolData.cVolumeName);
        wcscpy(ScanInfo.cFileSystem, TEXT("NTFS"));
        DataIoClientSetData(ID_BEGIN_SCAN, 
            (PTCHAR)&ScanInfo, 
            sizeof(BEGIN_SCAN_INFO), 
            pdataDfrgCtl);

        if ((!fAnalyseOnly) && IsBootVolume(VolData.cDrive)) {
            bBootOptimise = TRUE;
        }

        if (bBootOptimise) {
            InitialiseBootOptimise(TRUE);
        }

        // Get extent list for MFT & MFT2.
        EF(GetSystemsExtentList());
        
        //
        // Add the MFT extents to the diskview.  If the MFT is greater than 
        // 2 extents, make it red, else make it blue.
        //
        if (VolData.MftNumberOfExtents > 2) {
            bResult = AddExtentsStream(FragmentColor, 
                (STREAM_EXTENT_HEADER*)VolData.pExtentList);
        } 
        else {
            bResult = AddExtentsStream(UsedSpaceColor, 
                (STREAM_EXTENT_HEADER*)VolData.pExtentList);
        }
        if (!bResult) {
            LOG_ERR();
            Trace(log, "End: NTFS File Scan.  Error encountered while adding "
                       "file extents for MFT");
            return FALSE;
        }
        
        //
        // Get the root dir's base file record
        //
        VolData.FileRecordNumber = ROOT_FILE_NAME_INDEX_NUMBER;
        bResult = GetInUseFrs(VolData.hVolume, 
            &VolData.FileRecordNumber, 
            pFileRecord,
            (ULONG)VolData.BytesPerFRS
            );
        if ((!bResult) || 
            (ROOT_FILE_NAME_INDEX_NUMBER != VolData.FileRecordNumber)
            ) {
            LOG_ERR();
            Trace(log, "End: NTFS File Scan.  Error encountered while getting "
                       "file record for root directory");
            return FALSE;
        }

        // Count the root directory as one of the directories.
        NumDirs++;

        // Check to see if it's a nonresident dir.
        if (IsNonresidentFile(DEFAULT_STREAMS, pFileRecord)) {

            // Get the root dir's extent list.
            bResult = GetExtentList(DEFAULT_STREAMS, pFileRecord);
            
            // Now add the root dir to the disk view map of disk clusters.
            if (bResult) {
                bResult = AddExtents((TRUE == VolData.bFragmented) ? 
                    FragmentColor : UsedSpaceColor);
            }

            if (!bResult) {
                LOG_ERR();
                Trace(log, "End: NTFS File Scan.  Error encountered while "
                           "processing root directory");
                return FALSE;
            }

            if (bBootOptimise) {
                if (!UpdateInBootOptimiseList() && (VolData.bInBootExcludeZone)) {
                    AddFileToListNtfs(&VolData.FilesInBootExcludeZoneTable, 
                        VolData.FileRecordNumber);
                }
            }
            
            // If it is fragmented update the appropriate statistics.
            if (TRUE == VolData.bFragmented) {

                bResult = AddFileToListNtfs(
                    &VolData.FragmentedFileTable, 
                    VolData.FileRecordNumber
                    );
                
                // Keep track of fragged statstics.
                VolData.FraggedSpace += 
                        VolData.NumberOfRealClusters * VolData.BytesPerCluster;
                VolData.NumFraggedDirs ++;
                VolData.NumExcessDirFrags += VolData.NumberOfFragments - 1;
                VolData.InitialFraggedClusters  += VolData.NumberOfRealClusters;
            }
            else {
                if (!fAnalyseOnly) {
                    bResult = AddFileToListNtfs(
                        &VolData.ContiguousFileTable, 
                        VolData.FileRecordNumber
                        );
                }
                VolData.InitialContiguousClusters += VolData.NumberOfRealClusters;
            }
        }

        // Scan the MFT for fragmented files, directories & pagefile.
        for (VolData.FileRecordNumber = FIRST_USER_FILE_NUMBER;
            VolData.FileRecordNumber < TotalFileRecords;
            VolData.FileRecordNumber ++){

            // Sleep if paused.
            while (PAUSED == VolData.EngineState) {
                Sleep(1000);
            }
            
            // Exit if the controller wants us to stop.
            if (TERMINATE == VolData.EngineState) {
                PostMessage(hwndMain, WM_CLOSE, 0, 0);
                ExitThread(0);
            }

            // Calculate the percentage of analysis
            uPercentDone = (int)(((double) VolData.FileRecordNumber /
                                  (double) TotalFileRecords)  * 100);

            if ((uPercentDone < 1) &&
                (uPercentDone != uPercentDonePrevious)) {
                uPercentDone = 1;
                SendStatusData();
            }
            if (((uPercentDone % 5) == 0) && 
                (uPercentDone != uPercentDonePrevious) &&
                (uPercentDone > 0)
                ) {
                SendStatusData();
                uPercentDonePrevious = uPercentDone;
            }
                
            // Load next in-use file record.
            bResult = GetFrs(
                &VolData.FileRecordNumber, 
                VolData.pMftExtentList,
                pMftBitmap,
                VolData.pMftBuffer, 
                pFileRecord
                );
            if (!bResult) {
                if (VolData.bMFTCorrupt) {
                    Trace(log, "End: NTFS File Scan.  MFT appears to be "
                               "corrupt");
                    return FALSE;
                }
                continue;
            }

            // Skip if we're past the end of the MFT.
            if (VolData.FileRecordNumber >= TotalFileRecords) {
                continue;
            }

            // Skip if this is a secondary file record.
            if (pFileRecord->ReferenceCount == 0) {
                continue;
            }

            // Check if this is a directory or a file.
            if (pFileRecord->Flags & FILE_FILE_NAME_INDEX_PRESENT) {
                // Count that we found a dir.
                NumDirs++;
            }
            else {
                // Count that we found a file.
                NumFiles++;
            }

            // Skip this file record if it has nothing to move.
            if (!IsNonresidentFile(DEFAULT_STREAMS, pFileRecord)) {
                continue;
            }

            // This, of course, also includes moveable directories.
            NumMoveableFiles++;

            // Get the file's extent list
            if (!GetExtentList(DEFAULT_STREAMS, pFileRecord)) {
                continue;
            }

            if ((VolData.NumberOfFragments < 1) || 
                (VolData.NumberOfClusters < 1)) {
                continue;
            }

            if (bBootOptimise) {
                if (!UpdateInBootOptimiseList() && (VolData.bInBootExcludeZone)) {
                    AddFileToListNtfs(&VolData.FilesInBootExcludeZoneTable, 
                        VolData.FileRecordNumber);
                }
            }
            
            // If this is a directory...
            if (VolData.bDirectory) {

                // Add the file to the appropriate list, and update the statistics.
                if(VolData.bFragmented == TRUE){

                    bResult = AddFileToListNtfs(
                        &VolData.FragmentedFileTable, 
                        VolData.FileRecordNumber
                        );

                    if (bResult) {
                        bResult = AddExtents(FragmentColor);
                    }
                    
                    if (!bResult) {
                        LOG_ERR();
                        Trace(log, "End: NTFS File Scan, 1.  Error encountered "
                                   "while processing directories");
                        return FALSE;
                    }
                    
                    
                    // Keep track of fragged statstics.
                    VolData.FraggedSpace += 
                        VolData.NumberOfRealClusters * VolData.BytesPerCluster;
                    VolData.NumFraggedDirs++;
                    VolData.NumExcessDirFrags += VolData.NumberOfFragments - 1;
                    VolData.InitialFraggedClusters += VolData.NumberOfRealClusters;

                }
                else {

                    if (!fAnalyseOnly) {
                        bResult = AddFileToListNtfs(
                            &VolData.ContiguousFileTable, 
                            VolData.FileRecordNumber
                            );
                    }

                    if (bResult) {
                        bResult = AddExtents(UsedSpaceColor);
                    }
                    
                    if (!bResult) {
                        LOG_ERR();
                        Trace(log, "End: NTFS File Scan, 2.  Error encountered "
                                   "while processing directories");
                        return FALSE;
                    }
                    
                    VolData.InitialContiguousClusters += VolData.NumberOfRealClusters;
                }
            }
            else { 
                // Process files

                // Keep track of the total number of files so far.
                VolData.CurrentFile++;

                // Keep track of how many bytes there are in all files we've processed.
                VolData.TotalFileSpace 
                    += VolData.NumberOfRealClusters * VolData.BytesPerCluster;
                VolData.TotalFileBytes += VolData.FileSize;

                // 
                // Check to see if it's a pagefile, and if so, record the 
                // sizeof the pagefile extents.
                //
                bResult = CheckForPagefileNtfs(
                    VolData.FileRecordNumber, 
                    pFileRecord);
                if (!bResult) {
                    LOG_ERR();
                    continue;
                }

                // 
                // VolData.pPageFile is set TRUE/FALSE from above.  If it is 
                // a pagefile, add it to the pagefile list, and put its extents 
                // into DiskView.
                //
                if (!CheckFileForExclude(TRUE) || (VolData.bPageFile)) {
                    VolData.bPageFile = FALSE;

                    // Add page files to the page file list.
                    if (!fAnalyseOnly) {
                        bResult = AddFileToListNtfs(
                            &VolData.NonMovableFileTable, 
                            VolData.FileRecordNumber
                            );
                    }
                    
                    if (bResult) {
                        // Now add the file to the disk view map 
                        bResult = AddExtents(PageFileColor);
                    }

                    if (!bResult) {
                        LOG_ERR();
                        Trace(log, "End: NTFS File Scan, 1.  Error encountered "
                                   "while processing pagefiles");
                        return FALSE;
                    }

                    // Keep track of fragged statistics.
                    if (VolData.bFragmented){
                        VolData.FraggedSpace += VolData.NumberOfRealClusters * 
                                                VolData.BytesPerCluster;
                        VolData.NumFraggedFiles++;
                        VolData.NumExcessFrags += VolData.NumberOfFragments - 1;
                        VolData.InitialFraggedClusters += VolData.NumberOfRealClusters;
                    }
                    else {
                        VolData.InitialContiguousClusters  += VolData.NumberOfRealClusters;
                    }
                }
                
                else { 
                    // This is not a pagefile

                    // Add moveable files to the moveable file list.
                    if (VolData.bFragmented){

                        bResult = AddFileToListNtfs(
                            &VolData.FragmentedFileTable, 
                            VolData.FileRecordNumber
                            );

                        if (bResult) {
                            //Now add the file to the disk view 
                            bResult = AddExtents(FragmentColor);
                        }
                        
                        if (!bResult) {
                            LOG_ERR();
                            Trace(log, "End: NTFS File Scan, 2.  Error encountered "
                                       "while processing files");
                            return FALSE;
                        }

                        //0.0E00 Keep track of fragged statistics.
                        VolData.FraggedSpace += VolData.NumberOfRealClusters * VolData.BytesPerCluster;
                        VolData.NumFraggedFiles++;
                        VolData.NumExcessFrags += VolData.NumberOfFragments - 1;
                        VolData.InitialFraggedClusters += VolData.NumberOfRealClusters;
                    }
                    else{ // not fragmented


                        if (!fAnalyseOnly) {
                            bResult = AddFileToListNtfs(
                                &VolData.ContiguousFileTable, 
                                VolData.FileRecordNumber
                                );
                        }

                        if (bResult) {
                            // Now add the file to the disk view 
                            bResult = AddExtents(UsedSpaceColor);
                        }

                        if (!bResult) {
                            LOG_ERR();
                            Trace(log, "End: NTFS File Scan, 3.  Error encountered "
                                       "while processing files");
                            return FALSE;
                        }
                        
                        VolData.InitialContiguousClusters  += VolData.NumberOfRealClusters;
                    }
                }

            }
            // update cluster array
            PurgeExtentBuffer();

        }

        //Note the total number of files on the disk for statistics purposes.
        VolData.TotalFiles = NumFiles;

        //Note the total number of dirs on the disk for statistics purposes.
        VolData.TotalDirs = NumDirs;

        //0.0E00 Keep track of the average file size.
        if(VolData.CurrentFile != 0){
            VolData.AveFileSize = VolData.TotalFileBytes / VolData.CurrentFile;
        }

        // Validate data and keep track of the percent of the disk that is fragmented.
        if (VolData.UsedSpace != 0) {
            VolData.PercentDiskFragged = 100 * VolData.FraggedSpace / VolData.UsedSpace;
        }
        else if (VolData.UsedClusters != 0 && VolData.BytesPerCluster != 0) {
            VolData.PercentDiskFragged = (100 * VolData.FraggedSpace) / 
                                         (VolData.UsedClusters * VolData.BytesPerCluster);
        }

        // Validate data and keep track of the average number of fragments per file.
        if((VolData.NumFraggedFiles != 0) && (VolData.CurrentFile != 0)) {
            VolData.AveFragsPerFile = ((VolData.NumExcessFrags + VolData.CurrentFile) * 100) / VolData.CurrentFile;
        }

        //Send status data to the UI.
        SendStatusData();

        //Send graphical data to the UI.
        SendGraphicsData();
    }

    __finally {
        //0.0E00 Free up the MFT bitmap.
        if(VolData.hMftBitmap != NULL){
            EH_ASSERT(GlobalUnlock(VolData.hMftBitmap) == FALSE);
            EH_ASSERT(GlobalFree(VolData.hMftBitmap) == NULL);
            VolData.hMftBitmap = NULL;
        }
    }

    Trace(log, "End: NTFS File Scan.  %lu Fragmented files, %lu Contiguous Files.",
        RtlNumberGenericTableElementsAvl(&VolData.FragmentedFileTable),
        RtlNumberGenericTableElementsAvl(&VolData.ContiguousFileTable)
        );

    return TRUE;
}


/*******************************************************************************

ROUTINE DESCRIPTION:
    Thread routine for analysis.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN hwndMain     - Handle to the main window.

NOTE:
    When aborting, the main thread doesn't wait for this thread to 
    clean-up.  Therefore, DO NOT have state (temp files, global events, etc)
    that need to be cleaned up anywhere in this thread.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/
BOOL
AnalyzeThread(
    )
{
    BOOL bResult = FALSE;
   
    Trace(log, "Start: Volume Analysis for %ws", VolData.cDisplayLabel);
    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    
    // Statistical info.  Get the time that the engine started.
    GetLocalTime(&VolData.StartTime);

    uPercentDone = 0;
    uEngineState = DEFRAG_STATE_ANALYZING;
    SendStatusData();
    
    // 
    // There may be files on the volume with ACLs such that even an 
    // Administrator cannot open them.  Acquire the backup privilege:  this
    // lets us bypass the ACL checks when opening files.
    //
    AcquirePrivilege(SE_BACKUP_NAME);

    // Exit if the controller wants us to stop.
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        ExitThread(0);
    }

    //
    // Initialise the file list tables.  Note that since we're only analysing,
    // we can pas in TRUE for fAnalyseOnly, which takes shortcuts to make this 
    // faster.  If this fails, we can't go any further since we need the tables.
    //
    bResult = AllocateFileLists(TRUE);
    if (!bResult) {
        LOG_ERR();
        Trace(error, "End: Volume Analysis.  Errors encountered while "
                     "allocating internal data structures.");
        return FALSE;
    }

    // 
    // Scan the MFT and build up the tables of interest.  If this fails, there
    // isn't much we can do other than abort.
    //
    bResult = ScanNtfs(TRUE);    
    if (!bResult) {
        
        //
        // If we detected any MFT corruption, put up a message asking the user
        // to run chkdsk.  Otherwise, just put up a generic failure message
        // with the last file-name we were scanning when we failed.
        //
        if (VolData.bMFTCorrupt) {
            
            DWORD_PTR dwParams[3];
            TCHAR szMsg[500];
            TCHAR cString[500];

            Trace(error, "End: Volume Analysis.  Errors encountered while "
                         "scanning the volume (MFT appears to be corrupt)");
            
            //
            // IDS_CORRUPT_MFT - "Defragmentation of %1!s! has been aborted due
            // to inconsistencies that were detected in the filesystem. Please 
            // run CHKDSK or SCANDISK on %2!s! to repair these inconsistencies, 
            // then run Disk Defragmenter again"
            //
            dwParams[0] = (DWORD_PTR) VolData.cDisplayLabel;
            dwParams[1] = (DWORD_PTR) VolData.cDisplayLabel;
            dwParams[2] = 0;

            bResult = FormatMessage(
                FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                GetString(szMsg, sizeof(szMsg)/sizeof(TCHAR), 
                    IDS_CORRUPT_MFT, GetDfrgResHandle()),
                0,
                0,
                cString,
                sizeof(cString)/sizeof(TCHAR),
                (va_list*)dwParams);

            if (!bResult) {
                SendErrData(NULL, ENGERR_CORRUPT_MFT);
            }
            else {
                SendErrData(cString, ENGERR_CORRUPT_MFT);
            }
        }
        else {
            PWSTR pszTemp = NULL;

            //
            // IDMSG_SCANNTFS_SCAN_ABORT - "ScanNTFS: Scan Aborted - Fatal 
            // Error - File:"
            //
            VString msg(IDMSG_SCANNTFS_SCAN_ABORT, GetDfrgResHandle());
            msg.AddChar(L' ');
            
            // 
            // Get the name of the last file we were scannning.  If it begins
            // with the Volume GUID (is of the form \??\Volume{GUID}\file.txt),
            // strip off the volume GUID (and put in the drive letter if 
            // possible).
            //
            GetNtfsFilePath();
            pszTemp = VolData.vFileName.GetBuffer();
            
            if (StartsWithVolumeGuid(pszTemp)) {
                
                if ((VolData.cDrive >= L'C') && (VolData.cDrive <= L'Z')) {
                    // The drive letter is valid.
                    msg.AddChar(VolData.cDrive);
                    msg.AddChar(L':');
                }

                msg += (PWSTR)(pszTemp + 48);
            }
            else {
                if (VolData.vFileName.GetBuffer()) {
                    msg += VolData.vFileName;
                }
            }

            Trace(error, "End: Volume Analysis.  Errors encountered "
                         "while scanning the volume (last file processed: %ws)",
                         VolData.vFileName.GetBuffer());

            // Send error info to client
            SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        }

        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // Set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        // There isn't much else to do
        ExitThread(0);
        return TRUE;
    }

    // Statistical info: Note the end time for that pass.
    GetLocalTime(&VolData.EndTime);

    // Log the basic statistics for this if needed.
    DisplayNtfsVolumeStats();

    // Send stuff (status, bitmap, report) to the UI
    uEngineState = DEFRAG_STATE_ANALYZED;
    uPercentDone = 100;
    SendStatusData();
    SendGraphicsData();
    SendReportData();
    
    // Send the most fragged list to the UI.
    SendMostFraggedList(TRUE);

    //
    // Now clean-up the extent buffer.  This will purge it as well, so we'll
    // have a fully up-to-date DiskView of the disk.
    //
    // (ignoring return value)
    DestroyExtentBuffer();

    // We're done, close down now.
    PostMessage(hwndMain, WM_CLOSE, 0, 0);

    // Set the event to signaled, allowing the UI to proceed
    if (hDefragCompleteEvent){
        SetEvent(hDefragCompleteEvent);
    }

    Trace(log, "End: Volume Analysis for %ws (completed successfully)", 
        VolData.cDisplayLabel);

    //0.0E00 Kill the thread.
    ExitThread(0);
    return TRUE;
}


/*******************************************************************************

ROUTINE DESCRIPTION:
    Thread routine for defragmentation.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN hwndMain     - Handle to the main window.

NOTE:
    When aborting, the main thread doesn't wait for this thread to 
    clean-up.  Therefore, DO NOT have state (temp files, global events, etc)
    that need to be cleaned up anywhere in this thread.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/
BOOL
DefragThread(
    )
{
    BOOL bResult = FALSE;
    DWORD dwLayoutErrorCode = ENG_NOERR;
    
    Trace(log, "Start: Volume Defragmentation for %ws", VolData.cDisplayLabel);
    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // Statistical info.  Get the time that the engine started.
    GetLocalTime(&VolData.StartTime);
    
    uEngineState = DEFRAG_STATE_REANALYZING;
    SendStatusData();
   
    // 
    // There may be files on the volume with ACLs such that even an 
    // Administrator cannot open them.  Acquire the backup privilege:  this
    // lets us bypass the ACL checks when opening files.
    //
    AcquirePrivilege(SE_BACKUP_NAME);

    // Exit if the controller (UI/command-line) wants us to stop.
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);

        // Set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }
        
        ExitThread(0);
    }

    //
    // Initialise the file list tables.  Note that since we're defragmenting,
    // we're passing in FALSE for fAnalyseOnly.  This will allocate all the 
    // tables we care about (instead of taking the shortcut that Analyse does).
    // 
    // If this fails, we can't go any further since we need the tables.
    //
    bResult = AllocateFileLists(FALSE);
    if (!bResult) {
        LOG_ERR();
        Trace(error, "End: Volume Defragmentation.  Errors encountered while "
                     "allocating internal data structures.");
        
        // Set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }
        return FALSE;
    }

    // 
    // Scan the MFT and build up the tables of interest.  If this fails, there
    // isn't much we can do other than abort.
    //
    bResult = ScanNtfs(FALSE);    
    if (!bResult) {

        //
        // If we detected any MFT corruption, put up a message asking the user
        // to run chkdsk.  Otherwise, just put up a generic failure message
        // with the last file-name we were scanning when we failed.
        //
        if (VolData.bMFTCorrupt) {
            
            Trace(error, "End: Volume Defragmentation.  Errors encountered "
                         "while scanning the volume (MFT appears to be "
                         "corrupt)");
            
            DWORD_PTR dwParams[3];
            TCHAR szMsg[500];
            TCHAR cString[500];

            //
            // IDS_CORRUPT_MFT - "Defragmentation of %1!s! has been aborted due
            // to inconsistencies that were detected in the filesystem. Please 
            // run CHKDSK or SCANDISK on %2!s! to repair these inconsistencies, 
            // then run Disk Defragmenter again"
            //
            dwParams[0] = (DWORD_PTR) VolData.cDisplayLabel;
            dwParams[1] = (DWORD_PTR) VolData.cDisplayLabel;
            dwParams[2] = 0;

            bResult = FormatMessage(
                FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                GetString(szMsg, sizeof(szMsg)/sizeof(TCHAR), 
                    IDS_CORRUPT_MFT, GetDfrgResHandle()),
                0,
                0,
                cString,
                sizeof(cString)/sizeof(TCHAR),
                (va_list*)dwParams);

            if (!bResult) {
                SendErrData(NULL, ENGERR_CORRUPT_MFT);
            }
            else {
                SendErrData(cString, ENGERR_CORRUPT_MFT);
            }
        }
        else {
            PWSTR pszTemp = NULL;

            //
            // IDMSG_SCANNTFS_SCAN_ABORT - "ScanNTFS: Scan Aborted - Fatal 
            // Error - File:"
            //
            VString msg(IDMSG_SCANNTFS_SCAN_ABORT, GetDfrgResHandle());
            msg.AddChar(L' ');
            
            // 
            // Get the name of the last file we were scannning.  If it begins
            // with the Volume GUID (is of the form \??\Volume{GUID}\file.txt),
            // strip off the volume GUID (and put in the drive letter if 
            // possible).
            //
            GetNtfsFilePath();
            pszTemp = VolData.vFileName.GetBuffer();
            
            if (StartsWithVolumeGuid(pszTemp)) {
                if ((VolData.cDrive >= L'C') && (VolData.cDrive <= L'Z')) {
                    //
                    // The drive letter is valid.
                    //
                    msg.AddChar(VolData.cDrive);
                    msg.AddChar(L':');
                }

                msg += (PWSTR)(pszTemp + 48);
            }
            else {
                if (VolData.vFileName.GetBuffer()) {
                    msg += VolData.vFileName;
                }
            }

            Trace(error, "End: Volume Defragmentation.  Errors encountered "
                         "while scanning the volume (last file processed: %ws)",
                         VolData.vFileName.GetBuffer());

            // send error info to client
            SendErrData(msg.GetBuffer(), ENGERR_GENERAL);
        }

        // Trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // Set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        // There isn't much else to do.
        ExitThread(0);
        return TRUE;
    }

    // Exit if the controller (UI) wants us to stop.
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        
        // Set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }
        ExitThread(0);
    }

    if (!bCommandLineBootOptimizeFlag) {
        //Send the report text data to the UI.
        SendReportData();
    }

    // 
    // More initialisation, to update the display and get the Volume bitmap.
    //
    bResult = InitializeDefrag();
    if (!bResult) {
        LOG_ERR();
        Trace(error, "End: Volume Defragmentation.  Errors encountered while "
                     "initializing defrag engine.");
        // Set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }
        return FALSE;
    }

    //
    // Optimise the files listed by the prefetcher in layout.ini.  Note that
    // we currently only do this for the boot volume.
    //
    uEngineState = DEFRAG_STATE_BOOT_OPTIMIZING;
    uLastPercentDone = 0;
    uPercentDone = 1;
    SendStatusData();

    dwLayoutErrorCode = ProcessBootOptimise();
    Trace(log, "Bootoptimize returned %lu", dwLayoutErrorCode);

    // Exit if the controller (UI) wants us to stop.
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        // Set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }
        ExitThread(0);
    }

    // If command line was boot optimize -b /b, do the boot optimise only
    if (bCommandLineBootOptimizeFlag) {
        
        // If we failed layout optimization, tell the client.
        if (ENG_NOERR != dwLayoutErrorCode) {
            SendErrData(TEXT(""), dwLayoutErrorCode);
        }
        
        // Signal the client that we are done.
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        // And we're done!
        Trace(log, "End: Volume Defragmentation.  Boot Optimize status: %lu", 
            dwLayoutErrorCode);
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);
        ExitThread(0);
        return TRUE;
        
    }


    // 
    // Defrag the MFT next.  This may help with our defragmentation perf, since
    // there will presumably be fewer seeks while we find file fragments. (Of 
    // course, it would have been better if we could have done this before 
    // ScanNtfs, but still ...)
    //
    // We don't have a separate uEngineState for MFT Defag, but it's usually
    // pretty fast.
    //
    MFTDefrag(
        VolData.hVolume, 
        VolData.BitmapSize, 
        VolData.BytesPerSector, 
        VolData.TotalClusters, 
        VolData.MftZoneStart, 
        VolData.MftZoneEnd, 
        VolData.cDrive, 
        VolData.ClustersPerFRS
        );

    //
    // Update the MFT stats after moving the MFT.  This routine fills in some
    // important VolData fields (such as TotalClusters) that we use later on;
    // a failure here is fatal.
    //
    bResult = GetNtfsVolumeStats();
    if (!bResult) {
        LOG_ERR();
        Trace(error, "End: Volume Defragmentation.  Errors encountered while "
                     "updating NTFS volume statistics.");
        return FALSE;
    }

    //
    // If this is the command-line, check to ensure that at least 15% of the 
    // volume is free (unless, of course, the user specified the /f flag).  
    // 
    // Note that we only have to do this for the command-line:  for the MMC 
    // snap-in, dfrgui appears to do this in CVolume::WarnFutility.  Isn't 
    // consistency wonderful?
    //
    if ((bCommandLineMode) && (!bCommandLineForceFlag)) {
        TCHAR         szMsg[800];

        bResult = ValidateFreeSpace(
            bCommandLineMode, 
            VolData.FreeSpace, 
            VolData.UsableFreeSpace,
            (VolData.TotalClusters * VolData.BytesPerCluster), 
            VolData.cDisplayLabel, 
            szMsg, 
            sizeof(szMsg)/sizeof(TCHAR)
            );

        if (!bResult) {
            //
            // Not enough free space.  Send the error to the client, and 
            // trigger an abort  (unlike the snap-in, the user doesn't get
            // to answer y/n in the command-line;  he has to re-run this
            // with the /f flag to get any further).
            //
            SendErrData(szMsg, ENGERR_LOW_FREESPACE);
            PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

            // set the event to signaled, allowing the UI to proceed
            if (hDefragCompleteEvent){
                SetEvent(hDefragCompleteEvent);
            }

            ExitThread(0);
            return TRUE;
        }   
    }


    //0.0E00 Defragment the Drive.
    uEngineState = DEFRAG_STATE_DEFRAGMENTING;
    uPercentDone = 3;
    SendStatusData();


    // Finally, start actually defragmenting the volume.
    uConsolidatePercentDone = 3;
    bResult = DefragNtfs();
    if (!bResult) {
        
        //
        // If we detected any MFT corruption, put up a message asking the user
        // to run chkdsk.  Otherwise, just put up a generic failure message.
        // Note that we may actually detect an MFT corruption here that the 
        // ScanNtfs part didn't, since we do more with the MFT here.
        //
        if (VolData.bMFTCorrupt) {
            
            DWORD_PTR dwParams[3];
            TCHAR szMsg[500];
            TCHAR cString[500];

            //
            // IDS_CORRUPT_MFT - "Defragmentation of %1!s! has been aborted due 
            // to inconsistencies that were detected in the filesystem. Please 
            // run CHKDSK or SCANDISK on %2!s! to repair these inconsistencies,
            // then run Disk Defragmenter again"
            //
            dwParams[0] = (DWORD_PTR) VolData.cDisplayLabel;
            dwParams[1] = (DWORD_PTR) VolData.cDisplayLabel;
            dwParams[2] = 0;

            bResult = FormatMessage(
                FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                GetString(szMsg, sizeof(szMsg)/sizeof(TCHAR), 
                    IDS_CORRUPT_MFT, GetDfrgResHandle()),
                0,
                0,
                cString,
                sizeof(cString)/sizeof(TCHAR),
                (va_list*)dwParams);

            if (!bResult) {
                SendErrData(NULL, ENGERR_CORRUPT_MFT);
            }
            else {
                SendErrData(cString, ENGERR_CORRUPT_MFT);
            }
        }

        // There isn't much we can do other than trigger an abort.
        PostMessage(hwndMain, WM_COMMAND, ID_ABORT, 0);

        // set the event to signaled, allowing the UI to proceed
        if (hDefragCompleteEvent){
            SetEvent(hDefragCompleteEvent);
        }

        ExitThread(0);
        return TRUE;
    }

    
    // Exit if the controller (UI) wants us to stop.
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        ExitThread(0);
    }

    uPercentDone = 98;
    SendStatusData();
    
    //
    // Defrag the MFT again since all our file-moves above could have 
    // potentially fragmented it again
    MFTDefrag(
        VolData.hVolume, 
        VolData.BitmapSize, 
        VolData.BytesPerSector, 
        VolData.TotalClusters, 
        VolData.MftZoneStart, 
        VolData.MftZoneEnd, 
        VolData.cDrive, 
        VolData.ClustersPerFRS
        );

    //
    // Update the MFT stats after moving the MFT. 
    //
    bResult = GetNtfsVolumeStats();
    if (!bResult) {
        LOG_ERR();
        Trace(error, "End: Volume Defragmentation.  Errors encountered while "
                     "updating final NTFS volume statistics.");
        return FALSE;
    }

    // Statistical Info: Note the end time for that pass.
    GetLocalTime(&VolData.EndTime);

    // Write the statistics to the screen AFTER defrag.
    DisplayNtfsVolumeStats();

    //
    // Now clean-up the extent buffer.  This will purge it as well, so we'll
    // have a fully up-to-date DiskView of the disk.
    //
    // (ignoring return value)
    DestroyExtentBuffer();

    //
    // Send stuff (status, bitmap, report) to the UI
    //
    uEngineState = DEFRAG_STATE_DEFRAGMENTED;
    uPercentDone = 100;
    SendStatusData();
    SendGraphicsData();
    SendReportData();

    //Send the most fragged list to the UI.
    SendMostFraggedList(FALSE);

    // All done, close down now.
    PostMessage(hwndMain, WM_CLOSE, 0, 0);

    // Set the event to signaled, allowing the UI to proceed
    if (hDefragCompleteEvent){
        SetEvent(hDefragCompleteEvent);
    }

    //Kill the thread.
    Trace(log, "End: Volume Defragmentation for %ws", VolData.cDisplayLabel);

    ExitThread(0);
    return TRUE;
}

/*******************************************************************************

ROUTINE DESCRIPTION:
    Routine that carries out the defragmentation of a drive.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
DefragmentFiles(
    IN CONST UINT uDefragmentPercentProgressFactor,
    OUT LONGLONG *pSmallestFragmentedFileSize
    )
{
    ULONGLONG uFileCount = 0;
    BOOL bAllFilesDone = TRUE,   // set to true when we're fully done
        bResult = TRUE,
        bUsePerfCounter = TRUE;
    BOOLEAN bRestart = TRUE;

    LARGE_INTEGER CurrentCounter,
        LastStatusUpdate,
        LastSnapshotCheck, 
        CounterFrequency;

    Trace(log, "Start: Defragmenting Files.  Total fragmented file count: %lu", 
        RtlNumberGenericTableElementsAvl(&VolData.FragmentedFileTable));

    *pSmallestFragmentedFileSize = 0;

    // Exit if the controller wants us to stop.
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        ExitThread(0);
    }

    // If there aren't any fragmented files, we're done
    if (0 == RtlNumberGenericTableElementsAvl(&VolData.FragmentedFileTable)) {
        Trace(log, "End: Defragmenting Files.  No fragmented files");
        return TRUE;
    }

    uPass = 1;
    SendStatusData();
    
    do {
        //
        // Let's find the size of the first (smallest) fragmented file.
        // This will allow us to skip any free space chunks that are smaller
        // than it
        //
        bResult = GetNextNtfsFile(&VolData.FragmentedFileTable, bRestart);
        bRestart = FALSE;
    } while (bResult && !VolData.bFragmented);

    bRestart = TRUE;    // Reset this, so that the enumeration below re-starts

    //
    // Now build our free space list.  This will ignore any free space chunks
    // that are smaller than VolData.NumberOfClusters clusters (which currently 
    // contains the size of the smallest fragmented file)
    //
    bResult = BuildFreeSpaceList(&VolData.FreeSpaceTable, VolData.NumberOfClusters, TRUE);
    if (!bResult) {
        // A memory allocation failed, or some other error occured
        ClearFreeSpaceTable();

        Trace(log, "End: Defragmenting Files.  Unable to build free space list");
        return FALSE;
    }

    CurrentCounter.QuadPart = 0;
    LastStatusUpdate.QuadPart = 0;
    LastSnapshotCheck.QuadPart = 0;

    //
    // Check if the performance counters are available:  we'll use this later
    // to periodically update the status line and check for snapshots
    //
    if (!QueryPerformanceFrequency(&CounterFrequency) || 
        (0 == CounterFrequency.QuadPart) || 
        !QueryPerformanceCounter(&CurrentCounter)
        ) {
        bUsePerfCounter = FALSE;
        Trace(log, "QueryPerformaceFrequency failed, will update status "
                   "line based on file count");
    }

    // 
    // This loop will break when we run out of fragmented files or freespace
    //
    while (TRUE) {

        __try {

            // Sleep if paused.
            while (PAUSED == VolData.EngineState) {
                Sleep(1000);
            }

            // Exit if the controller wants us to stop.
            if (TERMINATE == VolData.EngineState) {
                PostMessage(hwndMain, WM_CLOSE, 0, 0);
                ExitThread(0);
            }

            //
            // If we have perf counters available, we can use it to update the 
            // status line once in 4 seconds, and check for snapshots once in
            // 64 seconds.
            //
            // If perf counters are not available, we have to fall back to the 
            // old way of updating the status once every 8 files, and checking
            // for snapshots once every 128 files
            //
            ++uFileCount;
            if (bUsePerfCounter && QueryPerformanceCounter(&CurrentCounter)) {

                if ((CurrentCounter.QuadPart - LastStatusUpdate.QuadPart) > 
                        (4 * CounterFrequency.QuadPart)) {

                    uDefragmentPercentDone = 
                        (UINT) (uDefragmentPercentProgressFactor * VolData.FraggedClustersDone / VolData.InitialFraggedClusters);
                    uPercentDone = uDefragmentPercentDone + uConsolidatePercentDone;

                    LastStatusUpdate.QuadPart = CurrentCounter.QuadPart;
                    SendStatusData();

                    if ((CurrentCounter.QuadPart - LastSnapshotCheck.QuadPart) > (64 * CounterFrequency.QuadPart)) {
                        LastSnapshotCheck.QuadPart = CurrentCounter.QuadPart;
                        PauseOnVolumeSnapshot(VolData.cVolumeName);
                    }
                }
            }
            else if (uFileCount % 32) {
                uDefragmentPercentDone = 
                    (UINT) (uDefragmentPercentProgressFactor * VolData.FraggedClustersDone / VolData.InitialFraggedClusters);
                uPercentDone = uDefragmentPercentDone + uConsolidatePercentDone;
                SendStatusData();

                if (uFileCount % 128) {
                    PauseOnVolumeSnapshot(VolData.cVolumeName);
                }
            }

            //
            // Okay, find the next file to defragment.  We need the check to 
            // sure that the file returned is in fact fragmented (though we're
            // checking the fragmented table, which should theoritically
            // contain only the fragmented files to begin with) since it is
            // possible that on our previous pass, we successfully defragmented
            // a file but were unable to remove it from this table for some 
            // reason (ie UpdateTables failed).
            //
            do {
                bResult = GetNextNtfsFile(&VolData.FragmentedFileTable, bRestart);
                bRestart = FALSE;
            } while (bResult && !VolData.bFragmented);
            
            if (!bResult) {
                //
                // We're out of fragmented files
                //
                Trace(log, "End: Defragmenting Files.  Out of fragmented files");
                break;
            }

            // Get the extent list & number of fragments in the file.
            if (GetExtentList(DEFAULT_STREAMS, NULL)) {

                if (FindFreeSpace(&VolData.FreeSpaceTable, TRUE, VolData.TotalClusters)) {

                    if (VolData.NumberOfClusters > (256 * 1024 / VolData.BytesPerCluster) * 1024) {
                        //
                        // If we're going to move a huge file (>256 MB), it is 
                        // going to take a while, so make sure the status bar has the 
                        // correct file name
                        //
                        GetNtfsFilePath();
                        SendStatusData();
                    }

                    if (MoveNtfsFile()) {
                        //
                        // We moved the file.  Yay!  Let's move this file to our 
                        // ContiguousFiles tree.
                        //
                        // Ignoring return value.  If this fails, it means that
                        // we couldn't move this file to the contiguous list.  
                        // This is okay for now, we'll ignore it for now and try
                        // again the next time.
                        //
                        VolData.FraggedClustersDone += VolData.NumberOfRealClusters;
                        (void) UpdateFileTables(&VolData.FragmentedFileTable, &VolData.ContiguousFileTable);
                    }
                    else {
                        //
                        // We couldn't move this file for some reason.  It might be
                        // because what we thought was a free region isn't any longer
                        // (the user's creating new files while we're defragging?)
                        //
                        Trace(warn, "Movefile failed.  File StartingLcn:%I64d  ClusterCount:%I64d  (%lu)",
                            VolData.pFileListEntry->StartingLcn,
                            VolData.pFileListEntry->ClusterCount,
                            VolData.Status
                            );

                        if (VolData.Status == ERROR_RETRY) {
                            VolData.pFreeSpaceEntry->ClusterCount = 0;
                        }

                        bAllFilesDone = FALSE;
                    }
                }
                else {
                    //
                    // Sigh.  No free space chunk that's big enough to hold all 
                    // the extents of this file.  It's no point enumerating more
                    // files for this pass, since they'll be bigger than the 
                    // current file.  Let's bail out of here, and hope that we
                    // can consolidate some free space.
                    //
                    GetNtfsFilePath();
                    
                    Trace(log, "End: Defragmenting Files.  Not enough free space remaining for this file (%I64u clusters) (%ws)", 
                        VolData.NumberOfClusters, VolData.vFileName.GetBuffer());
                    *pSmallestFragmentedFileSize = VolData.NumberOfClusters;
                    bAllFilesDone = FALSE;
                    break;
                }
            }
            else {
                //
                // We couldn't get the extents for this file.  Ignore the 
                // file for now, and let's pick it up on our next pass.
                //
                bAllFilesDone = FALSE;
                *pSmallestFragmentedFileSize = VolData.NumberOfClusters;
            }
        }

        __finally {
            if(VolData.hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(VolData.hFile);
                VolData.hFile = INVALID_HANDLE_VALUE;
            }
            if(VolData.hFreeExtents != NULL) {
                while(GlobalUnlock(VolData.hFreeExtents))
                    ;
                EH_ASSERT(GlobalFree(VolData.hFreeExtents) == NULL);
                VolData.hFreeExtents = NULL;
            }
            // update cluster array
            PurgeExtentBuffer();
        }
    }

    ClearFreeSpaceTable();

    Trace(log, "End: Defragmenting Files.  Processed %I64d Files.  bAllFilesDone is %d", uFileCount - 1, bAllFilesDone);
    return bAllFilesDone;
}


/*******************************************************************************

ROUTINE DESCRIPTION:
    Finds a region that is the best bet for moving files out of, to free up
    one big chunk of free space.  

INPUT:
    MinimumLength - The minimum length, in clusters, that we're looking for.  If
        this routine isn't able to find a region that is at least as big, it
        will return false.

    dwDesparationFactor - A number indicating what percent of the region may be
        in-use.  If this is 10, we're looking for a region that is no
        more than 10% in-use (i.e., is 90% free), while if this is 100, we don't
        care even if the region we find is full of files at the moment.

OUTPUT:
    RegionStart - This will contain the startingLCN for the region that is the
        best bet

    RegionEnd - This contains the LCN where the interesting region ends

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - We couldn't find a region that meets our needs
*/
BOOL
FindRegionToConsolidate(
    IN CONST LONGLONG MinimumLength,
    IN CONST DWORD dwDesparationFactor,
    OUT LONGLONG *pRegionStart,
    OUT LONGLONG *pRegionEnd
    ) 
{
    BOOLEAN bRestart = TRUE;
    BOOLEAN bNewElement = FALSE;

    BOOL bResult = FALSE;
    
    PFREE_SPACE_ENTRY pFree  = NULL;
    PFILE_LIST_ENTRY pFile = NULL;

    PRTL_GENERIC_TABLE pFreeTable = &VolData.FreeSpaceTable, 
        pContiguousTable = &VolData.ContiguousFileTable;

    DWORD dwBytesInUsePercent = 0;

    LONGLONG regionLength = 0,
        regionStart = 0,
        currentLcn = 0,
        bytesInUse = 0;

    LONGLONG bestRegionStart = 0, 
        bestRegionLength = 0, 
        bestRegionBytesInUse = 0;

    LONGLONG biggestFree = 0;

    Trace(log, "Start: FindRegionToConsolidate");

    *pRegionStart = 0;
    *pRegionEnd = 0;

    //
    // First, build the free space info--sort it by start sector
    //
    bResult = BuildFreeSpaceList(&VolData.FreeSpaceTable, 0, FALSE, &biggestFree);
    if (!bResult) {
        //
        // A memory allocation failed, or some other error occured
        //
        ClearFreeSpaceTable();

        Trace(log, "End: FindRegionToConsolidate.  Unable to build free space list");
        return FALSE;
    }

    //
    // For now, start from the beginning.  
    //
    pFile = (PFILE_LIST_ENTRY) LastEntry(pContiguousTable);
    pFree = (PFREE_SPACE_ENTRY) RtlEnumerateGenericTableAvl(pFreeTable, TRUE);
    if (!pFile || !pFree) {

        Trace(log, "End: FindRegionToConsolidate (File:0x%x FreeSpace:0x%x)", pFile, pFree);
        ClearFreeSpaceTable();
        return FALSE;
    }

    //
    // Go through the contiguous files and free-space regions, to keep track
    // of the largest contiguous chunk we can find.
    //
    while (pFile && pFree) {
        currentLcn = pFree->StartingLcn;
        regionStart = currentLcn;
        bytesInUse = 0;

        while ((pFree) && (currentLcn == pFree->StartingLcn)) {

            currentLcn += (pFree->ClusterCount);

            // Get the next free-space entry
            pFree = (PFREE_SPACE_ENTRY) RtlEnumerateGenericTableAvl(pFreeTable, FALSE);

            // And go through all the contiguous files before the
            // the next free space entry
            while ((pFile) && (pFile->StartingLcn < currentLcn)) {
                pFile = (PFILE_LIST_ENTRY) PreviousEntry(pFile);
            }

            while ((pFile) && (currentLcn == pFile->StartingLcn)) {

                if (pFile->ClusterCount > biggestFree) {
                    --currentLcn;
                    break;
                }

                bytesInUse += (pFile->ClusterCount);
                currentLcn += (pFile->ClusterCount);

                pFile = (PFILE_LIST_ENTRY) PreviousEntry(pFile);
            }

        }

        if (!pFile && !pFree) {
            //
            // We reached the end of the disk
            //
            currentLcn = VolData.TotalClusters;
        }

        regionLength = currentLcn - regionStart;
        if ((bytesInUse > 0)  && (regionLength >= MinimumLength)){
                dwBytesInUsePercent = (ULONG) ((bytesInUse * 100) / (regionLength));

                // Try to find some interesting chunks. 
                if ((regionLength > biggestFree) &&
                    (regionLength > bestRegionLength) && 
                    (dwBytesInUsePercent < dwDesparationFactor)) {
                    //
                    // Okay, now, see if this is in fact better than the current chunk.
                    //

//                    if ((regionLength - bestRegionLength) > (bytesInUse - bestRegionBytesInUse) * 1) {

                        bestRegionStart = regionStart;
                        bestRegionLength = regionLength;
                        bestRegionBytesInUse = bytesInUse;
//                    }
            }
        }
    }

    ClearFreeSpaceTable();

    if (bestRegionLength > 0) {
        dwBytesInUsePercent = (ULONG) ((bestRegionBytesInUse * 100) / (bestRegionLength));

        *pRegionStart = bestRegionStart;
        *pRegionEnd = bestRegionStart + bestRegionLength;
    }

    Trace(log, "End: FindRegionToConsolidate (Region Start:%I64u Length:%I64u End:%I64u Used:%I64u(%lu%%))",
        *pRegionStart, bestRegionLength, *pRegionEnd, bestRegionBytesInUse, dwBytesInUsePercent);

    return (bestRegionLength > 0);
}



/*******************************************************************************

ROUTINE DESCRIPTION:
    This routine attempts to free up space to form one big chunk
    
GLOBALS:
    VolData

RETURN:
    TRUE - We finished defragmenting the volume successfully.
    FALSE - Some files on the volume could not be defragmented.
*/
BOOL 
ConsolidateFreeSpace(
    IN CONST LONGLONG MinimumLength,
    IN CONST DWORD dwDesparationFactor,
    IN CONST BOOL bDefragMftZone,
    IN CONST UINT uPercentProgress
    )
{
    LONGLONG MaxFreeSpaceChunkSize = VolData.TotalClusters,
        CurrentFileSize = 0,
        CurrentLcn = 0;
    
    ULONGLONG uFileCount = 0;
    
    BOOL bResult = TRUE,
        bDone = FALSE,
        bSuccess = TRUE,
        bUsePerfCounter = TRUE;

    BOOLEAN bRestart = TRUE;

    UINT iCount = 0,
        uConsolidatePercentDoneAtStart = 0;
    
    FILE_LIST_ENTRY NewFileListEntry;

    FREE_SPACE_ENTRY NewFreeSpaceEntry;

    BOOLEAN bNewElement = FALSE;
    
    PVOID p = NULL;

    PFREE_SPACE_ENTRY pFreeSpace  = NULL;

    LARGE_INTEGER CurrentCounter,
        LastStatusUpdate,
        LastSnapshotCheck,
        CounterFrequency;

    LONGLONG RegionStartLcn = 0, RegionEndLcn = VolData.TotalClusters;

    LARGE_INTEGER Test1, Test2;

    Trace(log, "Start: Consolidating free space.  Total contiguous file count: %lu", 
        RtlNumberGenericTableElementsAvl(&VolData.ContiguousFileTable));

    uPass = 2;
    uConsolidatePercentDoneAtStart = uConsolidatePercentDone;
    SendStatusData();
    
    ZeroMemory(&NewFileListEntry, sizeof(FILE_LIST_ENTRY));
    //
    // Terminate if told to stop by the controller  - 
    // this is not an error.
    //
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        return TRUE;
    }

    if (bDefragMftZone) {
        RegionStartLcn = VolData.MftZoneStart;
        RegionEndLcn = VolData.MftZoneEnd;

        if ((RegionStartLcn < VolData.BootOptimizeEndClusterExclude) &&
           (RegionEndLcn > VolData.BootOptimizeBeginClusterExclude)) {

            if(RegionStartLcn < VolData.BootOptimizeBeginClusterExclude) {
                RegionEndLcn = VolData.BootOptimizeBeginClusterExclude;
            } 
            else if(RegionEndLcn <= VolData.BootOptimizeEndClusterExclude) {
                Trace(log, "End: Consolidating free space.  MFT Zone fully within Boot-optimise zone");
                return FALSE;
            } 
            else {                  
                //0.0E00 Handle the case of EndingLcn > pVolData->bootoptZoneEnd.
                RegionStartLcn = VolData.BootOptimizeEndClusterExclude;
            }
        }
    }
    else {
        if (!FindRegionToConsolidate(MinimumLength, dwDesparationFactor, &RegionStartLcn, &RegionEndLcn)) {

            Trace(log, "End: Consolidating free space.  Unable to find a suitable region");
            return FALSE;
        }
    }

    bResult = BuildFreeSpaceListWithExclude(&VolData.FreeSpaceTable, 0, RegionStartLcn, RegionEndLcn, TRUE);
    if (!bResult) {
        //
        // A memory allocation failed, or some other error occured
        //
        ClearFreeSpaceTable();

        Trace(log, "End: Consolidating free space.  Unable to build free space list");
        return FALSE;
    }

    CurrentLcn = RegionEndLcn;

    pFreeSpace = (PFREE_SPACE_ENTRY)LastEntry(&VolData.FreeSpaceTable);
    Trace(log, "Largest Free Space : %I64u", pFreeSpace->ClusterCount);

    NewFileListEntry.FileRecordNumber = (-1);
    NewFileListEntry.StartingLcn = RegionEndLcn;

    CurrentCounter.QuadPart = 0;
    LastStatusUpdate.QuadPart = 0;
    LastSnapshotCheck.QuadPart = 0;

    //
    // Check if the performance counters are available:  we'll use this later
    // to periodically update the status line and check for snapshots
    //
    if (!QueryPerformanceFrequency(&CounterFrequency) || (0 == CounterFrequency.QuadPart) || !QueryPerformanceCounter(&CurrentCounter)) {
        Trace(log, "QueryPerformaceFrequency failed, will update status line based on file count");
        bUsePerfCounter = FALSE;
    }

    //
    //
    // Now, let's start from the end of the disk, and attempt to move 
    // the files to free spaces earlier.
    //
    while (bResult) {

        // Sleep if paused.
        while (PAUSED == VolData.EngineState) {
            Sleep(1000);
        }
        // Terminate if told to stop by the controller - this is not an error.
        if (TERMINATE == VolData.EngineState) {
            PostMessage(hwndMain, WM_CLOSE, 0, 0);
            break;
        }

        //
        // If we have perf counters available, we can use it to update the 
        // status line once in 4 seconds, and check for snapshots once in
        // 64 seconds.
        //
        // If perf counters are not available, we have to fall back to the 
        // old way of updating the status once every 8 files, and checking
        // for snapshots once every 128 files
        //
        ++uFileCount;
        if (bUsePerfCounter && QueryPerformanceCounter(&CurrentCounter)) {

            if ((uFileCount > 1) && ((CurrentCounter.QuadPart - LastStatusUpdate.QuadPart) > 
                    (4 * CounterFrequency.QuadPart))) {

                uConsolidatePercentDone = uConsolidatePercentDoneAtStart + 
                   (UINT) (((RegionStartLcn - CurrentLcn) * uPercentProgress) / (RegionEndLcn - RegionStartLcn));
                uPercentDone = uDefragmentPercentDone + uConsolidatePercentDone;

                LastStatusUpdate.QuadPart = CurrentCounter.QuadPart;
                SendStatusData();

                if ((CurrentCounter.QuadPart - LastSnapshotCheck.QuadPart) > (64 * CounterFrequency.QuadPart)) {
                    LastSnapshotCheck.QuadPart = CurrentCounter.QuadPart;
                    PauseOnVolumeSnapshot(VolData.cVolumeName);
                }
            }
        }
        else if (uFileCount % 32) {
            uConsolidatePercentDone = uConsolidatePercentDoneAtStart + 
                (UINT)(((RegionStartLcn - CurrentLcn) * uPercentProgress) / (RegionEndLcn - RegionStartLcn));
            uPercentDone = uDefragmentPercentDone + uConsolidatePercentDone;
            SendStatusData();

            if (uFileCount % 128) {
                PauseOnVolumeSnapshot(VolData.cVolumeName);
            }
        }

        //
        // Okay, find the next file to move.  Note that the first file we find will be from
        // the region of interest
        //
        bResult = GetNextNtfsFile(&VolData.ContiguousFileTable, bRestart, MaxFreeSpaceChunkSize, &NewFileListEntry);
        bRestart = FALSE;
        CurrentFileSize = VolData.NumberOfClusters;
        CurrentLcn = VolData.StartingLcn;

        if (VolData.StartingLcn < RegionStartLcn) {
            break;
        }

        if (bResult) {
            if ((VolData.pFileListEntry->Flags & FLE_BOOTOPTIMISE) &&
                (VolData.StartingLcn > VolData.BootOptimizeBeginClusterExclude) &&
                (VolData.StartingLcn < VolData.BootOptimizeEndClusterExclude)) {
                continue;
            }
        }

        if (bResult) {
            // Get the extent list & number of fragments in the file.
            if (GetExtentList(DEFAULT_STREAMS, NULL)) {

                bDone = FALSE;
                while (!bDone) {

                    bDone = TRUE;
                    if (FindSortedFreeSpace(&VolData.FreeSpaceTable)) {
                        //
                        // Found a free space chunk that was big enough.  If 
                        // it's before the file, move the file towards the 
                        // start of the disk
                        //
                        CopyMemory(&NewFreeSpaceEntry, VolData.pFreeSpaceEntry, sizeof(FREE_SPACE_ENTRY));
                        bNewElement = RtlDeleteElementGenericTable(&VolData.FreeSpaceTable, (PVOID)VolData.pFreeSpaceEntry);
                        if (!bNewElement) {
                            Trace(warn, "Could not find Element in Free Space Table!");
                            assert(FALSE);
                        }

                        VolData.pFreeSpaceEntry = &NewFreeSpaceEntry;

                        CopyMemory(&NewFileListEntry, VolData.pFileListEntry, sizeof(FILE_LIST_ENTRY));
                        bNewElement = RtlDeleteElementGenericTable(&VolData.ContiguousFileTable, (PVOID)VolData.pFileListEntry);
                        if (!bNewElement) {
                            Trace(warn, "Could not find Element in ContiguousFileTable!");
                            assert(FALSE);
                        }

                        VolData.pFileListEntry = &NewFileListEntry;

                        if (MoveNtfsFile()) {
                                NewFileListEntry.StartingLcn = VolData.pFreeSpaceEntry->StartingLcn;
                                VolData.pFreeSpaceEntry->StartingLcn += VolData.NumberOfClusters;
                                VolData.pFreeSpaceEntry->ClusterCount -= VolData.NumberOfClusters;
                        }
                        else {

                            Trace(warn, "Movefile failed.  File StartingLcn:%I64d  ClusterCount:%I64d FreeSpace StartingLcn:%I64d ClusterCount:%I64d Status:%lu",
                                VolData.pFileListEntry->StartingLcn,
                                VolData.pFileListEntry->ClusterCount,
                                VolData.pFreeSpaceEntry->StartingLcn,
                                VolData.pFreeSpaceEntry->ClusterCount,
                                VolData.Status
                                );
                            if (VolData.Status == ERROR_RETRY) {
                                VolData.pFreeSpaceEntry->ClusterCount = 0;
                                bDone = FALSE;
                            }
                            else if (bDefragMftZone) {
                                bResult = FALSE;
                                bSuccess = FALSE;
                                break;
                            }                           
                        }

                        if (VolData.pFreeSpaceEntry->ClusterCount > 0) {
                            // Add this file to the contiguous-files table
                            p = RtlInsertElementGenericTable(
                                &VolData.FreeSpaceTable,
                                (PVOID) VolData.pFreeSpaceEntry,
                                sizeof(FREE_SPACE_ENTRY),
                                &bNewElement);

                            if (!p) {
                                // An allocation failed
                                Trace(log, "End: Consolidating free space.  Unable to add back a free space to the freespace table");
                                assert(FALSE);
                                bResult = FALSE;
                                bSuccess = FALSE;
                                break;
                            };

                        }

                        // Add this file to the contiguous-files table
                        p = RtlInsertElementGenericTable(
                            &VolData.ContiguousFileTable,
                            (PVOID) VolData.pFileListEntry,
                            sizeof(FILE_LIST_ENTRY),
                            &bNewElement);

                        if (!p) {
                            // An allocation failed
                            Trace(log, "End: Consolidating free space.  Unable to add back a file to the contiguous file table");
                            assert(FALSE);
                            bResult = FALSE;
                            bSuccess = FALSE;
                            break;
                        };

                    }
                    else {
                        Trace(log, "End: Consolidating free space.  Unable to move file out Start:%I64u Length:%I64u (%lu)", 
                            VolData.StartingLcn, VolData.NumberOfClusters, iCount);
                        if ((bDefragMftZone) || (++iCount > 10)) {
                            bSuccess = FALSE;
                            bResult = FALSE;
                            break;
                        }
                    }
                }
            }
            else if (bDefragMftZone) {
                bSuccess = FALSE;
                bResult = FALSE;
            }

            if(VolData.hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(VolData.hFile);
                VolData.hFile = INVALID_HANDLE_VALUE;
            }
            if(VolData.hFreeExtents != NULL) {
                while(GlobalUnlock(VolData.hFreeExtents))
                    ;
                EH_ASSERT(GlobalFree(VolData.hFreeExtents) == NULL);
                VolData.hFreeExtents = NULL;
            }

            // update cluster array
            PurgeExtentBuffer();
        }
    }

    ClearFreeSpaceTable();
    
    Trace(log, "End: Consolidating free space.  Processed %I64u files", uFileCount - 1);
    return bSuccess;
}


/*****************************************************************************************************************

ROUTINE DESCRIPTION:
    This routine attempts to free up space at the end of the disk
    
GLOBALS:
    VolData

RETURN:
    TRUE - We finished defragmenting the volume successfully.
    FALSE - Some files on the volume could not be defragmented.
*/
BOOL 
MoveFilesForward(
    IN CONST UINT uPercentProgress
    )
{
    LONGLONG MaxFreeSpaceChunkSize = VolData.TotalClusters,
        CurrentFileSize = 0,
        CurrentLcn = VolData.TotalClusters;
    
    ULONGLONG uFileCount = 0;
    
    BOOL bResult = TRUE,
        bDone = FALSE,
        bUsePerfCounter = TRUE;

    BOOLEAN bRestart = TRUE;

    FILE_LIST_ENTRY NewFileListEntry;

    FREE_SPACE_ENTRY NewFreeSpaceEntry;

    BOOLEAN bNewElement = FALSE;
    
    PVOID p = NULL;

    PFREE_SPACE_ENTRY pFreeSpace  = NULL;

    LARGE_INTEGER CurrentCounter,
        LastStatusUpdate,
        LastSnapshotCheck,
        CounterFrequency;

    UINT uConsolidatePercentDoneAtStart = 0;

    Trace(log, "Start: Moving files forward.  Total contiguous file count: %lu  (percent done: %lu + %lu, %lu)", 
        RtlNumberGenericTableElementsAvl(&VolData.ContiguousFileTable),
        uDefragmentPercentDone,
        uConsolidatePercentDone,
        uPercentProgress);

    //
    // Terminate if told to stop by the controller  - 
    // this is not an error.
    //
    if (TERMINATE == VolData.EngineState) {
        PostMessage(hwndMain, WM_CLOSE, 0, 0);
        return TRUE;
    }

    uPass = 2;
    uConsolidatePercentDoneAtStart = uConsolidatePercentDone;
    SendStatusData();

    ZeroMemory(&NewFreeSpaceEntry, sizeof(FREE_SPACE_ENTRY));
    AllocateFreeSpaceListsWithMultipleTrees();

    //
    // First, build the free space info--sort it by start sector
    //
    bResult = BuildFreeSpaceListWithMultipleTrees(&MaxFreeSpaceChunkSize);
    if (!bResult) {
        //
        // A memory allocation failed, or some other error occured
        //
        ClearFreeSpaceListWithMultipleTrees();

        Trace(log, "End: Moving files forward.  Unable to build free space list");
        return FALSE;
    }

    CurrentCounter.QuadPart = 0;
    LastStatusUpdate.QuadPart = 0;
    LastSnapshotCheck.QuadPart = 0;

    //
    // Check if the performance counters are available:  we'll use this later
    // to periodically update the status line and check for snapshots
    //
    if (!QueryPerformanceFrequency(&CounterFrequency) || (0 == CounterFrequency.QuadPart) || !QueryPerformanceCounter(&CurrentCounter)) {
        Trace(log, "QueryPerformaceFrequency failed, will update status line based on file count");
        bUsePerfCounter = FALSE;
    }

    //
    //
    // Now, let's start from the end of the disk, and attempt to move 
    // the files to free spaces earlier.
    //
    while (bResult) {

        // Sleep if paused.
        while (PAUSED == VolData.EngineState) {
            Sleep(1000);
        }
        // Terminate if told to stop by the controller - this is not an error.
        if (TERMINATE == VolData.EngineState) {
            PostMessage(hwndMain, WM_CLOSE, 0, 0);
            break;
        }

        //
        // If we have perf counters available, we can use it to update the 
        // status line once in 4 seconds, and check for snapshots once in
        // 64 seconds.
        //
        // If perf counters are not available, we have to fall back to the 
        // old way of updating the status once every 8 files, and checking
        // for snapshots once every 128 files
        //
        ++uFileCount;
        if (bUsePerfCounter && QueryPerformanceCounter(&CurrentCounter)) {

            if ((uFileCount > 1) && ((CurrentCounter.QuadPart - LastStatusUpdate.QuadPart) > 
                    (4 * CounterFrequency.QuadPart))) {
                
                uConsolidatePercentDone = uConsolidatePercentDoneAtStart + 
                    (UINT)(((VolData.TotalClusters - CurrentLcn) * uPercentProgress) / VolData.TotalClusters);
                uPercentDone = uDefragmentPercentDone + uConsolidatePercentDone;
                
                LastStatusUpdate.QuadPart = CurrentCounter.QuadPart;
                SendStatusData();

                if ((CurrentCounter.QuadPart - LastSnapshotCheck.QuadPart) > (64 * CounterFrequency.QuadPart)) {
                    LastSnapshotCheck.QuadPart = CurrentCounter.QuadPart;
                    PauseOnVolumeSnapshot(VolData.cVolumeName);
                }
            }
        }
        else if (uFileCount % 32) {
            
            uConsolidatePercentDone = uConsolidatePercentDoneAtStart + 
                (UINT)(((VolData.TotalClusters - CurrentLcn) * uPercentProgress) / VolData.TotalClusters);
            uPercentDone = uDefragmentPercentDone + uConsolidatePercentDone;

            SendStatusData();

            if (uFileCount % 128) {
                PauseOnVolumeSnapshot(VolData.cVolumeName);
            }
        }


        
        //
        // Okay, find the next file to move
        //
        bResult = GetNextNtfsFile(&VolData.ContiguousFileTable, bRestart, MaxFreeSpaceChunkSize);
        bRestart = FALSE;
        CurrentFileSize = VolData.NumberOfClusters;
        CurrentLcn = VolData.StartingLcn;

        if (bResult) {
            if ((VolData.pFileListEntry->Flags & FLE_BOOTOPTIMISE) &&
                (VolData.StartingLcn > VolData.BootOptimizeBeginClusterExclude) &&
                (VolData.StartingLcn < VolData.BootOptimizeEndClusterExclude)) {
                continue;
            }
        }
        if (bResult) {
            
            // Get the extent list & number of fragments in the file.
            if (GetExtentList(DEFAULT_STREAMS, NULL)) {
                
                bDone = FALSE;
                while (!bDone) {
                    bDone = TRUE;
                    if (FindFreeSpaceWithMultipleTrees(VolData.NumberOfClusters, VolData.StartingLcn)) {

                        //
                        // Found a free space chunk that was big enough.  If 
                        // it's before the file, move the file towards the 
                        // start of the disk
                        //
                        CopyMemory(&NewFileListEntry, VolData.pFileListEntry, sizeof(FILE_LIST_ENTRY));
                        bNewElement = RtlDeleteElementGenericTable(&VolData.ContiguousFileTable, (PVOID)VolData.pFileListEntry);
                        if (!bNewElement) {
                            Trace(warn, "Could not find Element in ContiguousFileTable!");
                            assert(FALSE);
                        }

                        VolData.pFileListEntry = &NewFileListEntry;

                        if (MoveNtfsFile()) {
                                NewFileListEntry.StartingLcn = VolData.pFreeSpaceEntry->StartingLcn;
                                NewFreeSpaceEntry.StartingLcn = VolData.pFreeSpaceEntry->StartingLcn + VolData.NumberOfClusters;
                                NewFreeSpaceEntry.ClusterCount = VolData.pFreeSpaceEntry->ClusterCount - VolData.NumberOfClusters;
                                
                                UpdateInMultipleTrees(VolData.pFreeSpaceEntry, &NewFreeSpaceEntry);
                                VolData.pFreeSpaceEntry = NULL;
                        }
                        else {

                            Trace(warn, "Movefile failed.  File StartingLcn:%I64d  ClusterCount:%I64d FreeSpace:%I64d Len:%I64d Status:%lu",
                                VolData.pFileListEntry->StartingLcn,
                                VolData.pFileListEntry->ClusterCount,
                                VolData.pFreeSpaceEntry->StartingLcn,
                                VolData.pFreeSpaceEntry->ClusterCount,
                                VolData.Status
                                );
                            if (VolData.Status == ERROR_RETRY) {
                                NewFreeSpaceEntry.StartingLcn = VolData.pFreeSpaceEntry->StartingLcn;
                                NewFreeSpaceEntry.ClusterCount = 0;

                                UpdateInMultipleTrees(VolData.pFreeSpaceEntry, NULL);
                                VolData.pFreeSpaceEntry = NULL;
                                bDone = FALSE;
                            }
                        }

                        // Add this file to the contiguous-files table
                        p = RtlInsertElementGenericTable(
                            &VolData.ContiguousFileTable,
                            (PVOID) VolData.pFileListEntry,
                            sizeof(FILE_LIST_ENTRY),
                            &bNewElement);

                        if (!p) {
                            // An allocation failed
                            Trace(log, "End: Moving files forward.  Unable to add back a file to the contiguous file table");
                            return FALSE;
                        };

                    }
                    else {
                        //
                        // No free space before this file that's big enough 
                        // to hold this file.  This implies that the biggest
                        // free space chunk before this file is smaller than
                        // this file--so we should skip trying to find a 
                        // free space chunk for any file that's bigger than 
                        // this file before this file.
                        //
                        if (1 >= CurrentFileSize) {
                            //
                            // No free space chunk before this file at all
                            //
                            Trace(log, "No free space before Lcn %I64d", 
                                VolData.pFileListEntry->StartingLcn);
                            bResult = FALSE;
                            break;
                        }

                        MaxFreeSpaceChunkSize = CurrentFileSize;

//                        Trace(log, "Resetting MaxFreeSpaceChunkSize to %I64d (StartingLcn:%I64d)", 
//                            MaxFreeSpaceChunkSize, VolData.pFileListEntry->StartingLcn);
                    }
                }
            }

            if(VolData.hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(VolData.hFile);
                VolData.hFile = INVALID_HANDLE_VALUE;
            }
            if(VolData.hFreeExtents != NULL) {
                while(GlobalUnlock(VolData.hFreeExtents))
                    ;
                EH_ASSERT(GlobalFree(VolData.hFreeExtents) == NULL);
                VolData.hFreeExtents = NULL;
            }

            // update cluster array
            PurgeExtentBuffer();
        }
    }

    ClearFreeSpaceListWithMultipleTrees();

    
    Trace(log, "End: Moving files forward.  Processed %I64u files", uFileCount - 1);
    return TRUE;

}


/*****************************************************************************************************************


ROUTINE DESCRIPTION:
    This moves between DefragmentFiles (which attempts to defrag fragmented 
    files), and ConsolidateFreeSpace (which attempts to move contiguous files 
    forward, towards the centre of the disk).

GLOBALS:
    VolData

RETURN:
    TRUE - We finished defragmenting the volume successfully.
    FALSE - Some files on the volume could not be defragmented.
*/
BOOL
DefragNtfs(
    )
{
    ULONG NumFragmentedFiles = 0, 
        PreviousFragmented = 0,
        PreviousFragmented2 = 0;
    UINT uPassCount = 0,
        uMoveFilesCount = 0;
    BOOL bDone = FALSE, bConsolidate = FALSE;
    LONGLONG MinimumLength = 0;
    BOOL bMftZoneDefragmented = FALSE;
    UINT consolidateProgress = 0;
    Trace(log, "Start:  DefragNtfs");

    do {
        do {
            //
            // If the controller tells us to stop (user cancelled), do.
            //
            if (VolData.EngineState == TERMINATE) {
                PostMessage(hwndMain, WM_CLOSE, 0, 0);
                break;
            }

            Trace(log, "Starting pass %lu (defrag: %lu%% done, consolidate: %lu%% done)", 
                ++uPassCount, uDefragmentPercentDone, uConsolidatePercentDone);

            //
            // Attempt to Defragment fragmented files.  This routine returns true
            // if we successfully defragmented all the files on the volume.
            //
            bDone = DefragmentFiles(45, &MinimumLength);
            NumFragmentedFiles = RtlNumberGenericTableElementsAvl(&VolData.FragmentedFileTable);

            Trace(log, "After DefragmentFiles, NumFragmentedFiles: %lu, PreviousFragmented:%lu", 
                NumFragmentedFiles, PreviousFragmented);
            
            if ((bDone) || (NumFragmentedFiles == PreviousFragmented)) {
                //
                // We're either done, or we didn't make any progress--fragmented 
                // file count didn't change from our last attempt.
                //
                break;
            }

            if (VolData.EngineState == TERMINATE) {
                PostMessage(hwndMain, WM_CLOSE, 0, 0);
                break;
            }

            //
            // Try to consolidate some free space.  This routine will try to
            // move files out of a region and create a big free space chunk.
            //
            if ((uPassCount < 10) && (uPassCount % 2)) {
                consolidateProgress = 1;
            }
            else {
                consolidateProgress = 0;
            }
            bConsolidate = ConsolidateFreeSpace(MinimumLength, 75, FALSE, consolidateProgress);
            PreviousFragmented = NumFragmentedFiles;
            if (!bConsolidate) {
                // We couldn't find/create a space big enough...
                break;
            }
            
            if (!bMftZoneDefragmented) {
                // If we haven't moved files out of the MFT Zone, now's a good
                // time to do so
                bMftZoneDefragmented = ConsolidateFreeSpace(0, 100, TRUE, 1);
            }
        }while (!bDone);


        if ((bDone) || (NumFragmentedFiles == PreviousFragmented2)) {
            break;
        }
        
        PreviousFragmented2 = NumFragmentedFiles;
        if (TERMINATE == VolData.EngineState) {
            PostMessage(hwndMain, WM_CLOSE, 0, 0);
            break;
        }

        ++uMoveFilesCount;
        MoveFilesForward(25 / (uMoveFilesCount * 2));
        ConsolidateFreeSpace(MinimumLength, 75, FALSE,0);
        
    }while (TRUE);


    if ((bDone) && (TERMINATE != VolData.EngineState)) {
        //
        // We're done on our first attempt above, we should consolidate at
        // least once
        //
        if (!bMftZoneDefragmented) {
            bMftZoneDefragmented = ConsolidateFreeSpace(0, 100, TRUE, 1);
        }
        
        MoveFilesForward((98 - uPercentDone));
    }
    

        
    VolData.bFragmented = !bDone;
    Trace(log, "End:  DefragNtfs.  Complete:%lu", bDone);

    return TRUE;
}


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    After a place has been found to move this file to, this function will move it there.

GLOBALS:
    VolData

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
MoveNtfsFile(
    )
{
//    Message(TEXT("MoveNtfsFile"), -1, NULL);

    if((!VolData.hFile) || (VolData.hFile == INVALID_HANDLE_VALUE)) {

        // Get the file name
        if(!GetNtfsFilePath() || (!VolData.vFileName.GetBuffer())) {
            return FALSE;
        }
        // Check if file is in exclude list
        if(!CheckFileForExclude()) {
            return FALSE;
        }
        // Get a handle to the file
        if(!OpenNtfsFile()) {
            return FALSE;
        }
    }
    //SendStatusData();
    // pVolData->Status already set.
    return MoveFile();
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Partially defrags an NTFS file.

GLOBALS:
    VolData

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
PartialDefragNtfs(
    )
{
    Message(TEXT("PartialDefragNtfs"), -1, NULL);

    // Check to see if there is enough free space.
    if(VolData.hFreeExtents == NULL) {
        return TRUE;
    }
    if(VolData.hFile == INVALID_HANDLE_VALUE) {

        // Get the file name
        if(!GetNtfsFilePath()) {
            VolData.Status = NEXT_ALGO_STEP;
            return FALSE;
        }
        // Check if file is in exclude list
        if(!CheckFileForExclude()) {
            VolData.Status = NEXT_FILE;
            return FALSE;
        }
        // Get a handle to the file
        if(!OpenNtfsFile()) {
            VolData.Status = NEXT_FILE;
            return FALSE;
        }
    }
    // Partially defrag the file
    return PartialDefrag();
}
/*****************************************************************************************************************

ROUTINE DESCRIPTION:
    Send graphics to UI.
*/

void SendGraphicsData()
{
    char * pAnalyzeLineArray = NULL;
    char * pDefragLineArray = NULL;
    DISPLAY_DATA * pDispData = NULL;

    __try {

        // Kill the timer until we're done.
        KillTimer(hwndMain, DISKVIEW_TIMER_ID);

        // don't send the data unless the engine is running
        if (VolData.EngineState != RUNNING){
            return;
        }

        // if DiskView didn't get memory, forget it
        if (!AnalyzeView.HasMapMemory() || !DefragView.HasMapMemory()) {
            SendGraphicsMemoryErr();
            return;
        }

        DISPLAY_DATA DisplayData = {0};
        DWORD dwDispDataSize = 0;

        // get copies of line arrays for analyze and defrag
        // (delete copy when finished)
        AnalyzeView.GetLineArray(&pAnalyzeLineArray, &DisplayData.dwAnalyzeNumLines);
        DefragView.GetLineArray(&pDefragLineArray, &DisplayData.dwDefragNumLines);

        // Allocate enough memory to hold both analyze and defrag displays.
        // If only analyze or defrag is present, then the NumLines field for the
        // other one will equal zero -- hence no additional allocation.
        dwDispDataSize =
            DisplayData.dwAnalyzeNumLines +
            DisplayData.dwDefragNumLines +
            sizeof(DISPLAY_DATA);

        // If neither an analyze diskview nor a defrag diskview are present, don't continue.
        if (DisplayData.dwAnalyzeNumLines == 0 && DisplayData.dwDefragNumLines == 0) {
            return;
        }

        pDispData = (DISPLAY_DATA *) new char[dwDispDataSize];

        // If we can't get memory, don't continue.
        if (pDispData == NULL) {
            return;
        }

        wcscpy(pDispData->cVolumeName, VolData.cVolumeName);

        // Copy over the fields for the analyze and defrag data.
        // If only one or the other is present, the fields for the other will equal zero.
        pDispData->dwAnalyzeNumLines        = DisplayData.dwAnalyzeNumLines;
        pDispData->dwDefragNumLines         = DisplayData.dwDefragNumLines;

        // Get the line array for the analyze view if it exists.
        if (pAnalyzeLineArray) {
            CopyMemory((char*) &(pDispData->LineArray),
                        pAnalyzeLineArray,
                        DisplayData.dwAnalyzeNumLines);
        }

        // Get the line array for the defrag view if it exists
        if (pDefragLineArray) {
            CopyMemory((char*) ((BYTE*)&pDispData->LineArray) + DisplayData.dwAnalyzeNumLines,
                        pDefragLineArray,
                        DisplayData.dwDefragNumLines);
        }

        // If the gui is connected, send gui data to it
        DataIoClientSetData(ID_DISP_DATA, (TCHAR*) pDispData, dwDispDataSize, pdataDfrgCtl);
        Message(TEXT("engine sending graphics to UI"), -1, NULL);
    }
    __finally {

        // clean up
        if (pAnalyzeLineArray) {
            delete [] pAnalyzeLineArray;
        }

        if (pDefragLineArray) {
            delete [] pDefragLineArray;
        }

        if (pDispData) {
            delete [] pDispData;
        }

        // reset the next timer for updating the disk view
        if(SetTimer(hwndMain, DISKVIEW_TIMER_ID, DiskViewInterval, NULL) == 0)
        {
            LOG_ERR();
        }
    }
}

/*****************************************************************************************************************

ROUTINE DESCRIPTION:
    This is the exit routine which will clean up all the open handles, free up all unused memory etc.

INPUT + OUTPUT:
    None.

GLOBALS:
    Pointless to enumerate here -- all unhandled handles (pun intended) and allocated memories are closed/freed.

RETURN:
    None.

*/

VOID
Exit(
    )
{
    // Delete the pointer to the GUI object.
    ExitDataIoClient(&pdataDfrgCtl);
    
    //If we were logging, then close the log file.
    if(bLogFile){
        ExitLogFile();
    }


    CoUninitialize();

    //0.0E00 Close event logging.
    CleanupLogging();
    //Close the error log.
    ExitErrorLog();


}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Allocate a buffer for and read the MFT bitmap (bitmap attribute in
    filerecord 0). The MFT bitmap contains one bit for each filerecord
    in the MFT and has the bit set if the filerecord is in use and reset
    if it is not in use.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN VolData.hVolume - Handle to the volume
    IN VolData.pFileRecord - Pointer to buffer to hold the file record for the current file.
    IN VolData.BytesPerFRS - The number of bytes in a file record.
    IN VolData.BytesPerSector - The number of bytes in a sector.
    IN VolData.BytesPerCluster - The number of bytes in a cluster.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
GetMftBitmap(
    )
{
    EXTENT_LIST*                pExtents = NULL;
    LONGLONG                    Extent;
    PUCHAR                      pMftBitmap = NULL;
    PBYTE                       pByte;
    LONGLONG                    Byte;
    STREAM_EXTENT_HEADER*       pStreamExtentHeader = NULL;

    __try{

        //0.0E00 Load the $MFT filerecord which is #0.
        VolData.FileRecordNumber = 0;
        EF(GetInUseFrs(VolData.hVolume, &VolData.FileRecordNumber, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord, (ULONG)VolData.BytesPerFRS));

        //0.0E00 Error out if we didn't get the record.
        EF_ASSERT(VolData.FileRecordNumber == 0);

        //0.0E00 Build an extent list of the MFT bitmap (which is stored in the $BITMAP attribute).
        EF(GetStreamExtentsByNameAndType(TEXT(""), $BITMAP, (FILE_RECORD_SEGMENT_HEADER*)VolData.pFileRecord));

        //0.0E00 Allocate a buffer large enough to hold the MFT bitmap per the extent data gotten in GetExtentList.
        EF(AllocateMemory((ULONG)((VolData.NumberOfClusters * VolData.BytesPerCluster) + VolData.BytesPerCluster), &VolData.hMftBitmap, (void**)&pMftBitmap));

        //0.0E00 Save a pointer to the beginning of the buffer.
        pByte = (PBYTE)pMftBitmap;

        //Get a pointer to the stream header.
        pStreamExtentHeader = (STREAM_EXTENT_HEADER*)VolData.pExtentList;

        //Get a pointer to the extent list.
        pExtents = (EXTENT_LIST*)((UCHAR*)VolData.pExtentList + sizeof(STREAM_EXTENT_HEADER));

        //0.0E00 Loop through each extent for the bitmap.
        for(Extent = 0; Extent < pStreamExtentHeader->ExtentCount; Extent ++){

            //0.0E00 Read the data in that extent into the buffer.
            EF(DasdReadClusters(VolData.hVolume,
                                pExtents[Extent].StartingLcn,
                                pExtents[Extent].ClusterCount,
                                pMftBitmap,
                                VolData.BytesPerSector,
                                VolData.BytesPerCluster));

            //0.0E00 Update our pointer to the end of the bitmap.
            pMftBitmap += (pExtents[Extent].ClusterCount * VolData.BytesPerCluster);
        }

        //0.0E00 Count how many file records are in use.
        for(Byte = 0; Byte < VolData.TotalFileRecords / 8; Byte ++){
            //0.0E00 Use the bit array above to determine how many bits are set in this byte, and add it to the total.
            VolData.InUseFileRecords += CountBitsArray[pByte[Byte]];
        }
    }
    __finally{

        //0.0E00 Cleanup.
        if((pMftBitmap != NULL) && (VolData.hMftBitmap != NULL)){
            GlobalUnlock(VolData.hMftBitmap);
        }
    }
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the name of the pagefiles and store them in a double null-terminated list of null terminated strings.

INPUT + OUTPUT:
    IN cDrive           - The current drive so that this can tell which pagefile names to store. (Only the current drive.)
    OUT phPageFileNames - Where to store the handle for the allocated memory.
    OUT ppPagseFileNames    - Where to store the pointer for the pagefile names.

GLOBALS:
    None.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
GetPagefileNames(
    IN TCHAR cDrive,
    OUT HANDLE * phPageFileNames,
    OUT TCHAR ** ppPageFileNames
    )
{
    HKEY hKey = NULL;
    ULONG lRegLen = 0;
    int i;
    int iStrLen;
    int iNameStart = 0;
    TCHAR * pTemp;
    TCHAR * pProcessed;
    DWORD dwRet = 0;
    DWORD dwType = 0;

    //0.0E00 Open the registry key to the pagefile.
    EF_ASSERT(ERROR_SUCCESS == RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
                0,
                KEY_QUERY_VALUE,
                &hKey));


    //0.0E00 Find out how much memory we need to hold the value pagefile names.
    EF_ASSERT(ERROR_SUCCESS == RegQueryValueEx(
                hKey,
                TEXT("PagingFiles"),
                0,
                &dwType,
                NULL,
                &lRegLen));

    //0.0E00 If there is no data then allocate enough for two bytes (a double termination).
    if(lRegLen<2){
        lRegLen = 2;
    }

    //0.0E00 Allocate enough memory.
    EF(AllocateMemory(lRegLen, phPageFileNames, (void**)ppPageFileNames));

    //0.0E00 Get the value.
    EF_ASSERT(ERROR_SUCCESS ==RegQueryValueEx(
                hKey,
                TEXT("PagingFiles"),
                0,
                &dwType,
                (LPBYTE)*ppPageFileNames,
                &lRegLen));

    //0.0E00 Strip out the numbers and drive letters so that we have only the pagefile names.
    // The REG_MULTI_SZ type has a series of null terminated strings with a double null termination at the end
    // of the list.
    // The format of each string is "c:\pagefile.sys 100 100".  The data after the slash and before the first space
    // is the page file name.  The numbers specify the size of the pagefile which we don't care about.
    // We extract the filename minus the drive letter of the pagefile (which must be in the root dir so we don't
    // need to worry about subdirs existing).  Therfore we put a null at the first space, and shift the pagefile
    // name earlier so that we don't have c:\ in there.  The end product should be a list of pagefile
    // names with a double null termination for example:  "pagefile.sys[null]pagefile2.sys[null][null]"  Furthermore,
    // we only take names for this drive, so the string may simply consist of a double null termination.
    // We use the same memory space for output as we use for input, so we just clip the pagefile.sys and bump it up
    // to the beginning of ppPageFileNames.  We keep a separate pointer which points to the next byte after
    // The previous outputed data.

    pProcessed = pTemp = *ppPageFileNames;

    //0.0E00 For each string...
    while(*pTemp!=0){

        iStrLen = lstrlen(pTemp);

        //0.0E00 If this pagefile is on the current drive.
        if((TCHAR)CharUpper((TCHAR*)pTemp[0]) == (TCHAR)CharUpper((TCHAR*)cDrive)){
            //0.0E00 Go through each character in this string.
            for(i=0; i<iStrLen; i++){
                //0.0E00 If this is a slash, then the next character is the first of the pagefile name.
                if(pTemp[i] == TEXT('\\')){
                    iNameStart = i+1;
                    continue;
                }
                //0.0E00 If this is a space then the rest of the string is numbers.  Null terminate it here.
                if(pTemp[i] == TEXT(' ')){
                    pTemp[i] = 0;
                    break;
                }
            }
            //0.0E00 Bump the string up so all the processed names are adjacent.
            MoveMemory(pProcessed, pTemp+iNameStart, (lstrlen(pTemp+iNameStart)+1)*sizeof(TCHAR));

            //0.0E00 Note where the next string should go.
            pProcessed += lstrlen(pProcessed) + 1;

            VolData.NumPagefiles++;
        }
        //0.0E00 If this pagefile is not on this current drive then simply ignore it.
        else{
        }

        //0.0E00 Note where to search for the next string.
        pTemp += iStrLen + 1;
    }

    //0.0E00 Add double null termination.
    *pProcessed = 0;

    EF_ASSERT(RegCloseKey(hKey)==ERROR_SUCCESS);
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Check to see if a file is a pagefile and grab it's extent list if it is.

INPUT + OUTPUT:
    IN FileRecordNumber - The number of the filerecord we want to check.
    IN pFileRecord      - A pointer to the filerecord for the file we want to check.

GLOBALS:
    OUT VolData.PagefileFrags   - The number of fragments in the pagefile if it is a pagefile.
    OUT VolData.PagefileSize    - The number of bytes in the pagefile if it is a pagefile.

    IN OUT Various other VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
CheckForPagefileNtfs(
    IN LONGLONG FileRecordNumber,
    IN FILE_RECORD_SEGMENT_HEADER* pFileRecord
    )
{
    //0.0E00 Get file's name
    LONGLONG ParentFileRecordNumber;
    TCHAR cFileName[MAX_PATH+1];
    EF(GetNameFromFileRecord(pFileRecord,
                             cFileName,
                             &ParentFileRecordNumber));

    VolData.vFileName = cFileName;

    if (!VolData.vFileName.GetBuffer()) {
        return FALSE;
    }
    
    //0.0E00 Check if this pagefile is in the root dir.
    if(ParentFileRecordNumber != ROOT_FILE_NAME_INDEX_NUMBER){
        //0.0E00 No it isn't so just return.
        return TRUE;
    }
    //0.0E00 See if this is a pagefile
    if(!CheckPagefileNameMatch(VolData.vFileName.GetBuffer(), pPageFileNames)){
        //0.0E00 No it isn't so just return.
        return TRUE;
    }

    //0.0E00 Get the pagefile's extent list
    VolData.pFileRecord = pFileRecord;
    VolData.FileRecordNumber = FileRecordNumber;
    EF(GetExtentList(DEFAULT_STREAMS, NULL));

    //Get a pointer to the extent list's file header.
    FILE_EXTENT_HEADER* pFileExtentHeader = (FILE_EXTENT_HEADER*)VolData.pExtentList;

    //0.0E00 If this file is compressed then it is not a valid pagefile so just return.
    if(VolData.bCompressed){
        return TRUE;
    }

    //0.0E00 Set the pagefile's stats and return.
    VolData.bPageFile = TRUE;
    // in case there is more than 1 pagefile, you need to add them up
    VolData.PagefileFrags += pFileExtentHeader->ExcessExtents + 1;
    VolData.PagefileSize += VolData.FileSize;

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Check a name against all the pagefile names to see if this name matches that of a pagefile.

INPUT + OUTPUT:
    IN pCompareName - The name of that we are checking to see if it is a pagefile.
    IN pPageFileNames - The list of pagefile names for this drive.

GLOBALS:
    None.

RETURN:
    TRUE    - This name matches a pagefile name.
    FALSE   - This name does not match a pagefile name.
*/

BOOL
CheckPagefileNameMatch(
    IN TCHAR * pCompareName,
    IN TCHAR * pPageFileNames
    )
{
    if (!pCompareName || !pPageFileNames) {
        return FALSE;
    }
    
    //0.0E00 Loop through all the pagefile names -- the list is double null terminated.
    while(*pPageFileNames!=0){
        //0.0E00 Check if these names match.
        if(!lstrcmpi(pCompareName, pPageFileNames)){
            return TRUE;
        }
        //0.0E00 If not then move to the next name.
        else{
            pPageFileNames+=lstrlen(pPageFileNames)+1;
        }
    }
    //0.0E00 No match with any of the names, so return FALSE.
    return FALSE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Prints out the disk statistics on screen.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN various VolData fields that get printed onto the screen.

RETURN:
    None.
*/

VOID
DisplayNtfsVolumeStats()
{
    ULONG      iTmp;
    LONGLONG   llTmp;

    Trace(log, " *  NTFS Volume Statistics:");
    Trace(log, "    Total sectors on disk = %I64d", VolData.TotalSectors);
    Trace(log, "    Bytes per sector = %I64d", VolData.BytesPerSector);
    Trace(log, "    Bytes per cluster = %I64d", VolData.BytesPerCluster);
    Trace(log, "    Sectors per cluster = %I64d", VolData.SectorsPerCluster);
    Trace(log, "    Total clusters on disk = %I64d", VolData.TotalClusters);
    Trace(log, "    Bytes per File Record Segment = %I64d", VolData.BytesPerFRS);
    Trace(log, "    Volume Bitmap Size = %I64d", VolData.BitmapSize);
    Trace(log, "    NumberOfFileRecords = %I64d", VolData.TotalFileRecords);
    Trace(log, "    Mft Start Lcn = 0x%I64x (%I64d)", VolData.MftStartLcn, VolData.MftStartLcn);
    Trace(log, "    Mft2 Start Lcn = 0x%I64x (%I64d)", VolData.Mft2StartLcn, VolData.Mft2StartLcn);
    Trace(log, "    Mft Zone Start = 0x%I64x (%I64d)", VolData.MftZoneStart, VolData.MftZoneStart);
    Trace(log, "    Mft Zone End = 0x%I64x (%I64d)", VolData.MftZoneEnd, VolData.MftZoneEnd);

    llTmp = VolData.MftZoneEnd - VolData.MftZoneStart;
    Trace(log, "    Mft Zone Size = %I64d clusters", llTmp);
    Trace(log, "    Mft Start Offset = 0x%I64x (%I64d)", VolData.MftStartOffset, VolData.MftStartOffset);
    Trace(log, "    Disk Size = %I64d", VolData.TotalClusters * VolData.BytesPerCluster);
    Trace(log, "    Cluster Size = %I64d", VolData.BytesPerCluster);
    Trace(log, "    Used Space = %I64d bytes", VolData.UsedClusters * VolData.BytesPerCluster);
    Trace(log, "    Free Space = %I64d bytes", (VolData.TotalClusters - VolData.UsedClusters) * VolData.BytesPerCluster);
    Trace(log, "    Free Space = %I64d bytes", VolData.FreeSpace);
    Trace(log, "    Usable Free Space = %I64d bytes", VolData.UsableFreeSpace);
    Trace(log, "    Smallest Free Space = %I64d clusters", VolData.SmallestFreeSpaceClusters);
    Trace(log, "    Largest Free Space = %I64d clusters", VolData.LargestFreeSpaceClusters);
    Trace(log, "    Average Free Space = %I64d clusters", VolData.AveFreeSpaceClusters);
    Trace(log, "    Pagefile Size = %I64d", VolData.PagefileSize);
    Trace(log, "    Pagefile Fragments = %I64d", VolData.PagefileFrags);
    Trace(log, "    Number of Active Pagefiles on this Drive = %I64d", VolData.NumPagefiles);
    Trace(log, "    Total Directories = %I64d", VolData.TotalDirs);
    Trace(log, "    Fragmented Dirs = %I64d", VolData.NumFraggedDirs);
    Trace(log, "    Excess Dir Frags = %I64d", VolData.NumExcessDirFrags);
    Trace(log, "    Total Files = %I64d", VolData.TotalFiles);
    Trace(log, "    Current File = %I64d", VolData.CurrentFile);
    Trace(log, "    Total File Space = %I64d bytes", VolData.TotalFileSpace);
    Trace(log, "    Total File Bytes = %I64d bytes", VolData.TotalFileBytes);
    Trace(log, "    Avg. File Size = %I64d bytes", VolData.AveFileSize);
    Trace(log, "    Fragmented Files = %I64d", VolData.NumFraggedFiles);
    Trace(log, "    Excess Fragments = %I64d", VolData.NumExcessFrags);

    if (VolData.TotalClusters - VolData.UsedClusters){
        iTmp =  (ULONG)(100 * (VolData.NumFreeSpaces - 4) /
                (VolData.TotalClusters - VolData.UsedClusters));
    }
    else {
        iTmp = -1;
    }
    Trace(log, "    Free Space Fragmention Percent = %ld", iTmp);
    Trace(log, "    Fragged Space = %I64d bytes", VolData.FraggedSpace);
    Trace(log, "    File Fragmention Percent = %I64d", VolData.PercentDiskFragged);
    Trace(log, "    MFT size = %I64d kb", VolData.MftSize / 1024);
    Trace(log, "    # MFT records = %I64d", VolData.TotalFileRecords);

    if(VolData.TotalFileRecords != 0) {
        iTmp = (ULONG)(100 * VolData.InUseFileRecords / VolData.TotalFileRecords);
    }
    else {
        iTmp = -1;
    }
    Trace(log, "    Percent MFT in use = %ld", iTmp);
    Trace(log, "    MFT Fragments = %I64d", VolData.MftNumberOfExtents);

    // time data
    Trace(log, "    Start Time = %s", GetTmpTimeString(VolData.StartTime));
    Trace(log, "    End Time = %s", GetTmpTimeString(VolData.EndTime));
    DWORD dwSeconds;
    if (GetDeltaTime(&VolData.StartTime, &VolData.EndTime, &dwSeconds)){
        Trace(log, "    Delta Time = %d seconds", dwSeconds);
    }

    Trace(log, " *  End of Statistics");
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Displays data about the current file for the developer.

INPUT + OUTPUT:
    None.

GLOBALS:
    IN Various VolData fields.

RETURN:
    None.
*/

VOID
DisplayNtfsFileSpecsFunction(
    )
{
    TCHAR cString[300];

    //0.0E00 Display File Name, number of extents and number of fragments.
    _stprintf(cString, TEXT("Extents = 0x%lX "), ((FILE_EXTENT_HEADER*)VolData.pExtentList)->ExcessExtents+((FILE_EXTENT_HEADER*)VolData.pExtentList)->NumberOfStreams);
    Message(cString, -1, NULL);

    _stprintf(cString,
             TEXT("%s %s at Lcn 0x%lX for Cluster Count of 0x%lX"),
             (VolData.bFragmented == TRUE) ? TEXT("Fragmented") : TEXT("Contiguous"),
             (VolData.bDirectory) ? TEXT("Directory") : TEXT("File"),
             (ULONG)VolData.StartingLcn,
             (ULONG)VolData.NumberOfClusters);
    Message(cString, -1, NULL);
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Load a requested file record into a memory buffer.  If the file record is not in use then
    load the next in-use file record and return its file record number.

    Note:
    GetFrs reads MFT_BUFFER_SIZE of the MFT at a time and returns pointers
    to the filerecords within the buffer rather than loading each filerecord individually.

INPUT + OUTPUT:
    IN OUT pFileRecordNumber    - Points to the file record number we're supposed to read, and where we write back
                                    which number we actually read.
    IN pMftExtentList           - The list of all the extents for the MFT (so we can DASD read the MFT).
    IN pMftBitmap               - The MFT bitmap (so we can see if records are in use.
    IN pMftBuffer               - The buffer that we hold a chunk of the MFT in.
    OUT pFileRecord             - A pointer to a pointer so we can pass back the file record requested.

GLOBALS:
    IN OUT Various VolData fields.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
GetFrs(
    IN LONGLONG*                        pFileRecordNumber,
    IN EXTENT_LIST*                     pMftExtentList,
    IN UCHAR*                           pMftBitmap,
    IN FILE_RECORD_SEGMENT_HEADER*      pMftBuffer,
    OUT FILE_RECORD_SEGMENT_HEADER* pFileRecord
    )
{
    LONGLONG                    FileRecordNumber = *pFileRecordNumber;
    LONGLONG                    Extent;
    LONGLONG                    Cluster;
    LONGLONG                    Vcn;
    LONGLONG                    ClustersInMftBuffer;
    PUCHAR                      pUchar = (PUCHAR)pMftBuffer;
    LONGLONG                    i;
    LONGLONG                    FileRecordsPerCluster;
    LONGLONG                    ClustersXfered;

    //Initialize FileRecordsPerCluster just in case we don't have to compute it...
    FileRecordsPerCluster = 1;

    //0.0E00 Loop until we find a bit that is in use in the bitmap (1 means in use, 0 means not in use).
    //If the current file record is not in use then we'll find the next that is.
    //FileRecordNumber/8 gets us the byte that contains the bit for this file record.
    //FileRecordNumber&7 gets us the bit offset in the byte for our record.
    while((pMftBitmap[FileRecordNumber / 8] & (1 << (FileRecordNumber & 7))) == 0){

        //0.0E00 Since this record is not in use, increment our offset.
        FileRecordNumber ++;

        //0.0E00 If we've gone beyond the end if the bitmap...
        if(FileRecordNumber >= VolData.TotalFileRecords){
            //0.0E00 Note this file record number and return.
            *pFileRecordNumber = FileRecordNumber;
            return TRUE;
        }
    }

    //0.0E00 We got here so we found an in use file record.

    //0.0E00 Return the number of this record.
    *pFileRecordNumber = FileRecordNumber;

    //0.0E00 If this filerecord isn't already in the buffer, load the block that contains it.
    //0.0E00 FileRecordLow keeps track of the lowest filerecord number currently loaded, FileRecordHi the highest.
    if((FileRecordNumber < FileRecordLow) || (FileRecordNumber >= FileRecordHi)){

        //0.0E00 If there are 1 or more clusters per FRS...
        if(VolData.ClustersPerFRS){
            //0.0E00 Note which cluster offset this file record number is in the MFT.
            Cluster = FileRecordNumber * VolData.ClustersPerFRS;
        }
        //0.0E00 ...else there are multiple file records per cluster.
        else{
            //0.0E00 Error if there are no bytes in an FRS.
            EF_ASSERT(VolData.BytesPerFRS != 0);

            //0.0E00 Calculate how many file records there are in a cluster.
            FileRecordsPerCluster = VolData.BytesPerCluster / VolData.BytesPerFRS;

            //0.0E00 Error if there are no file records per cluster.
            EF_ASSERT(FileRecordsPerCluster != 0);

            //0.0E00 Note which cluster offset this file record number is into the MFT.
            Cluster = FileRecordNumber / FileRecordsPerCluster;
        }

        //0.0E00 Find the extent that the filerecord's first cluster is in
        //0.0E00 Loop through each extent of the MFT starting with the first extent.
        for(Vcn = 0, Extent = 0; Extent < VolData.MftNumberOfExtents; Extent ++){

            //0.0E00 If the cluster we are looking for fits between the first cluster of this extent (Vcn) and the last, then we have found our extent.
            if((Vcn <= Cluster) && (Cluster < (Vcn + pMftExtentList[Extent].ClusterCount))){
                break;
            }

            //0.0E00 Otherwise we haven't found our extent so update to the next extent.
            Vcn += pMftExtentList[Extent].ClusterCount;
        }

        //0.0E00 Figure out how many clusters will fit in our buffer.
        EF_ASSERT(VolData.BytesPerCluster != 0);
        ClustersInMftBuffer = MFT_BUFFER_SIZE / VolData.BytesPerCluster;

        //0.0E00 If all the clusters for this block are in this extent, load them in one read
        if((Cluster + ClustersInMftBuffer) <= (Vcn + pMftExtentList[Extent].ClusterCount)){

            //0.0E00 Read one buffer full.
            EF_ASSERT(VolData.BytesPerCluster != 0);
            EF(DasdReadClusters(VolData.hVolume,
                                pMftExtentList[Extent].StartingLcn + (Cluster - Vcn),
                                MFT_BUFFER_SIZE / VolData.BytesPerCluster,
                                pMftBuffer,
                                VolData.BytesPerSector,
                                VolData.BytesPerCluster));
            ClustersXfered = ClustersInMftBuffer;
        }
        //0.0E00 If all the clusters for this block do not fit in this extent, do as many reads as necessary to fill up the buffer.
        else{
            //Keep track of how many clusters we actually transferred
            ClustersXfered = 0;

            //0.0E00 Cluster will be an offset from the beginning of the extent rather than from the beginning of the MFT.
            Cluster -= Vcn;

            //0.0E00 Keep reading extents until we fill the buffer.
            for(i = 0; i < ClustersInMftBuffer; i ++){

                //0.0E00 Read one cluster.
                EF(DasdReadClusters(VolData.hVolume,
                                    pMftExtentList[Extent].StartingLcn + Cluster,
                                    1,
                                    pUchar,
                                    VolData.BytesPerSector,
                                    VolData.BytesPerCluster));
                ClustersXfered++;

                //0.0E00 Read the next cluster.
                Cluster ++;

                //0.0E00 If this cluster is beyond the end of the extent, start on the next extent.
                if(Cluster >= pMftExtentList[Extent].ClusterCount){
                    Extent ++;
                    if(Extent >= VolData.MftNumberOfExtents){
                        break;
                    }
                    Cluster = 0;
                }

                //0.0E00 Keep our pointer into our buffer pointing to the end.
                pUchar += VolData.BytesPerCluster;
            }
        }

        //0.0E00 Record the first and last filerecord numbers now in the buffer
        EF_ASSERT(VolData.BytesPerFRS != 0);
        //0.0E00 Record the first and last file record numbers now in the buffer
        FileRecordLow = FileRecordNumber & ~(FileRecordsPerCluster-1);
        if (VolData.ClustersPerFRS) {
            FileRecordHi = FileRecordLow + (ClustersXfered / VolData.ClustersPerFRS);
        }
        else {
            FileRecordHi = FileRecordLow + (ClustersXfered * FileRecordsPerCluster);
        }
    }

    //0.0E00 Return a pointer to the filerecord in the buffer
    CopyMemory(pFileRecord,
        (PFILE_RECORD_SEGMENT_HEADER)((PUCHAR)(pMftBuffer) + ((FileRecordNumber - FileRecordLow) * VolData.BytesPerFRS)),
        (ULONG)VolData.BytesPerFRS);


    //
    // Check to make sure that the file record has the "FILE" signature.  If it doesn't, 
    // the FRS is corrupt.
    //
    if ((pFileRecord->MultiSectorHeader.Signature[0] != 'F') ||
        (pFileRecord->MultiSectorHeader.Signature[1] != 'I') ||
        (pFileRecord->MultiSectorHeader.Signature[2] != 'L') ||
        (pFileRecord->MultiSectorHeader.Signature[3] != 'E')
        ) {
        //
        // This FRS is corrupt.  
        //
        VolData.bMFTCorrupt = TRUE;
        return FALSE;
    }


    //0.0E00 Make the USA adjustments for this filerecord.
    EF(AdjustUSA(pFileRecord));
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Each filerecord has a verification encoding called Update Sequence Array.
    Throughout the file record at even intervals (every 256 bytes), two bytes are replaced with
    data for verification of the file record by the file system.  In order that the file record
    can be reconstructed for use again, there is an array near the beginning of the file record
    that contains an array of bytes holding each of the replaced bytes.  Thus, you can extract
    the bytes from the array, put them back throughout the file record and it is usable again.

    The number that is used to replace the bytes at even intervals is the same throughout each
    file record.  This number is stored in the first two bytes of the Update Sequence Array.
    Therefore, the verification that the file system normally does before the file record is
    reconstructed is to compare these first two bytes with each two replaced bytes throughout
    the record to make sure they are equal.  The file record is then reconstructed.

    Normally the USA (Update Sequence Array) is handled by the file system, but since we are
    reading directly from the disk with DASD reads, we must do it ourselves.

    AdjustUSA decodes the filerecord pointed to by pFrs.

INPUT + OUTPUT:
    IN OUT pFrs - A pointer to file record to decode.

GLOBALS:
    None.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
AdjustUSA(
    IN OUT FILE_RECORD_SEGMENT_HEADER*  pFrs
    )
{
    PUSHORT pUsa;
    PUSHORT pUshort;
    USHORT UsaLength;
    USHORT Usn;
    LONGLONG i;

    //0.0E00 Get a pointer to the Update Sequence Array
    pUsa = (PUSHORT)((PUCHAR)pFrs+pFrs->MultiSectorHeader.UpdateSequenceArrayOffset);

    //bug #9914 AV on initization if multi volume disk failed
    //need to check if pUsa is not NULL
    if(pUsa == NULL)
    {
        return FALSE;
    }

    //0.0E00 Get the length of the array
    UsaLength = pFrs->MultiSectorHeader.UpdateSequenceArraySize;

    //0.0E00 Get a 2 byte array pointer to the file record
    pUshort = (PUSHORT)pFrs;

    // 0.0E00 Get the first number from the array (called the Update Sequence Number).
    Usn = *pUsa++;

    //0.0E00 Loop thru the file record
    for(i=1; i<UsaLength; i++){

        //0.0E00 Error if the Update Sequence entry doesn't match the USN
        EF(pUshort[(i*256)-1] == Usn);

        //0.0E00 Replace the Update Sequence Entry from the array and move to the next array entry
        pUshort[(i*256)-1] = *pUsa++;
    }
    return TRUE;
}


/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Deallocates the mapping files for the file lists.

INPUT + OUTPUT:
    None.

GLOBALS:
    Similar to AllocateFileLists above.

RETURN:
    TRUE - Success.
    FALSE - Fatal Error.
*/

BOOL
DeallocateFileLists(
    )
{
    TCHAR cString[300];
    PVOID pTableContext = NULL;

    if(VolData.hSysList){
        EH_ASSERT(GlobalUnlock(VolData.hSysList) == FALSE);
        EH_ASSERT(GlobalFree(VolData.hSysList) == NULL);
        VolData.hSysList = NULL;
        VolData.pSysList = NULL;
    }

    VolData.pFreeSpaceEntry = NULL;
    VolData.pFileListEntry = NULL;

    //
    // Reinitialize the tables, so they're zero'ed out
    //
    pTableContext = NULL;
    RtlInitializeGenericTable(&VolData.FragmentedFileTable,
       FileEntryStartLcnCompareRoutine,
       FileEntryAllocateRoutine,
       FileEntryFreeRoutine,
       pTableContext);

    pTableContext = NULL;
    RtlInitializeGenericTable(&VolData.ContiguousFileTable,
       FileEntryStartLcnCompareRoutine,
       FileEntryAllocateRoutine,
       FileEntryFreeRoutine,
       pTableContext);

    pTableContext = NULL;
    RtlInitializeGenericTable(&VolData.NonMovableFileTable,
       FileEntryStartLcnCompareRoutine,
       FileEntryAllocateRoutine,
       FileEntryFreeRoutine,
       pTableContext);

    if(VolData.hNameList){
        EH_ASSERT(GlobalUnlock(VolData.hNameList) == FALSE);
        EH_ASSERT(GlobalFree(VolData.hNameList) == NULL);
        VolData.hNameList = NULL;
        VolData.pNameList = NULL;
    }

    //
    // Free the memory allocated for the tables
    //
    SaFreeContext(&VolData.SaFileEntryContext);
    ClearFreeSpaceTable();

    /*    _stprintf(cString, TEXT("Shared memory freed for Drive %ws"), VolData.cDisplayLabel);
    Message(cString, -1, NULL);
    */    
    return TRUE;
}
/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:

GLOBALS:

RETURN:
    TRUE - Success.
    FALSE - Fatal error.
*/
BOOL
SendMostFraggedList(
    IN CONST BOOL fAnalyseOnly
    )
{
    CFraggedFileList fraggedFileList(VolData.cVolumeName);

    // Build the most fragged list
    EF(FillMostFraggedList(fraggedFileList, fAnalyseOnly));

    // create the block of data to send to UI
    EF(fraggedFileList.CreateTransferBuffer());

    // Send the packet to the UI.
    DataIoClientSetData(
        ID_FRAGGED_DATA,
        fraggedFileList.GetTransferBuffer(),
        fraggedFileList.GetTransferBufferSize(),
        pdataDfrgCtl);

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:

RETURN:
    None.
*/

VOID
SendReportData(
    )
{
    TEXT_DATA textData = {0};

    _tcscpy(textData.cVolumeName, VolData.cVolumeName);
    _tcscpy(textData.cVolumeLabel, VolData.cVolumeLabel);
    _tcscpy(textData.cFileSystem, TEXT("NTFS"));

    //Figure out how many free spaces there are on the drive.
    CountFreeSpaces();

    // get usable free space
    LONGLONG llUsableFreeClusters;
    if (DetermineUsableFreespace(&llUsableFreeClusters)){
        VolData.UsableFreeSpace = llUsableFreeClusters * VolData.BytesPerCluster;
    }
    else{
        VolData.UsableFreeSpace = VolData.FreeSpace;
    }

    //Fill in all the TEXT_DATA fields for the UI's text display.
    textData.DiskSize               = VolData.TotalClusters * VolData.BytesPerCluster;
    textData.BytesPerCluster        = VolData.BytesPerCluster;
    textData.UsedSpace              = VolData.UsedClusters * VolData.BytesPerCluster;
    textData.FreeSpace              = (VolData.TotalClusters - VolData.UsedClusters) * 
                                      VolData.BytesPerCluster;
    EV_ASSERT(VolData.TotalClusters);
    textData.FreeSpacePercent       = 100 * (VolData.TotalClusters - VolData.UsedClusters) / 
                                      VolData.TotalClusters;
    textData.UsableFreeSpace        = VolData.UsableFreeSpace;
    textData.UsableFreeSpacePercent = 100 * VolData.UsableFreeSpace / 
                                      (VolData.TotalClusters * VolData.BytesPerCluster);
    textData.PagefileBytes          = VolData.PagefileSize;
    textData.PagefileFrags          = __max(VolData.PagefileFrags, 0);
    textData.TotalDirectories       = __max(VolData.TotalDirs, 1);
    textData.FragmentedDirectories  = __max(VolData.NumFraggedDirs, 1);
    textData.ExcessDirFrags         = __max(VolData.NumExcessDirFrags, 0);
    textData.TotalFiles             = VolData.TotalFiles;
    textData.AvgFileSize            = VolData.AveFileSize;
    textData.NumFraggedFiles        = __max(VolData.NumFraggedFiles, 0);
    textData.NumExcessFrags         = __max(VolData.NumExcessFrags, 0);
    textData.PercentDiskFragged     = VolData.PercentDiskFragged;

    if(VolData.TotalFiles){
        textData.AvgFragsPerFile    = (VolData.NumExcessFrags + VolData.TotalFiles) * 100 / 
                                      VolData.TotalFiles;
    }
    textData.MFTBytes               = VolData.MftSize;
    textData.InUseMFTRecords        = VolData.InUseFileRecords;
    textData.TotalMFTRecords        = VolData.TotalFileRecords;
    textData.MFTExtents             = VolData.MftNumberOfExtents;

    if(VolData.TotalClusters - VolData.UsedClusters){
        if(VolData.NumFreeSpaces){
            textData.FreeSpaceFragPercent = (100 * VolData.NumFreeSpaces) /
                                            (VolData.TotalClusters - VolData.UsedClusters);
        }
    }

    //If the gui is connected, send gui data to it.
    DataIoClientSetData(ID_REPORT_TEXT_DATA, (TCHAR*)&textData, sizeof(TEXT_DATA), pdataDfrgCtl);
}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

INPUT + OUTPUT:

RETURN:
    None.
*/

void SendGraphicsMemoryErr()
{
    // don't need to send any data
    NOT_DATA NotData;
    _tcscpy(NotData.cVolumeName, VolData.cVolumeName);

    // if the gui is connected, send gui data to it.
    Message(TEXT("engine sending ID_NO_GRAPHICS_MEMORY"), -1, NULL);
    DataIoClientSetData(ID_NO_GRAPHICS_MEMORY, (PTCHAR) &NotData, sizeof(NOT_DATA), pdataDfrgCtl);
}

// send error code to client
// (for command line mode)
VOID SendErrData(PTCHAR pErrText, DWORD ErrCode)
{
static BOOL FirstTime = TRUE;

// only send the first error
if (FirstTime)
{
    // prepare COM message for client
    ERROR_DATA ErrData = {0};

    _tcscpy(ErrData.cVolumeName, VolData.cVolumeName);
    ErrData.dwErrCode = ErrCode;
    if (pErrText != NULL) 
    {
        _tcsncpy(ErrData.cErrText, pErrText, 999);
        ErrData.cErrText[999] = TEXT('\0');
    }

    // send COM message to client
    DataIoClientSetData(ID_ERROR, (TCHAR*) &ErrData, sizeof(ERROR_DATA), pdataDfrgCtl);

    // write the error to the error log.
    if (bLogFile && pErrText != NULL) 
    {
        WriteErrorToErrorLog(pErrText, -1, NULL);
    }

    // only one error
    FirstTime = FALSE;
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgntfs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DfrgNtfs.rc
//
#define IDS_REGISTRY_ERROR              1
#define IDS_REGISTRY_ERROR_TITLE        2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgres\dfrgres.c ===
/********************************************************************/
#include <windows.h>
#include <DfrgRes.h>
#include <shfusion.h>
/********************************************************************/
BOOL WINAPI DllMain(HINSTANCE hInstDLL,DWORD fdwReason,LPVOID lpvReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH) {
        SHFusionInitialize(NULL);
    else if (dwReason == DLL_PROCESS_DETACH) {
        SHFusionUninitialize();
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgsnap\dfrgsnaphelp.h ===
#ifndef _ATLSNAPHELP_H_
#define _ATLSNAPHELP_H_

//
// Include files
//
#include "htmlhelp.h"
#include "expand.h"

//
// Allocates memory for a string, copies the string,
// and returns it to the caller. Throws exceptions.
//
inline LPOLESTR CoTaskDupString( LPOLESTR pszInput )
{
	USES_CONVERSION;
	LPOLESTR pszOut = NULL;

	//
	// We throw an exception if the following allocation fails.
	//
	pszOut = (LPOLESTR) CoTaskMemAlloc( ( wcslen( pszInput ) + 1 ) * sizeof( OLECHAR ) );
	if ( pszOut == NULL )
		throw;

	wcscpy( pszOut, pszInput );

	return( pszOut );
};

template <class T>        
class ATL_NO_VTABLE ISnapinHelpImpl : public ISnapinHelp
{
public:

	// get the dkms help file location and returns it
	STDMETHOD( GetHelpTopic )( LPOLESTR* lpCompiledHelpFile )
	{
		_ASSERT( lpCompiledHelpFile != NULL );
		USES_CONVERSION;
		HRESULT hr = E_FAIL;
		TCHAR szPath[ _MAX_PATH * 2 ];

		// this is where the dkms help file is stored
		wcscpy(szPath, L"%systemroot%\\help\\defrag.chm");

		// expand out the %systemroot% variable
		ExpandEnvVars(szPath);

		// Allocate the string and return it.
		*lpCompiledHelpFile = CoTaskDupString( T2W( szPath ) );
		hr = S_OK;

		return( hr );
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgntfs\mftdefrag.cpp ===
/**************************************************************************************************

FILENAME: MFTDefrag.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    MFT defragment for NTFS.

**************************************************************************************************/

#include "stdafx.h"

extern "C"{
    #include <string.h>
    #include <stdio.h>
    #include <stdlib.h>
}

#include "Windows.h"
#include <winioctl.h>
#include <math.h>
#include <fcntl.h>


extern "C" {
    #include "SysStruc.h"
}

#include "MFTDefrag.h"
#include "DfrgCmn.h"
#include "GetReg.h"

#include "Devio.h"

#include "movefile.h"

#include "Alloc.h"
#include "defragcommon.h"

#define THIS_MODULE 'M'
#include "logfile.h"





#if OPTLONGLONGMATH
#define DIVIDELONGLONGBY32(num)        Int64ShraMod32((num), 5)
#define MODULUSLONGLONGBY32(num)       ((num) & 0x1F)
#else
#define DIVIDELONGLONGBY32(num)        ((num) / 32)
#define MODULUSLONGLONGBY32(num)       ((num) % 32)
#endif


/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    The main process of the MFT Defrag functionality
    MFT Defrag defragments the MFT file. If the MFT (minus the first extent that includes the 
    first 16 records)  is in two fragments, find a empty space to move it to, and move it, else
    dont move it if a space big enough is not found

INPUT:
        HANDLE hVolumeHandle            Handle to the Volume 
        LONGLONG BitmapSize             The size of the bitmap, since its already known 
        LONGLONG BytesPerSector         The number of Bytes per Sector 
        LONGLONG TotalClusters          Total number of clusters on the drive
        ULONGLONG MftZoneStart          The Cluster Number of the start of the MFT Zone
        ULONGLONG MftZoneEnd            The Cluster Number of the end of the MFT Zone
        TCHAR tDrive                    The current drive letter
RETURN:
        return TRUE if I was able to defragment the MFT, else I return FALSE if an error occured.
*/
BOOL MFTDefrag(
        IN HANDLE hVolumeHandle,
        IN LONGLONG BitmapSize, 
        IN LONGLONG BytesPerSector, 
        IN LONGLONG TotalClusters,
        IN ULONGLONG MftZoneStart,
        IN ULONGLONG MftZoneEnd,
        IN TCHAR tDrive,
        IN LONGLONG ClustersPerFRS 
        )
{

    HANDLE hMFTHandle = NULL;                               //Handle to the MFT file.

    LONGLONG lFirstAvailableFreeSpace = 0;      //the first available free space on the disk dig enough to move to
    ULONGLONG ulMFTsize = 0;                        //size in clusters of how big the mft file is
    LONGLONG lMFTFragments = 0;                 //the number of fragments in the MFT after excluding the first 16 records
    LONGLONG lMFTStartingVcn = 0;               //the VCN of the MFT from record 17.
    BOOL bReturnValue = TRUE;                   //value to return

    //make sure the drive letter is upper case
    tDrive = towupper(tDrive);

    Trace(log, "Start: MFTDefrag");

    //get the handle to the MFT 
    TCHAR tMFTPath[100];                        //build the path to the MFT
    _stprintf(tMFTPath,TEXT("\\\\.\\%c:\\$MFT"),tDrive);
    
    hMFTHandle = CreateFile(tMFTPath, 
            0, 
            FILE_SHARE_READ|FILE_SHARE_WRITE, 
            NULL, 
            OPEN_EXISTING, 
            FILE_FLAG_NO_BUFFERING, 
            0);
    
    //check to make sure we got a valid handle (valid handle will be not NULL)
    if((hMFTHandle) && (hMFTHandle != INVALID_HANDLE_VALUE))
    {
        //get the size of the MFT minus the first extent in clusters.
        ulMFTsize = GetMFTSize(hMFTHandle, &lMFTFragments, &lMFTStartingVcn);
        if(lMFTStartingVcn > (ClustersPerFRS * 16))     //check to see if the first extent is beyond the first 16 record
        {
            if(lMFTFragments > 1)           //mft fragmented go ahead and try and move else just leave
            {       
            //find the first available chunk of free space that is available
            lFirstAvailableFreeSpace = FindFreeSpaceChunk(BitmapSize, BytesPerSector, 
                TotalClusters, ulMFTsize, TRUE, MftZoneStart, MftZoneEnd, hVolumeHandle);
                if(lFirstAvailableFreeSpace > 0)        //if the first available space is zero, nothing was found dont move
                {
                    //adjust the MFT size down by the size of the first extent, since we do not move
                    //the first extent
                    ulMFTsize = ulMFTsize - (ULONGLONG)lMFTStartingVcn;
                    //move the MFT to new location
                    if(!MoveFileLocation(hMFTHandle, lFirstAvailableFreeSpace, ulMFTsize, lMFTStartingVcn, hVolumeHandle))
                    {
                        //the move failed, so we return FALSE;
                        Trace(log, "MFTDefrag: MoveFileLocation failed");
                        bReturnValue = FALSE;
                    }
                }
            }
        } else
        {
            //the end of the first extent is not past record 16, so return FALSE;
            Trace(log, "MFTDefrag: End of first extent is not past record 16");
            bReturnValue = FALSE;
        }

        CloseHandle(hMFTHandle);
    } else
    {
        Trace(log, "MFTDefrag: Could not open %ws", tMFTPath);
        bReturnValue = FALSE;       //could not open the MFT
    } 

    Trace(log, "End: MFTDefrag (%s)", bReturnValue ? "succeeded" : "failed");
    return bReturnValue;    
}





/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Get the size of the MFT in clusters from calling FSCL_GET_RETRIEVAL_POINTERS.
    Also return the number of fragments in the MFT and the starting VCN of the second
    fragment of the MFT.

INPUT:
        HANDLE hMFTFile     The handle to the MFT File
RETURN:
        The size of the MFT file in clusters
        the number of fragments in the MFT
        the starting VCN of the MFT after the first extent
*/

ULONGLONG GetMFTSize(
        IN HANDLE hMFTHandle,
        OUT LONGLONG* lMFTFragments,
        OUT LONGLONG* lMFTStartingVcn
        )
{
    ULONGLONG                       ulSizeofFileInClusters = 0; //size of the file in clusters
    int                             i;
    ULONGLONG                       startVcn = 0;               //starting VCN of the file, always 0
    STARTING_VCN_INPUT_BUFFER       startingVcn;                //starting VCN Buffer
    ULONG                           BytesReturned = 0;          //number of bytes returned by ESDeviceIoControl 
    HANDLE                          hRetrievalPointersBuffer = NULL; //Handle to the Retrieval Pointers Buffer
    PRETRIEVAL_POINTERS_BUFFER      pRetrievalPointersBuffer = NULL; //pointer to the Retrieval Pointer
    PLARGE_INTEGER                  pRetrievalPointers = NULL;  //Pointer to retrieval pointers 
    ULONG                           RetrievalPointers = 0x100;  //Number of extents for the file, try 256 first
    BOOL                            bGetRetrievalPointersMore = TRUE;       //boolean to test the end of getting retrieval pointers
    BOOL                            bGetRetrievalPointersSuccess = TRUE;    //test if I was able to get retrieval pointers
    ULONG                           ulGlobalLockCount = 0;          //count the number of times I lock memory
    ULONG                           ii;                             //index 
    

    //initalize the values I give back incase I have an error
    *lMFTFragments = 0;
    *lMFTStartingVcn = 0;

    if (hMFTHandle == INVALID_HANDLE_VALUE) 
    {
        ulSizeofFileInClusters = 0;

    } else      //continue
    {
        //zero the memory of the starting VCN input buffer
        ZeroMemory(&startVcn, sizeof(STARTING_VCN_INPUT_BUFFER));

        //0.1E00 Read the retrieval pointers into a buffer in memory.
        while(bGetRetrievalPointersMore){
        
            //0.0E00 Allocate a RetrievalPointersBuffer.
            if(!AllocateMemory(sizeof(RETRIEVAL_POINTERS_BUFFER) + (RetrievalPointers * 2 * sizeof(LARGE_INTEGER)),
                      &hRetrievalPointersBuffer,
                      (void**)(PCHAR*)&pRetrievalPointersBuffer))
            {
                        ulSizeofFileInClusters = 0;
                        bGetRetrievalPointersSuccess = FALSE;
                        break;      //break out of the while loop
            }
            ulGlobalLockCount++;

            //call NTControlFile via ESDeviceIoControl to get a buffer with the 
            //retrieval pointers on the MFT.
            startingVcn.StartingVcn.QuadPart = 0;
            if(ESDeviceIoControl(hMFTHandle,
                         FSCTL_GET_RETRIEVAL_POINTERS,
                         &startingVcn,
                         sizeof(STARTING_VCN_INPUT_BUFFER),
                         pRetrievalPointersBuffer,
                         (DWORD)GlobalSize(hRetrievalPointersBuffer),
                         &BytesReturned,
                         NULL))
            {
                bGetRetrievalPointersMore = FALSE;
                bGetRetrievalPointersSuccess = TRUE;
            } else
            {

                //This occurs on a zero length file (no clusters allocated).
                if(GetLastError() == ERROR_HANDLE_EOF)
                {
                    //file is zero lenght, so return 0
                    //free the memory for the retrival pointers
                    //the while loop makes sure all occurances are unlocked
                    ulSizeofFileInClusters = 0;
                    bGetRetrievalPointersSuccess = FALSE;
                    break;      //break out of the while loop

                }

                //0.0E00 Check to see if the error is not because the buffer is too small.
                if(GetLastError() == ERROR_MORE_DATA)
                {
                    //0.1E00 Double the buffer size until it's large enough to hold the file's extent list.
                    RetrievalPointers *= 2;
                } else
                {
                    //some other error, return 0
                    //free the memory for the retrival pointers
                    //the while loop makes sure all occurances are unlocked
                    ulSizeofFileInClusters = 0;
                    bGetRetrievalPointersSuccess = FALSE;
                    break;      //break out of the while loop

                }
            }

        }
        if(bGetRetrievalPointersSuccess)        //continue processing if we were able to get retrieval pointers
        {
            //get the number of fragments in the MFT
            *lMFTFragments = pRetrievalPointersBuffer->ExtentCount;
            
            //get the size of the first extend for the starting VCN
            *lMFTStartingVcn = pRetrievalPointersBuffer->Extents[0].NextVcn.QuadPart - startVcn;

            //loop through the retrival pointer list and add up the size of the file
            startVcn = pRetrievalPointersBuffer->StartingVcn.QuadPart;
            for (i = 1; i < (ULONGLONG) pRetrievalPointersBuffer->ExtentCount; i++) 
            {
                ulSizeofFileInClusters += pRetrievalPointersBuffer->Extents[i].NextVcn.QuadPart - startVcn;
                startVcn = pRetrievalPointersBuffer->Extents[i].NextVcn.QuadPart;
            }

        }

        if(hRetrievalPointersBuffer != NULL)
        {
            //free the memory for the retrival pointers
            //the while loop makes sure all occurances are unlocked
            for (ii=0;ii< ulGlobalLockCount;ii++)
            {
                GlobalUnlock(hRetrievalPointersBuffer);
            }

            GlobalFree(hRetrievalPointersBuffer);
            hRetrievalPointersBuffer = NULL;
        }

    }
    return ulSizeofFileInClusters; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgsnap\dfrgsnap.cpp ===
// DfrgSnap.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		run nmake -f DfrgSnapps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "DfrgSnap.h"

#include "DfrgSnap_i.c"
#include "DfrgSnapin.h"

#include "DfrgUI_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DfrgSnapin, CDfrgSnapin)
	OBJECT_ENTRY(CLSID_DfrgSnapinAbout, CDfrgSnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        SHFusionInitialize(NULL);
		_Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
		DisableThreadLibraryCalls(hInstance);
	}
    else if (dwReason == DLL_PROCESS_DETACH) {
		_Module.Term();
        SHFusionUninitialize();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgsnap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DfrgSnap.rc
//
#define IDS_PROJNAME                    100
#define IDB_DFRGSNAPIN_16               101
#define IDB_DFRGSNAPIN_32               102
#define IDS_DFRGSNAPIN_DESC             103
#define IDS_DFRGSNAPIN_PROVIDER         104
#define IDS_DFRGSNAPIN_VERSION          105
#define IDR_DFRGSNAPIN                  106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        207
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgsnap\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include "atlwin.cpp"

/////////////////
// ESI Additions
const LPTSTR szDefragGUID = _T("{202D3AEF-2F0E-11D1-A1F6-0080C88593A5}");
//
///////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgsnap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CD83A789_6F75_11D2_A385_00609772642E__INCLUDED_)
#define AFX_STDAFX_H__CD83A789_6F75_11D2_A385_00609772642E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN64
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>

//////////////////////////////
// fixes problem with atlwin.h
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

DECLSPEC_IMPORT VOID APIENTRY DragAcceptFiles(HWND,BOOL);

#ifdef __cplusplus
}
#endif  /* __cplusplus */
// fixes problem with atlwin.h
//////////////////////////////

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//////////////////
// ESI additions
// Helper functions
template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        // todo TRACE(_T("Release called on NULL interface ptr\n"));
    }
}
extern const LPTSTR szDefragGUID;


#include <prsht.h>
#include <shfusion.h>

//
/////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CD83A789_6F75_11D2_A385_00609772642E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgsnap\dfrgsnapin.h ===
#ifndef __DFRGSNAPIN_H_
#define __DFRGSNAPIN_H_
#include "resource.h"
#include "DfrgCmn.h"
#include "DfrgRes.h"
#include "GetDfrgRes.h"
#include "errmacro.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include <atlsnap.h>
#include "DfrgSnapHelp.h"
#include "DfrgUI.h"

//#pragma message ("Please add the following to DllMain right after _Module.Init")
//#pragma message ("CSnapInItem::Init();")
//#error ""

///////////////////////////////
// mwp added for handling menu and toolbar messages
enum {
    // Identifiers for each of the commands/views to be inserted into the context menu.
    IDM_NOTHING, //This has to be zero to take up the zero values because a bug in MMC doesn't show tooltips for buttons with an ID of zero.
    IDM_ANALYZE,
    IDM_DEFRAG,
    IDM_CONTINUE,
    IDM_PAUSE,
    IDM_STOP,
    IDM_REFRESH,
    IDM_REPORT
};

enum CUSTOM_VIEW_ID {

    VIEW_DEFAULT_LV = 0,
    VIEW_DEFRAG_OCX = 1,
};

#define NUM_DEFRAG_BUTTONS 6

// end of ESI additions
///////////////////////////////

class CDfrgSnapinComponent;
class CDfrgSnapinData : public CSnapInItemImpl<CDfrgSnapinData>
{
public:
    ///////////////////////////////
    // ESI additions
    //TCHAR m_DefragmenterName[200];
    // end of ESI additions
    ///////////////////////////////
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    // esi OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    CComPtr<IControlbar> m_spControlBar;

    BEGIN_SNAPINCOMMAND_MAP(CDfrgSnapinData, FALSE)
    END_SNAPINCOMMAND_MAP()

    BEGIN_SNAPINTOOLBARID_MAP(CDfrgSnapinData)
        // Create toolbar resources with button dimensions 16x16
        // and add an entry to the MAP. You can add multiple toolbars
        // SNAPINTOOLBARID_ENTRY(Toolbar ID)
    END_SNAPINTOOLBARID_MAP()

    CDfrgSnapinData( bool fRemoted )
    {
        m_pComponent = NULL;
        m_fScopeItem = false;
        m_fRemoted = fRemoted;

        wcscpy(m_wstrColumnName, L"");
        wcscpy(m_wstrColumnType, L"");
        wcscpy(m_wstrColumnDesc, L"");
        
        VString msg(IDS_PRODUCT_NAME, GetDfrgResHandle());

        m_bstrDisplayName = msg.GetBuffer();                // base class
        if (msg.GetBuffer()) {
            wcsncpy(m_wstrColumnName, msg.GetBuffer(), 50);     // our copy
            m_wstrColumnName[50] = L'\0';
        }

        msg.Empty();
        msg.LoadString(IDS_COLUMN_TYPE, GetDfrgResHandle());
        if (msg.GetBuffer()) {
            wcsncpy(m_wstrColumnType, msg.GetBuffer(), 50);
            m_wstrColumnType[50] = L'\0';
        }

        msg.Empty();
        msg.LoadString(IDS_COLUMN_DESC, GetDfrgResHandle());
        if (msg.GetBuffer()) {
            wcsncpy(m_wstrColumnDesc, msg.GetBuffer(), 100);
            m_wstrColumnDesc[100] = L'\0';
        }

//      m_pResult       = NULL; // pointer to the IResultData interface
        m_CustomViewID  = VIEW_DEFRAG_OCX;

        // Image indexes may need to be modified depending on the images specific to
        // the snapin.
        memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
        m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
        m_scopeDataItem.displayname = (LPOLESTR)MMC_CALLBACK;
        m_scopeDataItem.nImage = 0;         // May need modification
        m_scopeDataItem.cChildren = 0;
        m_scopeDataItem.nOpenImage = 0;     // May need modification
        m_scopeDataItem.lParam = (LPARAM) this;
        memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
        m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        m_resultDataItem.str = (LPOLESTR)MMC_CALLBACK;
        m_resultDataItem.nImage = 0;        // May need modification
        m_resultDataItem.lParam = (LPARAM) this;
        ///////////////////////////////
        // ESI additions
        //m_SZDISPLAY_NAME = (LPOLESTR) CoTaskMemAlloc(200 * sizeof(OLECHAR));
        //LoadString(GetDfrgResHandle(), IDS_PRODUCT_NAME, m_DefragmenterName, 200);
        //m_SZDISPLAY_NAME = m_DefragmenterName;
        // end of ESI additions
        ///////////////////////////////

    }

    ~CDfrgSnapinData()
    {
        GetDfrgResHandle(TRUE); // this resets it

    }

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
        IComponentData* pComponentData,
        IComponent* pComponent,
        DATA_OBJECT_TYPES type);

    LPOLESTR GetResultPaneColInfo(int nCol);

    STDMETHOD(AddMenuItems)( LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
        DATA_OBJECT_TYPES type);

    STDMETHOD( GetResultViewType )( LPOLESTR* ppViewType, long* pViewOptions );
    STDMETHOD( FillData ) ( CLIPFORMAT cf, LPSTREAM pStream );

/*
    //
    // This is really just stubbed out for compliance with com.
    // The lifetime is managed by the node itself.
    //
    STDMETHOD(QueryInterface)(REFIID riid,void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void) { return InterlockedIncrement(&m_cRef); };
    STDMETHODIMP_(ULONG) Release(void);
*/

    void SetActiveControl( BOOL bActive, IComponent* pComponent );

protected:
    bool m_fRemoted;
    BOOL m_fScopeItem;

    OLECHAR m_wstrColumnName[50 + 1];
    OLECHAR m_wstrColumnType[50 + 1];
    OLECHAR m_wstrColumnDesc[100 + 1];

    //
    // Used to track the last valid component, for
    // update purposes.
    //
    CDfrgSnapinComponent* m_pComponent;

//  HRESULT InitializeOCX(); // inits the Dispatch interface to the OCX
    CUSTOM_VIEW_ID m_CustomViewID;
//    LPCONSOLE m_pConsole; // Console's IFrame interface
    CComQIPtr<IDispatch,&IID_IDispatch> m_iDfrgCtlDispatch;
//    IDispatch FAR* m_iDfrgCtlDispatch;  // Dispatch interface to the OCX
//    LPRESULTDATA m_pResult; // pointer to the IResultData interface
    HRESULT OnShow( LPARAM isShowing, IResultData* pResults );

    BOOL GetSessionState( LPDISPATCH pControl, UINT sessionState );
    // These are the Dispatch functions to get/send data from the OCX
    BOOL SendCommand( LPARAM lparamCommand );
    short GetEngineState();
    STDMETHOD( Command )(long lCommandID,       
        CSnapInObjectRootBase* pObj,        
        DATA_OBJECT_TYPES type);

};


//////////////////////////////////////
// New Extension code
class CDfrgSnapinExtData : public CSnapInItemImpl<CDfrgSnapinExtData, TRUE>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    CDfrgSnapinExtData()
    {
        m_pNode = NULL;
        memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
        memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
    }

    ~CDfrgSnapinExtData()
    {
        if ( m_pNode != NULL )
            delete m_pNode;
    }

    IDataObject* m_pDataObject;
    virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
    {
        m_pDataObject = pDataObject;
        // The default code stores off the pointer to the Dataobject the class is wrapping
        // at the time.
        // Alternatively you could convert the dataobject to the internal format
        // it represents and store that information
    }

    CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
    {
        // Modify to return a different CSnapInItem* pointer.
        return pDefault;
    }

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
        IComponentData* pComponentData,
        IComponent* pComponent,
        DATA_OBJECT_TYPES type);

    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
    {
        return( S_OK );
    }

protected:
        CSnapInItem* m_pNode;
};
// New Extension code end
//////////////////////////////////////


class CDfrgSnapin;

class CDfrgSnapinComponent : public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<2, CDfrgSnapin >,
    //public IExtendControlbarImpl<CDfrgSnapinComponent>,
    public IComponentImpl<CDfrgSnapinComponent>,
    public IExtendContextMenuImpl<CDfrgSnapin>,
    public IDfrgEvents
{
public:
BEGIN_COM_MAP(CDfrgSnapinComponent)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IDfrgEvents)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    //COM_INTERFACE_ENTRY(IExtendControlbar)
END_COM_MAP()

public:
    CDfrgSnapinComponent();
    /////////////////
    // ESI start
    ~CDfrgSnapinComponent();
    // ESI end
    ////////////////////
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
    {
        HRESULT hr = E_UNEXPECTED;

        //
        // Check for a special data object being sent.
        //
        if ( IS_SPECIAL_DATAOBJECT( lpDataObject ) )
            return( S_OK );

        if (lpDataObject != NULL)
        {
                //
                // Call our default handling.
                //
                hr = IComponentImpl<CDfrgSnapinComponent>::Notify(lpDataObject, event, arg, param);
        }

        return( hr );
    }

    void SetControl( LPDISPATCH pDisp )
    {
        if ( pDisp == NULL )
            Unadvise();

        m_spDisp = pDisp;

        if ( pDisp != NULL )
            Advise();
    }

    LPDISPATCH GetControl()
    {
        return( m_spDisp );
    }

    //
    // Status changes from the OCX.
    //
    STDMETHOD( StatusChanged )( BSTR bszStatus );

    //
    // Ok To Run status message from the OCX.
    //
    STDMETHOD( IsOKToRun )( BOOL bOK );

    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed);
    
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject);

protected:
    //
    // Interface to control.
    //
    CComQIPtr<IDispatch,&IID_IDispatch> m_spDisp;

    //
    // Sets up the connection point.
    //
    void Advise();
    void Unadvise();
    DWORD m_dwAdvise;
};

class CDfrgSnapin : public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<1, CDfrgSnapin>,
    public IComponentDataImpl<CDfrgSnapin, CDfrgSnapinComponent>,
    public CComCoClass<CDfrgSnapin, &CLSID_DfrgSnapin>,
    public IExtendContextMenuImpl<CDfrgSnapin>,
    public ISnapinHelpImpl<CDfrgSnapin>
{
public:
    // bitmaps associated with the scope pane
    HBITMAP m_hBitmap16;
    HBITMAP m_hBitmap32;

    CDfrgSnapin()
    {
        m_pNode = new CDfrgSnapinData( false );
        _ASSERTE(m_pNode != NULL);
        m_pComponentData = this;

        m_fRemoted = false;
        m_ccfRemotedFormat = 0;
        RegisterRemotedClass();

        m_hBitmap16 = m_hBitmap32 = NULL;

    }

    ~CDfrgSnapin()
    {
        if (m_hBitmap16){
            ::DeleteObject(m_hBitmap16);
        }

        if (m_hBitmap32){
            ::DeleteObject(m_hBitmap32);
        }

        delete m_pNode;
        m_pNode = NULL;
    }

//////////////////////////////////////
// New Extension code
EXTENSION_SNAPIN_DATACLASS(CDfrgSnapinExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CDfrgSnapin)
    EXTENSION_SNAPIN_NODEINFO_ENTRY(CDfrgSnapinExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()
// New Extension code end
//////////////////////////////////////

BEGIN_COM_MAP(CDfrgSnapin)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

// commented out and replaced below
//DECLARE_REGISTRY_RESOURCEID(IDR_DFRGSNAPIN)

    // with the following code (to support localization of the Project Name)
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
    {
        USES_CONVERSION;

        // name of the snapin is stored in the string resource IDS_PROJNAME

        const int nBufferMax = 128;
        TCHAR tszData[nBufferMax + 1];

        // this name string is used to populate the Add/Remove snapin dialog in MMC
        if (LoadString(_Module.GetModuleInstance(), IDS_PROJNAME, tszData, nBufferMax) == 0)
        {
            _ASSERTE(FALSE);
            return E_FAIL;
        }

        LPCOLESTR szData = T2OLE(tszData);
        if (szData == NULL)
            return E_OUTOFMEMORY;

        _ATL_REGMAP_ENTRY re[] = {L"SNAPINNAME", szData, NULL, NULL};
        
        // I don't just do "return _Module.UpdateRegistryFromResource" as
        // szData would get destroyed before the method finishes

        HRESULT hr = _Module.UpdateRegistryFromResource(IDR_DFRGSNAPIN, bRegister, re);

        return hr;
    }


DECLARE_NOT_AGGREGATABLE(CDfrgSnapin)

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

    static void WINAPI ObjectMain(bool bStarting)
    {
        if (bStarting)
            CSnapInItem::Init();
    }
    // ESI end
    //////////////////////////

    STDMETHOD(Notify)( LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
    {
        HRESULT hr = E_UNEXPECTED;

        if (lpDataObject != NULL)
        {
            switch ( event )
            {
            case MMCN_EXPAND:
                {
                    //
                    // Process out the local or machine name if we're expanding.
                    //
                    if ( arg == TRUE )
                        m_fRemoted = IsDataObjectRemoted( lpDataObject );

                    //
                    // Intentionally left to fall through to default handler.
                    //
                }
            default:
                {
                    //
                    // Call our default handling.
                    //
                    hr = IComponentDataImpl<CDfrgSnapin, CDfrgSnapinComponent>::Notify( lpDataObject, event, arg, param );
                }
            }
        }

        return( hr );
    }

    //
    // Accessor for the remoted state.
    //
    bool IsRemoted()
    {
        return( m_fRemoted );
    }

protected:
    //
    // Determine if we're monitoring a local or remote machine based on the given data object.
    //
    bool IsDataObjectRemoted( IDataObject* pDataObject );

    //
    // Retrieves the value of a given clipboard format from a given data object.
    //
    bool ExtractString( IDataObject* pDataObject, unsigned int cfClipFormat, LPTSTR pBuf, DWORD dwMaxLength );

    //
    // Register the clipboard format and get the value to query on.
    //
    void RegisterRemotedClass()
    {
        m_ccfRemotedFormat = RegisterClipboardFormat( _T( "MMC_SNAPIN_MACHINE_NAME" ) );
        _ASSERTE( m_ccfRemotedFormat > 0 );
    }

    //
    // Used to track whether we're remoted or not.
    //
    bool m_fRemoted;

    //
    // Initialized by RegisterRemoteClass(). Contains the clipboard ID
    // of MMC_SNAPIN_MACHINE_NAME after registered with the clipboard.
    //
    UINT m_ccfRemotedFormat;
};

class ATL_NO_VTABLE CDfrgSnapinAbout : public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass< CDfrgSnapinAbout, &CLSID_DfrgSnapinAbout>
{
public:
    DECLARE_REGISTRY(CDfrgSnapinAbout, _T("DfrgSnapinAbout.1"), _T("DfrgSnapinAbout.1"), IDS_DFRGSNAPIN_DESC, THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CDfrgSnapinAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(GetDfrgResHandle(), IDS_SNAPIN_DESCRIPTION, szBuf, 256) == 0)
            return E_FAIL;

        *lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpDescription == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpDescription, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(GetDfrgResHandle(), IDS_SNAPIN_PROVIDER, szBuf, 256) == 0)
            return E_FAIL;

        *lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpName == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpName, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {
        USES_CONVERSION;
        TCHAR szBuf[256];
        if (::LoadString(GetDfrgResHandle(), IDS_SNAPIN_VERSION, szBuf, 256) == 0)
            return E_FAIL;

        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if (*lpVersion == NULL)
            return E_OUTOFMEMORY;

        ocscpy(*lpVersion, T2OLE(szBuf));

        return S_OK;
    }

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
    {
        *hAppIcon = ::LoadIcon(GetDfrgResHandle(), MAKEINTRESOURCE(IDI_DEFRAG_ICON));
        if (*hAppIcon == NULL)
            return E_FAIL;

        return S_OK;
    }

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
        HBITMAP *hSmallImageOpen,
        HBITMAP *hLargeImage,
        COLORREF *cMask)
    {
        *hSmallImageOpen = *hLargeImage = *hLargeImage = 0;

        if( NULL == (*hSmallImageOpen = (HBITMAP) LoadImage(
            GetDfrgResHandle(),
            MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_16),  // name or identifier of image
            IMAGE_BITMAP,        // type of image
            0,     // desired width
            0,     // desired height
            LR_DEFAULTCOLOR        // load flags
            ) ) )
        {
            return E_FAIL;
        }


        if( NULL == (*hSmallImage = (HBITMAP) LoadImage(
            GetDfrgResHandle(),   // handle of the instance that contains the image
            MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_16),  // name or identifier of image
            IMAGE_BITMAP,        // type of image
            0,     // desired width
            0,     // desired height
            LR_DEFAULTCOLOR        // load flags
            ) ) )
        {
            return E_FAIL;
        }

        if( NULL == (*hLargeImage = (HBITMAP) LoadImage(
            GetDfrgResHandle(),   // handle of the instance that contains the image
            MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_32),  // name or identifier of image
            IMAGE_BITMAP,        // type of image
            0,     // desired width
            0,     // desired height
            LR_DEFAULTCOLOR        // load flags
            ) ) )
        {
            return E_FAIL;
        }

        // ISSUE: Need to worry about releasing these bitmaps.
        *cMask = RGB(255, 255, 255);

        return S_OK;
    }
};

//////////////////////////////////////
// ESI start
//////////////////////////////////////////////////
// These constants are used with GetSessionState()
//////////////////////////////////////////////////
#define IS_ENGINE_PAUSED        0
#define IS_ENGINE_RUNNING       1
#define IS_DEFRAG_IN_PROCESS    2
#define IS_VOLLIST_LOCKED       3
#define IS_REPORT_AVAILABLE     4
#define IS_OK_TO_RUN            5
#define DFRG_INTERFACE_COUNT    6
// ESI end
///////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgsnap\dfrgsnapin.cpp ===
#include "stdafx.h"
#include "DfrgSnap.h"
#include "DfrgSnapin.h"
#include "resource.h"
#include "GetDfrgRes.h"
#include "Message.h"
#include "ErrMacro.h"
#include "vString.hpp"



/////////////////////////////////////////////////////////////////////////////
// CDfrgSnapinComponentData
//static const GUID CDfrgSnapinGUID_NODETYPE = 
//{ 0xcd83a794, 0x6f75, 0x11d2, { 0xa3, 0x85, 0x0, 0x60, 0x97, 0x72, 0x64, 0x2e } };
static const GUID CDfrgSnapinGUID_NODETYPE = 
{ 0x43668e22, 0x2636, 0x11d1, { 0xa1, 0xce, 0x0, 0x80, 0xc8, 0x85, 0x93, 0xa5 } };
const GUID*  CDfrgSnapinData::m_NODETYPE = &CDfrgSnapinGUID_NODETYPE;
// original const OLECHAR* CDfrgSnapinData::m_SZNODETYPE = OLESTR("CD83A794-6F75-11D2-A385-00609772642E");
const OLECHAR* CDfrgSnapinData::m_SZNODETYPE = OLESTR("43668E22-2636-11D1-A1CE-0080C88593A5");
const OLECHAR* CDfrgSnapinData::m_SZDISPLAY_NAME = OLESTR("Disk Defragmenter");
const CLSID* CDfrgSnapinData::m_SNAPIN_CLASSID = &CLSID_DfrgSnapin;

//////////////////////////////////////
// New Extension code
static const GUID CDfrgSnapinExtGUID_NODETYPE = 
{ 0x476e644a, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CDfrgSnapinExtData::m_NODETYPE = &CDfrgSnapinExtGUID_NODETYPE;
const OLECHAR* CDfrgSnapinExtData::m_SZNODETYPE = OLESTR("476e644a-aaff-11d0-b944-00c04fd8d5b0");
//sks bug # 94863, storing text "disk Defragmenter" in the registry. took out the words
//disk defragmenter, because it is loaded from the resources in the override method.
const OLECHAR* CDfrgSnapinExtData::m_SZDISPLAY_NAME = OLESTR("");

const CLSID* CDfrgSnapinExtData::m_SNAPIN_CLASSID = &CLSID_DfrgSnapin;
// New Extension code end
//////////////////////////////////////

HRESULT CDfrgSnapinData::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
    //TCHAR szBuf[ 256 ];
    //wsprintf( szBuf, _T( "Mask is %d\n" ), pScopeDataItem->mask );
    //OutputDebugString( szBuf );

    if (pScopeDataItem->mask & SDI_STR)
        pScopeDataItem->displayname = m_bstrDisplayName;
    if (pScopeDataItem->mask & SDI_IMAGE)
        pScopeDataItem->nImage = m_scopeDataItem.nImage;
    if (pScopeDataItem->mask & SDI_OPENIMAGE)
        pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
    if (pScopeDataItem->mask & SDI_PARAM)
        pScopeDataItem->lParam = m_scopeDataItem.lParam;
    if (pScopeDataItem->mask & SDI_STATE )
        pScopeDataItem->nState = m_scopeDataItem.nState;

    // TODO : Add code for SDI_CHILDREN 
    return S_OK;
}

HRESULT CDfrgSnapinData::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
    //TCHAR szBuf[ 256 ];
    //wsprintf( szBuf, _T( "Mask is %d\n" ), pResultDataItem->mask );
    //OutputDebugString( szBuf );

    if (pResultDataItem->bScopeItem)
    {
        if (pResultDataItem->mask & RDI_STR)
        {
            pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
        }
        if (pResultDataItem->mask & RDI_IMAGE)
        {
            pResultDataItem->nImage = m_scopeDataItem.nImage;
        }
        if (pResultDataItem->mask & RDI_PARAM)
        {
            pResultDataItem->lParam = m_scopeDataItem.lParam;
        }

        return S_OK;
    }

    if (pResultDataItem->mask & RDI_STR)
    {
        pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
    }
    if (pResultDataItem->mask & RDI_IMAGE)
    {
        pResultDataItem->nImage = m_resultDataItem.nImage;
    }
    if (pResultDataItem->mask & RDI_PARAM)
    {
        pResultDataItem->lParam = m_resultDataItem.lParam;
    }
    if (pResultDataItem->mask & RDI_INDEX)
    {
        pResultDataItem->nIndex = m_resultDataItem.nIndex;
    }

    return S_OK;
}

HRESULT CDfrgSnapinData::Notify(
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param,
    IComponentData* pComponentData,
    IComponent* pComponent,
    DATA_OBJECT_TYPES type)
{
    // Add code to handle the different notifications.
    // Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
    // In response to MMCN_SHOW you have to enumerate both the scope
    // and result pane items.
    // For MMCN_EXPAND you only need to enumerate the scope items
    // Use IConsoleNameSpace::InsertItem to insert scope pane items
    // Use IResultData::InsertItem to insert result pane item.
    HRESULT hr = E_NOTIMPL;
    
    _ASSERTE(pComponentData != NULL || pComponent != NULL);

    CComPtr<IConsole> spConsole;
    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
    if (pComponentData != NULL)
        spConsole = ((CDfrgSnapin*)pComponentData)->m_spConsole;
    else
    {
        spConsole = ((CDfrgSnapinComponent*)pComponent)->m_spConsole;
        spHeader = spConsole;
    }

    switch (event)
    {
    case MMCN_SELECT:
        {
            //
            // Always track the last valid component.
            //
            if ( HIWORD( arg ) == TRUE && pComponent )
                m_pComponent = (CDfrgSnapinComponent*) pComponent;

            //
            // Always track whether or not we're a scope item.
            //
            m_fScopeItem = LOWORD( arg );

            hr = S_OK;
        }
        break;
    case MMCN_RESTORE_VIEW:
        {
            //
            // Determines whether or not the remoted or OCX is displayed.
            //
            *( (BOOL*)param ) = TRUE;
            hr = S_OK;
        }
        break;
    case MMCN_CONTEXTHELP:
        {
            CComQIPtr<IDisplayHelp,&IID_IDisplayHelp> spHelp = spConsole;
            spHelp->ShowTopic( CoTaskDupString( OLESTR( "defrag.chm::/defrag_overview.htm" ) ) );
            hr = S_OK;
        }
        break;
    case MMCN_DBLCLICK:
        {
            hr = S_FALSE;
        }
        break;
    case MMCN_INITOCX:
        {
            hr = S_OK;
            break;
        }
    case MMCN_SHOW:
        {
            CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
            if(arg == 0)
            {
                SetActiveControl(FALSE, pComponent );

            } else
            {
                SetActiveControl(TRUE, pComponent );
            } 

            hr = OnShow( arg, spResultData );
            break;
        }
    case MMCN_EXPAND:
        {
            CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
            // TODO : Enumerate scope pane items
            hr = S_OK;
            break;
        }
    case MMCN_ADD_IMAGES:
        {
            // Add Images
            IImageList* pImageList = (IImageList*)arg;
            hr = E_FAIL;

            // Load bitmaps associated with the scope pane
            // and add them to the image list
            // Loads the default bitmaps generated by the wizard
            // Change as required
            HBITMAP hBitmap16 = (HBITMAP) LoadImage(
                                    GetDfrgResHandle(),   // handle of the instance that contains the image  
                                    MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_16),  // name or identifier of image
                                    IMAGE_BITMAP,        // type of image  
                                    0,     // desired width
                                    0,     // desired height  
                                    LR_DEFAULTCOLOR        // load flags
                                    );

            if (hBitmap16 != NULL)
            {
                HBITMAP hBitmap32 = (HBITMAP ) LoadImage(
                                        GetDfrgResHandle(),
                                        MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_32),  // name or identifier of image
                                        IMAGE_BITMAP,        // type of image  
                                        0,     // desired width
                                        0,     // desired height  
                                        LR_DEFAULTCOLOR        // load flags
                                        );
                if (hBitmap32 != NULL)
                {
                    hr = pImageList->ImageListSetStrip((LONG_PTR *)hBitmap16, 
                    (LONG_PTR *)hBitmap32, 0, RGB(255, 255, 255));
                    if (FAILED(hr))
                        ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
                    ::DeleteObject(hBitmap32);
                    hBitmap32 = NULL;
                }
                ::DeleteObject(hBitmap16);
                hBitmap16 = NULL;
            }
            break;
        }
    }
    return hr;
}

LPOLESTR CDfrgSnapinData::GetResultPaneColInfo(int nCol)
{
    //
    // 12/13/99 This method is prototyped to return a pointer to an OLESTR which is 
    // an OLECHAR array.  Since this is a COM interface we should be using 
    // CoTaskMemAlloc to allocate space for a copy and then copy it in.  
    // The caller is then expected to free it.  However per the MMC PM they are not 
    // freeing it and probably cannot now or they would break too many snap-ins.
    //
    // So until they change which will probably be never, I will temporarily just 
    // copy into a static and return a pointer to it.  That way no one gets a 
    // pointer internal to our snap-in object, and we don't leak either.
    //
    LPOLESTR        pStr = NULL;
    static OLECHAR  ColumnName[50 + 1];
    static OLECHAR  ColumnType[50 + 1];
    static OLECHAR  ColumnDesc[100 + 1];

    switch (nCol)
    {
    case 0:
        wcsncpy(ColumnName, m_wstrColumnName, 50);
        ColumnName[50] = 0;
        pStr = ColumnName;
        break;

    case 1:
        wcsncpy(ColumnType, m_wstrColumnType, 50);
        ColumnType[50] = 0;
        pStr = ColumnType;
        break;

    case 2:
        wcsncpy(ColumnDesc, m_wstrColumnDesc, 100);
        ColumnDesc[100] = 0;
        pStr = ColumnDesc;
        break;
    }

    return(pStr);
}

HRESULT CDfrgSnapin::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr = IComponentDataImpl<CDfrgSnapin, CDfrgSnapinComponent >::Initialize(pUnknown);
    if (FAILED(hr))
        return hr;

    CComPtr<IImageList> spImageList;

    if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
    {
        ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
        return E_UNEXPECTED;
    }

    // Load bitmaps associated with the scope pane
    // and add them to the image list
    // Loads the default bitmaps generated by the wizard
    // Change as required
    m_hBitmap16 = LoadBitmap( GetDfrgResHandle(), MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_16));
    if (m_hBitmap16 == NULL)
        return S_OK;

    m_hBitmap32 = LoadBitmap( GetDfrgResHandle(), MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_32));
    if (m_hBitmap32 == NULL) {

        ::DeleteObject(m_hBitmap16);
        m_hBitmap16 = NULL;

        return S_OK;
    }

    if (spImageList->ImageListSetStrip(
        (LONG_PTR *)m_hBitmap16, 
        (LONG_PTR *)m_hBitmap32,
        0, RGB(255, 255, 255)) != S_OK)
    {
        ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
        
        ::DeleteObject(m_hBitmap16);
        m_hBitmap16 = NULL;

        ::DeleteObject(m_hBitmap32);
        m_hBitmap32 = NULL;

        return E_UNEXPECTED;
    }

    ::DeleteObject(m_hBitmap16);
    m_hBitmap16 = NULL;

    ::DeleteObject(m_hBitmap32);
    m_hBitmap32 = NULL;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// ESI Code Start

///////////////////////////////////
// IExtendContextMenu::AddMenuItems()
STDMETHODIMP CDfrgSnapinData::AddMenuItems(
    LPCONTEXTMENUCALLBACK pContextMenuCallback,
    long  *pInsertionAllowed,
    DATA_OBJECT_TYPES type)
{

    Message(TEXT("CDfrgSnapinData::AddMenuItems"), -1, NULL);

    HRESULT hr = S_OK;

    // Note - snap-ins need to look at the data object and determine
    // in what context, menu items need to be added. They must also
    // observe the insertion allowed flags to see what items can be 
    // added.
    /* handy comment:
    typedef struct  _CONTEXTMENUITEM
        {
        LPWSTR strName;
        LPWSTR strStatusBarText;
        LONG lCommandID;
        LONG lInsertionPointID;
        LONG fFlags;
        LONG fSpecialFlags;
        }   CONTEXTMENUITEM;
    */

    HINSTANCE hDfrgRes = GetDfrgResHandle();
    CONTEXTMENUITEM singleMenuItem;
    TCHAR menuText[200];
    TCHAR statusBarText[300];

    //
    // Retrieve the control from the current component.
    //
    assert( m_pComponent != NULL );
    CComPtr<IDispatch> spDispCtl = m_pComponent->GetControl();

    singleMenuItem.strName = menuText;
    singleMenuItem.strStatusBarText = statusBarText;
    singleMenuItem.fFlags = 0;
    singleMenuItem.fSpecialFlags = 0;

    // Add each of the items to the Action menu
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) {

        // setting for the Action menu
        singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;

        // get the state of the current engine
        BOOL isOkToRun = GetSessionState( spDispCtl, IS_OK_TO_RUN);

        if (isOkToRun && m_fScopeItem){
            BOOL isEnginePaused = GetSessionState(spDispCtl, IS_ENGINE_PAUSED);
            BOOL isEngineRunning = GetSessionState(spDispCtl, IS_ENGINE_RUNNING);
            BOOL isVolListLocked = GetSessionState(spDispCtl, IS_VOLLIST_LOCKED);
            BOOL isDefragInProcess = GetSessionState(spDispCtl, IS_DEFRAG_IN_PROCESS);
            BOOL isReportAvailable = GetSessionState(spDispCtl, IS_REPORT_AVAILABLE);

            // get the proper button states
            LONG analyzeFlags=0;
            LONG defragFlags=0;
            LONG pauseFlags=0;
            LONG stopFlags=0;
            LONG seeReportFlags=0;

            if (isVolListLocked){ // turn off all buttons if this volume is locked
                analyzeFlags = 
                defragFlags =
                pauseFlags =
                stopFlags =
                seeReportFlags = MF_DISABLED|MF_GRAYED;
            }
            else if (isEngineRunning){
                analyzeFlags = defragFlags = seeReportFlags = MF_DISABLED|MF_GRAYED;
                pauseFlags = stopFlags = MF_ENABLED;
            }
            else{ // neither defrag nor analyze are not running on any volumes
                analyzeFlags = defragFlags = MF_ENABLED;
                pauseFlags = stopFlags = MF_DISABLED|MF_GRAYED;
            
                // is the report available for the currently selected volume?
                seeReportFlags = isReportAvailable ? MF_ENABLED : MF_DISABLED|MF_GRAYED;
            }

            // analyze
            singleMenuItem.lCommandID = IDM_ANALYZE;
            singleMenuItem.fFlags = analyzeFlags;
            LoadString(hDfrgRes, IDS_ANALYZE, menuText, sizeof(menuText) / sizeof(TCHAR));
            LoadString(hDfrgRes, IDS_ANALYZE_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
            hr = pContextMenuCallback->AddItem(&singleMenuItem);
            if (FAILED(hr)) {
                Message(TEXT("CComponentDataImpl::AddMenuItems - pContextMenuCallback->AddItem"), hr, NULL);
                return hr;
            }

            // defrag
            singleMenuItem.lCommandID = IDM_DEFRAG;
            singleMenuItem.fFlags = defragFlags;
            LoadString(hDfrgRes, IDS_DEFRAGMENT, menuText, sizeof(menuText) / sizeof(TCHAR));
            LoadString(hDfrgRes, IDS_DEFRAG_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
            hr = pContextMenuCallback->AddItem(&singleMenuItem);
            if (FAILED(hr)) {
                Message(TEXT("CComponentDataImpl::AddMenuItems - pContextMenuCallback->AddItem"), hr, NULL);
                return hr;
            }

            // pause and resume button
            singleMenuItem.fFlags = pauseFlags;
            if (isEnginePaused) // resume
            {
                singleMenuItem.lCommandID = IDM_CONTINUE;
                LoadString(hDfrgRes, IDS_RESUME, menuText, sizeof(menuText) / sizeof(TCHAR));
                LoadString(hDfrgRes, IDS_RESUME_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
            }
            else{ // pause button
                singleMenuItem.lCommandID = IDM_PAUSE;
                LoadString(hDfrgRes, IDS_PAUSE, menuText, sizeof(menuText) / sizeof(TCHAR));
                LoadString(hDfrgRes, IDS_PAUSE_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
            }

            // add the pause/resume button
            hr = pContextMenuCallback->AddItem(&singleMenuItem);
            if (FAILED(hr)) {
                Message(TEXT("CComponentDataImpl::AddMenuItems - pContextMenuCallback->AddItem"), hr, NULL);
                return hr;
            }

            // stop
            singleMenuItem.lCommandID = IDM_STOP;
            singleMenuItem.fFlags = stopFlags;
            LoadString(hDfrgRes, IDS_STOP, menuText, sizeof(menuText) / sizeof(TCHAR));
            LoadString(hDfrgRes, IDS_STOP_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
            hr = pContextMenuCallback->AddItem(&singleMenuItem);
            if (FAILED(hr)) {
                Message(TEXT("CComponentDataImpl::AddMenuItems - pContextMenuCallback->AddItem"), hr, NULL);
                return hr;
            }

            // See Report
            singleMenuItem.lCommandID = IDM_REPORT;
            singleMenuItem.fFlags = seeReportFlags;
            LoadString(hDfrgRes, IDS_REPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
            LoadString(hDfrgRes, IDS_REPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
            hr = pContextMenuCallback->AddItem(&singleMenuItem);
            if (FAILED(hr)) {
                Message(TEXT("CComponentDataImpl::AddMenuItems - pContextMenuCallback->AddItem"), hr, NULL);
                return hr;
            }

            // spacer
            singleMenuItem.fFlags = MF_SEPARATOR;
            hr = pContextMenuCallback->AddItem(&singleMenuItem);
            if (FAILED(hr)) {
                Message(TEXT("CComponentDataImpl::AddMenuItems - pContextMenuCallback->AddItem"), hr, NULL);
                return hr;
            }

            // Refresh the list view
            singleMenuItem.lCommandID = IDM_REFRESH;
            singleMenuItem.fFlags = MF_ENABLED;
            LoadString(hDfrgRes, IDS_REFRESH, menuText, sizeof(menuText) / sizeof(TCHAR));
            LoadString(hDfrgRes, IDS_REFRESH_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
            hr = pContextMenuCallback->AddItem(&singleMenuItem);
            if (FAILED(hr)) {
                Message(TEXT("CComponentDataImpl::AddMenuItems - pContextMenuCallback->AddItem"), hr, NULL);
                return hr;
            }


        }// end of IsOkToRun
    } 

    // add the view items
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) {

    }
    return hr;
}

///////////////////////////////////
// IExtendContextMenu::Command()
STDMETHODIMP CDfrgSnapinData::Command(long lCommandID,      
        CSnapInObjectRootBase* pObj,        
        DATA_OBJECT_TYPES type)
{
    Message(TEXT("CDfrgSnapinData::Command"), -1, NULL);

    // Handle each of the commands.
    switch (lCommandID) {

    case IDM_ANALYZE:
        SendCommand(ID_ANALYZE);
        break;

    case IDM_DEFRAG:
        SendCommand(ID_DEFRAG);
        break;

    case IDM_CONTINUE:
        SendCommand(ID_CONTINUE);
        break;

    case IDM_PAUSE:
        SendCommand(ID_PAUSE);
        break;

    case IDM_STOP:
        SendCommand(ID_STOP);
        break;

    case IDM_REPORT:
        SendCommand(ID_REPORT);
        break;

    case IDM_REFRESH:
        SendCommand(ID_REFRESH);
        break;

    default:
        break;
    }

    return S_OK;
}

// contructor added by ESI
CDfrgSnapinComponent::CDfrgSnapinComponent()
{

    Message(TEXT("CSnapinApp::InitInstance"), -1, NULL);
    /*
    Message(TEXT("CDefragSnapinComponent::CDefragSnapinComponent"), -1, NULL);
    m_pHeader           = NULL;
    m_pComponentData    = NULL;
    //m_pToolbar1         = NULL;
    //m_pControlbar       = NULL;
    //m_pbmpToolbar1      = NULL;
    m_pConsoleVerb      = NULL;
    //m_pDfrgCtl          = NULL;
    */

    m_dwAdvise = 0;
}

CDfrgSnapinComponent::~CDfrgSnapinComponent()
{
    Message(TEXT("CSnapinApp::ExitInstance"), -1, NULL);
}

/*
///////////////////////////////////////////////////////////////////////////////////////////////////
// Implementation of IComponent::Notify()
STDMETHODIMP CDfrgSnapinComponent::Notify(
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    long arg,
    long param)
{
    long cookie = 0;
    HRESULT hr = S_OK;
    TCHAR cString[64];

    switch(event) {

    case MMCN_PROPERTY_CHANGE:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_PROPERTY_CHANGE"), -1, NULL);
        break;

    case MMCN_VIEW_CHANGE:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_VIEW_CHANGE"), -1, NULL);
        break;

    case MMCN_ACTIVATE:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_ACTIVATE"), -1, NULL);
        //hr = OnActivate(cookie, arg, param);
        break;

    case MMCN_CLICK:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_CLICK"), -1, NULL);
        break;

    case MMCN_DBLCLICK:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_DBLCLICK"), -1, NULL);
        hr = S_FALSE; // false indicates that this is not implemented
        break;

    case MMCN_ADD_IMAGES:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_ADD_IMAGES"), -1, NULL);
        break;

    case MMCN_SHOW:
        hr = OnShow(arg);
        break;

    case MMCN_MINIMIZED:
        //hr = OnMinimize(cookie, arg, param);
        break;

    case MMCN_SELECT:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_SELECT"), -1, NULL);
        // todo HandleStandardVerbs(arg, lpDataObject);            
        break;

    case MMCN_BTN_CLICK:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_BTN_CLICK"), -1, NULL);
        //AfxMessageBox(_T("CDefragSnapinComponent::MMCN_BTN_CLICK"));
        break;

    case MMCN_INITOCX:
        Message(TEXT("CDefragSnapinComponent::Notify - MMCN_INITOCX"), -1, NULL);
        break;

    // Note - Future expansion of notify types possible
    default:
        wsprintf(cString, TEXT("event = 0x%x"), event);
        Message(TEXT("CDefragSnapinComponent::Notify"), E_UNEXPECTED, cString);
        hr = E_UNEXPECTED;
        break;
    }
    return hr;
}
*/

/////////////////////////////////////////////////////
//
// Dispatch interface to the OCX (DfrgCtl) to send commands
//
/////////////////////////////////////////////////////

BOOL CDfrgSnapinData::SendCommand(LPARAM lparamCommand)
{
    HRESULT hr;

    // Ensure that we have a pointer to the Defrag OCX
    if ( m_iDfrgCtlDispatch == NULL ){
        Message(TEXT("SendCommand - m_iDfrgCtlDispatch is NULL!"), -1, NULL);
        return( FALSE );
    }

    // get the defragger OCX dispatch interface
    CComPtr<IDispatch> pDfrgCtlDispatch = m_iDfrgCtlDispatch;

    // get the ID of the "Command" interface
    OLECHAR FAR* szMember = TEXT("Command");  // maps this to "put_Command()"

    DISPID dispid;
    hr = pDfrgCtlDispatch->GetIDsOfNames(
            IID_NULL,           // Reserved for future use. Must be IID_NULL.
            &szMember,          // Passed-in array of names to be mapped.
            1,                  // Count of the names to be mapped.
            LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
            &dispid);           // Caller-allocated array (see help for details)

    if (!SUCCEEDED(hr)) {
        Message(TEXT("SendCommand - pDfrgCtlDispatch->GetIDsOfNames"), hr, NULL);
        return FALSE;
    }

    DISPID mydispid = DISPID_PROPERTYPUT;
    VARIANTARG* pvars = new VARIANTARG;
    EF(pvars);

    VariantInit(&pvars[0]);

    pvars[0].vt = VT_I2;
    pvars[0].iVal = (short)lparamCommand;
    DISPPARAMS disp = { pvars, &mydispid, 1, 1 };

    hr = pDfrgCtlDispatch->Invoke(
            dispid,                 // unique number identifying the method to invoke
            IID_NULL,               // Reserved. Must be IID_NULL
            LOCALE_USER_DEFAULT,    // A locale ID
            DISPATCH_PROPERTYPUT,   // flag indicating the context of the method to invoke
            &disp,                  // A structure with the parameters to pass to the method
            NULL,                   // The result from the calling method
            NULL,                   // returned exception information
            NULL);                  // index indicating the first argument that is in error

    delete pvars;

    if (!SUCCEEDED(hr)) {
        Message(TEXT("SendCommand - pDfrgCtlDispatch->Invoke"), hr, NULL);
        return FALSE;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// gets one of the states of the OCX
// see CSnapin.h for definition
///////////////////////////////////////////////////////////////////////////////////////////////////

BOOL CDfrgSnapinData::GetSessionState(LPDISPATCH pdispControl, UINT sessionState)
{
    DISPID dispid;
    HRESULT hr;

    // Ensure that we have a pointer to the Defrag OCX
    if ( pdispControl == NULL)
        return FALSE;

    // get the defragger OCX dispatch interface
    CComPtr<IDispatch> pDfrgCtlDispatch = pdispControl;

    // array of the interface names
    OLECHAR FAR* szMember[DFRG_INTERFACE_COUNT] = {
        OLESTR("IsEnginePaused"),
        OLESTR("IsEngineRunning"),
        OLESTR("IsDefragInProcess"),
        OLESTR("IsVolListLocked"),
        OLESTR("ReportStatus"),
        OLESTR("IsOkToRun")};

    hr = pDfrgCtlDispatch->GetIDsOfNames(
            IID_NULL,           // Reserved for future use. Must be IID_NULL.
            &szMember[sessionState],            // Passed-in array of names to be mapped.
            1/*DFRG_INTERFACE_COUNT*/,                  // Count of the names to be mapped.
            LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
            &dispid);           // Caller-allocated array (see help for details)

    if (!SUCCEEDED(hr)) {
        Message(TEXT("GetSessionState - pDfrgCtlDispatch->GetIDsOfNames"), hr, NULL);
        return FALSE;
    }

    VARIANT varResult;
    VariantInit(&varResult);
    V_VT(&varResult) = VT_I2;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

    hr = pDfrgCtlDispatch->Invoke(
            dispid,                 // unique number identifying the method to invoke
            IID_NULL,               // Reserved. Must be IID_NULL
            LOCALE_USER_DEFAULT,    // A locale ID
            DISPATCH_PROPERTYGET,   // flag indicating the context of the method to invoke
            &dispparamsNoArgs,      // A structure with the parameters to pass to the method
            &varResult,             // The result from the calling method
            NULL,                   // returned exception information
            NULL);                  // index indicating the first argument that is in error

    if (!SUCCEEDED(hr)) {
        Message(TEXT("IsReportAvailable - pDfrgCtlDispatch->Invoke"), hr, NULL);
        return FALSE;
    }

    return V_BOOL(&varResult);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// gets the current engine state from the OCX
///////////////////////////////////////////////////////////////////////////////////////////////////

short CDfrgSnapinData::GetEngineState(void)
{
    // Ensure that we have a pointer to the Defrag OCX
    if( m_iDfrgCtlDispatch == NULL ) 
        return FALSE;

    // get the defragger OCX dispatch interface
    CComPtr<IDispatch> pDfrgCtlDispatch =  m_iDfrgCtlDispatch;

    // get the ID of the "Command" interface
    OLECHAR FAR* szMember = TEXT("EngineState");  // maps this to "get_EngineState()"

    DISPID dispid;
    HRESULT hr = pDfrgCtlDispatch->GetIDsOfNames(
            IID_NULL,           // Reserved for future use. Must be IID_NULL.
            &szMember,          // Passed-in array of names to be mapped.
            1,                  // Count of the names to be mapped.
            LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
            &dispid);           // Caller-allocated array (see help for details)

    if (!SUCCEEDED(hr)) {
        Message(TEXT("GetEngineState - pDfrgCtlDispatch->GetIDsOfNames"), hr, NULL);
        return 0;
    }

    VARIANT varResult;
    VariantInit(&varResult);
    V_VT(&varResult) = VT_I2;
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

    hr = pDfrgCtlDispatch->Invoke(
            dispid,                 // unique number identifying the method to invoke
            IID_NULL,               // Reserved. Must be IID_NULL
            LOCALE_USER_DEFAULT,    // A locale ID
            DISPATCH_PROPERTYGET,   // flag indicating the context of the method to invoke
            &dispparamsNoArgs,          // A structure with the parameters to pass to the method
            &varResult,                 // The result from the calling method
            NULL,                   // returned exception information
            NULL);                  // index indicating the first argument that is in error

    if (!SUCCEEDED(hr)) {
        Message(TEXT("GetEngineState - pDfrgCtlDispatch->Invoke"), hr, NULL);
        return 0;
    }

    return V_I2(&varResult);
}

//
// Determines if the enumeration is for a remoted machine or not.
//
#ifndef DNS_MAX_NAME_LENGTH
#define DNS_MAX_NAME_LENGTH 255
#endif

bool CDfrgSnapin::IsDataObjectRemoted( IDataObject* pDataObject )
{

    bool fRemoted = false;
    TCHAR szComputerName[ DNS_MAX_NAME_LENGTH + 1 ];
    DWORD dwNameLength = (DNS_MAX_NAME_LENGTH + 1);
    TCHAR szDataMachineName[ DNS_MAX_NAME_LENGTH + 1 ];

    //
    // Get local computer name.
    //
    GetComputerName(szComputerName, &dwNameLength);

    //
    // Get the machine name from the given data object.
    //
    if ( ExtractString( pDataObject,  m_ccfRemotedFormat, szDataMachineName, DNS_MAX_NAME_LENGTH + 1 ) )
    {
        _toupper( szDataMachineName );

        //
        // Find the start of the server name.
        //
        LPTSTR pStr = szDataMachineName;
        while ( pStr && *pStr == L'\\' )
            pStr++;

        //
        // Compare the server name.
        //
        if ( pStr && *pStr && wcscmp( pStr, szComputerName ) != 0 )
            fRemoted = true;
    }

    return( fRemoted );
}

//
// Retrieves the value of a given clipboard format from a given data object.
//
bool CDfrgSnapin::ExtractString( IDataObject* pDataObject, unsigned int cfClipFormat, LPTSTR pBuf, DWORD dwMaxLength)
{
    USES_CONVERSION;
    bool fFound = false;
    FORMATETC formatetc = { (CLIPFORMAT) cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    stgmedium.hGlobal = ::GlobalAlloc( GMEM_SHARE, dwMaxLength  * sizeof(TCHAR));
    HRESULT hr;

    do 
    {
        //
        // This is a memory error condition!
        //
        if ( NULL == stgmedium.hGlobal )
            break;

        hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
            break;

        LPWSTR pszNewData = reinterpret_cast<LPWSTR>( ::GlobalLock( stgmedium.hGlobal ) );
        if ( NULL == pszNewData )
            break;

        pszNewData[ dwMaxLength - 1 ] = L'\0';
        _tcscpy( pBuf, OLE2T( pszNewData ) );
        fFound = true;
    } 
    while( false );

    if ( NULL != stgmedium.hGlobal )
    {
        GlobalUnlock( stgmedium.hGlobal );
        GlobalFree( stgmedium.hGlobal );
    }

    return( fFound );
}

HRESULT CDfrgSnapinExtData::Notify( MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param,
    IComponentData* pComponentData,
    IComponent* pComponent,
    DATA_OBJECT_TYPES type)
{
    // Add code to handle the different notifications.
    // Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
    // In response to MMCN_SHOW you have to enumerate both the scope
    // and result pane items.
    // For MMCN_EXPAND you only need to enumerate the scope items
    // Use IConsoleNameSpace::InsertItem to insert scope pane items
    // Use IResultData::InsertItem to insert result pane item.
    HRESULT hr = E_NOTIMPL;
    bool fRemoted = false;

    _ASSERTE( pComponentData != NULL || pComponent != NULL );

    CComPtr<IConsole> spConsole;
    if ( pComponentData != NULL )
    {
        CDfrgSnapin* pExt = (CDfrgSnapin*) pComponentData;
        spConsole = pExt->m_spConsole;

        //
        // Determine if we're remoted.
        //
        fRemoted = pExt->IsRemoted();
    }
    else
    {
        spConsole = ( (CDfrgSnapinComponent*) pComponent )->m_spConsole;
    }

    switch ( event )
    {
    case MMCN_SHOW:
        arg = arg;
        hr = S_OK;
        break;

    case MMCN_EXPAND:
        {
            if ( arg == TRUE )
            {
                CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
                SCOPEDATAITEM* pScopeData;

                //
                // Create the node based on whether we're remoted or
                // not.
                //
                m_pNode = new CDfrgSnapinData( fRemoted );
                EE(m_pNode);

                m_pNode->GetScopeData( &pScopeData );
                pScopeData->relativeID = param;
                spConsoleNameSpace->InsertItem( pScopeData );

                if ( pComponentData )
                    ( (CDfrgSnapin*) pComponentData )->m_pNode = m_pNode;
            }

            hr = S_OK;
            break;
        }
    case MMCN_REMOVE_CHILDREN:
        {
            //
            // We are not deleting this node since this same pointer is
            // stashed in the pComponentData in response to the MMCN_EXPAND
            // notification. The destructor of pComponentData deletes the pointer
            // to this node.
            //
            //delete m_pNode;
            m_pNode = NULL;
            hr = S_OK;
            break;
        }
    case MMCN_ADD_IMAGES:
        {
            // Add Images
            IImageList* pImageList = (IImageList*)arg;
            hr = E_FAIL;

            // Load bitmaps associated with the scope pane
            // and add them to the image list
            // Loads the default bitmaps generated by the wizard
            // Change as required
            HBITMAP hBitmap16 = (HBITMAP) LoadImage(
                                    GetDfrgResHandle(),   // handle of the instance that contains the image  
                                    MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_16),  // name or identifier of image
                                    IMAGE_BITMAP,        // type of image  
                                    0,     // desired width
                                    0,     // desired height  
                                    LR_DEFAULTCOLOR        // load flags
                                    );

            if (hBitmap16 != NULL)
            {
                BITMAP bm;
                GetObject( hBitmap16, sizeof( bm ), &bm );
                HBITMAP hBitmap32 = (HBITMAP ) LoadImage(
                                        GetDfrgResHandle(),
                                        MAKEINTRESOURCE(IDB_DEFRAGSNAPIN_32),  // name or identifier of image
                                        IMAGE_BITMAP,        // type of image  
                                        0,     // desired width
                                        0,     // desired height  
                                        LR_DEFAULTCOLOR        // load flags
                                        );
                if (hBitmap32 != NULL)
                {
                    GetObject( hBitmap32, sizeof( bm ), &bm );
                    hr = pImageList->ImageListSetStrip((LONG_PTR *)hBitmap16, 
                    (LONG_PTR *)hBitmap32, 0, RGB(255, 255, 255));
                    if (FAILED(hr))
                        ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));

                    ::DeleteObject(hBitmap32);
                    hBitmap32 = NULL;
                }
                ::DeleteObject(hBitmap16);
                hBitmap16 = NULL;
            }

            break;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// ESI function called when the snapin changes show state
//
HRESULT CDfrgSnapinData::OnShow(LPARAM isShowing, IResultData* pResults )
{
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// instantiates the OCX
//
// implementation of IComponent::GetResultViewType()
STDMETHODIMP CDfrgSnapinData::GetResultViewType(
    LPOLESTR* ppViewType,
    long* pViewOptions)
{
    TCHAR szPath[ _MAX_PATH + 30 ];
    Message(TEXT("IComponent::GetResultViewType"), -1, NULL);

    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    // Make sure that we are displaying the OCX?
    if ( m_CustomViewID != VIEW_DEFRAG_OCX ) {
        return S_FALSE;
    }

    //
    // TLP: Return back a web page if we're remoted.
    //
    if ( m_fRemoted )
    {
        TCHAR szModulePath[ _MAX_PATH + 1 ];

        //
        // Get the HTML embedded in the res file.
        //
        GetModuleFileName( GetDfrgResHandle(), szModulePath, _MAX_PATH );  
        
        // 
        // Append the necessary decorations for correct access. 
        // 
        _tcscpy( szPath, _T( "res://" ) ); 
        _tcscat( szPath, szModulePath ); 
        _tcscat( szPath, _T( "/REMOTED.HTM" ) );  
    }
    else
    {
        //
        // Display the normal OCX.
        //
        _tcscpy( szPath, szDefragGUID );
    }

    UINT uiByteLen = (lstrlen(szPath) + 1) * sizeof(OLECHAR);
    LPOLESTR psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);
    
    if (psz == NULL) {
        return S_FALSE;            
    }
    lstrcpy(psz, szPath);
    *ppViewType = psz;

    return S_OK;
}

void CDfrgSnapinComponent::Advise()
{
    if ( m_dwAdvise == 0 )
    {
        HRESULT hr = AtlAdvise( m_spDisp, this->GetUnknown(), IID_IDfrgEvents, &m_dwAdvise );
        _ASSERTE( SUCCEEDED( hr ) );
    }
}

void CDfrgSnapinComponent::Unadvise()
{
    if ( m_dwAdvise != 0 )
    {
        HRESULT hr = AtlUnadvise( m_spDisp, IID_IDfrgEvents, m_dwAdvise );
        _ASSERTE( SUCCEEDED( hr ) );
        m_dwAdvise = 0;
    }
}

//
// Overrides the Filldata
//
STDMETHODIMP CDfrgSnapinData::FillData( CLIPFORMAT cf, LPSTREAM pStream )
{
    HRESULT hr = DV_E_CLIPFORMAT;
    ULONG uWritten;

    //
    // We need to write out our own member since GetDisplayName() does
    // not give us an opportunity override its static implementation by
    // ATL.
    //
    if (cf == m_CCF_NODETYPE) // wants the guid for the node
    {
        hr = pStream->Write( GetNodeType(), sizeof(GUID), &uWritten);
        return hr;
    }

    if (cf == m_CCF_SZNODETYPE) // string that describes the node (not displayed, used for lookup of the node)
    {
        hr = pStream->Write( GetSZNodeType(), (lstrlen((LPCTSTR) GetSZNodeType()) + 1 )* sizeof(TCHAR), &uWritten);
        return hr;
    }

    if (cf == m_CCF_DISPLAY_NAME) // displayed in the scope pane to id the node (root only)
    {
        USES_CONVERSION;
        VString vDisplayName(IDS_PRODUCT_NAME, GetDfrgResHandle());
        hr = pStream->Write(vDisplayName.GetBuffer(), vDisplayName.GetLength() * sizeof( WCHAR ), &uWritten);
        return hr;
    }

    if (cf == m_CCF_SNAPIN_CLASSID) // guid of the snapin (CLSID)
    {
        hr = pStream->Write( GetSnapInCLSID(), sizeof(GUID), &uWritten);
        return hr;
    }

    return hr;
}

/*
STDMETHODIMP_(ULONG) CDfrgSnapinData::Release(void) 
{ 
    if (InterlockedDecrement(&m_cRef) == 0) {

        delete this; 
        return 0; 
    } 
    return m_cRef; 
}

STDMETHODIMP CDfrgSnapinData::QueryInterface(REFIID riid, void** ppv)
{
    if (ppv == NULL) 
        return E_INVALIDARG;

    // Make sure we are being asked for a DataObject interface.
    if ( riid == IID_IUnknown || riid == IID_IDfrgEvents )
    {
        // If so return a pointer to this interface.
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }

    // No interface.
    *ppv = NULL;
    return E_NOINTERFACE;
}
*/

//
// Called from the OCX when the status has changed.
//
STDMETHODIMP CDfrgSnapinComponent::StatusChanged( BSTR bszStatus )
{
    if (m_spConsole){
        CComQIPtr<IConsole2,&IID_IConsole2> pConsole = m_spConsole;
        pConsole->SetStatusText( bszStatus );
    }
    return( S_OK );
}

//
// Called from the OCX when the OK to run property has changed.
//
STDMETHODIMP CDfrgSnapinComponent::IsOKToRun( BOOL bOK )
{
    ( (CDfrgSnapinData*) m_pComponentData->m_pNode )->SetActiveControl( TRUE, this );
    return( S_OK );
}

void CDfrgSnapinData::SetActiveControl( BOOL bActive, IComponent* pComponent )
{
    CComPtr<IConsole> spConsole;
    spConsole = ((CDfrgSnapinComponent*)pComponent)->m_spConsole;

    //
    // Always get the ctl dispatch pointer.
    //
    CComPtr<IUnknown> pUnk;
    spConsole->QueryResultView( &pUnk );
    CComQIPtr<IDispatch,&IID_IDispatch> pCtl = pUnk;

    //
    // If this is the first one, then check if we're
    // valid. If we are, then assign this conrol to
    // 
    if ( GetSessionState( pCtl, IS_OK_TO_RUN ) == TRUE )
        m_iDfrgCtlDispatch = pCtl;

    //
    // Always attach the control to the component.
    //
    ( (CDfrgSnapinComponent*) pComponent )->SetControl( bActive == TRUE ? (LPDISPATCH) pCtl : (LPDISPATCH) NULL );
}

STDMETHODIMP CDfrgSnapinComponent::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK piCallback,long *pInsertionAllowed)
{
    HRESULT hr;

    if ( IS_SPECIAL_DATAOBJECT( pDataObject ) )
    {
        hr = m_pComponentData->m_pNode->AddMenuItems( piCallback, pInsertionAllowed, CCT_RESULT );
    }
    else
    {
        hr = IExtendContextMenuImpl<CDfrgSnapin>::AddMenuItems( pDataObject, piCallback, pInsertionAllowed );
    }

    return( hr );
}
    
STDMETHODIMP CDfrgSnapinComponent::Command(long lCommandID, LPDATAOBJECT pDataObject)
{
    HRESULT hr;

    if ( IS_SPECIAL_DATAOBJECT( pDataObject ) )
    {
        hr = m_pComponentData->m_pNode->Command( lCommandID, this, CCT_RESULT );
    }
    else
    {
        hr = IExtendContextMenuImpl<CDfrgSnapin>::Command( lCommandID, pDataObject );
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dfrgctl.h ===
// DfrgCtl.h : Declaration of the CDfrgCtl

#ifndef __DFRGCTL_H_
#define __DFRGCTL_H_

#pragma warning( disable: 4530 )


#include "resource.h"       // main symbols
#include "ESButton.h"
#include "ListView.h"
#include "graphix.h"
#include <vector>

/////////////////////////////////////////////////////////////////////////////
// CDfrgCtl
class ATL_NO_VTABLE CDfrgCtl : 
	public CComObjectRootEx<CComSingleThreadModel>
	,public CComCoClass<CDfrgCtl, &CLSID_DfrgCtl>
	,public CComControl<CDfrgCtl>
	,public CStockPropImpl<CDfrgCtl, IDfrgCtl, &IID_IDfrgCtl, &LIBID_DFRGUILib>
	,public IProvideClassInfo2Impl<&CLSID_DfrgCtl, NULL, &LIBID_DFRGUILib> // needed
	,public IPersistStreamInitImpl<CDfrgCtl>
	,public IPersistStorageImpl<CDfrgCtl>
	,public IQuickActivateImpl<CDfrgCtl>
	,public IOleControlImpl<CDfrgCtl> // needed
	,public IOleObjectImpl<CDfrgCtl> // needed
	,public IOleInPlaceActiveObjectImpl<CDfrgCtl>
	,public IViewObjectExImpl<CDfrgCtl>
	,public IOleInPlaceObjectWindowlessImpl<CDfrgCtl>
	,public IDataObjectImpl<CDfrgCtl>
	,public ISupportErrorInfo
	,public ISpecifyPropertyPagesImpl<CDfrgCtl>
	,public IConnectionPointContainerImpl<CDfrgCtl>
	,public IConnectionPointImpl<CDfrgCtl,&IID_IDfrgEvents>
{
public:
	CDfrgCtl();
	virtual ~CDfrgCtl();

DECLARE_REGISTRY_RESOURCEID(IDR_DFRGCTL)

BEGIN_COM_MAP(CDfrgCtl)
	COM_INTERFACE_ENTRY(IDfrgCtl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
	COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IDataObject)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDfrgCtl)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CDfrgCtl)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
	MESSAGE_HANDLER(WM_TIMER, OnTimer)
	MESSAGE_HANDLER(WM_COMMAND, OnCommand)
	MESSAGE_HANDLER(WM_CLOSE, OnClose)
	MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
END_MSG_MAP()

BEGIN_CONNECTION_POINT_MAP(CDfrgCtl)
    CONNECTION_POINT_ENTRY(IID_IDfrgEvents)
END_CONNECTION_POINT_MAP()

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}

// IDfrgCtl
public:
	STDMETHOD(get_IsVolListLocked)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_IsDefragInProcess)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_IsEngineRunning)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_IsEnginePaused)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_ReportStatus)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_EngineState)(/*[out, retval]*/ short *pVal);
	HRESULT OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	HRESULT OnCommand(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
    HRESULT OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
    HRESULT OnSizing(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
    HRESULT OnExitSizeMove(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
    HRESULT OnClose(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
    HRESULT OnEraseBkgnd(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	HRESULT SizeWindow();
	HRESULT OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	HRESULT OnFontChange(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	HRESULT OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	HRESULT RefreshListViewRow(CVolume *pVolume);
#ifdef ESI_PROGRESS_BAR
	void InvalidateProgressBar(void);
#endif
    HRESULT OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	STDMETHOD(get_Command)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_Command)(/*[in]*/ short newVal);

	HRESULT CreateButtons(void);
	BOOL PaintClusterMap(IN BOOL bPartialRedraw, HDC WorkDC);
	void InvalidateGraphicsWindow(void);
	BOOL SizeGraphicsWindow(void);
	BOOL DrawButtons(HDC);
	void SizeLegend(void);
	void SizeButtons(void);
	void SetButtonState(void);
	
	HRESULT PreviousTab();
	HRESULT NextTab();
	STDMETHOD(TranslateAccelerator)(LPMSG pMsg);

	LRESULT OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnKillFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	//
	// Status change handler.
	//
	void SendStatusChange( LPCTSTR pszStatus );

	//
	// Send to advises when control has changed OKToRun property.
	//
	void SendOKToRun( BOOL bOK );

// these are public cause they are used by the PostMsg
public:
	STDMETHOD(get_Enabled)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Enabled)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_IsOkToRun)(/*[out, retval]*/ BOOL *pVal);
	BOOL m_bPartialRedraw;

	// the graphics wells
	RECT rcAnalyzeDisp;
	RECT rcDefragDisp;

	/////////////////////////////////
	// The volume list container
	// is public so that PostMessageLocal can see it
	/////////////////////////////////
	CVolList m_VolumeList;

private:
	// used to prevent more than one instance of the control from running
	BOOL m_bStart;
	BOOL m_bNeedMultiInstanceMessage;
	BOOL m_bNeedIllegalVolumeMessage;
	DWORD m_dwInstanceRegister;

	BOOL m_IsOkToRun;
	HANDLE m_hIsOkToRunSemaphore;
	HFONT m_hFont;
	UINT m_FontHeight;
	UINT GetStringWidth(PTCHAR stringBuf, HDC WorkDC);
	BOOL IsOnlyInstance();

	/////////////////////////////////
	// The entire graphics area
	/////////////////////////////////
	BOOL DrawSingleInstanceScreen(HDC);
	RECT m_rcCtlRect;
	int m_Margin;

	/////////////////////////////////
	// Progress Bar
	/////////////////////////////////
#ifdef ESI_PROGRESS_BAR
	BOOL DrawProgressBar(HDC);
	RECT rcProgressBarBG;
	RECT rcProgressBar;
	BOOL m_IsProgressBarMoved;
	int m_ProgressBarOffset; // offset top and bottom in legend window
	int m_ProgressBarLength;
#endif

	/////////////////////////////////
	// Legend
	/////////////////////////////////
	BOOL DrawLegend(HDC);
	RECT rcLegendBG;
	int m_LegendTextWidth; // length of all the text if on 1 line
	int m_LegendGraphicSpacer;
	int m_LegendHeight;
	int m_LegendTextSpacer;
	int m_LegendTopSpace;
	int m_EtchedLineOffset;
	int m_BitmapVOffset; // space above and below the legend bitmaps

	/////////////////////////////////
	// Graphics Area
	/////////////////////////////////
	BOOL PaintGraphicsWindow(HDC);
	RECT rcGraphicsBG; // total BG

	// borders around the graphic wells
	RECT rcAnalyzeBorder;
	RECT rcDefragBorder;
	UINT m_GraphicWellSpacer;
	UINT m_GraphicWellHeight;

	/////////////////////////////////
	// Buttons
	/////////////////////////////////
	BOOL m_ButtonsLocked;

	RECT rcButtonBG;

	// position of the buttons
	// in absolute coodinates
	RECT rcDefragButton;
	RECT rcAnalyzeButton;
	RECT rcPauseButton;
	RECT rcCancelButton;
	RECT rcReportButton;

	// the buttons
	HRESULT DestroyButtons(void);
	BOOL m_bHaveButtons;
	UINT m_ButtonTopBottomSpacer;
	UINT m_ButtonHeight;
	UINT m_ButtonWidth;
	UINT m_ButtonSpacer;
	ESButton* m_pAnalyzeButton;
	ESButton* m_pDefragButton;
	ESButton* m_pPauseButton;
	ESButton* m_pStopButton;
	ESButton* m_pReportButton;
	HRESULT HandleEnterKeyPress();

	/////////////////////////////////
	// Listview
	/////////////////////////////////
	CESIListView m_ListView;
	RECT rcListView;

	// Pointer to CBmp class that holds all the legend bitmap squares
	CBmp* m_pLegend;

	struct legendData {
		int length; // length of legend text plus bitmap plus spacers
		VString text; // legend entry text
		RECT rcBmp; // rectangle that defines location of bitmap
	} m_LegendData[7];

};

using namespace std;
typedef vector< HWND, allocator<HWND> > HWNDVECTOR; 

class CTabEnumerator
{
public:
	CTabEnumerator( HWND hWndParent, bool fForward )
	{
		m_hWndParent = hWndParent;
		m_fForward = fForward;
	};

	HWND GetNextTabWindow();
	void AddChild( HWND hWnd )
	{
		//
		// Only add this if it is a top-level child.
		//
		if ( GetParent( hWnd ) == m_hWndParent && IsWindowEnabled( hWnd ) )
			m_Children.push_back( hWnd );
	}

protected:
	HWND m_hWndParent;
	HWNDVECTOR m_Children;
	bool m_fForward;
};

#endif //__DFRGCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dfrgctl.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  DfrgCtl.cpp
//=============================================================================*

//#define ESI_MULTI_ALLOWED

#include "stdafx.h"
#define GLOBAL_DATAHOME

#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif

#include <commctrl.h>
#include <htmlhelp.h>
#include "adminprivs.h"

extern "C" {
    #include "SysStruc.h"
}

#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DiskDisp.h"
#include "DfrgUI.h"
#include "DfrgCtl.h"
#include "DataIo.h"
#include "DataIoCl.h"
#include "ListView.h"
#include "ErrMacro.h"
#include "ErrMsg.h"
#include "Graphix.h"
#include "DfrgRes.h"
#include "EsButton.h"
#include "DlgRpt.h"
#include "DfrgRes.h"
#include "GetDfrgRes.h"
#include "IntFuncs.h"
#include "VolList.h"
#include "VolCom.h"
#include "MIMessage.h"
#include "adminprivs.h"
#include <algorithm>

#include "secattr.h"

#define NUM_ACCELERATORS    5

#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION        0x1000
#endif

#define MULTI_INSTANCE_TIMER    1000
#define PING_TIMER              3000

static const MI_TIMER_ID = 1;
static const LISTVIEW_TIMER_ID = 2;
static const PING_TIMER_ID = 3;

BOOL CALLBACK TabEnumChildren( HWND hwnd, LPARAM lParam );

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
CDfrgCtl::CDfrgCtl() : m_VolumeList( this ), m_ListView ( this )
{
    ATLTRACE( _T( "Creating defrag control.\n" ) );

    m_bStart = TRUE;
    m_bNeedMultiInstanceMessage = TRUE;
    m_bNeedIllegalVolumeMessage = FALSE;
    m_dwInstanceRegister = 0;
    m_hIsOkToRunSemaphore = NULL;

    // Determine if we're the first instance of the control running.
    m_IsOkToRun = IsOnlyInstance();

    if ( m_IsOkToRun )
    {
        //
        // Register the dataio with the system.
        //
        m_dwInstanceRegister = InitializeDataIo( CLSID_DfrgCtlDataIo, REGCLS_MULTIPLEUSE );
    }

    m_LegendHeight = 34;
    m_FontHeight = 0;  // calculated later
    m_LegendTextSpacer = 0;  // calculated later
    m_LegendTopSpace = 10;
    m_EtchedLineOffset = 5;
#ifdef ESI_PROGRESS_BAR
    m_ProgressBarOffset = 7; // offset top and bottom in legend window
    m_ProgressBarLength = 121;
#endif
    m_Margin = 14;
    m_GraphicWellHeight = 40;
    m_LegendGraphicSpacer = 5;
    m_LegendTextWidth = 0; // calculated later
    m_BitmapVOffset = 0; // calculated later
    m_ButtonTopBottomSpacer = 14;
    m_ButtonHeight = 26;
    m_ButtonWidth = 84;
    m_ButtonSpacer = 6;
    m_GraphicWellSpacer = 40;
    m_hFont = NULL;

    m_bHaveButtons = FALSE;
    m_pAnalyzeButton = (ESButton *) NULL;
    m_pDefragButton = (ESButton *) NULL;
    m_pPauseButton = (ESButton *) NULL;
    m_pStopButton = (ESButton *) NULL;
    m_pReportButton = (ESButton *) NULL;
    m_pLegend = (CBmp *) NULL;

    ZeroMemory(&rcLegendBG, sizeof(RECT));
    ZeroMemory(&rcReportButton, sizeof(RECT));

    // Initialize the legend.
    INT_PTR iBmp[20];

    if(SIMPLE_DISPLAY){
        iBmp[0] = (INT_PTR)MAKEINTRESOURCE(IDB_FRAGMENTED_FILES);
        iBmp[1] = (INT_PTR)MAKEINTRESOURCE(IDB_CONTIGUOUS_FILES);
        iBmp[2] = (INT_PTR)MAKEINTRESOURCE(IDB_SYSTEM_FILES);
        iBmp[3] = (INT_PTR)MAKEINTRESOURCE(IDB_FREE_SPACE);
        m_pLegend = new CBmp(GetDfrgResHandle(), iBmp, 4);
        EV_ASSERT(m_pLegend);
        // load the strings into all the text strings
        m_LegendData[0].text.LoadString(IDS_FRAGMENTED_FILES, GetDfrgResHandle());
        m_LegendData[1].text.LoadString(IDS_CONTIGUOUS_FILES, GetDfrgResHandle());
        m_LegendData[2].text.LoadString(IDS_SYSTEM_FILES, GetDfrgResHandle());
        m_LegendData[3].text.LoadString(IDS_FREE_SPACE, GetDfrgResHandle());
    }
    else{
        iBmp[0] = (INT_PTR)MAKEINTRESOURCE(IDB_SYSTEM_FILES);
        iBmp[1] = (INT_PTR)MAKEINTRESOURCE(IDB_RESERVED_SPACE);
        iBmp[2] = (INT_PTR)MAKEINTRESOURCE(IDB_PAGE_FILE);
        iBmp[3] = (INT_PTR)MAKEINTRESOURCE(IDB_DIRECTORY_FILES);
        iBmp[4] = (INT_PTR)MAKEINTRESOURCE(IDB_FRAGMENTED_FILES);
        iBmp[5] = (INT_PTR)MAKEINTRESOURCE(IDB_CONTIGUOUS_FILES);
        iBmp[6] = (INT_PTR)MAKEINTRESOURCE(IDB_FREE_SPACE);
        m_pLegend = new CBmp(GetDfrgResHandle(), iBmp, 7);
        EV_ASSERT(m_pLegend);
        m_LegendData[0].text.LoadString(IDS_SYSTEM_FILES, GetDfrgResHandle());
        m_LegendData[1].text.LoadString(IDS_RESERVED_SPACE, GetDfrgResHandle());
        m_LegendData[2].text.LoadString(IDS_PAGE_FILE, GetDfrgResHandle());
        m_LegendData[3].text.LoadString(IDS_DIRECTORY_FILES, GetDfrgResHandle());
        m_LegendData[3].text.LoadString(IDS_FRAGMENTED_FILES, GetDfrgResHandle());
        m_LegendData[3].text.LoadString(IDS_CONTIGUOUS_FILES, GetDfrgResHandle());
        m_LegendData[3].text.LoadString(IDS_FREE_SPACE, GetDfrgResHandle());
    }
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::~CDfrgCtl
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
CDfrgCtl::~CDfrgCtl()
{
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume) {
        pVolume->StoppedByUser(TRUE);
    }

    DestroyButtons();

    if(m_pLegend){
        delete m_pLegend;
    }

    ::DeleteObject(m_hFont);

    //
    // Remove our instance handler.
    //
    if ( m_dwInstanceRegister )
        CoRevokeClassObject( m_dwInstanceRegister );

    if(m_hIsOkToRunSemaphore) {
        if (m_IsOkToRun) {
            // this would increment the count, and make the semaphore seem like
            // is was available (signaled).  Only do this if this is the running instance
            ReleaseSemaphore(m_hIsOkToRunSemaphore, 1, NULL);
        }
        CloseHandle(m_hIsOkToRunSemaphore);
    }

    return;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::OnClose
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::OnClose(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult){
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::InterfaceSupportsErrorInfo
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = { &IID_IDfrgCtl,};

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++) {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::OnNotify
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
    m_ListView.NotifyListView(lParam);

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::OnCommand
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::OnCommand(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
    switch (LOWORD(wParam)) {

        case ID_ANALYZE:
            put_Command(ID_ANALYZE);
            break;

        case ID_DEFRAG:
            put_Command(ID_DEFRAG);
            break;

        case ID_PAUSE:
            put_Command(ID_PAUSE);
            break;

        case ID_STOP:
            put_Command(ID_STOP);
            break;

        case ID_REFRESH:
            put_Command(ID_REFRESH);
            break;

        case ID_HELP_CONTENTS:
            put_Command(ID_HELP_CONTENTS);
            break;

        case ID_REPORT:
            {
                // is the engine IDLE?
                CVolume *pVolume = m_VolumeList.GetCurrentVolume();
                if (pVolume){
                    if(pVolume->EngineState() == ENGINE_STATE_IDLE){
                        RaiseReportDialog(pVolume);
                        ::SetFocus(m_pReportButton->GetWindowHandle());
                    }
                }
            }
            break;
    }
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::OnSize
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
    TCHAR msg[200];
    _stprintf(msg, TEXT("CDfrgCtl::OnSize() lParam LO=%d, HI=%d"), LOWORD(lParam), HIWORD(lParam));
    Message(msg, -1, NULL);

    //Zero is passed in the first time this function is called.  This puts incorrect data into
    //the rectangles below for a fraction of a second.  Probably harmless, but better safe than sorry.
    if(!lParam) {
        ZeroMemory(&m_rcCtlRect, sizeof(RECT));
        return S_OK;
    }

    m_rcCtlRect.top = 0;
    m_rcCtlRect.left = 0;
    m_rcCtlRect.right = LOWORD(lParam);
    m_rcCtlRect.bottom = HIWORD(lParam);

    SizeWindow();

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::SizeWindow
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::SizeWindow()
{
    TCHAR msg[200];
    _stprintf(msg, TEXT("CDfrgCtl::SizeWindow() m_bStart=%d"), m_bStart);
    Message(msg, -1, NULL);

    if( m_bStart) {

        NONCLIENTMETRICS ncm;
        ncm.cbSize = sizeof(ncm);

        ::SystemParametersInfo (SPI_GETNONCLIENTMETRICS, sizeof (ncm), &ncm, 0);
        ncm.lfMenuFont.lfWeight = FW_NORMAL;
        m_hFont = ::CreateFontIndirect(&ncm.lfMenuFont);
        m_FontHeight = -ncm.lfMenuFont.lfHeight;

        EH_ASSERT(m_hFont);

        VString windowText(IDS_DK_TITLE, GetDfrgResHandle());
        SetWindowText(windowText.GetBuffer());

        CreateButtons();

        // Initialize list view and graphix windows.
        m_ListView.InitializeListView(&m_VolumeList, m_hWndCD, _Module.GetModuleInstance());

        // Display the drives available in the listview.
        m_ListView.GetDrivesToListView();

        // get the first drive hilited (check command line)
        m_ListView.SelectInitialListViewDrive(&m_bNeedIllegalVolumeMessage);

        // Hide or show the listview
        m_ListView.EnableWindow(m_IsOkToRun);

        // get the buttons enabled/disables properly
        SetButtonState();

        //Set the multi-instance timer.
        SetTimer(MI_TIMER_ID, MULTI_INSTANCE_TIMER, NULL);

        //Set the list view timer.
        SetTimer(LISTVIEW_TIMER_ID, m_VolumeList.GetRefreshInterval(), NULL);

        //Set the ping timer.
        SetTimer(PING_TIMER_ID, PING_TIMER, NULL);

        m_bStart = FALSE;
    }

    // size the legend and progress bar
    SizeLegend();

    // Size the buttons
    SizeButtons();

    m_pAnalyzeButton->ShowButton(SW_SHOW);
    m_pDefragButton->ShowButton(SW_SHOW);
    m_pReportButton->ShowButton(SW_SHOW);
    m_pPauseButton->ShowButton(SW_SHOW);
    m_pStopButton->ShowButton(SW_SHOW);
    ::SetFocus(m_pAnalyzeButton->GetWindowHandle());
    
    // Now size the graphics window.
    SizeGraphicsWindow();

    // size the list view (he gets the screen that is left over)
    rcListView.bottom = rcGraphicsBG.top;
    rcListView.top = 0;
    rcListView.left = 0;
    rcListView.right = m_rcCtlRect.right;

    // Now size the listview
    m_ListView.SizeListView(
        rcListView.left,
        rcListView.top,
        rcListView.right - rcListView.left,     // width
        rcListView.bottom - rcListView.top);    // height

    Invalidate(FALSE);

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::OnEraseBkgnd
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::OnEraseBkgnd(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::RefreshListViewRow
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::RefreshListViewRow(CVolume *pVolume)
{
    // refresh this row of the list view
    m_ListView.Update(pVolume);
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::OnPaint
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::OnPaint(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
    PAINTSTRUCT paintStruct;
    HDC OutputDC = BeginPaint(&paintStruct);

    // Paint the various windows.
    if (OutputDC){
        DrawLegend(OutputDC);
#ifdef ESI_PROGRESS_BAR
        DrawProgressBar(OutputDC);
#endif
        PaintGraphicsWindow(OutputDC);
        DrawButtons(OutputDC);
    }

    EndPaint(&paintStruct);

    // display the multi-instance screen if needed
    if (!m_IsOkToRun && m_bNeedMultiInstanceMessage){
        m_bNeedMultiInstanceMessage = FALSE;

        if (CheckForAdminPrivs() == FALSE) {
            SetLastError(ESI_VOLLIST_ERR_NON_ADMIN);
            VString title(IDS_DK_TITLE, GetDfrgResHandle());
            VString msg(IDS_NEED_ADMIN_PRIVS, GetDfrgResHandle());
            MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_OK|MB_ICONWARNING);
            
        }
        else if (!RaiseMIDialog(m_hWndCD)) {
            ATLTRACE( _T( "MI Dialog failed\n" ) );
        }
    }

    // display the illegal volume dialog if needed
    if (m_bNeedIllegalVolumeMessage) {

        // don't need to do it again
        m_bNeedIllegalVolumeMessage = FALSE;

        // warn user he can't defrag illegal volume
        VString title(IDS_DK_TITLE, GetDfrgResHandle());
        VString msg(IDS_VOLUME_TYPE_NOT_SUPPORTED, GetDfrgResHandle());
        MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_OK | MB_ICONWARNING);
    }

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::OnTimer
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::OnTimer(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
    switch (wParam)
    {
    // This timer checks the multi-instance semaphore
    case MI_TIMER_ID:

        //  if we are in a Terminal Server session, don't change anything
        //  if (GetSystemMetrics(SM_REMOTESESSION)){
        //  return S_OK;
        //}

        //
        // Refresh whether or not we're the only instance.
        //
        if ( m_IsOkToRun == FALSE )
        {
            m_IsOkToRun = IsOnlyInstance();
            if ( m_IsOkToRun == TRUE )
            {
                m_dwInstanceRegister = InitializeDataIo( CLSID_DfrgCtlDataIo, REGCLS_MULTIPLEUSE );

                SetButtonState();

                // Hide or show the listview
                m_ListView.EnableWindow(m_IsOkToRun);

                // Send OKToRun property change to advises.
                SendOKToRun( TRUE );

                Invalidate(TRUE);
            }
        }

        KillTimer(MI_TIMER_ID);

        SetTimer(MI_TIMER_ID, MULTI_INSTANCE_TIMER, NULL);
        break;

    // This timer refreshes the list view
    case LISTVIEW_TIMER_ID:

        KillTimer(LISTVIEW_TIMER_ID);

        m_ListView.GetDrivesToListView();

        SetTimer(LISTVIEW_TIMER_ID, m_VolumeList.GetRefreshInterval(), NULL);
        break;

    // This timer pings the engine
    case PING_TIMER_ID:
        {
        KillTimer(PING_TIMER_ID);

        CVolume *pVolume;
        for (UINT ii = 0; ii < m_VolumeList.GetVolumeCount(); ii++)
        {
            pVolume = (CVolume *) m_VolumeList.GetVolumeAt(ii);
            if (pVolume)
            {
                pVolume->PingEngine();
            }
        }

        SetTimer(PING_TIMER_ID, PING_TIMER, NULL);
        break;
        }

    default:
        EE_ASSERT(FALSE);
        break;
    }

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::get_EngineState
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::get_EngineState(short * pVal)
{
    // sets pVal to current engine state
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume) {
        *pVal = (short) pVolume->EngineState();
    }
    else {
        *pVal = 0;
    }
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::get_IsEngineRunning
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::get_IsEngineRunning(BOOL *pVal)
{
    // TRUE or FALSE whether current engine is running
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume) {
        *pVal = (pVolume->EngineState() == ENGINE_STATE_RUNNING);
    }
    else {
        *pVal = FALSE;
    }
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::get_IsOkToRun
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::get_IsOkToRun(BOOL *pVal)
{
    *pVal = m_IsOkToRun;

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::get_IsEnginePaused
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::get_IsEnginePaused(BOOL *pVal)
{
    // TRUE or FALSE whether current engine is paused
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume) {
        *pVal = pVolume->Paused();
    }
    else {
        *pVal = FALSE;
    }
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::get_IsDefragInProcess
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::get_IsDefragInProcess(BOOL *pVal)
{
    // TRUE or FALSE whether any engine is running
    *pVal = m_VolumeList.DefragInProcess();
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::get_IsVolListLocked
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::get_IsVolListLocked(BOOL *pVal)
{
    // TRUE or FALSE if current volume is locked
    *pVal = m_VolumeList.Locked();
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::get_ReportStatus
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::get_ReportStatus(BOOL * pVal)
{
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume) {
        *pVal = pVolume->IsReportOKToDisplay();
    }
    else {
        *pVal = FALSE;
    }

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::get_Command
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::get_Command(short * pVal)
{
    // not used so far
    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::put_Command
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::put_Command(short newVal)
{
    // get a pointer to the current volume
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume == (CVolume *) NULL) {
        return S_OK;
    }

    switch (newVal){
    case ID_REFRESH:
        // Display the drives available in the listview.
        m_ListView.GetDrivesToListView();
        Invalidate(TRUE);
        break;

    case ID_REPORT:
        pVolume->ShowReport();
        ::SetFocus(m_pReportButton->GetWindowHandle());
        break;

    case ID_HELP_CONTENTS:
        HtmlHelp(
            m_hWndCD,
            TEXT("defrag.chm::/defrag_overview.htm"),
            HH_DISPLAY_TOPIC, //HH_TP_HELP_CONTEXTMENU,
            NULL); //(DWORD)(LPVOID)myarray);
        break;

    case ID_STOP:
        m_ListView.SetFocus();      // list box gets focus
        pVolume->StopEngine();
        break;

    case ID_ABORT:
        pVolume->AbortEngine();
        break;

    case ID_PAUSE:
        pVolume->PauseEngine();
        break;

    case ID_CONTINUE:
        if (!pVolume->ContinueEngine()){
            if (GetLastError() == ESI_VOLLIST_ERR_MUST_RESTART){
                VString msg(IDS_MUST_RESTART, GetDfrgResHandle());
                VString title(IDS_DK_TITLE, GetDfrgResHandle());
                MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_OK|MB_ICONWARNING);
            }
        }
        break;

    case ID_ANALYZE:
        m_ListView.SetFocus();      // list box gets focus
        m_VolumeList.Locked(TRUE);
        pVolume->Analyze();
        m_VolumeList.Locked(FALSE);
        break;

    case ID_DEFRAG:
        m_ListView.SetFocus();      // list box gets focus
        m_VolumeList.Locked(TRUE);
        pVolume->Defragment();
        m_VolumeList.Locked(FALSE);
        break;

    default:
        return S_OK;

    }

    SetButtonState();

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::CreateButtons
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::CreateButtons(void)
{
    m_pAnalyzeButton    = new ESButton(m_hWndCD, ID_ANALYZE,  _Module.GetModuleInstance());
    m_pDefragButton     = new ESButton(m_hWndCD, ID_DEFRAG,   _Module.GetModuleInstance());
    m_pPauseButton      = new ESButton(m_hWndCD, ID_PAUSE,    _Module.GetModuleInstance());
    m_pStopButton       = new ESButton(m_hWndCD, ID_STOP,     _Module.GetModuleInstance());
    m_pReportButton     = new ESButton(m_hWndCD, ID_REPORT,   _Module.GetModuleInstance());

    // if any buttons fail, abort the whole thing and mark have buttons false
    if (m_pAnalyzeButton == NULL || m_pDefragButton == NULL || m_pPauseButton == NULL || 
        m_pStopButton == NULL || m_pReportButton == NULL) {

        Message(TEXT("CDfrgCtl::CreateButtons failed to alloc memory"), -1, NULL);
        m_bHaveButtons = FALSE;
        DestroyButtons();
        return E_OUTOFMEMORY;
    }

    // if all ok, set up buttons
    m_bHaveButtons = TRUE;

    m_pAnalyzeButton->SetFont(m_hFont);
    m_pAnalyzeButton->LoadString(GetDfrgResHandle(), IDS_BTN_ANALYZE);

    m_pDefragButton->SetFont(m_hFont);
    m_pDefragButton->LoadString(GetDfrgResHandle(), IDS_BTN_DEFRAGMENT);

    m_pPauseButton->SetFont(m_hFont);
    m_pPauseButton->LoadString(GetDfrgResHandle(), IDS_BTN_PAUSE);

    m_pStopButton->SetFont(m_hFont);
    m_pStopButton->LoadString(GetDfrgResHandle(), IDS_BTN_STOP);

    m_pReportButton->SetFont(m_hFont);
    m_pReportButton->LoadString(GetDfrgResHandle(), IDS_BTN_REPORT);

    SetButtonState();

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::DestroyButtons
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::DestroyButtons(void)
{
    if (m_pAnalyzeButton) {
        delete m_pAnalyzeButton;
    }
    if (m_pDefragButton) {
        delete m_pDefragButton;
    }
    if (m_pPauseButton) {
        delete m_pPauseButton;
    }
    if (m_pStopButton) {
        delete m_pStopButton;
    }
    if (m_pReportButton) {
        delete m_pReportButton;
    }

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::PaintClusterMap
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CDfrgCtl::PaintClusterMap(
    IN BOOL bPartialRedraw,
    HDC WorkDC
    )
{
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume == (CVolume *) NULL) {
        return FALSE;
    }

    /////////////////////////////////////////////////////////////////
    // Status text written in the graphics wells
    /////////////////////////////////////////////////////////////////

    // make the text white in all color schemes
//  SetTextColor(WorkDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
//  SetBkMode(WorkDC, TRANSPARENT);

    UINT defaultId;
    if (pVolume->NoGraphicsMemory() || 
        pVolume->m_AnalyzeDisplay.NoGraphicsMemory() || 
        pVolume->m_DefragDisplay.NoGraphicsMemory()) {
        defaultId = IDS_NO_GRAPHICS_MEMORY;
    }
    else {
        defaultId = IDS_LABEL_RESIZING;
    }

    // get the label that appears in the graphics wells
    VString defragLabel;
    VString analyzeLabel;
    VString statusLabel;
    VString compactingLabel(IDS_COMPACTING_FILES, GetDfrgResHandle());
    VString movingLabel(IDS_MOVING_FILES, GetDfrgResHandle());

    analyzeLabel.Empty();
    defragLabel.Empty();
    statusLabel.Empty();

    switch (pVolume->DefragState()){
    case DEFRAG_STATE_ANALYZING:
    case DEFRAG_STATE_REANALYZING:
        analyzeLabel = pVolume->DisplayLabel();
        analyzeLabel.AddChar(L' ');
        analyzeLabel += pVolume->sDefragState();
        statusLabel = analyzeLabel;
        //acs bug #101862// 
        statusLabel += _T(" ");
        statusLabel += pVolume->cPercentDone();
        statusLabel += _T("%");
        if (pVolume->PausedBySnapshot()) {
            pVolume->m_AnalyzeDisplay.SetReadyToDraw(FALSE);
        }
        break;

    case DEFRAG_STATE_ENGINE_DEAD:
        analyzeLabel = pVolume->DisplayLabel();
        analyzeLabel.AddChar(L' ');
        analyzeLabel += pVolume->sDefragState();
        statusLabel = analyzeLabel;
        break;

    case DEFRAG_STATE_DEFRAGMENTING:
        analyzeLabel.LoadString(defaultId, GetDfrgResHandle());
        defragLabel = pVolume->DisplayLabel();
        defragLabel.AddChar(L' ');
        defragLabel += pVolume->sDefragState();
        statusLabel += defragLabel;
        //acs bug #101862// 
        UINT mmpass;
        mmpass = pVolume->Pass();

       if (pVolume->PausedBySnapshot()) {
            pVolume->m_DefragDisplay.SetReadyToDraw(FALSE);    
        }
       else {

            if(mmpass == 2 || mmpass == 4 || mmpass == 6)
            {
                statusLabel += _T(" ");
                statusLabel += pVolume->cPercentDone();
                statusLabel += _T("%");
                statusLabel += compactingLabel;
            } else
            {
                statusLabel += _T(" ");
                statusLabel += pVolume->cPercentDone();
                statusLabel += _T("%");
                statusLabel += movingLabel;
                statusLabel += pVolume->m_fileName;
            }
       }
         break;

    case DEFRAG_STATE_BOOT_OPTIMIZING:
        analyzeLabel.LoadString(defaultId, GetDfrgResHandle());
        defragLabel = pVolume->DisplayLabel();
        defragLabel.AddChar(L' ');
        defragLabel += pVolume->sDefragState();
        statusLabel += defragLabel;

       if (pVolume->PausedBySnapshot()) {
            pVolume->m_DefragDisplay.SetReadyToDraw(FALSE);    
        }
       else {
            statusLabel += _T(" ");
            statusLabel += pVolume->cPercentDone();
            statusLabel += _T("%");
            statusLabel += compactingLabel;
        }
       break;


    case DEFRAG_STATE_ANALYZED:
        analyzeLabel.LoadString(defaultId, GetDfrgResHandle());
        statusLabel = pVolume->DisplayLabel();
        statusLabel.AddChar(L' ');
        statusLabel += pVolume->sDefragState();
        break;

    case DEFRAG_STATE_DEFRAGMENTED:
        analyzeLabel.LoadString(defaultId, GetDfrgResHandle());
        defragLabel.LoadString(defaultId, GetDfrgResHandle());
        statusLabel = pVolume->DisplayLabel();
        statusLabel.AddChar(L' ');
        statusLabel += pVolume->sDefragState();
        break;
    }

    // override the others if the user pressed "Stop"
    if (pVolume->StoppedByUser()){
        analyzeLabel.Empty();
        defragLabel.Empty();
        statusLabel.Empty();
    }


    pVolume->m_AnalyzeDisplay.SetLabel(analyzeLabel.GetBuffer());
    pVolume->m_DefragDisplay.SetLabel(defragLabel.GetBuffer());

    // write the text into the graphic wells
//  ::DrawText(WorkDC, analyzeLabel, analyzeLabel.GetLength(), &rcAnalyzeDisp, DT_CENTER);
//  ::DrawText(WorkDC, defragLabel,  defragLabel.GetLength(), &rcDefragDisp, DT_CENTER);



#ifndef ESI_PROGRESS_BAR
    // add the progress bar percent to the status text
    // Format: "left status well text"|"%percentdone"|"right status well text"
    // we are not currently using the right well, but we could if we ever 
    // get an accurate progress bar percentage...
    statusLabel += _T("|%");
    statusLabel += pVolume->cPercentDone();
#endif

    // send the status text to the lower-left status box
    SendStatusChange(statusLabel.GetBuffer());

    //Do the draw.
    pVolume->m_AnalyzeDisplay.DrawLinesInHDC(WorkDC);

    //Do the draw.
    pVolume->m_DefragDisplay.DrawLinesInHDC(WorkDC);

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::InvalidateProgressBar
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
#ifdef ESI_PROGRESS_BAR
void CDfrgCtl::InvalidateProgressBar(void)
{
    if (!InvalidateRect(&rcProgressBarBG, FALSE)){
        Message(L"CDfrgCtl::InvalidateProgressBar()", GetLastError(), NULL);
    }
}
#endif


//-------------------------------------------------------------------*
//  function:   CDfrgCtl::InvalidateGraphicsWindow
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
void CDfrgCtl::InvalidateGraphicsWindow(void)
{
    if(::IsWindow(m_hWnd))
    {
        if (!InvalidateRect(&rcGraphicsBG, FALSE))
        {
            Message(L"CDfrgCtl::InvalidateGraphicsWindow()", GetLastError(), NULL);
        }
    }
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::PaintGraphicsWindow
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CDfrgCtl::PaintGraphicsWindow(HDC OutputDC)
{
    // total background in local coordinates
    RECT tmpGraphicsBGLocal = {0};
    tmpGraphicsBGLocal.bottom = rcGraphicsBG.bottom - rcGraphicsBG.top;
    tmpGraphicsBGLocal.right = rcGraphicsBG.right - rcGraphicsBG.left;

    HANDLE hBitmap = ::CreateCompatibleBitmap(
        OutputDC, 
        rcGraphicsBG.right - rcGraphicsBG.left, 
        rcGraphicsBG.bottom - rcGraphicsBG.top);

    if (hBitmap == NULL)
        return 0;

    // Now we need a memory DC to copy old bitmap to new one.
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EF_ASSERT(WorkDC);

    HANDLE hOld = ::SelectObject(WorkDC, hBitmap);

    // Paint the background of the legend
    HBRUSH hBrush = ::CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    EF_ASSERT(hBrush);

    ::FillRect(WorkDC, &tmpGraphicsBGLocal, hBrush);
    ::DeleteObject(hBrush);

    // edge below the list view is at the very top of this window
    ::DrawEdge(WorkDC, &tmpGraphicsBGLocal, EDGE_SUNKEN, BF_TOP);

    /////////////////////////////////////////////////////////////////
    // Draw the graphics wells
    /////////////////////////////////////////////////////////////////

    // Fill the dark gray analyze and defrag graphics area
//  hBrush = ::CreateSolidBrush(GetSysColor(COLOR_3DSHADOW));
//  EF_ASSERT(hBrush);
//  ::FillRect(WorkDC, &rcAnalyzeDisp, hBrush);
//  ::FillRect(WorkDC, &rcDefragDisp, hBrush);
//  ::DeleteObject(hBrush);

    // Draw the sunken box borders around the analyze and defragment graphics displays
//  ::DrawBorderEx(WorkDC, rcAnalyzeBorder, SUNKEN_BOX);
//  ::DrawBorderEx(WorkDC, rcDefragBorder, SUNKEN_BOX);

    // Draw the text above the analyze and defrag displays
    ::SetBkColor(WorkDC, GetSysColor(COLOR_BTNFACE));
    ::SetBkMode(WorkDC, OPAQUE);
    if (m_IsOkToRun){
        ::SetTextColor(WorkDC, GetSysColor(COLOR_BTNTEXT));
    }
    else {
        ::SetTextColor(WorkDC, GetSysColor(COLOR_GRAYTEXT));
    }

    ::SelectObject(WorkDC, m_hFont);

    // write the graphic wells' labels
    VString textMsg;
    textMsg.LoadString(IDS_LABEL_ANALYSIS_DISPLAY, GetDfrgResHandle());
    UINT oldTxtAlignMode = ::SetTextAlign(WorkDC, TA_BOTTOM|TA_LEFT);
    ::TextOut(
        WorkDC, 
        rcAnalyzeDisp.left-0, 
        rcAnalyzeDisp.top-6,
        textMsg.GetBuffer(), 
        textMsg.GetLength());

    textMsg.LoadString(IDS_LABEL_DEFRAG_DISPLAY, GetDfrgResHandle());
    ::TextOut(
        WorkDC, 
        rcDefragDisp.left-1,
        rcDefragDisp.top-6, 
        textMsg.GetBuffer(), 
        textMsg.GetLength());

    ::SetTextAlign(WorkDC, oldTxtAlignMode);

    PaintClusterMap(FALSE, WorkDC);

    ::BitBlt(OutputDC, // screen DC
        rcGraphicsBG.left,
        rcGraphicsBG.top,
        rcGraphicsBG.right-rcGraphicsBG.left, 
        rcGraphicsBG.bottom-rcGraphicsBG.top, 
        WorkDC,
        0, 0,
        SRCCOPY);

    // Cleanup the bitmap stuff.
    ::SelectObject(WorkDC, hOld);
    ::DeleteObject(hBitmap);
    ::DeleteDC(WorkDC);

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::DrawButtons
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CDfrgCtl::DrawButtons(HDC OutputDC)
{
    // total background in local coordinates
    RECT tmpButtonBGLocal = {0};
    tmpButtonBGLocal.bottom = rcButtonBG.bottom - rcButtonBG.top;
    tmpButtonBGLocal.right = rcButtonBG.right - rcButtonBG.left;

    HANDLE hBitmap = ::CreateCompatibleBitmap(
        OutputDC, 
        rcButtonBG.right - rcButtonBG.left, 
        rcButtonBG.bottom - rcButtonBG.top);

    if (hBitmap == NULL)
        return 0;

    // Now we need a memory DC to copy old bitmap to new one.
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EF_ASSERT(WorkDC);

    HANDLE hOld = ::SelectObject(WorkDC, hBitmap);

    // Paint the background of the buttons
    HBRUSH hBrush = ::CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    EF_ASSERT(hBrush);
    ::FillRect(WorkDC, &tmpButtonBGLocal, hBrush);
    ::DeleteObject(hBrush);

    ::BitBlt(OutputDC, // screen DC
        rcButtonBG.left,
        rcButtonBG.top,
        rcButtonBG.right-rcButtonBG.left, 
        rcButtonBG.bottom-rcButtonBG.top, 
        WorkDC,
        0, 0,
        SRCCOPY);

    // Cleanup the bitmap stuff.
    ::SelectObject(WorkDC, hOld);
    ::DeleteObject(hBitmap);
    ::DeleteDC(WorkDC);

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::SizeLegend
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
void CDfrgCtl::SizeLegend()
{ 
    int x = 0, y = 0, i;

    // get the x and y size of the legend bitmap
    // use the size of number 0 as representative of all bitmaps
    // if they someday vary in size, put this call back into the loop
    m_pLegend->GetBmpSize(0, &x, &y);

    if (m_LegendTextWidth == 0) {
        // calculate the width of the legend with all the 
        // entries on one line

        HDC OutputDC = GetDC();
        EV_ASSERT(OutputDC);
        HDC WorkDC = ::CreateCompatibleDC(OutputDC);
        EV_ASSERT(WorkDC);
        ::SelectObject(WorkDC, m_hFont);

        // use the width of X to determine the spacer between legend entries
        m_LegendTextSpacer = 3 * GetStringWidth(_T("X"), WorkDC);

        m_LegendTextWidth = m_Margin;
        UINT iStringWidth;
        for (i=0; i < (SIMPLE_DISPLAY?4:7); i++) {
            // calc the width of the legend string
            iStringWidth = GetStringWidth(m_LegendData[i].text.GetBuffer(), WorkDC);

            // save the string width
            m_LegendData[i].length = x + iStringWidth + m_LegendTextSpacer;

            // calculate the overall length
            m_LegendTextWidth += m_LegendData[i].length; // add the space and the bitmap
        }
        // calculate the spacer between the top of the bitmaps and the legend rectangle
        m_BitmapVOffset = (m_LegendHeight - y) / 2;
        // subtract off the last spacers
        m_LegendTextWidth -= x + m_LegendTextSpacer;

        ::DeleteDC(WorkDC);
        EH_ASSERT(ReleaseDC(OutputDC)); // member function
    }

    // this is the longest that the text can be and still have the progress
    // bar on the same line, based on the current window width
#ifdef ESI_PROGRESS_BAR
    int legendTextMaxWidth = 
        m_rcCtlRect.right - 
        2*m_Margin - 
        2*m_EtchedLineOffset - m_ProgressBarLength;
#else
    int legendTextMaxWidth = 
        m_rcCtlRect.right - 
        2*m_Margin - 
        2*m_EtchedLineOffset;
#endif

#ifdef ESI_PROGRESS_BAR
    // check if we need to move the progress bar down
    if (m_LegendTextWidth < legendTextMaxWidth){ // if true, all on 1 line

        m_IsProgressBarMoved = FALSE;

        // progress bar background (absolute coords)
        rcProgressBarBG.right = m_rcCtlRect.right;
        rcProgressBarBG.left = m_rcCtlRect.right - m_Margin - m_ProgressBarLength - m_EtchedLineOffset;
        rcProgressBarBG.bottom = m_rcCtlRect.bottom;
        rcProgressBarBG.top = m_rcCtlRect.bottom - 2*m_EtchedLineOffset - m_LegendHeight;

        // legend background (absolute coords)
        rcLegendBG.left = m_rcCtlRect.left;
        rcLegendBG.top = m_rcCtlRect.bottom - 2*m_EtchedLineOffset - m_LegendHeight;
        rcLegendBG.right = m_rcCtlRect.right - m_Margin - m_ProgressBarLength - m_EtchedLineOffset;
        rcLegendBG.bottom = m_rcCtlRect.bottom;

        // calculate the rectangle positions for the legend bitmaps
        int currentLineLength = 0;
        for (i=0; i<(SIMPLE_DISPLAY?4:7); i++) {
            m_LegendData[i].rcBmp.top = 0;
            m_LegendData[i].rcBmp.bottom = m_LegendData[i].rcBmp.top + y;
            m_LegendData[i].rcBmp.left = currentLineLength;
            m_LegendData[i].rcBmp.right = m_LegendData[i].rcBmp.left + x;
            currentLineLength += m_LegendData[i].length;
        }
    }
    else { // need to move progress bar down below text
        m_IsProgressBarMoved = TRUE;

        // progress bar background (absolute coords)
        rcProgressBarBG.right = m_rcCtlRect.right;
        rcProgressBarBG.left = m_rcCtlRect.left;
        rcProgressBarBG.bottom = m_rcCtlRect.bottom;
        rcProgressBarBG.top = m_rcCtlRect.bottom - 2*m_EtchedLineOffset - m_LegendHeight;
#endif
        int yOffset = 0; // use a Bitmap coordinate system first, stack from the top
        int screenWidth = m_rcCtlRect.right - m_rcCtlRect.left - 2 * m_Margin;

        // start the first legend entry off at the upper left
        m_LegendData[0].rcBmp.top = 0;
        m_LegendData[0].rcBmp.left = 0;
        int currentLineLength = m_LegendData[0].length;

        // loop thru the rest of the entries (note the loop starts at 1!)
        // and determine if they will fit on the current line, or if
        // we need to start another line
        for (i=1; i<(SIMPLE_DISPLAY?4:7); i++) {
            if (currentLineLength + m_LegendData[i].length > screenWidth){
                // need to go to the next line
                yOffset += m_FontHeight + m_LegendGraphicSpacer; // add height of bitmap and a spacer
                m_LegendData[i].rcBmp.top = yOffset;
                m_LegendData[i].rcBmp.left = 0;
                // current length of current line is reset
                currentLineLength = m_LegendData[i].length;
            }
            else { // it will fit on this line
                m_LegendData[i].rcBmp.top = yOffset;
                m_LegendData[i].rcBmp.left = currentLineLength;
                currentLineLength += m_LegendData[i].length;
            }
        }

#ifdef ESI_PROGRESS_BAR
        rcLegendBG.left = m_rcCtlRect.left;
        rcLegendBG.right = m_rcCtlRect.right;
        rcLegendBG.top = m_rcCtlRect.bottom - 
            (m_LegendHeight + 4*m_EtchedLineOffset + y + 2*m_BitmapVOffset + yOffset);
        rcLegendBG.bottom = m_rcCtlRect.bottom -
            (m_LegendHeight + 2*m_EtchedLineOffset);
    }
#else
        // legend background (absolute coords)
        rcLegendBG.left = m_rcCtlRect.left;
        rcLegendBG.right = m_rcCtlRect.right;
        rcLegendBG.bottom = m_rcCtlRect.bottom;
        rcLegendBG.top = m_rcCtlRect.bottom - 
            (2*m_EtchedLineOffset + y + 2*m_BitmapVOffset + yOffset);
#endif
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::DrawSingleInstanceScreen
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CDfrgCtl::DrawSingleInstanceScreen(HDC OutputDC)
{

    HANDLE hBitmap = ::CreateCompatibleBitmap(
        OutputDC, 
        m_rcCtlRect.right - m_rcCtlRect.left, 
        m_rcCtlRect.bottom - m_rcCtlRect.top);

    if (hBitmap == NULL)
        return FALSE;

    // Now we need a memory DC to copy old bitmap to new one.
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EF_ASSERT(WorkDC);

    HANDLE hOld = ::SelectObject(WorkDC, hBitmap);

    // Paint the background of the legend
    HBRUSH hBrush = ::CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    EF_ASSERT(hBrush);
    ::FillRect(WorkDC, &m_rcCtlRect, hBrush);
    ::DeleteObject(hBrush);

    ::BitBlt(OutputDC, // screen DC
        0,
        0,
        m_rcCtlRect.right-m_rcCtlRect.left, 
        m_rcCtlRect.bottom-m_rcCtlRect.top, 
        WorkDC,
        0, 0,
        SRCCOPY);

    HBITMAP hCriticalIcon = (HBITMAP)::LoadImage(
        GetDfrgResHandle(),
        MAKEINTRESOURCE(IDB_CRITICALICON_GREY),
        IMAGE_BITMAP,
        0, 0,
        LR_LOADTRANSPARENT|LR_LOADMAP3DCOLORS);

    ::SelectObject(WorkDC, hCriticalIcon);

    ::BitBlt(OutputDC, // screen DC
        10,
        10,
        m_rcCtlRect.right-m_rcCtlRect.left, 
        m_rcCtlRect.bottom-m_rcCtlRect.top, 
        WorkDC,
        0, 0,
        SRCCOPY);

    // Cleanup the bitmap stuff.
    ::SelectObject(WorkDC, hOld);
    ::DeleteObject(hCriticalIcon);
    ::DeleteObject(hBitmap);
    ::DeleteDC(WorkDC);

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::DrawLegend
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CDfrgCtl::DrawLegend(HDC OutputDC)
{
    int x = 0, y = 0;

    m_pLegend->GetBmpSize(0, &x, &y);

    // total legend background in local coordinates
    RECT tmpLegendBGLocal = {0};
    tmpLegendBGLocal.bottom = rcLegendBG.bottom - rcLegendBG.top;
    tmpLegendBGLocal.right = rcLegendBG.right - rcLegendBG.left;

    HANDLE hBitmap = ::CreateCompatibleBitmap(
        OutputDC, 
        rcLegendBG.right - rcLegendBG.left, 
        rcLegendBG.bottom - rcLegendBG.top);

    if (hBitmap == NULL)
        return FALSE;

    // Now we need a memory DC to copy old bitmap to new one.
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EF_ASSERT(WorkDC);

    HANDLE hOld = ::SelectObject(WorkDC, hBitmap);

    // Paint the background of the legend
    HBRUSH hBrush = ::CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    EF_ASSERT(hBrush);
    ::FillRect(WorkDC, &tmpLegendBGLocal, hBrush);
    ::DeleteObject(hBrush);

    // select the font
    ::SetBkColor(WorkDC, GetSysColor(COLOR_BTNFACE));
    ::SetBkMode(WorkDC, OPAQUE);
    if (m_IsOkToRun){
        ::SetTextColor(WorkDC, GetSysColor(COLOR_BTNTEXT));
    }
    else {
        ::SetTextColor(WorkDC, GetSysColor(COLOR_GRAYTEXT));
    }
    ::SelectObject(WorkDC, m_hFont);

    // use for debugging
    //::DrawEdge(WorkDC, &tmpLegendBGLocal, EDGE_RAISED, BF_RECT);

    RECT rcBmp;
    RECT rcLegend = tmpLegendBGLocal;
    rcLegend.left += m_Margin;
    rcLegend.top += m_EtchedLineOffset;
    rcLegend.bottom -= m_EtchedLineOffset;

    // Draw the legend at the bottom
    for (int i=0; i<(SIMPLE_DISPLAY?4:7); i++) {

        // rcBmp gets the bitmap position in absolute coordinates
        rcBmp.top =  rcLegend.top + m_BitmapVOffset + m_LegendData[i].rcBmp.top;
        rcBmp.left = rcLegend.left + m_LegendData[i].rcBmp.left;
        rcBmp.bottom = rcBmp.top + y;
        rcBmp.right = rcBmp.left + x;

        // draw bitmap in upper-left corner of rectangle
        m_pLegend->DrawBmpInHDCTruncate(WorkDC, i, &rcBmp);

        // draw the text 5 units to the right of the bitmap
        ::TextOut(
            WorkDC, 
            rcBmp.left + x + m_LegendGraphicSpacer, 
            rcBmp.top-0, 
            m_LegendData[i].text.GetBuffer(), 
            m_LegendData[i].text.GetLength());
    }

    // etched line on top of legend
    RECT rcHorizontalDivider = tmpLegendBGLocal;
    rcHorizontalDivider.left += m_Margin;
    rcHorizontalDivider.right += 1; // small adjustment

    // is the progress bar is on the bottom, adjust the line in from the margin
#ifdef ESI_PROGRESS_BAR
    if (m_IsProgressBarMoved){
        rcHorizontalDivider.right -= m_Margin;
    }
#else
    rcHorizontalDivider.right -= m_Margin;
#endif

    // rectangle used as the horizontal divider line (top, and bottom if necessary)
    ::DrawEdge(WorkDC, &rcHorizontalDivider, EDGE_ETCHED, BF_TOP);

    ::BitBlt(OutputDC, // screen DC
        rcLegendBG.left,
        rcLegendBG.top,
        rcLegendBG.right-rcLegendBG.left, 
        rcLegendBG.bottom-rcLegendBG.top, 
        WorkDC,
        0, 0,
        SRCCOPY);

    // Cleanup the bitmap stuff.
    ::SelectObject(WorkDC, hOld);
    ::DeleteObject(hBitmap);
    ::DeleteDC(WorkDC);

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::DrawProgressBar
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
#ifdef ESI_PROGRESS_BAR
BOOL CDfrgCtl::DrawProgressBar(HDC OutputDC)
{
    UINT percentDone = 0;
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume){
        percentDone = pVolume->PercentDone();
    }

    // total progress background in local coordinates
    RECT tmpProgressBarBGLocal = {0};
    tmpProgressBarBGLocal.bottom = rcProgressBarBG.bottom - rcProgressBarBG.top;
    tmpProgressBarBGLocal.right = rcProgressBarBG.right - rcProgressBarBG.left;

    HANDLE hBitmap = ::CreateCompatibleBitmap(
        OutputDC, 
        rcProgressBarBG.right - rcProgressBarBG.left, 
        rcProgressBarBG.bottom - rcProgressBarBG.top);

    if (hBitmap == NULL)
        return FALSE;

    // Now we need a memory DC to copy old bitmap to new one.
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EF_ASSERT(WorkDC);

    HANDLE hOld = ::SelectObject(WorkDC, hBitmap);

    // Paint the background of the legend
    HBRUSH hBrush = ::CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    EF_ASSERT(hBrush);
    ::FillRect(WorkDC, &tmpProgressBarBGLocal, hBrush);
    ::DeleteObject(hBrush);

    // use for debugging
    //DrawEdge(WorkDC, &tmpProgressBarBGLocal, EDGE_RAISED, BF_RECT);

    // find the actual outline of the progress bar
    rcProgressBar.left = m_Margin;
    rcProgressBar.top = m_EtchedLineOffset + m_ProgressBarOffset;
    rcProgressBar.right = m_EtchedLineOffset + m_ProgressBarLength;
    rcProgressBar.bottom = m_EtchedLineOffset + m_LegendHeight - m_ProgressBarOffset;

    // etched line on top of legend
    RECT rcHorizontalDivider = tmpProgressBarBGLocal;
    rcHorizontalDivider.right -= m_Margin;

    if (m_IsProgressBarMoved){
        rcHorizontalDivider.left += m_Margin;
        // rectangle used as the horizontal divider line (top, and bottom if necessary)
        ::DrawEdge(WorkDC, &rcHorizontalDivider, EDGE_ETCHED, BF_TOP);
    }
    else{
        ::DrawEdge(WorkDC, &rcHorizontalDivider, EDGE_ETCHED, BF_TOP);

        // etched line to the left (if needed)
        RECT rcVerticalDivider = tmpProgressBarBGLocal;
        rcVerticalDivider.top = m_EtchedLineOffset + m_ProgressBarOffset;
        rcVerticalDivider.bottom -= m_EtchedLineOffset + m_ProgressBarOffset;
        // Draw the etched line to the left of the progress bar
        ::DrawEdge(WorkDC, &rcVerticalDivider, EDGE_ETCHED, BF_LEFT);
    }

    ProgressBar(WorkDC,
                &rcProgressBar,
                m_hFont,
                4, // width
                2, // space
                percentDone);

    ::BitBlt(OutputDC, // screen DC
        rcProgressBarBG.left,
        rcProgressBarBG.top,
        rcProgressBarBG.right-rcProgressBarBG.left, 
        rcProgressBarBG.bottom-rcProgressBarBG.top, 
        WorkDC,
        0, 0,
        SRCCOPY);

    // Cleanup the bitmap stuff.
    ::SelectObject(WorkDC, hOld);
    ::DeleteObject(hBitmap);
    ::DeleteDC(WorkDC);

    return TRUE;
}
#endif
//-------------------------------------------------------------------*
//  function:   CDfrgCtl::SizeButtons
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
void CDfrgCtl::SizeButtons(void)
{ 
    /////////////////////////////////////////
    // The button coordinates are absolute!!!
    /////////////////////////////////////////

    // the area around the buttons needed to grey out the background
    rcButtonBG.left = m_rcCtlRect.left;
    rcButtonBG.top = rcLegendBG.top - m_ButtonTopBottomSpacer - m_ButtonHeight;
    rcButtonBG.bottom = rcLegendBG.top;
    rcButtonBG.right = m_rcCtlRect.right;

    HDC OutputDC = GetDC();
    EV_ASSERT(OutputDC);
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EV_ASSERT(WorkDC);
    ::SelectObject(WorkDC, m_hFont);

    TCHAR buttonText[200];
    UINT adjustedButtonWidth;
    const bigButtonSpacer = 20;

    UINT adjustedButtonHeight = __max((UINT)(1.5 * m_FontHeight), m_ButtonHeight);

    // Calculate the Analyze button position and size.
    ::LoadString(GetDfrgResHandle(), IDS_BTN_ANALYZE, buttonText, 200);
    adjustedButtonWidth = __max(bigButtonSpacer + GetStringWidth(buttonText, WorkDC), m_ButtonWidth);

    rcAnalyzeButton.left = m_Margin;
    rcAnalyzeButton.bottom = rcLegendBG.top - m_ButtonTopBottomSpacer;
    rcAnalyzeButton.top = rcAnalyzeButton.bottom - adjustedButtonHeight;
    rcAnalyzeButton.right = rcAnalyzeButton.left + adjustedButtonWidth;

    // start off with all buttons the same as the analyze button
    rcDefragButton = 
    rcPauseButton =
    rcCancelButton =
    rcReportButton = rcAnalyzeButton;

    // Calculate the Defrag button position and size.
    ::LoadString(GetDfrgResHandle(), IDS_BTN_DEFRAGMENT, buttonText, 200);
    adjustedButtonWidth = __max(bigButtonSpacer + GetStringWidth(buttonText, WorkDC), m_ButtonWidth);
    rcDefragButton.left = rcAnalyzeButton.right + m_ButtonSpacer;
    rcDefragButton.right = rcDefragButton.left + adjustedButtonWidth;

    // Calculate the Pause button position and size.
    ::LoadString(GetDfrgResHandle(), IDS_BTN_PAUSE, buttonText, 200);
    adjustedButtonWidth = __max(bigButtonSpacer + GetStringWidth(buttonText, WorkDC), m_ButtonWidth);
    // check to see if the resume text is longer
    ::LoadString(GetDfrgResHandle(), IDS_BTN_RESUME, buttonText, 200);
    adjustedButtonWidth = __max(bigButtonSpacer + GetStringWidth(buttonText, WorkDC), adjustedButtonWidth);
    rcPauseButton.left = rcDefragButton.right + m_ButtonSpacer;
    rcPauseButton.right = rcPauseButton.left + adjustedButtonWidth;

    // Calculate the Cancel button position and size.
    ::LoadString(GetDfrgResHandle(), IDS_BTN_STOP, buttonText, 200);
    adjustedButtonWidth = __max(bigButtonSpacer + GetStringWidth(buttonText, WorkDC), m_ButtonWidth);
    rcCancelButton.left = rcPauseButton.right + m_ButtonSpacer;
    rcCancelButton.right = rcCancelButton.left + adjustedButtonWidth;

    // Calculate the See Report button position and size.
    ::LoadString(GetDfrgResHandle(), IDS_BTN_REPORT, buttonText, 200);
    adjustedButtonWidth = __max(bigButtonSpacer + GetStringWidth(buttonText, WorkDC), m_ButtonWidth);
    rcReportButton.left = rcCancelButton.right + m_ButtonSpacer;
    rcReportButton.right = rcReportButton.left + adjustedButtonWidth;

    // Set the rectangles of the buttons
    if (m_bHaveButtons) {
        m_pAnalyzeButton->PositionButton(&rcAnalyzeButton);
        m_pDefragButton->PositionButton(&rcDefragButton);
        m_pPauseButton->PositionButton(&rcPauseButton);
        m_pStopButton->PositionButton(&rcCancelButton);
        m_pReportButton->PositionButton(&rcReportButton);
    }

    ::DeleteDC(WorkDC);
    EH_ASSERT(ReleaseDC(OutputDC));
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::SizeGraphicsWindow
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CDfrgCtl::SizeGraphicsWindow(void) 
{ 
    rcGraphicsBG.left = m_rcCtlRect.left;
    rcGraphicsBG.right = m_rcCtlRect.right;
    rcGraphicsBG.bottom = rcLegendBG.top - m_ButtonTopBottomSpacer - m_ButtonHeight;
    rcGraphicsBG.top = 
        rcGraphicsBG.bottom - 
        m_ButtonTopBottomSpacer - 
        2*m_GraphicWellHeight - 
        2*m_GraphicWellSpacer;

    // analyze graphics well
    rcAnalyzeDisp.left = m_Margin+1;
    rcAnalyzeDisp.top = m_GraphicWellSpacer;
    rcAnalyzeDisp.bottom = rcAnalyzeDisp.top + m_GraphicWellHeight;
    rcAnalyzeDisp.right = __max(rcGraphicsBG.right - m_Margin, rcReportButton.right);
    
    // defrag graphics well
    rcDefragDisp = rcAnalyzeDisp;
    rcDefragDisp.top = rcAnalyzeDisp.bottom + m_GraphicWellSpacer;
    rcDefragDisp.bottom = rcDefragDisp.top + m_GraphicWellHeight;

    // Calculate the analyze display border.
    rcAnalyzeBorder.top = rcAnalyzeDisp.top - 1;
    rcAnalyzeBorder.left = rcAnalyzeDisp.left - 1;
    rcAnalyzeBorder.right = rcAnalyzeDisp.right;
    rcAnalyzeBorder.bottom = rcAnalyzeDisp.bottom;

    // Calculate the defrag display border.
    rcDefragBorder.top = rcDefragDisp.top - 1;
    rcDefragBorder.left = rcDefragDisp.left - 1;
    rcDefragBorder.right = rcDefragDisp.right;
    rcDefragBorder.bottom = rcDefragDisp.bottom;

    //Set output dimensions on the analyze display rectangle.
    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume == (CVolume *) NULL){
        return FALSE;
    }

    //Set the dimensions.
    pVolume->m_AnalyzeDisplay.SetOutputArea(rcAnalyzeBorder);

    //Set the dimensions.
    pVolume->m_DefragDisplay.SetOutputArea(rcDefragBorder);

    //tell the engines what the line count is
    SET_DISP_DATA DispData = {0};
    DispData.AnalyzeLineCount = pVolume->m_AnalyzeDisplay.GetLineCount();
    DispData.DefragLineCount = pVolume->m_DefragDisplay.GetLineCount();
    DispData.bSendGraphicsUpdate = TRUE;  // send graphics back immediately

    DataIoClientSetData(ID_SETDISPDIMENSIONS,
                        (PTCHAR)&DispData,
                        sizeof(SET_DISP_DATA),
                        pVolume->m_pdataDefragEngine);

    return TRUE;
}


//-------------------------------------------------------------------*
//  function:   CDfrgCtl::SetButtonState
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
void CDfrgCtl::SetButtonState(void)
{
    // sanity check to make sure the buttons are created
    if (!m_bHaveButtons) {
        return;
    }

    CVolume *pVolume = m_VolumeList.GetCurrentVolume();
    if (pVolume == (CVolume *) NULL){
        return;
    }

    // set the pause/resume text correctly
    m_pPauseButton->LoadString(GetDfrgResHandle(), pVolume->Paused() ? IDS_BTN_RESUME : IDS_BTN_PAUSE);

    if (m_VolumeList.Locked() || !m_IsOkToRun){
        m_pAnalyzeButton->EnableButton(FALSE);
        m_pDefragButton->EnableButton(FALSE);
        m_pReportButton->EnableButton(FALSE);
        m_pPauseButton->EnableButton(FALSE);
        m_pStopButton->EnableButton(FALSE);
        return;
    }

    if (pVolume->EngineState() == ENGINE_STATE_RUNNING){ // the selected vol is being analyzed/defragged
        m_pAnalyzeButton->EnableButton(FALSE);
        m_pDefragButton->EnableButton(FALSE);
        m_pPauseButton->EnableButton(TRUE);
        m_pStopButton->EnableButton(TRUE);
        m_pReportButton->EnableButton(FALSE);
    }
    else {
        m_pAnalyzeButton->EnableButton(TRUE);
        m_pDefragButton->EnableButton(TRUE);
        m_pPauseButton->EnableButton(FALSE);
        m_pStopButton->EnableButton(FALSE);
        m_pReportButton->EnableButton(pVolume->IsReportOKToDisplay());
    }
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::GetStringWidth
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
UINT CDfrgCtl::GetStringWidth(PTCHAR stringBuf, HDC WorkDC)
{
    if (!stringBuf){
        return 0;
    }

    UINT iStringWidth = 0;
    int iCharWidth = 0;             //initialize for bugf 445627

    for (UINT i=0; i<wcslen(stringBuf); i++){
        ::GetCharWidth32(
            WorkDC, 
            stringBuf[i], 
            stringBuf[i], 
            &iCharWidth);
        iStringWidth += iCharWidth;
    }

    return iStringWidth;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::IsOnlyInstance
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CDfrgCtl::IsOnlyInstance()
{
    BOOL fFirst = FALSE;
    IDataObject* pData = NULL;

    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;

    if (CheckForAdminPrivs() == FALSE) {
        return FALSE;
    }
    
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = FALSE;

    if (!ConstructSecurityAttributes(&saSecurityAttributes, esatSemaphore, FALSE)) {
        return FALSE;
    }

#ifdef ESI_MULTI_ALLOWED
    return( TRUE );
#endif

    if (CheckForAdminPrivs() == FALSE) {
        return FALSE;
    }
    if (m_hIsOkToRunSemaphore == NULL){
        m_hIsOkToRunSemaphore = CreateSemaphore(&saSecurityAttributes, 1, 1, IS_OK_TO_RUN_SEMAPHORE_NAME);
    }

    CleanupSecurityAttributes(&saSecurityAttributes);
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

    if (m_hIsOkToRunSemaphore){
        // is the semaphore signaled?
        DWORD retValue = WaitForSingleObject(m_hIsOkToRunSemaphore, 10);

        // if so, this process is the only one, and the semaphore count is decremented to 0
        if (retValue == WAIT_OBJECT_0){
            return TRUE;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::SendStatusChange
//
//  returns:    None
//  note:       Loops through all of the connection points and sends 
//              the status change message.
//-------------------------------------------------------------------*
void CDfrgCtl::SendStatusChange( LPCTSTR pszStatus )
{
    BSTR bszStatus;
    if (pszStatus){
        bszStatus = SysAllocString( pszStatus );
    }
    else {
        bszStatus = SysAllocString(_T(""));
    }

    Lock();
    IUnknown** pp = m_vec.begin();
    while (pp < m_vec.end())
    {
        if (*pp != NULL)
        {
            IDfrgEvents* pEvents = reinterpret_cast<IDfrgEvents*>( *pp );
            pEvents->StatusChanged( bszStatus );
        }
        pp++;
    }
    Unlock();

    SysFreeString( bszStatus );
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::SendOKToRun
//
//  returns:    None
//  note:       Loops through all of the connection points and sends 
//              the new OKToRun property.
//-------------------------------------------------------------------*
void CDfrgCtl::SendOKToRun( BOOL bOK )
{
    Lock();
    IUnknown** pp = m_vec.begin();
    while (pp < m_vec.end())
    {
        if (*pp != NULL)
        {
            IDfrgEvents* pEvents = reinterpret_cast<IDfrgEvents*>( *pp );
            pEvents->IsOKToRun( bOK );
        }
        pp++;
    }
    Unlock();
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::TranslateAccelerator
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
STDMETHODIMP CDfrgCtl::TranslateAccelerator(LPMSG pMsg)
{
    HRESULT hr = S_FALSE;       // we didn't handle keypress

    switch( pMsg->message )
    {
    case WM_KEYDOWN:
        {
            switch ( pMsg->wParam )
            {
            case VK_TAB:
                {
                    //
                    // Check for the shift key.
                    //
                    Message(TEXT("CDfrgCtl got a tab key press"), -1, NULL);

                    if ( GetAsyncKeyState( VK_SHIFT ) & 0x8000 )
                        hr = PreviousTab();
                    else
                        hr = NextTab();
                }
                break;

            case VK_SPACE:
                Message(TEXT("CDfrgCtl got a spacebar key press"), -1, NULL);
                break;

            case VK_RETURN:
                Message(TEXT("CDfrgCtl got an enter key press"), -1, NULL);
                hr = HandleEnterKeyPress();
                break;

            case VK_F5:
                m_ListView.GetDrivesToListView();
                hr = S_OK;                          // we handled keypress
                break;
            }
        }
        break;
    default:
        break;
    }

    return( hr );
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::PreviousTab
//
//  returns:    None
//  note:       Handle moving to the previous tab.
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::PreviousTab()
{
    HRESULT hr;
    HWND hWndNext = NULL;
    CTabEnumerator TabEnum(m_hWndCD, FALSE);

    hWndNext = TabEnum.GetNextTabWindow();
    if(hWndNext == NULL)                    //out of memory bug 445628
    {
        return(S_FALSE);
    }

    ::SetFocus(hWndNext);

    if (hWndNext == m_ListView.m_hwndListView)
        hr = S_FALSE;                   // we didn't handle keypress
    else
        hr = S_OK;                      // we handled keypress

    return(hr);
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::NextTab
//
//  returns:    None
//  note:       Handle moving to the next tab.
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::NextTab()
{
    HRESULT hr;
    HWND hWndNext = NULL;
    CTabEnumerator TabEnum(m_hWndCD, TRUE);

    hWndNext = TabEnum.GetNextTabWindow();
    if(hWndNext == NULL)                    //out of memory bug 445628
    {
        return(S_FALSE);
    }

    ::SetFocus(hWndNext);

    if (hWndNext == m_ListView.m_hwndListView)
        hr = S_FALSE;                   // we didn't handle keypress
    else
        hr = S_OK;                      // we handled keypress

    return(hr);
}

//-------------------------------------------------------------------*
//  function:   CDfrgCtl::GetNextTabWindow
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HWND CTabEnumerator::GetNextTabWindow()
{
    HWND hWndNext = NULL;
    //
    // Get the window with the current focus.
    //
    HWND hWndCurrent = GetFocus();
    _ASSERTE( hWndCurrent );
    
    //
    // Enumerate our child windows. This should generate
    // a list of child windows.
    //
    EnumChildWindows( m_hWndParent, TabEnumChildren, (LONG_PTR) this );

    //
    // Find the existing position of the focus window.
    //
    HWND* pFind = find( m_Children.begin(), m_Children.end(), hWndCurrent );
    
    //
    // Determine if we need to wrap around to the beginning.
    //
    if (m_fForward)
    {
        if (pFind == m_Children.end() - 1)
            pFind = m_Children.begin();
        else
            pFind++;
    }
    else 
    {
        if (pFind == m_Children.begin())
            pFind = m_Children.end() - 1;
        else
            pFind--;
    }

    hWndNext = *pFind;

    return(hWndNext);
}

//-------------------------------------------------------------------*
//  function:   TabEnumChildren
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CALLBACK TabEnumChildren( HWND hwnd, LPARAM lParam )
{
    reinterpret_cast<CTabEnumerator*>( lParam )->AddChild( hwnd );
    return( TRUE );
}

//-------------------------------------------------------------------*
//  function:   OnContextMenu
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::OnContextMenu(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
    //return( m_ListView.OnContextMenu( (HWND) wParam, LOWORD( lParam ), HIWORD( lParam ) ) );
    HRESULT hr = E_NOTIMPL;

    CVolume *pVolume = m_VolumeList.GetCurrentVolume();

    if (pVolume == (CVolume *) NULL){
        return hr;
    }

    if ( m_ListView.m_hwndListView == (HWND) wParam )
    {
        HMENU hMenu;

        hMenu = ::CreatePopupMenu();
        if ( hMenu != NULL )
        {
            // determine button availability
            BOOL AnalDfrgOk = FALSE;
            BOOL StopPauseOk = FALSE;
            BOOL ReportOk = FALSE;

            if (m_VolumeList.Locked() || !m_IsOkToRun) {                // UI disabled
                AnalDfrgOk = FALSE;
                StopPauseOk = FALSE;
                ReportOk = FALSE;
            }
            else if (pVolume->EngineState() == ENGINE_STATE_RUNNING) {  // the selected vol is being analyzed/defragged
                AnalDfrgOk = FALSE;
                StopPauseOk = TRUE;
                ReportOk = FALSE;
            }
            else {
                AnalDfrgOk = TRUE;
                StopPauseOk = FALSE;
                ReportOk = pVolume->IsReportOKToDisplay();
            }

            TCHAR menuText[200];
            UINT uFlags;

            //
            // Populate context menu.
            //

            // analyze
            ::LoadString(GetDfrgResHandle(), IDS_ANALYZE, menuText, sizeof(menuText) / sizeof(TCHAR));
            uFlags = MF_STRING | (AnalDfrgOk ? MF_ENABLED : MF_GRAYED);
            ::AppendMenu(hMenu, uFlags, ID_ANALYZE, menuText);

            // defrag
            ::LoadString(GetDfrgResHandle(), IDS_DEFRAGMENT, menuText, sizeof(menuText) / sizeof(TCHAR));
            uFlags = MF_STRING | (AnalDfrgOk ? MF_ENABLED : MF_GRAYED);
            ::AppendMenu(hMenu, uFlags, ID_DEFRAG, menuText);

            if (pVolume->Paused()){ // resume
                ::LoadString(GetDfrgResHandle(), IDS_RESUME, menuText, sizeof(menuText) / sizeof(TCHAR));
                uFlags = MF_STRING | (StopPauseOk ? MF_ENABLED : MF_GRAYED);
                ::AppendMenu(hMenu, uFlags, ID_PAUSE, menuText);
            }
            else { // pause
                ::LoadString(GetDfrgResHandle(), IDS_PAUSE, menuText, sizeof(menuText) / sizeof(TCHAR));
                uFlags = MF_STRING | (StopPauseOk ? MF_ENABLED : MF_GRAYED);
                ::AppendMenu(hMenu, uFlags, ID_PAUSE, menuText);
            }

            // stop
            ::LoadString(GetDfrgResHandle(), IDS_STOP, menuText, sizeof(menuText) / sizeof(TCHAR));
            uFlags = MF_STRING | (StopPauseOk ? MF_ENABLED : MF_GRAYED);
            ::AppendMenu(hMenu, uFlags, ID_STOP, menuText);

            // see report
            ::LoadString(GetDfrgResHandle(), IDS_REPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
            uFlags = MF_STRING | (ReportOk ? MF_ENABLED : MF_GRAYED);
            ::AppendMenu(hMenu, uFlags, ID_REPORT, menuText);

            // separator
            ::AppendMenu(hMenu, MF_SEPARATOR, NULL, NULL);

            // refresh
            ::LoadString(GetDfrgResHandle(), IDS_REFRESH, menuText, sizeof(menuText) / sizeof(TCHAR));
            ::AppendMenu(hMenu, MF_STRING | MF_ENABLED, ID_REFRESH, menuText);

            // separator
            ::AppendMenu(hMenu, MF_SEPARATOR, NULL, NULL);

            // help
            ::LoadString(GetDfrgResHandle(), IDS_HELP, menuText, sizeof(menuText) / sizeof(TCHAR));
            ::AppendMenu(hMenu, MF_STRING | MF_ENABLED, ID_HELP_CONTENTS, menuText);


            //
            // Display pop-up.
            //
            // get mouse coordinates
            short xPos = LOWORD(lParam);
            short yPos = HIWORD(lParam);

            // get window screen location
            RECT rect;
            BOOL ok = ::GetWindowRect(m_ListView.m_hwndListView, &rect);
 
            // if we got the window location and the mouse coords are negative, 
            // assume invoked from keyboard and locate menu in window
            if (ok && (xPos < 0 || yPos < 0)) {
                xPos = rect.left + 10;
                yPos = rect.top + 10;
            }

            // map menu
            TrackPopupMenu(hMenu,
                TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                xPos,
                yPos,
                0,
                m_hWndCD, //GetParent( m_hwndListView ),
                NULL );

            ::DestroyMenu(hMenu);
            
            hr = S_OK;
        }
    }

    return( hr );
}


STDMETHODIMP CDfrgCtl::get_Enabled(BOOL *pVal)
{
    if (m_IsOkToRun)
        Message(TEXT("CDfrgCtl::get_Enabled returning TRUE"), -1, NULL);
    else
        Message(TEXT("CDfrgCtl::get_Enabled returning FALSE"), -1, NULL);

    *pVal = m_IsOkToRun;

    return S_OK;
}

STDMETHODIMP CDfrgCtl::put_Enabled(BOOL newVal)
{
    if (newVal)
        Message(TEXT("CDfrgCtl::put_Enabled got TRUE"), -1, NULL);
    else
        Message(TEXT("CDfrgCtl::put_Enabled got FALSE"), -1, NULL);

    return S_OK;
}

//-------------------------------------------------------------------*
//  function:   OnSetFocus
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
LRESULT CDfrgCtl::OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Message(TEXT("CDfrgCtl::OnSetFocus"), -1, NULL);

    CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
    if (m_bInPlaceActive && spSite)
    {
        spSite->OnFocus(TRUE);
        m_ListView.SetFocus();      // list box gets focus first
    }

    return 0;
}

LRESULT CDfrgCtl::OnKillFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    Message(TEXT("CDfrgCtl::OnKillFocus"), -1, NULL);

    CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
    if (m_bInPlaceActive && spSite)
        spSite->OnFocus(FALSE);
    return 0;
}

//-------------------------------------------------------------------*
//  function:   HandleEnterKeyPress
//
//  returns:    S_OK:       we handled keypress
//              S_FALSE:    we didn't handle keypress
//  note:       
//-------------------------------------------------------------------*
HRESULT CDfrgCtl::HandleEnterKeyPress()
{
    HWND     hWndCurrent = GetFocus();      // current focus window
    HRESULT  hr = S_FALSE;

    if (hWndCurrent == m_pAnalyzeButton->GetWindowHandle())
    {
        put_Command(ID_ANALYZE);
        hr = S_OK;
    }
    else if (hWndCurrent == m_pDefragButton->GetWindowHandle())
    {
        put_Command(ID_DEFRAG);
        hr = S_OK;
    }
    else if (hWndCurrent == m_pPauseButton->GetWindowHandle())
    {
        put_Command(ID_PAUSE);
        hr = S_OK;
    }
    else if (hWndCurrent == m_pStopButton->GetWindowHandle())
    {
        put_Command(ID_STOP);
        hr = S_OK;
    }
    else if (hWndCurrent == m_pReportButton->GetWindowHandle())
    {
        // is the engine IDLE?
        CVolume *pVolume = m_VolumeList.GetCurrentVolume();
        if (pVolume)
        {
            if(pVolume->EngineState() == ENGINE_STATE_IDLE)
            {
                RaiseReportDialog(pVolume);
                hr = S_OK;
                ::SetFocus(m_pReportButton->GetWindowHandle());
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dfrgui.cpp ===
// DfrgUI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f DfrgUIps.mk in the project directory.

#include "stdafx.h"
#include "DfrgUI.h"
#include "DataIo.h"
#include "DataIoCl.h"
#include "Message.h"
#include "DfrgUI_i.c"
#include "DfrgCtl.h"
#include "GetDfrgRes.h"

/////////////////////////////////////////////////////////////////////////////

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DfrgCtl, CDfrgCtl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{

        SHFusionInitialize(NULL);
		_Module.Init(ObjectMap, hInst);
		BOOL isOk = DisableThreadLibraryCalls(hInst);

        Message(TEXT("DllMain - DLL_PROCESS_ATTACH"), -1, NULL);

	}
    else if (dwReason == DLL_PROCESS_DETACH) {
        Message(TEXT("DllMain - DLL_PROCESS_DETACH"), -1, NULL);

		ExitDataIo();

        SHFusionUninitialize();

		BOOL bIsLibraryNotFree = TRUE;
		if(GetDfrgResHandle() != NULL)
		{
			while(bIsLibraryNotFree)
			{
				bIsLibraryNotFree = FreeLibrary(GetDfrgResHandle());
			}
		}

		_Module.Term();
    }
	return TRUE;    // ok
}
/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dlganl.cpp ===
/*****************************************************************************************************************

FILENAME: DlgAnl.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/
#include "stdafx.h"

#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif

#include "DfrgUI.h"
#include "DfrgCmn.h"
#include "DfrgCtl.h"
#include "resource.h"
#include "DlgRpt.h"
#include "DlgAnl.h"
#include "GetDfrgRes.h"
#include "DfrgHlp.h"
#include "VolList.h"
#include "genericdialog.h"
static CVolume *pLocalVolume = NULL;
static HFONT hDlgFont = NULL;

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Raises the Analyze Complete dialog

GLOBAL VARIABLES:
None

INPUT:
    IN pVolume - address of volume that has just completed Analyzing

RETURN:
    TRUE - Worked OK
    FALSE - Failure
*/
BOOL RaiseAnalyzeDoneDialog(
    CVolume *pVolume
)
{
    pLocalVolume = pVolume;
    VString dlgString;
    UINT iWhichKeyPressed = NULL;
    CGenericDialog* genericdialog = new CGenericDialog();

    if (!genericdialog) {
        return FALSE;
    }

    genericdialog->SetTitle(IDS_LABEL_ANALYSIS_COMPLETE);   
    //close button 0
    genericdialog->SetButtonText(0,IDS_CLOSE);
    //defrag button 1
    genericdialog->SetButtonText(1,IDS_DEFRAGMENT);
    //view report 2
    genericdialog->SetButtonText(2,IDS_REPORT);


    //get the string displayed in the dialog 
    dlgString.Empty();
    dlgString += GetDialogBoxTextAnl(pLocalVolume);

    genericdialog->SetText(dlgString.GetBuffer());

    //set the help context IDs
    genericdialog->SetButtonHelp(0, IDH_106_2);
    genericdialog->SetButtonHelp(1, IDH_106_201);
    genericdialog->SetButtonHelp(2, IDH_106_205);
    genericdialog->SetHelpFilePath();


    iWhichKeyPressed = genericdialog->DoModal(pLocalVolume->m_pDfrgCtl->m_hWndCD);
    delete genericdialog;

    switch(iWhichKeyPressed) { 

    case 0:
        break;

    case 1:
        pLocalVolume->Defragment();
        break;

    case 2:

        if(pLocalVolume->EngineState() == ENGINE_STATE_IDLE){
            // close the dialog
            // raise the report dialog
            RaiseReportDialog(pLocalVolume);
        }
        break;



    default: 
        return FALSE;
    }
        
    return TRUE;
}

VString GetDialogBoxTextAnl(CVolume *pVolume)
{
    // write the Analysis Complete text in the dialog
    VString dlgText(IDS_ANALYSIS_COMPLETE_FOR, GetDfrgResHandle());
    dlgText += TEXT(" ");
    dlgText += pLocalVolume->DisplayLabel();
    dlgText += TEXT("\r");
    dlgText += TEXT("\n");
    dlgText += TEXT("\r");
    dlgText += TEXT("\n");

    //If the fragmentation on the disk exceeds 10% fragmentation, then recommend defragging.
    int percentFragged = ((int)pLocalVolume->m_TextData.PercentDiskFragged + 
                          (int)pLocalVolume->m_TextData.FreeSpaceFragPercent) / 2;
    VString userMsg;
    if(percentFragged > 10){
        userMsg.LoadString(IDS_LABEL_CHOOSE_DEFRAGMENT, GetDfrgResHandle());
    }
    //Otherwise tell the user he doesn't need to defragment at this time.
    else{
        userMsg.LoadString(IDS_LABEL_NO_CHOOSE_DEFRAGMENT, GetDfrgResHandle());
    }

    dlgText += userMsg;

    return(dlgText);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dlganl.h ===
/**************************************************************************************************

FILENAME: DlgAnl.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

**************************************************************************************************/

#include "VolList.h"

BOOL RaiseAnalyzeDoneDialog(
	CVolume *pVolume
);

VString GetDialogBoxTextAnl(CVolume *pVolume);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dlgdfrg.cpp ===
/*****************************************************************************************************************

FILENAME: DlgDfrg.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/
#include "stdafx.h"

#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif

#include "DfrgUI.h"
#include "DfrgCmn.h"
#include "DfrgCtl.h"
#include "resource.h"
#include "DlgRpt.h"
#include "DlgDfrg.h"
#include "GetDfrgRes.h"
#include "DfrgHlp.h"
#include "VolList.h"
#include "genericdialog.h"

static CVolume *pLocalVolume = NULL;
static HFONT hDlgFont = NULL;




/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Raises the Defrag Complete dialog

GLOBAL VARIABLES:
None

INPUT:
    IN pVolume - address of volume that has just completed Analyzing

RETURN:
    TRUE - Worked OK
    FALSE - Failure
*/
BOOL RaiseDefragDoneDialog(
    CVolume *pVolume,
    IN BOOL bFragmented
)
{
    pLocalVolume = pVolume;
    VString dlgString;
    UINT iWhichKeyPressed = NULL;
    CGenericDialog* genericdialog = new CGenericDialog();

    if (!genericdialog) {
        return FALSE;
    }
    
    genericdialog->SetTitle(IDS_LABEL_DEFRAG_COMPLETE); 
    //close button 0
    genericdialog->SetButtonText(0,IDS_CLOSE);
    //view report button 1
    genericdialog->SetButtonText(1,IDS_REPORT);

    //get the string displayed in the dialog 
    dlgString.Empty();
    dlgString += GetDialogBoxTextDefrag(pLocalVolume, bFragmented);

    genericdialog->SetText(dlgString.GetBuffer());

    //set the help context IDs
    genericdialog->SetButtonHelp(0, IDH_102_2);
    genericdialog->SetButtonHelp(1, IDH_102_205);
    genericdialog->SetHelpFilePath();


    iWhichKeyPressed = genericdialog->DoModal(pLocalVolume->m_pDfrgCtl->m_hWndCD);
    delete genericdialog;

    switch(iWhichKeyPressed) { 

    case 0:
        break;

    case 1:
        if(pLocalVolume->IsReportOKToDisplay()){
            // close the dialog before raising the report dialog
            // raise the report dialog
            RaiseReportDialog(pLocalVolume /*, DEFRAG*/);
        }

        break;

    default: 
        return FALSE;
    }

    return TRUE;
}


VString GetDialogBoxTextDefrag(
    CVolume *pVolume,
    IN BOOL bFragmented
    )
{

    // write the message that appears at the top of the dialog
    if (!bFragmented) {
        VString dlgText(IDS_DEFRAG_COMPLETE_FOR, GetDfrgResHandle());
        dlgText += TEXT(" ");
        dlgText += TEXT("\r");
        dlgText += TEXT("\n");

        dlgText += pLocalVolume->DisplayLabel();

        return(dlgText);

    }
    else {
        VString dlgText(IDS_DEFRAG_FAILED_FOR_1, GetDfrgResHandle());
        dlgText += pLocalVolume->DisplayLabel();

        VString dlgText2(IDS_DEFRAG_FAILED_FOR_2, GetDfrgResHandle());
        dlgText += TEXT("\r");
        dlgText += TEXT("\n");
        dlgText += TEXT("\r");
        dlgText += TEXT("\n");

        dlgText += dlgText2;

        return(dlgText);
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dlgrpt.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  DlgRpt.cpp
//=============================================================================*

#include "stdafx.h"
#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif
#include "commdlg.h"
#include <commctrl.h>
#include <shlobj.h> // for SHGetSpecialFolderLocation()

#include "DfrgUI.h"
#include "DfrgCmn.h"
#include "DfrgCtl.h"
#include "DlgRpt.h"
#include "GetDfrgRes.h"
#include "DfrgHlp.h"
#include "TextBlock.h"
#include "VolList.h"
#include <locale.h>
#include "expand.h"

#define MAX_FRAGGED_FILE_COLUMNS 3
#define MAX_VOLUME_INFO_COLUMNS 3


static CVolume *pLocalVolume = NULL;
static HFONT hDlgFont;
static RECT rcButtonClose;
static RECT rcButtonDefrag;
static RECT rcButtonSave;
static RECT rcButtonPrint;
static RECT rButton;

static RECT rcOriginalDialogSize;
static RECT rcNewDialogSize;

static UINT minimumDialogWidth;
static UINT minimumDialogHeight;
static UINT maximumDialogWidth;
static UINT maximumDialogHeight;
static UINT totalButtonWidth;
static UINT m_ButtonTopBottomSpacer;
static UINT m_ButtonHeight;
static UINT m_ButtonWidth;
static UINT m_ButtonSpacer;
static UINT m_Margin;
static UINT m_ButtonFloat;


static UINT adjustedButtonWidthClose;
static UINT adjustedButtonWidthDefrag;
static UINT adjustedButtonWidthSave;
static UINT adjustedButtonWidthPrint;

static UINT uEditBoxWidth;
static UINT uEditBoxHeight;
static UINT adjustedButtonHeight;
static UINT wNormalHeight;     // height of reduced dialog box (which
                                  // extends just past the ID_MORE button vertically)
static UINT wExpandedHeight;   // height of full size dialog box
static BOOL fExpanded = FALSE;
static UINT uFontHeight;
static UINT uVolumeListViewWidth;
//structure for the buttons
typedef struct{
    TCHAR       m_buttonText[200];
    TCHAR       m_buttonHelp[200];
    BOOL        m_buttonVisible;
} GENERICBUTTONARRAY;
    
static GENERICBUTTONARRAY genericButtonArray[5];



static BOOL
InitializeReport(
    IN HWND hWndDialog
    );

static BOOL
WriteTextReportInMemory(
    CTextBlock &textBlock,
    DWORD dwFlags
);

static UINT
WriteTextReportListView(
    IN HWND hWndDialog, 
    IN CTextBlock &textBlock,
    IN DWORD dwFlags
);

static void
InitializeFragListView(
    IN HWND hWndDialog
    );

static void
InitializeVolumeListView(
    IN HWND hWndDialog
    );
//Prints the text report and most fragged list on a printer.
static BOOL
PrintDriveData(
    IN HWND hWndDialog
    );

//Saves the text report and most fragged list to a text file.
static BOOL
SaveDriveData(
    IN HWND hWndDialog
    );

static void
InsertListViewItems(
    IN HWND hWndDialog,
    CVolume *pLocalVolume
    );

static UINT
InsertVolumeListViewItems(
    IN HWND hWndDialog, IN UINT iListItemNumber, IN UINT resourceIDText, IN UINT resourceIDSeperator,
    IN TCHAR* pTextStr, BOOL bIndentText, UINT uLongestTextString
    );
static UINT
InsertVolumeListViewItems(
    IN HWND hWndDialog, IN UINT iListItemNumber, IN TCHAR* itemOneText, IN UINT resourceIDSeperator,
    IN TCHAR* pTextStr, BOOL bIndentText, UINT uLongestTextString
    );
static UINT
InsertVolumeListViewItems(
    IN HWND hWndDialog, IN UINT iListItemNumber, IN UINT resourceIDText, IN UINT resourceIDSeperator,
    IN TCHAR* pTextStr, IN UINT resourceIDPercent, BOOL bIndentText, UINT uLongestTextString
    );
TCHAR*
InsertCommaIntoText(
    IN TCHAR* stringBuffer
    );
static void
ExitReport(
    IN HWND hWndDialog
    );

static BOOL CALLBACK
ReportDialogProc(
    IN HWND hWndDialog,
    IN UINT uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    );


//resize stuff
void SetButtonsandIcon(HWND hWndDialog);

void PositionButton(RECT* prcPos, HWND hWndDialog);

void PositionControls(HWND hWndDialog, RECT rDlg);

void GetButtonDimensions(HWND hWndDialog, BOOL bIsAnalysisReport);

void PositionButtons(HWND hWndDialog, RECT rDlg, BOOL bIsAnalysisReport);


UINT GetStringWidth(PTCHAR stringBuf, HDC WorkDC);

void ResizeDialog(HWND hWndDialog);

static UINT FindMaxEditboxStringWidth(VString vstring);

static UINT FindMaxEditboxStringHeight(VString vstring);

static void
ResizeVolumeListViewColumns(
    IN HWND hWndDialog, IN UINT uWidthFirstColumn,
    IN UINT uWidthSecondColumn,  IN UINT uWidthThirdColumn);


// Creates a text report that can be dumped to the screen or file, or printer, etc.
// Passed into CreateTextReportInMemory to tell it what type of report to generate.
#define TEXT_REPORT             1
#define MOST_FRAGGED_REPORT     2
#define NULL_TERMINATE_REPORT   4
#define ASCII_REPORT            8
#define UNICODE_REPORT          16
#define CR_LF_REPORT            32
#define ADD_TABS_REPORT         64
#define PRINT_DEFRAG_TITLE      128

static BOOL
CreateTextReportInMemory(
    CTextBlock &textBlock,
    DWORD dwFlags = NULL
    );

static BOOL
WriteFraggedReportInMemory(
    CTextBlock &textBlock,
    DWORD dwFlags
);

static BOOL isDescending = TRUE; // used by sort routine

// prototype for the list sort function
static int CALLBACK ListViewCompareFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort);


LONGLONG checkForNegativeValues(
    LONGLONG lldatavalue
    );



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Raises the Defrag Report dialog

GLOBAL VARIABLES:
None

INPUT:
    IN pLocalVolume - address of volume that has just completed Analyzing

RETURN:
    TRUE - Worked OK
    FALSE - Failure
*/

BOOL RaiseReportDialog(
    CVolume *pVolume
)
{
    LPCTSTR lpTemplateName;

    pLocalVolume = pVolume;
    isDescending = FALSE;

    m_ButtonTopBottomSpacer = 12;
    m_ButtonHeight = 26;
    m_ButtonWidth = 84;
    m_ButtonSpacer = 16;
    m_Margin = 20;
    m_ButtonFloat = 20;
    minimumDialogWidth = 275;
    minimumDialogHeight = 330;
//  minimumNumberOfCaractersWide = 40;
//  minimumNumberOfLinesLong = 2;


    if (pLocalVolume->DefragMode() == ANALYZE){
        lpTemplateName = MAKEINTRESOURCE(IDD_ANALYSIS_REPORT);
    }
    else {
        lpTemplateName = MAKEINTRESOURCE(IDD_DEFRAG_REPORT);
    }

    INT_PTR ret = DialogBoxParam(
        GetDfrgResHandle(),
        lpTemplateName,
        pLocalVolume->m_pDfrgCtl->m_hWndCD,
        (DLGPROC)ReportDialogProc,
        pLocalVolume->DefragMode());
    
    if (ret == -1){
        Message(TEXT("RaiseReportDialog - DialogBoxParam"), GetLastError(), TEXT("RaiseReportDialog"));
        return FALSE;
    }

    return TRUE;
}

/********************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    The Report dialog callback

GLOBAL VARIABLES:
    hFauItems
    dwFragListSize
    hFragFile

INPUT:
    IN HWND     hWndDialog, - handle to dialog
    IN UINT     uMessage,   - window message
    IN WPARAM   wParam,     - message flags
    IN LPARAM   lParam      - message flags

RETURN:
    TRUE - processed message
    FALSE - message not processed.
*/

static BOOL CALLBACK
ReportDialogProc(
    IN HWND hWndDialog,
    IN UINT uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {

        case WM_INITDIALOG:
            if(!InitializeReport(hWndDialog))
                ExitReport(hWndDialog);

            SetFocus(GetDlgItem(hWndDialog, IDCANCEL));
            return FALSE;
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR) lParam)->code) {

                // Process LVN_GETDISPINFO to supply information about callback items.
                case LVN_GETDISPINFO:
                {
                    Message(TEXT("ReportDialogProc: LVN_GETDISPINFO"), -1, NULL);

                    LV_DISPINFO* pnmv = (LV_DISPINFO*)lParam;

                    // Provide the item or subitem's text, if requested.
                    if (pnmv->item.mask & LVIF_TEXT) {

                        CFraggedFile *pFraggedFile = (CFraggedFile *) pnmv->item.lParam;

                        // copy the text from the array into the list column
                        switch (pnmv->item.iSubItem)
                        {
                            case 0:
                                _tcsnccpy(pnmv->item.pszText, pFraggedFile->cExtentCount(),
                                        pnmv->item.cchTextMax);
                                break;

                            case 1:
                                _tcsnccpy(pnmv->item.pszText, pFraggedFile->cFileSize(),
                                        pnmv->item.cchTextMax);
                                break;

                            case 2:
                                // if path is too long, truncate it and use elipse
                                if (pFraggedFile->FileNameLen() >= pnmv->item.cchTextMax) {
                                    _tcsnccpy(pnmv->item.pszText, TEXT("\\..."), pnmv->item.cchTextMax);
                                    _tcsnccat(pnmv->item.pszText,
                                            pFraggedFile->FileNameTruncated(pnmv->item.cchTextMax - 5),
                                            pnmv->item.cchTextMax);
                                }
                                // otherwise use full path
                                else {
                                    _tcsnccpy(pnmv->item.pszText, pFraggedFile->FileName(),
                                            pnmv->item.cchTextMax);
                                }
                                break;
                        }
                    }
                    break;
                }

                // Process LVN_COLUMNCLICK to sort items by column.
                case LVN_COLUMNCLICK:
                {
                    Message(TEXT("ReportDialogProc: LVN_COLUMNCLICK"), -1, NULL);
                    NM_LISTVIEW *pnm = (NM_LISTVIEW *) lParam;
                    ListView_SortItems(
                        pnm->hdr.hwndFrom,
                        ListViewCompareFunc,
                        (LPARAM) pnm->iSubItem);
                    isDescending = !isDescending;
                    break;
                }
            }
            break;

        case WM_CLOSE:
            ExitReport(hWndDialog);
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) {
                case IDC_VOLUME_INFORMATION:
                    {
                        //
                        // Don't select all of the text in the edit
                        // control.
                        //
                        if ( HIWORD( wParam ) == EN_SETFOCUS )
                            SendMessage( (HWND) lParam, EM_SETSEL, 0, 0 );
                    }
                    break;

                case IDC_PRINT:
                    PrintDriveData(hWndDialog);
                    break;

                case IDC_SAVE:
                    SaveDriveData(hWndDialog);
                    break;

                case IDC_DEFRAGMENT:
                    pLocalVolume->Defragment();
                    ExitReport(hWndDialog);
                    break;

                case IDCANCEL:
                    ExitReport(hWndDialog);
                    break;

                case IDHELP:
        //          WinHelp (hWndDialog, cHelpFileName, HELP_CONTEXT, 65);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_HELP:
            switch((int)((LPHELPINFO)lParam)->iCtrlId){
                case IDC_EDITBOX_TEXT:
                case IDC_VOLUME_INFORMATION_TEXT:
                case IDC_MOST_FRAGMENTED_TEXT:
                break;

                default:
                {
                    HWND hHelpHandle = (HWND)((LPHELPINFO)lParam)->hItemHandle;
                    DWORD_PTR dwData;

                    if(pLocalVolume->DefragMode() == ANALYZE){
                        dwData = (DWORD_PTR) AnalysisRptHelpIDArray;
                    }
                    else{
                        dwData = (DWORD_PTR) DefragRptHelpIDArray;
                    }
                    EF(WinHelp(hHelpHandle, GetHelpFilePath(), HELP_WM_HELP, dwData));
                    break;
                }
            }
            break;

        case WM_CONTEXTMENU:
        {
            switch(GetDlgCtrlID((HWND)wParam)){
                case 0:
                    EH(FALSE);
                    break;
                case IDC_EDITBOX_TEXT:
                case IDC_VOLUME_INFORMATION_TEXT:
                case IDC_MOST_FRAGMENTED_TEXT:
                    break;

                default:
                    if(pLocalVolume->DefragMode() == ANALYZE){
                        EF(WinHelp (hWndDialog, GetHelpFilePath(), HELP_CONTEXTMENU, (DWORD_PTR)AnalysisRptHelpIDArray));
                    }
                    else{
                        EF(WinHelp (hWndDialog, GetHelpFilePath(), HELP_CONTEXTMENU, (DWORD_PTR)DefragRptHelpIDArray));
                    }
            }
        }
        break;

        default:
            return FALSE;
    }
    return TRUE;
}
/****************************************************************************************************************/

// ListViewCompareFunc - sorts the list view control. It is a comparison function.
// Returns a negative value if the first item should precede the
//     second item, a positive value if the first item should
//     follow the second item, and zero if the items are equivalent.
// lParam1 and lParam2 - pointers to the REPORT_FRAGGED_FILE_DATA struct for that item (row)
// lParamSort - the index of the column to sort
static int CALLBACK ListViewCompareFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    LPTSTR lpString1 = NULL, lpString2 = NULL;
    LONGLONG number1, number2;
    int iResult = 1;
    BOOL isNumber = FALSE;

    CFraggedFile *pRec1 = (CFraggedFile *)lParam1;
    CFraggedFile *pRec2 = (CFraggedFile *)lParam2;

    if (pRec1 && pRec2)
    {
        switch (lParamSort)
        {
            case 0:
                number1 = pRec1->ExtentCount();
                number2 = pRec2->ExtentCount();
                isNumber = TRUE;
                break;

            case 1:
                number1 = pRec1->FileSize();
                number2 = pRec2->FileSize();
                isNumber = TRUE;
                break;

            case 2:
                lpString1 = pRec1->FileName();
                lpString2 = pRec2->FileName();
                isNumber = FALSE;
                break;

            default:
                Message(TEXT("ListViewCompareFunc: Unrecognized column number"), E_FAIL, 0);
                break;
        }

        if (isNumber){
            if (number1 < number2)
                iResult = -1;
            else if (number1 > number2)
                iResult = 1;
            else
                iResult = 0;
        }
        else{
            if (lpString1 && lpString2) {
                iResult = lstrcmpi(lpString1, lpString2);
            }
        }

        if (isDescending)
            iResult = -iResult;
    }

    return iResult;
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function initializes data for the report dialog box

DATA STRUCTURES:
    None.

GLOBALS:
    hFauItems
    hFragFile
    dwFragListSize

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/

static BOOL
InitializeReport(
    IN HWND hWndDialog
    )
{
    
    RECT rDlg;
    // set up the font
    NONCLIENTMETRICS ncm;
    ncm.cbSize = sizeof(ncm);
    setlocale(LC_ALL, ".OCP");


    //get the maximum size of the screen
    maximumDialogWidth = GetSystemMetrics(SM_CXFULLSCREEN);
    maximumDialogHeight = GetSystemMetrics(SM_CYFULLSCREEN);

    ::SystemParametersInfo (SPI_GETNONCLIENTMETRICS, sizeof (ncm), &ncm, 0);
    ncm.lfStatusFont.lfWeight = FW_NORMAL;

    InitializeVolumeListView(hWndDialog);

//  hDlgFont = ::CreateFontIndirect(&ncm.lfStatusFont);
    hDlgFont = ::CreateFontIndirect(&ncm.lfMessageFont);
    SendDlgItemMessage(hWndDialog, IDC_EDITBOX_TEXT, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, IDC_VOLUME_INFORMATION_TEXT, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, IDC_VOLUME_INFORMATION, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, IDC_MOST_FRAGMENTED_TEXT, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, IDC_MOST_FRAGMENTED, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, IDC_PRINT, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, IDC_SAVE, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, IDCANCEL, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    if(pLocalVolume->DefragMode() == ANALYZE)
    {
        SendDlgItemMessage(hWndDialog, IDC_DEFRAGMENT, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    }


    // set the title of the dialog box
    UINT titleTextID;
    if(pLocalVolume->DefragMode() == ANALYZE){
        titleTextID = IDS_ANALYSIS_REPORT_TITLE;
        // also set the font of the defrag button
        //SendDlgItemMessage(hWndDialog, IDC_DEFRAGMENT, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    }
    else{
        titleTextID = IDS_DEFRAG_REPORT_TITLE;
    }
    VString titleText(titleTextID, GetDfrgResHandle());
    EF(SetWindowText(hWndDialog, titleText.GetBuffer()));
    
    CTextBlock textBlock;

    // Create a text report in memory that we can dump to the screen.
//  EF(CreateTextReportInMemory(textBlock, ADD_TABS_REPORT));

    // set the tab stops for the Volume information list view
    UINT tabStopArray[3] = {15, 180, 190}; // 1=label, 2=equal sign
//  EF(SendDlgItemMessage(hWndDialog, IDC_VOLUME_INFORMATION,
//      EM_SETTABSTOPS, (WPARAM) 3, (LPARAM)tabStopArray));

    // Write the report to the edit control.
 //   SetDlgItemText(hWndDialog, IDC_VOLUME_INFORMATION, textBlock.GetBuffer());

    InitializeFragListView(hWndDialog);

    InsertListViewItems(hWndDialog, pLocalVolume);
    //what is the longest string loaded in the volume list view
    UINT uLongestTextString = 0;

    uLongestTextString = WriteTextReportListView(hWndDialog,textBlock, ADD_TABS_REPORT);

    //calulate the Width of the Volume Information Columns and adjust
    UINT uWidthFirstColumn = uLongestTextString * uFontHeight / 2;
    UINT uWidthSecondColumn = 3 * uFontHeight / 2;
    UINT uWidthThirdColumn = 12 * uFontHeight / 2;
    uLongestTextString += 15;       //add the length of the other two colums max should be 15
    UINT uWidthOfVolumeListBox = uLongestTextString * uFontHeight / 2;
    ResizeVolumeListViewColumns(hWndDialog, uWidthFirstColumn, uWidthSecondColumn, uWidthThirdColumn);
    
    
    VString label1;

    if(pLocalVolume->DefragMode() == ANALYZE){
    
        // write the Analysis Complete text in the dialog
        VString dlgText(IDS_ANALYSIS_COMPLETE_FOR, GetDfrgResHandle());
        dlgText.AddChar(L' ');
        dlgText += pLocalVolume->DisplayLabel();
        dlgText.AddChar(L'\r');
        dlgText.AddChar(L'\n');

        if((pLocalVolume->m_TextData.PercentDiskFragged + pLocalVolume->m_TextData.FreeSpaceFragPercent) / 2 > 10){
            //If the fragmentation on the disk exceeds 10% fragmentation, then recommend defragging.
            label1.LoadString(IDS_LABEL_CHOOSE_DEFRAGMENT, GetDfrgResHandle());
        }
        else{
            //Otherwise tell the user he doesn't need to defragment at this time.
            label1.LoadString(IDS_LABEL_NO_CHOOSE_DEFRAGMENT, GetDfrgResHandle());
        }

        dlgText += label1;

        EF(SetDlgItemText(hWndDialog, IDC_EDITBOX_TEXT, dlgText.GetBuffer()));
    }
    else{
        TCHAR cString[200];

        label1.LoadString(IDS_DEFRAG_REPORT_FOR, GetDfrgResHandle());
        wsprintf(cString, TEXT("%s %s"),
            label1.GetBuffer(),
            pLocalVolume->DisplayLabel());

        EF(SetDlgItemText(hWndDialog, IDC_EDITBOX_TEXT, cString));
        SetFocus(GetDlgItem(hWndDialog, IDCANCEL));
    }


    //I have created the dialog, now it is time to make the size correct
    //I am sizing it by calculating the size of the volume information listview
    //and the size of the buttons and comparing that to the default size and taking
    //the largest value.

    //first calculate the list view width
    uFontHeight = -ncm.lfMessageFont.lfHeight;
    uVolumeListViewWidth = uLongestTextString * uFontHeight / 2;        //the width of the list view in pixels
    //second calculate the width of the buttons
    if(pLocalVolume->DefragMode() == ANALYZE)
    {
        GetButtonDimensions(hWndDialog, TRUE);
    } else
    {
        GetButtonDimensions(hWndDialog, FALSE);
    }
    //now decide which one is bigger
    
    if(minimumDialogWidth < totalButtonWidth)
    {
        minimumDialogWidth = totalButtonWidth;
    }
    if(minimumDialogWidth < uVolumeListViewWidth)
    {
        minimumDialogWidth = uVolumeListViewWidth;
    }

    //calculate the final Height and Width of things

    //now we can move everything around and make it look cool...
    GetWindowRect(hWndDialog, &rDlg);

    //calculate to final size of the dialog and adjust if necessary
    UINT dialogBoxFinalWidth = rDlg.right - rDlg.left;// + 3 * m_Margin + iconSize;
    minimumDialogHeight = (16 * dialogBoxFinalWidth) /10;
    UINT dialogBoxFinalHeight = rDlg.bottom - rDlg.top;
    dialogBoxFinalWidth = __max(dialogBoxFinalWidth,minimumDialogWidth);
    dialogBoxFinalHeight = __max(dialogBoxFinalHeight,minimumDialogHeight);

    //check to see if the dialogBoxFinalWidth/Height is greater than the screen and adjust
    dialogBoxFinalWidth = __min(dialogBoxFinalWidth,maximumDialogWidth);
    dialogBoxFinalHeight = __min(dialogBoxFinalHeight,maximumDialogHeight); 
        
    //resize the dialog by moving it to make sure that the minimum size is used if necessary
    MoveWindow(hWndDialog,rDlg.left,rDlg.top,dialogBoxFinalWidth,dialogBoxFinalHeight, TRUE);
    GetWindowRect(hWndDialog, &rDlg);


    UINT iNumberofLinesLong = 0;
    UINT iNumberofCharactersWide = 0;

    //adjust the size of the edit box IDC_EDITBOX_TEXT
    TCHAR dlgText[256];
    VString dlgString;
    GetDlgItemText(hWndDialog, IDC_EDITBOX_TEXT, dlgText, 256);
    dlgString += dlgText;
    iNumberofCharactersWide = FindMaxEditboxStringWidth(dlgString);
    uEditBoxWidth = rDlg.right - rDlg.left - (2 * m_Margin);  //if no characters make it the total width

    if(iNumberofCharactersWide == 0)
    {
        iNumberofLinesLong = 1;     //and put one line in it
    } else
    {
        iNumberofCharactersWide +=5;        //add little extra space
        iNumberofLinesLong = FindMaxEditboxStringHeight(dlgString);
    }

    uEditBoxHeight = (iNumberofLinesLong * uFontHeight * 15) / 10;      //the height of editbox in pixels

    UINT uHeightOfFont = (uFontHeight * 15) / 10;

    UINT uCurrentVerticalSpaceLocation = 0;
    //resize the edit box
    MoveWindow(GetDlgItem(hWndDialog, IDC_EDITBOX_TEXT), m_Margin, m_ButtonTopBottomSpacer, uEditBoxWidth,  uEditBoxHeight, TRUE);
    uCurrentVerticalSpaceLocation += m_ButtonTopBottomSpacer + uEditBoxHeight + 5;
    
    //move the dividing line
    MoveWindow(GetDlgItem(hWndDialog, IDC_DIVIDE_LINE), m_Margin, uCurrentVerticalSpaceLocation, rDlg.right - rDlg.left - (2 * m_Margin),  2, TRUE);
    uCurrentVerticalSpaceLocation += m_ButtonTopBottomSpacer + 2;

    //move the Volume Information Text
    GetWindowRect(GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION_TEXT),&rDlg);
    MoveWindow(GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION_TEXT), m_Margin, uCurrentVerticalSpaceLocation, uEditBoxWidth,  uHeightOfFont, TRUE);
    uCurrentVerticalSpaceLocation += m_ButtonTopBottomSpacer + uHeightOfFont;

    //move and resize the Volume Information
    GetWindowRect(GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION),&rDlg);
    MoveWindow(GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION), m_Margin, uCurrentVerticalSpaceLocation, dialogBoxFinalWidth - (2 * m_Margin),  ((dialogBoxFinalHeight - (2 * m_Margin)) / 6) , TRUE);
    uCurrentVerticalSpaceLocation += m_ButtonTopBottomSpacer + ((dialogBoxFinalHeight - (2 * m_Margin)) / 6);

    //move the Most Fragmented Information Text
    GetWindowRect(GetDlgItem(hWndDialog, IDC_MOST_FRAGMENTED_TEXT),&rDlg);
    MoveWindow(GetDlgItem(hWndDialog, IDC_MOST_FRAGMENTED_TEXT), m_Margin, uCurrentVerticalSpaceLocation, uEditBoxWidth, uHeightOfFont, TRUE);
    uCurrentVerticalSpaceLocation += m_ButtonTopBottomSpacer + uHeightOfFont;

    //move the Most Fragmented Information
    GetWindowRect(GetDlgItem(hWndDialog, IDC_MOST_FRAGMENTED),&rDlg);
    MoveWindow(GetDlgItem(hWndDialog, IDC_MOST_FRAGMENTED), m_Margin, uCurrentVerticalSpaceLocation, dialogBoxFinalWidth - (2 * m_Margin),  ((dialogBoxFinalHeight - (2 * m_Margin)) / 4), TRUE);
    uCurrentVerticalSpaceLocation += m_ButtonTopBottomSpacer + ((dialogBoxFinalHeight - (2 * m_Margin)) / 4);

    //calculate the new dialogBoxFinalHeight based on the size of the controls
    //don't forget the title bar  estimated to be (2 * uHeightOfFont)
    dialogBoxFinalHeight = //__min((UINT)dialogBoxFinalHeight,
        uCurrentVerticalSpaceLocation + (2 * uHeightOfFont) + (2 * m_ButtonTopBottomSpacer) + m_ButtonHeight;
    

    //resize the dialog box
    GetWindowRect(hWndDialog,&rDlg);
    MoveWindow(hWndDialog,rDlg.left,rDlg.top,dialogBoxFinalWidth,dialogBoxFinalHeight, TRUE);
    GetWindowRect(hWndDialog,&rDlg);
    if(pLocalVolume->DefragMode() == ANALYZE)
    {
        PositionButtons(hWndDialog, rDlg, TRUE);
    } else
    {
        PositionButtons(hWndDialog, rDlg, FALSE);
    }

    return TRUE;
}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This will write a report telling how many fragmented files are on the drive, etc., into a memory buffer.

DATA STRUCTURES:
    None.

GLOBALS:

INPUT:
    hText - The handle to the memory to write the report to.
    pText - A pointer to the same.
    pTextEnd - A pointer to the end of the buffer.
    dwFlags - Contains flags specifying how to generate the report, (unicode vs. ascii, and cr lf instead of newline.)

RETURN:
    TRUE - Success.
    FALSE - Fatal error.
*/

static BOOL
WriteTextReportInMemory(
    CTextBlock &textBlock,
    DWORD dwFlags
    )
{

    setlocale(LC_ALL, ".OCP");
    // Get a pointer to the text data structure.
    TEXT_DATA *pTextData = &(pLocalVolume->m_TextData);

    // check all the values of textdata to make sure no negative values
    //to fix bug number 35764
    pTextData->DiskSize = checkForNegativeValues(pTextData->DiskSize);
    pTextData->BytesPerCluster = checkForNegativeValues(pTextData->BytesPerCluster);
    pTextData->UsedSpace = checkForNegativeValues(pTextData->UsedSpace);
    pTextData->FreeSpace = checkForNegativeValues(pTextData->FreeSpace);
    pTextData->FreeSpacePercent = checkForNegativeValues(pTextData->FreeSpacePercent);
    pTextData->UsableFreeSpace = checkForNegativeValues(pTextData->UsableFreeSpace);
    pTextData->UsableFreeSpacePercent = checkForNegativeValues(pTextData->UsableFreeSpacePercent);
    pTextData->PagefileBytes = checkForNegativeValues(pTextData->PagefileBytes);
    pTextData->PagefileFrags = checkForNegativeValues(pTextData->PagefileFrags);
    pTextData->TotalDirectories = checkForNegativeValues(pTextData->TotalDirectories);
    pTextData->FragmentedDirectories = checkForNegativeValues(pTextData->FragmentedDirectories);
    pTextData->ExcessDirFrags = checkForNegativeValues(pTextData->ExcessDirFrags);
    pTextData->TotalFiles = checkForNegativeValues(pTextData->TotalFiles);
    pTextData->AvgFileSize = checkForNegativeValues(pTextData->AvgFileSize);
    pTextData->NumFraggedFiles = checkForNegativeValues(pTextData->NumFraggedFiles);
    pTextData->NumExcessFrags = checkForNegativeValues(pTextData->NumExcessFrags);
    pTextData->PercentDiskFragged = checkForNegativeValues(pTextData->PercentDiskFragged);
    pTextData->AvgFragsPerFile = checkForNegativeValues(pTextData->AvgFragsPerFile);
    pTextData->MFTBytes = checkForNegativeValues(pTextData->MFTBytes);
    pTextData->InUseMFTRecords = checkForNegativeValues(pTextData->InUseMFTRecords);
    pTextData->TotalMFTRecords = checkForNegativeValues(pTextData->TotalMFTRecords);
    pTextData->MFTExtents = checkForNegativeValues(pTextData->MFTExtents);
    pTextData->FreeSpaceFragPercent = checkForNegativeValues(pTextData->FreeSpaceFragPercent);

    // set up the text block
    textBlock.SetResourceHandle(GetDfrgResHandle());

    // if no tabs, then set the fixed columns
    if (dwFlags & ADD_TABS_REPORT){
        textBlock.SetUseTabs(TRUE);
    }
    else{
        textBlock.SetFixedColumnWidth(TRUE);
        textBlock.SetColumnCount(5);
        textBlock.SetColumnWidth(0, 4);     // spacer
        textBlock.SetColumnWidth(1, 43);    // label
        textBlock.SetColumnWidth(2, 2);     // equal sign
        textBlock.SetColumnWidth(3, 1);     // data
        textBlock.SetColumnWidth(4, 2);     // percent sign
    }

    textBlock.SetUseCRLF(TRUE);

    // print the title
    if (dwFlags & PRINT_DEFRAG_TITLE){
        textBlock.WriteToBuffer(IDS_PRODUCT_NAME);
        textBlock.EndOfLine();
        textBlock.EndOfLine();
    }



    // write out the display label (usually the drive letter/label)
    textBlock.WriteToBuffer(IDS_LABEL_VOLUME);
    textBlock.WriteToBuffer(L" %s", pLocalVolume->DisplayLabel());
    textBlock.EndOfLine();

    // if there are >1 mount points, print them all out
    // yes, this will duplicate the same as the display label

    // refresh the mount point list
#ifndef VER4
    pLocalVolume->GetVolumeMountPointList();
    if (pLocalVolume->MountPointCount() > 1){
        for (UINT i=0; i<pLocalVolume->MountPointCount(); i++){
            textBlock.WriteToBuffer(IDS_MOUNTED_VOLUME);
            textBlock.WriteToBuffer(L": %s", pLocalVolume->MountPoint(i));
            textBlock.EndOfLine();
        }
    }
#endif

    ///////////////////////////////////////////////////////////////////////////
    // Volume Size
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_VOLUME_SIZE);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteByteCount(pTextData->DiskSize);
    textBlock.EndOfLine();

    // Cluster Size
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_CLUSTER_SIZE);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteByteCount(pTextData->BytesPerCluster);
    textBlock.EndOfLine();

    // Used Space
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_USED_SPACE);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteByteCount(pTextData->UsedSpace);
    textBlock.EndOfLine();

    // Free Space
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_FREE_SPACE);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteByteCount(pTextData->FreeSpace);
    textBlock.EndOfLine();

    // % Free Space
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_PERCENT_FREE_SPACE);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(L"%d ", (UINT) pTextData->FreeSpacePercent);
    textBlock.WriteToBuffer(IDS_LABEL_PERCENT_SIGN);
    textBlock.EndOfLine();

    // Volume Fragmentation Header
    textBlock.EndOfLine();
    textBlock.WriteToBuffer(IDS_LABEL_VOLUME_FRAGMENTATION_HEADING);
    textBlock.EndOfLine();

    // % Total Fragmentation
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_TOTAL_FRAGMENTATION);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(L"%d ", (UINT) (pTextData->PercentDiskFragged + pTextData->FreeSpaceFragPercent) / 2);
    textBlock.WriteToBuffer(IDS_LABEL_PERCENT_SIGN);
    textBlock.EndOfLine();

    // % File Fragmentation
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_FILE_FRAGMENTATION);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(L"%d ", (UINT) pTextData->PercentDiskFragged);
    textBlock.WriteToBuffer(IDS_LABEL_PERCENT_SIGN);
    textBlock.EndOfLine();

    // % Free Space Fragmentation
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_FREE_SPACE_FRAGMENTATION);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(L"%d ", (UINT) pTextData->FreeSpaceFragPercent);
    textBlock.WriteToBuffer(IDS_LABEL_PERCENT_SIGN);
    textBlock.EndOfLine();

    // File Fragmentation Header
    textBlock.EndOfLine();
    textBlock.WriteToBuffer(IDS_LABEL_FILE_FRAGMENTATION_HEADING);
    textBlock.EndOfLine();

    // Total Files
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_TOTAL_FILES);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    //textBlock.WriteToBuffer(L"%d", pTextData->TotalFiles);
    textBlock.WriteToBufferLL(pTextData->TotalFiles);
    textBlock.EndOfLine();
    
    // Average Files Size
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_AVERAGE_FILE_SIZE);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteByteCount(pTextData->AvgFileSize);
    textBlock.EndOfLine();

    // Total fragmented files
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_TOTAL_FRAGMENTED_FILES);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    //textBlock.WriteToBuffer(L"%d", pTextData->NumFraggedFiles);
    textBlock.WriteToBufferLL(pTextData->NumFraggedFiles);
    textBlock.EndOfLine();
    
    // Total excess fragments
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_TOTAL_EXCESS_FRAGMENTS);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    //textBlock.WriteToBuffer(L"%d", pTextData->NumExcessFrags);
    textBlock.WriteToBufferLL(pTextData->NumExcessFrags);
    textBlock.EndOfLine();

    // Average Fragments per File (CHECK THE MATH AND THE UNITS ON THIS ONE!!!)
    struct lconv *locals = localeconv();
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_AVERAGE_FRAGMENTS_PER_FILE);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(L"%d%c%02d",
        (UINT)pTextData->AvgFragsPerFile/100,
        ((locals && (locals->decimal_point)) ? *(locals->decimal_point) : '.'), 
        (UINT)pTextData->AvgFragsPerFile%100);
    textBlock.EndOfLine();

    // Pagefile Fragmentation Header
    textBlock.EndOfLine();
    textBlock.WriteToBuffer(IDS_LABEL_PAGEFILE_FRAGMENTATION_HEADING);
    textBlock.EndOfLine();

    // Pagefile Size
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_PAGEFILE_SIZE);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    textBlock.WriteByteCount(pTextData->PagefileBytes);
    textBlock.EndOfLine();

    // Total Fragments
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_TOTAL_FRAGMENTS);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    //textBlock.WriteToBuffer(L"%d", pTextData->PagefileFrags);
    textBlock.WriteToBufferLL(pTextData->PagefileFrags);
    textBlock.EndOfLine();

    // Directory Fragmentation Header
    textBlock.EndOfLine();
    textBlock.WriteToBuffer(IDS_LABEL_DIRECTORY_FRAGMENTATION_HEADING);
    textBlock.EndOfLine();

    // Total Directories
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_TOTAL_DIRECTORIES);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    //textBlock.WriteToBuffer(L"%d", pTextData->TotalDirectories);
    textBlock.WriteToBufferLL(pTextData->TotalDirectories);
    textBlock.EndOfLine();

    // Fragmented Directories
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_FRAGMENTED_DIRECTORIES);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    //textBlock.WriteToBuffer(L"%d", pTextData->FragmentedDirectories);
    textBlock.WriteToBufferLL(pTextData->FragmentedDirectories);
    textBlock.EndOfLine();

    // Excess directory fragments
    textBlock.WriteToBuffer(L"");
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EXCESS_DIRECTORY_FRAGMENTS);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
    textBlock.WriteTab();
    //textBlock.WriteToBuffer(L"%d", pTextData->ExcessDirFrags);
    textBlock.WriteToBufferLL(pTextData->ExcessDirFrags);
    textBlock.EndOfLine();

    //Only display MFT data if this is an NTFS drive.
    if(wcscmp(pLocalVolume->FileSystem(), L"NTFS") == 0){

        // MFT Fragmentation Header
        textBlock.EndOfLine();
        textBlock.WriteToBuffer(IDS_LABEL_MFT_FRAGMENTATION_HEADING);
        textBlock.EndOfLine();

        // Total MFT Size
        textBlock.WriteToBuffer(L"");
        textBlock.WriteTab();
        textBlock.WriteToBuffer(IDS_LABEL_TOTAL_MFT_SIZE);
        textBlock.WriteTab();
        textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
        textBlock.WriteTab();
        textBlock.WriteByteCount(pTextData->MFTBytes);
        textBlock.EndOfLine();

        // Number of MFT records
        textBlock.WriteToBuffer(L"");
        textBlock.WriteTab();
        textBlock.WriteToBuffer(IDS_LABEL_MFT_RECORD_COUNT);
        textBlock.WriteTab();
        textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
        textBlock.WriteTab();
        textBlock.WriteToBufferLL(pTextData->InUseMFTRecords);
        textBlock.EndOfLine();

        // Percent of MFT in use
        textBlock.WriteToBuffer(L"");
        textBlock.WriteTab();
        textBlock.WriteToBuffer(IDS_LABEL_PERCENT_MFT_IN_USE);
        textBlock.WriteTab();
        textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
        textBlock.WriteTab();
        textBlock.WriteToBuffer(L"%d ", (UINT) (100*pTextData->InUseMFTRecords/pTextData->TotalMFTRecords));
        textBlock.WriteToBuffer(IDS_LABEL_PERCENT_SIGN);
        textBlock.EndOfLine();

        // Total MFT fragments
        textBlock.WriteToBuffer(L"");
        textBlock.WriteTab();
        textBlock.WriteToBuffer(IDS_LABEL_TOTAL_MFT_FRAGMENTS);
        textBlock.WriteTab();
        textBlock.WriteToBuffer(IDS_LABEL_EQUAL_SIGN);
        textBlock.WriteTab();
        textBlock.WriteToBufferLL(pTextData->MFTExtents);
        textBlock.EndOfLine();
    }

    return TRUE;
}




static UINT
WriteTextReportListView(
    IN HWND hWndDialog, 
    IN CTextBlock &textBlock,
    IN DWORD dwFlags
)
{
        // Get a pointer to the text data structure.
    TEXT_DATA *pTextData = &(pLocalVolume->m_TextData);
    TCHAR buffer[256];
    TCHAR tempBuffer[256];
    UINT uIndexofListView = 0;

    //what is the longest string loaded in the volume list view
    UINT uLongestTextString = 0;

    // check all the values of textdata to make sure no negative values
    //to fix bug number 35764
    pTextData->DiskSize = checkForNegativeValues(pTextData->DiskSize);
    pTextData->BytesPerCluster = checkForNegativeValues(pTextData->BytesPerCluster);
    pTextData->UsedSpace = checkForNegativeValues(pTextData->UsedSpace);
    pTextData->FreeSpace = checkForNegativeValues(pTextData->FreeSpace);
    pTextData->FreeSpacePercent = checkForNegativeValues(pTextData->FreeSpacePercent);
    pTextData->UsableFreeSpace = checkForNegativeValues(pTextData->UsableFreeSpace);
    pTextData->UsableFreeSpacePercent = checkForNegativeValues(pTextData->UsableFreeSpacePercent);
    pTextData->PagefileBytes = checkForNegativeValues(pTextData->PagefileBytes);
    pTextData->PagefileFrags = checkForNegativeValues(pTextData->PagefileFrags);
    pTextData->TotalDirectories = checkForNegativeValues(pTextData->TotalDirectories);
    pTextData->FragmentedDirectories = checkForNegativeValues(pTextData->FragmentedDirectories);
    pTextData->ExcessDirFrags = checkForNegativeValues(pTextData->ExcessDirFrags);
    pTextData->TotalFiles = checkForNegativeValues(pTextData->TotalFiles);
    pTextData->AvgFileSize = checkForNegativeValues(pTextData->AvgFileSize);
    pTextData->NumFraggedFiles = checkForNegativeValues(pTextData->NumFraggedFiles);
    pTextData->NumExcessFrags = checkForNegativeValues(pTextData->NumExcessFrags);
    pTextData->PercentDiskFragged = checkForNegativeValues(pTextData->PercentDiskFragged);
    pTextData->AvgFragsPerFile = checkForNegativeValues(pTextData->AvgFragsPerFile);
    pTextData->MFTBytes = checkForNegativeValues(pTextData->MFTBytes);
    pTextData->InUseMFTRecords = checkForNegativeValues(pTextData->InUseMFTRecords);
    pTextData->TotalMFTRecords = checkForNegativeValues(pTextData->TotalMFTRecords);
    pTextData->MFTExtents = checkForNegativeValues(pTextData->MFTExtents);
    pTextData->FreeSpaceFragPercent = checkForNegativeValues(pTextData->FreeSpaceFragPercent);


    //Only display MFT data if this is an NTFS drive.
    if(wcscmp(pLocalVolume->FileSystem(), L"NTFS") == 0)
    {
        // Total MFT fragments
        swprintf(buffer, L"%I64d", pTextData->MFTExtents);
        uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_TOTAL_MFT_FRAGMENTS,
                IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE,uLongestTextString);
        uIndexofListView++; 

        // Percent of MFT in use
        swprintf(buffer, L"%d", 100*pTextData->InUseMFTRecords/pTextData->TotalMFTRecords);
        uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_PERCENT_MFT_IN_USE,
                IDS_LABEL_EQUAL_SIGN,buffer,TRUE,uLongestTextString);
        uIndexofListView++; 

        // Number of MFT records
        swprintf(buffer, L"%I64d", pTextData->InUseMFTRecords);
        uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_MFT_RECORD_COUNT,
                IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE,uLongestTextString);
        uIndexofListView++; 
        
        // Total MFT Size
        swprintf(buffer, L"%I64d", pTextData->MFTBytes);
        InsertCommaIntoText(buffer);
        textBlock.FormatNum(GetDfrgResHandle(), pTextData->MFTBytes, buffer);
        uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_TOTAL_MFT_SIZE,
                IDS_LABEL_EQUAL_SIGN,buffer,TRUE,uLongestTextString);
        uIndexofListView++; 
        
        // MFT Fragmentation Header
        uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_MFT_FRAGMENTATION_HEADING,
                NULL,L"",FALSE,uLongestTextString);
        uIndexofListView++;
    }


    // Excess directory fragments
    swprintf(buffer, L"%I64d", pTextData->ExcessDirFrags);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_EXCESS_DIRECTORY_FRAGMENTS,
            IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE,uLongestTextString);
    uIndexofListView++; 

    // Fragmented Directories
    swprintf(buffer, L"%I64d", pTextData->FragmentedDirectories);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_FRAGMENTED_DIRECTORIES,
            IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE,uLongestTextString);
    uIndexofListView++; 

    // Total Directories
    swprintf(buffer, L"%I64d", pTextData->TotalDirectories);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_TOTAL_DIRECTORIES,
            IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE,uLongestTextString);
    uIndexofListView++; 

    // Directory Fragmentation Header
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_DIRECTORY_FRAGMENTATION_HEADING
            ,NULL,L"",FALSE,uLongestTextString);
    uIndexofListView++; 

    // Total Fragments
    swprintf(buffer, L"%I64d", pTextData->PagefileFrags);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_TOTAL_FRAGMENTS,
            IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE,uLongestTextString);
    uIndexofListView++; 

    // Pagefile Size
    swprintf(buffer, L"%I64d", pTextData->PagefileBytes);
    InsertCommaIntoText(buffer);
    textBlock.FormatNum(GetDfrgResHandle(), pTextData->PagefileBytes, buffer);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_PAGEFILE_SIZE,
            IDS_LABEL_EQUAL_SIGN,buffer,TRUE,uLongestTextString);
    uIndexofListView++; 

    // Pagefile Fragmentation Header
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_PAGEFILE_FRAGMENTATION_HEADING
                ,NULL,L"",FALSE,uLongestTextString);
    uIndexofListView++; 

    // Average Fragments per File (CHECK THE MATH AND THE UNITS ON THIS ONE!!!)
    struct lconv *locals = localeconv();
    swprintf(buffer, L"%d%c%02d", (UINT)pTextData->AvgFragsPerFile/100, 
        ((locals && (locals->decimal_point)) ?  *(locals->decimal_point) : '.'), 
        (UINT)pTextData->AvgFragsPerFile%100);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_AVERAGE_FRAGMENTS_PER_FILE,
            IDS_LABEL_EQUAL_SIGN,buffer,TRUE,uLongestTextString);
    uIndexofListView++; 

    // Total excess fragments
    swprintf(buffer, L"%I64d", pTextData->NumExcessFrags);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_TOTAL_EXCESS_FRAGMENTS,
            IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE,uLongestTextString);
    uIndexofListView++; 

    // Total fragmented files
    swprintf(buffer, L"%I64d", pTextData->NumFraggedFiles);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_TOTAL_FRAGMENTED_FILES,
            IDS_LABEL_EQUAL_SIGN,InsertCommaIntoText(buffer),TRUE,uLongestTextString);
    uIndexofListView++; 

    // Average Files Size
    swprintf(buffer, L"%I64d", pTextData->AvgFileSize);
    InsertCommaIntoText(buffer);
    textBlock.FormatNum(GetDfrgResHandle(), pTextData->AvgFileSize, buffer);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_AVERAGE_FILE_SIZE,
            IDS_LABEL_EQUAL_SIGN,buffer,TRUE,uLongestTextString);
    uIndexofListView++; 

    // Total Files
    swprintf(buffer, L"%I64d", pTextData->TotalFiles);
    InsertCommaIntoText(buffer);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_TOTAL_FILES
            ,IDS_LABEL_EQUAL_SIGN,buffer,TRUE,uLongestTextString);
    uIndexofListView++; 

    // File Fragmentation Header
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_FILE_FRAGMENTATION_HEADING
            ,NULL,L"",FALSE,uLongestTextString);
    uIndexofListView++; 

    // % Free Space Fragmentation
    swprintf(buffer, L"%d", pTextData->FreeSpaceFragPercent);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_FREE_SPACE_FRAGMENTATION,
            IDS_LABEL_EQUAL_SIGN,buffer,IDS_LABEL_PERCENT_SIGN,TRUE,uLongestTextString);
    uIndexofListView++; 

    // % File Fragmentation
    swprintf(buffer, L"%d", pTextData->PercentDiskFragged);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_FILE_FRAGMENTATION,
            IDS_LABEL_EQUAL_SIGN,buffer,IDS_LABEL_PERCENT_SIGN,TRUE,uLongestTextString);
    uIndexofListView++; 

    // % Total Fragmentation
    swprintf(buffer, L"%d", (pTextData->PercentDiskFragged + pTextData->FreeSpaceFragPercent) / 2);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_TOTAL_FRAGMENTATION,
            IDS_LABEL_EQUAL_SIGN,buffer,IDS_LABEL_PERCENT_SIGN,TRUE,uLongestTextString);
    uIndexofListView++; 

    // Volume Fragmentation Header
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_VOLUME_FRAGMENTATION_HEADING
            ,NULL,L"",FALSE,uLongestTextString);
    uIndexofListView++; 

    // % Free Space
    swprintf(buffer, L"%d", pTextData->FreeSpacePercent);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_PERCENT_FREE_SPACE,
            IDS_LABEL_EQUAL_SIGN,buffer,IDS_LABEL_PERCENT_SIGN,TRUE,uLongestTextString);
    uIndexofListView++; 

    // Free Space
    swprintf(buffer, L"%I64d", pTextData->FreeSpace);
    InsertCommaIntoText(buffer);
    textBlock.FormatNum(GetDfrgResHandle(), pTextData->FreeSpace, buffer);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_FREE_SPACE,IDS_LABEL_EQUAL_SIGN,
        buffer,TRUE,uLongestTextString);
    uIndexofListView++; 

    // Used Space
    swprintf(buffer, L"%I64d", pTextData->UsedSpace);
    InsertCommaIntoText(buffer);
    textBlock.FormatNum(GetDfrgResHandle(), pTextData->UsedSpace, buffer);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_USED_SPACE,IDS_LABEL_EQUAL_SIGN,
        buffer,TRUE,uLongestTextString);
    uIndexofListView++; 

    // Cluster Size
    swprintf(buffer, L"%I64d", pTextData->BytesPerCluster);
    InsertCommaIntoText(buffer);
    textBlock.FormatNum(GetDfrgResHandle(), pTextData->BytesPerCluster, buffer);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_CLUSTER_SIZE,IDS_LABEL_EQUAL_SIGN,
        buffer,TRUE,uLongestTextString);
    uIndexofListView++; 

    ///////////////////////////////////////////////////////////////////////////
    // Volume Size
    swprintf(buffer, L"%I64d", pTextData->DiskSize);
    InsertCommaIntoText(buffer);
    textBlock.FormatNum(GetDfrgResHandle(), pTextData->DiskSize, buffer);
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_LABEL_VOLUME_SIZE,IDS_LABEL_EQUAL_SIGN,
        buffer,TRUE,uLongestTextString);
    uIndexofListView++; 

    // if there are >1 mount points, print them all out
    // yes, this will duplicate the same as the display label

    // refresh the mount point list
#ifndef VER4
    pLocalVolume->GetVolumeMountPointList();
    if (pLocalVolume->MountPointCount() > 1){
        for (UINT i=0; i<pLocalVolume->MountPointCount(); i++){
            LoadString(GetDfrgResHandle(), IDS_MOUNTED_VOLUME, tempBuffer, sizeof(tempBuffer)/sizeof(TCHAR));
            swprintf(buffer, L"%s  %s", tempBuffer, pLocalVolume->MountPoint(i));
            uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,buffer,
                    NULL,L"",FALSE,uLongestTextString);
            uIndexofListView++; 
        }
    }
#endif

    // write out the display label (usually the drive letter/label)
    LoadString(GetDfrgResHandle(), IDS_LABEL_VOLUME, tempBuffer, sizeof(tempBuffer)/sizeof(TCHAR));
    swprintf(buffer, L"%s  %s", tempBuffer,pLocalVolume->DisplayLabel());
    uLongestTextString = InsertVolumeListViewItems(hWndDialog,uIndexofListView,buffer
        ,NULL,L"",FALSE,uLongestTextString);
    uIndexofListView++; 

//  InsertVolumeListViewItems(hWndDialog,uIndexofListView,IDS_PRODUCT_NAME,NULL,L"",FALSE);

    return uLongestTextString;
}



/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This will write the fragmented file list into a memory buffer that can be displayed.

DATA STRUCTURES:
    None.

GLOBALS:

INPUT:
    hText - The handle to the memory to write the report to.
    pText - A pointer to the same.
    dwFlags - Contains flags specifying how to generate the report, (unicode vs. ascii, and cr lf instead of newline.)

RETURN:
    TRUE - Success.
    FALSE - Fatal error.
*/

static BOOL
WriteFraggedReportInMemory(
    CTextBlock &textBlock,
    DWORD dwFlags
    )
{
    const colWidth0 = 16;
    const colWidth1 = 16;
    const colWidth2 = 55;

    // set up the text block
    textBlock.SetResourceHandle(GetDfrgResHandle());
    textBlock.SetUseCRLF(TRUE);

    // print the title
    if (dwFlags & PRINT_DEFRAG_TITLE){
        textBlock.WriteToBuffer(IDS_PRODUCT_NAME);
        textBlock.EndOfLine();
        // write out the display label (usually the drive letter/label)
        textBlock.WriteToBuffer(IDS_LABEL_VOLUME);
        textBlock.WriteToBuffer(L" %s", pLocalVolume->DisplayLabel());
        textBlock.EndOfLine();

        // if there are >1 mount points, print them all out
        // yes, this will duplicate the same as the display label

        // refresh the mount point list
#ifndef VER4
        pLocalVolume->GetVolumeMountPointList();
        if (pLocalVolume->MountPointCount() > 1){
            for (UINT i=0; i<pLocalVolume->MountPointCount(); i++){
                textBlock.WriteToBuffer(IDS_MOUNTED_VOLUME);
                textBlock.WriteToBuffer(L": %s", pLocalVolume->MountPoint(i));
                textBlock.EndOfLine();
            }
        }
#endif
        textBlock.EndOfLine();
    }
    else { // otherwise add a dividing line
        textBlock.EndOfLine();
        textBlock.WriteToBuffer(L"--------------------------------------------------------------------------------");
        textBlock.EndOfLine();
    }

    // if no tabs, then set the fixed columns
    if (dwFlags & ADD_TABS_REPORT){
        textBlock.SetUseTabs(TRUE);
    }
    else{
        textBlock.SetFixedColumnWidth(TRUE);
        textBlock.SetColumnCount(3);
        textBlock.SetColumnWidth(0, colWidth0); // fragments
        textBlock.SetColumnWidth(1, colWidth1); // file size
        textBlock.SetColumnWidth(2, colWidth2); // file name
    }

    // header
    textBlock.WriteToBuffer(IDS_NUM_FRAGMENTS);
    textBlock.WriteTab();
    textBlock.WriteToBuffer(IDS_FRAGGED_FILESIZE);
    textBlock.WriteTab();
    if(pLocalVolume->DefragMode() == ANALYZE)
        textBlock.WriteToBuffer(IDS_LABEL_MOST_FRAGMENTED_FILE);
    else
        textBlock.WriteToBuffer(IDS_FILE_NO_DEFRAG);
    textBlock.EndOfLine();

    //If there are no items in the list, print "None"
    if(pLocalVolume->m_FraggedFileList.Size() == 0){
        textBlock.WriteToBuffer(IDS_LABEL_NONE);
        textBlock.EndOfLine();
    }
    else{
        CFraggedFile *pFraggedFile;
        for(UINT i=0; i<pLocalVolume->m_FraggedFileList.Size(); i++){
            pFraggedFile = pLocalVolume->m_FraggedFileList.GetAt(i);

            // write the data columns

            textBlock.WriteToBuffer(pFraggedFile->cExtentCount());
            textBlock.WriteTab();
            textBlock.WriteToBuffer(pFraggedFile->cFileSize());
            textBlock.WriteTab();
            if (pFraggedFile->FileNameLen() >= 4 * MAX_PATH) {
                textBlock.WriteToBuffer(L"\\...%s", pFraggedFile->FileNameTruncated(4 * MAX_PATH - 5));
            }
            else {
                textBlock.WriteToBuffer(pFraggedFile->FileName());
            }
            textBlock.EndOfLine();
        }
    }
    return TRUE;
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function will create a text report that can be dumped into a dialog, saved to a file or printed.
    Flags are passed in to determine what type of report should be generated.
    Memory is allocated, filled in with the report, and the handle is returned and must be freed by the caller.

DATA STRUCTURES:

GLOBALS:
    None.

INPUT:
    dwFlags -   MOST_FRAGGED_REPORT will create a most fragged list.
                NULL_TERMINATE_REPORT will add a null terminator to the end of the report.
                ASCII_REPORT will cause the report to be generated in ASCII
                UNICODE_REPORT will cause the report to be generated in UNICODE (default).
                CR_LF_REPORT will cause carriage returns and line feeds to be placed at the end of each line so
                            the text can be written to a file.
                NO_TABS_REPORT will cause the report to contain spaces rather than tabs.  Tabs should be used for a proportional font,
                            spaces for a fixed font.

  ***NOTE: Right now, only ASCII_REPORT works and is the default.  UNICODE is not implemented yet in this report system.

RETURN:
    A handle to the memory containing the report.
*/

static BOOL
CreateTextReportInMemory(
                         CTextBlock &textBlock,
                         DWORD dwFlags
    )
{
    // Create the basic text report that will tell how many fragged files, etc.
    WriteTextReportInMemory(textBlock, dwFlags);

    if(dwFlags & MOST_FRAGGED_REPORT){
        //textBlock.EndOfLine();
        //textBlock.WriteToBuffer
        //  (L"--------------------------------------------------------------------------------");
        //textBlock.EndOfLine();

        // Create the most fragged file list.
        WriteFraggedReportInMemory(textBlock, dwFlags);
    }

    textBlock.WriteNULL();

    return TRUE;
}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function saves the data from the drive report as a text file.

DATA STRUCTURES:
    None.

GLOBALS:

INPUT:

RETURN:
    None.
*/

static BOOL
SaveDriveData(
    IN HWND hWndDialog
    )
{
    CTextBlock textBlock;

    OPENFILENAME ofn = {0};
    TCHAR cFile[MAX_PATH + 50];
    TCHAR szFilter[300];
    TEXT_DATA* pTextData = &(pLocalVolume->m_TextData);
    DWORD commError = 0;
    BOOL done = FALSE;

    VString saveStatsLabel(IDS_LABEL_SAVE_DISK_STATS, GetDfrgResHandle());
    VString textFilesLabel(IDS_LABEL_TEXT_FILES, GetDfrgResHandle());
    VString allFilesLabel(IDS_LABEL_ALL_FILES, GetDfrgResHandle());

    // get the My Documents path
    LPITEMIDLIST pidl;
    TCHAR myDocsPath[MAX_PATH];
    SHGetSpecialFolderLocation(hWndDialog, CSIDL_PERSONAL, &pidl);
    if (SHGetPathFromIDList(pidl, myDocsPath))
        ofn.lpstrInitialDir = myDocsPath; // it was found
    else
        ofn.lpstrInitialDir = NULL; // My Docs dir not found - default to current dir

    // Concoct a file name from the Drive letter if there is one
    // otherwise use the display label
    VString volume;
    if (pLocalVolume->Drive()) {
        volume.LoadString(IDS_LABEL_VOLUME, GetDfrgResHandle());
        wsprintf(cFile, TEXT("%s%c.txt"), volume.GetBuffer(), pLocalVolume->Drive());
    }
    else if (_tcslen(pLocalVolume->VolumeLabel()) > 0) {
        wsprintf(cFile, TEXT("%s.txt"), pLocalVolume->VolumeLabel());
    }
    else {
        volume.LoadString(IDS_LABEL_MOUNTED_VOLUME, GetDfrgResHandle());
        wsprintf(cFile, TEXT("%s.txt"), volume.GetBuffer());
    }

#ifdef VER4
    ofn.lStructSize = sizeof(OPENFILENAME);
#else
    // sizeof doesn't work under nt5
    // special size was placed in header by MS
    ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
#endif
    ofn.hwndOwner = pLocalVolume->m_pDfrgCtl->m_hWndCD;
    ofn.hInstance = _Module.GetModuleInstance();
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = cFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrTitle = saveStatsLabel.GetBuffer();
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.Flags = OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;
    ofn.lpstrFilter = szFilter;

    //IDS_ANY_FILES_FILTER - "Analysis Files"
    //IDS_ALL_FILES_FILTER - "All Files"
    wsprintf((PTCHAR)ofn.lpstrFilter, TEXT("%s (*.txt)"), textFilesLabel.GetBuffer());
    ofn.lpstrFilter += lstrlen(ofn.lpstrFilter)+1;
    lstrcpy((PTCHAR)ofn.lpstrFilter, TEXT("*.txt"));
    ofn.lpstrFilter += lstrlen(ofn.lpstrFilter)+1;
    wsprintf((PTCHAR)ofn.lpstrFilter, TEXT("%s (*.*)"), allFilesLabel.GetBuffer());
    ofn.lpstrFilter += lstrlen(ofn.lpstrFilter)+1;
    lstrcpy((PTCHAR)ofn.lpstrFilter, TEXT("*.*"));
    ofn.lpstrFilter += lstrlen(ofn.lpstrFilter)+1;
    *(PTCHAR)ofn.lpstrFilter = 0;

    ofn.lpstrFilter = szFilter;

    // Disable the report dialog box
    EnableWindow(hWndDialog, FALSE);

    do {
        // Create the Save dialog box - it is a mutated Open file common dialog.
        BOOL isOK = GetSaveFileName(&ofn);

        // inspect this if the GetSaveFileName() function fails
        if (!isOK){
          commError = CommDlgExtendedError();
        }


        // the GetSaveFileName() function failed.  Bummer.
        if (isOK) {
            // Create a text report in memory that we can dump to the screen.
            if (CreateTextReportInMemory(textBlock, MOST_FRAGGED_REPORT)) {
                TCHAR cExtension[MAX_PATH+2];
                _tsplitpath(cFile, NULL, NULL, NULL, cExtension);

                if (_tcsclen(cExtension) != 4){
                    _tcscat(cFile, _T(".txt"));
                }

                // save the data to a text file (this method puts the Unicode marker in the file)
                if (textBlock.StoreFile(cFile, CREATE_ALWAYS)) {
                    // enable the report dialog box
                    EnableWindow(hWndDialog, TRUE);
                    SetFocus(hWndDialog);

                    return TRUE;
                }
            }
        }
        else {
            if (0 == commError) {
                // enable the report dialog box
                EnableWindow(hWndDialog, TRUE);
                SetFocus(hWndDialog);

              // User hit cancel, so all's well
              return TRUE;
            }
        }

        //
        // We were unable to save the report.  Put up a message box, and let
        // the user try again
        //
        VString errFormat(IDS_ERR_UNABLE_TO_SAVE_REPORT, GetDfrgResHandle());

        LPTSTR lpErrorMessage = new TCHAR[errFormat.GetLength() + _tcslen(cFile) + 2];
        wsprintf(lpErrorMessage, errFormat, (LPCTSTR) cFile);
        done = (IDCANCEL == MessageBoxW(hWndDialog, lpErrorMessage, saveStatsLabel.GetBuffer(), MB_OKCANCEL | MB_ICONWARNING));
        delete [] lpErrorMessage;

    } while (!done);
    
    // enable the report dialog box
    EnableWindow(hWndDialog, TRUE);
    SetFocus(hWndDialog);

    return TRUE;
}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function prints the data from the drive report as a text file.

DATA STRUCTURES:
    None.

GLOBALS:

INPUT:

RETURN:
    None.
*/

static BOOL
PrintDriveData(
    IN HWND hWndDialog
    )
{
    PRINTDLG pd = {0};
    DOCINFO di = {0};
    RECT Rect;
    HBRUSH hBrush;
    TEXT_DATA* pTextData = &(pLocalVolume->m_TextData);

    pd.lStructSize = sizeof(PRINTDLG);
    pd.hwndOwner = pLocalVolume->m_pDfrgCtl->m_hWndCD;
    pd.hDevMode = (HANDLE)NULL;
    pd.hDevNames = (HANDLE)NULL;
    pd.nFromPage = 0;
    pd.nToPage = 0;
    pd.nMinPage = 0;
    pd.nMaxPage = 0;
    pd.nCopies = 0;
    pd.hInstance = _Module.GetModuleInstance();
    pd.Flags = PD_RETURNDC|PD_USEDEVMODECOPIES|PD_COLLATE|PD_NOSELECTION;//|PD_PRINTSETUP;
    pd.lpfnSetupHook = (LPSETUPHOOKPROC)(FARPROC)NULL;
    pd.lpSetupTemplateName = (LPTSTR)NULL;
    pd.lpfnPrintHook = (LPPRINTHOOKPROC)(FARPROC)NULL;
    pd.lpPrintTemplateName = (LPTSTR)NULL;

    // Disable the report dialog box
    EnableWindow(hWndDialog, FALSE);

    // raise the system print dialog
    BOOL isOK = PrintDlg(&pd);

    // enable the report dialog box
    EnableWindow(hWndDialog, TRUE);
    SetFocus(hWndDialog);

    if (!isOK)
        return FALSE;

    di.cbSize = sizeof(DOCINFO);
    TCHAR docName[200];
    EH_ASSERT(LoadString(GetDfrgResHandle(), IDS_DEFRAG_REPORT_DOC_NAME, docName, sizeof(docName)/sizeof(TCHAR)));
    di.lpszDocName = docName;
    di.lpszOutput = (LPTSTR)NULL;
    di.fwType = 0;

    StartDoc(pd.hDC, &di);
    StartPage(pd.hDC);

    Rect.top    = 0.1 * GetDeviceCaps(pd.hDC, VERTRES);
    Rect.bottom = 0.9 * GetDeviceCaps(pd.hDC, VERTRES);
    Rect.left   = 0.1 * GetDeviceCaps(pd.hDC, HORZRES);;
    Rect.right  = 0.9 * GetDeviceCaps(pd.hDC, HORZRES);
    
    hBrush = (HBRUSH)GetStockObject(WHITE_BRUSH);
    EF_ASSERT(hBrush);
    FillRect(pd.hDC, &Rect, hBrush);

    // get the extended window styles
    LONG styles = ::GetWindowLong(hWndDialog, GWL_EXSTYLE);

    // check the window styles for a right to left layout
    UINT uFormat = DT_LEFT;
    if (styles & WS_EX_LAYOUTRTL){
        uFormat = DT_RIGHT | DT_RTLREADING;
    }

    // Create the basic text report
    CTextBlock page1text;
    WriteTextReportInMemory(page1text, MOST_FRAGGED_REPORT|PRINT_DEFRAG_TITLE);

    // if we have a short list of fragged files, put it all on one page
    if (pLocalVolume->m_FraggedFileList.Size() <= 5){

        // get the text report
        WriteFraggedReportInMemory(page1text, MOST_FRAGGED_REPORT);

        // write the report to the printer
        DrawText(pd.hDC, page1text.GetBuffer(), wcslen(page1text.GetBuffer()), &Rect, uFormat);
    }
    else { // if we have a long list of fragged files, then do a page break

        // write the text (upper) portion to the printer
        DrawText(pd.hDC, page1text.GetBuffer(), wcslen(page1text.GetBuffer()), &Rect, uFormat);

        // do a page break and clear the rectangle
        EndPage(pd.hDC);
        FillRect(pd.hDC, &Rect, hBrush);

        // create the fragged file list report in memory
        CTextBlock page2text;
        WriteFraggedReportInMemory(page2text, MOST_FRAGGED_REPORT|PRINT_DEFRAG_TITLE);
        
        // send the fragged file list to the printer, page 2
        DrawText(pd.hDC, page2text.GetBuffer(), wcslen(page2text.GetBuffer()), &Rect, uFormat);
    }

    // end of page
    if(EndPage(pd.hDC) <= 0){
        AbortDoc(pd.hDC);
        return FALSE;
    }

    // end of print job
    EndDoc(pd.hDC);

    DeleteDC(pd.hDC);
    if(pd.hDevMode){
        EH_ASSERT(GlobalFree(pd.hDevMode) == NULL);
    }

    if(pd.hDevNames){
        EH_ASSERT(GlobalFree(pd.hDevNames) == NULL);
    }

    return TRUE;
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function initializes data for the report dialog box

DATA STRUCTURES:
    None.

GLOBALS:

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/

static void
InitializeFragListView(
    IN HWND hWndDialog
    )
{
    int iColumnWidth[MAX_FRAGGED_FILE_COLUMNS] = {65, 65, 223};
    int iColumnID[MAX_FRAGGED_FILE_COLUMNS] = {
        IDS_NUM_FRAGMENTS,
        IDS_FRAGGED_FILESIZE,
        IDS_FRAGGED_FILENAME
    };
    int iColumnFormat[MAX_FRAGGED_FILE_COLUMNS] = {
        LVCFMT_RIGHT,
        LVCFMT_RIGHT,
        LVCFMT_LEFT
    };

    // Initialize the LVCOLUMN structure.
    LVCOLUMN lvc = {0};
    TCHAR cTemp[200];
    lvc.mask    = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
    lvc.pszText = cTemp;

    // Get handle to the Fragged listview
    HWND hListView = GetDlgItem(hWndDialog, IDC_MOST_FRAGMENTED);
    EV_ASSERT(hListView);

    // Insert the columns into the Listview.
    int col;
    for (col = 0; col < MAX_FRAGGED_FILE_COLUMNS; col++) {
    
        lvc.fmt = iColumnFormat[col];
        lvc.iSubItem = col;

        LoadString(
            GetDfrgResHandle(),
            iColumnID[col],
            cTemp,
            sizeof(cTemp)/sizeof(TCHAR));

        // Insert the columns into the ListView.
        if (ListView_InsertColumn(hListView, col, &lvc) == -1) {
            Message(TEXT("InitializeFragListView - ListView_InsertColumn."), E_FAIL, 0);
            return;
        }
    }

    // Go back thru and update columns.
    for (col = 0; col < MAX_FRAGGED_FILE_COLUMNS; col++) {
    
        // Size column to header text.
        if (!ListView_SetColumnWidth(hListView, col, LVSCW_AUTOSIZE_USEHEADER)) {
            Message(TEXT("InitializeFragListView - ListView_SetColumnWidth."), E_FAIL, 0);
        }

        // Grow width if needed.
        int tmpStrWidth = ListView_GetColumnWidth(hListView, col);
        if (tmpStrWidth < iColumnWidth[col]) {
            if (!ListView_SetColumnWidth(hListView, col, iColumnWidth[col])) {
                Message(TEXT("InitializeFragListView - 2nd ListView_SetColumnWidth."), E_FAIL, 0);
            }
        }
    }

    // Tell the left column that he is RIGHT JUSTIFIED!!!
    // The formatting sent with the InsertColumn does not
    // stick for some reason.
    // You can comment this code out and see if it is fixed if you wanna.
    // Or maybe you can find the fix.  But after 3 hours of trying, this
    // was my solution...
    lvc.mask = LVCF_FMT;
    lvc.fmt = LVCFMT_RIGHT;
    if (ListView_SetColumn(hListView, 0, &lvc) == -1) {
        Message(TEXT("InitializeFragListView - ListView_SetColumn."), E_FAIL, 0);
        return;
    }

    // make the listview hilite the entire row
    ListView_SetExtendedListViewStyle(hListView, LVS_EX_FULLROWSELECT);
}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function initializes data for the report dialog box

DATA STRUCTURES:
    None.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/

static void
InitializeVolumeListView(
    IN HWND hWndDialog
    )
{
    int iColumnWidth[MAX_VOLUME_INFO_COLUMNS] = {200,5,50};

//not needed, no column labels
    int iColumnID[MAX_VOLUME_INFO_COLUMNS] = {
        NULL,
        NULL,
        NULL
    };
    int iColumnFormat[MAX_VOLUME_INFO_COLUMNS] = {
        LVCFMT_LEFT,
        LVCFMT_RIGHT,
        LVCFMT_LEFT
    };


    // Initialize the LVCOLUMN structure.
    LVCOLUMN lvc = {0};
    TCHAR cTemp[200];
    lvc.mask    = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
    lvc.pszText = cTemp;

    // Get handle to the Fragged listview
    HWND hListView = GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION);
    EV_ASSERT(hListView);

    // Insert the columns into the Listview.
    int col = 0;
    for (col = 0; col < MAX_VOLUME_INFO_COLUMNS; col++) {
    
        lvc.fmt = iColumnFormat[col];
        lvc.iSubItem = col;

//      LoadString(
//          GetDfrgResHandle(),
//          iColumnID[col],
//          cTemp,
//          sizeof(cTemp)/sizeof(TCHAR));

        // Insert the columns into the ListView.
        if (ListView_InsertColumn(hListView, col, &lvc) == -1) {
            Message(TEXT("InitializeFragListView - ListView_InsertColumn."), E_FAIL, 0);
            return;
        }
    }

    // Go back thru and update columns.
    for (col = 0; col < MAX_VOLUME_INFO_COLUMNS; col++) {
    
        // Size column to header text.
        if (!ListView_SetColumnWidth(hListView, col, iColumnWidth[col])) {
            Message(TEXT("InitializeFragListView - ListView_SetColumnWidth."), E_FAIL, 0);
        }

        // Grow width if needed.
        int tmpStrWidth = ListView_GetColumnWidth(hListView, col);
        if (tmpStrWidth < iColumnWidth[col])
        {
            if (!ListView_SetColumnWidth(hListView, col, iColumnWidth[col])) {
                Message(TEXT("InitializeFragListView - 2nd ListView_SetColumnWidth."), E_FAIL, 0);
            }
        }
    }

    // Tell the left column that he is RIGHT JUSTIFIED!!!
    // The formatting sent with the InsertColumn does not
    // stick for some reason.
    // You can comment this code out and see if it is fixed if you wanna.
    // Or maybe you can find the fix.  But after 3 hours of trying, this
    // was my solution...
    lvc.mask = LVCF_FMT;
    lvc.fmt = LVCFMT_LEFT;
    if (ListView_SetColumn(hListView, 0, &lvc) == -1) {
        Message(TEXT("InitializeFragListView - ListView_SetColumn."), E_FAIL, 0);
        return;
    }

    // make the listview hilite the entire row
    ListView_SetExtendedListViewStyle(hListView, LVS_EX_FULLROWSELECT);
}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function initializes data for the report dialog box

DATA STRUCTURES:
    None.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/

static void
ResizeVolumeListViewColumns(
    IN HWND hWndDialog, IN UINT uWidthFirstColumn,
    IN UINT uWidthSecondColumn,  IN UINT uWidthThirdColumn
    )
{


    // Get handle to the Fragged listview
    HWND hListView = GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION);
    EV_ASSERT(hListView);

    // Go back thru and update columns.
    if (!ListView_SetColumnWidth(hListView, 0, LVSCW_AUTOSIZE))
    {
        Message(TEXT("InitializeFragListView - ListView_SetColumnWidth."), E_FAIL, 0);
    }

    if (!ListView_SetColumnWidth(hListView, 1, LVSCW_AUTOSIZE))
    {
        Message(TEXT("InitializeFragListView - ListView_SetColumnWidth."), E_FAIL, 0);
    }

    if (!ListView_SetColumnWidth(hListView, 2, LVSCW_AUTOSIZE))
    {
        Message(TEXT("InitializeFragListView - ListView_SetColumnWidth."), E_FAIL, 0);
    }



}



/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Displays a pre-formated items on the pop-up list view screen.

DATA STRUCTURES:
    None.

GLOBALS:
    None.

INPUT:
    IN HANDLE hListView,- handle to report dialog

RETURN:
    None.
*/

static void
InsertListViewItems(
    IN HWND hWndDialog,
    CVolume *pLocalVolume
    )
{


    // Get handle to the Fragged listview
    HWND hListView = GetDlgItem(hWndDialog, IDC_MOST_FRAGMENTED);
    EV_ASSERT(hListView);

    LVITEM lvi = {0};
    lvi.mask        = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText     = LPSTR_TEXTCALLBACK; // will be populated by the callback

    // Add each item to the listview.
    for (UINT i=0; i<pLocalVolume->m_FraggedFileList.Size(); i++) {

        lvi.iItem  = i;
         // address of fragged file object
        lvi.lParam = (LPARAM) pLocalVolume->m_FraggedFileList.GetAt(i);

        // Send the data to the list view box.
        if (ListView_InsertItem(hListView, &lvi) == -1){
            Message(TEXT("InsertListViewItems - ListView_InsertItem"), E_FAIL, 0);
            return;
        }

        for (UINT iSubItem = 0; iSubItem < MAX_FRAGGED_FILE_COLUMNS; iSubItem++) {
            ListView_SetItemText(
                hListView,
                lvi.iItem,
                iSubItem,
                LPSTR_TEXTCALLBACK);
        }
    }
}
/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Displays a pre-formated items on the pop-up list view screen.

DATA STRUCTURES:
    None.

GLOBALS:
    None.

INPUT:
    IN HANDLE hListView,- handle to report dialog

RETURN:
    None.
*/

static UINT
InsertVolumeListViewItems(
    IN HWND hWndDialog, IN UINT iListItemNumber, IN UINT resourceIDText, IN UINT resourceIDSeperator,
    IN TCHAR* pTextStr, BOOL bIndentText, UINT uLongestTextString
    )
{

    // Get handle to the Fragged listview
    HWND hListView = GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION);
    assert(hListView);
    TCHAR buffer[256];
    

    LVITEM lvi = {0};
    lvi.mask        = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText     = LPSTR_TEXTCALLBACK; // will be populated by the callback
//  lvi.item = iListItemNumber;

        // Send the data to the list view box.
        if (ListView_InsertItem(hListView, &lvi) == -1){
            Message(TEXT("InsertVolumeListViewItems Failed"), E_FAIL, 0);
            return 0;
        }
    TCHAR tempBuffer[300];

    //load the resourceIDText   
    LoadString(GetDfrgResHandle(), resourceIDText, buffer, sizeof(buffer)/sizeof(TCHAR));
    if(bIndentText)
    {
            swprintf(tempBuffer, L"    %s", buffer);
    } else
    {
            swprintf(tempBuffer, L"%s", buffer);
    }

    //need to make the string 30% longer and fill with spaces
    UINT uTempStrLen = _tcslen(tempBuffer);
    UINT uExtraStrLen = uTempStrLen * 3 / 10;
    UINT i = 0;
    if ((uTempStrLen + uExtraStrLen) < 255)     //buffer already at maximum length
    {
        for(i=0;i<uExtraStrLen;i++)
        {
            _tcscat(tempBuffer, L" ");
        }
    }

    uTempStrLen = _tcslen(tempBuffer);

    if(uTempStrLen > uLongestTextString)
    {
        uLongestTextString = uTempStrLen;
    }
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                0,
                tempBuffer);

    //load the resourceIDSeperator
    LoadString(GetDfrgResHandle(), resourceIDSeperator, buffer, sizeof(buffer)/sizeof(TCHAR));
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                1,
                buffer);

    //load the pTextStr
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                2,
                pTextStr);  
    
    return uLongestTextString;
}



/**************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Displays a pre-formated items on the pop-up list view screen.

DATA STRUCTURES:
    None.

GLOBALS:
    None.

INPUT:
    IN HANDLE hListView,- handle to report dialog

RETURN:
    None.
*/

static UINT
InsertVolumeListViewItems(
    IN HWND hWndDialog, IN UINT iListItemNumber, IN TCHAR* itemOneText, IN UINT resourceIDSeperator,
    IN TCHAR* pTextStr, BOOL bIndentText, UINT uLongestTextString
    )
{
    // Get handle to the Fragged listview
    HWND hListView = GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION);
    assert(hListView);
    TCHAR buffer[256];
    

    LVITEM lvi = {0};
    lvi.mask        = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText     = LPSTR_TEXTCALLBACK; // will be populated by the callback
//  lvi.item = iListItemNumber;

        // Send the data to the list view box.
        if (ListView_InsertItem(hListView, &lvi) == -1){
            Message(TEXT("InsertVolumeListViewItems Failed"), E_FAIL, 0);
            return 0;
        }
    TCHAR tempBuffer[300];

    //load the resourceIDText   
    if(bIndentText)
    {
            swprintf(tempBuffer, L"    %s", itemOneText);
    } else
    {
            swprintf(tempBuffer, L"%s", itemOneText);
    }
    UINT uTempStrLen = _tcslen(itemOneText);
    if(uTempStrLen > uLongestTextString)
    {
        uLongestTextString = uTempStrLen;
    }
    //load the resourceIDText   
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                0,
                itemOneText);

    //load the resourceIDSeperator
    LoadString(GetDfrgResHandle(), resourceIDSeperator, buffer, sizeof(buffer)/sizeof(TCHAR));
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                1,
                buffer);

    //load the pTextStr
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                2,
                pTextStr);  
    
    return uLongestTextString;
    
}


static UINT
InsertVolumeListViewItems(
    IN HWND hWndDialog, IN UINT iListItemNumber, IN UINT resourceIDText, IN UINT resourceIDSeperator,
    IN TCHAR* pTextStr, IN UINT resourceIDPercent, BOOL bIndentText, UINT uLongestTextString
    )
{
    // Get handle to the Fragged listview
    HWND hListView = GetDlgItem(hWndDialog, IDC_VOLUME_INFORMATION);
    assert(hListView);
    TCHAR buffer[256];
    TCHAR tempbuffer[256];
    

    LVITEM lvi = {0};
    lvi.mask        = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText     = LPSTR_TEXTCALLBACK; // will be populated by the callback
//  lvi.item = iListItemNumber;

        // Send the data to the list view box.
        if (ListView_InsertItem(hListView, &lvi) == -1){
            Message(TEXT("InsertVolumeListViewItems Failed"), E_FAIL, 0);
            return 0;
        }
    TCHAR tempBuffer[300];


    //load the resourceIDText   
    LoadString(GetDfrgResHandle(), resourceIDText, buffer, sizeof(buffer)/sizeof(TCHAR));
    if(bIndentText)
    {
            swprintf(tempBuffer, L"    %s", buffer);
    } else
    {
            swprintf(tempBuffer, L"%s", buffer);
    }
    UINT uTempStrLen = _tcslen(tempBuffer);
    if(uTempStrLen > uLongestTextString)
    {
        uLongestTextString = uTempStrLen;
    }
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                0,
                tempBuffer);

    //load the resourceIDSeperator
    LoadString(GetDfrgResHandle(), resourceIDSeperator, buffer, sizeof(buffer)/sizeof(TCHAR));
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                1,
                buffer);

    LoadString(GetDfrgResHandle(), resourceIDPercent, buffer, sizeof(buffer)/sizeof(TCHAR));
    swprintf(tempbuffer, L"%s %s", pTextStr,buffer);
    //load the pTextStr
    ListView_SetItemText(
                hListView,
                lvi.iItem,
                2,
                tempbuffer);    
    
    return uLongestTextString;
    
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function deallocate resources for the report dialog

DATA STRUCTURES:
    None.


INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/

static void
ExitReport(
    IN HWND hWndDialog
    )
{
    ::DeleteObject(hDlgFont);
    EndDialog(hWndDialog, 0);
}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function deallocate resources for the report dialog

DATA STRUCTURES:
    None.


INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/

TCHAR*
InsertCommaIntoText(
    IN TCHAR* stringBuffer
    )
{
    TCHAR targetString[256];
    TCHAR sourceString[256];
    TCHAR tcThousandsSep[2] = {TEXT(','), 0};

    _tcscpy(sourceString, stringBuffer);

    if(_tcslen(sourceString) == 0) {
        return TEXT("");
    }

    struct lconv *locals = localeconv();
    if (locals && (locals->thousands_sep) && (*(locals->thousands_sep) != 0)) {
        _stprintf(tcThousandsSep, TEXT("%C"), *(locals->thousands_sep));
    }

    UINT uGrouping = 0;
    if (locals && (locals->grouping)) {
        uGrouping = atoi(locals->grouping);
    }
    if(uGrouping == 0) {
        uGrouping = 3;      //default value if its not supported
    }

    // point the source pointer at the null terminator
    PTCHAR pSource = sourceString + _tcslen(sourceString);

    // put the target pointer at the end of the target buffer
    PTCHAR pTarget = targetString + sizeof(targetString) / sizeof(TCHAR) - 1;

    // write the null terminator
    *pTarget = NULL;

    for (UINT i=0; i<_tcslen(sourceString); i++){
        if (i>0 && i%uGrouping == 0){
            pTarget--;
            *pTarget = tcThousandsSep[0];
        }
        pTarget--;
        pSource--;
        *pTarget = *pSource;
    }

//  if (stringBufferLength > _tcslen(pTarget)){
        _tcscpy(stringBuffer, pTarget);
//  }
//  else{
//      _tcscpy(stringBuffer, TEXT(""));
//  }
    return stringBuffer;
}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method resizes the buttons
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/
void GetButtonDimensions(HWND hWndDialog, BOOL bIsAnalysisReport)
{
    HDC OutputDC = GetDC(hWndDialog);
    EV_ASSERT(OutputDC);
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EV_ASSERT(WorkDC);
    ::SelectObject(WorkDC, hDlgFont);

    const bigButtonSpacer = 20;

    adjustedButtonHeight = __max((UINT)(1.5 * uFontHeight), m_ButtonHeight);

    //need to know the total width of the buttons before setting location
    totalButtonWidth = 0;
    TCHAR buffer[256];

    //width of the Close button
    SendDlgItemMessage(hWndDialog, IDCANCEL, WM_GETTEXT, (WPARAM) 255, (LPARAM) buffer);
    adjustedButtonWidthClose = __max(m_ButtonSpacer + GetStringWidth(buffer, WorkDC), m_ButtonWidth);
    totalButtonWidth += adjustedButtonWidthClose + 2 * m_ButtonSpacer;

    //width of the Defragment button
    if(bIsAnalysisReport)       //need to include the Defragment button if we are using the analysis report
    {
        SendDlgItemMessage(hWndDialog, IDC_DEFRAGMENT, WM_GETTEXT, (WPARAM) 255, (LPARAM) buffer);
        adjustedButtonWidthDefrag = __max(m_ButtonSpacer + GetStringWidth(buffer, WorkDC), m_ButtonWidth);
        totalButtonWidth += adjustedButtonWidthDefrag + m_ButtonSpacer;
    } else      //add another close button to make the dialog wide enough
    {
        totalButtonWidth += adjustedButtonWidthClose + 2 * m_ButtonSpacer;
    }

    //width of the Save As button
    SendDlgItemMessage(hWndDialog, IDC_SAVE, WM_GETTEXT, (WPARAM) 255, (LPARAM) buffer);
    adjustedButtonWidthSave = __max(m_ButtonSpacer + GetStringWidth(buffer, WorkDC), m_ButtonWidth);
    totalButtonWidth += adjustedButtonWidthSave + m_ButtonSpacer;

    //width of the Print button
    SendDlgItemMessage(hWndDialog, IDC_PRINT, WM_GETTEXT, (WPARAM) 255, (LPARAM) buffer);
    adjustedButtonWidthPrint = __max(m_ButtonSpacer + GetStringWidth(buffer, WorkDC), m_ButtonWidth);
    totalButtonWidth += adjustedButtonWidthPrint + m_ButtonSpacer;

    minimumDialogWidth = __max(minimumDialogWidth,totalButtonWidth);

    DeleteDC(OutputDC);   // handle to device context
    DeleteDC(WorkDC);   // handle to device context

}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method positons the buttons
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/
void PositionButtons(HWND hWndDialog, RECT rDlg, BOOL bIsAnalysisReport)
{
    HDC OutputDC = GetDC(hWndDialog);
    EV_ASSERT(OutputDC);
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EV_ASSERT(WorkDC);
    ::SelectObject(WorkDC, hDlgFont);

    // Calculate Close Button position and size.
    GetWindowRect(GetDlgItem(hWndDialog, IDCANCEL), &rcButtonClose);
    rcButtonClose.right = rDlg.right -  rDlg.left - m_ButtonFloat;
    rcButtonClose.left = rcButtonClose.right - adjustedButtonWidthClose;
    rcButtonClose.bottom = rDlg.bottom - rDlg.top - (1.75 * adjustedButtonHeight);
    rcButtonClose.top = rcButtonClose.bottom - adjustedButtonHeight;
    PositionButton(&rcButtonClose,GetDlgItem(hWndDialog, IDCANCEL));

    if(bIsAnalysisReport)
    {
        GetWindowRect(GetDlgItem(hWndDialog, IDC_DEFRAGMENT), &rcButtonDefrag);
        rcButtonDefrag.right = rcButtonClose.left - m_ButtonSpacer;
        rcButtonDefrag.left = rcButtonDefrag.right - adjustedButtonWidthDefrag;
        rcButtonDefrag.bottom = rDlg.bottom - rDlg.top - (1.75 * adjustedButtonHeight);
        rcButtonDefrag.top = rcButtonDefrag.bottom - adjustedButtonHeight;
        PositionButton(&rcButtonDefrag,GetDlgItem(hWndDialog, IDC_DEFRAGMENT));

        //need to do the Save As button also
        GetWindowRect(GetDlgItem(hWndDialog, IDC_SAVE), &rcButtonSave);
        rcButtonSave.right = rcButtonDefrag.left - m_ButtonSpacer;
        rcButtonSave.left = rcButtonSave.right - adjustedButtonWidthSave;
        rcButtonSave.bottom = rDlg.bottom - rDlg.top - (1.75 * adjustedButtonHeight);
        rcButtonSave.top = rcButtonSave.bottom - adjustedButtonHeight;
        PositionButton(&rcButtonSave,GetDlgItem(hWndDialog, IDC_SAVE));     

    } else
    {
        //we position the Save Button next to the Close Button
        GetWindowRect(GetDlgItem(hWndDialog, IDC_SAVE), &rcButtonSave);
        rcButtonSave.right = rcButtonClose.left - m_ButtonSpacer;
        rcButtonSave.left = rcButtonSave.right - adjustedButtonWidthSave;
        rcButtonSave.bottom = rDlg.bottom - rDlg.top - (1.75 * adjustedButtonHeight);
        rcButtonSave.top = rcButtonSave.bottom - adjustedButtonHeight;
        PositionButton(&rcButtonSave,GetDlgItem(hWndDialog, IDC_SAVE));
    }

    GetWindowRect(GetDlgItem(hWndDialog, IDC_PRINT), &rcButtonPrint);
    rcButtonPrint.right = rcButtonSave.left - m_ButtonSpacer;
    rcButtonPrint.left = rcButtonPrint.right - adjustedButtonWidthPrint;
    rcButtonPrint.bottom = rDlg.bottom - rDlg.top - (1.75 * adjustedButtonHeight);
    rcButtonPrint.top = rcButtonPrint.bottom - adjustedButtonHeight;
    PositionButton(&rcButtonPrint,GetDlgItem(hWndDialog, IDC_PRINT));

    ::DeleteDC(WorkDC);
    ::DeleteDC(OutputDC);
}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method positons the buttons
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/
void PositionControls(HWND hWndDialog, RECT rDlg)
{



}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method repositions the buttons
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    hWndDialog - handle to the dialog box
    RECT - Defining the location of where the button is going

RETURN:
    None.
*/
void PositionButton(RECT* prcPos, HWND hWndDialog)
{
    if (hWndDialog != NULL){
        MoveWindow(hWndDialog,
                   prcPos->left,
                   prcPos->top,
                   prcPos->right - prcPos->left,
                   prcPos->bottom - prcPos->top,
                   TRUE);
    }

}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method finds the longest string inside the VString terminated by a \n
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    PTCHAR - buffer that contains the string
    HDC - Handle to a device context (DC) on the screen.

RETURN:
    Width of the character.
*/
UINT GetStringWidth(PTCHAR stringBuf, HDC WorkDC)
{
    if (!stringBuf){
        return 0;
    }

    UINT iStringWidth = 0;
    int iCharWidth = 0;

    for (UINT i=0; i<_tcslen(stringBuf); i++){
        if (::GetCharWidth32(
            WorkDC,
            stringBuf[i],
            stringBuf[i],
            &iCharWidth)) {
        iStringWidth += iCharWidth;
        }
    }

    return iStringWidth;
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method resizes the dialog in response to the user resizing the dialog
    
DATA STRUCTURES:
    None.

INPUT:
    None.


RETURN:
    None.
*/
void ResizeDialog(HWND hWndDialog)
{

    UINT dialogBoxFinalWidth;
    UINT dialogBoxFinalHeight;

    //get the new  dimensions of the dialog
    GetWindowRect(hWndDialog, &rcNewDialogSize);
    if((rcNewDialogSize.bottom - rcNewDialogSize.top) < (rcOriginalDialogSize.bottom - rcOriginalDialogSize.top) ||
        (rcNewDialogSize.right - rcNewDialogSize.left) < (rcOriginalDialogSize.right - rcOriginalDialogSize.left))
    {
        dialogBoxFinalWidth = rcOriginalDialogSize.right - rcOriginalDialogSize.left;
        dialogBoxFinalHeight = rcOriginalDialogSize.bottom - rcOriginalDialogSize.top;
        //set back to original size
        MoveWindow(hWndDialog, rcOriginalDialogSize.left, rcOriginalDialogSize.top, dialogBoxFinalWidth, dialogBoxFinalHeight, TRUE);
        return;
    }
    //if its not smaller, it must be bigger or the same, no matter, reposition the stuff
    m_ButtonFloat = ((rcNewDialogSize.right - rcNewDialogSize.left) - totalButtonWidth) / 2;
    PositionButtons(hWndDialog, rcNewDialogSize,TRUE);
    InvalidateRect(
                    hWndDialog,         // handle of window with changed update region
                    &rcNewDialogSize,   // address of rectangle coordinates
                    TRUE                // erase-background flag
                    );

}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method finds the longest string inside the VString terminated by a \n
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    VString - string in the editbox

RETURN:
    Longest line in the editbox terminated by a \n.
*/
UINT FindMaxEditboxStringWidth(VString vstring)
{
    int iLongestLine = 0, iEndofString = 0, iCurrentSearchLocation = 0;

    iEndofString = vstring.GetLength();
    if(iEndofString == 0)       //oops no string return 0
    {
        return(0);
    }
    while(iCurrentSearchLocation < iEndofString)
    {
            iCurrentSearchLocation = vstring.Find(TEXT("\n"));
        if(iCurrentSearchLocation == -1)        //I didnt find any more
        {
            if (0 == iLongestLine) {
                iLongestLine = iEndofString;
            }
            break;
        }
        if(iCurrentSearchLocation > iLongestLine)
        {
            iLongestLine = iCurrentSearchLocation;
        }
        vstring = vstring.Mid(iCurrentSearchLocation+1);                    //sub string the original chopping off the front
        iEndofString = vstring.GetLength(); 
        iCurrentSearchLocation = 0;
    }
    return(iLongestLine);
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method counts the number of \n inside the VString for the editbox
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    VString - editbox string

RETURN:
    Number of lines in the editbox.
*/
UINT FindMaxEditboxStringHeight(VString vstring)
{
    int iNumberofLines = 0, iEndofString = 0, iCurrentSearchLocation = 0;

    iEndofString = vstring.GetLength();
    if(iEndofString == 0)       //oops no string return 0
    {
        return(0);
    }
    while(iCurrentSearchLocation < iEndofString)
    {
        iCurrentSearchLocation = vstring.Find(TEXT("\n"));
        if(iCurrentSearchLocation == -1)        //I didnt find any more
        {
            break;
        }
        iNumberofLines++;
        vstring = vstring.Mid(iCurrentSearchLocation+1);                    //sub string the original chopping off the front
        iEndofString = vstring.GetLength();
        iCurrentSearchLocation = 0;
    }
    return(++iNumberofLines);       //add 1 more since the last line does not have a \n

}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    checks for negative values and returns 0 for negative numbers.
    
DATA STRUCTURES:
    none.

INPUT:
    LONGLONG - lldatavalue

RETURN:
    either lldatavalue or zero.
*/
LONGLONG checkForNegativeValues(LONGLONG lldatavalue)
{

    if(lldatavalue > 0)
    {
        return(lldatavalue);
    } else
    {
        return 0;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dlgrpt.h ===
/**************************************************************************************************

FILENAME: DlgRpt.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

/*************************************************************************************************/

#include "VolList.h"



BOOL RaiseReportDialog(CVolume *pVolume);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\dlgdfrg.h ===
/**************************************************************************************************

FILENAME: Report.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

**************************************************************************************************/

#include "vollist.h"

BOOL RaiseDefragDoneDialog(
	CVolume *pVolume,
    IN BOOL bFragmented
);


VString GetDialogBoxTextDefrag(
    CVolume *pVolume, 
    IN BOOL bFragmented
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\genericdialog.cpp ===
/*****************************************************************************************************************

FILENAME: GenericDialog.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/
#include "stdafx.h"

#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif
#include "assert.h"


#include "DfrgUI.h"
#include "DfrgCmn.h"
#include "DfrgCtl.h"
#include "resource.h"
#include "GetDfrgRes.h"
#include "DfrgHlp.h"
#include "genericdialog.h"
#include "expand.h"

static CVolume *pLocalVolume = NULL;
static HFONT hDlgFont = NULL;
static BOOL bIsIconVisible = FALSE;
static HANDLE hgenericDialogIcon = NULL;

static RECT rcButton0;
static RECT rcButton1;
static RECT rcButton2;
static RECT rcButton3;
static RECT rcButton4;
static RECT rButton;
static RECT rcIcon;
static RECT rcOriginalDialogSize;
static RECT rcNewDialogSize;

static UINT totalButtonWidth;
static UINT m_ButtonTopBottomSpacer;
static UINT m_ButtonHeight;
static UINT m_ButtonWidth;
static UINT m_ButtonSpacer;
static UINT m_Margin;
static UINT m_ButtonFloat;
static UINT minimumDialogWidth;
static UINT minimumDialogHeight;
static UINT iconSize;
static UINT minimumNumberOfCaractersWide;
static UINT minimumNumberOfLinesLong;

static UINT adjustedButtonWidth0;
static UINT adjustedButtonWidth1;
static UINT adjustedButtonWidth2;
static UINT adjustedButtonWidth3;
static UINT adjustedButtonWidth4;

static UINT adjustedButtonHeight;
static UINT wNormalHeight;     // height of reduced dialog box (which
                                  // extends just past the ID_MORE button vertically)
static WORD wExpandedHeight;   // height of full size dialog box
static BOOL fExpanded = FALSE;
static WORD wFontHeight;
static WORD wEditBoxHeight;
static WORD wEditBoxWidth;
//structure for the buttons
typedef struct{
    TCHAR       m_buttonText[200];
    TCHAR       m_buttonHelp[200];
    BOOL        m_buttonVisible;
} GENERICBUTTONARRAY;
    
static GENERICBUTTONARRAY genericButtonArray[5];

//structure for the help buttons
//the structure consists of pairs of DWORDS
//the first DWORD is the control identifier
//the second DWORD is the help context identifier from the help file
typedef struct{
    DWORD       dHelpControlIdentifier;
    DWORD       dHelpContextIdentifier;
} GENERICHELPIDARRAY;
    
static GENERICHELPIDARRAY genericHelpIDArray[5];

static TCHAR genericDialogTitle[200];
static TCHAR genericHelpFilePath[MAX_PATH + 30];
static TCHAR genericEditBoxText[1024];
static UINT iKeyPressedByUser;




BOOL InitializeGenericDialog(IN HWND hWndDialog);

void ExitAnalyzeDone(IN HWND hWndDialog);

BOOL CALLBACK GenericDialogProc(
    IN HWND hWndDialog,
    IN UINT uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

static void SetButtonsandIcon(HWND hWndDialog);

static UINT FindMaxEditboxStringWidth(VString vstring);

static UINT FindMaxEditboxStringHeight(VString vstring);

static void PositionButton(RECT* prcPos, HWND hWndDialog);

static void SizeButtons(HWND hWndDialog);

static void PositionButtons(HWND hWndDialog, RECT rDlg);


static UINT GetStringWidth(PTCHAR stringBuf, HDC WorkDC);

static void ResizeDialog(HWND hWndDialog);

static void DrawIconOnDialog(HWND hWndDialog);



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Constructor for GenericDialog Class

INPUT:
    IN pVolume - address of volume that has just completed Analyzing

RETURN:
    
*/
CGenericDialog::CGenericDialog(void)
{
    int i;
    for(i=0;i<=4;i++)
    {
        genericButtonArray[i].m_buttonVisible = FALSE;
    }
    bIsIconVisible = FALSE; 
    iconSize = 0;
    m_ButtonTopBottomSpacer = 24;
    m_ButtonHeight = 26;
    m_ButtonWidth = 84;
    m_ButtonSpacer = 22;
    m_Margin = 20;
    m_ButtonFloat = 20;
    minimumDialogWidth = 250;
    minimumDialogHeight = 75;
    minimumNumberOfCaractersWide = 40;
    minimumNumberOfLinesLong = 2;


    //initialize the helpID array
    genericHelpIDArray[0].dHelpControlIdentifier = ID_GENERIC_BUTTON0;
    genericHelpIDArray[1].dHelpControlIdentifier = ID_GENERIC_BUTTON1;
    genericHelpIDArray[2].dHelpControlIdentifier = ID_GENERIC_BUTTON2;
    genericHelpIDArray[3].dHelpControlIdentifier = ID_GENERIC_BUTTON3;
    genericHelpIDArray[4].dHelpControlIdentifier = ID_GENERIC_BUTTON4;


}





/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Destructor for GenericDialog Class

INPUT:
    IN pVolume - address of volume that has just completed Analyzing

RETURN:
    
*/
CGenericDialog::~CGenericDialog(void)
{



}



/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Raises the Analyze Complete dialog

INPUT:
    IN pVolume - address of volume that has just completed Analyzing

RETURN:
    TRUE - Worked OK
    FALSE - Failure
*/
UINT CGenericDialog::DoModal(HWND hWndDialog)
{
    iKeyPressedByUser = NULL;
    INT_PTR ret = DialogBoxParam(
        GetDfrgResHandle(),
        MAKEINTRESOURCE(IDD_GENERIC_DIALOG),
        hWndDialog,
        (DLGPROC)GenericDialogProc,
        NULL
        );

    return iKeyPressedByUser;
}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    sets the genericDialog title string from a string
    
DATA STRUCTURES:
    None.

INPUT:
    TCHAR * - Title string for genericDialog


RETURN:
    None.
*/
void CGenericDialog::SetTitle(TCHAR * tDialogBoxTitle)
{
    //assert if tDialogBoxTitle lenght = 0
    assert(_tcslen(tDialogBoxTitle) == 0);
    _tcscpy(genericDialogTitle, tDialogBoxTitle);


}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    sets the genericDialog title string from a resource ID
    
DATA STRUCTURES:
    None.

INPUT:
    UINT resource ID for the title string

RETURN:
    None.
*/
void CGenericDialog::SetTitle(UINT uResID)
{
    ::LoadString(GetDfrgResHandle(), uResID, genericDialogTitle, sizeof(genericDialogTitle)/sizeof(TCHAR));
    //assert if nothing got loaded
    assert((_tcslen(genericDialogTitle) > 0));
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    sets the button text from a TCHAR string
    
DATA STRUCTURES:
    None.

INPUT:
    UINT - Index for the button, must be in the range 0 to 4
    TCHAR * - button string

RETURN:
    None.
*/
void CGenericDialog::SetButtonText(UINT uIndex, TCHAR * tButtonText)
{
    //assert if index out of range
    assert(uIndex<5);
    //assert if tButtonText length = 0
    assert(_tcslen(tButtonText) == 0);

    //set button to visible
    genericButtonArray[uIndex].m_buttonVisible = TRUE;
    //copy button text to the button structure
    _tcscpy(genericButtonArray[uIndex].m_buttonText, tButtonText);
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    sets the button text from a resource ID
    
DATA STRUCTURES:
    None.

INPUT:
    UINT - Index for the button, must be in the range 0 to 4
    UINT - resource ID for the button string

RETURN:
    None.
*/
void CGenericDialog::SetButtonText(UINT uIndex, UINT uResID)
{
    //assert if index out of range
    assert(uIndex<5);

    TCHAR tTempButtonString[200];

    //set button to visible
    genericButtonArray[uIndex].m_buttonVisible = TRUE;
    //get the button text from the resource
    ::LoadString(GetDfrgResHandle(), uResID, tTempButtonString, sizeof(tTempButtonString)/sizeof(TCHAR));

    //assert if tTempButtonString length = 0
    assert(_tcslen(tTempButtonString) > 0);

    //copy button text to the button structure
    _tcscpy(genericButtonArray[uIndex].m_buttonText, tTempButtonString);


}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    sets the button help using Help Context ID
    
DATA STRUCTURES:
    None.

INPUT:
    UINT - Index for the button, must be in the range 0 to 4
    DWORD - Help Context ID

RETURN:
    None.
*/
void CGenericDialog::SetButtonHelp(UINT uIndex, DWORD dHelpContextID)
{
    //assert if index out of range
    assert(uIndex<5);

    //set the contect identifiers
    genericHelpIDArray[uIndex].dHelpContextIdentifier = dHelpContextID;

}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    sets the help file path
    
DATA STRUCTURES:
    None.

INPUT:
    TCHAR * - the location of the help file

RETURN:
    None.
*/
void CGenericDialog::SetHelpFilePath()
{

    _tcscpy(genericHelpFilePath, GetHelpFilePath());

}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This changes the ICON for the genericdialog
    
DATA STRUCTURES:
    None.

INPUT:
    UINT - resource ID for the Icon

RETURN:
    None.
*/
void CGenericDialog::SetIcon(UINT uResID)
{

    bIsIconVisible = TRUE;
    hgenericDialogIcon = LoadImage(
                        GetDfrgResHandle(),         // handle of the instance containing the image
                        MAKEINTRESOURCE(uResID),    // name or identifier of image
                        IMAGE_ICON,                 // type of image
                        0,                          // desired width
                        0,                          // desired height
                        LR_DEFAULTSIZE              // load flags
                        );
 
    assert(hgenericDialogIcon);
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    sets the text for the EditBox
    
DATA STRUCTURES:
    None.

INPUT:
    TCHAR * - string for the EditBox

RETURN:
    None.
*/
void CGenericDialog::SetText(TCHAR * tEditBoxText)
{   
    //assert if tEditBoxText length = 0
    assert(_tcslen(tEditBoxText) > 0  && _tcslen(tEditBoxText)<1025);

    _tcscpy(genericEditBoxText, tEditBoxText);

}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    sets the text for the EditBox
    
DATA STRUCTURES:
    None.

INPUT:
    UINT - resource ID for the editBox text

RETURN:
    None.
*/
void CGenericDialog::SetText(UINT uResID)
{
    TCHAR tTempEditBoxString[1024];

    //get the editbox text from the resource
    ::LoadString(GetDfrgResHandle(), uResID, tTempEditBoxString, sizeof(tTempEditBoxString)/sizeof(TCHAR));

    //assert if tTempEditBoxString length = 0
    assert(_tcslen(tTempEditBoxString) > 0);

    //copy button text to the button structure
    _tcscpy(genericEditBoxText, tTempEditBoxString);
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    The Report dialog callback

INPUT:
    IN HWND     hWndDialog, - handle to dialog
    IN UINT     uMessage,   - window message 
    IN WPARAM   wParam,     - message flags
    IN LPARAM   lParam      - message flags

RETURN:
    TRUE - processed message
    FALSE - message not processed.
*/

BOOL CALLBACK 
GenericDialogProc(
    IN HWND hWndDialog,
    IN UINT uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {

    case WM_INITDIALOG:
        if(!InitializeGenericDialog(hWndDialog)) {
            ExitAnalyzeDone(hWndDialog);
        }
        break;

    case WM_CLOSE:
        iKeyPressedByUser = 9999999;  //make it this value so that I will not act like a zero
        ExitAnalyzeDone(hWndDialog);
        break;

    case WM_SIZE:

        break;

    case WM_EXITSIZEMOVE:
        ResizeDialog(hWndDialog);

        
        break;      
    case WM_COMMAND:

        switch(LOWORD(wParam)) { 

        case ID_GENERIC_BUTTON0:
            iKeyPressedByUser = 0;
            ExitAnalyzeDone(hWndDialog);
            break;

        case ID_GENERIC_BUTTON1:
            iKeyPressedByUser = 1;
            ExitAnalyzeDone(hWndDialog);
            break;

        case ID_GENERIC_BUTTON2:
            iKeyPressedByUser = 2;
            ExitAnalyzeDone(hWndDialog);
            break;

        case ID_GENERIC_BUTTON3:
            iKeyPressedByUser = 3;
            ExitAnalyzeDone(hWndDialog);
            break;

        case ID_GENERIC_BUTTON4:
            iKeyPressedByUser = 4;
            ExitAnalyzeDone(hWndDialog);
            break;

        default: 
            return FALSE;
        }
        break;

        case WM_HELP:
            if(((int)((LPHELPINFO)lParam)->iCtrlId != IDC_STATIC_TEXT) && ((int)((LPHELPINFO)lParam)->iCtrlId != IDC_STATIC_TEXT2)){
                EF(WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, genericHelpFilePath, HELP_WM_HELP, (DWORD_PTR)genericHelpIDArray));
            }
            break;

        case WM_CONTEXTMENU:
            switch(GetDlgCtrlID((HWND)wParam)){
            case 0:
            case IDC_STATIC_TEXT:
            case IDC_STATIC_TEXT2:
                break;

            default:
                WinHelp (hWndDialog, genericHelpFilePath, HELP_CONTEXTMENU, (DWORD_PTR)genericHelpIDArray);
                break;
            }
            break;

    default: 
        return FALSE;
    }
    return TRUE;
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function initializes data for the report dialog box

DATA STRUCTURES:
    None.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    TRUE = success
    FALSE = error
*/

BOOL
InitializeGenericDialog(
    IN HWND hWndDialog
    )
{
    RECT rDlg, rect;
    HDC hDC = GetDC(hWndDialog);

    ZeroMemory(&rect, sizeof(RECT));
    //set the dialog box title
    SetWindowText(hWndDialog, genericDialogTitle);


    GetWindowRect(GetDlgItem(hWndDialog, IDC_GENERIC_EDITBOX), &rButton);
    GetWindowRect(hWndDialog, &rDlg);


    // set up the font
    NONCLIENTMETRICS ncm;
    ncm.cbSize = sizeof(ncm);


    ::SystemParametersInfo (SPI_GETNONCLIENTMETRICS, sizeof (ncm), &ncm, 0);
    ncm.lfStatusFont.lfWeight = FW_NORMAL;
    hDlgFont = ::CreateFontIndirect(&ncm.lfStatusFont);
    
    //set the font for the edit box
    SendDlgItemMessage(hWndDialog, IDC_GENERIC_EDITBOX, WM_SETFONT, (WPARAM) hDlgFont, 0L);

    //set the font for the buttons 
    SendDlgItemMessage(hWndDialog, ID_GENERIC_BUTTON0, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, ID_GENERIC_BUTTON1, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, ID_GENERIC_BUTTON2, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, ID_GENERIC_BUTTON3, WM_SETFONT, (WPARAM) hDlgFont, 0L);
    SendDlgItemMessage(hWndDialog, ID_GENERIC_BUTTON4, WM_SETFONT, (WPARAM) hDlgFont, 0L);

    VString dlgText;
    dlgText.Empty();
    dlgText += (LPCTSTR)genericEditBoxText;

    wFontHeight = -ncm.lfCaptionFont.lfHeight;

    rect.left = 0;
    rect.right = wFontHeight * 20; 
    rect.top = 0;
    rect.bottom = 0;

    if (dlgText.GetLength()) {
        DrawTextEx(hDC, dlgText.GetBuffer(), -1, &rect, DT_CALCRECT, NULL);
    } 

    wEditBoxWidth = __max((rect.right - rect.left), (wFontHeight * 20)) ;
    wEditBoxHeight = __max((rect.bottom - rect.top), (wFontHeight * (FindMaxEditboxStringHeight(dlgText) + 1)));

    //check for minimum size of the edit box
    m_ButtonTopBottomSpacer = wFontHeight;
    m_Margin = wFontHeight;

    SetButtonsandIcon(hWndDialog);
    SizeButtons(hWndDialog);

    // Resize the dialog box so it extends just past the 
    // ID_MORE button vertically.  Keep the upper left 
    // coordinates and the width the same.
    rDlg.bottom = rDlg.top + wEditBoxHeight+ (2 * m_ButtonTopBottomSpacer) +  
        (adjustedButtonHeight * 2) + ncm.iMenuHeight;
    rDlg.right = rDlg.left + wEditBoxWidth + iconSize + 3 * m_Margin;
 
    //calculate to final size of the dialog and adjust if necessary
    UINT dialogBoxFinalWidth = rDlg.right - rDlg.left;// + 3 * m_Margin + iconSize;
    UINT dialogBoxFinalHeight = rDlg.bottom - rDlg.top;
    dialogBoxFinalWidth = __max(dialogBoxFinalWidth,minimumDialogWidth);
    dialogBoxFinalHeight = __max(dialogBoxFinalHeight,minimumDialogHeight);

    m_ButtonFloat = (dialogBoxFinalWidth - totalButtonWidth) / 2;

    //move the icon
    MoveWindow(GetDlgItem(hWndDialog, IDC_GENERIC_ICON), m_Margin, m_ButtonTopBottomSpacer, iconSize,  iconSize, TRUE);


    //resize the edit box
    MoveWindow(GetDlgItem(hWndDialog, IDC_GENERIC_EDITBOX), 2 * m_Margin + iconSize, m_ButtonTopBottomSpacer, wEditBoxWidth,  wEditBoxHeight, TRUE);
    InvalidateRect(GetDlgItem(hWndDialog, IDC_GENERIC_EDITBOX),         // handle of window with changed update region
                    &rDlg,  // address of rectangle coordinates
                    TRUE                // erase-background flag
                    );

    // write the defrag recommendation
    SetDlgItemText(hWndDialog, IDC_GENERIC_EDITBOX, dlgText.GetBuffer());

    //resize the dialog
    MoveWindow(hWndDialog, rDlg.left, rDlg.top, dialogBoxFinalWidth, dialogBoxFinalHeight, TRUE);
    GetWindowRect(hWndDialog, &rDlg);
    PositionButtons(hWndDialog, rDlg);

    
    //save the original dimensions of the dialog
    GetWindowRect(hWndDialog, &rcOriginalDialogSize);

    ReleaseDC(hWndDialog, hDC); // handle to device context
    return TRUE;
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This function deallocate resources for the report dialog

DATA STRUCTURES:
    None.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/

void
ExitAnalyzeDone(
    IN HWND hWndDialog
    )
{
    ::DeleteObject(hDlgFont);
    EndDialog(hWndDialog, 0);
}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method hides/shows the buttons on the dialog according to the values in genericButtonArray structure.
    It also loads the text into the buttons from the same structure.

DATA STRUCTURES:
    genericButton structure.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/

void SetButtonsandIcon(HWND hWndDialog)
{
    if(!bIsIconVisible)
    {
        ::ShowWindow(GetDlgItem(hWndDialog, IDC_GENERIC_ICON),SW_HIDE);
    } else
    {
        GetWindowRect(GetDlgItem(hWndDialog, IDC_GENERIC_ICON), &rcIcon);
        iconSize = rcIcon.right - rcIcon.left;
        DrawIconOnDialog(hWndDialog);
    }

    if(!genericButtonArray[0].m_buttonVisible)
    {
        ::ShowWindow(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON0),SW_HIDE);
    } else
    {
        SetWindowText(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON0), genericButtonArray[0].m_buttonText );
    }

    if(!genericButtonArray[1].m_buttonVisible)
    {
        ::ShowWindow(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON1),SW_HIDE);
    }else
    {
        SetWindowText(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON1), genericButtonArray[1].m_buttonText );
    }

    if(!genericButtonArray[2].m_buttonVisible)
    {
        ::ShowWindow(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON2),SW_HIDE);
    }else
    {
        SetWindowText(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON2), genericButtonArray[2].m_buttonText );
    }

    if(!genericButtonArray[3].m_buttonVisible)
    {
        ::ShowWindow(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON3),SW_HIDE);
    }else
    {
        SetWindowText(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON3), genericButtonArray[3].m_buttonText );
    }
    if(!genericButtonArray[4].m_buttonVisible)
    {
        ::ShowWindow(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON4),SW_HIDE);
    }else
    {
        SetWindowText(GetDlgItem(hWndDialog, ID_GENERIC_BUTTON4), genericButtonArray[4].m_buttonText );
    }

}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method finds the longest string inside the VString terminated by a \n
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    VString - string in the editbox

RETURN:
    Longest line in the editbox terminated by a \n.
*/
UINT FindMaxEditboxStringWidth(VString vstring)
{
    int iLongestLine = 0, iEndofString = 0, iCurrentSearchLocation = 0;

    iEndofString = vstring.GetLength();
    if(iEndofString == 0)       //oops no string return 0
    {
        return(0);
    }
    while(iCurrentSearchLocation < iEndofString)
    {
        iCurrentSearchLocation = vstring.Find((LPTSTR)TEXT("\n"));
        if(iCurrentSearchLocation == -1)        //I didnt find any more
        {
            if (iLongestLine == 0) {
                iLongestLine = iEndofString;
            }
            break;
        }
        if(iCurrentSearchLocation > iLongestLine)
        {
            iLongestLine = iCurrentSearchLocation;
        }
        vstring = vstring.Mid(iCurrentSearchLocation+1);                    //sub string the original chopping off the front
        iEndofString = vstring.GetLength(); 
        iCurrentSearchLocation = 0;
    }

    return(iLongestLine);
}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method counts the number of \n inside the VString for the editbox
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    VString - editbox string

RETURN:
    Number of lines in the editbox.
*/
UINT FindMaxEditboxStringHeight(VString vstring)
{
    int iNumberofLines = 0, iEndofString = 0, iCurrentSearchLocation = 0;

    iEndofString = vstring.GetLength();
    if(iEndofString == 0)       //oops no string return 0
    {
        return(0);
    }

    while(iCurrentSearchLocation < iEndofString)
    {
        iCurrentSearchLocation = vstring.Find((LPTSTR)TEXT("\n"));
        if(iCurrentSearchLocation == -1)        //I didnt find any more
        {
            break;
        }
        iNumberofLines++;
        vstring = vstring.Mid(iCurrentSearchLocation+1);                    //sub string the original chopping off the front
        iEndofString = vstring.GetLength();
        iCurrentSearchLocation = 0;
    }

    return(++iNumberofLines);       //add 1 more since the last line does not have a \n

}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method resizes the buttons
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/
void SizeButtons(HWND hWndDialog)
{
    HDC OutputDC = GetDC(hWndDialog);
    EV_ASSERT(OutputDC);
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EV_ASSERT(WorkDC);
    ::SelectObject(WorkDC, hDlgFont);

    const bigButtonSpacer = 20;

    adjustedButtonHeight = __max((UINT)(1.5 * wFontHeight), m_ButtonHeight);

    //need to know the total width of the buttons before setting location
    totalButtonWidth = 0;
    if(genericButtonArray[0].m_buttonVisible)
    {
        adjustedButtonWidth0 = __max(m_ButtonSpacer + GetStringWidth(genericButtonArray[0].m_buttonText, WorkDC), m_ButtonWidth);
        totalButtonWidth += adjustedButtonWidth0 + m_ButtonSpacer;
    }
    if(genericButtonArray[1].m_buttonVisible)
    {
        adjustedButtonWidth1 = __max(m_ButtonSpacer + GetStringWidth(genericButtonArray[1].m_buttonText, WorkDC), m_ButtonWidth);
        totalButtonWidth += adjustedButtonWidth1 + m_ButtonSpacer;
    }
    if(genericButtonArray[2].m_buttonVisible)
    {
        adjustedButtonWidth2 = __max(m_ButtonSpacer + GetStringWidth(genericButtonArray[2].m_buttonText, WorkDC), m_ButtonWidth);
        totalButtonWidth += adjustedButtonWidth2 + m_ButtonSpacer;
    }
    if(genericButtonArray[3].m_buttonVisible)
    {
        adjustedButtonWidth3 = __max(m_ButtonSpacer + GetStringWidth(genericButtonArray[3].m_buttonText, WorkDC), m_ButtonWidth);
        totalButtonWidth += adjustedButtonWidth3 + m_ButtonSpacer;
    }
    if(genericButtonArray[4].m_buttonVisible)
    {
        adjustedButtonWidth4 = __max(m_ButtonSpacer + GetStringWidth(genericButtonArray[4].m_buttonText, WorkDC), m_ButtonWidth);
        totalButtonWidth += adjustedButtonWidth4 + m_ButtonSpacer;
    }

    minimumDialogWidth = __max(minimumDialogWidth,totalButtonWidth + m_ButtonSpacer*2);

    ReleaseDC(hWndDialog, OutputDC); // handle to device context
    DeleteDC(WorkDC);   // handle to device context

}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method resizes the buttons
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    hWndDialog - handle to the dialog box

RETURN:
    None.
*/
void PositionButtons(HWND hWndDialog, RECT rDlg)
{
    HDC OutputDC = GetDC(hWndDialog);
    EV_ASSERT(OutputDC);
    HDC WorkDC = ::CreateCompatibleDC(OutputDC);
    EV_ASSERT(WorkDC);
    ::SelectObject(WorkDC, hDlgFont);

    // Calculate Button0 position and size.
    if(genericButtonArray[0].m_buttonVisible)
    {
        rcButton0.right = rDlg.right -  rDlg.left - m_ButtonFloat;
        rcButton0.left = rcButton0.right - adjustedButtonWidth0;
        rcButton0.bottom = rDlg.bottom - rDlg.top - (1.50 * adjustedButtonHeight);
        rcButton0.top = rcButton0.bottom - adjustedButtonHeight;
        PositionButton(&rcButton0,GetDlgItem(hWndDialog, ID_GENERIC_BUTTON0));
    }
    if(genericButtonArray[1].m_buttonVisible)
    {
        rcButton1.right = rcButton0.left - m_ButtonSpacer;
        rcButton1.left = rcButton1.right - adjustedButtonWidth1;
        rcButton1.bottom = rDlg.bottom - rDlg.top - (1.50 * adjustedButtonHeight);
        rcButton1.top = rcButton1.bottom - adjustedButtonHeight;
        PositionButton(&rcButton1,GetDlgItem(hWndDialog, ID_GENERIC_BUTTON1));
    }
    if(genericButtonArray[2].m_buttonVisible)
    {
        rcButton2.right = rcButton1.left - m_ButtonSpacer;
        rcButton2.left = rcButton2.right - adjustedButtonWidth2;
        rcButton2.bottom = rDlg.bottom - rDlg.top - (1.50 * adjustedButtonHeight);
        rcButton2.top = rcButton2.bottom - adjustedButtonHeight;
        PositionButton(&rcButton2,GetDlgItem(hWndDialog, ID_GENERIC_BUTTON2));
    }
    if(genericButtonArray[3].m_buttonVisible)
    {
        rcButton3.right = rcButton2.left - m_ButtonSpacer;
        rcButton3.left = rcButton3.right - adjustedButtonWidth3;
        rcButton3.bottom = rDlg.bottom - rDlg.top - (1.50 * adjustedButtonHeight);
        rcButton3.top = rcButton3.bottom - adjustedButtonHeight;
        PositionButton(&rcButton3,GetDlgItem(hWndDialog, ID_GENERIC_BUTTON3));
    }
    if(genericButtonArray[4].m_buttonVisible)
    {
        rcButton4.right = rcButton3.left - m_ButtonSpacer;
        rcButton4.left = rcButton4.right - adjustedButtonWidth4;
        rcButton4.bottom = rDlg.bottom - rDlg.top - (1.50 * adjustedButtonHeight);
        rcButton4.top = rcButton4.bottom - adjustedButtonHeight;
        PositionButton(&rcButton4,GetDlgItem(hWndDialog, ID_GENERIC_BUTTON4));
    }

    ::DeleteDC(WorkDC);
    EH_ASSERT(ReleaseDC(hWndDialog, OutputDC));
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method repositions the buttons
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    hWndDialog - handle to the dialog box
    RECT - Defining the location of where the button is going

RETURN:
    None.
*/
void PositionButton(RECT* prcPos, HWND hWndDialog)
{
    if (hWndDialog != NULL){
        MoveWindow(hWndDialog,
                   prcPos->left,
                   prcPos->top,
                   prcPos->right - prcPos->left,
                   prcPos->bottom - prcPos->top,
                   TRUE);
    }

}


/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method finds the longest string inside the VString terminated by a \n
    
DATA STRUCTURES:
    genericButton structure.

INPUT:
    PTCHAR - buffer that contains the string
    HDC - Handle to a device context (DC) on the screen.

RETURN:
    Width of the character.
*/
UINT GetStringWidth(PTCHAR stringBuf, HDC WorkDC)
{
    if (!stringBuf){
        return 0;
    }

    UINT iStringWidth = 0;
    int iCharWidth;

    for (UINT i=0; i<_tcslen(stringBuf); i++){
        ::GetCharWidth32(
            WorkDC, 
            stringBuf[i], 
            stringBuf[i], 
            &iCharWidth);
        iStringWidth += iCharWidth;
    }

    return iStringWidth;
}
/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This method resizes the dialog in response to the user resizing the dialog
    
DATA STRUCTURES:
    None.

INPUT:
    None.


RETURN:
    None.
*/
void ResizeDialog(HWND hWndDialog)
{

    UINT dialogBoxFinalWidth;
    UINT dialogBoxFinalHeight;

    //get the new  dimensions of the dialog
    GetWindowRect(hWndDialog, &rcNewDialogSize);
    if((rcNewDialogSize.bottom - rcNewDialogSize.top) < (rcOriginalDialogSize.bottom - rcOriginalDialogSize.top) ||
        (rcNewDialogSize.right - rcNewDialogSize.left) < (rcOriginalDialogSize.right - rcOriginalDialogSize.left))
    {
        dialogBoxFinalWidth = rcOriginalDialogSize.right - rcOriginalDialogSize.left;
        dialogBoxFinalHeight = rcOriginalDialogSize.bottom - rcOriginalDialogSize.top;
        //set back to original size
        MoveWindow(hWndDialog, rcOriginalDialogSize.left, rcOriginalDialogSize.top, dialogBoxFinalWidth, dialogBoxFinalHeight, TRUE);
        return;
    }
    //if its not smaller, it must be bigger or the same, no matter, reposition the stuff
    m_ButtonFloat = ((rcNewDialogSize.right - rcNewDialogSize.left) - totalButtonWidth) / 2;
    PositionButtons(hWndDialog, rcNewDialogSize);
    InvalidateRect(
                    hWndDialog,         // handle of window with changed update region
                    &rcNewDialogSize,   // address of rectangle coordinates
                    TRUE                // erase-background flag
                    );

}

/***************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    This changes the ICON for the genericdialog
    
DATA STRUCTURES:
    None.

INPUT:
    hWndDialog - handle to the dialog box


RETURN:
    None.
*/
void DrawIconOnDialog(HWND hWndDialog)
{

    ::SendDlgItemMessage(hWndDialog,                //dialog box handle
                        IDC_GENERIC_ICON,           //icon identifier   
                        STM_SETIMAGE,               //message to send
                        (WPARAM) IMAGE_ICON,        //image type
                        (LPARAM) hgenericDialogIcon // icon handle
                        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\graphwin.cpp ===
/*****************************************************************************************************************

FILENAME: GraphWin.cpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif

#include "stdafx.h"

extern "C" {
    #include "SysStruc.h"
}

#include "DfrgUI.h"
#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DiskView.h"
#include "DfrgCtl.h"
#include "DataIoCl.h"
#include "GraphWin.h"
#include "Message.h"
#include "Graphix.h"
#include "ESButton.h"
#include "ErrMacro.h"
#include "DlgRpt.h"
#include "DfrgRes.h"
#include "VolList.h"

/****************************************************************************************************************/

extern CDfrgCtl* pCDfrgCtl;

extern HINSTANCE hinstRes;
extern HINSTANCE hInstRes;
extern HINSTANCE hinstMain;
extern HFONT g_hFont;

extern CVolList VolumeList;

extern BOOL bSnapinSelected;

/****************************************************************************************************************/

HWND hwndGraphics = NULL;
RECT rcGraphics;

RECT rcDefragStartButton;
RECT rcAnalyzeStartButton;
RECT rcPauseButton;
RECT rcCancelButton;
RECT rcReportButton;

RECT rcAnalyzeDisp;
RECT rcDefragDisp;
static RECT rcAnalyzeBorder;
static RECT rcDefragBorder;
extern RECT rcCtlRect;

static ESButton* pAnalyzeButton = NULL;
static ESButton* pDefragButton = NULL;
static ESButton* pPauseButton = NULL;
static ESButton* pStopButton = NULL;
static ESButton* pReportButton = NULL;

static DWORD dwLastMax = 0;
static int iLastPos = 0;

static DWORD dwScrollUnit = 0;
static DWORD dwScrollPage = 0;

#define ESI_BUTTON_SPACE 6
#define ESI_BUTTON_WIDTH 84
#define ESI_LEFT_MARGIN 14

/****************************************************************************************************************/
static BOOL
PaintGraphicsWindowBackground(
    HDC WorkDC
);

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:
    None;

RETURN:
    None.
*/

BOOL
InitializeGraphicsWindow(
    IN HWND hwnd,
    IN HINSTANCE hInst
    )
{
    WNDCLASS wc;

    // Initialize the window class.
    wc.style = CS_OWNDC|CS_HREDRAW|CS_VREDRAW|CS_SAVEBITS;
    wc.lpfnWndProc = (WNDPROC) GraphicsWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = GRAPHICSWINDOW_CLASS;

    // Register the window class.
    EF(RegisterClass(&wc));

    // Create the window.
    EF((hwndGraphics = CreateWindow(GRAPHICSWINDOW_CLASS,
                                    TEXT(""),
                                    WS_CHILD|WS_VISIBLE|WS_CLIPCHILDREN,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    CW_USEDEFAULT,
                                    hwnd,
                                    NULL,
                                    hInst,
                                    NULL)) != NULL);

    ShowScrollBar(hwndGraphics, SB_VERT, FALSE);

    ShowWindow(hwndGraphics, SW_SHOW);
    UpdateWindow(hwndGraphics);

    pAnalyzeButton  = new ESButton(hwndGraphics, ID_ANALYZE,  hInst);
    pDefragButton   = new ESButton(hwndGraphics, ID_DEFRAG,   hInst);
    pPauseButton    = new ESButton(hwndGraphics, ID_PAUSE,    hInst);
    pStopButton     = new ESButton(hwndGraphics, ID_STOP,     hInst);
    pReportButton   = new ESButton(hwndGraphics, ID_REPORT,   hInst);

    pAnalyzeButton->SetFont(g_hFont);
    pAnalyzeButton->SetText(hInstRes, IDS_BTN_ANALYZE);

    pDefragButton->SetFont(g_hFont);
    pDefragButton->SetText(hInstRes, IDS_BTN_DEFRAGMENT);

    pPauseButton->SetFont(g_hFont);
    pPauseButton->SetText(hInstRes, IDS_BTN_PAUSE);

    pStopButton->SetFont(g_hFont);
    pStopButton->SetText(hInstRes, IDS_BTN_STOP);

    pReportButton->SetFont(g_hFont);
    pReportButton->SetText(hInstRes, IDS_BTN_REPORT);

    SetButtonState();
    SetFocus(pAnalyzeButton->GetWindowHandle());

    return TRUE;
} 
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    This is the WndProc function for the graphics window.

GLOBALS:

INPUT:
    hWnd - Handle to the window.
    uMsg - The message.
    wParam - The word parameter for the message.
    lParam - the long parameter for the message.

RETURN:
    various.
*/

LRESULT CALLBACK
GraphicsWndProc(
    IN  HWND hWnd,
    IN  UINT uMsg,
    IN  UINT wParam,
    IN  LONG lParam
    )
{
    switch(uMsg) {

    case WM_COMMAND:

        switch ((short int)wParam) {

        case ID_ANALYZE:
            pCDfrgCtl->put_Command(ID_ANALYZE);
            break;

        case ID_DEFRAG:
            pCDfrgCtl->put_Command(ID_DEFRAG);
            break;

        case ID_PAUSE:
            pCDfrgCtl->put_Command(ID_PAUSE);
            break;

        case ID_CONTINUE:
            pCDfrgCtl->put_Command(ID_CONTINUE);
            break;

        case ID_STOP:
            pCDfrgCtl->put_Command(ID_STOP);
            break;

        case ID_REPORT:
            if (VolumeList.GetCurrentVolume()->IsReportOKToDisplay()){
                // raise the report dialog
                RaiseReportDialog(
                    VolumeList.GetCurrentVolume(), 
                    VolumeList.GetCurrentVolume()->DefragMode());
            }
            break;

        return S_OK;
        }

    case WM_VSCROLL:

        switch((short int)wParam){

        case SB_LINEDOWN:
            iLastPos += dwScrollUnit;
            break;

        case SB_LINEUP:
            iLastPos -= dwScrollUnit;
            break;

        case SB_PAGEDOWN:
            iLastPos += dwScrollPage;
            break;

        case SB_PAGEUP:
            iLastPos -= dwScrollPage;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            iLastPos = (wParam >> 16)*dwLastMax/100;
            break;

        case SB_ENDSCROLL:
            return 0;
        }
        if(iLastPos < 0){
            iLastPos = 0;
        }
        if(iLastPos > (int)dwLastMax){
            iLastPos = dwLastMax;
        }

        SizeGraphicsWindow();
//      pCDfrgCtl->InvalidateRect(NULL, TRUE);
//      pCDfrgCtl->FireViewChange();
        pCDfrgCtl->OnDrawFunction();
        break;

    case WM_ERASEBKGND:
        return TRUE;
        break;

    case WM_PAINT:
        {
        PAINTSTRUCT ps;

        EF(BeginPaint(hWnd, &ps));

        PaintGraphicsWindowFunction();

        EF(EndPaint(hWnd, &ps));
        }
        break;

    case WM_CLOSE:
        DestroyWindow(hWnd);
        break;

    case WM_DESTROY:
        // Destroy the thread.
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return 0;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Sizes the graphics window

GLOBAL VARIABLES:
    HWND hwndGraphics - handle of the list view window. 

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/

BOOL
SizeGraphicsWindow(
    void
) 
{ 
    SET_DISP_DATA DispData = {0};
    SCROLLINFO si = {0};
    CVolume *pVolume = VolumeList.GetCurrentVolume();

    si.cbSize = sizeof(SCROLLINFO);

    // Size and position the Graphics window.
    EF(SetWindowPos(hwndGraphics,               // handle of window
                    HWND_TOP,                   // placement-order handle
                    rcGraphics.left,                // horizontal position
                    rcGraphics.top,                 // vertical position
                    rcGraphics.right - rcGraphics.left, // width
                    rcGraphics.bottom - rcGraphics.top, // height
                    SWP_SHOWWINDOW              // window-positioning flags
                    ));

    si.fMask = SIF_RANGE|SIF_POS;
    si.nMin = 0;

    if((rcGraphics.bottom - rcGraphics.top) > MIN_SCROLL_HEIGHT){
        si.nMax = 0;
    }
    else {
        si.nMax = MIN_SCROLL_HEIGHT - (rcGraphics.bottom - rcGraphics.top);
    }

    si.nPos = iLastPos;

    if(si.nPos > si.nMax){
        si.nPos = si.nMax;
    }

    SetScrollInfo(hwndGraphics, SB_VERT, &si, TRUE);
    dwLastMax = si.nMax;
    iLastPos = si.nPos;
    dwScrollUnit = si.nMax / 10;
    dwScrollPage = rcGraphics.bottom - rcGraphics.top;

    if(dwScrollPage > (DWORD)si.nMax){
        dwScrollPage = si.nMax;
    }

    //Calculate the position for the analyze display rectangle.
    rcAnalyzeDisp.top = 40 - si.nPos;

    if((rcGraphics.bottom - rcGraphics.top) > MIN_SCROLL_HEIGHT){
        rcAnalyzeDisp.top += ((rcGraphics.bottom - rcGraphics.top) - MIN_SCROLL_HEIGHT)/2;
    }
    rcAnalyzeDisp.bottom = rcAnalyzeDisp.top + TOP_MARGIN_RAW + BOTTOM_MARGIN_RAW + ROW_HEIGHT_RAW;
    rcAnalyzeDisp.left = ESI_LEFT_MARGIN;
    rcAnalyzeDisp.right = (rcGraphics.right - rcGraphics.left) - ESI_LEFT_MARGIN - (si.nMax ? 25 : 0);

    // max right margin of the graphics wells
    int maxRightEdge = ESI_LEFT_MARGIN + 5*ESI_BUTTON_WIDTH + 4*ESI_BUTTON_SPACE;

    if (rcAnalyzeDisp.right < maxRightEdge)
        rcAnalyzeDisp.right = maxRightEdge;

    //Calculate from the analyze display rectangle, the position of the defrag display rectangle.
    rcDefragDisp = rcAnalyzeDisp;
    rcDefragDisp.top = rcDefragDisp.bottom + 40;
    rcDefragDisp.bottom = rcDefragDisp.top + rcAnalyzeDisp.bottom - rcAnalyzeDisp.top;

    //Set output dimensions on the analyze display rectangle.
    if(pVolume->m_pAnalyzeDisplay) {

        //Get mutex.
        EF_ASSERT(WaitForSingleObject(pVolume->m_hAnalyzeDisplayMutex,
                                      DISKDISPLAYMUTEXWAITINTERVAL
                                      ) == WAIT_OBJECT_0);
        //Set the dimensions.
        (pVolume->m_pAnalyzeDisplay)->SetNewOutputDimensions(
            rcAnalyzeDisp.left,
            rcAnalyzeDisp.top,
            rcAnalyzeDisp.right - rcAnalyzeDisp.left,
            rcAnalyzeDisp.bottom - rcAnalyzeDisp.top);

        //Get the cluster factor (so we can test for an error consition -- this value should not be zero.)
        DispData.AnalyzeClusterFactor = (pVolume->m_pAnalyzeDisplay)->GetClusterFactor();
        //Close the mutex.
        EF_ASSERT(ReleaseMutex(pVolume->m_hAnalyzeDisplayMutex));
        //Test for the cluster factor equaling zero.
        EF_ASSERT(DispData.AnalyzeClusterFactor);
    }
    
    //Set output dimensions on the defrag display rectangle.
    if(pVolume->m_pDefragDisplay) {

        //Get mutex.
        EF_ASSERT(WaitForSingleObject(pVolume->m_hDefragDisplayMutex,
                                      DISKDISPLAYMUTEXWAITINTERVAL)
                                      == WAIT_OBJECT_0);

        //Set the dimensions.
        (pVolume->m_pDefragDisplay)->SetNewOutputDimensions(
            rcDefragDisp.left,
            rcDefragDisp.top,
            rcDefragDisp.right - rcDefragDisp.left,
            rcDefragDisp.bottom - rcDefragDisp.top);

        //Get the cluster factor (so we can test for an error consition -- this value should not be zero.)
        DispData.DefragClusterFactor = (pVolume->m_pDefragDisplay)->GetClusterFactor();
        //Close the mutex.
        EF_ASSERT(ReleaseMutex(pVolume->m_hDefragDisplayMutex));
        //Test for the cluster factor equaling zero.
        EF_ASSERT(DispData.DefragClusterFactor);
    }

    if(pVolume->m_pdataDefragEngine && (DispData.AnalyzeClusterFactor || DispData.DefragClusterFactor)) {
        DataIoClientSetData(ID_SETDISPDIMENSIONS,
                            (PTCHAR)&DispData,
                            sizeof(SET_DISP_DATA),
                            pVolume->m_pdataDefragEngine);
    }

    // Calculate the analyze display border.
    rcAnalyzeBorder.top = rcAnalyzeDisp.top - 1;
    rcAnalyzeBorder.left = rcAnalyzeDisp.left - 1;
    rcAnalyzeBorder.right = rcAnalyzeDisp.right;
    rcAnalyzeBorder.bottom = rcAnalyzeDisp.bottom;

    // Calculate the defrag display border.
    rcDefragBorder.top = rcDefragDisp.top - 1;
    rcDefragBorder.left = rcDefragDisp.left - 1;
    rcDefragBorder.right = rcDefragDisp.right;
    rcDefragBorder.bottom = rcDefragDisp.bottom;

    // Calculate the Analyze button position and size.
    rcAnalyzeStartButton.top = rcDefragDisp.bottom + ESI_LEFT_MARGIN - 1;
    rcAnalyzeStartButton.left = rcDefragDisp.left - 1;
    rcAnalyzeStartButton.right = rcAnalyzeStartButton.left + ESI_BUTTON_WIDTH;
    rcAnalyzeStartButton.bottom = rcAnalyzeStartButton.top + 26;

    // start off with all buttons the same as the analyze button
    rcDefragStartButton = 
        rcPauseButton =
        rcCancelButton =
        rcReportButton =
        rcAnalyzeStartButton;

    // Calculate the Defrag button position and size.
    rcDefragStartButton.left = rcAnalyzeStartButton.right + ESI_BUTTON_SPACE;
    rcDefragStartButton.right = rcDefragStartButton.left + ESI_BUTTON_WIDTH;

    // Calculate the Pause button position and size.
    rcPauseButton.left = rcDefragStartButton.right + ESI_BUTTON_SPACE;
    rcPauseButton.right = rcPauseButton.left + ESI_BUTTON_WIDTH;

    // Calculate the Cancel button position and size.
    rcCancelButton.left = rcPauseButton.right + ESI_BUTTON_SPACE;
    rcCancelButton.right = rcCancelButton.left + ESI_BUTTON_WIDTH;

    // Calculate the See Report button position and size.
    rcReportButton.left = rcCancelButton.right + ESI_BUTTON_SPACE;
    rcReportButton.right = rcReportButton.left + ESI_BUTTON_WIDTH;

    // put the buttons on the screen
    pAnalyzeButton->PositionButton(&rcAnalyzeStartButton);
    pDefragButton->PositionButton(&rcDefragStartButton);
    pPauseButton->PositionButton(&rcPauseButton);
    pStopButton->PositionButton(&rcCancelButton);
    pReportButton->PositionButton(&rcReportButton);

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/

BOOL
PaintGraphicsWindowFunction(
    )
{
    HDC OutputDC, WorkDC;
    HANDLE hBitmap = NULL;
    HANDLE hOld = NULL;
    RECT rect;

    //Only paint if this snapin is selected.
    if(!bSnapinSelected){
        return TRUE;
    }

    //Get the size of the window.
    EF(GetClientRect(hwndGraphics, &rect));

    // Get the DC
    OutputDC = GetDC(hwndGraphics);
    WorkDC = CreateCompatibleDC(OutputDC);
    EF_ASSERT(hBitmap = CreateCompatibleBitmap(OutputDC, rect.right-rect.left, rect.bottom-rect.top));
    hOld = SelectObject(WorkDC, hBitmap);

    // Paint a light gray background on the entire window.
    HBRUSH hBrush  = (HBRUSH) CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    FillRect(WorkDC, &rect, hBrush);
    DeleteObject(hBrush);

    EF(PaintGraphicsWindowBackground(WorkDC));

    EF(PaintGraphicsWindow(rect, FALSE, WorkDC));

    EF(BitBlt(OutputDC, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top, WorkDC, 0, 0, SRCCOPY));

    // Cleanup the bitmap stuff.
    EF(hBitmap == SelectObject(WorkDC, hOld));
    EF(DeleteObject(hBitmap));
    EF(DeleteDC(WorkDC));
    EF(ReleaseDC(hwndGraphics, OutputDC));

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Paints the information in the graphics window.

GLOBAL VARIABLES:

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/

BOOL
PaintGraphicsWindow(
    IN RECT rect,
    IN BOOL bPartialRedraw,
    HDC hdc
    )
{
    CVolume *pVolume = VolumeList.GetCurrentVolume();

    //Paint the analyze display.
    if(pVolume->m_pAnalyzeDisplay) {

        //Get The mutex.
        EF_ASSERT(WaitForSingleObject(pVolume->m_hAnalyzeDisplayMutex,
                                      DISKDISPLAYMUTEXWAITINTERVAL
                                      ) == WAIT_OBJECT_0);
        //Do the draw.
        pVolume->m_pAnalyzeDisplay->DrawLinesInHDC(
            NULL,
            hdc,
            bPartialRedraw ? NULL : &rect,
            FALSE);

        //Release the mutex.
        EF_ASSERT(ReleaseMutex(pVolume->m_hAnalyzeDisplayMutex));
    }
    //Paint the defrag display.
    if(pVolume->m_pDefragDisplay) {

        //Get The mutex.
        EF_ASSERT(WaitForSingleObject(pVolume->m_hDefragDisplayMutex,
                                      DISKDISPLAYMUTEXWAITINTERVAL
                                      ) == WAIT_OBJECT_0);
        //Do the draw.
        pVolume->m_pDefragDisplay->DrawLinesInHDC(
            NULL,
            hdc,
            bPartialRedraw ? NULL : &rect,
            FALSE);

        //Release the mutex.
        EF_ASSERT(ReleaseMutex(pVolume->m_hDefragDisplayMutex));
    }

    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:
    Paints the information in the graphics window.  Most code extracted from DrawBackgroundBorders.

GLOBAL VARIABLES:

INPUT:

RETURN:
    TRUE = success
    FALSE = error
*/

static BOOL
PaintGraphicsWindowBackground(
    HDC WorkDC
    )
{
/*  HDC OutputDC, WorkDC;
    HANDLE hBitmap = NULL;

    // Get the DC
    OutputDC = GetDC(hwndGraphics);
    WorkDC = CreateCompatibleDC(OutputDC);
    EF_ASSERT(hBitmap = CreateCompatibleBitmap(OutputDC, rcGraphics.right-rcGraphics.left, rcGraphics.bottom-rcGraphics.top));
    SelectObject(WorkDC, hBitmap);
*/
    HBRUSH hBrush;
    RECT rcAll;

    // Note we want to paint ALL of the graphics window.
    rcAll = rcGraphics;
    rcAll.top = 0;
    rcAll.left = 0;

    // Paint the entire graphics window to the system color
    hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    FillRect(WorkDC, &rcAll, hBrush);
    DeleteObject(hBrush);

    // Fill the dark gray analyze and defrag graphics area
    hBrush = CreateSolidBrush(GetSysColor(COLOR_3DSHADOW));
    FillRect(WorkDC, &rcAnalyzeDisp, hBrush);
    FillRect(WorkDC, &rcDefragDisp, hBrush);
    DeleteObject(hBrush);

    // edge below the list view is at the very top of this window
    //ESIDrawEdge(WorkDC, rcListView.left, 0, rcListView.right, 0);
    //DrawEdge(WorkDC, &rcCtlRect, BDR_SUNKENINNER|BDR_RAISEDOUTER, BF_TOP);
    DrawEdge(WorkDC, &rcCtlRect, EDGE_BUMP, BF_TOP);

    // Draw the sunken box borders around the analyze and defragment grapics displays
    DrawBorderEx(WorkDC, rcAnalyzeBorder, SUNKEN_BOX);
    DrawBorderEx(WorkDC, rcDefragBorder, SUNKEN_BOX);

    // Draw the text above the analyze and defrag displays
    SetBkColor(WorkDC, GetSysColor(COLOR_BTNFACE));
    SetBkMode(WorkDC, OPAQUE);
    SetTextColor(WorkDC, GetSysColor(COLOR_BTNTEXT));
    SelectObject(WorkDC, g_hFont);

    TCHAR cString[300];

    EH_ASSERT(LoadString(hInstRes, IDS_LABEL_ANALYSIS_DISPLAY, cString, sizeof(cString)/sizeof(TCHAR)));
    TextOut(WorkDC, rcAnalyzeDisp.left-1, rcAnalyzeDisp.top-20, cString, wcslen(cString));

    EH_ASSERT(LoadString(hInstRes, IDS_LABEL_DEFRAG_DISPLAY, cString, sizeof(cString)/sizeof(TCHAR)));
    TextOut(WorkDC, rcDefragDisp.left-2, rcDefragDisp.top-20, cString, wcslen(cString));

    // If we had an analyze or defrag display then tell the user that we are resizing.

    SetBkMode(WorkDC, TRANSPARENT);
     // make the text white in all color schemes
    SetTextColor(WorkDC, GetSysColor(COLOR_HIGHLIGHTTEXT));

    // get the label that appears in the graphics wells
    TCHAR defragLabel[300];
    TCHAR analyzeLabel[300];

    CVolume *pVolume = VolumeList.GetCurrentVolume();
    switch (pVolume->DefragState()){
    case DEFRAG_STATE_NONE:
        wcscpy(analyzeLabel, L"");
        wcscpy(defragLabel, L"");
        break;

    case DEFRAG_STATE_ANALYZING:
        EH_ASSERT(LoadString(hInstRes, IDS_LABEL_ANALYZING, analyzeLabel, sizeof(analyzeLabel)/sizeof(TCHAR)));
        wcscat(analyzeLabel, L" ");
        wcscat(analyzeLabel, pVolume->DisplayLabel());

        wcscpy(defragLabel, L"");
        break;

    case DEFRAG_STATE_ANALYZED:
        EH_ASSERT(LoadString(hInstRes, IDS_LABEL_CREATING_COLOR_IMAGE, analyzeLabel, sizeof(analyzeLabel)/sizeof(TCHAR)));

        wcscpy(defragLabel, L"");
        break;

    case DEFRAG_STATE_REANALYZING:
        EH_ASSERT(LoadString(hInstRes, IDS_LABEL_REANALYZING, analyzeLabel, sizeof(analyzeLabel)/sizeof(TCHAR)));
        wcscat(analyzeLabel, L" ");
        wcscat(analyzeLabel, pVolume->DisplayLabel());
        wcscpy(defragLabel, L"");
        break;

    case DEFRAG_STATE_DEFRAGMENTING:
        EH_ASSERT(LoadString(hInstRes, IDS_LABEL_RESIZING, analyzeLabel, sizeof(analyzeLabel)/sizeof(TCHAR)));
        EH_ASSERT(LoadString(hInstRes, IDS_LABEL_DEFRAGMENTING, defragLabel, sizeof(defragLabel)/sizeof(TCHAR)));
        wcscat(defragLabel, L" ");
        wcscat(defragLabel, pVolume->DisplayLabel());
        break;

    case DEFRAG_STATE_DEFRAGMENTED:
        EH_ASSERT(LoadString(hInstRes, IDS_LABEL_RESIZING, analyzeLabel, sizeof(analyzeLabel)/sizeof(TCHAR)));
        EH_ASSERT(LoadString(hInstRes, IDS_LABEL_RESIZING, defragLabel, sizeof(defragLabel)/sizeof(TCHAR)));
        break;

    default:
        wcscpy(analyzeLabel, L"");
        wcscpy(defragLabel, L"");
    }

    // override the others if the user pressed "Stop"
    if (pVolume->StoppedByUser()){
        wcscpy(analyzeLabel, L"");
        wcscpy(defragLabel, L"");
    }

    // write the text into the graphic wells
    DrawText(WorkDC, analyzeLabel, wcslen(analyzeLabel), &rcAnalyzeDisp, DT_CENTER);
    DrawText(WorkDC, defragLabel, wcslen(defragLabel), &rcDefragDisp, DT_CENTER);

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Drawing the buttons is accomplished by simply positioning them.
    pAnalyzeButton->PaintButton();
    pDefragButton->PaintButton();
    pPauseButton->PaintButton();
    pStopButton->PaintButton();
    pReportButton->PaintButton();
/*
    EF(BitBlt (OutputDC, rcGraphics.left, rcGraphics.top, rcGraphics.right-rcGraphics.left, rcGraphics.bottom-rcGraphics.top, WorkDC, 0, 0, SRCCOPY));

    // Cleanup the bitmap stuff.
    DeleteObject(hBitmap);
    ReleaseDC(hwndGraphics, WorkDC);
    ReleaseDC(hwndGraphics, OutputDC);
*/
    return TRUE;
}
/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:
    None;

RETURN:
    None.
*/
void
SetButtonState(void)
{
    CVolume *pVolume = VolumeList.GetCurrentVolume();

    pAnalyzeButton->ShowButton(SW_SHOW);
    pDefragButton->ShowButton(SW_SHOW);
    pReportButton->ShowButton(SW_SHOW);
    pPauseButton->ShowButton(SW_SHOW);
    pStopButton->ShowButton(SW_SHOW);

    if (pVolume == (CVolume *) NULL)
        return;

    // set the pause/resume text correctly
    if (pVolume->Paused()){
        pPauseButton->SetText(hInstRes, IDS_BTN_RESUME);
    }
    else {
        pPauseButton->SetText(hInstRes, IDS_BTN_PAUSE);
    }

    if (pVolume->Locked()){ // turn off all buttons if this volume is locked
        pAnalyzeButton->EnableButton(FALSE);
        pDefragButton->EnableButton(FALSE);
        pReportButton->EnableButton(FALSE);
        pPauseButton->EnableButton(FALSE);
        pStopButton->EnableButton(FALSE);
    }
    else if (VolumeList.DefragInProcess()){ // one of the volumes is being analyzed/defragged
        pAnalyzeButton->EnableButton(FALSE);
        pDefragButton->EnableButton(FALSE);
        pReportButton->EnableButton(FALSE);
        if (pVolume->EngineState() == ENGINE_STATE_RUNNING){ // the selected vol is being analyzed/defragged
            pPauseButton->EnableButton(TRUE);
            pStopButton->EnableButton(TRUE);
        }
        else{
            pPauseButton->EnableButton(FALSE);
            pStopButton->EnableButton(FALSE);
        }
    }
    else{ // neither defrag nor analyze are not running on any volumes
        pAnalyzeButton->EnableButton(TRUE);
        pDefragButton->EnableButton(TRUE);
        pPauseButton->EnableButton(FALSE);
        pStopButton->EnableButton(FALSE);
        // is the report available for the currently selected volume?
        if (pVolume->IsReportOKToDisplay()){
            pReportButton->EnableButton(TRUE);
        }
        else{
            pReportButton->EnableButton(FALSE);
        }
    }


}

/*****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

ROUTINE DESCRIPTION:

GLOBAL VARIABLES:

INPUT:
    None;

RETURN:
    None.
*/

BOOL
DestroyGraphicsWindow(
    )
{
    if(hwndGraphics != NULL) { DestroyWindow(hwndGraphics); hwndGraphics = NULL; }
    if(pAnalyzeButton){
        delete pAnalyzeButton;
    }
    if(pDefragButton){
        delete pDefragButton;
    }
    if(pPauseButton){
        delete pPauseButton;
    }
    if(pStopButton){
        delete pStopButton;
    }
    if(pReportButton){
        delete pReportButton;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\graphwin.h ===
/**************************************************************************************************

FILENAME: GraphWin.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

**************************************************************************************************/

#define GRAPHICSWINDOW_CLASS TEXT("DfrgUI Graphics Window")
#define MIN_SCROLL_HEIGHT 200

BOOL
InitializeGraphicsWindow(
    IN HWND hwnd,
    IN HINSTANCE hInst
    );

LRESULT CALLBACK
GraphicsWndProc(
    IN  HWND hWnd,
    IN  UINT uMsg,
    IN  UINT wParam,
    IN  LONG lParam
    );

BOOL
SizeGraphicsWindow(
	void
    );

BOOL
PaintGraphicsWindowFunction(
    );

BOOL
PaintGraphicsWindow(
	IN RECT rect,
	IN BOOL bPartialRedraw,
	HDC hdc
    );

BOOL
DestroyGraphicsWindow(
    );

void
SetButtonState(
	void
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\mimessage.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  MIMessage.cpp
//=============================================================================*

#include "stdafx.h"
#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif

// from the c++ library
#include "vString.hpp"
#include "vPtrArray.hpp"

#include <htmlhelp.h>
#include "resource.h"
#include "GetDfrgRes.h"
#include "errmacro.h"
#include "MIMessage.h"

VString GetDialogBoxTextMultiple();
#include "genericdialog.h"

//-------------------------------------------------------------------*
//  function:   RaiseMIDialog
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL RaiseMIDialog(HWND hWndDialog)
{

    VString dlgString;
    UINT iWhichKeyPressed = NULL;
    CGenericDialog* genericdialog = new CGenericDialog();

    if (!genericdialog) {
        return FALSE;
    }

    genericdialog->SetTitle(IDS_DK_TITLE);  
    //close button 0
    genericdialog->SetButtonText(0,IDS_MI_HELP);
    //defrag button 1
    genericdialog->SetButtonText(1,IDS_OK);


    //get the string displayed in the dialog 
    dlgString += GetDialogBoxTextMultiple();

    genericdialog->SetText(dlgString.GetBuffer());

    //set the icon status
    genericdialog->SetIcon(IDI_CRITICAL_ICON);

    iWhichKeyPressed = genericdialog->DoModal(hWndDialog);
    delete genericdialog;

    switch(iWhichKeyPressed) { 

    case 0:
        HtmlHelp(
                hWndDialog,
                TEXT("dkconcepts.chm::/defrag_overview_01.htm"),
                HH_DISPLAY_TOPIC, //HH_TP_HELP_CONTEXTMENU,
                NULL); //(DWORD)(LPVOID)myarray);
        break;
    case 1:
        break;

    default: 
        return FALSE;
    }
        
    return TRUE;

}

VString GetDialogBoxTextMultiple()
{
    // write the Analysis Complete text in the dialog
    VString dlgText(IDS_MULTI_INSTANCE_1, GetDfrgResHandle());
    
    return(dlgText);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DfrgUI.rc
//
#define IDS_PROJNAME                    100
#define IDR_DFRGCTL                     101
#define IDI_DISK                        203
#define IDC_VOLUME_INFORMATION          203
#define IDC_MOST_FRAGMENTED             204
#define IDI_DEFRAG                      205
#define IDI_REMDISK                     214
#define IDC_SAVE                        1013
#define IDC_PRINT                       1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        215
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         210
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\postmsgc.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  PostMsgC.cpp
//=============================================================================*

// System Include files
#include "stdafx.h"

#ifndef SNAPIN
#ifndef NOWINDOWSH
#include <windows.h>
#endif
#endif


// ESI Common Include files
#include "ErrMacro.h"

extern "C" {
    #include "SysStruc.h"
}
#include "DfrgCmn.h"
#include "DfrgEngn.h"
#include "DiskDisp.h"
#include "DfrgUI.h"
#include "DfrgCtl.h"
#include "GetDfrgRes.h"
#include "DataIo.h"
#include "DataIoCl.h"
#include "Graphix.h"
#include "PostMsgC.h"
#include "DlgAnl.h"
#include "DlgDfrg.h"
#include "DfrgRes.h"
#include "VolList.h"
#include "FraggedFileList.h"


/****************************************************************************************************************

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
    
ROUTINE DESCRIPTION:
    This routines handles the 're-routed' window posted command messages. The general DataIo (DCOM)
    routines that we use would normally call the PostMessage() routine to handle incoming data requests.
    But for console applications, there is NO windows application to handle the PostMessage() commands,
    so in DataIo.cpp (SetData() routine), it was modified to call a locally define PostMessageConsole()
    routine instead if the user defines "ConsoleApplication" at build time.
  
GLOBAL DATA:
    None

INPUT:
    hWnd   - Handle to the window - always NULL
    uMsg   - The message.
    wParam - The word parameter for the message.
    lParam - the long parameter for the message.

    Note: These are the same inputs that the WndProc() routine would handle for PostMessage() commands.

RETURN:
    TRUE
*/

BOOL
CVolume::PostMessageLocal (
    IN  HWND    hWnd,
    IN  UINT    Msg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    DATA_IO* pDataIo;

    switch (LOWORD(wParam)) {

        // says that the engine is instantiated, but not defragging or analyzing
        case ID_ENGINE_START:
            {
            Message(TEXT("ID_ENGINE_START"), -1, NULL);

            // The engine sends a startup block to identify the volume
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            ENGINE_START_DATA *pEngineStartData = (ENGINE_START_DATA*) &(pDataIo->cData);
            EF_ASSERT(pDataIo->ulDataSize == sizeof(ENGINE_START_DATA));

            // the engine is running, unlock the buttons
            EngineState(ENGINE_STATE_RUNNING);
            Locked(FALSE);
            m_pVolList->Locked(FALSE);
            Paused(FALSE);
            StoppedByUser(FALSE);

            // make sure the startup volume is the current volume in the UI
            EF_ASSERT(!lstrcmp(FileSystem(), pEngineStartData->cFileSystem));

            // set the defrag mode to what the engine says
            DefragMode(pEngineStartData->dwAnalyzeOrDefrag);

            // set the UI buttons for the current state
            m_pDfrgCtl->SetButtonState();

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // defrag or analyze has actually started
        case ID_BEGIN_SCAN:
            {
            Message(TEXT("ID_BEGIN_SCAN"), -1, NULL);

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            BEGIN_SCAN_INFO* pScanInfo = (BEGIN_SCAN_INFO*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize == sizeof(BEGIN_SCAN_INFO));

            //Make sure the engine agrees which file system it's running on.
            EF_ASSERT(!lstrcmp(FileSystem(), pScanInfo->cFileSystem));

            // the engine is running, unlock the buttons
            EngineState(ENGINE_STATE_RUNNING);
            m_pVolList->Locked(FALSE);
            Locked(FALSE);

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // user pressed Pause button, engine acknowledges
        case ID_PAUSE_ON_SNAPSHOT:
            {
            Message(TEXT("ID_PAUSE"), -1, NULL);

            NOT_DATA* pNotData;

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pNotData = (NOT_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(NOT_DATA));

            PausedBySnapshot(TRUE);
            Paused(TRUE);
            Locked(FALSE);
            m_pDfrgCtl->SetButtonState();
            m_pDfrgCtl->RefreshListViewRow( this );
            m_pDfrgCtl->InvalidateGraphicsWindow();

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        case ID_PAUSE:
            {
            Message(TEXT("ID_PAUSE"), -1, NULL);

            NOT_DATA* pNotData;

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pNotData = (NOT_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(NOT_DATA));

            Paused(TRUE);
            Locked(FALSE);
            m_pDfrgCtl->SetButtonState();
            m_pDfrgCtl->RefreshListViewRow( this );
            m_pDfrgCtl->InvalidateGraphicsWindow();

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // user pressed Resume button, engine acknowledges
        case ID_CONTINUE:
            {
            Message(TEXT("ID_CONTINUE"), -1, NULL);

            NOT_DATA* pNotData;

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pNotData = (NOT_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(NOT_DATA));

            Paused(FALSE);
            PausedBySnapshot(FALSE);
            Locked(FALSE);
            m_pDfrgCtl->SetButtonState();
            m_pDfrgCtl->RefreshListViewRow( this );
            m_pDfrgCtl->InvalidateGraphicsWindow();

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // defrag or analyze has ended
        case ID_END_SCAN:
            {
            BOOL bFragmented = FALSE;
            Message(TEXT("ID_END_SCAN"), -1, NULL);

            END_SCAN_DATA* pEndScanData;

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pEndScanData = (END_SCAN_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(END_SCAN_DATA));

            // did the file system somehow magically change?
            EF_ASSERT(!lstrcmp(FileSystem(), pEndScanData->cFileSystem));

            bFragmented = ((pEndScanData->dwAnalyzeOrDefrag & DEFRAG_FAILED ) ? TRUE: FALSE);
            pEndScanData->dwAnalyzeOrDefrag = DWORD(LOWORD(pEndScanData->dwAnalyzeOrDefrag));

            // i'm not sure how this could change, but i'll set it anyway
            DefragMode(pEndScanData->dwAnalyzeOrDefrag);

            // the engine is now idle
            EngineState(ENGINE_STATE_IDLE);

            // set the progress bar to zero
            PercentDone(0,TEXT(""));

            // unlock the buttons
            Locked(FALSE);

            m_pDfrgCtl->InvalidateGraphicsWindow();
            m_pDfrgCtl->RefreshListViewRow(this);
#ifdef ESI_PROGRESS_BAR
            m_pDfrgCtl->InvalidateProgressBar();
#endif

            // Did the user ask it to stop - if so no pop-ups.
            if(!StoppedByUser()){
                // Note whether this was an analyze or defrag that finished.
                switch(DefragMode()) {

                case ANALYZE:
                    RaiseAnalyzeDoneDialog(this);
                    break;

                case DEFRAG:
                    RaiseDefragDoneDialog(this, bFragmented);
                    break;

                default:
                    EF_ASSERT(FALSE);
                    break;
                }
            }

            Paused(FALSE);

            m_pDfrgCtl->SetButtonState();

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // engine died
        case ID_TERMINATING:
            {
            Message(TEXT("ID_TERMINATING"), -1, NULL);

            NOT_DATA* pNotData;

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pNotData = (NOT_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(NOT_DATA));

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);

            // get rid of the graphics data
            Reset();

            // was this engine aborted so that it could be restarted?
            if(Restart()){
                // turn the restart state off
                Restart(FALSE);

                // send an ANALYZE or DEFRAG message to restart the engine
                if (DefragMode() == DEFRAG){
                    Defragment();
                }
                else {
                    Analyze();
                }
            }

            break;
            }

        // engine error data
        case ID_ERROR:
            {
            ERROR_DATA* pErrorData;

            // Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pErrorData = (ERROR_DATA*)&(pDataIo->cData);

            // Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(ERROR_DATA));

            if (_tcslen(pErrorData->cErrText) > 0) {
                VString title(IDS_DK_TITLE, GetDfrgResHandle());
                m_pDfrgCtl->MessageBox(pErrorData->cErrText, title.GetBuffer(), MB_OK|MB_ICONSTOP);
            }

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // sends the progress bar setting and the status that is 
        // displayed in the list view
        case ID_STATUS:
            {
            Message(TEXT("ID_STATUS"), -1, NULL);

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            STATUS_DATA *pStatusData = (STATUS_DATA*) &(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize == sizeof(STATUS_DATA));

            if (!StoppedByUser()){
                //Get the percent dones for the status bar
                //acs// Get the Pass we are on.
                Pass(pStatusData->dwPass);
//              if (PercentDone() != pStatusData->dwPercentDone){
                    PercentDone(pStatusData->dwPercentDone,pStatusData->vsFileName);
#ifdef ESI_PROGRESS_BAR
                    m_pDfrgCtl->InvalidateProgressBar();
#endif
//              }

                if (DefragState() != pStatusData->dwEngineState){
                    Message(TEXT("DefragState changed"), -1, NULL);
                    DefragState(pStatusData->dwEngineState);
                    m_pDfrgCtl->RefreshListViewRow(this);
                    m_pDfrgCtl->InvalidateGraphicsWindow();
                }
            }

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // sends the list of most fragged files
        case ID_FRAGGED_DATA:{
            Message(TEXT("ID_FRAGGED_DATA"), -1, NULL);

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            EF_ASSERT(pDataIo);

            PTCHAR pTransferBuffer = &(pDataIo->cData);

            // parse the transfer buffer and build the 
            // fragged file list list in the container
            m_FraggedFileList.ParseTransferBuffer(pTransferBuffer);

            //Make sure this is a valid size packet.
            DWORD transBufSize = m_FraggedFileList.GetTransferBufferSize();
            EF_ASSERT(pDataIo->ulDataSize == transBufSize);

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);

            break;
            }

        // sends the data displayed in the graphic wells (cluster maps)
        case ID_DISP_DATA:
            {
            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            DISPLAY_DATA* pDispData = (DISPLAY_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(DISPLAY_DATA));

            if (!StoppedByUser()){
                Message(TEXT("ID_DISP_DATA received analyze data."), -1, NULL);
                m_AnalyzeDisplay.SetLineArray(
                    (char*)&(pDispData->LineArray),
                    pDispData->dwAnalyzeNumLines);

                Message(TEXT("ID_DISP_DATA received defrag data."), -1, NULL);
                m_DefragDisplay.SetLineArray(
                    (char*)((BYTE*)&pDispData->LineArray) + pDispData->dwAnalyzeNumLines, 
                    pDispData->dwDefragNumLines);

                //Repaint graphics area
                m_pDfrgCtl->InvalidateGraphicsWindow();
            }

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        // sends the text data that is displayed on the report
        case ID_REPORT_TEXT_DATA:
            {
            Message(TEXT("ID_REPORT_TEXT_DATA"), -1, NULL);

            TEXT_DATA* pTextData = NULL;

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pTextData = (TEXT_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(TEXT_DATA));

            //Copy over the text display information. 
            CopyMemory(&m_TextData, pTextData, sizeof(TEXT_DATA));

            //Check for not enough disk space
            if (!WasFutilityChecked()){
                // check futility
                if (WarnFutility()){
                    StoppedByUser(TRUE);
                    AbortEngine(TRUE);                  // abort
                    DefragState(DEFRAG_STATE_NONE);     // defrag state is now NONE
                    Reset();
                }

                // set futility checked
                WasFutilityChecked(TRUE);
            }

            Message(TEXT("ID_REPORT_TEXT_DATA - end"), -1, NULL);

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        case ID_NO_GRAPHICS_MEMORY:
            {
            Message(TEXT("ID_NO_GRAPHICS_MEMORY"), -1, NULL);

            NOT_DATA* pNotData;

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pNotData = (NOT_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(NOT_DATA));

            //Set no graphics flag
            NoGraphicsMemory(TRUE);

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        case ID_PING:
            // Do nothing.  
            // This is just a ping sent by the engine to make sure the UI is still up.
            {
            Message(TEXT("ID_PING"), -1, NULL);

            NOT_DATA* pNotData;

            //Get a pointer to the data sent via DCOM.
            pDataIo = (DATA_IO*)GlobalLock((void*)lParam);
            pNotData = (NOT_DATA*)&(pDataIo->cData);

            //Make sure this is a valid size packet.
            EF_ASSERT(pDataIo->ulDataSize >= sizeof(NOT_DATA));

            EH_ASSERT(GlobalUnlock((void*)lParam) == FALSE);
            EH_ASSERT(GlobalFree((void*)lParam) == NULL);
            break;
            }

        default:
            EF_ASSERT(FALSE);
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__202D3AE4_2F0E_11D1_A1F6_0080C88593A5__INCLUDED_)
#define AFX_STDAFX_H__202D3AE4_2F0E_11D1_A1F6_0080C88593A5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#define STRICT

//#error DfrgUI stdafx

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#pragma warning( disable: 4786 )

#define _ATL_APARTMENT_THREADED

#ifndef MSDEVBUILD
//#include <afxwin.h>
//#include <afxdisp.h>
//#include <afxcmn.h>
#endif

#ifndef RTL_USE_AVL_TABLES 
#define RTL_USE_AVL_TABLES 0
#endif  // RTL_USE_AVL_TABLES

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>

#include <atlbase.h>
//////////////////////////////
// fixes problem with atlwin.h
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

DECLSPEC_IMPORT VOID APIENTRY DragAcceptFiles(HWND,BOOL);

#ifdef __cplusplus
}
#endif  /* __cplusplus */
// fixes problem with atlwin.h
//////////////////////////////


//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>


#include <prsht.h>
#include <shfusion.h>
#endif // !defined(AFX_STDAFX_H__202D3AE4_2F0E_11D1_A1F6_0080C88593A5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\volcom.h ===
#ifndef __VOLCOM_H__
#define __VOLCOM_H__

#include "sysstruc.h"
#include "VolList.h"
#include "DataIo.h"
#include "errmacro.h"

class CVolume;
class EsiVolumeDataObject : public EsiDataObject
{
public:
	EsiVolumeDataObject( CVolume* pVol )
	{
		_ASSERTE( pVol );
		m_pVolOwner = pVol;
	}

	//
	// Overridden to use our volume to direct messages to.
	//
    STDMETHOD(SetData)(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease);

protected:
	//
	// The volume all communications will be sent to.
	//
	CVolume* m_pVolOwner;
};

class EsiVolumeClassFactory : public CClassFactory
{
public:
	EsiVolumeClassFactory( CVolume* pVol )
	{
		_ASSERTE( pVol );
		m_pVolOwner = pVol;
	}

	//
	// Overridden to create a data object containing a volume.
	//
    STDMETHODIMP CreateInstance (LPUNKNOWN punkOuter, REFIID iid, void **ppv);

protected:
	//
	// The volume used when creating the dataobject.
	//
	CVolume* m_pVolOwner;
};

class COleStr
{
public:
	COleStr()
	{
		m_pStr = NULL;
	}

	virtual ~COleStr()
	{
		if ( m_pStr != NULL )
			CoTaskMemFree( m_pStr );
	}

	operator LPOLESTR()
	{
		return( m_pStr );
	}

	operator LPOLESTR*()
	{
		return( &m_pStr );
	}

	long GetLength()
	{
		return( wcslen( m_pStr ) );
	}

	LPOLESTR m_pStr;
};

#endif //__VOLCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\adminprivs.h ===
#ifndef _ADMINPRIVS_H
#define _ADMINPRIVS_H

BOOL
CheckForAdminPrivs (
					void
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\vollist.h ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  VolList.h
//=============================================================================*

#ifndef _VOLLIST_H
#define _VOLLIST_H

#include "stdafx.h"
#include "diskdisp.h"
#include "dfrgcmn.h"
#include "fssubs.h"
#include "VolCom.h"
#include "FraggedFileList.h"

// from the c++ library
#include "vString.hpp"
#include "vPtrArray.hpp"

// the number of chars in the volume name to compare
// to determine a match
// this handles the trailing backslash problem
#if _WIN32_WINNT>=0x0500
#define ESI_VOLUME_NAME_LENGTH 48
#else
#define ESI_VOLUME_NAME_LENGTH 6
#endif

//-------------------------------------------------------------------*
// Constants used by the CVolume class
//-------------------------------------------------------------------*
/*
// for the EngineState()
#define ENGINE_STATE_NULL       0   // Means it hasn't begun running yet.
#define ENGINE_STATE_IDLE       1   // Means it is instantiated, but not running
#define ENGINE_STATE_RUNNING    2   // Means it is running

// for the DefragMode()
#define NONE        0
#define ANALYZE     1
#define DEFRAG      2

// for DefragState()
#define DEFRAG_STATE_NONE           0   // set when the engine starts, always set thereafter
#define DEFRAG_STATE_USER_STOPPED   1   // set when user stops anal or defrag
#define DEFRAG_STATE_ANALYZING      2   // set during analyze phase only
#define DEFRAG_STATE_ANALYZED       3   // set when volume is analyzed and graphic data is available
#define DEFRAG_STATE_REANALYZING    4   // set during reanalyze phase only
#define DEFRAG_STATE_DEFRAGMENTING  5   // set when defragging is going on
#define DEFRAG_STATE_DEFRAGMENTED   6   // set when defragging is complete
*/

#define ESI_VOLLIST_ERR_MUST_RESTART    0x20009000
#define ESI_VOLLIST_ERR_FAT12           0x20009001
#define ESI_VOLLIST_ERR_NON_ADMIN       0x20009002
#define ESI_VOLLIST_ERR_NON_WRITE_DISK  0x20009004
#define ESI_VOLLIST_ERR_ENGINE_ERROR    0x20009008

// number of usable freespace bytes that is always ok to defrag with
static const ULONG UsableFreeSpaceByteMin = 1073741824;


//-------------------------------------------------------------------*
// Class that represents a single volume
//-------------------------------------------------------------------*
class CDfrgCtl;
class CVolume{
public:
    friend class CVolList;
    CVolume(PTCHAR pVolumeName, CVolList* pVolList, CDfrgCtl* pDfrgCtl);
    virtual ~CVolume();
    TCHAR           Drive(void) {return m_Drive;}
    void            Drive(TCHAR drive) {m_Drive = drive;}
    PTCHAR          VolumeName(void) {return m_VolumeName;}
    PTCHAR          VolumeNameTag(void) {return m_VolumeNameTag;}
    PTCHAR          VolumeLabel(void) {return m_VolumeLabel;}
    PTCHAR          FileSystem(void) {return m_FileSystem;}
    PTCHAR          sCapacity(void) {return m_sCapacity;}
    ULONGLONG       Capacity(void) {return m_Capacity;}
    PTCHAR          sFreeSpace(void) {return m_sFreeSpace;}
    ULONGLONG       FreeSpace(void) {return m_FreeSpace;}
    PTCHAR          DisplayLabel(void) {return m_DisplayLabel;}
    PTCHAR          sFreeSpacePercent(void) {return m_sPercentFreeSpace;}
    UINT            FreeSpacePercent(void) {return m_PercentFreeSpace;}
    UINT            DefragMode(void) {return m_DefragMode;}
    void            DefragMode(UINT defragMode) {m_DefragMode = defragMode;}
    UINT            PercentDone(void) {return m_PercentDone;}
    void            PercentDone(UINT percentDone, PTCHAR fileName);
    PTCHAR          cPercentDone(void) {return m_cPercentDone;}
    UINT            EngineState(void) {return m_EngineState;}
    void            EngineState(UINT engineState) {m_EngineState = engineState;}
    UINT            DefragState(void) {return m_DefragState;}
    void            DefragState(UINT defragState);
    PTCHAR          sDefragState(void) {return m_sDefragState;}
    BOOL            IsReportOKToDisplay(void);
    void            GetVolumeMountPointList(void);
    UINT            MountPointCount(void) {return m_MountPointCount;}
    PTCHAR          MountPoint(UINT mountPointIndex);
    BOOL            Locked(void) {return m_Locked;}
    void            Locked(BOOL locked) {m_Locked = locked;}
    BOOL            Changed(void) {return m_Changed;}
    void            Changed(BOOL isChanged) {m_Changed = isChanged;}
    BOOL            FileSystemChanged(void) {return m_FileSystemChanged;}
    BOOL            New(void) {return m_New;}
    void            New(BOOL isNew) {m_New = isNew;}
    BOOL            Deleted(void) {return m_Deleted;}
    BOOL            Paused(void) {return m_Paused;}
    void            Paused(BOOL paused);
    BOOL            PausedBySnapshot(void) {return m_PausedBySnapshot;}
    void            PausedBySnapshot(BOOL paused);
    BOOL            StoppedByUser(void) {return m_StoppedByUser;}
    void            StoppedByUser(BOOL stoppedByUser);
    BOOL            Restart(void) {return m_Restart;};
    void            Restart(BOOL restartState) {m_Restart = restartState;}
    BOOL            RemovableVolume(void) {return m_RemovableVolume;};
    void            RemovableVolume(BOOL removableVolume) {m_RemovableVolume = removableVolume;}
    BOOL            Refresh(void);
    void            Reset(void);
    void            ShowReport(void);
    void            StopEngine(void);
    void            AbortEngine(BOOL bOCXIsDead=FALSE);
    void            PauseEngine(void);
    BOOL            ContinueEngine(void);
    BOOL            Analyze(void);
    BOOL            Defragment(void);
    BOOL            PostMessageLocal(IN HWND hWnd, IN UINT Msg, IN WPARAM wParam, IN LPARAM lParam);
    BOOL            WasFutilityChecked(void) {return m_WasFutilityChecked;}
    void            WasFutilityChecked(BOOL wasFutilityChecked) {m_WasFutilityChecked = wasFutilityChecked;}
    BOOL            IsDefragFutile(DWORD *dwFreeSpaceErrorLevel);
    BOOL            WarnFutility(void);
    BOOL            NoGraphicsMemory(void) {return m_bNoGraphicsMemory;}
    void            NoGraphicsMemory(BOOL noGraphicsMemory) {m_bNoGraphicsMemory = noGraphicsMemory;}
//acs//
    UINT            Pass(void) {return m_Pass;}
    void            Pass(UINT Pass);
    PTCHAR          cPass(void) {return m_cPass;}
    TCHAR           m_fileName[100];


private:
    void            Deleted(BOOL isDeleted) {m_Deleted = isDeleted;}
    void            FileSystemChanged(BOOL isChanged) {m_FileSystemChanged = isChanged;}
    BOOL            CheckFileSystem(PTCHAR volumeLabel, PTCHAR fileSystem);
    BOOL            GetDriveLetter(void);
    void            FormatDisplayString(void);
    void            SetStatusString(void);
    BOOL            GetVolumeSizes(void);

private:
    TCHAR           m_Drive;
    TCHAR           m_VolumeName[50]; // a GUID or UNC "\\?\Volume{0c89e9d1-0523-11d2-935b-000000000000}\" or "\\.\x:"
    TCHAR           m_VolumeNameTag[50]; // can be used to concat onto file names, etc.
    TCHAR           m_FileSystem[20];
    TCHAR           m_VolumeLabel[100];
    TCHAR           m_DisplayLabel[MAX_PATH]; // drive letter + volume label or 1st Mount Point
    ULONGLONG       m_Capacity;
    TCHAR           m_sCapacity[30]; // string version
    ULONGLONG       m_FreeSpace;
    TCHAR           m_sFreeSpace[30]; // string version
    UINT            m_PercentFreeSpace;
    TCHAR           m_sPercentFreeSpace[30]; // string version
    UINT            m_DefragState; // specific phase of defrag
    TCHAR           m_sDefragState[100]; // string version specific phase of defrag
    UINT            m_DefragMode; // ANALYZE or DEFRAG
    UINT            m_EngineState; // STOPPED, IDLE OR RUNNING
    UINT            m_PercentDone; // 0 to 100 percent done
    TCHAR           m_cPercentDone[10]; // 0 to 100 percent done
    VString         m_MountPointList[MAX_MOUNT_POINTS];  // up to five mount points
    UINT            m_MountPointCount;
    BOOL            m_RemovableVolume;
    BOOL            m_Changed;
    BOOL            m_FileSystemChanged;
    BOOL            m_New;
    BOOL            m_Deleted;
    BOOL            m_Locked;
    BOOL            m_Paused;
    BOOL            m_PausedBySnapshot;
    BOOL            m_StoppedByUser;
    BOOL            m_Restart;
    BOOL            m_WasFutilityChecked;
    BOOL            m_bNoGraphicsMemory;        // engine can't allocate enough memory for graphics
//acs//
    UINT            m_Pass;
    TCHAR           m_cPass[10];

public:
    TEXT_DATA        m_TextData;
    CFraggedFileList m_FraggedFileList;

    DiskDisplay      m_AnalyzeDisplay;
    DiskDisplay      m_DefragDisplay;
    LPDATAOBJECT     m_pdataDefragEngine;

    CDfrgCtl*        m_pDfrgCtl;

    IDataObject*     m_pIDataObject;

private:
    HINSTANCE m_hDfrgRes; // handle to resource dll

//
// TLP
//
    CVolList*       m_pVolList;

public:
    BOOL PingEngine();
    const BOOL InitializeDataIo( DWORD dwRegCls = REGCLS_MULTIPLEUSE );

    //
    // Generate a random guid for communication purposes.
    //
    BOOL InitVolumeID();

    //
    // Accessor
    //
    CLSID GetVolumeID()
    {
        return( m_VolumeID );
    }

    //
    // Accessor
    //
    void SetVolumeID( CLSID VolumeID )
    {
        m_VolumeID = VolumeID;
    }

protected:
    //
    // Contains the clsid used to start communications.
    //
    CLSID m_VolumeID;

    //
    // Contains the object registration token.
    //
    DWORD m_dwRegister;

    //
    // Contains the factory registered.
    //
    IClassFactory* m_pFactory;
};

//-------------------------------------------------------------------*
// Class that represents the list of volumes on the computer
//-------------------------------------------------------------------*
class CVolList
{
private:
    VPtrArray   m_VolumeList; // array of pointers to CVolume objects
    int         m_CurrentVolume;
    BOOL        m_Locked;
    BOOL        m_Redraw;  // set this to TRUE to tell the OCX to redraw

public:
    CVolList( CDfrgCtl* pDfrgCtl );
    ~CVolList();
    BOOL Refresh(void);
    BOOL Locked(void) {return m_Locked;}
    void Locked(BOOL locked) {m_Locked = locked;}
    BOOL Redraw(void) {return m_Redraw;}
    void Redraw(BOOL redraw) {m_Redraw = redraw;}
    BOOL DefragInProcess(void);
    UINT GetVolumeCount(void) {return m_VolumeList.Size();}
    UINT GetVolumeIndex(CVolume *pVolume);  // gets the array index for a given CVolume object
    CVolume * SetCurrentVolume(CVolume *pVolume);  // sets current based on CVolume pointer
    CVolume * SetCurrentVolume(TCHAR driveLetter); // drive letter version
    CVolume * SetCurrentVolume(PTCHAR volumeName); // volume name version
    CVolume * GetCurrentVolume(void);

    // the GetVolumeAt functions do not change the current Volume
    CVolume * GetVolumeAt(UINT i);
    CVolume * GetVolumeAt(TCHAR driveLetter);
    CVolume * GetVolumeAt(PTCHAR volumeName);
    CVolume * GetVolumeRunning(void);
    UINT GetRefreshInterval(void);

protected:
    CDfrgCtl* m_pDfrgCtl;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\alloc.h ===
/**************************************************************************************************

FILENAME: Alloc.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

**************************************************************************************************/

#ifndef _ALLOC_H_
#define _ALLOC_H_


//Allocates or reallocates a memory block automatically handling locking of the pointer etc.
BOOL
AllocateMemory(
        IN DWORD SizeInBytes,
        IN OUT PHANDLE phMemory,
        IN OUT PVOID* ppMemory
        );


struct _SA_CONTEXT;
struct _SLAB_HEADER;
struct _PACKET_HEADER;


//
// This is the general slab allocator context.
//
typedef struct _SA_CONTEXT {

    //
    // Doubly linked list of allocated slabs
    //
    struct _SLAB_HEADER *pAllocatedSlabs;

    //
    // We keep up to two freed slabs lying around
    //
    struct _SLAB_HEADER *pFreeSlabs;

    //
    // Size of a packet in bytes
    //
    DWORD dwPacketSize;

    //
    // Size of a slab in bytes, usually a multiple of the page size.
    //
    DWORD dwSlabSize;

    //
    // Packets per slab
    //
    DWORD dwPacketsPerSlab;

} SA_CONTEXT, *PSA_CONTEXT;


//
// Small header at the top of the page, which contains the slab flink/blink, 
// and a pointer to the free packets in the slab
//
typedef struct _SLAB_HEADER {

    //
    // Doubly linked list flink blinks.
    //
    struct _SLAB_HEADER *pNext;
    struct _SLAB_HEADER *pPrev;

    //
    // List of freed packets in this slab.  Note that this is the list of
    // packets that were allocated and freed.  Packets that have never
    // been allocated so far are not on this list.
    //
    struct _PACKET_HEADER *pFree;

    //
    // Number of unallocated/freed packets in this slab.  0 if slab is full.
    //
    DWORD   dwFreeCount;
} SLAB_HEADER, *PSLAB_HEADER;


//
// Header at the top of a packet
//
typedef struct _PACKET_HEADER {
    union {
        //
        // In "brand new" packets (ie packets that have never been allocated), 
        // the packet header contains garbage.
        //

        //
        // In allocated packets, the packet header contains a pointer back 
        // to the slab header
        //
        struct _SLAB_HEADER  *pSlab;

        //
        // In packets that have been allocated and freed, the packet header
        // contains a pointer to the next freed pointer.  (Packets are put
        // on a singly linked list when they are freed.)
        //
        struct _PACKET_HEADER *pNext;
    };
} PACKET_HEADER, *PPACKET_HEADER;



// 
// Returns a packet of size SIZE_OF_PACKET bytes.  May return NULL if the 
// system is out of free memory.
//
PVOID
SaAllocatePacket(
    IN OUT PSA_CONTEXT pSaContext
    );

//
// Frees a packet allocated by SaAllocatePacket.  
//
VOID
SaFreePacket(
    IN PSA_CONTEXT pSaContext,
    IN PVOID pMemory
    );
//
// Frees all slabs currently in use
//
VOID
SaFreeAllPackets(
    IN OUT PSA_CONTEXT pSaContext
    );

//
// Initialises a slab-allocator context.  
//
BOOL
SaInitialiseContext(
    IN OUT PSA_CONTEXT pSaContext,
    IN CONST DWORD dwPacketSize,
    IN CONST DWORD dwSlabSize
    );

//
// Frees all memory associated with a context, and resets the context
//
VOID
SaFreeContext(
    IN OUT PSA_CONTEXT pSaContext
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\vollist.cpp ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  VolList.cpp
//=============================================================================*

#include "stdafx.h"


extern "C" {
    #include "SysStruc.h"
}

#include "VolList.h"
#include "fssubs.h"
#include "errmacro.h"
#include "DfrgRes.h"
#include "DlgRpt.h"
#include "GetDfrgRes.h" // to use the GetDfrgResHandle()
#include "GetReg.h"
#include "TextBlock.h" // to use the FormatNumber function
#include "AdminPrivs.h"
#include "DataIo.h"
#include "DataIoCl.h"
#include "Message.h"
#include "DfrgCtl.h"

#include "UiCommon.h"


//-------------------------------------------------------------------*
//  function:   CVolume::CVolume
//
//  returns:    None
//  note:       Constructor that takes a Volume GUID or UNC name
//              Format of the GUID is:
//              \\?\Volume{0c89e9d1-0523-11d2-935b-000000000000}\
//              Currently the drive letter format is (UNC):
//              \\.\x:\
//-------------------------------------------------------------------*
CVolume::CVolume(
    PTCHAR volumeName,
    CVolList* pVolList,
    CDfrgCtl* pDfrgCtl
    )
{
    // check for null pointer
    require(volumeName);

    //
    // TLP
    //
    require(pDfrgCtl);



    m_pDfrgCtl = pDfrgCtl;
    m_pVolList = pVolList;

    m_bNoGraphicsMemory = FALSE;
    m_FileSystemChanged = FALSE;
    m_Changed = TRUE;
    m_New = TRUE;
    m_Deleted = FALSE;
    m_Drive = (TCHAR) NULL;
    m_Locked = FALSE;
    m_Paused = FALSE;
    m_PausedBySnapshot = FALSE;
    m_StoppedByUser = FALSE;
    m_WasFutilityChecked = FALSE;
    m_Restart = FALSE;
    m_RemovableVolume = FALSE;
    wcscpy(m_VolumeName, L"");
    wcscpy(m_FileSystem, L"");
    wcscpy(m_VolumeLabel, L"");
    wcscpy(m_DisplayLabel, L"");
    m_Capacity = 0;
    wcscpy(m_sCapacity, L"");
    m_FreeSpace = 0;
    wcscpy(m_sFreeSpace, L"");
    m_PercentFreeSpace = 0;
    wcscpy(m_sPercentFreeSpace, L"");
    m_DefragState = 0;
    m_DefragMode = 0;
    m_EngineState = 0;
    //acs bug #101862//
    m_Pass = 0;
    wcscpy(m_cPass, L"");

    m_pIDataObject = NULL;

    SetLastError(ERROR_SUCCESS);
    // clear out the mount point list
    m_MountPointCount = 0;
    for (UINT i=0; i<MAX_MOUNT_POINTS; i++){
        m_MountPointList[i].Empty();
    }

    PercentDone(0,TEXT(""));
    
    // do all the public members too...
    ZeroMemory((void *)&m_TextData, sizeof(TEXT_DATA));
    m_pdataDefragEngine = NULL;

    // NT5: Pull the numbers out of the GUID and make a substring
    // Converting:      \\?\Volume{0c89e9d1-0523-11d2-935b-000000000000}\
    // To:          0c89e9d1052311d2935b000000000000

    // NT4: Given a drive letter x, create the UNC string \\?\x:
    // use the drive letter x as the tag

    // if this is a guid, extract the hex numbers for the tag
    if (_tcslen(volumeName) == 49){
        _tcscpy(m_VolumeName, volumeName);
        // find the first "{"
        PTCHAR pTmp = _tcschr(volumeName, TEXT('{'));
        UINT i = 0;
        while (pTmp && *pTmp){
            if (_istxdigit (*pTmp)){
                m_VolumeNameTag[i++] = *pTmp;
            }
            pTmp++;
        }
        m_VolumeNameTag[i] = (TCHAR) NULL;
    }
    // otherwise, format the volume name in UNC format and use the drive letter as the tag
    else if (_tcslen(volumeName) == 7){ // for NT 4
        _tcscpy(m_VolumeName, volumeName); // UNC format
        _stprintf(m_VolumeNameTag, TEXT("%c"), volumeName[4]); // the drive letter only
        m_Drive = volumeName[4];
    }
    else{ // error condition
        assert(FALSE);
        _stprintf(m_VolumeName, TEXT("\\\\?\\%c:\\"), TEXT('C')); // UNC format
        _stprintf(m_VolumeNameTag, TEXT("%c"), TEXT('C')); // the drive letter only
    }

    _tcscpy(m_sDefragState, TEXT(""));

    m_AnalyzeDisplay.SetNewLineColor(SystemFileColor, GREEN);       // System files
    m_AnalyzeDisplay.SetNewLineColor(PageFileColor, GREEN);         // Pagefile
    m_AnalyzeDisplay.SetNewLineColor(FragmentColor, RED);           // Fragmented files
    m_AnalyzeDisplay.SetNewLineColor(UsedSpaceColor, BLUE);         // Contiguous files
    m_AnalyzeDisplay.SetNewLineColor(FreeSpaceColor, WHITE);        // Free space
    m_AnalyzeDisplay.SetNewLineColor(DirectoryColor, BLUE);         // Directories
    m_AnalyzeDisplay.SetNewLineColor(MftZoneFreeSpaceColor, BLUE);  // MFT zone free space. set it blue by default
    m_AnalyzeDisplay.StripeMftZoneFreeSpace(FALSE);                 // Don't paint the MFT zone as a striped pattern but as a solid color instead..

    m_DefragDisplay.SetNewLineColor(SystemFileColor, GREEN);        // System files
    m_DefragDisplay.SetNewLineColor(PageFileColor, GREEN);          // Pagefile
    m_DefragDisplay.SetNewLineColor(FragmentColor, RED);            // Fragmented files
    m_DefragDisplay.SetNewLineColor(UsedSpaceColor, BLUE);          // Contiguous files
    m_DefragDisplay.SetNewLineColor(FreeSpaceColor, WHITE);         // Free space
    m_DefragDisplay.SetNewLineColor(DirectoryColor, BLUE);          // Directories
    m_DefragDisplay.SetNewLineColor(MftZoneFreeSpaceColor, BLUE);   // MFT zone free space.
    m_DefragDisplay.StripeMftZoneFreeSpace(FALSE);                  // Don't paint the MFT zone as a striped pattern but as a solid color instead..

    m_hDfrgRes = GetDfrgResHandle();

    //
    // TLP
    //
    m_pFactory = NULL;
    m_dwRegister = 0;
    InitVolumeID();

    return;
}

//-------------------------------------------------------------------*
//  function:   CVolume::~CVolume
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
CVolume::~CVolume()
{
    BOOL bDataIOStatus = TRUE;
    NOT_DATA NotData;
    UINT iCounter = 1;

    AbortEngine(TRUE); // TRUE tells the engine DO NOT SEND BACK AN ACK MESSAGE

/*    while((bDataIOStatus) && (iCounter < 10))
    {
        // Check if the engine is alive.  We do this every second for 
        // 10 seconds
        bDataIOStatus = DataIoClientSetData(ID_PING, (PTCHAR) &NotData, sizeof(NOT_DATA), m_pdataDefragEngine);
        Sleep(1000);
        ++iCounter;
    }
*/
    // Either the engine died, or it's been over 10 seconds since we told it
    // to.  We'll disconnect the engine from us, and carry on.

    // drop the connection (this also nulls the pointer)
    ExitDataIoClient(&m_pdataDefragEngine);

    // CoDisconnectObject will disconnect the object from external 
    // connections.  So the engine will get an RPC error if
    // it accesses the object after this point, but the UI
    // will not AV  (see 106357)
    if (m_pIDataObject) {
        CoDisconnectObject((LPUNKNOWN)m_pIDataObject, 0);
        m_pIDataObject->Release();
        m_pIDataObject = NULL;
    }    

    // get rid of the DCOM connection
    if ( m_dwRegister != 0 )
        CoRevokeClassObject( m_dwRegister );

    if ( m_pFactory != NULL ) {
        delete m_pFactory;
    }
}

//-------------------------------------------------------------------*
//  function:   CVolume::Reset
//
//  returns:    TRUE if all is well, otherwise FALSE
//  note:       resets all the engine parameters
//-------------------------------------------------------------------*
void CVolume::Reset(void)
{

    // drop the connection (this also nulls the pointer)
    ExitDataIoClient(&m_pdataDefragEngine);

    Sleep(200);

    // engine state is now NULL (no engine running)
    EngineState(ENGINE_STATE_NULL);
    PercentDone(0,TEXT(""));

    // engine is not paused (in case it was when it was killed)
    Paused(FALSE);

    // unlock the volume container
    m_pVolList->Locked(FALSE);

    // unlock the volume
    Locked(FALSE);

    // refresh the state of the list view
    m_pDfrgCtl->RefreshListViewRow(this);

    // Set the button states to reflect no engine.
    m_pDfrgCtl->SetButtonState();

    // delete all the graphics
    m_AnalyzeDisplay.DeleteAllData();
    m_DefragDisplay.DeleteAllData();

    // refresh the graphics window to empty out any graphics that were there
    m_pDfrgCtl->InvalidateGraphicsWindow();

#ifdef ESI_PROGRESS_BAR
    m_pDfrgCtl->InvalidateProgressBar();
#endif

    // defrag state is now NONE
    DefragState(DEFRAG_STATE_NONE);
}

//-------------------------------------------------------------------*
//  function:   CVolume::Refresh
//
//  returns:    TRUE if all is well, otherwise FALSE
//  note:       refreshed the data in a volume
//-------------------------------------------------------------------*
BOOL CVolume::Refresh(void)
{
    TCHAR tmpFileSystem[20];
    TCHAR tmpVolumeLabel[100];

    // save the file system and label to compare later
    wcscpy(tmpFileSystem, m_FileSystem);
    wcscpy(tmpVolumeLabel, m_VolumeLabel);

    if (IsValidVolume(m_VolumeName, m_VolumeLabel, m_VolumeLabel)){

        // set the flag if this is a removable vol (e.g. Jaz drive)
        RemovableVolume(IsVolumeRemovable(m_VolumeName));

        // start off assuming that there are no changes.
        // the functions below will change the flags if needed

        FileSystemChanged(FALSE);
        //Restart(FALSE);

        // check the file system and label for changes
        // (file system attributes were retrieved as part of
        // the IsValidVolume() call)
        if (!CheckFileSystem(tmpVolumeLabel, tmpFileSystem)){
            Message(L"CVolume::Refresh()", -1, _T("CheckFileSystem()"));
            EF(FALSE);
        }

        if (!GetVolumeSizes()){
            Message(L"CVolume::Refresh()", -1, _T("GetVolumeSizes()"));
            EF(FALSE);
        }

#if _WIN32_WINNT>=0x0500
        if (!GetDriveLetter()){
            // get the mount list only if needed (it's time expensive)
            GetVolumeMountPointList();
        }
#endif

        if (Changed()){
            FormatDisplayString();
        }
    }
    else{ // this is not a valid volume, so if it in the list, delete it!
        Deleted(TRUE);
    }

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CVolume::ShowReport
//
//  returns:    None
//  note:       Raises the report dialog
//-------------------------------------------------------------------*
void CVolume::ShowReport(void)
{

    if (IsReportOKToDisplay()){
        RaiseReportDialog(this);
    }
}

//-------------------------------------------------------------------*
//  function:   CVolume::StopEngine
//
//  returns:    None
//  note:       Stops the engine
//-------------------------------------------------------------------*
void CVolume::StopEngine(void)
{

    if (m_EngineState == ENGINE_STATE_RUNNING){
        Locked(TRUE); // lock the buttons
        StoppedByUser(TRUE);
        EngineState(ENGINE_STATE_IDLE);
        DataIoClientSetData(ID_STOP, NULL, 0, m_pdataDefragEngine);
    }
}

//-------------------------------------------------------------------*
//  function:   CVolume::AbortEngine
//
//  returns:    None
//  note:       Stops the engine
//-------------------------------------------------------------------*
void CVolume::AbortEngine(BOOL bOCXIsDead)
{
//  if (m_EngineState == ENGINE_STATE_IDLE ||
//      m_EngineState == ENGINE_STATE_RUNNING){
        Locked(TRUE); // lock the buttons
        EngineState(ENGINE_STATE_NULL);
        DataIoClientSetData(ID_ABORT, (PTCHAR)&bOCXIsDead, sizeof(BOOL), m_pdataDefragEngine);
//  }
}

//-------------------------------------------------------------------*
//  function:   CVolume::PauseEngine
//
//  returns:    None
//  note:       Stops the engine
//-------------------------------------------------------------------*
void CVolume::PauseEngine(void)
{

    if (m_EngineState == ENGINE_STATE_RUNNING){
        Locked(TRUE); // lock the buttons
        if (Paused()){ // the buttons send only 1 message, regardless of state
            ContinueEngine();
        }
        else{
            Paused(TRUE);
            DataIoClientSetData(ID_PAUSE, NULL, 0, m_pdataDefragEngine);
        }
    }
}

//-------------------------------------------------------------------*
//  function:   CVolume::ContinueEngine
//
//  returns:    None
//  note:       Stops the engine
//-------------------------------------------------------------------*
BOOL CVolume::ContinueEngine(void)
{

    SetLastError(ERROR_SUCCESS);
    Locked(TRUE);
    Paused(FALSE);

    // refresh the volume to determine if the engine should be restarted
    Refresh();
    if (Restart()){
        StoppedByUser(TRUE);
        DataIoClientSetData(ID_STOP, NULL, 0, m_pdataDefragEngine);
        SetLastError(ESI_VOLLIST_ERR_MUST_RESTART);
        return FALSE;
    }

    DataIoClientSetData(ID_CONTINUE, NULL, 0, m_pdataDefragEngine);

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CVolume::Analyze
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CVolume::Analyze(void)
{

    VString cmd;
    int ret;

    // ONLY ADMIN'S CAN ANALYZE A VOLUME
    if (CheckForAdminPrivs() == FALSE){
        SetLastError(ESI_VOLLIST_ERR_NON_ADMIN);
        VString title(IDS_DK_TITLE, GetDfrgResHandle());
        VString msg(IDS_NEED_ADMIN_PRIVS, GetDfrgResHandle());
        if (m_pDfrgCtl){
            m_pDfrgCtl->MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_OK|MB_ICONWARNING);
        }
        return FALSE;
    }

    SetLastError(ERROR_SUCCESS);

    if (m_pVolList->DefragInProcess()){
        // only handle this if the currently running volume is not this volume
        VString msg(IDS_LABEL_ONLY_ONE_ANALYSIS, GetDfrgResHandle());
        VString title(IDS_DK_TITLE, GetDfrgResHandle());
        if (m_pDfrgCtl){
            ret = m_pDfrgCtl->MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_YESNO|MB_ICONEXCLAMATION);
        }
        else {
            ret = IDYES;
        }
        if (ret == IDYES){
            // stop the current running engine
            CVolume *pRunningVolume = m_pVolList->GetVolumeRunning();
            if (pRunningVolume){
                pRunningVolume->StopEngine();
            }
        }
        else{
            return TRUE;
        }
    }

    // if the engine is already running, kill it and set the
    // flag to restart, and the ID_TERMINATING handler in PostMessageLocal
    // will restart the engine.
    if (m_EngineState == ENGINE_STATE_IDLE ||
        m_EngineState == ENGINE_STATE_RUNNING){

        Message(L"CVolume::Analyze() - kill engine", -1, NULL);

        // set the defrag/analyze mode
        DefragMode(ANALYZE);

        // set the flag indicating a restart
        Restart(TRUE);

        // kill the engine
        AbortEngine();
    }
    else {

        Message(L"CVolume::Analyze() - kill engine", -1, NULL);

        Restart(FALSE); // this volume does not need to be restarted

        WasFutilityChecked(TRUE);   // don't want futility dialog for analyze

        // Is this an NTFS volume?
        if(wcscmp(m_FileSystem, L"NTFS") == 0) {
            
            Message(L"CVolume::Analyze() - get engine pointer", -1, NULL);

            // Get a pointer to the NTFS engine.
            if(!InitializeDataIoClient(CLSID_DfrgNtfs, NULL, &m_pdataDefragEngine)) {
                Message(L"CVolume::Analyze() - can't get engine pointer", GetLastError(), NULL);
                SetLastError(ESI_VOLLIST_ERR_ENGINE_ERROR);
                Message(L"CVolume::Analyze() - can't get engine pointer", GetLastError(), NULL);
                return FALSE;
            }
            // Build the NTFS command string
            cmd = L"DfrgNtfs ";
        }
        // Is this a FAT or FAT32 volume?
        else if(wcscmp(m_FileSystem, L"FAT") == 0 ||
                wcscmp(m_FileSystem, L"FAT32") == 0) {

            if (IsFAT12Volume(m_VolumeName)){
                SetLastError(ESI_VOLLIST_ERR_FAT12);
                TCHAR msg[200];
                DWORD_PTR dwParams[10];

                VString msgFormat(IDMSG_BITFAT_ERROR, GetDfrgResHandle());
                VString title(IDS_DK_TITLE, GetDfrgResHandle());

                // IDMSG_BITFAT_ERROR - "Error - Volume %s: has a 12-bit FAT.
                // Diskeeper does not support 12-bit FAT partitions."
                dwParams[0] = (DWORD_PTR)DisplayLabel(); // this error will not happen for mounted volumes
                dwParams[1] = 0;
                ::FormatMessage(
                    FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    msgFormat.GetBuffer(),
                    0, 0,
                    msg, sizeof(msg)/sizeof(TCHAR),
                    (va_list*) dwParams);

                if (m_pDfrgCtl){
                    m_pDfrgCtl->MessageBox(msg, title.GetBuffer(), MB_OK|MB_ICONWARNING);
                }
                return FALSE;
            }

            Message(L"CVolume::Analyze() - get engine pointer", -1, NULL);

            // Get a pointer to the FAT engine.
            if(!InitializeDataIoClient(CLSID_DfrgFat, NULL, &m_pdataDefragEngine)) {
                Message(L"CVolume::Analyze() - can't get engine pointer", GetLastError(), NULL);
                SetLastError(ESI_VOLLIST_ERR_ENGINE_ERROR);
                Message(L"CVolume::Analyze() - can't get engine pointer", GetLastError(), NULL);
                return FALSE;
            }
            // Start the FAT command string
            cmd = L"DfrgFat ";
        }

        cmd += VolumeName();
        cmd += L" ANALYZE";

        Message(L"CVolume::Analyze() - create engine cmd", -1, cmd);
        Message(L"CVolume::Analyze() - create GUID", -1, NULL);

        //
        // Start the volume-oriented communication. Create
        // a guid for communication first.
        //
        USES_CONVERSION;
        COleStr VolID;
        StringFromCLSID(GetVolumeID(), VolID);
        InitializeDataIo();

        Message(L"CVolume::Analyze() - send engine ID_INIT_VOLUME_COMM", -1, NULL);

        //
        // Send the generated clsid to the engine.
        //
        DataIoClientSetData(ID_INIT_VOLUME_COMM,
                            OLE2T( VolID ),
                            VolID.GetLength() * sizeof( TCHAR ),
                            m_pdataDefragEngine );

        Message(L"CVolume::Analyze() - send engine ID_INITIALIZE_DRIVE", -1, NULL);

        // Send the command request to the Dfrg engine.
        DataIoClientSetData(ID_INITIALIZE_DRIVE,
                            cmd.GetBuffer(),
                            cmd.GetLength() * sizeof(TCHAR),
                            m_pdataDefragEngine);
    }

    Message(L"CVolume::Analyze()", 0, cmd.GetBuffer());

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CVolume::Defragment
//
//  returns:    None
//  note:       
//-------------------------------------------------------------------*
BOOL CVolume::Defragment(void)
{

    VString cmd;
    DWORD dLastError = 0;
    int ret;

    SetLastError(ERROR_SUCCESS);

    if (m_pVolList->DefragInProcess()){
        // only handle this if the currently running volume is not this volume
        VString msg(IDS_LABEL_ONLY_ONE_DEFRAG, GetDfrgResHandle());
        VString title(IDS_DK_TITLE, GetDfrgResHandle());
        if (m_pDfrgCtl){
            ret = m_pDfrgCtl->MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_YESNO|MB_ICONEXCLAMATION);
        }
        else{
            ret = IDYES;
        }

        if (ret == IDYES){
            // stop the current running engine
            CVolume *pRunningVolume = m_pVolList->GetVolumeRunning();
            if (pRunningVolume){
                pRunningVolume->StopEngine();
            }
        }
        else{
            return TRUE;
        }
    }

    // if the engine is already running, kill it and set the
    // flag to restart, and the ID_TERMINATING handler in PostMessageLocal
    // will restart the engine.
    if (m_EngineState == ENGINE_STATE_IDLE ||
        m_EngineState == ENGINE_STATE_RUNNING){

        // set the defrag/analyze mode
        DefragMode(DEFRAG);

        // set the flag indicating a restart
        Restart(TRUE);

        // kill the engine
        AbortEngine();
    }
    else {
        // ONLY ADMIN'S CAN DEFRAG A VOLUME
        if (CheckForAdminPrivs() == FALSE){
            VString title(IDS_DK_TITLE, GetDfrgResHandle());
            VString msg(IDS_NEED_ADMIN_PRIVS, GetDfrgResHandle());
            if (m_pDfrgCtl){
                m_pDfrgCtl->MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_OK|MB_ICONWARNING);
            }
            SetLastError(ESI_VOLLIST_ERR_NON_ADMIN);
            return FALSE;
        }

        // check for non-writeable device
        if (IsVolumeWriteable(VolumeName(),&dLastError) == FALSE)
        {
            VString title(IDS_DK_TITLE, GetDfrgResHandle());
            if(dLastError == ERROR_HANDLE_DISK_FULL)
            {
                VString msg(IDS_DISK_FULL, GetDfrgResHandle());
                msg += L": ";
                msg += DisplayLabel();
                msg += L".";
                if (m_pDfrgCtl)
                {
                    m_pDfrgCtl->MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_OK|MB_ICONWARNING);
                }
            } else
            {
                VString msg(IDS_READONLY_VOLUME, GetDfrgResHandle());
                msg += L": ";
                msg += DisplayLabel();
                msg += L".";
                if (m_pDfrgCtl)
                {
                    m_pDfrgCtl->MessageBox(msg.GetBuffer(), title.GetBuffer(), MB_OK|MB_ICONWARNING);
                }
            }   
            SetLastError(ESI_VOLLIST_ERR_NON_WRITE_DISK);
            return FALSE;
        }

        Restart(FALSE); // this volume does not need to be restarted

        WasFutilityChecked(FALSE);  // haven't checked for futility yet

        // Is this an NTFS volume?
        if(wcscmp(m_FileSystem, L"NTFS") == 0) {
            
            // Get a pointer to the NTFS engine.
            if(!InitializeDataIoClient(CLSID_DfrgNtfs, NULL, &m_pdataDefragEngine)) {
                SetLastError(ESI_VOLLIST_ERR_ENGINE_ERROR);
                return FALSE;
            }
            // Build the NTFS command string
            cmd = L"DfrgNtfs ";
        }
        // Is this a FAT or FAT32 volume?
        else if(wcscmp(m_FileSystem, L"FAT") == 0 ||
                wcscmp(m_FileSystem, L"FAT32") == 0) {

            if (IsFAT12Volume(m_VolumeName)){
                TCHAR msg[200];
                DWORD_PTR dwParams[10];

                VString msgFormat(IDMSG_BITFAT_ERROR, GetDfrgResHandle());
                VString title(IDS_DK_TITLE, GetDfrgResHandle());

                // IDMSG_BITFAT_ERROR - "Error - Volume %s: has a 12-bit FAT.
                // Diskeeper does not support 12-bit FAT partitions."
                dwParams[0] = (DWORD_PTR)DisplayLabel(); // this error will not happen for mounted volumes
                dwParams[1] = 0;
                FormatMessage(
                    FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    msgFormat.GetBuffer(),
                    0, 0,
                    msg, sizeof(msg)/sizeof(TCHAR),
                    (va_list*) dwParams);

                if (m_pDfrgCtl){
                    m_pDfrgCtl->MessageBox(msg, title.GetBuffer(), MB_OK|MB_ICONWARNING);
                }
                SetLastError(ESI_VOLLIST_ERR_FAT12);
                return FALSE;
            }

            // Get a pointer to the FAT engine.
            if(!InitializeDataIoClient(CLSID_DfrgFat, NULL, &m_pdataDefragEngine)) {
                SetLastError(ESI_VOLLIST_ERR_ENGINE_ERROR);
                return FALSE;
            }
            // Start the FAT command string
            cmd = L"DfrgFat ";
        }

        cmd += VolumeName();
        cmd += L" DEFRAG";

        //
        // Start the volume-oriented communication. Create
        // a guid for communication first.
        //
        USES_CONVERSION;
        COleStr VolID;
        StringFromCLSID(GetVolumeID(), VolID);
        InitializeDataIo();

        //
        // Send the generated clsid to the engine.
        //
        DataIoClientSetData(ID_INIT_VOLUME_COMM,
                            OLE2T( VolID ),
                            VolID.GetLength() * sizeof( TCHAR ),
                            m_pdataDefragEngine );

        // Send the command request to the Dfrg engine.
        DataIoClientSetData(ID_INITIALIZE_DRIVE,
                            cmd.GetBuffer(),
                            cmd.GetLength() * sizeof(TCHAR),
                            m_pdataDefragEngine);
    }

    Message(L"CVolume::Defrag()", 0, cmd.GetBuffer());

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CVolume::CheckFileSystem
//
//  returns:    Always returns TRUE
//  note:       Get volume label and file system
//-------------------------------------------------------------------*
BOOL CVolume::CheckFileSystem(PTCHAR volumeLabel, PTCHAR fileSystem)
{

    EF_ASSERT(volumeLabel);
    EF_ASSERT(fileSystem);

    // check to see of these values have changed
    // no need to check on a new volume
    if (!m_New) {
        m_Changed = (m_Changed || wcscmp(m_VolumeLabel, volumeLabel));
        m_FileSystemChanged = wcscmp(m_FileSystem, fileSystem);
    }

    if (m_FileSystemChanged){
        m_Changed = TRUE;
        m_Restart = TRUE;
    }

    wcscpy(m_VolumeLabel, volumeLabel);
    wcscpy(m_FileSystem, fileSystem);

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CVolume::PercentDone
//
//  returns:    void
//  note:       sets the percent done for the progress bar
//-------------------------------------------------------------------*
void CVolume::PercentDone(UINT percentDone, PTCHAR fileName){

    if (EngineState() == ENGINE_STATE_RUNNING){
        m_PercentDone = percentDone;

        assert(percentDone <= 100);
        if (m_PercentDone > 100 ) {
            m_PercentDone = 100;
        }

        //need to strip off the path of the file name leaving only the file
        if(_tcslen(fileName) > 0)
        {
            if(_tcsrchr(fileName,TEXT('\\')) != NULL)   //we have a \ in the file name
            {
                _tcsncpy(m_fileName,_tcsrchr(fileName,TEXT('\\')) + 1,95);
            } else      //we do not have a \ in the file name so just copy it
            {
                _tcsncpy(m_fileName,fileName,95);
            }

            if (_tcslen(fileName) > 95) {
                m_fileName[93] = TEXT('.');
                m_fileName[94] = TEXT('.');
                m_fileName[95] = TEXT('.');
                m_fileName[96] = TEXT('\0');
            }


        } else
        {
                _tcscpy(m_fileName,TEXT(""));
        }
    }
    else{
        m_PercentDone = 0; // if the engine is not running, then it better be 0!
    }
    if(m_PercentDone == 0 || m_PercentDone == 100)
    {
        _stprintf(m_cPercentDone, TEXT(""));
    } else
    {
        _stprintf(m_cPercentDone, TEXT("%d"), m_PercentDone);
    }
}

//acs//
//-------------------------------------------------------------------*
//  function:   CVolume::Pass
//
//  returns:    void
//  note:       sets the pass for the display
//-------------------------------------------------------------------*
void CVolume::Pass(UINT pass){
        m_Pass = pass;
        _stprintf(m_cPass, _T("%d"), m_Pass);
}

//-------------------------------------------------------------------*
//  function:   CVolume::GetVolumeSizes
//
//  returns:    TRUE if ok, otherwise FALSE
//  note:       gets the size of the volume
//-------------------------------------------------------------------*
BOOL CVolume::GetVolumeSizes(void)
{   

    ULARGE_INTEGER liBytesAvailable;
    ULARGE_INTEGER liFreeSpace;
    ULARGE_INTEGER liCapacity;
    
    BOOL isOk = GetDiskFreeSpaceEx(
        m_VolumeName,
        &liBytesAvailable,
        &liCapacity,
        &liFreeSpace);

    if (isOk == FALSE){
        Message(L"CVolume::GetVolumeSizes()", GetLastError(), _T("GetDiskFreeSpaceEx()"));
        EF(FALSE);
    }

    // get the ULONGLONG versions of the numbers
    ULONGLONG oldFreeSpace = m_FreeSpace;
    m_Capacity = liCapacity.QuadPart;
    m_FreeSpace = liFreeSpace.QuadPart;

    // if the free space changes by > 10%, set the restart bit
    if (oldFreeSpace > 0){

        if (oldFreeSpace > m_FreeSpace) {
            if ((100 * (oldFreeSpace - m_FreeSpace) / oldFreeSpace) > 10){
                m_Restart = TRUE;
            }
        }
        else {
            if ((100 * (m_FreeSpace - oldFreeSpace) / oldFreeSpace) > 10){
                m_Restart = TRUE;
            }
        }
    }
            

    // calculate %Free Space (watch for divide by 0)
    m_PercentFreeSpace = 0;
    if (m_Capacity > 0){
        m_PercentFreeSpace = (UINT) (100 * m_FreeSpace / m_Capacity);
    }

    // now get the string versions in temp variables
    TCHAR capacity[30];
    TCHAR freeSpace[30];
    FormatNumberMB(m_hDfrgRes, m_Capacity, capacity);
    FormatNumberMB(m_hDfrgRes, m_FreeSpace, freeSpace);
    swprintf(m_sPercentFreeSpace, L"%d %%", m_PercentFreeSpace);

    // check to see if these have changed.
    // I use the string versions because the byte counts change
    // more often than the string version, causing unnecessary refreshes
    if (wcscmp(capacity, m_sCapacity)){
        m_Changed = TRUE;
        wcscpy(m_sCapacity, capacity);
        m_Restart = TRUE; // if the drive capacity changes, you'd better restart!
    }

    if (wcscmp(freeSpace, m_sFreeSpace)){
        m_Changed = TRUE;
        wcscpy(m_sFreeSpace, freeSpace);
    }

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CVolume::GetDriveLetter (NT5 version)
//
//  returns:    returns TRUE if drive letter was found
//  note:       get the drive letter for a volume
//-------------------------------------------------------------------*
#if _WIN32_WINNT>=0x0500
BOOL CVolume::GetDriveLetter(void)
{

    TCHAR   cDrive[10];
    TCHAR   tmpVolumeName[GUID_LENGTH];
    TCHAR   drive;
    BOOL    isOk;

    cDrive[1] = L':';
    cDrive[2] = L'\\';
    cDrive[3] = 0;
    for (drive = L'A'; drive <= L'Z'; drive++) {
        cDrive[0] = drive;
        // get the VolumeName based on the mount point or drive letter
        isOk = GetVolumeNameForVolumeMountPoint(cDrive, tmpVolumeName, GUID_LENGTH);
        if (isOk) {
            // did we get a match on the GUID (compare first 48 or 6)?
            if (wcsncmp(tmpVolumeName, m_VolumeName, ESI_VOLUME_NAME_LENGTH) == 0) {
                // did the drive letter change?
                if (drive != m_Drive){
                    m_Changed = TRUE;
                    m_Drive = drive;
                }
                return TRUE;
            }
        }
    }

    // if it got this far, the drive letter was removed
    if (m_Drive){
        m_Drive = (TCHAR) NULL;
        m_Changed = TRUE;
        m_Restart = TRUE;
    }

    return FALSE;
}
#endif // #if _WIN32_WINNT>=0x0500

//-------------------------------------------------------------------*
//  function:   CVolume::FormatDisplayString
//
//  returns:    None
//  note:       Formats the display string for a volume
//-------------------------------------------------------------------*
void CVolume::FormatDisplayString(void)
{   
    // create the volume label display string

    if (m_Drive){
        if(wcslen(m_VolumeLabel) == 0){
            wsprintf(m_DisplayLabel, L"(%c:)", m_Drive);
        }
        else{
            // "<volume label> (C:)"
            wsprintf(m_DisplayLabel, L"%s (%c:)", m_VolumeLabel, m_Drive);
        }
    }
    else if (wcslen(m_VolumeLabel) > 0){  // use the label only if that's what we have
        wcscpy(m_DisplayLabel, m_VolumeLabel);
    }
    else if (m_MountPointCount > 0){  // no drive letter or label, use the first mount point
        // start off with "Mounted Volume"
        LoadString(m_hDfrgRes, IDS_MOUNTED_VOLUME, m_DisplayLabel, 50);
        wcscat(m_DisplayLabel, L": ");

        // concat the first mount point
        int len = wcslen(m_DisplayLabel);
        if (m_MountPointList[0].GetLength() + len > MAX_PATH) {
            wcsncat(m_DisplayLabel, m_MountPointList[0].GetBuffer(), MAX_PATH - len - 3);
            m_DisplayLabel[MAX_PATH - len - 3] = TEXT('\0');
            wcscat(m_DisplayLabel, TEXT("..."));
        }
        else {
            wcscat(m_DisplayLabel, m_MountPointList[0].GetBuffer());
        }
    }
    else {  // no drive letter or label or mount point
        LoadString(m_hDfrgRes, IDS_UNMOUNTED_VOLUME, m_DisplayLabel, 50);
    }
}
//-------------------------------------------------------------------*
//  function:   CVolume::GetVolumeMountPointList (NT5 Only)
//
//  returns:    None
//  note:       
//  Finds all the spots where a volume is mounted
//  by searching all the drive letters for mount points that they support
//  and comparing the volume GUID that is mounted there to the volume GUID we are
//  interested in. When the GUIDs match, we have found a mount point for this volume.
//  s that clear?
//-------------------------------------------------------------------*
#ifndef VER4
void CVolume::GetVolumeMountPointList(void)
{   

    VString cDrive = L"x:\\";
    BOOL    mountPointFound = FALSE;
    TCHAR   drive;
    UINT    i;

    // clear out the mount point list (we keep only 10 mount points, but there could be more)
    // we display in the list view only the first one to come up
    // the report will display up to 10
    m_MountPointCount = 0;
    for (i=0; i<MAX_MOUNT_POINTS; i++){
        m_MountPointList[i].Empty();
    }

    for (TCHAR driveLetter = L'A'; driveLetter <= L'Z'; driveLetter++) {
        if (IsValidVolume(driveLetter)){
            cDrive[0] = driveLetter;
            mountPointFound =
                (GetMountPointList(cDrive, m_VolumeName, m_MountPointList, m_MountPointCount) || mountPointFound);
        }
    }

    // find the actual drive letter (if it exists)
    BOOL driveLetterFound = FALSE;
    for (i=0; i<m_MountPointCount; i++){
        if (m_MountPointList[i].GetLength() == 3){
            drive = m_MountPointList[i][0];
            driveLetterFound = TRUE;
            if (drive != m_Drive){
                m_Changed = TRUE;
                m_Drive = drive;
            }
            break;
        }
    }

    if (!driveLetterFound)
        m_Drive = L'';
}
#endif //#ifndef VER4

//-------------------------------------------------------------------*
//  function:   CVolume::IsReportOKToDisplay
//
//  returns:    TRUE is report is availble, otherwise FALSE
//  note:       
//-------------------------------------------------------------------*
BOOL CVolume::IsReportOKToDisplay(void)
{
    // whether the report is available for display

    return (m_EngineState == ENGINE_STATE_IDLE && !m_StoppedByUser);
}

//-------------------------------------------------------------------*
//  function:   CVolume::StoppedByUser
//
//  returns:    None ("Get" version in VolList.h)
//  note:       Used to set the flag if the user stopped the process
//-------------------------------------------------------------------*
void CVolume::StoppedByUser(BOOL stoppedByUser)
{

    // don't bother if it's already true and the state didn't changed
    if (stoppedByUser && stoppedByUser == m_StoppedByUser)
        return;

    m_Changed = TRUE;

    m_StoppedByUser = stoppedByUser;

    if (m_StoppedByUser){
        DefragState(DEFRAG_STATE_USER_STOPPED);
    }

    PercentDone(0,TEXT(""));

    m_AnalyzeDisplay.DeleteAllData();
    m_DefragDisplay.DeleteAllData();

    SetStatusString();
}

//-------------------------------------------------------------------*
//  function:   CVolume::Paused
//
//  returns:    None
//  note:       Sets the Paused flag ("Get" version in VolList.h)
//-------------------------------------------------------------------*
void CVolume::Paused(BOOL paused)
{

    // don't bother if the state didn't changed
    if (paused == m_Paused)
        return;

    m_Changed = TRUE;
    m_Paused = paused;
    SetStatusString();
}

//-------------------------------------------------------------------*
//  function:   CVolume::PausedBySnapshot
//
//  returns:    None
//  note:       Sets the PausedBySnapshot flag ("Get" version in VolList.h)
//-------------------------------------------------------------------*
void CVolume::PausedBySnapshot(BOOL paused)
{

    // don't bother if the state didn't changed
    if (paused == m_PausedBySnapshot)
        return;

    m_Changed = TRUE;
    m_PausedBySnapshot = paused;
    SetStatusString();
}

//-------------------------------------------------------------------*
//  function:   CVolume::MountPoint (NT5 only)
//
//  returns:    None
//  note:       Gets mount point string given an index
//-------------------------------------------------------------------*
PTCHAR CVolume::MountPoint(UINT mountPointIndex)
{

    require(mountPointIndex > 0 || mountPointIndex < m_MountPointCount);

    // remember, m_MountPointList is an array of VStrings
    return m_MountPointList[mountPointIndex].GetBuffer();
}

//-------------------------------------------------------------------*
//  function:   CVolume::DefragState
//
//  returns:    None ("Get" version in VolList.h)
//  note:       Sets the defrag state
//-------------------------------------------------------------------*
void CVolume::DefragState(UINT defragState)
{

    // if we are starting a defrag w/o a previous analysis
    // then say "Analyzing" instead of "Reanalyzing"
    if (m_DefragState < DEFRAG_STATE_ANALYZED && defragState == DEFRAG_STATE_REANALYZING){
        defragState = DEFRAG_STATE_ANALYZING;
    }

    // don't bother if the state didn't changed
    // or if something tried to set the state back to DEFRAG_STATE_NONE
    // 'cause it's not allowed. Once it's set it's set.
    if (defragState == m_DefragState)
        return;

    m_Changed = TRUE;

    m_DefragState = defragState;

    SetStatusString();
}

//-------------------------------------------------------------------*
//  function:   CVolume::SetStatusString
//
//  returns:    None
//  note:       This creates a string that fully describes the volume
//              status.  This text is displayed in the Session State
//              column and in the Graphics Wells.
//-------------------------------------------------------------------*
void CVolume::SetStatusString(void)
{

    UINT resourceID=0;

    if (m_StoppedByUser) {
        resourceID = IDS_LABEL_USER_STOPPED;
    }
    else if (m_Paused) {
        if (m_PausedBySnapshot) {
            m_DefragDisplay.SetReadyToDraw(FALSE);    
            resourceID = IDS_LABEL_PAUSED_BY_SNAPSHOT;
        }
        else {
            resourceID = IDS_LABEL_PAUSED;
        }
    }
    else {
        // the string version based on the state
        switch (m_DefragState){
        case DEFRAG_STATE_NONE:
            resourceID = 0;
            break;

        case DEFRAG_STATE_ANALYZING:
            resourceID = IDS_LABEL_ANALYZINGDDD;
            break;

        case DEFRAG_STATE_ANALYZED:
            resourceID = IDS_LABEL_ANALYZED;
            break;

        case DEFRAG_STATE_REANALYZING:
            resourceID = IDS_LABEL_REANALYZINGDDD;
            break;

        case DEFRAG_STATE_BOOT_OPTIMIZING:
        case DEFRAG_STATE_DEFRAGMENTING:
            resourceID = IDS_LABEL_DEFRAGMENTINGDDD;
            break;

        case DEFRAG_STATE_DEFRAGMENTED:
            resourceID = IDS_LABEL_DEFRAGMENTED;
            break;

        case DEFRAG_STATE_ENGINE_DEAD:
            resourceID = IDS_ENGINE_DEAD;
            break;
        }
    }

    if (resourceID){
        LoadString(
            m_hDfrgRes,
            resourceID,
            m_sDefragState,
            sizeof(m_sDefragState) / sizeof(TCHAR));
    }
    else {
        wcscpy(m_sDefragState, L"");
    }
}

//-------------------------------------------------------------------*
//  function:   CVolume::IsDefragFutile
//
//  returns:    TRUE if futile, otherwise FALSE
//  note:       Futility is determined as both a percent stored in the
//              registry and a hard-coded constant (1GB).
//-------------------------------------------------------------------*
BOOL CVolume::IsDefragFutile(DWORD *dwFreeSpaceErrorLevel)
{

    *dwFreeSpaceErrorLevel = 0;

    // check for absolute free space (don't care about percent)
    if (m_TextData.UsableFreeSpace >= UsableFreeSpaceByteMin) {
        return FALSE;                       // OK to defrag
    }

    // get threshold percent from registry
    TCHAR cRegValue[100];
    HKEY hValue = NULL;
    DWORD dwRegValueSize = sizeof(cRegValue);

    // get the free space error threshold from the registry
    long ret = GetRegValue(
        &hValue,
        TEXT("SOFTWARE\\Microsoft\\Dfrg"),
        TEXT("FreeSpaceErrorLevel"),
        cRegValue,
        &dwRegValueSize);

    RegCloseKey(hValue);

    // convert it and apply range limits
    if (ret == ERROR_SUCCESS) {
        *dwFreeSpaceErrorLevel = (DWORD) _ttoi(cRegValue);

        // > 50 does not make sense!
        if (*dwFreeSpaceErrorLevel > 50)
            *dwFreeSpaceErrorLevel = 50;

        // < 0 does not either!
        if (*dwFreeSpaceErrorLevel < 1)
            *dwFreeSpaceErrorLevel = 0;
    }

    // check usable freespace vs. the threshold
    if (m_TextData.UsableFreeSpacePercent < *dwFreeSpaceErrorLevel) {
        return TRUE;                        // not enough to defrag
    }

    return FALSE;                           // default OK to defrag
}

//-------------------------------------------------------------------*
//  function:   CVolume::WarnFutility
//
//  returns:    TRUE if user aborts, otherwise FALSE
//  note:       Checks if defragmenting is futile or not, warns user
//              if it is, and offers them a choice to cancel or proceed.
//-------------------------------------------------------------------*
BOOL CVolume::WarnFutility(void)
{

    BOOL  userabort = FALSE;

    TCHAR         msg[800];
    TCHAR         title[100];

    // if too little free space, then notify user
    if(!ValidateFreeSpace(FALSE, m_TextData.FreeSpace, m_TextData.UsableFreeSpace,
                          m_TextData.DiskSize, m_DisplayLabel, msg, sizeof(msg) / sizeof(TCHAR)))
    {
        // prompt user
        int ret = IDYES;

        if (m_pDfrgCtl)
        {
            // pause the engine
            PauseEngine();

            // prompt user if they want to continue
            LoadString(GetDfrgResHandle(), IDS_DK_TITLE, title, sizeof(title) / sizeof(TCHAR));
            ret = m_pDfrgCtl->MessageBox(msg, title, MB_YESNO | MB_ICONWARNING);

            // restart it
            ContinueEngine();
        }

        // user wants to abort
        if (ret == IDNO) {
            userabort = TRUE;
        }
    }

    return userabort;
}

//-------------------------------------------------------------------*
//  function:   CVolume::PingEngine
//              Ping engine to see if it is still alive
//
//  returns:    
//  note:       It send the engine the number of lines in the line array
//-------------------------------------------------------------------*
BOOL CVolume::PingEngine()
{

    if (EngineState() != ENGINE_STATE_NULL)
    {
        SET_DISP_DATA DispData = {0};
        DispData.AnalyzeLineCount = m_AnalyzeDisplay.GetLineCount();
        DispData.DefragLineCount = m_DefragDisplay.GetLineCount();
        DispData.bSendGraphicsUpdate = FALSE;  // no need to send graphics

        BOOL bReturn = DataIoClientSetData(ID_SETDISPDIMENSIONS,
                        (PTCHAR)&DispData,
                        sizeof(SET_DISP_DATA),
                        m_pdataDefragEngine);

        if (!bReturn)
        {
            Message(TEXT("CDfrgCtl error pinging engine"), -1, NULL);
            Reset();
            DefragState(DEFRAG_STATE_ENGINE_DEAD);
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------*
//  function:   CVolList::CVolList
//
//  returns:    None
//  note:       Constructor for the VolumeList container.  Needs the
//              address of the parent OCX, and stores it.
//-------------------------------------------------------------------*
CVolList::CVolList(CDfrgCtl* pDfrgCtl)
{

    m_CurrentVolume = -1;
    m_Locked = FALSE;
    m_Redraw = FALSE;  // set this to TRUE to tell the OCX to redraw

    // parent OCX address
    m_pDfrgCtl = pDfrgCtl;
}
//-------------------------------------------------------------------*
//  function:   CVolList::~CVolList
//
//  returns:    None
//  note:       Volume container class destructor
//-------------------------------------------------------------------*
CVolList::~CVolList()
{
    // Clear out the Volume List
    CVolume *pVolume;
    for (int i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (pVolume)
            delete pVolume;
    }
}

//-------------------------------------------------------------------*
//  function:   CVolList::Refresh (NT5 version)
//
//  returns:    TRUE if success, otherwise FALSE
//  note:       Populates the Volume list
//-------------------------------------------------------------------*
#if _WIN32_WINNT>=0x0500
BOOL CVolList::Refresh(void)
{

    HANDLE  hVolList;
    BOOL    bVolumeFound;
    TCHAR   volumeName[GUID_LENGTH];
    CVolume *pVolume;
    int i;

    Message(TEXT("Refreshing ListView..."), -1, NULL);
    ///////////////////////////////////////
    // step 1 - delete any that are marked
    // as deleted and scrunch the array.
    // These were marked during the last refresh.
    ///////////////////////////////////////

    for (i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (pVolume->Deleted()){
            delete (CVolume*) m_VolumeList[i]; // get rid of the CVolume object
            m_VolumeList.RemoveAt(i); // scrunch the array
        }
    }

    ///////////////////////////////////////
    // step 2 - mark ALL volumes as deleted
    ///////////////////////////////////////

    for (i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        pVolume->Deleted(TRUE);
    }

    ///////////////////////////////////////
    // step 3 - loop through volumes and note
    // which are actually NOT deleted, leaving
    // the deleted volumes marked as deleted.
    ///////////////////////////////////////

    hVolList = FindFirstVolume(volumeName, sizeof(volumeName) / sizeof(TCHAR));
    if (hVolList == INVALID_HANDLE_VALUE) {
        Message(TEXT("CVolList::Refresh()"), GetLastError(), TEXT("FindFirstVolume()"));
        EF(FALSE);
    }
    
    for (;;) {

        // find this volume in the list (if you can)
        pVolume = GetVolumeAt(volumeName);

        // if found, mark as NOT deleted
        if (pVolume){
            pVolume->Deleted(FALSE);
        }
        bVolumeFound = FindNextVolume(hVolList, volumeName, sizeof(volumeName) / sizeof(TCHAR));
        if (!bVolumeFound) {
            break;
        }
    }

    FindVolumeClose(hVolList);

    ///////////////////////////////////////
    // step 4 - Add new volumes
    ///////////////////////////////////////

    // FindFirst/FindNextVolume return volume guids in the form:
    // "\\?\Volume{06bee7c1-82cf-11d2-afb2-000000000000}\"
    // NOTE THE TRAILING WHACK!

    hVolList = FindFirstVolume(volumeName, sizeof(volumeName) / sizeof(TCHAR));
    if (hVolList == INVALID_HANDLE_VALUE) {
        Message(TEXT("CVolList::Refresh()"), GetLastError(), TEXT("FindFirstVolume()"));
        EF(FALSE);
    }

    // these are used to store the results from IsValidVolume()
    // in case we need them
    TCHAR volumeLabel[100];
    TCHAR fileSystem[20];

    // loop through all the volumes on this computer
    for (;;) {

        // if this NEW volume is OK, IsValidVolume() will return TRUE and fill in the label and file system
        if (IsValidVolume(volumeName, volumeLabel, fileSystem)){

            // find this volume in the list (if you can)
            pVolume = GetVolumeAt(volumeName);

            // if the volume was not in the list, add it
            if (pVolume == (CVolume *) NULL){

                // create a new CVolume object and place it into the list
                // the constructor can take the VolumeName as an argument
                pVolume = (CVolume *) new CVolume(volumeName, this, m_pDfrgCtl);
                if (pVolume == (CVolume *) NULL){
                    Message(L"CVolList::Refresh()", -1, _T("new Failed"));
                    FindVolumeClose(hVolList);
                    EF(FALSE);
                }
                // add the new volume object to the list
                // and increment the counter
                m_VolumeList.Add(pVolume);
                pVolume->New(TRUE);
            }
            else{
                pVolume->New(FALSE);
            }

            // set the flag if this is a removable vol (e.g. Jaz drive)
            pVolume->RemovableVolume(IsVolumeRemovable(volumeName));

            // start off assuming that there are no changes.
            // the functions below will change the flags if needed
            pVolume->FileSystemChanged(FALSE);

            // check the file system for changes
            // (file system attributes were retrieved as part of the IsValidVolume() call)
            if (!pVolume->CheckFileSystem(volumeLabel, fileSystem)){
                Message(TEXT("CVolList::Refresh()"), -1, _T("Bad value passed into CheckFileSystem()"));
                EF(FALSE);
            }

            if (!pVolume->GetVolumeSizes()){
                Message(TEXT("CVolList::Refresh()"), GetLastError(), TEXT("GetVolumeSizes()"));
                EF(FALSE);
            }

            if (!pVolume->GetDriveLetter()){
                // get the mount list only if needed (it's time expensive)
                pVolume->GetVolumeMountPointList();
            }

            if (pVolume->Changed()){
                pVolume->FormatDisplayString();
            }
        }
        else{ // this is not a valid volume, so if it in the list, delete it!
            // this happens when a Jaz disk is ejected

            // find this volume in the list (if you can)
            pVolume = GetVolumeAt(volumeName);

            // if found, mark as NOT deleted
            if (pVolume){
                pVolume->Deleted(TRUE);
            }
        }


        bVolumeFound = FindNextVolume(hVolList, volumeName, sizeof(volumeName) / sizeof(TCHAR));
        if (!bVolumeFound) {
            break;
        }
    }

    FindVolumeClose(hVolList);

    // if the volume is deleted and the engine is running, stop the engine
    for (i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (pVolume->Deleted()){
            if (pVolume->EngineState() == ENGINE_STATE_IDLE ||
                pVolume->EngineState() == ENGINE_STATE_RUNNING){
                pVolume->AbortEngine();
            }
        }
    }

    return TRUE;
}
#endif // #if _WIN32_WINNT>=0x0500

//-------------------------------------------------------------------*
//  function:   CVolList::Refresh (NT4 version)
//
//  returns:    TRUE if success, otherwise FALSE
//  note:       Populates the Volume list
//-------------------------------------------------------------------*
#ifdef VER4
BOOL CVolList::Refresh(void)
{

    TCHAR   volumeName[GUID_LENGTH];
    CVolume *pVolume;
    int i;

    ///////////////////////////////////////
    // step 1 - delete any that are marked
    // as deleted and scrunch the array.
    // These were marked during the last refresh.
    ///////////////////////////////////////

    for (i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (pVolume->Deleted()){
            delete (CVolume*) m_VolumeList[i]; // get rid of the CVolume object
            m_VolumeList.RemoveAt(i); // scrunch the array
        }
    }

    ///////////////////////////////////////
    // step 2 - mark ALL volumes as deleted
    ///////////////////////////////////////

    for (i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        pVolume->Deleted(TRUE);
    }

    ///////////////////////////////////////
    // step 3 - loop through volumes and note
    // which are actually NOT deleted, leaving
    // the deleted volumes marked as deleted.
    ///////////////////////////////////////

    TCHAR driveLetter;
    TCHAR cRootPath[4];
    TCHAR volumeLabel[100];
    TCHAR fileSystem[20];

    for(i=0; i<26; i++){

        driveLetter = (TCHAR)(i + 'A');

        //0.0E00 Don't bother with CDRoms, network drives or floppy drives.
        if (!IsValidVolume(driveLetter))
            continue;

        wsprintf(cRootPath, L"%c:\\", driveLetter);

        if (!GetVolumeInformation(
                cRootPath,
                volumeLabel,
                sizeof(volumeLabel)/sizeof(TCHAR),
                NULL,
                NULL,
                NULL,
                fileSystem,
                sizeof(fileSystem)/sizeof(TCHAR))) {
            continue;
        }

        // Only NTFS, FAT or FAT32
        if (wcscmp(fileSystem, L"NTFS")  != 0 &&
            wcscmp(fileSystem, L"FAT")   != 0 &&
            wcscmp(fileSystem, L"FAT32") != 0) {
            continue;
        }

        // if it made it this far, this volume is OK and should
        // be kept in the list or added
        wsprintf(volumeName, L"\\\\.\\%c:\\", driveLetter);

        // find this volume in the list (if you can)
        pVolume = GetVolumeAt(volumeName);

        // if found, mark as NOT deleted
        if (pVolume){
            pVolume->New(FALSE);
            pVolume->Deleted(FALSE);
        }
        else {
            // create a new CVolume object and place it into the list
            // the constructor can take the VolumeName as an argument
            pVolume = (CVolume *) new CVolume(volumeName);
            if (pVolume == (CVolume *) NULL){
                Message(L"CVolList::Refresh()", -1, _T("new Failed"));
                EF(FALSE);
            }
            // add the new volume object to the list
            // and increment the counter
            m_VolumeList.Add(pVolume);
            pVolume->New(TRUE);

            // start off assuming that there are no changes.
            // the functions below will change the flags if needed
            pVolume->FileSystemChanged(FALSE);

        }

        // set the flag if this is a removable vol (e.g. Jaz drive)
        pVolume->RemovableVolume(IsVolumeRemovable(volumeName));

        // check the file system for changes
        if (!pVolume->CheckFileSystem(volumeLabel, fileSystem)){
            Message(TEXT("CVolList::Refresh()"), -1, _T("Bad value passed into CheckFileSystem()");
            EF(FALSE);
        }

        if (!pVolume->GetVolumeSizes()){
            Message(L"CVolume::Refresh()", GetLastError(), _T("GetVolumeSizes()"));
            EF(FALSE);
        }

        // if some data has changed, redo the display string
        if (pVolume->Changed()){
            pVolume->FormatDisplayString();
        }
    }

    return TRUE;
}
#endif // #if _WIN32_WINNT<0x0500

//-------------------------------------------------------------------*
//  function:   CVolList::SetCurrentVolume(by drive letter)
//
//  returns:    Address of Volume (if found) otherwise NULL
//  note:       Gets the volume based on drive letter, and makes that
//              the current volume
//-------------------------------------------------------------------*
CVolume * CVolList::SetCurrentVolume(TCHAR driveLetter)
{

    CVolume *pVolume;
    for (int i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (pVolume->Drive() == driveLetter){
            m_CurrentVolume = i;
            return (CVolume *) m_VolumeList[i];
        }
    }

    return (CVolume *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CVolList::SetCurrentVolume(by volume name, GUID or UNC)
//
//  returns:    Address of Volume (if found) otherwise NULL
//  note:       Gets the volume based on volume name, and makes that
//              the current volume
//-------------------------------------------------------------------*
CVolume * CVolList::SetCurrentVolume(PTCHAR volumeName)
{

    CVolume *pVolume;
    for (int i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (wcsncmp(pVolume->VolumeName(), volumeName, ESI_VOLUME_NAME_LENGTH) == 0){
            m_CurrentVolume = i;
            return (CVolume *) m_VolumeList[i];
        }
    }

    return (CVolume *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CVolList::SetCurrentVolume(by CVolume * pointer)
//
//  returns:    Address of Volume (if found) otherwise NULL
//  note:       Gets the volume based on volume address, and makes that
//              the current volume
//-------------------------------------------------------------------*
CVolume * CVolList::SetCurrentVolume(CVolume *pVolume)
{

    for (int i=0; i<m_VolumeList.Size(); i++){
        if (m_VolumeList[i] == pVolume){
            m_CurrentVolume = i;
            return (CVolume *) m_VolumeList[i];
        }
    }

    return (CVolume *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CVolList::GetCurrentVolume
//
//  returns:    Address of current Volume, otherwise NULL
//  note:       Gets the address of the current volume
//-------------------------------------------------------------------*
CVolume * CVolList::GetCurrentVolume(void)
{

    if (m_CurrentVolume > -1)
        return (CVolume *) m_VolumeList[m_CurrentVolume];

    return (CVolume *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CVolList::GetVolumeAt(based on index)
//
//  returns:    Address of volume at an index (used for looping)
//  note:       DOES NOT set the current volume
//-------------------------------------------------------------------*
CVolume * CVolList::GetVolumeAt(UINT i)
{

    if (i >= (UINT) m_VolumeList.Size())
        return (CVolume *) NULL;

    if (m_VolumeList.Size() > -1){
        return (CVolume *) m_VolumeList[i];
    }

    return (CVolume *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CVolList::GetVolumeAt(based on drive letter)
//
//  returns:    Address of volume
//  note:       DOES NOT set the current volume
//-------------------------------------------------------------------*
CVolume * CVolList::GetVolumeAt(TCHAR driveLetter)
{

    CVolume *pVolume;
    for (int i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (pVolume->Drive() == driveLetter){
            return (CVolume *) m_VolumeList[i];
        }
    }

    return (CVolume *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CVolList::GetVolumeAt(based on Volume Name)
//
//  returns:    Address of volume
//  note:       DOES NOT set the current volume
//-------------------------------------------------------------------*
CVolume * CVolList::GetVolumeAt(PTCHAR volumeName)
{

    CVolume *pVolume;
    for (int i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (wcsncmp(pVolume->VolumeName(), volumeName, ESI_VOLUME_NAME_LENGTH) == 0){
            return (CVolume *) m_VolumeList[i];
        }
    }

    return (CVolume *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CVolList::GetVolumeIndex
//
//  returns:    Index of a volume given its address
//  note:       DOES NOT set the current volume
//-------------------------------------------------------------------*
UINT CVolList::GetVolumeIndex(CVolume *pVolume)
{

    for (int i=0; i<m_VolumeList.Size(); i++){
        if (pVolume == m_VolumeList[i]){
            return i;
        }
    }

    return -1;
}

//-------------------------------------------------------------------*
//  function:   CVolList::GetVolumeRunning
//
//  returns:    Gets a pointer to the volume that is running
//  note:       Returns NULL if none are running
//-------------------------------------------------------------------*
CVolume * CVolList::GetVolumeRunning(void)
{

    CVolume *pVolume;
    for (int i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (pVolume->EngineState() == ENGINE_STATE_RUNNING){
            return pVolume;
        }
    }

    return (CVolume *) NULL;
}

//-------------------------------------------------------------------*
//  function:   CVolList::DefragInProcess
//
//  returns:    TRUE if an engine is currently defragmenting a drive
//  note:       
//-------------------------------------------------------------------*
BOOL CVolList::DefragInProcess(void)
{

    CVolume *pVolume;
    for (int i=0; i<m_VolumeList.Size(); i++){
        pVolume = (CVolume *) m_VolumeList[i];
        if (pVolume->EngineState() == ENGINE_STATE_RUNNING){
            return TRUE;
        }
    }

    return FALSE;
}
//-------------------------------------------------------------------*
//  function:   CVolList::GetRefreshInterval
//
//  returns:    Sets the refresh interval based on number of volumes
//              in the list (I just made them up!)
//  note:       Refresh interval in milliseconds
//-------------------------------------------------------------------*
UINT CVolList::GetRefreshInterval(void)
{

    if (m_VolumeList.Size() < 10)
        return 3 * 1000; // 3 seconds
    else if (m_VolumeList.Size() < 50)
        return 30 * 1000; // 30 seconds
    else
        return 5 * 60 * 1000; // 5 minutes
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\dfrgui\volcom.cpp ===
#include "stdafx.h"
#include "VolCom.h"
#include "DataIoCl.h"
#include "PostMsgC.h"

STDMETHODIMP EsiVolumeDataObject::SetData(LPFORMATETC pformatetc, 
                                    STGMEDIUM FAR * pmedium,
                                    BOOL fRelease)
{
    WPARAM wpPostCommand;
    DWORD dwGlobalSize;
    char FAR* pstrSrc;
    PCHAR pDataIn;
    
    // We only support CF_TEXT
    if (pformatetc->cfFormat != CF_TEXT)
        return E_FAIL;

    // We want memory only.
    if (pformatetc->tymed != TYMED_HGLOBAL) 
        return E_FAIL;

    // Check for valid memory handle.
    if(pmedium->hGlobal == NULL) 
        return E_FAIL;

    // Get the size of the incoming data.
    dwGlobalSize = (DWORD)GlobalSize(pmedium->hGlobal);

    // Allocate enough memory for the incoming data.
    hDataIn = GlobalAlloc(GHND,dwGlobalSize);
	EE_ASSERT(hDataIn);

    // Lock and get pointers to the data.
    pDataIn = (PCHAR)GlobalLock(hDataIn);
	EE_ASSERT(pDataIn);
    pstrSrc  = (char FAR*)GlobalLock(pmedium->hGlobal);
	EE_ASSERT(pstrSrc);

    // Copy the data to this processes memory.
    CopyMemory(pDataIn, pstrSrc, dwGlobalSize);

    // Unlock and release the pointer to the source memory.
    GlobalUnlock(pmedium->hGlobal);

	// Release the memory if requested by the caller.
    if (fRelease) 
	    ReleaseStgMedium(pmedium);

    DATA_IO* pDataIo = (DATA_IO*)pDataIn;

    // Extract the Post Command message
    wpPostCommand = pDataIo->wparam;

    // Check ESI data structre ID which is always = 0x4553 'ES'
    if(pDataIo->dwID != ESI_DATA_STRUCTURE) 
        return FALSE;

    // Check the data structure type.
    if(pDataIo->dwType != FR_COMMAND_BUFFER) 
        return FALSE;

    // Check for data structure compatibility.
   	if(pDataIo->dwCompatibilty != FR_COMMAND_BUFFER_ONE) 
        return FALSE;

    // Unlock the memory.
    GlobalUnlock(hDataIn);

    // Check for any data.
   	if( pDataIo->ulDataSize == 0 )  
	{
        EH_ASSERT(!GlobalFree(hDataIn));
        hDataIn = NULL;
    }

    // Send the data to the message pump.
    // NOTE THAT THE MEMORY MUST FREED BY THE PROCESSING FUNCTION.

    // If we use DataIo with a console application, then we cannot use the WNT
    // PostMessage() routine as there is No window to post the message to, so
    // we will use a locally created PostMessageConsole() routine instead.
    m_pVolOwner->PostMessageLocal(NULL, WM_COMMAND, wpPostCommand, (LPARAM)hDataIn);

    return S_OK;
}

STDMETHODIMP EsiVolumeClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void** ppv)
{
    LPUNKNOWN punk;
    HRESULT hr;

    *ppv = NULL;

    // Check for aggregation - we don't support it..
    if ( punkOuter != NULL )
        return CLASS_E_NOAGGREGATION;

	//
	// Create the volume data object.
	//
    punk = new EsiVolumeDataObject( m_pVolOwner );

    // If we didn't get a pointer then we are out of memory.
    if (punk == NULL) 
        return E_OUTOFMEMORY;

    // Get a pointer to the ESI Data Object interface.
    hr = punk->QueryInterface(riid, ppv);

    if (SUCCEEDED(hr) && (*ppv)) {

        if (m_pVolOwner->m_pIDataObject) {
            CoDisconnectObject((LPUNKNOWN)m_pVolOwner->m_pIDataObject, 0);
            m_pVolOwner->m_pIDataObject->Release();
            m_pVolOwner->m_pIDataObject = NULL;
        }    

        m_pVolOwner->m_pIDataObject = (IDataObject *)*ppv;
        m_pVolOwner->m_pIDataObject->AddRef();
    }

    // Release the pointer to the ESI Data Object.
    punk->Release();

    return hr;
}

//
// Initialize the server side communication only for volumes.
// Warning! The class will nuke the class factory in the destructor.
// Make sure the client has achieved communication before this
// function goes out of scope.
//
const BOOL CVolume::InitializeDataIo( DWORD dwRegCls )
{
    HRESULT hr;
	BOOL fSuccess = FALSE;

	//
	// Don't do this again if we've already created and
	// registered a factory.
	//
	if ( m_pFactory == NULL )
	{
		//
		// Allocate the factory.
		//
		m_pFactory = new EsiVolumeClassFactory( this );
		if ( m_pFactory )
		{
			// Register the class-object with OLE.
			hr = CoRegisterClassObject( m_VolumeID,
									   m_pFactory,
									   CLSCTX_SERVER,
									   dwRegCls, 
									   &m_dwRegister );
			if ( SUCCEEDED( hr ) )
				fSuccess = TRUE;
		}
	}
	else
	{
		//
		// Since we're already started, go ahead and indicate
		// success.
		//
		fSuccess = TRUE;
	}

    return( fSuccess );
}

//
// Generate a random guid for communication purposes.
//
BOOL CVolume::InitVolumeID()
{
	BOOL fSuccess = FALSE;

	if ( SUCCEEDED( CoCreateGuid( &m_VolumeID ) ) )
		fSuccess = TRUE;

	return( fSuccess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\atlsnap.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATL_SNAPIN_H__
#define __ATL_SNAPIN_H__
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include <mmc.h>
#include <commctrl.h>
#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")

template <class T, bool bAutoDelete = true>
class ATL_NO_VTABLE CSnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CSnapInPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CSnapInPropertyPageImpl< T, bAutoDelete > thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}
};

#if _ATL_VER < 0x0300
// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_nSize > 0)
		{
			free(m_aKey);
			free(m_aVal);
			m_aKey = NULL;
			m_aVal = NULL;
			m_nSize = 0;
		}
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aKey[nIndex] = key;
		m_aVal[nIndex] = val;
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};
#endif


class CSnapInItem;
class CSnapInObjectRootBase;

class CObjectData
{
public:
	CSnapInItem* m_pItem;
	DATA_OBJECT_TYPES m_type;
};

class ATL_NO_VTABLE CSnapInItem 
{
public:
	virtual ~CSnapInItem()
	{
	}
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM  *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultViewType)(LPOLESTR  *ppViewType,
        long  *pViewOptions) = 0;
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM  *pResultDataItem) = 0;
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long  *pInsertionAllowed,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(Command)(long lCommandID,		
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        long handle,
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(SetControlbar)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap) = 0;
    
    STDMETHOD(ControlbarNotify)(IControlbar  *pControlbar,
        IExtendControlbar  *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type) = 0;
    
    STDMETHOD(GetScopeData)(SCOPEDATAITEM  * *pScopeDataItem) = 0;
    
    STDMETHOD(GetResultData)(RESULTDATAITEM  * *pResultDataItem) = 0;

	STDMETHOD(FillData)(CLIPFORMAT cf, 
		LPSTREAM pStream) = 0;

	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		_ASSERTE(0 && "Override this function in derived class");
	}

	static HRESULT GetDataClass(IDataObject* pDataObj, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		if (ppItem == NULL)
			return E_POINTER;
		if (pType == NULL)
			return E_POINTER;

		if (IS_SPECIAL_DATAOBJECT(pDataObj))
			return E_NOTIMPL;

		*ppItem = NULL;
		*pType = CCT_UNINITIALIZED;

		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
		FORMATETC formatetc = { m_CCF_SNAPIN_GETOBJECTDATA, 
			NULL, 
			DVASPECT_CONTENT, 
			-1, 
			TYMED_HGLOBAL 
		};

		stgmedium.hGlobal = GlobalAlloc(0, sizeof(CObjectData));
		if (stgmedium.hGlobal == NULL)
			return E_OUTOFMEMORY;

		HRESULT hr = pDataObj->GetDataHere(&formatetc, &stgmedium);
		if (SUCCEEDED(hr))
		{
			CObjectData* pData = (CObjectData*)stgmedium.hGlobal;
			 *ppItem = pData->m_pItem;
			 *pType = pData->m_type;
		}
		
		GlobalFree(stgmedium.hGlobal);
		
		return hr;
	}


	virtual HRESULT STDMETHODCALLTYPE GetDataObject(IDataObject** pDataObj, DATA_OBJECT_TYPES type) = 0;

	static void Init()
	{
		m_CCF_NODETYPE			= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_NODETYPE"));
		m_CCF_SZNODETYPE		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SZNODETYPE"));  
		m_CCF_DISPLAY_NAME		= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_DISPLAY_NAME")); 
		m_CCF_SNAPIN_CLASSID	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_SNAPIN_CLASSID"));
		m_CCF_SNAPIN_GETOBJECTDATA	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_GETOBJECTDATA"));
		m_CCF_MMC_MULTISELECT_DATAOBJECT	= (CLIPFORMAT) RegisterClipboardFormat(_T("CCF_MMC_MULTISELECT_DATAOBJECT"));
	}
public:
	static CLIPFORMAT m_CCF_NODETYPE;
	static CLIPFORMAT m_CCF_SZNODETYPE;
	static CLIPFORMAT m_CCF_DISPLAY_NAME;
	static CLIPFORMAT m_CCF_SNAPIN_CLASSID;
	static CLIPFORMAT m_CCF_SNAPIN_GETOBJECTDATA;
	static CLIPFORMAT m_CCF_MMC_MULTISELECT_DATAOBJECT;
};

class CSnapInObjectRootBase
{
public:
	CComPtr <IControlbar> m_spControlbar;
	CSimpleMap <UINT, IUnknown*> m_toolbarMap;
	const int m_nType;

	CSnapInObjectRootBase(int n = 0) : m_nType(n)
	{
	}
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType)
	{
		return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
	}
};

template <int n, class ComponentData>
class CSnapInObjectRoot : public CSnapInObjectRootBase
{
public :
	CSnapInObjectRoot() : CSnapInObjectRootBase(n)
	{
		m_pComponentData = NULL;
	}
	ComponentData* m_pComponentData;
};

#define EXTENSION_SNAPIN_DATACLASS(dataClass) dataClass m_##dataClass;

#define BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(classname) \
	HRESULT GetDataClass(IDataObject* pDataObject, CSnapInItem** ppItem, DATA_OBJECT_TYPES* pType) \
	{ \
		if (ppItem == NULL) \
			return E_POINTER; \
		if (pType == NULL) \
			return E_POINTER; \
\
		*ppItem = NULL; \
\
		*pType = CCT_UNINITIALIZED; \
\
		STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL }; \
		FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, \
			NULL, \
			DVASPECT_CONTENT, \
			-1, \
			TYMED_HGLOBAL \
		}; \
\
		stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID)); \
		if (stgmedium.hGlobal == NULL) \
			return E_OUTOFMEMORY; \
\
		HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium); \
		if (FAILED(hr)) \
		{ \
			GlobalFree(stgmedium.hGlobal); \
			return hr; \
		} \
\
		GUID guid; \
		memcpy(&guid, stgmedium.hGlobal, sizeof(GUID)); \
\
		GlobalFree(stgmedium.hGlobal); \
		hr = S_OK;

#define EXTENSION_SNAPIN_NODEINFO_ENTRY(dataClass) \
		if (IsEqualGUID(guid, *(GUID*)m_##dataClass.GetNodeType())) \
		{ \
			*ppItem = m_##dataClass.GetExtNodeObject(pDataObject, &m_##dataClass); \
			_ASSERTE(*ppItem != NULL); \
			(*ppItem)->InitDataClass(pDataObject, &m_##dataClass); \
			return hr; \
		}

#define END_EXTENSION_SNAPIN_NODEINFO_MAP() \
			return CSnapInItem::GetDataClass(pDataObject, ppItem, pType); \
	};

class ATL_NO_VTABLE CSnapInDataObjectImpl : public IDataObject,
	public CComObjectRoot
{
public:
	BEGIN_COM_MAP(CSnapInDataObjectImpl)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetData\n"));
	}

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium)
	{
		ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
		if (pmedium == NULL)
			return E_POINTER;

		HRESULT hr = DV_E_TYMED;
		// Make sure the type medium is HGLOBAL
		if (pmedium->tymed == TYMED_HGLOBAL)
		{
			// Create the stream on the hGlobal passed in
			CComPtr<IStream> spStream;
			hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
			if (SUCCEEDED(hr))
				if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
				{
					hr = DV_E_CLIPFORMAT;
					ULONG uWritten;
					hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
				}
				else
					hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
		}
		return hr;
	}

	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::QueryGetData\n"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
	}

	CObjectData m_objectData;
};


template <class T, class Component>
class ATL_NO_VTABLE IComponentDataImpl : public IComponentData 
{
public :
	IComponentDataImpl()
	{
		m_pNode = NULL;
	}

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown)
	{
		ATLTRACE(_T("IComponentDataImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(pUnknown != NULL);
		if (pUnknown == NULL)
			ATLTRACE(_T("IComponentData::Initialize called with pUnknown == NULL\n"));
		else
		{
			hr = pUnknown->QueryInterface(IID_IConsole, (void**)&m_spConsole);
			if (FAILED(hr))
				ATLTRACE(_T("QI for IConsole failed\n"));
		}

		return hr;
	}

	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent)
	{
		ATLTRACE(_T("IComponentDataImpl::CreateComponent\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(ppComponent != NULL);
		if (ppComponent == NULL)
			ATLTRACE(_T("IComponentData::CreateComponent called with ppComponent == NULL\n"));
		else
		{
			*ppComponent = NULL;
			
			CComObject< Component >* pComponent;
			hr = CComObject< Component >::CreateInstance(&pComponent);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				ATLTRACE(_T("IComponentData::CreateComponent : Could not create IComponent object\n"));
			else
			{
				pComponent->m_pComponentData = static_cast<T*>(this);
				hr = pComponent->QueryInterface(IID_IComponent, (void**)ppComponent);
			}
		}
		return hr;
	}

    
    STDMETHOD(Notify)( 
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param)
	{
		ATLTRACE(_T("IComponentDataImpl::Notify\n"));
		ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
		HRESULT hr = E_POINTER;

		ATLASSERT(lpDataObject != NULL);
		if (lpDataObject == NULL)
			ATLTRACE(_T("IComponentData::Notify called with lpDataObject == NULL\n"));
		else
		{
			T* pT = static_cast<T*>(this);
			CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
			hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
			ATLASSERT(SUCCEEDED(hr));
			if (SUCCEEDED(hr))
				hr = pItem->Notify(event, arg, param, pT, NULL, type);
		}
		return hr;
	}

    STDMETHOD(Destroy)(void)
	{
		ATLTRACE(_T("IComponentDataImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);
		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole.Release();
		return S_OK;
	}

    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentDataImpl::QueryDataObject\n"));
		HRESULT hr = E_POINTER;
		
		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
			ATLTRACE(_T("IComponentData::QueryDataObject called with ppDataObject == NULL\n"));
		else
		{
			*ppDataObject = NULL;
			
			CSnapInItem* pItem = (CSnapInItem*) cookie;
			if (cookie == NULL)
				pItem = m_pNode;

			hr = pItem->GetDataObject(ppDataObject, type);
		}
		return hr;
	}
    
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACE(_T("IComponentDataImpl::GetDisplayInfo\n"));


		HRESULT hr = E_POINTER;
		
		ATLASSERT(pScopeDataItem != NULL);
		if (pScopeDataItem == NULL)
			ATLTRACE(_T("IComponentData::GetDisplayInfo called with pScopeDataItem == NULL\n"));
		else
		{
			CSnapInItem* pItem= (CSnapInItem*) pScopeDataItem->lParam;
			if (pItem == NULL)
				pItem = m_pNode;

			hr = E_UNEXPECTED;
			if (pItem != NULL)
				hr = pItem->GetScopePaneInfo(pScopeDataItem);
		}
		return hr;
	}
    
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentDataImpl::CompareObjects\n"));
    }

	CComPtr<IConsole> m_spConsole;
	CSnapInItem* m_pNode;
};


template <class T>
class ATL_NO_VTABLE IComponentImpl : public IComponent
{
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole)
	{
		ATLTRACE(_T("IComponentImpl::Initialize\n"));

		HRESULT hr = E_POINTER;

		ATLASSERT(lpConsole != NULL);
		if (lpConsole == NULL)
			ATLTRACE(_T("lpConsole is NULL\n"));
		else
		{
			m_spConsole = lpConsole;
	
			CComPtr<IHeaderCtrl> spHeaderCtrl;
			hr = m_spConsole->QueryInterface(IID_IHeaderCtrl, (void**)&spHeaderCtrl);
			if (FAILED(hr))
				ATLTRACE(_T("QI for IHeaderCtrl failed\n"));
			else
			{
				hr = m_spConsole->SetHeader(spHeaderCtrl);
				if (FAILED(hr))
					ATLTRACE(_T("IConsole::SetHeader failed (HRESULT = %x)\n"), hr);
			}
		}
		return hr;
	}
    
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);
    
    STDMETHOD(Destroy)(MMC_COOKIE cookie)
	{
		ATLTRACE(_T("IComponentImpl::Destroy\n"));

		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		m_spConsole->SetHeader(NULL);
		m_spConsole.Release();
		return S_OK;
	}
    
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT  *ppDataObject)
	{
		ATLTRACE(_T("IComponentImpl::QueryDataObject\n"));

		ATLASSERT(ppDataObject != NULL);
		if (ppDataObject == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with ppDataObject==NULL \n"));
			return E_POINTER;
		}
		
		if (cookie == NULL)
		{
			ATLTRACE(_T("IComponent::QueryDataObject called with cookie==NULL \n"));
			return E_UNEXPECTED;
		}

		*ppDataObject = NULL;
		if (cookie == MMC_MULTI_SELECT_COOKIE)
		{
			ATLTRACE(_T("Override QueryDataObject to handle multiselect\n"));
			return E_UNEXPECTED;
		}

		CSnapInItem* pItem = (CSnapInItem*) cookie;
		return pItem->GetDataObject(ppDataObject, type);
	}
    
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,
        LPOLESTR  *ppViewType,
        long  *pViewOptions);
    
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACE(_T("IComponentImpl::GetDisplayInfo\n"));

		ATLASSERT(pResultDataItem != NULL);
		if (pResultDataItem == NULL)
		{
			ATLTRACE(_T("IComponent::GetDisplayInfo called with pResultDataItem==NULL\n"));
			return E_POINTER;
		}

		CSnapInItem* pItem = (CSnapInItem*) pResultDataItem->lParam;

		if (pItem == NULL)
		{
			ATLTRACE(_T("Invalid Item\n"));
			return E_UNEXPECTED;
		}
		return pItem->GetResultPaneInfo(pResultDataItem);
	}
    
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB)
	{
		ATLTRACENOTIMPL(_T("IComponentImpl::CompareObjects\n"));
	}

	CComPtr<IConsole> m_spConsole;
};

template <class T>
HRESULT IComponentImpl<T>::Notify(LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
	ATLTRACE(_T("IComponentImpl::Notify\n"));
	ATLASSERT(lpDataObject != NULL && _T("Override Notify in derived class handle notifications for which lpDataObject == NULL"));		
	HRESULT hr = E_POINTER;

	if (lpDataObject == NULL)
		ATLTRACE(_T("IComponent::Notify called with lpDataObject==NULL \n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		// Make sure that the object is derived from CSnapInObjectRoot
		hr = pT->m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);
		if (SUCCEEDED(hr))
			hr = pItem->Notify(event, arg, param, NULL, pT, type);
	}
	return hr;
}

template <class T>
HRESULT IComponentImpl<T>::GetResultViewType(MMC_COOKIE cookie,
    LPOLESTR  *ppViewType,
    long  *pViewOptions)
{
	ATLTRACE(_T("IComponentImpl::GetResultViewType\n"));

	HRESULT hr = E_FAIL;
	if (cookie == NULL)
	{
		T* pT = static_cast<T*> (this);
		ATLASSERT( pT->m_pComponentData != NULL );
		ATLASSERT( pT->m_pComponentData->m_pNode != NULL );
		hr = pT->m_pComponentData->m_pNode->GetResultViewType(ppViewType, pViewOptions);
	}
	else
	{
		CSnapInItem* pItem = (CSnapInItem*)cookie;
		hr = pItem->GetResultViewType(ppViewType, pViewOptions);
	}
	return hr;
}

template <class T, class D>        
class ATL_NO_VTABLE IResultDataCompareImpl : public IResultDataCompare
{
public:
    STDMETHOD(Compare)(long lUserParam,
        MMC_COOKIE cookieA,
        MMC_COOKIE cookieB,
        int *pnResult)
	{
		ATLTRACENOTIMPL(_T("IResultDataCompareImpl::Compare"));
	}
};


template <class T>
class ATL_NO_VTABLE IExtendContextMenuImpl : public IExtendContextMenu
{
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed);
	
    STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject);
};

template <class T>
inline HRESULT IExtendContextMenuImpl<T>::AddMenuItems(LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long *pInsertionAllowed)
{
	ATLTRACE(_T("IExtendContextMenuImpl::AddMenuItems\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
	}
	return hr;
}

template <class T>
inline HRESULT IExtendContextMenuImpl<T>::Command(long lCommandID,
    LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendContextMenuImpl::Command\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
		
		if (SUCCEEDED(hr))
			hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)pT, type);
	}
	return hr;
}

template<class T>
class ATL_NO_VTABLE IExtendPropertySheetImpl : public IExtendPropertySheet
{
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        long handle,
        LPDATAOBJECT pDataObject);
    
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);
};

template<class T>
inline HRESULT IExtendPropertySheetImpl<T>::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    long handle,
    LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendPropertySheetImpl::CreatePropertyPages called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->CreatePropertyPages(lpProvider, handle, this, type);
	}

	return hr;
}

template <class T>
inline HRESULT IExtendPropertySheetImpl<T>::QueryPagesFor(LPDATAOBJECT pDataObject)
{
	ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor\n"));
	

	HRESULT hr = E_POINTER;
	
	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE(_T("IExtendPropertySheetImpl::QueryPagesFor called with pDataObject==NULL\n"));
	else
	{
		T* pT = static_cast<T*>(this);
		CSnapInItem* pItem;
		DATA_OBJECT_TYPES type;
		hr = pT->m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

		if (SUCCEEDED(hr))
			hr = pItem->QueryPagesFor(type);
	}
	return hr;
}

template <class T>
class ATL_NO_VTABLE IExtendControlbarImpl : public IExtendControlbar
{
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar)
	{
		ATLTRACE(_T("IExtendControlbarImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		if (pT->m_spControlbar != NULL)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
				 {
					pT->m_spControlbar->Detach(pToolbar);
					pToolbar->Release();
				 }
			}
		}
		pT->m_toolbarMap.RemoveAll();

		pT->m_spControlbar = pControlbar;
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param);
};

template <class T>
inline HRESULT IExtendControlbarImpl<T>::ControlbarNotify(MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
	ATLTRACE(_T("IExtendControlbarImpl::ControlbarNotify\n"));

	CSnapInItem* pItem = NULL;
	DATA_OBJECT_TYPES type;
	HRESULT hr = S_OK;
	T* pT = static_cast<T*>(this);

	if (event == MMCN_BTN_CLICK)
		hr = pT->m_pComponentData->GetDataClass((IDataObject*) arg, &pItem, &type);
	else if (event == MMCN_SELECT)
	{
		hr = pT->m_pComponentData->GetDataClass((IDataObject*) param, &pItem, &type);
		BOOL bSelect = (BOOL) HIWORD (arg);
		BOOL bScope = (BOOL) LOWORD(arg); 
		if (bSelect)
		{
			int n = pT->m_toolbarMap.GetSize();
			for (int i = 0; i < n; i++)
			{
				IToolbar* pToolbar = (IToolbar*)pT->m_toolbarMap.GetValueAt(i);
				 if (pToolbar != NULL)
					pT->m_spControlbar->Detach(pToolbar);
			}
		}
	}

	if (SUCCEEDED(hr))
		hr = pItem->ControlbarNotify(pT->m_spControlbar, this, &(pT->m_toolbarMap), event, arg, param, (CSnapInObjectRootBase*) pT, type);

	return hr;
}
#define SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define EXT_SNAPINMENUID(id) \
public: \
	static const UINT GetMenuID() \
	{ \
		static const UINT IDMENU = id; \
		return id; \
	}

#define BEGIN_SNAPINCOMMAND_MAP(theClass, bIsExtension) \
	HRESULT ProcessCommand(UINT nID, \
		bool& bHandled, \
		CSnapInObjectRootBase* pObj, \
		DATA_OBJECT_TYPES type) \
	{ \
			bHandled = true; \
			HRESULT hr = S_OK;

#define SNAPINCOMMAND_ENTRY(id, func) \
		if (id == nID) \
		{ \
			hr = func(bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define SNAPINCOMMAND_RANGE_ENTRY(id1, id2, func) \
		if (id1 >= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

#define CHAIN_SNAPINCOMMAND_MAP(theChainClass) \
	{ \
		hr = theChainClass::ProcessCommand(nID, bHandled, pObj, type); \
		if (bHandled) \
			return hr; \
	}

#define END_SNAPINCOMMAND_MAP() \
			return hr; \
	}

struct CSnapInToolBarData
{
	WORD wVersion;
	WORD wWidth;
	WORD wHeight;
	WORD wItemCount;
	//WORD aItems[wItemCount]

	WORD* items()
		{ return (WORD*)(this+1); }
};

#define RT_TOOLBAR  MAKEINTRESOURCE(241)
	
class CSnapInToolbarInfo
{
public:
	~CSnapInToolbarInfo()
	{
		CleanUp();
	}

	HRESULT CleanUp()
	{
		if (m_pStrToolTip)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrToolTip[i];
				m_pStrToolTip[i] = NULL;
			}
			delete [] m_pStrToolTip;
			m_pStrToolTip = NULL;
		}

		if (m_pStrButtonText)
		{
			for (UINT i = 0; i < m_nButtonCount; i++)
			{
				delete m_pStrButtonText[i];
				m_pStrButtonText[i] = NULL;
			}

			delete [] m_pStrButtonText;
			m_pStrButtonText = NULL;
		}
		if (m_pnButtonID)
		{
			delete m_pnButtonID;
			m_pnButtonID = NULL;
		}

		m_nButtonCount = 0;
		return S_OK;
	}

	OLECHAR** m_pStrToolTip;
	OLECHAR** m_pStrButtonText;
	UINT* m_pnButtonID;
	UINT m_idToolbar;
	UINT m_nButtonCount;
};

#define BEGIN_SNAPINTOOLBARID_MAP(theClass) \
public: \
	static CSnapInToolbarInfo* GetToolbarInfo() \
	{ \
		static CSnapInToolbarInfo m_toolbarInfo[] = \
		{

#define SNAPINTOOLBARID_ENTRY(id) \
			{ NULL, NULL, NULL, id, 0},

#define END_SNAPINTOOLBARID_MAP() \
			{ NULL, NULL, NULL, 0, 0} \
		}; \
		return m_toolbarInfo; \
	}	

template <class T, BOOL bIsExtension = FALSE>
class ATL_NO_VTABLE CSnapInItemImpl : public CSnapInItem
{
public:
	CSnapInItemImpl()
	{
	}

	virtual ~CSnapInItemImpl()
	{
	}    

public:

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::Notify"));
	}
    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetScopePaneInfo"));
	}
    
    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
        long *pViewOptions)
	{
		ATLTRACE(_T("CSnapInItemImpl::GetResultViewType\n"));
		*ppViewType = NULL;
		*pViewOptions = MMC_VIEW_OPTIONS_NONE;
		return S_FALSE;
	}
    
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
	{
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::GetResultPaneInfo"));
	}
    
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
        long *pInsertionAllowed,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::AddMenuItems\n"));
		T* pT = static_cast<T*>(this);

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		UINT menuID = pT->GetMenuID();
		if (menuID == 0)
			return S_OK;

		HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
		long insertionID;
		if (hMenu)
		{
			for (int i = 0; 1; i++)
			{
				HMENU hSubMenu = GetSubMenu(hMenu, i);
				if (hSubMenu == NULL)
					break;
				
				MENUITEMINFO menuItemInfo;
				memset(&menuItemInfo, 0, sizeof(menuItemInfo));
				menuItemInfo.cbSize = sizeof(menuItemInfo);

				switch (i)
				{
				case 0:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
					break;

				case 1:
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
					break;

				case 2:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
						continue;
					if (bIsExtension)
						insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
					else
						insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
					break;
				case 3:;
					if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
						continue;
					insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
					break;
				default:
					{
						insertionID = 0;
						continue;
					}
					break;
				}

				menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
				menuItemInfo.fType = MFT_STRING;
				TCHAR szMenuText[128];

				for (int j = 0; 1; j++)
				{
					menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
					menuItemInfo.fType = MFT_STRING;
					menuItemInfo.cch = 128;
					menuItemInfo.dwTypeData = szMenuText;
					TCHAR szStatusBar[256];

					if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
						break;
					if (menuItemInfo.fType != MFT_STRING)
						continue;

					pT->UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
					LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

					OLECHAR wszStatusBar[256];
					OLECHAR wszMenuText[128];
					USES_CONVERSION;
					ocscpy(wszMenuText, T2OLE(szMenuText));
					ocscpy(wszStatusBar, T2OLE(szStatusBar));

					CONTEXTMENUITEM contextMenuItem;
					contextMenuItem.strName = wszMenuText;
					contextMenuItem.strStatusBarText = wszStatusBar;
					contextMenuItem.lCommandID = menuItemInfo.wID;
					contextMenuItem.lInsertionPointID = insertionID;
					contextMenuItem.fFlags = menuItemInfo.fState;
					contextMenuItem.fSpecialFlags = 0;
					
					HRESULT hr = piCallback->AddItem(&contextMenuItem);
					ATLASSERT(SUCCEEDED(hr));
				}
			}
			DestroyMenu(hMenu);
		}

		if (!bIsExtension)
			pT->SetMenuInsertionFlags(true, pInsertionAllowed);

		return S_OK;
	}
    
    STDMETHOD(Command)(long lCommandID,		
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::Command\n"));
		bool bHandled;
		T* pT = static_cast<T*>(this);
		return pT->ProcessCommand(lCommandID, bHandled, pObj, type);
	}
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
        long handle, 
		IUnknown* pUnk,
		DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::CreatePropertyPages"));
	}
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		ATLASSERT("Override Function in Derived Class");
		ATLTRACENOTIMPL(_T("CSnapInItemImpl::QueryPagesFor"));
	}

    STDMETHOD(SetControlbar)(IControlbar *pControlbar, 
		IExtendControlbar* pExtendControlBar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap)
	{
		ATLTRACE(_T("CSnapInItemImpl::SetControlbar\n"));
		T* pT = static_cast<T*>(this);

		CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
		if (pInfo == NULL)
			return S_OK;

		for( ; pInfo->m_idToolbar; pInfo++)
		{
			IToolbar* p = (IToolbar*) pToolbarMap->Lookup(pInfo->m_idToolbar);
			if (p != NULL)
				continue;

			HBITMAP hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar));
			if (hBitmap == NULL)
				return S_OK;

			HRSRC hRsrc = ::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE(pInfo->m_idToolbar), RT_TOOLBAR);
			if (hRsrc == NULL)
				return S_OK;

			HGLOBAL hGlobal = LoadResource(_Module.GetResourceInstance(), hRsrc);
			if (hGlobal == NULL)
				return S_OK;

			CSnapInToolBarData* pData = (CSnapInToolBarData*)LockResource(hGlobal);
			if (pData == NULL)
				return S_OK;
			ATLASSERT(pData->wVersion == 1);
			ATLASSERT(pData->wWidth == 16);
			ATLASSERT(pData->wHeight == 16);

			pInfo->m_nButtonCount = pData->wItemCount;
			if (pInfo->m_pnButtonID == NULL)
				pInfo->m_pnButtonID = new UINT[pInfo->m_nButtonCount];

			if (pInfo->m_pnButtonID == NULL)
				continue;

			MMCBUTTON *pButtons = new MMCBUTTON[pData->wItemCount];
			if (pButtons == NULL)
			{
				delete []pInfo->m_pnButtonID;
				continue;
			}
			
			if (pInfo->m_pStrToolTip == NULL)
			{
				pInfo->m_pStrToolTip = new OLECHAR* [pData->wItemCount];
				if (pInfo->m_pStrToolTip)
					memset(pInfo->m_pStrToolTip, 0, sizeof(OLECHAR*) * pData->wItemCount);
			}

			if (pInfo->m_pStrToolTip == NULL)
			{
				delete []pInfo->m_pnButtonID;
				delete []pButtons;
				continue;
			}


			for (int i = 0, j = 0; i < pData->wItemCount; i++)
			{
				pInfo->m_pnButtonID[i] = pButtons[i].idCommand = pData->items()[i];
				if (pButtons[i].idCommand)
				{
					pButtons[i].nBitmap = j++;
					// get the statusbar string and allow modification of the button state
					TCHAR szStatusBar[512];
					LoadString(_Module.GetResourceInstance(), pButtons[i].idCommand, szStatusBar, 512);

					if (pInfo->m_pStrToolTip[i] == NULL)
						pInfo->m_pStrToolTip[i] = new OLECHAR[lstrlen(szStatusBar) + 1];
					if (pInfo->m_pStrToolTip[i] == NULL)
						continue;
					USES_CONVERSION;
					ocscpy(pInfo->m_pStrToolTip[i], T2OLE(szStatusBar));
					pButtons[i].lpTooltipText = pInfo->m_pStrToolTip[i];
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsState = TBSTATE_ENABLED;
					pButtons[i].fsType = TBSTYLE_BUTTON;
					pT->SetToolbarButtonInfo(pButtons[i].idCommand, &pButtons[i].fsState, &pButtons[i].fsType);
				}
				else
				{
					pButtons[i].lpTooltipText = OLESTR("");
					pButtons[i].lpButtonText = OLESTR("");
					pButtons[i].fsType = TBSTYLE_SEP;
					pButtons[i].fsState = 0;
				}
			}

			IToolbar* pToolbar;
	        HRESULT hr = pControlbar->Create(TOOLBAR, pExtendControlBar, reinterpret_cast<LPUNKNOWN*>(&pToolbar));
			if (SUCCEEDED(hr))
			{

				hr = pToolbar->AddBitmap(pData->wItemCount, hBitmap, pData->wWidth, pData->wHeight, RGB(192, 192, 192));
				if (SUCCEEDED(hr))
				{
					hr = pToolbar->AddButtons(pData->wItemCount, pButtons);
					if (SUCCEEDED(hr))
					{
						pToolbar->AddRef();
						pToolbarMap->Add(pInfo->m_idToolbar, (IUnknown*)pToolbar);
					}
				}
			}
			pToolbar->Release();
			delete [] pButtons;
		}
		return S_OK;
	}
    
    STDMETHOD(ControlbarNotify)(IControlbar *pControlbar,
        IExtendControlbar *pExtendControlbar,
		CSimpleMap<UINT, IUnknown*>* pToolbarMap,
		MMC_NOTIFY_TYPE event,
        LPARAM arg, 
		LPARAM param,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("CSnapInItemImpl::ControlbarNotify\n"));
		T* pT = static_cast<T*>(this);

		SetControlbar(pControlbar, pExtendControlbar, pToolbarMap);

		if(event == MMCN_SELECT)
		{
			if (pControlbar == NULL)
				return S_OK;

			BOOL bSelect = (BOOL) HIWORD (arg);
			if (!bSelect)
				return S_OK;
			BOOL bScope = (BOOL) LOWORD(arg); 

			CSnapInToolbarInfo* pInfo = pT->GetToolbarInfo();
			if (pInfo == NULL)
				return S_OK;

			for(; pInfo->m_idToolbar; pInfo++)
			{
				IToolbar* pToolbar = (IToolbar*)pToolbarMap->Lookup(pInfo->m_idToolbar);
				if (pToolbar == NULL)
					continue;

				pControlbar->Attach(TOOLBAR, pToolbar);
				for (UINT i = 0; i < pInfo->m_nButtonCount; i++)
				{
					if (pInfo->m_pnButtonID[i])
					{
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							ENABLED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								ENABLED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							CHECKED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								CHECKED));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							HIDDEN,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								HIDDEN));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							INDETERMINATE,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								INDETERMINATE));
						pToolbar->SetButtonState(pInfo->m_pnButtonID[i], 
							BUTTONPRESSED,
							pT->UpdateToolbarButton(pInfo->m_pnButtonID[i], 
								BUTTONPRESSED));
					}
				}
			}
			return S_OK;
		}
		else if (event == MMCN_BTN_CLICK)
		{
			bool bHandled;
			return pT->ProcessCommand((UINT) param, bHandled, pObj, type);
		}

		return E_UNEXPECTED;
	}

	STDMETHOD(GetScopeData)(SCOPEDATAITEM **pScopeDataItem)
	{
		if (pScopeDataItem == NULL)
			return E_FAIL;

		*pScopeDataItem = &m_scopeDataItem;
		return S_OK;
	}
        
    STDMETHOD(GetResultData)(RESULTDATAITEM **pResultDataItem)
	{
		if (pResultDataItem == NULL)
			return E_FAIL;

		*pResultDataItem = &m_resultDataItem;
		return S_OK;
	}

	STDMETHOD(GetDataObject)(IDataObject** pDataObj, DATA_OBJECT_TYPES type)
	{
		CComObject<CSnapInDataObjectImpl>* pData;
		HRESULT hr = CComObject<CSnapInDataObjectImpl>::CreateInstance(&pData);
		if (FAILED(hr))
			return hr;

		T* pT = static_cast<T*> (this);
		pData->m_objectData.m_pItem = pT;
		pData->m_objectData.m_type = type;

		hr = pData->QueryInterface(IID_IDataObject, (void**)(pDataObj));
		return hr;
	}

	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
	{
		return;
	}

	void SetToolbarButtonInfo(UINT id, BYTE *pfsState, BYTE *pfsType)
	{
		*pfsState = TBSTATE_ENABLED;
		*pfsType = TBSTYLE_BUTTON;
	}

	BOOL UpdateToolbarButton(UINT id, BYTE fsState)
	{
		if (fsState == ENABLED)
			return TRUE;
		return FALSE;
	}

	HRESULT ProcessCommand(UINT nID, 
		bool& bHandled,
		CSnapInObjectRootBase* pObj,
		DATA_OBJECT_TYPES type)
	{
		ATLTRACE(_T("No handler for item with ID %d\n"), nID);
		return S_OK;
	}

	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;
		ULONG uWritten;

		T* pT = static_cast<T*> (this);

		if (cf == m_CCF_NODETYPE)
		{
			hr = pStream->Write(pT->GetNodeType(), sizeof(GUID), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SZNODETYPE)
		{
			hr = pStream->Write(pT->GetSZNodeType(), (ocslen((OLECHAR*)pT->GetSZNodeType()) + 1 )* sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_DISPLAY_NAME)
		{
			hr = pStream->Write(pT->GetDisplayName(), (ocslen((OLECHAR*)pT->GetDisplayName()) + 1) * sizeof(OLECHAR), &uWritten);
			return hr;
		}

		if (cf == m_CCF_SNAPIN_CLASSID)
		{
			hr = pStream->Write(pT->GetSnapInCLSID(), sizeof(GUID), &uWritten);
			return hr;
		}

		return hr;
	}

	static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return NULL;
	}

	static const UINT GetMenuID() 
	{
		return 0;
	}

	void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed)
	{
	}

	void* GetNodeType()
	{
		return (void*)T::m_NODETYPE;
	}
	void* GetSZNodeType()
	{
		return (void*)T::m_SZNODETYPE;
	}

	void* GetDisplayName()
	{
		return (void*)T::m_SZDISPLAY_NAME;
	}

	void* GetSnapInCLSID()
	{
		return (void*)T::m_SNAPIN_CLASSID;
	}

	CComBSTR m_bstrDisplayName;
	SCOPEDATAITEM m_scopeDataItem;
	RESULTDATAITEM m_resultDataItem;
};


_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_NODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SZNODETYPE = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_DISPLAY_NAME = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_CLASSID = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA = 0;
_declspec( selectany ) CLIPFORMAT CSnapInItem::m_CCF_MMC_MULTISELECT_DATAOBJECT = 0;

#endif //__ATL_SNAPIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\bootoptimizefat.h ===
/**************************************************************************************************

FILENAME: BootOptimizeFat.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Boot Optimize.

**************************************************************************************************/
//
// Prototype for NtFsControlFile and data structures
// used in its definition
//
//typedef LONG NTSTATUS;

//
// This is the definition for a VCN/LCN (virtual cluster/logical cluster)
// mapping pair that is returned in the buffer passed to 
// FSCTL_GET_RETRIEVAL_POINTERS
//
typedef struct {
	ULONGLONG			Vcn;
	ULONGLONG			Lcn;
} MAPPING_PAIR, *PMAPPING_PAIR;

//
// This is the definition for the buffer that FSCTL_GET_RETRIEVAL_POINTERS
// returns. It consists of a header followed by mapping pairs
//
typedef struct {
	ULONG				NumberOfPairs;
	ULONGLONG			StartVcn;
	MAPPING_PAIR		Pair[1];
} GET_RETRIEVAL_DESCRIPTOR, *PGET_RETRIEVAL_DESCRIPTOR;



DWORD BootOptimize(
		IN HANDLE hVolumeHandle,
		IN LONGLONG BitmapSize,
		IN LONGLONG BytesPerSector,
		IN LONGLONG TotalClusters,
		IN BOOL IsNtfs, 
		IN ULONGLONG MftZoneStart, 
		IN ULONGLONG MftZoneEnd,
		IN TCHAR tDrive
		);
BOOL LoadOptimizeFileList(
		IN TCHAR* cBootOptimzePath,
		IN BOOL IsNtfs,
		IN TCHAR tDrive,
		IN UINT uNumberofRecords
		);
VOID FreeFileList();
LONGLONG GetSizeInformationAboutFiles();
ULONGLONG GetFileSizeInfo(
		IN HANDLE hBootOptimizeFileHandle
		);

BOOL MoveFilesInOrder(
		IN ULONGLONG lFirstAvailableFreeSpace,
		IN ULONGLONG lEndOfFreeSpace,
		IN HANDLE hBootVolumeHandle
		);
BOOL GetBootOptimizeFileStreams(
		IN HANDLE hBootOptimizeFileHandle,
		IN TCHAR* tBootOptimizeFile,
		IN UINT uNumberofRecords
		);
static PTCHAR ParseStreamName(
		IN PTCHAR StreamName
		);
HANDLE GetFileHandle(
		IN TCHAR* tBootOptimizeFile
		);

BOOL GetRegistryEntires(
		OUT TCHAR cBootOptimzePath[MAX_PATH]
		);
VOID SetRegistryEntires(
		IN LONGLONG lLcnStartLocation,
		IN LONGLONG lLcnEndLocation
		);
BOOL CloseFileHandle(
		IN HANDLE hBootOptimizeFileHandle
		);
BOOL OpenReadBootOptimeFileIntoList(
		IN TCHAR* cBootOptimzePath,
		IN BOOL IsNtfs,
		IN TCHAR tDrive
		);
UINT CountNumberofRecordsinFile(
		IN TCHAR* cBootOptimzePath
		);
BOOL IsAValidFile(
		IN TCHAR pBootOptimizeFileName[MAX_PATH+1],
		IN TCHAR tDrive
		);
VOID SaveErrorInRegistry(
		TCHAR* tComplete,
		TCHAR* tErrorString
		);
LONGLONG GetStartingEndLncLocations(
		IN PTCHAR pRegKey
		);
BOOL CheckDateTimeStampInputFile(
		IN TCHAR cBootOptimzePath[MAX_PATH]
		);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\bootoptimizentfs.h ===
/**************************************************************************************************

FILENAME: BootOptimizeNtfs.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Boot Optimize.

**************************************************************************************************/
//
// Prototype for NtFsControlFile and data structures
// used in its definition
//
#ifndef _BOOTOPTIMIZE_H_
#define _BOOTOPTIMIZE_H_

typedef struct _FILE_LIST_ENTRY *PFILE_LIST_ENTRY;
typedef struct _FREE_SPACE_ENTRY *PFREE_SPACE_ENTRY;

BOOL
InitialiseBootOptimise(
	IN CONST BOOL bIsNtfs
    );


DWORD
ProcessBootOptimise();

BOOL
UpdateInBootOptimiseList(
    IN PFILE_LIST_ENTRY pFileListEntry = NULL
    );

DWORD BootOptimize(
		IN HANDLE hVolumeHandle,
		IN LONGLONG BitmapSize,
		IN LONGLONG BytesPerSector,
		IN LONGLONG TotalClusters,
		IN BOOL IsNtfs, 
		IN ULONGLONG MftZoneStart, 
		IN ULONGLONG MftZoneEnd,
		IN TCHAR tDrive
		);
BOOL LoadOptimizeFileList(
		IN TCHAR* cBootOptimzePath,
		IN BOOL IsNtfs,
		IN TCHAR tDrive,
		IN UINT uNumberofRecords
		);
VOID FreeFileList();
LONGLONG GetSizeInformationAboutFiles();

LONGLONG GetFileSizeInfo(
		IN HANDLE hBootOptimizeFileHandle
		);

BOOL MoveFilesInOrder(
        IN ULONGLONG lMoveFileHere,
        IN ULONGLONG lEndOfFreeSpace,
        IN HANDLE hBootVolumeHandle
        );

BOOL GetBootOptimizeFileStreams(
		IN HANDLE hBootOptimizeFileHandle,
		IN TCHAR* tBootOptimizeFile,
		IN UINT uNumberofRecords
		);
static PTCHAR ParseStreamName(
		IN PTCHAR StreamName
		);
HANDLE GetFileHandle(
		IN LPCTSTR lpFilePath
		);

BOOL GetRegistryEntires(
		OUT TCHAR cBootOptimzePath[MAX_PATH]
		);
VOID SetRegistryEntires(
		IN LONGLONG lLcnStartLocation,
		IN LONGLONG lLcnEndLocation
		);
BOOL CloseFileHandle(
		IN HANDLE hBootOptimizeFileHandle
		);
BOOL OpenReadBootOptimeFileIntoList(
		IN TCHAR* cBootOptimzePath,
		IN BOOL IsNtfs,
		IN TCHAR tDrive
		);
BOOL IsAValidFile(
		IN TCHAR pBootOptimizeFileName[MAX_PATH+1],
		IN TCHAR tDrive
		);
VOID SaveErrorInRegistry(
		TCHAR* tComplete,
		TCHAR* tErrorString
		);
LONGLONG GetStartingEndLncLocations(
		IN PTCHAR pRegKey
		);
BOOL CheckDateTimeStampInputFile(
		IN TCHAR cBootOptimzePath[MAX_PATH]
		);



#endif // #define _BOOTOPTIMIZE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dataio.h ===
#ifndef __DATAIO_H__
#define __DATAIO_H__

/*****************************************************************************************************************

FILENAME: DataIo.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
	Header file for the Data IO.

*****************************************************************************************************************/

//#include <objbase.h>
//#include <initguid.h>

// File Rescue GUIDS

// {912F3920-B440-11d0-90DB-0060975EC077}
DEFINE_GUID(CLSID_EsiUndelNtfs, 0x912f3920, 0xb440, 0x11d0, 0x90, 0xdb, 0x0, 0x60, 0x97, 0x5e, 0xc0, 0x77);

// {E2B090D0-BAA3-11d0-90DE-0060975EC077}
DEFINE_GUID(CLSID_EsiUndeleteUI, 0xe2b090d0, 0xbaa3, 0x11d0, 0x90, 0xde, 0x0, 0x60, 0x97, 0x5e, 0xc0, 0x77);

// {260546E1-E9B4-11d0-910F-0060975EC077}
DEFINE_GUID(CLSID_EsiRescueBin, 0x260546e1, 0xe9b4, 0x11d0, 0x91, 0xf, 0x0, 0x60, 0x97, 0x5e, 0xc0, 0x77);

// {94665C20-C645-11d0-90EE-0060975EC077}
DEFINE_GUID(CLSID_EsiUndelFat, 0x94665c20, 0xc645, 0x11d0, 0x90, 0xee, 0x0, 0x60, 0x97, 0x5e, 0xc0, 0x77);

// {C2BD5645-F09A-11d0-9969-0060975B6ADB}
DEFINE_GUID(CLSID_EsiFrFtrCtl, 0xc2bd5645, 0xf09a, 0x11d0, 0x99, 0x69, 0x0, 0x60, 0x97, 0x5b, 0x6a, 0xdb);

/****************************************************************************************************************/

// DKMS GUIDS

// {AE6EFB51-2FBD-11d1-A1FC-0080C88593A5}
DEFINE_GUID(CLSID_DfrgCtlDataIo, 0xae6efb51, 0x2fbd, 0x11d1, 0xa1, 0xfc, 0x0, 0x80, 0xc8, 0x85, 0x93, 0xa5);

// {80EE4901-33A8-11d1-A213-0080C88593A5}
DEFINE_GUID(CLSID_DfrgNtfs, 0x80ee4901, 0x33a8, 0x11d1, 0xa2, 0x13, 0x0, 0x80, 0xc8, 0x85, 0x93, 0xa5);

// {80EE4902-33A8-11d1-A213-0080C88593A5}
DEFINE_GUID(CLSID_DfrgFat, 0x80ee4902, 0x33a8, 0x11d1, 0xa2, 0x13, 0x0, 0x80, 0xc8, 0x85, 0x93, 0xa5);

/****************************************************************************************************************/

typedef struct {
	WORD dwID;          // ESI data structre ID always = 0x4553 'ES'
	WORD dwType;        // Type of data structure
   	WORD dwVersion;     // Version number
   	WORD dwCompatibilty;// Compatibilty number
    ULONG ulDataSize;   // Data size - zero = no data
    WPARAM wparam;      // LOWORD(wparam) = Command
    TCHAR cData;        // Start of data - NULL = no data
} DATA_IO, *PDATA_IO;

/****************************************************************************************************************/

class CClassFactory : public IClassFactory {

  public:
    // IUnknown
    STDMETHODIMP QueryInterface (REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void)  { return 1; };
    STDMETHODIMP_(ULONG) Release(void) { return 1; }

    // IClassFactory
    STDMETHODIMP CreateInstance (LPUNKNOWN punkOuter, REFIID iid, void **ppv);
    STDMETHODIMP LockServer (BOOL fLock) { return E_FAIL; };
};
/****************************************************************************************************************/

class EsiDataObject : public IDataObject {

 protected:
    FORMATETC m_aFormatEtc[2];

 public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid,void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void) { return InterlockedIncrement(&m_cRef); };
    STDMETHODIMP_(ULONG) Release(void); 

    STDMETHOD(GetData)(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium );
    STDMETHOD(GetDataHere)(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium );
    STDMETHOD(QueryGetData)(LPFORMATETC pformatetc );
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut);
    STDMETHOD(SetData)(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc);
    STDMETHOD(DAdvise)(FORMATETC FAR* pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD FAR* pdwConnection);
    STDMETHOD(DUnadvise)(DWORD dwConnection);
    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA FAR* ppenumAdvise);

    EsiDataObject(void);
    ~EsiDataObject(void);

    HANDLE hDataIn;
    HANDLE hDataOut;

  private:
    LONG m_cRef;
};
/****************************************************************************************************************/

DWORD
InitializeDataIo(
    IN REFCLSID refCLSID,
	DWORD dwRegCls
	);

BOOL
ExitDataIo(
    );

#endif //__DATAIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dataiocl.h ===
/**************************************************************************************************

FILENAME: DataIoCl.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
	Header file for the Data IO.

**************************************************************************************************/

#define ESI_DATA_STRUCTURE      0x4553
#define FR_COMMAND_BUFFER       103
#define FR_COMMAND_BUFFER_ONE   1


BOOL
InitializeDataIoClient(
    IN REFCLSID rclsid,
    IN PTCHAR pMachine,
    IN OUT LPDATAOBJECT* ppstm
	);

BOOL
DataIoClientSetData(
    IN WPARAM wparam,
    IN PTCHAR pData,
    IN DWORD dwDataSize,
    IN LPDATAOBJECT pstm
	);

HGLOBAL
DataIoClientGetData(
    IN LPDATAOBJECT pstm
	);

BOOL
ExitDataIoClient(
    IN LPDATAOBJECT* ppstm
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dasdread.h ===
/**************************************************************************************************

FILENAME: DasdRead.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Direct-disk read routines.

**************************************************************************************************/

//Allocate memory and read sectors directly from disk into that memory.
HANDLE
DasdLoadSectors(
        IN HANDLE		hVolume,
		IN LONGLONG		Sector,
        IN LONGLONG		Sectors,
        IN LONGLONG		BytesPerSector
    );

BOOL
DasdStoreSectors(
	IN HANDLE			hVolume,
    IN LONGLONG	       	Sector,
	IN LONGLONG			Sectors,
	IN LONGLONG			BytesPerSector,
	IN LPBYTE			pBuffer
    );

//Read clusters directly from disk.
BOOL
DasdReadClusters(
        IN HANDLE		hVolume,
		IN LONGLONG		Cluster,
        IN LONGLONG		Clusters,
        IN PVOID		pBuffer,
        IN LONGLONG		BytesPerSector,
        IN LONGLONG		BytesPerCluster
    );

BOOL
DasdWriteClusters(
	IN HANDLE			hVolume,
    IN LONGLONG	       	Cluster,
	IN LONGLONG			Clusters,
	IN PVOID			pBuffer,
	IN LONGLONG			BytesPerSector,
	IN LONGLONG			BytesPerCluster
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\defragcommon.h ===
/**************************************************************************************************

FILENAME: Defragcommon.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Common routines used in MFTDefrag and bootoptimize.

**************************************************************************************************/


ULONGLONG FindFreeSpaceChunk(
    IN LONGLONG BitmapSize,
    IN LONGLONG BytesPerSector,
    IN LONGLONG TotalClusters,
    IN ULONGLONG ulFileSize,
    IN BOOL IsNtfs,
    IN ULONGLONG MftZoneStart,
    IN ULONGLONG MftZoneEnd,
    IN HANDLE hVolumeHandle
    );

VOID MarkBitMapforNTFS(
    IN OUT PULONG pBitmap,
    IN ULONGLONG MftZoneStart,
    IN ULONGLONG MftZoneEnd
    );

BOOL MoveFileLocation(
    IN HANDLE hMFTHandle,
    IN ULONGLONG ulFirstAvailableFreeSpace,
    IN ULONGLONG ulMFTsize,
    IN ULONGLONG ulStartingVcn,
    IN HANDLE hVolumeHandle
    );

BOOL StartsWithVolumeGuid(
    IN PCWSTR szName
    );

BOOL PauseOnVolumeSnapshot(
    IN PWSTR szVolumeName
    );

BOOL
AcquirePrivilege(
    IN CONST PCWSTR szPrivilegeName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\devio.h ===
/****************************************************************************************************************

 FILENAME: DevIo.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
 
 DESCRIPTION:
    Prototypes for call to defrag hooks.

***************************************************************************************************************/

#define STATUS_ALREADY_COMMITTED         ((NTSTATUS)0xC0000021L)
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)


BOOL
WINAPI
ESDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dfrgengn.h ===
/****************************************************************************************************************

FILENAME: DfrgEngn.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        This contains the definitions for the common global data as used in
        both the FAT and NTFS defragmentation engines.

/***************************************************************************************************************

Structures

***************************************************************************************************************/

#ifndef _DFRGENGN_H_
#define _DFRGENGN_H_

#include "VString.hpp"
#include "alloc.h"

//The size of the extent buffer in bytes.
#define EXTENT_BUFFER_LENGTH 65536

//The number of milliseconds to set the timer for updating the DiskView class.
#define DISKVIEWUPDATEINTERVAL 1000

//The number of milliseconds to wait for the DiskView mutex before erroring out.
#define DISKVIEWMUTEXWAITINTERVAL 20000

//The number of milliseconds between pings.
#define PINGTIMER 5000

//The prescan reads in chunks of the MFT directly from disk.  This is the size of the chunks.
#define MFT_BUFFER_SIZE 65536

//Defines for whether the current pass moves these types of files.
#define MOVE_FRAGMENTED 0x00000001
#define MOVE_CONTIGUOUS 0x00000002

//Defines the type of file system this engine is running on.
#define FS_NONE		0
#define FS_FAT		1
#define FS_NTFS		2
#define FS_FAT32	3

//For use to determine whether we're moveing through the files forward or backward on a volume.
#define FORWARD		0
#define BACKWARD	1

//The different combinations of bits that can be set to determine which type of free space to look for in
//defragmenting a file.
#define FIRST_FIT			0x001
#define BEST_FIT			0x002
#define LAST_FIT			0x004
#define EARLIER				0x008
#define FIND_FIRST			0x010
#define FIND_LAST			0x020
#define FIND_LARGEST		0x040
#define AT_END				0x080
#define COUNT_FREE_SPACES	0x100

//The status's after attempting to defrag a file.
#define NEXT_FILE			0x10		//Go on to the next file (successfully defragged, or can't defrag at all).
#define NEXT_ALGO_STEP		0x20		//Try the next method of defragmenting this file (last one failed).
#define NEXT_PASS			0x30		//Done with this pass, or major error, bomb out of this pass.
#define TERMINATE_ENGINE	0x40		//Fatal error. Die a miserable death (gracefully).

//The status of the engine.
#define RUNNING				0x01		//The engine is running.
#define PAUSED				0x02		//The engine is paused.
#define TERMINATE			0x03		//The engine needs to terminate.

//There will be a buffer for reading in chunks of the MFT.  Make it nice and big so we aren't doing zillions of I/O's.
#define MFT_BUFFER_BYTES	65536

//#define AT_END				0x080

//#define COUNT_FREE_SPACES	0x100

//This goes at the beginning of an extent list before the series of streams to identify the streams that follow.
typedef struct {
	LONGLONG	FileRecordNumber;		//The FRS of the file that owns the following streams.
	DWORD		NumberOfStreams;		//The number of streams that follow.
	DWORD		TotalNumberOfStreams;	//The total number of streams in the file including resident ones.
	LONGLONG	ExcessExtents;			//The number of excess extents in all the streams that follow.
} FILE_EXTENT_HEADER, *PFILE_EXTENT_HEADER;

//This goes into extent lists before each series of extents to identify the extents that follow within a stream.
typedef struct {
	DWORD		StreamNumber;			//The number of this stream..
	LONGLONG	ExtentCount;			//The number of extents that follow.
	LONGLONG	ExcessExtents;			//The number of excess extents in the stream.
	LONGLONG	AllocatedLength;		//The allocated length for this stream.
	LONGLONG	FileSize;				//The size of data in this stream.
} STREAM_EXTENT_HEADER, *PSTREAM_EXTENT_HEADER;

//The extent list for files has a series of these structures, one for each extent.
typedef struct {
	LONGLONG	StartingLcn;			//The Lcn this extent starts on.
   	LONGLONG 	ClusterCount;			//The count of clusters in this extent.
#ifdef OFFLINEDK
    LONGLONG    Frn;                    //The FileRecordNumber we got this from.
    LONGLONG    OriginalLcn;            //The Lcn this extent got moved from.
	DWORD		AttributeNumber;		//Which attribute in that FRS this is from.
#endif
} EXTENT_LIST, *PEXTENT_LIST;

//We will have a buffer for holding extent lists of individual files.  Allocate a nice big buffer initially to avoid frequent reallocs.
#define INITIAL_EXTENT_LIST_BYTES (4096 * sizeof(EXTENT_LIST))

//This is a file list entry.
typedef struct _FILE_LIST_ENTRY {
	LONGLONG	StartingLcn;
	LONGLONG    FileRecordNumber;
    LONGLONG    ClusterCount;
	ULONG		ExcessExtentCount;
	BYTE		Flags;
    BYTE        Reserved[3];
} FILE_LIST_ENTRY;

typedef struct _FREE_SPACE_ENTRY {
    LONGLONG    StartingLcn;
    LONGLONG    ClusterCount;
    BOOL        SortBySize;
    DWORD       Reserved;
} FREE_SPACE_ENTRY;

typedef struct _FILE_LIST_ENTRY *PFILE_LIST_ENTRY;
typedef struct _FREE_SPACE_ENTRY *PFREE_SPACE_ENTRY;


//FLE stands for FILE_LIST_EXTRY.  These masks are the bitmasks to the Flags member of FILE_LIST_EXTRY.
#define FLE_DISABLED		0x01		//This bit identifies whether the file is not to be defragmented on any further pass.
#define FLE_NEXT_PASS		0x02		//This bit identifies whether the file is not to be defragmented again this pass.
#define FLE_FRAGMENTED		0x04		//This bit identifies whether the file is fragmented or not.
#define FLE_DIRECTORY		0x08		//This bit identifies whether the file is a directory or not.
#define FLE_BOOTOPTIMISE 	0x10		//This bit identifies whether the file is to be boot-optimised

////Same as extent list except this is the format we use in the file lists.  It only holds 32-bit values
////to save space in the file lists.
//typedef struct{
//	ULONG	StartingLcn;
//	ULONG 	ClusterCount;
//} FILE_LIST_EXTENT;
//
////This goes into the file lists before each series of extents to identify the extents that follow.
////Notice it has the same exact structure size as FILE_LIST_EXTENT so allocs can use one or the other without trouble.
//typedef struct{
//	ULONG	FileRecordNumber;					//The FRS of the file that owns the following extents.
//	ULONG	ExtentCount;						//The number of extents that follow.
//} FILE_LIST_HEADER;

//This contains the various pointers necessary to hold an extent list and pass it around among the extent functions.
typedef struct{
	HANDLE hExtents;							//Handle to the memory for the extent list.
	UCHAR* pExtents;							//Pointer to the memory for the extent list.
	DWORD ExtentListAlloced;					//The number of bytes allocated in memory for the extent list.
	DWORD ExtentListSize;						//The number of bytes actually used by the extent list in the alloced memory.
	FILE_EXTENT_HEADER* pFileExtentHeader;		//The file extent header for this file's extent list.
	STREAM_EXTENT_HEADER* pStreamExtentHeader;	//The stream extent header for any given stream in this file's extent list.
	DWORD dwEnabledStreams;						//Determines which types of streams to look for.
	LONGLONG BytesRead;							//The number of bytes read to the current stream.
	LONGLONG TotalClusters;						//The number of clusters in all the streams of the file.
	LONGLONG TotalRealClusters;					//The number of real clusters in all the streams of the file.
} EXTENT_LIST_DATA;

#define DEFAULT_STREAMS	0 //$DATA and $INDEX_ALLOCATION
#define ALL_STREAMS		1 //$DATA, $INDEX_ALLOCATION, and $BITMAP

//Used to access a LONGLONG as two discrete DWORDs
typedef union _DWORD_AND_LONGLONG
{
   	struct {
		DWORD	Low;
		DWORD	High;
	} Dword;
	LONGLONG	LongLong;
} DWORD_AND_LONGLONG;

// number of passes in the defrag alogrithm
#define PASS_COUNT 7

typedef struct {
	LONGLONG			BitmapSize;				//Total bits in bitmap buffer (padded fort 32 bit scans)
	LONGLONG			BytesPerSector;			//Number of bytes in one sector
	LONGLONG			BytesPerCluster;		//Number of bytes in one cluster
	LONGLONG			SectorsPerCluster;		//Number of sector in one cluster
	LONGLONG			TotalSectors;			//Number of sectors in this volume
	LONGLONG			TotalClusters;			//Number of clusters in this volume
	LONGLONG			UsedClusters;			//Number of used clusters on the drive
	LONGLONG			UsedSpace;				//Number of used bytes on the drive
	LONGLONG			FreeSpace;				//Number of free bytes on the drive
	LONGLONG			UsableFreeSpace;		//Number of usable free bytes on the drive
	LONGLONG			NumFreeSpaces;			//The number of free spaces on the volume.
	LONGLONG			SmallestFreeSpaceClusters;//The size of the smallest free space in clusters.
	LONGLONG			LargestFreeSpaceClusters;//The size of the largest free space in clusters.
	LONGLONG			AveFreeSpaceClusters;	//The average size of the free spaces in clusters.
	LONGLONG			ExtentListAlloced;		//The size in bytes of the allocated memory for the extent list.
	LONGLONG			ExtentListSize;
	
	LONGLONG			FileRecordNumber;		//File record number of current file in this volume
												//(for NTFS it may be less than FreeSpace)
	LONGLONG			StartingLcn;			//The Lcn to consider as the earliest on the disk for the current file (not necessarily the earliest in actuality).
//	LONGLONG			NumberOfExtents;		//Number of extents in current file
	LONGLONG			NumberOfFragments;		//Number of fragments in current file
	LONGLONG			NumberOfClusters;		//Number of clusters in current file
	LONGLONG			NumberOfRealClusters;	//Number of real clusters in current file
	LONGLONG			NumberOfFileRecords;	//Number of File Records holding this file's extents
	LONGLONG			FileSize;				//Number of bytes in current file
	LONGLONG			AllocatedLength;		//Number of bytes allocated to the current file on disk.
	LONGLONG			MftStartOffset;			//Byte offset to the Mft
	LONGLONG			MftStartLcn;			//First cluster of the Mft
	LONGLONG			Mft2StartLcn;			//First cluster of the Mirror Mft
    LONGLONG			MftZoneStart;			//First cluster of the Mft zone.
    LONGLONG			MftZoneEnd;				//Last cluster of the Mft zone.
	LONGLONG			BytesPerFRS;			//Number of bytes in one file record segment
	LONGLONG			ClustersPerFRS;			//Number of clusters in one file record segment
	LONGLONG			TotalFileRecords;		//Number of file records in this volume
	LONGLONG			InUseFileRecords;		//How many file records are in use in the MFT.
	LONGLONG			LastStartingLcn;		//The LCN referring to the last file we said to defrag so we know where to pick up again when looking for the next file in the file lists to defrag.
	LONGLONG			FatOffset;				//The offset from the beginning of the disk to the active fat in clusters.
	LONGLONG			FatMirrOffset;			//The offset from the beginning of the disk to the mirror fat in clusters (or 0 if it doesn't exist).
	LONGLONG			FoundLcn;				//The Lcn of the free space found to move this file into.
	LONGLONG			FoundLen;				//The length of the free space.
	LONGLONG			FilesMoved;				//The number of files moved in the last pass.
	LONGLONG			FreeSpaces;				//The number of free spaces on the disk.
	LONGLONG			CenterOfDisk;			//The center cluster number on the disk.
	LONGLONG			TotalFiles;				//The total number of large files on the disk.  (Not size, see the types of files that can exist on NTFS: small, large, huge, extremely huge)
	LONGLONG			NumFraggedFiles;		//The number of fragmented files on the disk.
	LONGLONG			NumExcessFrags;			//The number of frags over and above the 1 per file (i.e. frags that degrade performance.)
	LONGLONG			TotalDirs;				//The total number of directories on the disk.
	LONGLONG			TotalSmallDirs;			//Total number of Small Directories on the disk.
//	LONGLONG			TotalDirExtents;		//The total number of extents in all directories on the disk.
	LONGLONG			NumFraggedDirs;			//The total number of fragmented directories on the disk.
	LONGLONG			NumExcessDirFrags;		//The total number of excess frags in directories.
	LONGLONG			NumFilesInMftZone;		//acs//The total number of files in the Mft Zone
	LONGLONG			AveFileSize;			//The average size of the files on this disk in bytes.
	LONGLONG			FraggedSpace;			//The continuous counter of how many bytes on the disk are occupied by fragmented files.
	LONGLONG			PercentDiskFragged;		//What percent of the disk is fragmented.
	LONGLONG			AveFragsPerFile;		//The average number of fragments per file.
	LONGLONG			TotalFileBytes;			//The total number of bytes in all the files on the disk.
	LONGLONG			TotalFileSpace;			//The continuous counter of how many bytes all the files found on a scan take up.
//	LONGLONG			TotalDirSpace;			//The continuous counter of how many bytes all the directories found on a scan take up.
	LONGLONG			CurrentFile;			//The continuous counter of how many files have been found on a scan.
//	LONGLONG			CurrentDirectory;		//The continuous counter of how many directories have been found on a scan.
	LONGLONG			MftSize;				//The size of the Mft in bytes.
	LONGLONG			MftNumberOfExtents;		//Number of extents in the Mft
	LONGLONG			PagefileSize;			//The size of the pagefile in bytes.
	LONGLONG			PagefileFrags;			//The number of fragments in the pagefile.
	LONGLONG			NumPagefiles;			//The number of active pagefiles on this drive.
	LONGLONG			LeastFragged;			//The number of fragments in the least fragmented file in the most fragmented file list.
	LONGLONG			LastPathFrs;			//The frs of the directory the last file was in.
	LONGLONG			MasterLcn;				//The starting lcn of the directory that contains the entry for this file.
	LONGLONG			FreeExtents;			//The number of free extents in the free extents list (partial defrag).

    LONGLONG            InitialFraggedClusters;  //The total number of fragmented clusters after the analyse
    LONGLONG            InitialContiguousClusters; // The total number of contiguous clusters after the analyse

    LONGLONG            FraggedClustersDone;    // Number of clusters we have finished defragmenting

	LONGLONG			BootOptimizeBeginClusterExclude;		//the cluster number where we exclude moving files
	LONGLONG			BootOptimizeEndClusterExclude;		    //the cluster number where we exclude moving files
	LONGLONG   			BootOptimiseFileListTotalSize;
	LONGLONG 			BootOptimiseFilesAlreadyInZoneSize;

    PFILE_LIST_ENTRY    pFileListEntry;
    PFREE_SPACE_ENTRY   pFreeSpaceEntry;
    PLONGLONG			pBootOptimiseFrnList;

    struct _SA_CONTEXT  SaFreeSpaceContext;
    struct _SA_CONTEXT  SaFileEntryContext;
	struct _SA_CONTEXT  SaBootOptimiseFilesContext;

    RTL_GENERIC_TABLE   FragmentedFileTable;
    RTL_GENERIC_TABLE   ContiguousFileTable;
    RTL_GENERIC_TABLE   NonMovableFileTable;
    RTL_GENERIC_TABLE   FreeSpaceTable;
    RTL_GENERIC_TABLE   BootOptimiseFileTable;
    RTL_GENERIC_TABLE   FilesInBootExcludeZoneTable;
    RTL_GENERIC_TABLE	MultipleFreeSpaceTrees[10];

    PTCHAR				pNameList;				//Pointer to the name list.
	UCHAR*				pExtentList;			//Pointer to the extent list.
	FILE_RECORD_SEGMENT_HEADER*	pMftBuffer;		//Pointer to that buffer.
	EXTENT_LIST*		pMftExtentList;			//The pointer to the Mft's extent list.
	PVOID				pFileRecord;			//Pointer to the Frs.

	VString				vFileName;				//The name of the current file


  	TCHAR				
		NodeName[MAX_COMPUTERNAME_LENGTH+1];	//The name of the node this engine is running on.
	SYSTEMTIME			StartTime;				//The time the engine started.
	SYSTEMTIME			EndTime;				//The time the engine finished action (not terminated).
						
	FILE_LIST_ENTRY*	pSysList;				//Pointer to the system file list.
	

	DWORD				FileSystem;				//This volume's file system (FS_NTFS, FS_FAT, FS_NONE)
	DWORD				EngineState;			//Whether the engine is paused, runnning or should terminate.
	DWORD				FirstDataOffset;		//On FAT and FAT32 drives, it specifies the byte offset for the first cluster on the disk (not zero).  On NTFS - zero.
	DWORD				Status;					//During defrag this contains the status -- whether to go on to the next file, end pass, etc.
	DWORD				Pass;					//The current pass number. (prescan is 0, scan is 1, defrag passes start at 2)

	// The following fields are relevant only for the FAT engine
    HANDLE				hMoveableFileList;		//Handle to the moveable file list.

	
	DWORD				ProcessFilesDirection;	//Which direction we're traversing the disk.  FORWARD or BACKWARD 
	LONGLONG			SourceStartLcn;			//The first LCN in the region to move files from in the current pass.
	LONGLONG			SourceEndLcn;			//The last LCN in the region to move files from in the current pass.
	FILE_LIST_ENTRY*	pMoveableFileList;		//Pointer to the moveable file list
    ULONG				MoveableFileListSize;	//The size of the moveable file list in bytes.
	ULONG				MoveableFileListEntries;//The number of entries (FILE_LIST_ENTRY size structures) in the moveable list.
	ULONG				MoveableFileListIndex;	//The current index into the moveable file list (in FILE_LIST_ENTRY size increments).
	
	FILE_LIST_ENTRY*	pPagefileList;			//Pointer to the page file list.
	ULONG				PagefileListSize;		//The size of the pagefile list in bytes.
	ULONG				PagefileListEntries;	//The number of entries (FILE_LIST_ENTRY size structures) in the pagefile file list.
	ULONG				PagefileListIndex;		//The current index into the page file list (in FILE_LIST_ENTRY size increments).

	DWORD				Pass6Rep;				//How many repetitions have occurred on pass 6.  Used to limit the number of repetitions.
	LONGLONG			FilesMovedInLastPass;	//How many files were moved in the last pass.
	LONGLONG			DestStartLcn;			//The first LCN in the region to move files to in the current pass.
	LONGLONG			DestEndLcn;				//The last LCN in the region to move files to in the current pass.
	
	LONGLONG			LargestFound;			//The largest space found to move a file into in clusters.
	ULONG				SysListSize;			//The size of the system file list in bytes.
	
	// end FAT specific

	ULONG				NameListSize;			//The size of the name list in bytes.
	ULONG				NameListIndex;			//The current index into the name list (in bytes).
	ULONG				VolumeBufferFlushes[PASS_COUNT];	// number of file flushes during each pass

	ULONG				FragmentedFileMovesAttempted[PASS_COUNT]; //number of times a defragment attempt was made
	ULONG				FragmentedFileMovesSucceeded[PASS_COUNT]; //number of times a defragment attempt succeeded
	ULONG				FragmentedFileMovesFailed[PASS_COUNT]; //number of times a defragment attempt failed

	ULONG				ContiguousFileMovesAttempted[PASS_COUNT]; //number of times a move attempt was made
	ULONG				ContiguousFileMovesSucceeded[PASS_COUNT]; //number of times a move attempt succeeded
	ULONG				ContiguousFileMovesFailed[PASS_COUNT]; //number of times a move attempt failed

	WORD				FatVersion;				//The version number of the FAT or FAT32 volume.

	HANDLE				hVolume;				//Handle to this volume
	HANDLE				hVolumeBitmap;			//Handle to volume's free space bitmap
	HANDLE				hExtentList;			//Handle to the current file's extent list
	HANDLE				hMftBuffer; 			//Handle to the buffer for reading in chunks of the MFT.
	HANDLE				hMftBitmap;				//Handle to this volume's Mft bitmap
	HANDLE				hMftExtentList;			//Handle to this volume's Mft extent list
	HANDLE				hFileRecord;			//Handle for the Frs for the current file.
	HANDLE				hExcludeList;			//Handle to the exclusion list.
	HANDLE				hFile;					//Handle to the current file
	HANDLE				hFreeExtents;			//The handle to the free extents found to move this file into.
	HANDLE				hSysList;				//Handle to the system file list.
	HANDLE				hPagefileList;			//Handle to the page file list.
	HANDLE				hNameList;				//Handle to the name list which is used only for FAT and holds the names of every file in all the lists.
	HANDLE				hBootOptimiseFrnList;


	TCHAR				cDrive;					//Drive letter of this volume (eg. C:)
	TCHAR				cVolumeName[GUID_LENGTH];//The name of the volume (GUID or UNC)
	TCHAR				cVolumeTag[GUID_LENGTH];//Used to concat onto strings to make unique IDs
	TCHAR				cVolumeLabel[100];		//The volume label
	TCHAR				cDisplayLabel[100];		//String used when printing to screen or logfile


	BOOL				bCompressed;			//If current file is compressed
	BOOL				bDirectory;				//If current file is a directory (index)
	BOOL				bPageFile;				//If current file is a PageFile
	BOOL				bFragmented;			//If current file is fragmented
	BOOL				bSmallFile; 			//If current file is a small-file
	BOOL				bLargeFile; 			//If current file is a large file
	BOOL				bHugeFile;				//If current file is a huge file
	BOOL				bExtremelyHugeFile;		//If current file is an extremely huge file		

    BOOL				bMFTCorrupt;			//If the MFT contains corrupt records
    BOOL				bInBootExcludeZone; 	//If current file has an extent in the region reserved for boot-optimisation
    BOOL				bBootOptimiseFile;		//If current file needs to be boot-optimised

} VOL_DATA, *PVOL_DATA;


//***************************************************************************************************************
//
// Global variables
//
//***************************************************************************************************************/

//VolData contains all kinds of data!
#ifndef GLOBAL_DATAHOME
extern
#endif
VOL_DATA VolData;

/* NO GLOBALS!! - MWP 12/3/98

 //Stores the instance of the resource DLL that we use to hold all resources.  This is obtained by LoadLibrary and
//is used to get any resources from the resource DLL.
#ifndef GLOBAL_DATAHOME
extern
#endif
HINSTANCE hInst
#ifdef GLOBAL_DATAHOME
= NULL
#endif
;
*/

//Tells whether were supposed to to an analyze or an analyze and a defrag.
#ifndef GLOBAL_DATAHOME
extern
#endif
DWORD AnalyzeOrDefrag
#ifdef GLOBAL_DATAHOME
= ANALYZE
#endif
;

//Stores the priority for the engine.
#ifndef GLOBAL_DATAHOME
extern
#endif
TCHAR cPriority[300];

//Holds the handle to the main window for the Dfrg engine.
#ifndef GLOBAL_DATAHOME
extern
#endif
HWND hwndMain
#ifdef GLOBAL_DATAHOME
= NULL
#endif
;

//This is the buffer into which a file record is written after calling ESDeviceIoControl to get a file record.
#ifndef GLOBAL_DATAHOME
extern
#endif
UCHAR FileRecordOutputBuffer[(4096+32+16) * 10];

//Handle to the memory which holds the name of the active pagefiles on the current drive.
#ifndef GLOBAL_DATAHOME
extern
#endif
HANDLE hPageFileNames
#ifdef GLOBAL_DATAHOME
= NULL
#endif
;

//The pointer for hPageFileNames
#ifndef GLOBAL_DATAHOME
extern
#endif
TCHAR* pPageFileNames
#ifdef GLOBAL_DATAHOME
= NULL
#endif
;

//The handle for the worker thread that carries out either Analyzing or Defragging.
#ifndef GLOBAL_DATAHOME
extern
#endif
HANDLE hThread
#ifdef GLOBAL_DATAHOME
= NULL
#endif
;

//The MFT is read in in chunks.  This records the file record number of the lowest file record of the chunk that's currently loaded.
#ifndef GLOBAL_DATAHOME
extern
#endif
LONGLONG FileRecordLow
#ifdef GLOBAL_DATAHOME
= 0
#endif
;

//The MFT is read in in chunks.  This records the file record number of the highest file record of the chunk that's currently loaded.
#ifndef GLOBAL_DATAHOME
extern
#endif
LONGLONG FileRecordHi
#ifdef GLOBAL_DATAHOME
= 0
#endif
;

//This table allows the number of set bits in a byte to be counted by using the
//byte as an index into this table. FAST bit count. (do it twice for a word, etc)
#ifndef GLOBAL_DATAHOME
extern
#endif
BYTE CountBitsArray[256]
#ifdef GLOBAL_DATAHOME
= {
//      0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f
        0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,                //      0
        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,                //      1
        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,                //      2
        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,                //      3
        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,                //      4
        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,                //      5
        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,                //      6
        3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,                //      7
        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,                //      8
        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,                //      9
        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,                //      a
        3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,                //      b
        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,                //      c
        3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,                //      d
        3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,                //      e
        4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8                 //      f
};
#endif
;

#endif //#ifndef _DFRGENGN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dfrgcmn.h ===
/****************************************************************************************************************

FILENAME: DfrgCmn.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

REVISION HISTORY: 
    0.0E00 - 21 April 1997 - Zack Gainsforth - Created file from FileSys.h

DESCRIPTION:
    This is the header file for stuff that is common to both the defragmenter engines and the GUI.

/****************************************************************************************************************/

#ifndef _DFRGCMN_H
#define _DFRGCMN_H

#include "vString.hpp"
#include "vStandard.h"

#define SIMPLE_DISPLAY TRUE

// for string compare
#define MATCH                   0

// event name for syncing up with a console app
#define DEFRAG_COMPLETE_EVENT_NAME TEXT("DiskDefragmenter.Event.Volume")

// event name for preventing multiple instances
#define IS_OK_TO_RUN_SEMAPHORE_NAME TEXT("Global\\DiskDefragmenter.Semaphore.MultiInstance")

// for the EngineState()
#define ENGINE_STATE_NULL       0   // Means it hasn't begun running yet.
#define ENGINE_STATE_IDLE       1   // Means it is instantiated, but not running
#define ENGINE_STATE_RUNNING    2   // Means it is running

// for the DefragMode()
#define NONE            0
#define ANALYZE         1
#define DEFRAG          2

#define DEFRAG_FAILED   0x10000000  // set the bit if defrag failed

#define GUID_LENGTH 51

// for DefragState()
#define DEFRAG_STATE_NONE           0   // set when the engine starts, always set thereafter
#define DEFRAG_STATE_USER_STOPPED   1   // set when user stops anal or defrag
#define DEFRAG_STATE_ANALYZING      2   // set during analyze phase only
#define DEFRAG_STATE_ANALYZED       3   // set when volume is analyzed and graphic data is available
#define DEFRAG_STATE_REANALYZING    4   // set during reanalyze phase only
#define DEFRAG_STATE_DEFRAGMENTING  5   // set when defragging is going on
#define DEFRAG_STATE_DEFRAGMENTED   6   // set when defragging is complete
#define DEFRAG_STATE_ENGINE_DEAD    7   // set when engine connection is lost
#define DEFRAG_STATE_BOOT_OPTIMIZING  8 // set when the engine is optimising the boot files

//The number of milliseconds to wait for the DiskView mutex before erroring out.
#define DISKDISPLAYMUTEXWAITINTERVAL 20000

//The number of milliseconds between resetting the communication link.
#define RESETCOMMLINKTIMER 30000

//These are the WM_COMMAND messages that the GUI can send to the engine.
#define ID_ANALYZE                  8100
#define ID_DEFRAG                   8101
#define ID_STOP                     8102
#define ID_PAUSE                    8103
#define ID_CONTINUE                 8104
#define ID_ABORT                    8105
#define ID_INITIALIZE_DRIVE         8106
#define ID_SETDISPDIMENSIONS        8107
#define ID_INIT_VOLUME_COMM         8108
#define ID_PAUSE_ON_SNAPSHOT        8109
#define ID_ABORT_ON_SNAPSHOT        8110

//These are the WM_COMMAND messages that the engine can send to the GUI
#define ID_BEGIN_SCAN               8200
#define ID_DISP_DATA                8201
#define ID_END_SCAN                 8202
#define ID_STATUS                   8203
#define ID_TERMINATING              8204
#define ID_ENGINE_START             8205
#define ID_FRAGGED_DATA             8206
#define ID_REPORT_TEXT_DATA         8207
#define ID_NO_GRAPHICS_MEMORY       8208
#define ID_ERROR                    8209

//These are the WM_COMMAND messages that can be sent either way.
#define ID_PING                     8300

//These are the WM_COMMAND messages that are used internally in the engines.
#define ID_INITIALIZE               8400

//These are the WM_COMMAND messages that are used internally in the UI.
#define ID_REPORT                   8500
#define ID_REFRESH                  8501
#define ID_HELP_CONTENTS            8502
#define ID_ABORTANDSTART            8503

//The names used to create and find other instances of the the window for the DfrgNtfs engine.
#define DFRGNTFS_CLASS              TEXT("DfrgNtfsClass")
#define DFRGNTFS_WINDOW             TEXT("DfrgNtfs")

//The names used to create and find other instances of the the window for the DfrgFat engine.
#define DFRGFAT_CLASS               TEXT("DfrgFatClass")
#define DFRGFAT_WINDOW              TEXT("DfrgFat")

//Structure with the data necessary to initialize the DiskDisplay in the GUI when the scan starts.
typedef struct {
    TCHAR cVolumeName[GUID_LENGTH];
    TCHAR cVolumeTag[GUID_LENGTH];
    TCHAR cDisplayLabel[GUID_LENGTH];
    TCHAR cFileSystem[16];
}BEGIN_SCAN_INFO;

//Structure sent when the engine starts and has initialized.
typedef struct {
    TCHAR cVolumeName[GUID_LENGTH];
    TCHAR cFileSystem[16];
    DWORD dwAnalyzeOrDefrag;
}ENGINE_START_DATA;

//Structure sent from the engine when the engine dies
typedef struct {
    TCHAR cVolumeName[GUID_LENGTH];
    TCHAR cFileSystem[16];
    DWORD dwAnalyzeOrDefrag;
}END_SCAN_DATA;

//Contains all the various statistics about the disk drive that will be used to
//create a text display in the UI.
typedef struct {
    TCHAR cVolumeName[GUID_LENGTH];
    TCHAR cVolumeLabel[100]; // added
    TCHAR cDrive;
    TCHAR cFileSystem[16];
    LONGLONG DiskSize;
    LONGLONG BytesPerCluster;
    LONGLONG UsedSpace;
    LONGLONG FreeSpace;
    LONGLONG FreeSpacePercent;
    LONGLONG UsableFreeSpace;
    LONGLONG UsableFreeSpacePercent;
    LONGLONG PagefileBytes;
    LONGLONG PagefileFrags;
    LONGLONG TotalDirectories;
    LONGLONG FragmentedDirectories;
    LONGLONG ExcessDirFrags;
    LONGLONG TotalFiles;
    LONGLONG AvgFileSize;
    LONGLONG NumFraggedFiles;
    LONGLONG NumExcessFrags;
    LONGLONG PercentDiskFragged;
    LONGLONG AvgFragsPerFile;
    LONGLONG MFTBytes;
    LONGLONG InUseMFTRecords;
    LONGLONG TotalMFTRecords;
    LONGLONG MFTExtents;
    LONGLONG FreeSpaceFragPercent;
}TEXT_DATA;

//Structure containing data for DiskDisplay to display.
//Any of the DWORD fields can contain zero to indicate that no data is held for analyze or defrag.
//The defrag line array always comes after the analyze line array.  However, it may be that only
//one or the other is present.
typedef struct {
    TCHAR cVolumeName[GUID_LENGTH];
    DWORD dwAnalyzeNumLines;
    DWORD dwDefragNumLines;
    BYTE LineArray;
}DISPLAY_DATA;

//Structure containing display dimensions for the DiskView from the UI.
typedef struct {
    //Either of these may contain 0
    DWORD AnalyzeLineCount;
    DWORD DefragLineCount;
    BOOL bSendGraphicsUpdate;  // set to true if you want an immediate update from the engine
}SET_DISP_DATA;

//Structure containing status data about the engine.
typedef struct {
    TCHAR cVolumeName[GUID_LENGTH];
    DWORD dwPercentDone;    //0 to 100
    DWORD dwEngineState;    // conforms to states given at top of file (STATE_xxxx)
    DWORD dwPass;           //0 through 7.
    TCHAR vsFileName[200];      //the file name of the last moved file
//acs//
//  DWORD dwAnalyzePass;    //0 or 1.
//  DWORD dwAnalyzePercent; //0 to 100
//  DWORD dwDefragPass;     //0 through 7.
//  DWORD dwDefragPercent;  //0 to 100

}STATUS_DATA;

//Structure containing error code and text when the engine encounters a problem.
// (see codes below)
typedef struct {
    TCHAR cVolumeName[GUID_LENGTH];
    DWORD dwErrCode;
    TCHAR cErrText[1000];
}ERROR_DATA;

//Structure sent when there is no data to send.
typedef struct {
    TCHAR cVolumeName[GUID_LENGTH];
}NOT_DATA;

//Defines whether we are supposed to simply analyze the disk, or analyze and defragment it.
#define NONE        0
#define ANALYZE     1
#define DEFRAG      2

//Engine error codes
//Note that these values are also used by programs that launch
//the defragger to interpret the exit code.
#define ENG_NOERR               0
#define ENG_USER_CANCELLED      1
#define ENGERR_BAD_PARAM        2
#define ENGERR_UNKNOWN          3
#define ENGERR_NOMEM            4
#define ENGERR_GENERAL          5
#define ENGERR_SYSTEM           6
#define ENGERR_LOW_FREESPACE    7
#define ENGERR_CORRUPT_MFT      8
#define ENGERR_RETRY			9

#include "Message.h"

//Message window.
#ifndef GLOBAL_DATAHOME
extern
#endif
BOOL bMessageWindowActive
#ifdef GLOBAL_DATAHOME
= TRUE
#endif
;

//Allow Messageboxes.
#ifndef GLOBAL_DATAHOME
extern
#endif
BOOL bPopups
#ifdef GLOBAL_DATAHOME
= TRUE
#endif
;

//If an error occurred which is identified, a message is printed at that location giving data
//to the user.  Otherwise, more generic errors are outputted as the code filters up.
#ifndef GLOBAL_DATAHOME
extern
#endif
BOOL bIdentifiedErrorPath
#ifdef GLOBAL_DATAHOME
= FALSE
#endif
;

#endif // #ifndef _DFRGCMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dfrghlp.h ===
//Make sure this header only gets included once.
#ifndef DFRGHLPINC
#define DFRGHLPINC

#include "DfrgRes.h"

// "Defragmentation Statistics" Dialog Box

#define IDH_DISABLEHELP	(DWORD(-1))
#define IDH_101_1001	65601637	// Defragmentation Statistics: "" (ListBox)
#define IDH_101_1		65637		// Defragmentation Statistics: "&Close" (Button)

// "Defragmentation Complete" Dialog Box

#define IDH_DISABLEHELP	(DWORD(-1))
#define IDH_102_205		13434982	// Defragmentation Complete: "See Report" (Button)
#define IDH_102_2		131174		// Defragmentation Complete: "Close Window" (Button)

static const DWORD DefragCompleteHelpIDArray[]=
{
    ID_GENERIC_BUTTON1,			IDH_102_205,
	ID_GENERIC_BUTTON0,			IDH_102_2,
    0, 0
};

// "Analysis Report" Dialog Box

#define IDH_DISABLEHELP	(DWORD(-1))
#define IDH_104_1013	66388072	// Analysis Report: "Save Report" (Button)
#define IDH_104_1014	66453608	// Analysis Report: "Print" (Button)
#define IDH_104_201		13172840	// Analysis Report: "Defragment" (Button)
#define IDH_104_203		13303912	// Analysis Report: "" (Edit)
#define IDH_104_204		13369448	// Analysis Report: "List1" (SysListView32)
#define IDH_104_2		131176		// Analysis Report: "Close Window" (Button)

static const DWORD AnalysisRptHelpIDArray[]=
{
    IDC_SAVE,						IDH_104_1013,
    IDC_PRINT,						IDH_104_1014,
    IDC_DEFRAGMENT,					IDH_104_201,
    IDC_VOLUME_INFORMATION,			IDH_104_203,
    IDC_VOLUME_INFORMATION_TEXT,	IDH_104_203,
    IDC_MOST_FRAGMENTED,			IDH_104_204,
    IDC_MOST_FRAGMENTED_TEXT,		IDH_104_204,
	IDCANCEL,						IDH_104_2,
    0, 0
};

// "Defragmentation Report" Dialog Box

#define IDH_DISABLEHELP	(DWORD(-1))
#define IDH_105_1013	66388073	// Defragmentation Report: "Save Report" (Button)
#define IDH_105_1014	66453609	// Defragmentation Report: "Print" (Button)
#define IDH_105_203		13303913	// Defragmentation Report: "" (Edit)
#define IDH_105_204		13369449	// Defragmentation Report: "List1" (SysListView32)
#define IDH_105_2		131177		// Defragmentation Report: "Close Window" (Button)

static const DWORD DefragRptHelpIDArray[]=
{
    IDC_SAVE,						IDH_105_1013,
    IDC_PRINT,						IDH_105_1014,
    IDC_VOLUME_INFORMATION,			IDH_105_203,
    IDC_VOLUME_INFORMATION_TEXT,	IDH_105_203,
    IDC_MOST_FRAGMENTED,			IDH_105_204,
    IDC_MOST_FRAGMENTED_TEXT,		IDH_105_204,
	IDCANCEL,						IDH_105_2,
    0, 0
};

// "Analysis Complete" Dialog Box

#define IDH_DISABLEHELP	(DWORD(-1))
#define IDH_106_201		13172842	// Analysis Complete: "Defragment" (Button)
#define IDH_106_205		13434986	// Analysis Complete: "See Report" (Button)
#define IDH_106_2		131178		// Analysis Complete: "Close Window" (Button)

static const DWORD AnalysisCompleteHelpIDArray[]=
{
    ID_GENERIC_BUTTON1,		IDH_106_201,
    ID_GENERIC_BUTTON2,		IDH_106_205,
	ID_GENERIC_BUTTON0,		IDH_106_2,
    0, 0
};

#endif //DFRGHLPINC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dfrgfat.h ===
/**************************************************************************************************

FILENAME: DfrgFat.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        This contains the prototypes for routines in the FAT file system
        defragmentation central module.

**************************************************************************************************/

// If ESI_MESSAGE_WINDOW is defined, then the Message() routine is set active otherwise it is set
// to NULL so there is no overhead costs.

#ifdef ESI_MESSAGE_WINDOW
    #define DisplayFatFileSpecs() DisplayFatFileSpecsFunction()
#else
    #define DisplayFatFileSpecs()
#endif

/*************************************************************************************************/

/////////////////////////////////
// ACPI Support
/////////////////////////////////
#define STATUS_AC_POWER_OFFLINE             0
#define STATUS_BATTERY_POWER_LOW            2
#define STATUS_BATTERY_POWER_CRITICAL       4
#define STATUS_POWER_UNKNOWN                255

#define BOOT_OPTIMIZE_REGISTRY_PATH				TEXT("SOFTWARE\\Microsoft\\Dfrg\\BootOptimizeFunction")
#define BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION TEXT("LcnStartLocation")
#define BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION	TEXT("LcnEndLocation")


//This is the WndProc for Dfrg.
LRESULT CALLBACK
MainWndProc(
	IN HWND  hWnd,
	IN UINT  uMsg,
	IN WPARAM  wParam,
	IN LPARAM  lParam
	);

//This initializes DCOM and the message window.
BOOL Initialize();

//This gets data about the volume and initializes variables and so forth for the Dfrg engine.
BOOL InitializeDrive(IN PTCHAR pCommandLine);

//Initializes defrag specific stuff before defragging, and after scanning.
BOOL InitializeDefrag();

//Sends status data to the UI.
VOID SendStatusData();

//Send the report text data to the UI.
VOID SendReportData();

//Sends the graphical data to the UI.
void SendGraphicsData();

//Notifies the UI there is not enough memory for graphics.
void SendGraphicsMemoryErr();

// send error to client to display for user
VOID SendErrData(PTCHAR pErrText, DWORD ErrCode = ENGERR_UNKNOWN);

//This is the exit routine that cleans up after being called by WM_CLOSE.
VOID Exit();

//This gets the MFT bitmap which has one bit set for each file record that is in use.
BOOL GetMftBitmap();

//This gets the names of the pagefiles on a given drive and stores them in a list.
BOOL
GetPagefileNames(
	TCHAR    cDrive,
	HANDLE*  phPageFileNames,
	TCHAR**  ppPageFileNames
	);

//Checks a file to see if it is a pagefile.
BOOL CheckForPagefileFat();

//Checks a given file name to see if it matches that of one of the pagefiles on a drive.
BOOL
CheckPagefileNameMatch(
	IN TCHAR*  pCompareName,
	IN TCHAR*  pPageFileNames
	);

//Display various statistics about the volume.
VOID DisplayFatVolumeStats();

//Displays the data about a given file on a FAT volume.
VOID DisplayFatFileSpecsFunction();

//This is the analyze thread's main routine.
BOOL AnalyzeThread();

//Determines how big the file lists will have to be.
BOOL PreScanFat();

//Fills in the file lists.
BOOL ScanFat();

//This is the defrag thread's main routine.
BOOL DefragThread();

//This defrags all the files in the file lists.
BOOL DefragFat();

//Tells the caller to end the current pass if there was no space to move a file into.
BOOL EndPassIfNoSpaces();

BOOL NextFileIfFalse();

BOOL BeepNowIfFileNotMoved();

//When a file cannot be fully defragmented, this routine will partially defragment it.
BOOL PartialDefragFat();

//Once a spot has been found for a file, this will move it there.
BOOL MoveFatFile();

//Allocate memory for the file lists.
BOOL AllocateFileLists();

//Free up the memory allocated for the file lists.
BOOL DeallocateFileLists();

BOOL UpdateDiskView();

//Sends the most fragged list to the UI.
BOOL SendMostFraggedList();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dfrgntfs.h ===
/**************************************************************************************************

FILENAME: DfrgNtfs.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

REVISION HISTORY:
    1.0.00 Andy Staffer - 17 May 1997 - Created.

/*************************************************************************************************/

// If ESI_MESSAGE_WINDOW is defined, then the Message() routine is set active otherwise it is set
// to NULL so there is no overhead costs.

#ifdef ESI_MESSAGE_WINDOW
    #define DisplayNtfsFileSpecs() DisplayNtfsFileSpecsFunction()
#else
    #define DisplayNtfsFileSpecs()
#endif

/*************************************************************************************************/

/////////////////////////////////
// ACPI Support
/////////////////////////////////
#define STATUS_AC_POWER_OFFLINE             0
#define STATUS_BATTERY_POWER_LOW            2
#define STATUS_BATTERY_POWER_CRITICAL       4
#define STATUS_POWER_UNKNOWN                255

#define BOOT_OPTIMIZE_REGISTRY_PATH				TEXT("SOFTWARE\\Microsoft\\Dfrg\\BootOptimizeFunction")
#define BOOT_OPTIMIZE_REGISTRY_LCNSTARTLOCATION TEXT("LcnStartLocation")
#define BOOT_OPTIMIZE_REGISTRY_LCNENDLOCATION	TEXT("LcnEndLocation")


LRESULT CALLBACK
MainWndProc(
	IN HWND  hWnd,
	IN UINT  uMsg,
	IN WPARAM  wParam,
	IN LPARAM  lParam
	);

//This intialize DCOM and the message window.
BOOL Initialize();

//This gets data about the volume and initializes variables and so forth for the Dfrg engine.
BOOL InitializeDrive(IN PTCHAR pCommandLine);

//Initializes defrag specific stuff before defragging, and after scanning.
BOOL InitializeDefrag();

//Sends status data to the UI.
VOID SendStatusData();

//Send the report text data to the UI.
VOID SendReportData();

//Sends the graphical data to the UI.
void SendGraphicsData();

//Notifies the UI there is not enough memory for graphics.
void SendGraphicsMemoryErr();

// send error to client to display for user
VOID SendErrData(PTCHAR pErrText, DWORD ErrCode = ENGERR_UNKNOWN);

//This is the exit routine that cleans up after being called by WM_CLOSE.
VOID Exit();

//This gets the MFT bitmap which has one bit set for each file record that is in use.
BOOL GetMftBitmap();

//This gets the names of the pagefiles on a given drive and stores them in a list.
BOOL
GetPagefileNames(
	TCHAR    cDrive,
	HANDLE*  phPageFileNames,
	TCHAR**  ppPageFileNames
	);

//Checks a file to see if it is a pagefile.
BOOL CheckForPagefileFat();

//Checks a file to see if it is a pagefile.
BOOL
CheckForPagefileNtfs(
	IN LONGLONG                     FileRecordNumber,
	IN FILE_RECORD_SEGMENT_HEADER*  pFileRecord
	);

//Checks a given file name to see if it matches that of one of the pagefiles on a drive.
BOOL
CheckPagefileNameMatch(
	IN TCHAR*  pCompareName,
	IN TCHAR*  pPageFileNames
	);

//Display various statistics about the volume.
VOID DisplayNtfsVolumeStats();

//Displays the data about a given file on a FAT volume.
VOID DisplayNtfsFileSpecsFunction();

//This is the analyze thread's main routine.
BOOL AnalyzeThread();

//Determines how big the file lists will have to be.
BOOL PreScanNtfs();

//Fills in the file lists.
BOOL ScanNtfs(IN CONST BOOL fAnalyseOnly);

//This is the defrag thread's main routine.
BOOL DefragThread();

//This defrags all the files in the file lists.
BOOL DefragNtfs();

//Tells the caller to end the current pass if there was no space to move a file into.
BOOL EndPassIfNoSpaces();

BOOL NextFileIfFalse();

//When a file cannot be fully defragmented, this routine will partially defragment it.
BOOL PartialDefragNtfs();

//Once a spot has been found for a file, this will move it there.
BOOL MoveNtfsFile();

//Gets a FRS for the prescan.  This reads in chunks of the MFT directly by DASD reads for speed.
//This is only permissible for the prescan since DASD reads may be out of sync with the drive's cache.
BOOL
GetFrs(
	IN  LONGLONG*                     pFileRecordNumber,
	IN  EXTENT_LIST*                  pMftExtentList,
	IN  UCHAR*                        pMftBitmap,
	IN  FILE_RECORD_SEGMENT_HEADER*   pMftBuffer,
	OUT FILE_RECORD_SEGMENT_HEADER*   pFileRecord
	);

//Read the function's header comment -- it must be run to "decode" a MFT record before using it.
AdjustUSA(IN OUT FILE_RECORD_SEGMENT_HEADER* pFrs);

//Allocate memory for the file lists.
BOOL AllocateFileLists(IN CONST BOOL fAnalyseOnly);

//Free up the memory allocated for the file lists.
BOOL DeallocateFileLists();

BOOL UpdateDiskView();

//Sends the most fragged list to the UI.
BOOL SendMostFraggedList(IN CONST BOOL fAnalyseOnly);

BOOL
AllocateFreeSpaceListsWithMultipleTrees();

VOID
ClearFreeSpaceListWithMultipleTrees();

VOID
ClearFreeSpaceTable();

BOOL 
ConsolidateFreeSpace(
    IN CONST LONGLONG MinimumLength,
    IN CONST DWORD dwDesparationFactor,
    IN CONST BOOL bDefragMftZone
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\dfrgres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by E:\execsoft\dfrg.ip\DfrgRes\DfrgRes.rc
//
#define IDS_INVALID_CMDLINE_OPERATION   1
#define IDS_PRODUCT_NAME                11
#define IDS_PARTIAL                     16
#define IDD_DFRGSTAT                    101
#define IDB_SYSTEM_FILES                102
#define IDD_DEFRAG_DONE                 102
#define IDD_ANALYSIS_REPORT             104
#define IDD_DEFRAG_REPORT               105
#define IDD_ANALYSIS_DONE               106
#define IDI_DEFRAG_ICON                 106
#define IDS_UNITS_BYTES                 109
#define IDS_UNITS_KB                    110
#define IDS_UNITS_MB                    111
#define IDS_UNITS_GB                    112
#define IDS_LABEL_EQUAL_SIGN            113
#define IDB_DEFRAGSNAPIN_16             113
#define IDS_LABEL_PERCENT_SIGN          114
#define IDB_DEFRAGSNAPIN_32             114
#define IDS_LABEL_CLUSTER_SIZE          115
#define IDS_LABEL_USED_SPACE            116
#define IDS_LABEL_FREE_SPACE            117
#define IDS_LABEL_PERCENT_FREE_SPACE    118
#define IDS_LABEL_VOLUME_SIZE           119
#define IDS_LABEL_VOLUME_FRAGMENTATION_HEADING 120
#define IDS_LABEL_TOTAL_FRAGMENTATION   121
#define IDS_DK_FAT                      122
#define IDS_DK_TITLE                    122
#define IDB_ESILOGO                     122
#define IDS_DK_NTFS                     123
#define IDS_LABEL_FILE_FRAGMENTATION    124
#define IDB_CRITICALICON                124
#define IDS_LABEL_FREE_SPACE_FRAGMENTATION 125
#define IDS_LABEL_FILE_FRAGMENTATION_HEADING 126
#define IDD_MULTI_INSTANCE              126
#define IDS_LABEL_TOTAL_FILES           127
#define IDI_CRITICAL_ICON               127
#define IDS_LABEL_AVERAGE_FILE_SIZE     128
#define IDS_LABEL_TOTAL_FRAGMENTED_FILES 129
#define IDD_GENERIC_DIALOG              129
#define IDS_LABEL_TOTAL_EXCESS_FRAGMENTS 130
#define IDS_LABEL_AVERAGE_FRAGMENTS_PER_FILE 131
#define IDI_HAPPY                       131
#define IDS_LABEL_PAGEFILE_FRAGMENTATION_HEADING 132
#define IDB_SMILEY                      132
#define IDS_LABEL_PAGEFILE_SIZE         133
#define IDI_APERSAND                    133
#define IDS_LABEL_TOTAL_FRAGMENTS       134
#define IDD_GENERIC_REPORT              134
#define IDS_LABEL_DIRECTORY_FRAGMENTATION_HEADING 135
#define IDS_LABEL_TOTAL_DIRECTORIES     136
#define IDS_LABEL_FRAGMENTED_DIRECTORIES 137
#define IDS_LABEL_EXCESS_DIRECTORY_FRAGMENTS 138
#define IDS_LABEL_MFT_FRAGMENTATION_HEADING 139
#define IDS_LABEL_TOTAL_MFT_SIZE        140
#define IDB_RESERVED_SPACE              141
#define IDS_LABEL_MFT_RECORD_COUNT      141
#define IDB_PAGE_FILE                   142
#define IDS_LABEL_PERCENT_MFT_IN_USE    142
#define IDB_DIRECTORY_FILES             143
#define IDS_LABEL_TOTAL_MFT_FRAGMENTS   143
#define IDB_FRAGMENTED_FILES            144
#define IDS_LABEL_MOST_FRAGMENTED_FILE  144
#define IDB_CONTIGUOUS_FILES            145
#define IDS_LABEL_NONE                  145
#define IDB_FREE_SPACE                  146
#define IDS_LABEL_DRIVE_ANALYZED        146
#define IDS_LABEL_DRIVE_DEFRAGGED       147
#define IDB_CRITICALICON_GREY           147
#define IDS_LABEL_CANCEL_ANALYSIS       148
#define IDS_LABEL_CANCEL_DEFRAG         149
#define IDS_LABEL_DRIVE_CHANGED         150
#define IDS_LABEL_RESTART_DEFRAG        151
#define IDS_LABEL_RESTART_ANALYSIS      152
#define IDS_LABEL_DISK_DEFRAGMENTER     153
#define IDS_LABEL_ONLY_ONE_ANALYSIS     154
#define IDS_LABEL_TERMINATE_ACTION      155
#define IDS_LABEL_ONLY_ONE_DEFRAG       156
#define IDS_LABEL_DEFRAG_COMPLETE       157
#define IDS_LABEL_ANALYSIS_COMPLETE     158
#define IDS_LABEL_CHOOSE_DEFRAGMENT     159
#define IDS_LABEL_NO_CHOOSE_DEFRAGMENT  160
#define IDS_LABEL_VOLUME                161
#define IDS_LABEL_SAVE_DISK_STATS       162
#define IDS_LABEL_TEXT_FILES            163
#define IDS_LABEL_ALL_FILES             164
#define IDS_PRINT_ERROR_MSG             165
#define IDS_ANALYZE                     166
#define IDS_DEFRAGMENT                  167
#define IDS_PAUSE                       168
#define IDS_STOP                        169
#define IDS_SEE_REPORT                  170
#define IDS_LABEL_ANALYSIS_DISPLAY      171
#define IDS_LABEL_DEFRAG_DISPLAY        172
#define IDS_LABEL_RESIZING              173
#define IDS_SAVE_FILE_AS                174
#define IDS_ALLOCATE_MEMORY_ERROR       175
#define IDS_LABEL_MOUNTED_VOLUME        175
#define IDS_SAVE_ERROR                  176
#define IDMSG_BITFAT_ERROR              189
#define IDC_DEFRAGMENT                  201
#define IDC_VOLUME_INFORMATION          203
#define IDC_MOST_FRAGMENTED             204
#define IDC_REPORT                      205
#define IDMSG_DRIVE_CLUSTERS_PER_ROW_SMALL 320
#define IDMSG_ERR_NOT_FAT_PARTITION     402
#define IDMSG_ERR_NOT_NTFS_PARTITION    425
#define IDMSG_SCANFAT_SCAN_ABORT        506
#define IDMSG_SCANNTFS_SCAN_ABORT       507
#define IDMSG_DRIVE_CLUSTERS_PER_ROW_LARGE 515
#define IDMSG_SCANFAT_PRESCAN_ABORT     517
#define IDMSG_SCANNTFS_PRESCAN_ABORT    518
#define IDS_SCANFAT_INIT_ABORT          519
#define IDS_SCANNTFS_INIT_ABORT         520
#define IDS_SCANNTFS_INIT_ABORT2        521
#define IDMSG_4K_CLUSTERSIZE_ABORT      592
#define IDS_INVALID_CMDLINE_DRIVE       593
#define IDMSG_CORRUPT_DISK              594
#define IDMSG_DRIVE_PROPS_CHANGE        595
#define IDS_INFORMATION                 596
#define IDS_ANOTHER_ENGINE_RUNNING      597
#define IDS_FILE_BUG_MESSAGE            598
#define IDS_ERROR                       600
#define IDS_CANT_GET_PATH_NTFS          601
#define IDS_CANT_CLOSE_REG_NTFS         602
#define IDS_CANT_EXPAND_ENV             603
#define IDS_CANT_REGISTER_NTFS_WINDOW   604
#define IDS_CANT_CREATE_RESOURCE        604
#define IDS_CANT_CREATE_NTFS_WINDOW     605
#define IDS_ANALYZING                   606
#define IDS_COMPLETED_ANALYSIS          607
#define IDS_ANALYSIS_COMPLETE_FOR       607
#define IDS_DONE_DEFRAGGING             608
#define IDS_DEFRAGGING                  609
#define IDS_DISPLAY_DRIVE               610
#define IDS_DISPLAY_CLUSTERSIZE         611
#define IDS_DISPLAY_USEDSPACE           612
#define IDS_DISPLAY_FREESPACE           613
#define IDS_DISPLAY_PAGEFILESIZE        614
#define IDS_DISPLAY_PAGEFILEFRAGS       615
#define IDS_DISPLAY_DIRS                616
#define IDS_DISPLAY_FRAGGED_DIRS        617
#define IDS_DISPLAY_EXCESS_DIRS         618
#define IDS_DISPLAY_TOTAL_FILES         619
#define IDS_DISPLAY_AVG_FILE_SIZE       620
#define IDS_DISPLAY_FRAGGEDFILES        621
#define IDS_DISPLAY_EXCESSFRAGS         622
#define IDS_DISPLAY_PERCENTFRAGGED      623
#define IDS_CANT_GET_PATH_FAT           624
#define IDS_CANT_CLOSE_REG_FAT          625
#define IDS_CANT_REGISTER_FAT_WINDOW    626
#define IDS_UNSUPPORTED_NT_VERSION_NTFS 628
#define IDS_UNSUPPORTED_NT_VERSION_FAT  629
#define IDS_UNSUPPORTED_FAT_VERSION     630
#define IDS_UNSUPPORTED_NTFS_VERSION    631
#define IDS_CONTIGUOUS_FILES            632
#define IDS_DIRECTORY_FILES             633
#define IDS_FRAGMENTED_FILES            634
#define IDS_FREE_SPACE                  635
#define IDS_PAGE_FILE                   636
#define IDS_RESERVED_SPACE              637
#define IDS_SYSTEM_FILES                638
#define IDMSG_DIRTY_VOLUME              639
#define IDS_FRAGGED_FILENAME            645
#define IDS_NUM_FRAGMENTS               646
#define IDS_FRAGGED_FILESIZE            647
#define IDS_RESUME                      648
#define IDS_ABOUT                       649
#define IDS_REPORT                      650
#define IDS_TOOLBAR                     651
#define IDS_ANALYZE_STATUS_BAR          652
#define IDS_DEFRAG_STATUS_BAR           653
#define IDS_PAUSE_STATUS_BAR            654
#define IDS_RESUME_STATUS_BAR           655
#define IDS_STOP_STATUS_BAR             656
#define IDS_TOOLBAR_ON_STATUS_BAR       657
#define IDS_TOOLBAR_OFF_STATUS_BAR      658
#define IDS_REPORT_STATUS_BAR           659
#define IDS_ABOUT_STATUS_BAR            660
#define IDS_NEED_ADMIN_PRIVS            661
#define IDS_ANALYSIS_REPORT_TITLE       662
#define IDS_DEFRAG_REPORT_TITLE         663
#define IDS_LOCAL_DISK                  664
#define IDS_DEFRAG_REPORT_DOC_NAME      665
#define IDS_BTN_ANALYZE                 666
#define IDS_BTN_DEFRAGMENT              667
#define IDS_BTN_PAUSE                   668
#define IDS_BTN_RESUME                  669
#define IDS_BTN_STOP                    670
#define IDS_BTN_REPORT                  671
#define IDS_DEFRAG_COMPLETE_FOR         672
#define IDS_LABEL_DEFRAGMENTING         673
#define IDS_LABEL_ANALYZING             674
#define IDS_LABEL_PAUSED                675
#define IDS_LABEL_REANALYZING           676
#define IDS_MOUNTED_VOLUME              677
#define IDS_UNMOUNTED_VOLUME            678
#define IDS_LABEL_CREATING_COLOR_IMAGE  679
#define IDS_FIRST_COLUMN                680
#define IDS_SECOND_COLUMN               681
#define IDS_THIRD_COLUMN                682
#define IDS_FOURTH_COLUMN               683
#define IDS_FIFTH_COLUMN                684
#define IDS_SIXTH_COLUMN                685
#define IDS_LABEL_ANALYZED              686
#define IDS_LABEL_DEFRAGMENTED          687
#define IDS_LABEL_USER_STOPPED          688
#define IDS_LABEL_ANALYZINGDDD          689
#define IDS_LABEL_DEFRAGMENTINGDDD      690
#define IDS_LABEL_REANALYZINGDDD        691
#define IDS_VOLUME_TYPE_NOT_SUPPORTED   692
#define IDS_READONLY_VOLUME             693
#define IDS_REFRESH                     694
#define IDS_REFRESH_STATUS_BAR          695
#define IDS_SNAPIN_DESCRIPTION          696
#define IDS_SNAPIN_VERSION              697
#define IDS_SNAPIN_PROVIDER             698
#define IDS_MUST_RESTART                699
#define IDS_ONLY_ONE_INSTANCE           700
#define IDS_COLUMN_TYPE                 701
#define IDS_COLUMN_DESC                 702
#define IDS_MULTI_INSTANCE_2            703
#define IDS_MULTI_INSTANCE_TITLE        704
#define IDS_MULTI_INSTANCE_1            705
#define IDS_CMD_LINE_OFF                706
#define IDS_HELP                        707
#define IDS_TERMINAL_SERVER_SESSION     708
#define IDS_LABEL_VOLUME_LABEL          709
#define IDS_LABEL_FILE_SYSTEM           710
#define IDS_ERR_2_DRIVES                711
#define IDS_ERR_CONNECT_ENGINE          712
#define IDS_ERR_RELEASE_ENGINE          713
#define IDS_ERR_CREATE_EVENT            714
#define IDS_CMD_LINE_COPYRIGHT          715
#define IDS_IOSTRESS_CMD_LINE           716
#define IDS_OEM_CMD_LINE                717
#define IDS_ERR_BAD_OPTION              718
#define IDS_ERR_SAME_DRIVE              719
#define IDS_NO_USABLE_FREE_SPACE        720
#define IDS_NO_FREE_SPACE               721
#define IDS_ENGINE_DEAD                 722
#define IDS_NO_GRAPHICS_MEMORY          723
#define IDS_CANT_MOVE                   724
#define IDS_FILE_NO_DEFRAG              725
#define IDS_CLOSE                       726
#define IDS_OK                          727
#define IDS_MI_HELP                     728
#define IDS_NO_USABLE_FREE_SPACE_LESS_1 729
#define IDS_NO_FREE_SPACE_LESS_1        730
#define IDS_APM_FAILED_ENGINE           731
#define IDS_LABEL_APM_SUSPEND           732
#define IDS_CMDLINE_COPYRIGHT           733
#define IDS_CMDLINE_USAGE               734
#define IDS_USER_CANCELLED              735
#define IDS_CMDLINE_MULTI_INSTANCE      736
#define IDS_OUT_OF_MEMORY               737
#define IDS_DEFRAG_NOW_ANYWAY           738
#define IDS_CMDLINE_BAD_VOL             739
#define IDS_CMDLINE_UNKNOWN_ERR         740
#define IDS_COMMANDLINE_DESCRIPTION     741
#define IDS_DISK_FULL                   742
#define IDS_COMPACTING_FILES            743
#define IDS_MOVING_FILES                744
#define IDS_CORRUPT_MFT                 745
#define IDS_LABEL_PAUSED_BY_SNAPSHOT    746
#define IDS_DEFRAG_FAILED_FOR_1         747
#define IDS_DEFRAG_FAILED_FOR_2         748
#define IDS_DEFRAG_REPORT_FOR           749
#define IDS_CONCISE_OUTPUT_FORMAT       750
#define IDS_ERR_UNABLE_TO_SAVE_REPORT   751

#define IDC_STATLIST                    1001
#define IDC_STATIC_TEXT                 1002
#define IDC_STATIC_TEXT2                1003
#define IDC_VOLUME_INFORMATION_TEXT     1004
#define IDC_MOST_FRAGMENTED_TEXT        1006
#define IDC_ANALYSIS_RESULTS            1007
#define IDC_DEFRAG_RESULTS              1008
#define IDC_EDIT1                       1011
#define IDC_GENERIC_EDITBOX             1011
#define IDC_MOST_FRAGMENT_LABEL         1011
#define IDC_EDITBOX_TEXT                1011
#define IDC_GENERIC_REPORT_VOLUME_LABEL 1012
#define IDC_SAVE                        1013
#define IDC_GENERIC_REPORT_LABEL        1013
#define IDC_PRINT                       1014
#define IDC_MI_HELP                     1015
#define IDC_MI_TEXT                     1016
#define IDC_FUTILE_TEXT                 1017
#define ID_GENERIC_BUTTON0              1020
#define ID_GENERIC_BUTTON1              1021
#define ID_GENERIC_BUTTON2              1022
#define ID_GENERIC_BUTTON3              1023
#define ID_GENERIC_BUTTON4              1024
#define IDC_GENERIC_ICON                1025
#define ID_GENERIC_REPORT_BUTTON0       1026
#define ID_GENERIC_REPORT_BUTTON1       1027
#define ID_GENERIC_REPORT_BUTTON2       1028
#define ID_GENERIC_REPORT_BUTTON3       1029
#define IDC_GENERIC_REPORT_VOLUME_INFO  1030
#define IDC_LIST1                       1035
#define IDC_DIVIDE_LINE                 1036


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\diskdisp.h ===
/*****************************************************************************************************************

FILENAME: DiskDisp.hpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#ifndef _DISKDISP_H
#define _DISKDISP_H

#include "windows.h"
#include "tchar.h"

#define BLACK       0
#define RED         1
#define GREEN       2
#define YELLOW      3
#define BLUE        4
#define PURPLE      5
#define LIGHTBLUE   6
#define WHITE       7
#define LIGHTGRAY   8

#define GRAPHIC_WELL_HEIGHT     20
#define SPACER_HEIGHT           10

#define INDENTED_BORDER     1
#define RAISED_BORDER       2

#define SystemFileColor             0
#define PageFileColor               1
#define FragmentColor               2
#define UsedSpaceColor              3
#define FreeSpaceColor              4
#define DirectoryColor              5
#define MftZoneFreeSpaceColor       6
#define NUM_COLORS                  7

/*****************************************************************************************************************

    m_hCurrentPen - The pen selected into the DC last time DrawLine was called (used so we don't keep reselecting the same pen into the same DC).
    m_hCurrentBrush - The brush last selected.
    m_PenArray - An array of pens of different colors that we use to draw the lines.
    m_BrushArray - An array of brushes we also use to draw the lines.
    m_ColorArray - An array of colors for our lines.
    m_Clusters - The number of clusters on this drive.
    m_NumLines - How many lines we have in m_LineArray.
    m_LineArray - The array of bytes that store the color code for each line to display.

INPUT + OUTPUT:
    hInstance - Passed in value for m_hInst.
    InClusters - Passed in value for m_Clusters.
    xInMax - Passed in value for m_xMax.
    yInMax - Passed in value for m_yMax.
    DiskSize - Passed in value for m_DiskMegs.
    cInDrive - Passed in value for cDrive.

RETURN:
    None.
*/
class DiskDisplay 
{
private:
    RECT m_Rect;                // rectangle that bounds the entire graphics area
    int m_NumGraphicsRows;      // number of graphics wells (calculated)
    int m_SpacerHeight;         // space between graphics wells
    int m_GraphicWellHeight;    // calculated height of graphic wells
    int m_GraphicWellWidth;     // width of wells (usually the rectangle width)
    int m_NumLines;             // number of lines (stripes) in the display (includes all graphic wells)
    char * m_LineArray;         // array of lines - stores the colors
    HPEN * m_PenArray;          // array of pens
    HBRUSH * m_BrushArray;      // array of brushes
    int * m_ColorArray;         // array of colors of the lines
    HPEN m_hCurrentPen;         // set to the current pen
    HBRUSH m_hCurrentBrush;     // set to the current brush
    TCHAR m_Label[MAX_PATH * 2];
    BOOL m_bReadyToDraw;
    BOOL m_bStripeMftZone;

public:
    DiskDisplay::DiskDisplay();
    ~DiskDisplay();
    DiskDisplay& DiskDisplay::operator=(DiskDisplay&);
    void SetOutputArea(RECT rect, BOOL isSingleRow=TRUE, UINT spacerHeight = SPACER_HEIGHT);
    void ChangeLineColor(int, int);
    void SetNewLineColor(int, int);
    void StripeMftZoneFreeSpace(BOOL);
    void DrawLinesInHDC(HDC);
    inline void DiskDisplay::DrawLine(HDC, char, int, int, int);
    int GetLineCount() {return m_NumLines;}
    void SetLineArray(char*, int);
    void SetReadyToDraw(BOOL);
    void SetDiskSize(int inClusters, int inDiskMegs);
    void UpdateOutputDimensions();
    void DeleteAllData();
    BOOL NoGraphicsMemory() {return (m_LineArray == NULL || m_PenArray == NULL || m_ColorArray == NULL || m_BrushArray == NULL);}
    void SetLabel(PTCHAR InLabel);

};


#endif // #define _DISKDISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\diskview.h ===
/*****************************************************************************************************************

FILENAME: diskview.hpp

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#ifndef _DISKVIEW_H
#define _DISKVIEW_H

class DiskView {
private:
	int Clusters;			// number of clusters on the disk
	int ClusterArraySize;	// number of elements in pClusterArray
	int NumLines;			// number of lines in the line array
	int ClusterFactor;		// number of clusters per line in the line array
	int MftZoneStart;		// first cluster of the MFT zone (or reserved space)
	int MftZoneEnd;			// last cluster of the MFT zone (or reserved space)
	char * pClusterArray;	// memory array holding data about the fragmented or contiguous 
							// etc state for each cluster on the volume 
							// (one nibble per cluster)
	char * pLineArray;		// memory array holding condensed cluster data for GUI
	BOOL m_bIsDataSent;
	BOOL m_IsActive;		// is this DiskView in use
	UINT m_FragColorThreshold;	// required % fragmented clusters to turn line red
	BOOL m_bMemAllocFailed;	// failed to allocate cluster or line array

    INT m_nFreeDelta;
    INT m_nFragDelta;
    INT m_nNonMovableDelta;
    INT m_nUsedDelta;

	void InitFragColorThreshold();
	BOOL TransferToLineArray();
	BOOL Invariant() const;

	CRITICAL_SECTION m_CriticalSection;

public:
	DiskView(const int, const int, const int);
	DiskView(const DiskView&);
	DiskView();
	DiskView& operator=(const DiskView&);
	~DiskView();

	BOOL IsActive() {return m_IsActive;}
	BOOL IsDataSent() {return m_bIsDataSent;}
	BOOL HasMapMemory() const;

	void SetNumLines(const int numLines);
	void SetClusterCount(const int InClusters);
	void SetMftZone(const int InZoneStart, const int InZoneEnd);

	BOOL GetLineArray(char ** ppOutLineArray, DWORD *pNumLines);
	void UpdateClusterArray(PBYTE);
	void EnterMyCriticalSection();
	void LeaveMyCriticalSection();

};


// must match DiskDisp.h
#define SystemFileColor				0		// green
#define PageFileColor				1		// green
#define FragmentColor				2		// red
#define UsedSpaceColor				3		// blue
#define FreeSpaceColor				4		// white
#define DirectoryColor				5		// blue
#define MftZoneFreeSpaceColor		6		// green

#define NUM_COLORS					7

#define DirtyColor					12

#endif // #define _DISKVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\esbutton.h ===
/*****************************************************************************************************************

FILENAME: ESButton.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
*/

#ifndef _ESBUTTON_H_
#define _ESBUTTON_H_


class ESButton
{
private:
    HWND m_hwndButton;

public:
    ESButton(HWND hwndParent, UINT ButtonId, HINSTANCE hInstance);
    ~ESButton();

    BOOL ShowButton(int cmdShow);
    BOOL PositionButton(RECT* prcPos);
    BOOL SetText(TCHAR* szNewText);
    BOOL LoadString(HINSTANCE hInstance, UINT labelResourceID);
    BOOL SetFont(HFONT hNewFont);
    BOOL EnableButton(BOOL bEnable);
    BOOL ShowWindow(UINT showState);
    BOOL IsButtonEnabled(void);
    HWND GetWindowHandle(void) {return m_hwndButton;};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\errmsg.h ===
/**************************************************************************************************

FILENAME: ErrMsg.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Error messaging for specific user friendly errors: not bugs.
		For example, not a valid drive.

***************************************************************************************************/

//The MessageBox routine which will print out the user friendly errors.
BOOL
ErrorMessageBox(
        TCHAR* cMsg,
		TCHAR* cTitle
        );

//Dialog to tell the user to file a bug report with Microsoft.
BOOL
FileBugReportMessage(
	TCHAR* cMsg,
	TCHAR* cTitle
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\event.h ===
/*  MESSAGE.MC

 This file contains the message definitions for Diskeeper.
-------------------------------------------------------------------------
 HEADER SECTION

 The header section defines names and language identifiers for use
 by the message definitions later in this file. The MessageIdTypedef,
 SeverityNames, FacilityNames, and LanguageNames keywords are
 optional and not required.
 The MessageIdTypedef keyword gives a typedef name that is used in a
 type cast for each message code in the generated include file. Each
 message code appears in the include file with the format: #define
 name ((type) 0xnnnnnnnn) The default value for type is empty, and no
 type cast is generated. It is the programmer's responsibility to
 specify a typedef statement in the application source code to define
 the type. The type used in the typedef must be large enough to
 accomodate the entire 32-bit message code.
 The SeverityNames keyword defines the set of names that are allowed
 as the value of the Severity keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 severity name is a number that, when shifted left by 30, gives the
 bit pattern to logical-OR with the Facility value and MessageId
 value to form the full 32-bit message code. The default value of
 this keyword is:

 SeverityNames = (
       Success=0x0
       Informational=0x1
       Warning=0x2
       Error=0x3)

 Severity values occupy the high two bits of a 32-bit message code.
 Any severity value that does not fit in two bits is an error. The
 severity codes can be given symbolic names by following each value
 with :name
 The FacilityNames keyword defines the set of names that are allowed
 as the value of the Facility keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 facility name is a number that, when shift it left by 16 bits, gives
 the bit pattern to logical-OR with the Severity value and MessageId
 value to form the full 32-bit message code. The default value of
 this keyword is:

FacilityNames = (
       System=0x0FF
       Application=0xFFF)

 Facility codes occupy the low order 12 bits of the high order
 16-bits of a 32-bit message code. Any facility code that does not
 fit in 12 bits is an error. This allows for 4,096 facility codes.
 The first 256 codes are reserved for use by the system software. The
 facility codes can be given symbolic names by following each value
 with :name
 The LanguageNames keyword defines the set of names that are allowed
 as the value of the Language keyword in the message definition. The
 set is delimited by left and right parentheses. Associated with each
 language name is a number and a file name that are used to name the
 generated resource file that contains the messages for that
 language. The number corresponds to the language identifier to use
 in the resource table. The number is separated from the file name
 with a colon. The initial value of LanguageNames is:

 LanguageNames=(English=1:MSG00001)

 Any new names in the source file which don't override the built-in
 names are added to the list of valid languages. This allows an
 application to support private languages with descriptive names.
-------------------------------------------------------------------------
 MESSAGE DEFINITION SECTION

 Following the header section is the body of the Message Compiler
 source file. The body consists of zero or more message definitions.
 Each message definition begins with one or more of the following
 statements:

 MessageId = [number|+number]
 Severity = severity_name
 Facility = facility_name
 SymbolicName = name

 The MessageId statement marks the beginning of the message
 definition. A MessageID statement is required for each message,
 although the value is optional. If no value is specified, the value
 used is the previous value for the facility plus one. If the value
 is specified as +number then the value used is the previous value
 for the facility, plus the number after the plus sign. Otherwise, if
 a numeric value is given, that value is used. Any MessageId value
 that does not fit in 16 bits is an error.

 The Severity and Facility statements are optional. These statements
 specify additional bits to OR into the final 32-bit message code. If
 not specified they default to the value last specified for a message
 definition. The initial values prior to processing the first message
 definition are:

 Severity=Success
 Facility=Application

 The value associated with Severity and Facility must match one of
 the names given in the FacilityNames and SeverityNames statements in
 the header section. The SymbolicName statement allows you to
 associate a C/C++ symbolic constant with the final 32-bit message
 code.
 */
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_STUBS                   0x3
#define FACILITY_RUNTIME                 0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MSG_SETUP_SUCCESS
//
// MessageText:
//
//  Diskeeper for Windows NT has been successfully installed.
//
#define MSG_SETUP_SUCCESS                ((DWORD)0x00000001L)

//
// MessageId: MSG_CONTROL_START
//
// MessageText:
//
//  The Diskeeper Control Center has been started.
//  %1
//
#define MSG_CONTROL_START                ((DWORD)0x40000002L)

//
// MessageId: MSG_CONTROL_CLOSE
//
// MessageText:
//
//  The Diskeeper Control Center has been shut down.
//
#define MSG_CONTROL_CLOSE                ((DWORD)0x40000003L)

//
// MessageId: MSG_CONTROL_EXCLUDE
//
// MessageText:
//
//  The Diskeeper exclusion list and drive scheduling file has been changed.
//
#define MSG_CONTROL_EXCLUDE              ((DWORD)0x40000004L)

//
// MessageId: MSG_CONTROL_SCHEDULE
//
// MessageText:
//
//  Diskeeper "Set It and Forget It" has been started. %1
//
#define MSG_CONTROL_SCHEDULE             ((DWORD)0x40000005L)

//
// MessageId: MSG_CONTROL_ERROR
//
// MessageText:
//
//  Diskeeper Control Center - ERROR
//  %1
//
#define MSG_CONTROL_ERROR                ((DWORD)0xC0000006L)

//
// MessageId: MSG_ENGINE_START
//
// MessageText:
//
//  The Diskeeper Engine has started for drive %1
//
#define MSG_ENGINE_START                 ((DWORD)0x40000007L)

//
// MessageId: MSG_ENGINE_CLOSE
//
// MessageText:
//
//  The Diskeeper Engine has shut down for drive %1
//
#define MSG_ENGINE_CLOSE                 ((DWORD)0x40000008L)

//
// MessageId: MSG_ENGINE_DEFRAGMENT
//
// MessageText:
//
//  Diskeeper has successfully defragmented file %1
//
#define MSG_ENGINE_DEFRAGMENT            ((DWORD)0x00000009L)

//
// MessageId: MSG_ENGINE_FREE_SPACE
//
// MessageText:
//
//  Diskeeper has successfully consolidated free space by moving file %1
//
#define MSG_ENGINE_FREE_SPACE            ((DWORD)0x0000000AL)

//
// MessageId: MSG_ENGINE_EXCLUDE
//
// MessageText:
//
//  Diskeeper has excluded file %1
//
#define MSG_ENGINE_EXCLUDE               ((DWORD)0x0000000BL)

//
// MessageId: MSG_ENGINE_ERROR
//
// MessageText:
//
//  Diskeeper Engine - ERROR
//  %1
//
#define MSG_ENGINE_ERROR                 ((DWORD)0xC000000CL)

//
// MessageId: MSG_DEFRAG_SUMMARY
//
// MessageText:
//
//  The Diskeeper Defragemention Summary
//  %1
//

#define MSG_DEFRAG_SUMMARY               ((DWORD)0x4000000DL)

//
// MessageId: MSG_DISK_INFO
//
// MessageText:
//
//  Diskeeper Message Disk Information for Drive
//  %1
//
#define MSG_DISK_INFO                    ((DWORD)0x4000000FL)

//
// MessageId: MSG_FILE_INFO
//
// MessageText:
//
//  Diskeeper Message File Information
//  %1
//
#define MSG_FILE_INFO                    ((DWORD)0x40000010L)

//
// MessageId: MSG_PAGE_FILE_INFO
//
// MessageText:
//
//  Diskeeper Message PageFile Information for Drive
//  %1
//
#define MSG_PAGE_FILE_INFO               ((DWORD)0x40000011L)

//
// MessageId: MSG_DIRECTORIS_INFO
//
// MessageText:
//
//  Diskeeper Message Directory Information for Drive
//  %1
//
#define MSG_DIRECTORIS_INFO              ((DWORD)0x40000012L)

//
// MessageId: MSG__MFT_INFO
//
// MessageText:
//
//  Diskeeper Message MFT Information for Drive
//  %1
//
#define MSG__MFT_INFO                    ((DWORD)0x40000013L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\errlog.h ===
/**************************************************************************************************

FILENAME: ErrLog.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

//Initializes the error log.
BOOL
InitializeErrorLog (
    IN PTCHAR   pErrLogName,
	IN PTCHAR   pLoggerIdentifier
    );

//Writes a message to the error log.
void
WriteErrorToErrorLog(
    IN LPTSTR pMessage,
    IN HRESULT  hr,
    IN LPTSTR pParameter1
    );

//Closes the error log.
void
ExitErrorLog (
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\exclude.h ===
/**************************************************************************************************

FILENAME: Exclude.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Exclusion list handling..

**************************************************************************************************/

//Loads the excluded file list.
BOOL
GetExcludeFile(
        IN PTCHAR cExcludeFile,
        OUT PHANDLE phExcludeList
        );

//Checks to see if a file is excluded.
BOOL
CheckFileForExclude(
	IN CONST fAcceptNameOnly = FALSE
        );

BOOL
lStrWildCmp (
             IN PTCHAR   pOrigSourceString,
             IN PTCHAR   pOrigPatternString,
             IN BOOL     bCaseType
             );
#ifdef DKNT30

#include "pipes.h"

    BOOL RequestExcludeDataFromController(
	    HANDLE hSendDataMutex,
	    PIPEHEADER* psPipeHeaderOut,
	    PIPEDATA* psPipeDataOut,
	    TCHAR* cControlPipe
	    );

    BOOL SendExcludeDataToGui(
	    HANDLE hSendDataMutex,
	    PIPEHEADER* psPipeHeaderOut,
	    PIPEDATA* psPipeDataOut,
	    TCHAR* cControlFileName,
	    TCHAR* cGuiPipe
	    );

    BOOL SendExcludeDataToController(
	    HANDLE hSendDataMutex,
	    PIPEHEADER* psPipeHeaderOut,
	    PIPEDATA* psPipeDataOut,
	    char* pControlFile,
	    DWORD dwControlFileSize,
	    TCHAR* cControlPipe
	    );

    BOOL SetNewExcludeData(
	    char* pNewControl,
	    DWORD dwNewControlFileSize,
	    TCHAR* cControlFileName,
	    TCHAR* cInstallPath
	    );

    BOOL APIENTRY ExcludeDialog(
	    HWND hDlg,
	    UINT uMsg,
	    UINT wParam,
	    LONG lParam
	    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\extents.h ===
/****************************************************************************************************************

FILENAME: Extents.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    File system extent handling prototypes.

***************************************************************************************************************/
#include "stdafx.h"

//Creates the extent buffer.
BOOL
CreateExtentBuffer(
        );

//Purges the buffer and then destroys it.
BOOL
DestroyExtentBuffer(
        );

//Adds extents to the extent buffer.
BOOL
AddExtents(
        BYTE Color
        );

BOOL
AddExtentsStream(
	BYTE Color,
	STREAM_EXTENT_HEADER* pStreamExtentHeader
	);

//Adds one chunk to the extent buffer (Called by AddExtents)
BOOL
AddExtentChunk(
	BYTE Color,
	EXTENT_LIST* pExtentList,
	LONGLONG ExtentsAdded,
    LONGLONG lExtentCount
	);

//Sends all the data in the extent buffer to DiskView and zeroes the buffer out so more extents can be added.
BOOL
PurgeExtentBuffer(
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\fastfat2.h ===
/**************************************************************************************************

FILENAME: FastFat2.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Fat file sytem prototypes.

**************************************************************************************************/

// Define some special character codes used in FAT directory entries
#define Deleted				0xe5			//The code placed in the first byte of the filename on a deleted fat entry.
#define DirPointer			0x2e			//The code placed in the first byte of the filename on a Directory Pointer fat entry.

//The attribute field of a FAT entry can be set to any of the following (which identifies what kind of entry it is):
#define EndOfDirectory		0x0
#define LabelAttribute		0x8
#define DirAttribute		0x10
#define UnicodeAttribute	0x0F

#define MaxDirs 128						//We cannnot have a directory tree more than 128 directories deep.

//Flags for which types of FAT entries are kept by StripDir (see StripDir() below).
#define KEEP_DIRECTORIES	0x01
#define KEEP_FILES			0x02
#define KEEP_DELDIRECTORIES 0x04
#define KEEP_DELFILES       0x08

typedef struct {
	HANDLE FatTreeHandles[MaxDirs];			//Handles to each FAT directory in our chain
	DIRSTRUC* pCurrentFatDir;				//Pointer to the beginning of the current FAT directory
	DIRSTRUC* pCurrentFatDirEnd;			//Pointer to the end of the current FAT directory
	DIRSTRUC* pCurrentEntry;				//Pointer to the current entry in the current FAT directory
	DWORD dwCurrentEntryNum;				//Number of the current entry in the current FAT directory
	DWORD CurrentEntryPos[MaxDirs];			//Number of the current entry in each level of the FAT chain
	TCHAR DirName[MaxDirs][MAX_PATH];		//Name of each directory at each level of our FAT chain
	DWORD dwCurrentLevel;					//Which level we're at - 0 is root.
	BOOL bMovedUp;							//If we moved up a directory, files have already been processed at this level.
	BOOL bProcessingFiles;					//Whether or not we are processing files at this level (as compared to directories).
	LONGLONG llCurrentFatDirLcn[MaxDirs];	//LCN of the current FAT Directory
} TREE_DATA;

//extern  TREE_DATA TreeData;

//
// Routine Declarations
//

//Gets data from the boot sector of a FAT drive.  Initializes NextFatFile.
BOOLEAN
GetFatBootSector(
        );

//Gets one at a time files on a FAT drive by directly traversing a directory tree.
BOOL
NextFatFile(
        );

//Strips a directory of unused/unwanted entries.  Called by NextFatFile.
BOOL
StripDir(
	TREE_DATA* pTreeData,
	DWORD dwFlags
	);

//Reads a new directory from the disk.  Called by NextFatFile.
BOOL
LoadDir(
	TREE_DATA* pTreeData
	);

//Gets the unicode name for a file from its directory.  Called by NextFatFile.
BOOL
GetUnicodeName(
	TREE_DATA* pTreeData,
	VString &unicodeName
	);

//Gets the full unicode path for a file by traversing up it's directory tree.  Called by NextFatFile.
BOOL
GetUnicodePath(
	IN TREE_DATA* pTreeData,
	OUT VString &unicodePath
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\expand.h ===
/**************************************************************************************************

FILENAME: Expand.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Handles expansion of system defines into their values within strings.

**************************************************************************************************/

//Replace environment variables with their values in a string.
BOOL
ExpandEnvVars(
    IN OUT TCHAR * pString
    );


LPTSTR 
GetHelpFilePath();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\fatsubs.h ===
/**************************************************************************************************

FILENAME: FatSubs.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Prototypes for the FAT file system.

**************************************************************************************************/

//Gets the basic statistics for a FAT volume (cluster size, etc.
BOOL
GetFatVolumeStats(
        );

//Gets the extent list of a FAT file.
BOOL
GetExtentList(
	DWORD dwEnabledStreams,
	FILE_RECORD_SEGMENT_HEADER* pFrs
	);

//0.0E00 This may not be the ideal number.  This will use a maximum of 32K on even the largest FAT drive
//since that's the largest cluster size.  I didn't see any performance gain on my computer by reading
//multiple clusters.  So I saved memory instead.
#define CLUSTERS_PER_FAT_CHUNK 1

//Gets the extent list of a FAT file by going directly to disk (bypasses OS).
BOOL
GetExtentListManuallyFat(
        );

//Opens a FAT file.
BOOL
OpenFatFile(
        );

//Gets the next FAT file for defrag.
BOOL
GetNextFatFile(
        DWORD dwMoveFlags
        );

//Adds a file to the file list on a FAT volume.
BOOL
AddFileToListFat(
	OUT FILE_LIST_ENTRY* pList,
	IN OUT ULONG* pListIndex,
	IN ULONG ListSize,
	IN UCHAR* pExtentList
	);

BOOL
UpdateInFileList(
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\errmacro.h ===
/**************************************************************************************************

FILENAME: ErrMacro.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Error handling macros.

**************************************************************************************************/

#include <assert.h>


// set up some aliases
#define require(exp)	assert(exp)
#define ensure(exp)		assert(exp)
#define invariant(exp)	assert(exp)

#define LOG_ERR()		LogErrForMacro(TEXT(__FILE__), TEXT(__TIMESTAMP__), __LINE__)

// handle logging to message window and or error log file
void LogErrForMacro(LPTSTR filename, LPTSTR timestamp, UINT lineno);


/****************************** EF DEFINITIONS ***************************************/
//EF's will return debugging information in debug mode, but will not compile in for release builds.

//If an error occurs, handle and return FALSE
#define EF(FunctionCall)		\
{								\
	if (!(FunctionCall)) {		\
		LOG_ERR();				\
		return FALSE;			\
	}							\
}

//If an error occurs, handle and continue on without returning
#define EH(FunctionCall)		\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
	}							\
}

//If an error occurs, handle and return NULL
#define EN(FunctionCall)		\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		return NULL;			\
	}							\
}

//If an error occurs, handle and return VOID
#define EV(FunctionCall)		\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		return;					\
	}							\
}

//If an error occurs, handle and break (not return)
#define EB(FunctionCall)		\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		break;					\
	}							\
}

//If an error occurs, handle and continue (not return)
#define EC(FunctionCall)		\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		continue;				\
	}							\
}

//If an error occurs, handle and return E_FAIL
#define EE(FunctionCall)		\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		return E_FAIL;			\
	}							\
}

//If an error occurs, handle and return -1
#define EM(FunctionCall)		\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		return -1;				\
	}							\
}

/****************************** EF DEFINITIONS ***************************************/
//EF_ASSERTS's are the same as EF's, except they assert before returning.

//If an error occurs, handle and return FALSE
#define EF_ASSERT(FunctionCall)	\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		assert(FALSE);			\
		return FALSE;			\
	}							\
}

//If an error occurs, handle and continue on without returning
#define EH_ASSERT(FunctionCall)	\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		assert(FALSE);			\
	}							\
}

//If an error occurs, handle and return NULL
#define EN_ASSERT(FunctionCall)	\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		assert(FALSE);			\
		return NULL;			\
	}							\
}

//If an error occurs, handle and return VOID
#define EV_ASSERT(FunctionCall)	\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		assert(FALSE);			\
		return;					\
	}							\
}

//If an error occurs, handle and break (not return)
#define EB_ASSERT(FunctionCall)	\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		assert(FALSE);			\
		break;					\
	}							\
}

//If an error occurs, handle and continue (not return)
#define EC_ASSERT(FunctionCall)	\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		assert(FALSE);			\
		continue;				\
	}							\
}

//If an error occurs, handle and return E_FAIL
#define EE_ASSERT(FunctionCall)	\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		assert(FALSE);			\
		return E_FAIL;			\
	}							\
}

//If an error occurs, handle and return -1
#define EM_ASSERT(FunctionCall)	\
{								\
	if(!(FunctionCall)) {		\
		LOG_ERR();				\
		assert(FALSE);			\
		return -1;				\
	}							\
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\fraggedfilelist.h ===
//=============================================================================*
// COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
//=============================================================================*
//       File:  FraggedFileList.h
//=============================================================================*

#ifndef _FRAGGEDFILELIST_H
#define _FRAGGEDFILELIST_H


#include "stdafx.h"
//#include "diskview.h"
//#include "dfrgcmn.h"
//#include "fssubs.h"
//#include "VolCom.h"

// from the c++ library
//#include "vString.hpp"
#include "vPtrArray.hpp"

//This is the number of most fragmented files to keep track of.
#define MAX_MOST_FRAGGED_FILES  30

#ifndef GUID_LENGTH
#define GUID_LENGTH 51
#endif

#ifndef MAX_UNICODE_PATH
#define MAX_UNICODE_PATH 32000
#endif

//-------------------------------------------------------------------*
// Class that represents a fragged file
//-------------------------------------------------------------------*
class CFraggedFile{
private:

    LONGLONG    m_ExtentCount;
    LONGLONG    m_FileSize;

    PTCHAR      m_cFileName;
    TCHAR       m_cFileSize[32];
    TCHAR       m_cExtentCount[32];

public:
    CFraggedFile(void);
    CFraggedFile(PTCHAR cFileName, LONGLONG fileSize, LONGLONG extentCount);
    ~CFraggedFile(void);

    LONGLONG    FileSize(void);
    LONGLONG    ExtentCount(void);

    PTCHAR      FileName(void) {return m_cFileName;}
    PTCHAR      FileNameTruncated(UINT MaxLen);
    PTCHAR      cExtentCount(void) {return m_cExtentCount;}
    PTCHAR      cFileSize(void) {return m_cFileSize;}
    void        ExtentCount(LONGLONG extentCount) {m_ExtentCount = extentCount;}
    void        FileSize(LONGLONG fileSize) {m_FileSize = fileSize;}
    UINT        FileNameLen(void);

};

//-------------------------------------------------------------------*
// Class that represents the list of fragmented files
//-------------------------------------------------------------------*
class CFraggedFileList
{
private:
    VPtrArray       m_FraggedFileList; // array of pointers to CFraggedFile object
    TCHAR           m_cVolumeName[GUID_LENGTH];
    HANDLE          m_hTransferBuffer;
    PTCHAR          m_pTransferBuffer;
    DWORD           m_TransferBufferSize;
    LONGLONG        m_MinExtentCount;
    int             m_MinIndex;



public:
    CFraggedFileList(PTCHAR cVolumeName);
    CFraggedFileList(void);
    ~CFraggedFileList(void);
    CFraggedFile*   GetAt(UINT i);
    int             Add(PTCHAR cFileName, LONGLONG fileSize, LONGLONG extentCount);
    BOOL            RemoveAt(UINT i);
    void            RemoveAll(void);
    UINT            Size(void) {return m_FraggedFileList.Size();}
    BOOL            CreateTransferBuffer(void);
    BOOL            DeleteTransferBuffer(void);
    DWORD           GetTransferBufferSize(void) {return m_TransferBufferSize;}
    BOOL            ParseTransferBuffer(PTCHAR pTransferBuffer);
    PTCHAR          GetTransferBuffer(void);
    inline LONGLONG GetMinExtentCount() {return m_MinExtentCount;}
};

#endif // #define _FRAGGEDFILELIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\getdfrgres.h ===
#ifndef __GETDFRGRES_H
#define __GETDFRGRES_H

#include "DfrgRes.h"
#include <windef.h>

HINSTANCE GetDfrgResHandle(BOOL fReset = FALSE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\fssubs.h ===
/****************************************************************************************************************

FILENAME: FsSubs.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

***************************************************************************************************************/

#ifndef _FSSUBS_H_
#define _FSSUBS_H_

#include "dfrgengn.h"
#include "FraggedFileList.h"

#ifdef OFFLINEDK
BOOL
GetFileSystem(
    IN TCHAR DriveLetter,
    OUT PULONG pFileSystem
    );
#else
BOOL
GetFileSystem(
    IN PTCHAR volumeName,
    OUT PULONG pFileSystem,
    OUT TCHAR* pVolumeLabel
    );
#endif

//Reduces an extent list to an actual extent list as can be seen on the disk.
//Sometimes extent lists contain two or more factually contiguous "extents".
BOOL
CollapseExtentList(
    EXTENT_LIST_DATA* pExtentData
    );

BOOL
CountStreamExtentsAndClusters(
    DWORD dwStreamNumber,
    LONGLONG* pExcessExtents,
    LONGLONG* pClusters
    );

//Gets the earliest Lcn of the file on the drive.
BOOL
GetLowestStartingLcn(
    OUT LONGLONG* pStartingLcn,
    FILE_EXTENT_HEADER* pFileExtentHeader
    );

BOOL
FillMostFraggedList(
	CFraggedFileList &fraggedFileList, 
	IN CONST BOOL fAnalyseOnly = FALSE
	);

// compresses long paths into 50 character paths
BOOL ESICompressFilePath(
    IN PTCHAR infilePath,
    OUT PTCHAR outFilePath
);

// compresses long paths into 50 character paths, in place
TCHAR * ESICompressFilePath(
    IN PTCHAR inFilePath
);

BOOL
IsVolumeDirty(
    void
    );

BOOL
IsVolumeRemovable(
    PTCHAR volumeName
);

BOOL
IsFAT12Volume(
    PTCHAR volumeName
);

void FormatDisplayString(
    TCHAR driveLetter, 
    PTCHAR volumeLabel,
    PTCHAR displayLabel
);

//*************************************
//
// These are for NT5 only
//
//*************************************

#define MAX_MOUNT_POINTS 10

#ifndef VER4 // NT5 version

BOOL GetDriveLetterByGUID(
    PTCHAR volumeName, 
    TCHAR &driveLetter
);

BOOL GetMountPointList(
    VString Name, // path to a mount point (start with a drive letter)
    PWSTR   VolumeName, // guid of volume in question
    VString mountPointList[MAX_MOUNT_POINTS],
    UINT    &mountPointCount
);

// gets the mount point list given a guid
void GetVolumeMountPointList(
    PWSTR volumeName,
    VString mountPointList[MAX_MOUNT_POINTS],
    UINT  &mountPointCount
);

// overload of NT4 version for use with NT5
void FormatDisplayString(
    TCHAR driveLetter, 
    PTCHAR volumeLabel,
    VString mountPointList[MAX_MOUNT_POINTS],
    UINT  mountPointCount,
    PTCHAR displayLabel
);


// check if enough free space exists to defrag
BOOL ValidateFreeSpace(BOOL bCommandLineMode, LONGLONG llFreeSpace, LONGLONG llUsableFreeSpace, 
                       LONGLONG llDiskSize, TCHAR *VolLabel, TCHAR *returnMsg, UINT returnMsgLen);

BOOL IsBootVolume(
        IN TCHAR tDrive
        );

#endif // #ifndef VER4

#endif //#ifndef _FSSUBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\genericdialog.h ===
/*****************************************************************************************************************

FILENAME: GenericDialog.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
*/

#ifndef _GENERICDIALOG_H_
#define _GENERICDIALOG_H_

class CGenericDialog
{
private:


	// position of the buttons
	// in absolute coodinates


public:

	CGenericDialog(void);
	~CGenericDialog(void);
	UINT DoModal(HWND hWndDialog);
	void SetTitle(TCHAR * tDialogBoxTitle);
	void SetTitle(UINT uResID);
	void SetButtonText(UINT uIndex, TCHAR * tButtonText);
	void SetButtonText(UINT uIndex, UINT uResID);
	void SetHelpFilePath();
	void SetIcon(UINT uResID);
	void SetText(TCHAR * tEditBoxText);
	void SetText(UINT uResID);
	void SetButtonHelp(UINT uIndex, DWORD dHelpContextID);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\freespace.h ===
/**************************************************************************************************

FILENAME: Freespace.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Free space location prototypes.

**************************************************************************************************/

#ifndef _FREESPACE_H_
#define _FREESPACE_H_

typedef struct _FILE_LIST_ENTRY *PFILE_LIST_ENTRY;
typedef struct _FREE_SPACE_ENTRY *PFREE_SPACE_ENTRY;

PVOID
PreviousEntry(
    IN PVOID pCurrentEntry
    );

PVOID
LastEntry(
    IN PRTL_AVL_TABLE Table
    );

BOOL
BuildFreeSpaceList(
    IN OUT PRTL_GENERIC_TABLE pFreeSpaceTable,
    IN CONST LONGLONG MinClusterCount,
    IN CONST BOOL bSortBySize,
    OUT LONGLONG *pBiggestFreeSpaceClusterCount = NULL,
    OUT LONGLONG *pBiggestFreeSpaceStartingLcn = NULL,
    IN CONST BOOL bIgnoreMftZone = FALSE
    );

BOOL
BuildFreeSpaceListWithExclude(
	IN OUT PRTL_GENERIC_TABLE pFreeSpaceTable,
    IN CONST LONGLONG MinClusterCount,
    IN CONST LONGLONG ExcludeZoneStart,
    IN CONST LONGLONG ExcludeZoneEnd,
    IN CONST BOOL bSortBySize,
    IN CONST BOOL bExcludeMftZone = TRUE
    );

BOOL
BuildFreeSpaceListWithMultipleTrees(
    OUT LONGLONG *pMaxClusterCount,
    IN CONST LONGLONG IncludeZoneStartingLcn = 0,
    IN CONST LONGLONG IncludeZoneEndingLcn = 0
    );

BOOL 
FindFreeSpace(
	IN PRTL_GENERIC_TABLE pTable,
    IN BOOL DeleteUnusedEntries,
    IN LONGLONG MaxStartingLcn
    );

BOOL
FindSortedFreeSpace(
	IN PRTL_GENERIC_TABLE pTable
    );

BOOL 
FindFreeSpaceWithMultipleTrees(
    IN CONST LONGLONG ClusterCount,
    IN CONST LONGLONG MaxStartingLcn
    );

BOOL
UpdateInMultipleTrees(
    IN PFREE_SPACE_ENTRY pOldEntry,
    IN PFREE_SPACE_ENTRY pNewEntry
    );



//Uses FindFreeSpace to find a series of free space extents that can be used to partially defragment a file.
BOOL
FindLastFreeSpaceChunks(
        );

//Checks to see if the cluster just before the first cluster of the current file is free.  Used when moving
//contiguous files to consolidate free space.
BOOL
IsFreeSpaceAtHeadOfFile(
        );

//Finds the next extent of free space on the drive within a given range of clusters.
VOID
FindFreeExtent(
        IN PULONG pBitmap,
        IN LONGLONG RangeEnd,
        IN OUT PLONGLONG pLcn,
        OUT PLONGLONG pStartingLcn,
        OUT PLONGLONG pClusterCount
        );

//Generic routine to find free space fitting various requirements.
BOOL
FindFreeSpace(
        IN int Type
        );

//Gets a volume bitmap and (on NTFS) fills the MFT zone with "in use".
BOOL
GetVolumeBitmap(
    );

//Counts the number of free spaces in the bitmap, and calculates stats about the free spaces.
BOOL
CountFreeSpaces(
	);

//Fills a VolumeBitmap with 'inuse' if it's an NTFS volume
BOOL
MarkMFTUnavailable(
	void
	);

//Checking for usable freespace
BOOL
DetermineUsableFreespace(
	LONGLONG *llUsableFreeClusters
	);

#endif // _FREESPACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\getreg.h ===
/**************************************************************************************************

FILENAME: GetReg.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Registry manipulation.

***************************************************************************************************/

#ifndef __GETREG_H_
#define __GETREG_H_

#include <windows.h>

//Gets a handle to a registry key.
LONG
GetRegSubKey(
        IN OUT PHKEY phKey,
        IN PTCHAR cRegKey,
        IN DWORD dwIndex,
        OUT PTCHAR cRegSubKey,
        IN OUT PDWORD pdwRegSubKeySize
        );

//Gets a value from a key out of the registry.
LONG
GetRegValue(
        IN OUT PHKEY phKey,
        IN PTCHAR cRegKey,
        IN PTCHAR cRegValueName,
        OUT PTCHAR cRegValue,
        IN OUT PDWORD pdwRegValueSize
        );

//Gets a value from a key out of the registry.
//overloaded to handle FILETIME directly
LONG
GetRegValue(
        IN OUT PHKEY phKey,
        IN PTCHAR cRegKey,
        IN PTCHAR cRegValueName,
        OUT PLONGLONG cRegValue,
        IN OUT PDWORD pdwRegValueSize
        );

//Sets the value of a key in the registry.
LONG
SetRegValue(
        IN OUT PHKEY phKey,
        IN PTCHAR cRegKey,
        IN PTCHAR cRegValueName,
        OUT PTCHAR cRegValue,
        IN DWORD dwRegValueSize,
        IN DWORD dwKeyType
        );

//Sets the value of a key in the registry.
//overloaded to handle FILETIME directly
LONG
SetRegValue(
        IN OUT PHKEY phKey,
        IN PTCHAR cRegKey,
        IN PTCHAR cRegValueName,
        IN LONGLONG cRegValue,
        IN DWORD dwRegValueSize,
        IN DWORD dwKeyType
        );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\gettime.h ===
/**************************************************************************************************

FILENAME: GetTime.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Prototypes for the file-system time fetcher.

**************************************************************************************************/

//Returns the current system time in FILETIME format.
BOOL
GetTime(
        FILETIME* pFileTime
        );

// This routine returns a formatted time string for output.
PTCHAR
GetTmpTimeString(
	SYSTEMTIME & pTime
	);

// This routine returns the number of seconds between two system times.
BOOL
GetDeltaTime(
	SYSTEMTIME * pStartTime, 
	SYSTEMTIME * pEndTime, 
	DWORD * pdwSeconds
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\logging.h ===
/****************************************************************************************************************

FILENAME: Logging.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Event logging prototypes.

***************************************************************************************************/

//Gets the logging options from the registry and sets up to begin logging.
BOOL InitLogging(
    PTCHAR cEventSource
    );

//Called by Init Logging, gets the logging options from the registry.
BOOL GetLogOptionsFromRegistry(
    );

//When done logging, it closes our handles to the event log.
BOOL CleanupLogging(
    );

//Used to log a specific event.
BOOL LogEvent(
    DWORD dwEventID,
    PTCHAR cMsg
    );

#ifdef NOEVTLOG
#define InitLogging(x)				TRUE
#define GetLogOptionsFromRegistry()	TRUE
#define CleanupLogging()			TRUE
#define LogEvent(x,y)				TRUE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\listview.h ===
/*****************************************************************************

FILENAME: ListView.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

******************************************************************************/

#ifndef _LISTVIEW_H_
#define _LISTVIEW_H_

#include "stdafx.h"
#include <commctrl.h>
extern "C" {
	#include "SysStruc.h"
}
#include "DfrgCmn.h"
#include "DfrgEngn.h"
//#include "DiskView.h"
#include "DfrgUI.h"
#include "DfrgCtl.h"
#include "VolList.h"


class CESIListView
{
public:
	CESIListView(CDfrgCtl *pDfrgCtl);
	~CESIListView();

	HWND m_hwndListView;		// list view window handle

	BOOL EnableWindow(BOOL bIsEnabled);
	BOOL InitializeListView(
		IN CVolList* pVolumeList,
		IN HWND hwndMain, 
		IN HINSTANCE hInstance);
	BOOL InitListViewImageLists(IN HWND hwndListView, IN HINSTANCE hInstRes); 
	BOOL SizeListView(IN int iHorizontal, IN int iVertical, IN int iWidth, IN int iHeight);
	BOOL RepaintListView(void);
	void NotifyListView(IN LPARAM lParam);
	BOOL DeleteAllListViewItems(void);
	BOOL GetDrivesToListView(void);
	void SelectInitialListViewDrive(BOOL * needFloppyWarn);
	BOOL Update(CVolume *pVolume);
	void SetFocus();

private:
	BOOL AddListViewItem(CVolume *pVolume);
	int FindListViewItem(CVolume *pVolume);

private:
	HIMAGELIST m_himlLarge;		// image list for icon view 
	HIMAGELIST m_himlSmall;		// image list for other views 
	CVolList *m_pVolumeList;	// pointer to the volume list container
	CDfrgCtl *m_pDfrgCtl;		// pointer to the parent OCX
};


#endif // #ifndef _LISTVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\message.h ===
/**************************************************************************************************

FILENAME: Message.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
	Header file for ESI messaging.

**************************************************************************************************/

#ifndef __MESSAGE_H_
#define __MESSAGE_H_

#include <windows.h>


#define Message(szMessage,hr,szParameter1)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\intfuncs.h ===
/**************************************************************************************************

FILENAME: IntFuncs.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Prototypes for Internationalization functions.

/*************************************************************************************************/

//Gets a string out of the resource DLL.
TCHAR*
GetString(
        OUT TCHAR* ptOutString,
        IN DWORD dwOutStringLen,
        IN DWORD dwResourceId,
        IN HINSTANCE hInst
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\logfile.h ===
/**************************************************************************************************

FILENAME: ErrLog.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/
#ifndef __LOGFILE_H_
#define __LOGFILE_H_

#include <windows.h>

#ifndef DPFLTR_ERROR_LEVEL
#define DPFLTR_ERROR_LEVEL 0
#define DPFLTR_WARNING_LEVEL 1
#define DPFLTR_TRACE_LEVEL 2
#define DPFLTR_INFO_LEVEL 3
#endif


#define log     THIS_MODULE, __LINE__, DPFLTR_TRACE_LEVEL
#define warn    THIS_MODULE, __LINE__, DPFLTR_WARNING_LEVEL
#define error   THIS_MODULE, __LINE__, DPFLTR_ERROR_LEVEL

#define Trace   IsLoggingAvailable() && DebugMessage

#define WriteStringToLogFile(x) WriteStringToLogFileFunction(x)

//Initializes the error log.
BOOL
InitializeLogFile(
    IN TCHAR* pLogName
    );

//Closes the error log.
void
ExitLogFile(
    );

BOOL
IsLoggingAvailable();

BOOL
WriteStringToLogFileFunction(
    IN TCHAR* pMessage
    );

BOOL
DebugMessage(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN PCSTR FormatString,
    ...);



#endif // #ifndef __LOGFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\graphix.h ===
/*****************************************************************************************************************

FILENAME: Graphix.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/

#ifndef _GRAPHIX_H_
#define _GRAPHIX_H_

#define LINE_HEIGHT  20

#define PLAIN_BORDER  0
#define SUNKEN_BORDER 1
#define RAISED_BORDER 2
#define SUNKEN_BOX    3
#define RAISED_BOX    4

BOOL ESIDrawEdge(
	HDC OutputDC, 
	int startX,
	int startY,
	int endX,
	int endY);

HRESULT
DrawBorderEx(
    IN HDC hdcOutput,
    IN RECT rect,
    IN int iBorderType
    );

HRESULT
ProgressBar(
    IN HDC hdcOutput,
    IN RECT* prect,
	IN HFONT hFont,
    IN int iWidth,
	IN int iSpace,
	IN int iPercent
    );

BOOL DrawBorder(HDC OutputDC, RECT * pRect, int BorderType);

class CBmp
{
private:
	int iNumBitmaps;
	HINSTANCE hInst;
	HBITMAP * BitmapArray;

	void DeleteBitmaps();

public:
	CBmp(HINSTANCE, LPTSTR);
	CBmp(HINSTANCE, INT_PTR *, int);
	~CBmp();

	void LoadBitmaps(INT_PTR *, int);
	BOOL ChangeColor(int, int);
	BOOL ChangeColor(int, int, int);
	BOOL GetBmpSize(int *, int *);
	BOOL GetBmpSize(int, int *, int *);
	BOOL DrawBmpInHDC(HDC, int, int);
	BOOL DrawBmpInHDC(HDC, int, int, int);
	BOOL DrawBmpInHDCTruncate(HDC, RECT*);
	BOOL DrawBmpInHDCTruncate(HDC, int, RECT*);
};

#endif // #define _GRAPHIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\loadfile.h ===
/**************************************************************************************************

FILENAME: LoadFile.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

**************************************************************************************************/

//Loads a file from disk, allocating enough memory, and returns the handle to the memory.
HANDLE
LoadFile(
        IN PTCHAR cLoadFileName,
        IN PDWORD pdwFileSize,
        IN DWORD dwSharing,
        IN DWORD dwCreate
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\mftdefrag.h ===
/**************************************************************************************************

FILENAME: MFTDefrag.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Defrag the MFT.

**************************************************************************************************/

BOOL MFTDefrag(
		IN HANDLE hVolumeHandle,
		IN LONGLONG BitmapSize,
		IN LONGLONG BytesPerSector,
		IN LONGLONG TotalClusters,
		IN ULONGLONG MftZoneStart, 
		IN ULONGLONG MftZoneEnd,
		IN TCHAR tDrive,
		IN LONGLONG ClustersPerFRS 
		);


ULONGLONG GetMFTSize(
		IN HANDLE hMFTHandle,
		OUT LONGLONG* lMFTFragments,
		OUT LONGLONG* lMFTStartingVcn
		);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\postmsgc.h ===
/***************************************************************************

FILENAME: PostMsgC.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.
    
DESCRIPTION:
	Include file for the respective module.
    
***************************************************************************/

// Declare routine prototypes
//
BOOL
PostMessageLocal (
    IN  HWND    hWnd,
    IN  UINT    Msg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\mimessage.h ===
/**************************************************************************************************

FILENAME: MIMessage.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

**************************************************************************************************/
#ifndef __MIMESSAGE_H_
#define __MIMESSAGE_H_

BOOL RaiseMIDialog(HWND hWndParent);

#endif //#ifndef __MIMESSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\ntfssubs.h ===
/****************************************************************************************************************

FILENAME: NtfsSubs.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

***************************************************************************************************************/

//Gets the extent list of an NTFS file.
BOOL
GetExtentList(
	DWORD dwEnabledStreams,
	FILE_RECORD_SEGMENT_HEADER* pFrs
    );

BOOL
FindStreamInFrs(
	IN PFILE_RECORD_SEGMENT_HEADER  pFrs,
	OUT PATTRIBUTE_RECORD_HEADER*   ppArh,
	EXTENT_LIST_DATA* pExtentData
	);

BOOL
FindNextStreamInFrs(
	IN PFILE_RECORD_SEGMENT_HEADER  pFrs,
	OUT PATTRIBUTE_RECORD_HEADER*   ppArh,
	EXTENT_LIST_DATA* pExtentData
	);

BOOL
AddMappingPointersToStream(
	IN PATTRIBUTE_RECORD_HEADER pArh,
	EXTENT_LIST_DATA* pExtentData
	);

BOOL
GetLargeStreamExtentList(
	IN PFILE_RECORD_SEGMENT_HEADER pFrs,
	IN PATTRIBUTE_RECORD_HEADER pArh,
	EXTENT_LIST_DATA* pExtentData
	);

BOOL
FindStreamInAttrList(
	ATTRIBUTE_LIST_ENTRY* pAleStart,
	ATTRIBUTE_LIST_ENTRY** ppAle,
	LONGLONG ValueLength,
	EXTENT_LIST_DATA* pExtentData
	);

BOOL
FindNextStreamInAttrList(
	ATTRIBUTE_LIST_ENTRY* pAleStart,
	ATTRIBUTE_LIST_ENTRY** ppAle,
	LONGLONG ValueLength,
	EXTENT_LIST_DATA* pExtentData
	);

ATTRIBUTE_RECORD_HEADER*
FindAttributeByInstanceNumber(
	HANDLE* phFrs,
	ATTRIBUTE_LIST_ENTRY* pAle,
	EXTENT_LIST_DATA* pExtentData
	);

UCHAR
AttributeFormCode(
	ATTRIBUTE_LIST_ENTRY* pAle,
	EXTENT_LIST_DATA* pExtentData
	);

LONGLONG
AttributeAllocatedLength(
	ATTRIBUTE_LIST_ENTRY* pAle,
	EXTENT_LIST_DATA* pExtentData
	);

LONGLONG
AttributeFileSize(
	ATTRIBUTE_LIST_ENTRY* pAle,
	EXTENT_LIST_DATA* pExtentData
	);

BOOL
GetHugeStreamExtentList(
	ATTRIBUTE_LIST_ENTRY* pAleStart,
	ATTRIBUTE_LIST_ENTRY** ppAle,
	LONGLONG ValueLength,
	EXTENT_LIST_DATA* pExtentData
	);

BOOL
LoadExtentDataToMem(
	ATTRIBUTE_RECORD_HEADER* pArh,
	HANDLE* phAle,
	DWORD* pdwByteLen
	);

BOOL
GetStreamExtentsByNameAndType(
	TCHAR* StreamName,
	ATTRIBUTE_TYPE_CODE StreamType,
	FILE_RECORD_SEGMENT_HEADER* pFrs
	);

BOOL
GetStreamExtentsByNumber(
	ULONG StreamNumber
	);

BOOL
GetStreamNumberFromNameAndType(
	ULONG* pStreamNumber,
	TCHAR* StreamName,
	ATTRIBUTE_TYPE_CODE TypeCode,
	FILE_RECORD_SEGMENT_HEADER* pFrs
	);

BOOL
GetStreamNameAndTypeFromNumber(
	ULONG StreamNumber,
	TCHAR* StreamName,
	ATTRIBUTE_TYPE_CODE* pTypeCode,
	FILE_RECORD_SEGMENT_HEADER* pFrs
	);

BOOL
GetNonDataStreamExtents(
	);

BOOL
IsNonresidentFile(
	DWORD dwEnabledStreams,
	FILE_RECORD_SEGMENT_HEADER* pFrs
	);

#ifdef OFFLINEDK
BOOL
CheckFragged(
    );
#endif

BOOL
GetNtfsVolumeStats(
        );

//This gets a specified FRS from the MFT, or the next one that's in use if this one isn't.
BOOL
GetInUseFrs(
    IN HANDLE hVolume,
    IN OUT LONGLONG* pFileRecordNumber,
    OUT FILE_RECORD_SEGMENT_HEADER* pFrs,
    IN ULONG uBytesPerFRS
    );

//Gets the path of a file by getting the MFT records for each of it's parent directories.
BOOL
GetNtfsFilePath(
    );

//Get the name of a file from it's file record and those of it parent directories.
BOOL
GetNameFromFileRecord(
        IN FILE_RECORD_SEGMENT_HEADER*  pFrs,
        OUT TCHAR*                                              pcName,
        IN LONGLONG*                                    pParentFileRecordNumber
        );


//Gets the next file to defragment from the file lists.
GetNextNtfsFile(
    IN CONST PRTL_GENERIC_TABLE pTable,
    IN CONST BOOLEAN Restart,
    IN CONST LONGLONG ClusterCount = 0,
    IN OUT PFILE_LIST_ENTRY pEntry = NULL
    );


//Opens a file on an NTFS volume.
BOOL
OpenNtfsFile(
        );

//Gets the extent list for the MFT and MFT mirror.
BOOL
GetSystemsExtentList(
        );


#ifdef DFRGNTFS
BOOL
AddFileToListNtfs(
    IN PRTL_GENERIC_TABLE Table,
	IN LONGLONG FileRecordNumber
	);

BOOL
UpdateFileTables(
    IN OUT PRTL_GENERIC_TABLE pFragmentedTable,
    IN OUT PRTL_GENERIC_TABLE pContiguousTable
    );

#else // DFRGNTFS
//Adds the extent list for a file to a file list on an NTFS drive.
BOOL
AddFileToListNtfs(
		OUT FILE_LIST_ENTRY* pList,
        IN OUT ULONG* pListIndex,
		IN ULONG ListSize,
        IN LONGLONG FileRecordNumber,
        IN UCHAR* pExtentList
        );

#endif // DFRGNTFS
BOOL
UpdateInFileList(
	);

BOOL
FindAttributeByType(
	IN ATTRIBUTE_TYPE_CODE TypeCode,
	IN PFILE_RECORD_SEGMENT_HEADER pFrs,
	OUT PATTRIBUTE_RECORD_HEADER* ppArh,
	IN ULONG uBytesPerFRS
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\msgres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MsgRes.rc
//
#define IDS_PRODUCT_NAME                1
#define IDS_COMPANY                     2
#define IDS_MSG_FIRST_COLUMN            3
#define IDS_MSG_SECOND_COLUMN           4
#define IDS_MSG_THIRD_COLUMN            5
#define IDS_MSG_FOURTH_COLUMN           6
#define IDD_MESSAGE                     101
#define IDC_MESSAGES                    1001
#define ID_SAVE                         1002
#define IDC_FILENAME                    1003
#define ID_CLEAR_DISPLAY                1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\remmsg.h ===
/**************************************************************************************************

FILENAME: RemMsg.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
        Remote message prototypes.

***************************************************************************************************/

//Sends a text message to a remote process so we can pop up MessageBoxes on remote machines.
BOOL
RemoteMessageBox(
        TCHAR* cMsg,
        TCHAR* cTitle
        );

//Takes the message from another process and displays a MessageBox here (compliment to RemoteMessageBox).
BOOL
PrintRemoteMessageBox(
        TCHAR* pText
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\movefile.h ===
/****************************************************************************************************************

FILENAME: Movefile.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

***************************************************************************************************************/

//The OS has a function called MoveFile.  We wish to use our's not the OS's.
#undef MoveFile

//Moves a file to a new location on the disk.
BOOL
MoveFile(
        );

//Called by MoveFile to move a file on a FAT drive.
BOOL
MoveFileFat(
        );

//Called by MoveFile to move a file on an NTFS drive.
BOOL
MoveFileNtfs(
        );

//Moves a piece of a file -- called by MoveFileFat or MoveFileNtfs
BOOL
MoveAPieceOfAFile(
        IN LONGLONG FileVcn,
        IN LONGLONG FreeLcn,
        IN LONGLONG FreeClusters
        );

//If we cannot fully defragment a file, then partially defrag it by placing it in several locations on the disk.
BOOL
PartialDefrag(
        );

//For debugging -- will display the extent list of a file.
VOID
ShowExtentList(
        );

//Removes a file from it's file list.
BOOL
RemoveFileFromList(
        );

//Adds a file to the appropriate file list.
BOOL
InsertFileInList(
        BOOL bPartialDefrag
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\priority.h ===
/**************************************************************************************************

FILENAME: Priority.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

*/


// Determine whether the current thread running below the normal priority or not
BOOL IsBelowNormalBasePriority();

// Sets Current Thread's Base priority to Normal
BOOL ResetToNormalPriority();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\textblock.h ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

class CTextBlock
{
private:
	PTCHAR m_pText;
	PTCHAR m_pEndOfBuffer;
	BOOL m_isFixedWidth;
	BOOL m_isUseTabs;
	BOOL m_isUseCRLF;
	UINT m_colCount;
	UINT m_currentCol;
	UINT m_colWidth[10];
	HANDLE m_hMemory;
	HINSTANCE m_hResource;

public:
	CTextBlock();
	~CTextBlock();

	void SetColumnCount(UINT colCount) {m_colCount = colCount;};
	void SetFixedColumnWidth(BOOL isFixedWidth) {m_isFixedWidth = isFixedWidth;};
	void SetColumnWidth(UINT col, UINT colWidth);
	void SetUseTabs(BOOL isUseTabs) {m_isUseTabs = isUseTabs;};
	void SetResourceHandle(HINSTANCE hResource) {m_hResource = hResource;};
	void SetUseCRLF(BOOL isUseCRLF) {m_isUseCRLF = isUseCRLF;};

	PTCHAR GetBuffer(void) {return m_pText;};
	HANDLE GetHandle(void) {return m_hMemory;};
	void __cdecl WriteToBuffer(PTCHAR cFormat, ...);
	void WriteToBufferLL(LONGLONG number);
	void WriteToBuffer(UINT resourceID); // to write a resource string
	void WriteTab(void);
	void WriteNULL(void);
	void WriteByteCount(LONGLONG byteCount);
	void EndOfLine(void);
	void FormatNum(HINSTANCE hResource, LONGLONG number, PTCHAR buffer);
	// write the text to a UNICODE file
	BOOL StoreFile(IN TCHAR* cStoreFileName, IN DWORD dwCreate);

private:
	void WriteToBufferAndPad(PTCHAR buffer, UINT length);


};


DWORD
FormatNumber(
			 HINSTANCE hResource,
			 LONGLONG Number,
			 PTCHAR buffer
	);

DWORD
FormatNumberMB(
			 HINSTANCE hResource,
			 LONGLONG number,
			 PTCHAR buffer
	);

PTCHAR
CommafyNumber(
	 LONGLONG number,
	 PTCHAR stringBuffer,
	 UINT stringBufferLength
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\uicommon.h ===
BOOL IsValidVolume(
    TCHAR driveLetter
);

BOOL IsValidVolume(
    PTCHAR volumeName, 
    PTCHAR volumeLabel, 
    PTCHAR fileSystem
);

BOOL
IsVolumeWriteable(
   PTCHAR volumeName,
   DWORD* dLastError
);

BOOL
IsVolumeRemovable(
    PTCHAR volumeName
);

BOOL
IsFAT12Volume(
    PTCHAR volumeName
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\secattr.h ===
/**************************************************************************************************

FILENAME: SecAttr.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
    Security attribute related routines
    
**************************************************************************************************/


typedef enum _SecurityAttributeType
{
    esatUndefined = 0,
    esatMutex,
    esatSemaphore,
    esatEvent,
    esatFile
} SecurityAttributeType;



BOOL
ConstructSecurityAttributes(
    PSECURITY_ATTRIBUTES  psaSecurityAttributes,
    SecurityAttributeType eSaType,
    BOOL                  bIncludeBackupOperator
    );

VOID 
CleanupSecurityAttributes(
    PSECURITY_ATTRIBUTES psaSecurityAttributes
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\stdafx.h ===
// STUB - Andy Staffer - 23 September 1997
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\vrtti.hpp ===
#ifndef __VRTTI_HPP
#define __VRTTI_HPP

#include "vStandard.h"

// <VDOC<CLASS=VRTTI><DESC=Supports simple, fast, runtime type identification><FAMILY=General Utility><AUTHOR=Todd Osborne (todd.osborne@poboxes.com)>VDOC>
class VRTTI
{
public:
	VRTTI(UINT nRTTI = 0)
		{ m_nRTTI = nRTTI; }

	virtual ~VRTTI()
		{;}
	
	operator	UINT()
		{ return m_nRTTI; }

	// Get / Set members
	UINT		RTTI()
		{ return m_nRTTI; }

	UINT		RTTI(UINT nRTTI)
		{ m_nRTTI = nRTTI; return m_nRTTI; }

private:
	// Embedded Members
	UINT		m_nRTTI;
};

#endif // __VRTTI_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\vptrarray.hpp ===
#ifndef __VPTRARRAY_HPP
#define __VPTRARRAY_HPP

#include "vStandard.h"

#define VPTRARRAY_ELEMENT ULONG_PTR

// <VDOC<CLASS=VPtrArray><DESC=Collection of unknown 4 byte types (FAR pointers)><FAMILY=Collections><AUTHOR=Todd Osborne (todd.osborne@poboxes.com)>VDOC>
class VPtrArray
{
public:
	VPtrArray()
		{ m_lpData = NULL; m_nSize = 0; }

	virtual ~VPtrArray()
		{ RemoveAll(); }
	
	// Same as At(nIndex)
	LPVOID operator [] (int nIndex)
		{ return At(nIndex); }
	
	// Same as Add()
	int operator + (LPVOID lpData)
		{ return Add(lpData); }

	// Same as FindAndRemove()
	int operator - (LPVOID lpData)
		{ return FindAndRemove(lpData); }

	// Add a new element at the end of the array. Returns index into array on success, -1 on failure
	int			Add(LPVOID lpData)
	{
		if ( AllocCopy(m_nSize + 1, -1, -1) )
		{
			m_lpData[m_nSize - 1] = (VPTRARRAY_ELEMENT)lpData;
			return m_nSize - 1;
		}

		return -1;
	}

	// Return element at given index
	LPVOID		At(int nIndex)
		{ assert(nIndex >= 0 && nIndex < m_nSize); return (LPVOID)m_lpData[nIndex]; }
	
	// Set element at given index. This does not allocate memory, that must already have been done by Add(), Size(), or +
	void		At(int nIndex, LPVOID lpData)
		{ assert(nIndex >= 0 && nIndex < m_nSize); m_lpData[nIndex] = (VPTRARRAY_ELEMENT)lpData; }

	// Return the index into array for first occurence of lpData, or -1 if not found
	int			Find(LPVOID lpData)
	{
		int nResult = -1;

		for ( int i = 0; i < m_nSize; i++ )
		{
			if ( m_lpData[i] == (VPTRARRAY_ELEMENT)lpData )
			{
				nResult = i;
				break;
			}
		}

		return nResult;
	}

	// Find and remove element from array. Returns TRUE on success, FALSE on failure
	BOOL		FindAndRemove(LPVOID lpData)
		{ int nIndex = Find(lpData); return (nIndex != -1) ? RemoveAt(nIndex) : FALSE; }

	// Insert a new element into the array at specified index, moving everything after
	// it further into the array. Returns index on success, -1 on failure
	int			InsertAt(int nIndex, LPVOID lpData)
	{
		assert(nIndex <= m_nSize);
		
		// Add item first to end
		if ( Add(lpData) != - 1 )
		{
			if ( nIndex < m_nSize - 1 )
			{
				// Shift memory up in array
				MoveMemory(	&m_lpData[nIndex + 1],
							&m_lpData[nIndex],
							sizeof(VPTRARRAY_ELEMENT) * (m_nSize - nIndex - 1));
						
				// Set lpData where told to
				m_lpData[nIndex] = (VPTRARRAY_ELEMENT)lpData;
			}

			return nIndex;
		}

		return -1;
	}

	// Remove all elements from array
	void		RemoveAll()
		{ delete [] m_lpData; m_lpData = NULL; m_nSize = 0; }

	// Remove a single element from the array. All other elements will be shifted down one slot
	BOOL		RemoveAt(int nIndex)
		{ return RemoveRange(nIndex, nIndex); }

	// Remove multiple elements from the array. All other elements will be shifted down by the number of elements removed
	BOOL		RemoveRange(int nIndexStart, int nIndexEnd)
	{
		assert(nIndexStart >= 0 && nIndexStart < m_nSize && nIndexEnd >= nIndexStart);
		
		int nSize =	m_nSize;
		return		(AllocCopy(m_nSize - ((nIndexEnd - nIndexStart) + 1), nIndexStart, nIndexEnd) && m_nSize != nSize) ? TRUE : FALSE;
	}

	// Get / Set the size of the array (number of elements). Returns TRUE on success, FALSE on failure
	// Elements currently in array will be preserved, unless array is skrinking, in which
	// case element(s) at the end of the current array will be truncated
	BOOL		Size(int nSize)
		{ assert(nSize >= 0); return AllocCopy(nSize , -1, -1); }

	int			Size()
		{ return m_nSize; }

protected:
	// Internal function to work with private data
	BOOL		AllocCopy(int nNewSize, int nSkipIndexStart, int nSkipIndexEnd)
	{
		VPTRARRAY_ELEMENT* lpNewData = (nNewSize) ? new VPTRARRAY_ELEMENT[nNewSize] : NULL;

		// If memory allocation was required and did not succeed, exit now with error
		if ( nNewSize && !lpNewData )
			return FALSE;

		if ( lpNewData )
		{
			#ifdef _DEBUG
				// Data but no size!
				if ( m_lpData )
					assert(m_nSize);
			#endif

			// Clear new memory
			ZeroMemory(lpNewData, nNewSize * sizeof(VPTRARRAY_ELEMENT));

			// Copy any previous memory
			if ( m_nSize )
			{
				// There must be data!
				assert(m_lpData);

				// If either skip index is -1, we will copy everything
				// -1 is used internally as a flag to indicate no exclusions
				if ( nSkipIndexStart == -1 || nSkipIndexEnd == -1 )
					CopyMemory(lpNewData, m_lpData, min(m_nSize, nNewSize) * sizeof(VPTRARRAY_ELEMENT));
				else
				{
					// Copy up to nSkipIndexStart
					if ( nSkipIndexStart )
						CopyMemory(&lpNewData[0], &m_lpData[0], nSkipIndexStart * sizeof(VPTRARRAY_ELEMENT));

					// Copy from nSkipIndexEnd + 1 to end
					CopyMemory(	&lpNewData	[nSkipIndexStart],
								&m_lpData	[nSkipIndexEnd + 1],
								(m_nSize * sizeof(VPTRARRAY_ELEMENT)) - ((nSkipIndexEnd + 1) * sizeof(VPTRARRAY_ELEMENT)));
				}
			}
		}

		// Kill any current memory
		delete [] m_lpData;

		// Make new assignments
		m_lpData =	lpNewData;
		m_nSize =	nNewSize;

		return TRUE;
	}

private:
	// Embedded Members
	VPTRARRAY_ELEMENT*		m_lpData;
	int						m_nSize;
};

#endif // __VPTRARRAY_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\sysstruc.h ===
/****************************************************************************************************************

FILENAME: SysStruc.h

COPYRIGHT 2001 Microsoft Corporation and Executive Software International, Inc.

DESCRIPTION:
	This contains the windows NT file system data strucutures that we need to use.  The headers used by NTFS
	cannot be included directly since they contain kernel mode stuff, so this contains simply the data
	structures we need.

/****************************************************************************************************************/

#ifndef _SYSSTRUC_H_
#define _SYSSTRUC_H_

//Makes sure the following structures are not aligned on memory
//boundaries.  They are byte for byte representative of how they should
//be in memory.
#include "pshpack1.h"									//0.0E00 DO NOT MOVE

//This is the format of a standard FAT16 boot sector.  Kept here for reference.
//typedef struct {
//	UCHAR	Jump[3];
//	UCHAR	Name[8];
//	USHORT	BytesPerSector;
//	UCHAR	SectorsPerCluster;
//	USHORT	BootSectors;
//	UCHAR	Fats;
//	USHORT	RootDirs;
//	USHORT	TotalSectors;
//	UCHAR	Media;
//	USHORT	SectorsPerFat;
//	USHORT	SectorsPerTrack;
//	USHORT	Heads;
//	DWORD	HiddenSectors;
//	DWORD	BigTotalSectors;
//}BOOTSECTOR;

//This is the NTFS boot sector.  Kept here for reference.
//typedef struct _PACKED_BOOT_SECTOR {
//    UCHAR		/* 0x000 */ Jump[3];
//    UCHAR		/* 0x003 */ Oem[8];
//    USHORT	/* 0x00B */ BytesPerSector;
//    UCHAR		/* 0x00D */ SectorsPerCluster;
//    USHORT	/* 0x00E */ ReservedSectors;   // (zero)
//    UCHAR		/* 0x010 */ Fats;              // (zero)
//    USHORT	/* 0x011 */ RootEntries;       // (zero)
//    USHORT	/* 0x013 */ Sectors;           // (zero)
//    UCHAR		/* 0x015 */ Media;
//    USHORT	/* 0x016 */ SectorsPerFat;     // (zero)              
//    USHORT	/* 0x018 */ SectorsPerTrack;
//    USHORT	/* 0x01A */ Heads;
//    DWORD		/* 0x01C */ HiddenSectors;     // (zero)
//    DWORD		/* 0x020 */ LargeSectors;      // (zero)
//    UCHAR		/* 0x024 */ Unused[4];
//    LONGLONG	/* 0x028 */ NumberSectors;
//    LCN		/* 0x030 */ MftStartLcn;
//    LCN		/* 0x038 */ Mft2StartLcn;
//    ULONG		/* 0x040 */ ClustersPerFileRecordSegment;
//    ULONG		/* 0x044 */ DefaultClustersPerIndexAllocationBuffer;
//    LONGLONG	/* 0x048 */ SerialNumber;
//    ULONG		/* 0x050 */ Checksum;
//    UCHAR		/* 0x054 */ BootStrap[0x200-0x044];
//} PACKED_BOOT_SECTOR;                                   //  sizeof = 0x200

//This is the format of a standard FAT directory entry.
typedef struct {
	UCHAR	Name[8];
	UCHAR	Ext[3];
	BYTE	Attribute;
	BYTE	Reserved;
	BYTE	CreateTimeMillisecs;
	USHORT	CreateTime;
	USHORT	CreateDate;
	USHORT	LastAccessDate;
	USHORT	ClusterHigh;
	BYTE	Time[2];
	BYTE	Date[2];
	USHORT	ClusterLow;
	DWORD	FileSize;
}DIRSTRUC;

//Undoes the byte alignment disabling done by pshpack1.h above.
#include "poppack.h"									//0.0E00 DO NOT MOVE

//On NTFS - this is the first file record number to begin defragging at (skip all the system entries).
#define FIRST_USER_FILE_NUMBER 16

//On NTFS - the FRN of the root directory.
#define ROOT_FILE_NAME_INDEX_NUMBER      (5)   			//File Record Number of the Root Directory

/*************************************************************************************************************

From PRIVATE\NTOS\INC\LFS.H

/************************************************************************************************************/

//The format of an NTFS data structure.
//Shouldn't this be gotten out of a standard windows header file?
typedef struct _MULTI_SECTOR_HEADER {
    UCHAR Signature[4];
    USHORT UpdateSequenceArrayOffset;
    USHORT UpdateSequenceArraySize;
} MULTI_SECTOR_HEADER, *PMULTI_SECTOR_HEADER;

typedef LARGE_INTEGER LSN, *PLSN;

/*************************************************************************************************************

From PRIVATE\NTOS\CNTFS\NTFS.H

/************************************************************************************************************/

//The format of another standard structure found in an NTFS FRS.
typedef struct _MFT_SEGMENT_REFERENCE {
    ULONG LowPart;                                      //  offset = 0x000
    USHORT HighPart;                                    //  offset = 0x004
    USHORT SequenceNumber;                              //  offset = 0x006
} MFT_SEGMENT_REFERENCE, *PMFT_SEGMENT_REFERENCE;       //  sizeof = 0x008

typedef MFT_SEGMENT_REFERENCE FILE_REFERENCE, *PFILE_REFERENCE;

typedef USHORT UPDATE_SEQUENCE_NUMBER, *PUPDATE_SEQUENCE_NUMBER;
typedef UPDATE_SEQUENCE_NUMBER UPDATE_SEQUENCE_ARRAY[1];

//The format of an NTFS FRS Header.
typedef struct _FILE_RECORD_SEGMENT_HEADER {
    MULTI_SECTOR_HEADER MultiSectorHeader;              //  offset = 0x000
    LSN Lsn;                                            //  offset = 0x008
    USHORT SequenceNumber;                              //  offset = 0x010
    USHORT ReferenceCount;                              //  offset = 0x012
    USHORT FirstAttributeOffset;                        //  offset = 0x014
    USHORT Flags;                                       //  offset = 0x016
    ULONG FirstFreeByte;                                //  offset = x0018
    ULONG BytesAvailable;                               //  offset = 0x01C
    FILE_REFERENCE BaseFileRecordSegment;               //  offset = 0x020
    USHORT NextAttributeInstance;                       //  offset = 0x028
    UPDATE_SEQUENCE_ARRAY UpdateArrayForCreateOnly;     //  offset = 0x02A
} FILE_RECORD_SEGMENT_HEADER;

typedef FILE_RECORD_SEGMENT_HEADER *PFILE_RECORD_SEGMENT_HEADER;
#define FILE_RECORD_SEGMENT_IN_USE       (0x0001)
#define FILE_FILE_NAME_INDEX_PRESENT     (0x0002)

typedef ULONG ATTRIBUTE_TYPE_CODE;
typedef LONGLONG VCN;
typedef VCN *PVCN;

//The format of an NTFS FRS attribute header - specifies what type of attributes follow.
typedef struct _ATTRIBUTE_RECORD_HEADER {
    ATTRIBUTE_TYPE_CODE TypeCode;                       //  offset = 0x000
    ULONG RecordLength;                                 //  offset = 0x004
    UCHAR FormCode;                                     //  offset = 0x008
    UCHAR NameLength;                                   //  offset = 0x009
    USHORT NameOffset;                                  //  offset = 0x00A
    USHORT Flags;                                       //  offset = 0x00C
    USHORT Instance;                                    //  offset = 0x00E
    union {
        struct {
            ULONG ValueLength;                          //  offset = 0x010
            USHORT ValueOffset;                         //  offset = 0x014
            UCHAR ResidentFlags;                        //  offset = 0x016
            UCHAR Reserved;                             //  offset = 0x017
        } Resident;
        struct {
            VCN LowestVcn;                              //  offset = 0x010
            VCN HighestVcn;                             //  offset = 0x018
            USHORT MappingPairsOffset;                  //  offset = 0x020
            UCHAR CompressionUnit;                      //  offset = 0x022
            UCHAR Reserved[5];                          //  offset = 0x023
            LONGLONG AllocatedLength;                   //  offset = 0x028
            LONGLONG FileSize;                          //  offset = 0x030
            LONGLONG ValidDataLength;                   //  offset = 0x038
            LONGLONG TotalAllocated;                    //  offset = 0x040
        } Nonresident;
    } Form;
} ATTRIBUTE_RECORD_HEADER;
typedef ATTRIBUTE_RECORD_HEADER *PATTRIBUTE_RECORD_HEADER;

//The different types of NTFS attributes.  This would be in TypeCode of the ATTRIBUTE_RECORD_HEADER structure above.
#define $UNUSED                          (0X0)
#define $STANDARD_INFORMATION            (0x10)
#define $ATTRIBUTE_LIST                  (0x20)
#define $FILE_NAME                       (0x30)
#define $VOLUME_VERSION                  (0x40)
#define $SECURITY_DESCRIPTOR             (0x50)
#define $VOLUME_NAME                     (0x60)
#define $VOLUME_INFORMATION              (0x70)
#define $DATA                            (0x80)
#define $INDEX_ROOT                      (0x90)
#define $INDEX_ALLOCATION                (0xA0)
#define $BITMAP                          (0xB0)
#define $SYMBOLIC_LINK                   (0xC0)
#define $EA_INFORMATION                  (0xD0)
#define $EA                              (0xE0)
#define $FIRST_USER_DEFINED_ATTRIBUTE    (0x100)
#define $END                             (0xFFFFFFFF)

//These specify whether the attribute is resident or not and go in the FormCode entry of the ATTRIBUTE_RECORD_HEADER structure above.
#define RESIDENT_FORM                    (0x00)
#define NONRESIDENT_FORM                 (0x01)

typedef struct _DUPLICATED_INFORMATION {
    LONGLONG CreationTime;                              //  offset = 0x000
    LONGLONG LastModificationTime;                      //  offset = 0x008
    LONGLONG LastChangeTime;                            //  offset = 0x010
    LONGLONG LastAccessTime;                            //  offset = 0x018
    LONGLONG AllocatedLength;                           //  offset = 0x020
    LONGLONG FileSize;                                  //  offset = 0x028
    ULONG FileAttributes;                               //  offset = 0x030
    USHORT PackedEaSize;                                //  offset = 0x034
    USHORT Reserved;                                    //  offset = 0x036
} DUPLICATED_INFORMATION;                               //  sizeof = 0x038
typedef DUPLICATED_INFORMATION *PDUPLICATED_INFORMATION;

//If we have an attribute list, this is the format of the entries in it.
typedef struct _ATTRIBUTE_LIST_ENTRY {
    ATTRIBUTE_TYPE_CODE AttributeTypeCode;  			//  offset = 0x000
    USHORT RecordLength;                    			//  offset = 0x004
    UCHAR AttributeNameLength;              			//  offset = 0x006
    UCHAR AttributeNameOffset;              			//  offset = 0x007
    VCN LowestVcn;                          			//  offset = 0x008
    MFT_SEGMENT_REFERENCE SegmentReference; 			//  offset = 0x010
    USHORT Instance;                        			//  offset = 0x018
    WCHAR AttributeName[1];                 			//  offset = 0x01A
} ATTRIBUTE_LIST_ENTRY;
typedef ATTRIBUTE_LIST_ENTRY *PATTRIBUTE_LIST_ENTRY;

//This the the format of a standard information attribute structure.
typedef struct _STANDARD_INFORMATION {
    LONGLONG CreationTime;                              //  offset = 0x000
    LONGLONG LastModificationTime;                      //  offset = 0x008
    LONGLONG LastChangeTime;                            //  offset = 0x010
    LONGLONG LastAccessTime;                            //  offset = 0x018
    ULONG FileAttributes;                               //  offset = 0x020
    ULONG MaximumVersions;                              //  offset = 0x024
    ULONG VersionNumber;                                //  offset = 0x028
    ULONG Reserved;                                     //  offset = 0x02c
} STANDARD_INFORMATION;                                 //  sizeof = 0x030
typedef STANDARD_INFORMATION *PSTANDARD_INFORMATION;

//This is the format of a file name attribute structure.
typedef struct _FILE_NAME {
    FILE_REFERENCE ParentDirectory;                     //  offset = 0x000
    DUPLICATED_INFORMATION Info;                        //  offset = 0x008
    UCHAR FileNameLength;                               //  offset = 0x040
    UCHAR Flags;                                        //  offset = 0x041
    WCHAR FileName[1];                                  //  offset = 0x042
} FILE_NAME;
typedef FILE_NAME *PFILE_NAME;

#define FILE_NAME_NTFS                   (0x01)

//Contains the version number for the volume, and the dirty bit.
typedef struct _VOLUME_INFORMATION {
    LONGLONG Reserved;
    UCHAR MajorVersion;                                  //  offset = 0x000
    UCHAR MinorVersion;                                  //  offset = 0x001
    USHORT VolumeFlags;                                  //  offset = 0x002
} VOLUME_INFORMATION;                                    //  sizeof = 0x004
typedef VOLUME_INFORMATION *PVOLUME_INFORMATION;

//Dirty volume flags.
#define VOLUME_DIRTY                     (0x0001)
#define VOLUME_RESIZE_LOG_FILE           (0x0002)		//This one unused?
#define VOLUME_UPGRADE_ON_MOUNT          (0x0004)


/****************************************************************************************************************

  These are required for the Razzle build

  */

// begin_ntndis
//
// NTSTATUS
//

typedef LONG NTSTATUS;
/*lint -e624 */  // Don't complain about different typedefs.   // winnt
typedef NTSTATUS *PNTSTATUS;
/*lint +e624 */  // Resume checking for different typedefs.    // winnt

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

// begin_winnt
#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000
// end_winnt

// end_ntndis

// begin_ntddk begin_nthal
//
// Define the base asynchronous I/O argument types
//
// end_ntddk end_nthal

#define STATUS_BUFFER_OVERFLOW           ((NTSTATUS)0x80000005L)


/*************************************************************************************************************

From PUBLIC\SDK\INC\WINBASE.H

  These are the declarations for the GUID-base volume functions

/************************************************************************************************************/

#ifndef FindFirstVolume

#if !defined(_KERNEL32_)
#define WINBASEAPI DECLSPEC_IMPORT
#else
#define WINBASEAPI
#endif

WINBASEAPI
HANDLE
WINAPI
FindFirstVolumeA(
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );
WINBASEAPI
HANDLE
WINAPI
FindFirstVolumeW(
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );
#ifdef UNICODE
#define FindFirstVolume FindFirstVolumeW
#else
#define FindFirstVolume FindFirstVolumeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextVolumeA(
    HANDLE hFindVolume,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );
WINBASEAPI
BOOL
WINAPI
FindNextVolumeW(
    HANDLE hFindVolume,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );
#ifdef UNICODE
#define FindNextVolume FindNextVolumeW
#else
#define FindNextVolume FindNextVolumeA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindVolumeClose(
    HANDLE hFindVolume
    );

WINBASEAPI
HANDLE
WINAPI
FindFirstVolumeMountPointA(
    LPCSTR lpszRootPathName,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );
WINBASEAPI
HANDLE
WINAPI
FindFirstVolumeMountPointW(
    LPCWSTR lpszRootPathName,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );
#ifdef UNICODE
#define FindFirstVolumeMountPoint FindFirstVolumeMountPointW
#else
#define FindFirstVolumeMountPoint FindFirstVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindNextVolumeMountPointA(
    HANDLE hFindVolumeMountPoint,
    LPSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );
WINBASEAPI
BOOL
WINAPI
FindNextVolumeMountPointW(
    HANDLE hFindVolumeMountPoint,
    LPWSTR lpszVolumeMountPoint,
    DWORD cchBufferLength
    );
#ifdef UNICODE
#define FindNextVolumeMountPoint FindNextVolumeMountPointW
#else
#define FindNextVolumeMountPoint FindNextVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
FindVolumeMountPointClose(
    HANDLE hFindVolumeMountPoint
    );

WINBASEAPI
BOOL
WINAPI
SetVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPCSTR lpszVolumeName
    );
WINBASEAPI
BOOL
WINAPI
SetVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPCWSTR lpszVolumeName
    );
#ifdef UNICODE
#define SetVolumeMountPoint SetVolumeMountPointW
#else
#define SetVolumeMountPoint SetVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
DeleteVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint
    );
WINBASEAPI
BOOL
WINAPI
DeleteVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint
    );
#ifdef UNICODE
#define DeleteVolumeMountPoint DeleteVolumeMountPointW
#else
#define DeleteVolumeMountPoint DeleteVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetVolumeNameForVolumeMountPointA(
    LPCSTR lpszVolumeMountPoint,
    LPSTR lpszVolumeName,
    DWORD cchBufferLength
    );
WINBASEAPI
BOOL
WINAPI
GetVolumeNameForVolumeMountPointW(
    LPCWSTR lpszVolumeMountPoint,
    LPWSTR lpszVolumeName,
    DWORD cchBufferLength
    );

#ifdef UNICODE
#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointW
#else
#define GetVolumeNameForVolumeMountPoint GetVolumeNameForVolumeMountPointA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetVolumePathNameA(
    LPCSTR lpszFileName,
    LPSTR lpszVolumePathName,
    DWORD cchBufferLength
    );
WINBASEAPI
BOOL
WINAPI
GetVolumePathNameW(
    LPCWSTR lpszFileName,
    LPWSTR lpszVolumePathName,
    DWORD cchBufferLength
    );
#ifdef UNICODE
#define GetVolumePathName GetVolumePathNameW
#else
#define GetVolumePathName GetVolumePathNameA
#endif // !UNICODE


#endif // #ifndef FindFirstVolume

#endif //#define _SYSSTRUC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\vapplication.hpp ===
#ifndef __VAPPLICATION_HPP
#define __VAPPLICATION_HPP

#ifndef VWCL_WRAP_WINDOWS_ONLY
	#include "vPtrArray.hpp"
#endif

#include "vSimpleString.hpp"

// <VDOC<CLASS=VApplication><DESC=Encapsulation of startup code, window handling logic, and support for internationalization><FAMILY=VWCL Core><AUTHOR=Todd Osborne (todd.osborne@poboxes.com)>VDOC>
class VApplication
{
public:
	VApplication()
	{
		// Initialize
		m_hInstance =				NULL;
		m_hResource =				NULL;
		
		#ifdef VWCL_INIT_OLE
			m_hrOleInitialize =		E_UNEXPECTED;
		#endif

		#ifndef _CONSOLE
			#ifndef VWCL_WRAP_WINDOWS_ONLY
				m_nCommandShow =		0;
				m_nLastKnownMapIndex =	-1;
				ZeroMemory(&m_CurrentMessage, sizeof(m_CurrentMessage));
			#endif
			m_hIcon =				NULL;
			m_pMainWindow =			NULL;
		#endif
	}

	virtual ~VApplication()
	{
		// Verify all allocated maps are gone
		#ifndef _CONSOLE
			#ifndef VWCL_WRAP_WINDOWS_ONLY
				while ( m_listWindowMaps.Size() )
					FreeWindowMap((LPVWCL_WINDOW_MAP)m_listWindowMaps[0]);
			#endif
		#endif

		// Free OLE
		#ifdef VWCL_INIT_OLE
			if ( SUCCEEDED(m_hrOleInitialize) )
				OleUninitialize();
		#endif
	}

	#ifndef _CONSOLE
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			// Allocate and initialize a window map object and add to list of maps
			LPVWCL_WINDOW_MAP	AllocWindowMap(VWindow* pWindow, HWND hWnd = NULL);
		#endif
	#endif

	// Get / Set the title for this application
	LPCTSTR					AppTitle(LPCTSTR lpszAppTitle)
		{ m_strAppTitle.String(lpszAppTitle); return m_strAppTitle.String(); }

	LPCTSTR					AppTitle()
		{ return m_strAppTitle.String(); }

	// Get / Set the current open file
	LPCTSTR					CurrentFile()
		{ return m_strCurrentFile.String(); }

	LPCTSTR					CurrentFile(LPCTSTR lpszFileName, BOOL bUpdateCaption = TRUE);

	#ifndef _CONSOLE
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			// Setup mappings of VWindow object to Windows window handle, and subclass non-VWCL class windows
			BOOL			Attach(VWindow* pWindow, HWND hWnd);

			// Remove any subclassing from the VWindow object, but do not destroy the window.
			// This function has no effect on VWCL registered and instantiated windows
			void			Detach(VWindow* pWindow);

			// Free a window map object and remove from list of maps
			void			FreeWindowMap(LPVWCL_WINDOW_MAP lpMap);
		#endif

		// Get command show param (the ShowWindow() API SW_xxx Constant)
		int					GetCommandShow()
			{ return m_nCommandShow; }
		
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			// Get the message currently being processed
			LPMSG			GetCurrentMessage()
				{ return &m_CurrentMessage; }
		#endif
	#endif

	// Get instance handle
	HINSTANCE				GetInstanceHandle()
		{ assert(m_hInstance); return m_hInstance; }

	#ifndef _CONSOLE
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			// Return the global WindowProc() procedure used by all VWCL windows
			WNDPROC				GetWindowProc()
				{ return WindowProc; }
		#endif

		// Get / Set icon
		HICON				Icon()
			{ return m_hIcon; }

		HICON				Icon(HICON hIcon)
			{ m_hIcon = hIcon; return m_hIcon; }
	#endif

	// Initialize class library, application startup, and register window classes
	// The icon and menu names will be used only for main window objects. You can optionally
	// provide a background color to use for registered window classes. One function is provided
	// for when windowing applications are being built, and others for when a console app is
	#ifndef _CONSOLE
		BOOL				Initialize(HINSTANCE hInstance, int nCommandShow, UINT nIDMenu, UINT nIDIcon, HBRUSH hBackgroundBrush = (HBRUSH)(COLOR_WINDOW + 1));
	#else
		BOOL				Initialize(HINSTANCE hInstance)
		{
			assert(hInstance);

			// Global application object should be uninitialized, you are walking on it!
			assert(m_hInstance == NULL);
			m_hInstance = hInstance;

			// Initialize Component Object Model
			#ifdef VWCL_INIT_OLE
				m_hrOleInitialize = OleInitialize(NULL);
				
				if ( FAILED(m_hrOleInitialize) )
					return FALSE;
			#endif

			return TRUE;
		}
	#endif

	// Returns TRUE if class library has been initialized (Instance handle set)
	BOOL					IsInitialized()
		{ return (m_hInstance) ? TRUE : FALSE; }

	#ifndef _CONSOLE
		// Get / Set main window pointer
		VWindow*			MainWindow()
			{ return m_pMainWindow; }

		VWindow*			MainWindow(VWindow* pWindow)
			{ m_pMainWindow = pWindow; return m_pMainWindow; }
	#endif

	// / Get / Set the resource handle. By default this is the same as instance
	HINSTANCE				ResourceHandle()
		{ assert(m_hResource); return m_hResource; }

	HINSTANCE				ResourceHandle(HINSTANCE hResource)
		{ assert(hResource); m_hResource = hResource; return m_hResource; }

	#ifndef _CONSOLE
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			// Create a window using specified CREATESTRUCT and call Attach()
			// to attach it to a VWindow object, and add to map. All memory
			// allocations (AllocWindowMap) will be done for calling code
			BOOL			VCreateWindow(VWindow* pWindow, LPCREATESTRUCT lpCreateStruct, BOOL bDontCallPostCreateWindow = FALSE);

			// Get a VWindow pointer when a HWND is known. Returns NULL on failure
			VWindow*		VWindowFromHandle(HWND hWnd);
		#endif
	#endif

protected:
	#ifndef _CONSOLE
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			// Resolves hWnd to VWindow objects and dispatches message
			LRESULT					HandleMessage(HWND hWnd, UINT nMessage, WPARAM wParam, LPARAM lParam);

			// Shared window procedure by all VWindow and derived objects. This function
			// simply resolves the global application object and calls VWindow object to handle message
			static LRESULT CALLBACK	WindowProc(HWND hWnd, UINT nMessage, WPARAM wParam, LPARAM lParam);
		#endif
	#endif

private:
	// Embedded Members
	HINSTANCE				m_hInstance;
	HINSTANCE				m_hResource;
	VSimpleString			m_strAppTitle;
	VSimpleString			m_strCurrentFile;

	#ifdef VWCL_INIT_OLE
		HRESULT				m_hrOleInitialize;
	#endif

	#ifndef _CONSOLE
		HICON				m_hIcon;
		int					m_nCommandShow;
		VWindow*			m_pMainWindow;
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			MSG				m_CurrentMessage;
			VPtrArray		m_listWindowMaps;
			int				m_nLastKnownMapIndex;
		#endif
	#endif
};

#endif	// __VAPPLICATION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\vsimplestring.hpp ===
#ifndef __VSIMPLESTRING_HPP
#define __VSIMPLESTRING_HPP

#include "vStandard.h"

// <VDOC<CLASS=VSimpleString><DESC=A very lightweight class that supports dynamically allocated C style strings. This class can also be used any time a fixed amount of dynamic memory is needed.><FAMILY=String Processing,General Utility><AUTHOR=Todd Osborne (todd.osborne@poboxes.com)>VDOC>
class VSimpleString
{
public:
	VSimpleString(LPCTSTR lpszText = NULL, UINT nExtraBytes = 0)
		{ m_lpszString = NULL; m_nBufferSize = 0; String(lpszText, nExtraBytes); }

	virtual ~VSimpleString()
		{ String(NULL); }

	operator	LPTSTR()
		{ return m_lpszString; }

	operator	LPCTSTR()
		{ return m_lpszString; }

	// Get the length of the string, or if bBuffer is TRUE, the amount of allocated memory
	UINT		GetLength(BOOL bBuffer = FALSE)
		{ return (bBuffer) ? m_nBufferSize : (m_lpszString) ? lstrlen(m_lpszString) : 0; }

	// Set a pointer to globally allocate memory into object. This can be done to replace a string pointer
	// will a previously "stolen" pointer from the StealBuffer() function
	LPTSTR		ReplaceBuffer(LPTSTR lpszString, UINT nBufferSize = 0)
		{ String(NULL, 0), m_lpszString = lpszString, m_nBufferSize = (nBufferSize) ? nBufferSize : (m_lpszString) ? lstrlen(m_lpszString) : 0; return m_lpszString; }

	// Steal the buffer. Calling code takes ownership of string pointer and must
	// free it when done using GlobalFreePtr()
	LPTSTR		StealBuffer()
		{ LPTSTR lpszBuffer = m_lpszString; m_lpszString = NULL; m_nBufferSize = 0; return lpszBuffer; }

	// Get the text pointer
	LPTSTR		String()
		{ return m_lpszString; }

	// Save lpszString in class and returns pointer to buffer if a string is held.
	// If nExtraBytes is set, that much more memory will be allocated in addition
	// to the length of lpszString. lpszString can be NULL and still have memory
	// allocated if nExtraBytes is not 0
	LPTSTR		String(LPCTSTR lpszString, UINT nExtraBytes = 0)
	{
		if ( m_lpszString )
			GlobalFreePtr(m_lpszString);
		
		m_nBufferSize = nExtraBytes;
		
		if ( lpszString )
			m_nBufferSize += (lstrlen(lpszString) + 1);

		m_lpszString = (m_nBufferSize) ? (LPTSTR)GlobalAllocPtr(GPTR, m_nBufferSize) : NULL;
		
		if ( m_lpszString )
		{
			if ( lpszString )
				lstrcpy(m_lpszString, lpszString);
		}
		else
			m_nBufferSize = 0;

		return m_lpszString;
	}

private:
	// Embedded Member(s)
	LPTSTR		m_lpszString;
	UINT		m_nBufferSize;
};

#endif // __VSIMPLESTRING_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\vstandard.h ===
#ifndef __VSTANDARD_H
#define __VSTANDARD_H

// This is the standard include file for the Virtual Windows Class Library (VWCL)
// This header replaces the older VWCL.H and is used only to define basic functionality,
// and implies nothing about the application being written. In fact, the application can
// be C++ or a mix of C and C++. Previous releases of VWCL (Prior to December 1997) used
// the preprocessor extensively to include or excluse code. VWCL grew to such a size that
// this method proved extremely hard to maintain. The new method requires the users of VWCL
// to include manually the classes they need. Those classes, should they require others, will
// include those other headers as needed. This makes the code more maintainable, and also has
// the benefit of better code re-use and builds smaller and tighter application by only including
// required code. There are still some basic preprocessor command that can or should be defined:

// VWCL_NO_GLOBAL_APP_OBJECT -		Causes vWindowAppCore.cpp to not implement a global application object
// VWCL_NO_REGISTER_CLASSES -		Causes VApplication::Initialize() not to register VWindow and VMainWindow classes
// VWCL_WRAP_WINDOWS_ONLY -			Causes VWindow(s) to wrap HWND's only, not subclass them
// VWCL_INIT_COMMON_CONTROLS -		Causes VApplication::Initialize() to call InitCommonControls()
// VWCL_INIT_OLE -					Causes VApplication::Initialize() to call OleInitialize()/OleUninitialize()
// VWCL_EXPORT_DLL -				Define this when building a DLL version of class library
//									A shared VWCL DLL can only be loaded once per process. VWCL has
//									no state or resource management functions, so multiple DLL's that
//									use VWCL dynamically linked into one EXE would fail to locate resources
//									outside of the calling programs resources. A call to VGetApp()->Initialize()
//									from these DLL's would corrupt the EXE's global VApplication object.
// VWCL_IMPORT_DLL -				Define this when using VWCL from a DLL (importing)

// Force strict type checking
#ifndef STRICT
	#define STRICT
#endif

// Include standard Windows header
#include <windows.h>

// Include Windows extensions header
#include <windowsx.h>

// Support debug build assertions
#include <assert.h>

// Support TCHAR generic text mapping
#include <tchar.h>

// OutputDebugString wrapper
#ifdef _DEBUG
	#ifndef ODS
		#define ODS(string)OutputDebugString(string);
	#endif
#else
	#ifndef ODS
		#define ODS(string)
	#endif
#endif

// Macro compiles to assert(expression) in debug build, and just expression in release build
#ifndef VERIFY
	#ifdef _DEBUG
		#define	VERIFY(expression) assert(expression)
	#else
		#define VERIFY(expression) expression
	#endif
#endif

// Not all compilers define this macro
#ifndef MAKEWORD
	#define MAKEWORD(a, b)((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#endif

// Not all compilers define this
#ifndef LPBOOL
	#define LPBOOL BOOL FAR*
#endif

// Determine how classes and functions are exported, imported, or nothing
#ifdef VWCL_EXPORT_DLL
	#define VWCL_API _declspec(dllexport)
#else
	#ifdef VWCL_IMPORT_DLL
		#define VWCL_API _declspec(dllimport)
	#else
		#define VWCL_API
	#endif
#endif

// VWCL implements these in vWindowAppCore.cpp. Non-VWCL apps do not need to implement
#ifdef __cplusplus
	class				VApplication;
	class				VWindow;
	VApplication*		VGetApp();
	
	#ifndef VWCL_WRAP_WINDOWS_ONLY
		VWCL_API BOOL	VTranslateDialogMessage(LPMSG lpMsg);

		typedef struct tagVWCL_WINDOW_MAP
		{
			HWND		hWnd;
			VWindow*	pWindow;

		} VWCL_WINDOW_MAP;

		typedef VWCL_WINDOW_MAP FAR* LPVWCL_WINDOW_MAP;

		static LPCTSTR	VMAINWINDOWCLASS =	_T("VMainWindow");
		static LPCTSTR	VWINDOWCLASS =		_T("VWindow");
	#endif
#endif

// For argc and argv support
#ifdef __cplusplus
	extern "C" __declspec(dllimport) int	argc;
	extern "C" __declspec(dllimport) char**	argv;
#else
	static int		argc;
	static char**	argv;
#endif

#define argc	__argc
#define argv	__argv

// Standard C style Global VWCL API's
#ifdef __cplusplus
	extern "C" {
#endif

// If building a standard GUI VWCL application, these functions will already be implemented
// for you in vWindowAppCore.cpp. However, if you are picking an choosing classes from VWCL
// to use in another application, you may have to implement these C style functions because
// those classes that require these will have to have them to compile and link properly

// Return a static string buffer to the applications title, or name
LPCTSTR			VGetAppTitle();

// Return the show command (ShowWindow() SW_xxx constant passed on command line)
int				VGetCommandShow();

// Return the global instance handle of the application or DLL
HINSTANCE		VGetInstanceHandle();

// Return the instance handle where resources are held
HINSTANCE		VGetResourceHandle();

// GDI Support Routines implemented in vGDIGlobal.c
VWCL_API void	VMapCoords			(HDC hDC, LPSIZEL lpSizeL, BOOL bToPixels);
VWCL_API void	VPixelsToHIMETRIC	(LPSIZEL lpSizeL, HDC hDC);
VWCL_API void	VPixelsFromHIMETRIC	(LPSIZEL lpSizeL, HDC hDC);

// OLE Support Routines implemented in vOLEGlobal.c
// Given a C string, allocate a new string with CoTaskMemAlloc() and copy string
VWCL_API BOOL	VCoStringFromString(LPTSTR* lppszCoString, LPCTSTR lpszString);

// Debugging Support Routines implemented in vDebugGlobal.c
// Show the result from GetLastError() as a message box, or ODS if a console application
VWCL_API int	VShowLastErrorMessage(HWND hWndParent);

#ifdef __cplusplus
	}
#endif

#endif // __VSTANDARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskcomp\diskcomp.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        diskcomp.cxx

Abstract:

        Utility to compare two disks

Author:

        Norbert P. Kusters (norbertk) 10-May-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "system.hxx"
#include "ifssys.hxx"
#include "supera.hxx"
#include "hmem.hxx"
#include "cmem.hxx"
#include "ulibcl.hxx"


INT
DiskComp(
    IN      PCWSTRING   SrcNtDriveName,
    IN      PCWSTRING   DstNtDriveName,
    IN      PCWSTRING   SrcDosDriveName,
    IN      PCWSTRING   DstDosDriveName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine copies on floppy diskette to another floppy diskette.

Arguments:

    SrcNtDriveName  - Supplies the NT style drive name for the source.
    DstNtDriveName  - Supplies the NT style drive name for the destination.
    SrcDosDriveName - Supplies the DOS style drive name for the source.
    DstDosDriveName - Supplies the DOS style drive name for the destination.
    Message         - Supplies an outlet for messages.

Return Value:

    0   - The disks are the same.
    1   - The disks are different.
    3   - A hard error occurred.
    4   - An initialization error occurred.

--*/
{
    LOG_IO_DP_DRIVE src_drive;
    LOG_IO_DP_DRIVE dst_drive;
    HMEM            src_hmem;
    HMEM            dst_hmem;
    CONT_MEM        src_cmem;
    PVOID           mem_ptr;
    SECRUN          src_secrun;
    SECRUN          dst_secrun;
    SECTORCOUNT     sec_per_track;
    ULONG           total_tracks;
    ULONG           grab;       // number of tracks to grab at once.
    ULONG           sector_size;
    BOOLEAN         one_drive;
    ULONG           src_top;    // src track pointer -- next read
    ULONG           dst_top;    // dst track pointer -- next write
    PCHAR           dst_pchar;
    PCHAR           src_pchar;
    ULONG           i;
    BOOLEAN         the_same;
    ULONG           heads;
    DSTRING         fsname;
#if defined(FE_SB) && defined(_X86_)
    MEDIA_TYPE      AltMediaType;
#endif

    one_drive = (*SrcDosDriveName == *DstDosDriveName);

    Message->Set(MSG_DCOMP_INSERT_FIRST);
    Message->Display("%W", SrcDosDriveName);

    if (!one_drive) {
        Message->Set(MSG_DCOMP_INSERT_SECOND);
        Message->Display("%W", DstDosDriveName);
    }

    Message->Set(MSG_PRESS_ENTER_WHEN_READY);
    Message->Display();
    Message->WaitForUserSignal();

    if (!src_drive.Initialize(SrcNtDriveName)) {

        // Verify that we can access the source drive:

        if (src_drive.QueryLastNtStatus() == STATUS_ACCESS_DENIED) {
            Message->Set(MSG_DASD_ACCESS_DENIED);
            Message->Display();
            return 4;
        }

        Message->Set(MSG_DCOMP_FIRST_DISK_BAD);
        Message->Display();
        return 3;
    }

    if (!src_drive.IsFloppy()) {
        Message->Set(MSG_DCOPY_INVALID_DRIVE);
        Message->Display();
        return 4;
    }

    if (src_drive.QueryMediaType() == Unknown) {
        Message->Set(MSG_DCOMP_FIRST_DISK_BAD);
        Message->Display();
        return 3;
    }

    Message->Set(MSG_DCOMP_COMPARING);
    Message->Display("%d%d%d", src_drive.QueryCylinders().GetLowPart(),
                               src_drive.QuerySectorsPerTrack(),
                               src_drive.QueryHeads());

    sec_per_track = src_drive.QuerySectorsPerTrack();
    sector_size = src_drive.QuerySectorSize();
    total_tracks = src_drive.QueryTracks().GetLowPart();
    heads = src_drive.QueryHeads();

    DebugAssert(src_drive.QuerySectors().GetHighPart() == 0);

    src_top = 0;

    if (!dst_hmem.Initialize()) {
        return 4;
    }

    the_same = TRUE;

    for (dst_top = 0; dst_top < total_tracks; dst_top++) {

        if (src_top == dst_top) {

            if (src_top && one_drive) {
                Message->Set(MSG_DCOMP_INSERT_FIRST);
                Message->Display("%W", SrcDosDriveName);
                Message->Set(MSG_PRESS_ENTER_WHEN_READY);
                Message->Display();
                Message->WaitForUserSignal();
            }


            // Allocate memory for read.

            for (grab = total_tracks - src_top;
                 !src_hmem.Initialize() ||
                 !(mem_ptr = src_hmem.Acquire(grab*sector_size*sec_per_track,
                                              src_drive.QueryAlignmentMask()));
                 grab /= 2) {

                if (grab < 2) {
                    Message->Set(MSG_CHK_NO_MEMORY);
                    Message->Display();
                    return 4;
                }
            }

            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                return 4;
            }


            // Read the source, track by track.

            for (i = 0; i < grab; i++) {
                if (!src_secrun.Initialize(&src_cmem, &src_drive,
                                           src_top*sec_per_track,
                                           sec_per_track)) {
                    return 4;
                }

                if (!src_secrun.Read()) {

                    if (src_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                        src_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                        return 3;
                    }

                    Message->Set(MSG_DCOPY_READ_ERROR);
                    Message->Display("%W%d%d", SrcDosDriveName,
                                               src_top%heads, src_top/heads);
                    the_same = FALSE;
                }
                src_top++;
            }

            if (!src_cmem.Initialize(mem_ptr, grab*sector_size*sec_per_track)) {
                return 4;
            }

            if (one_drive) {
                Message->Set(MSG_DCOMP_INSERT_SECOND);
                Message->Display("%W", DstDosDriveName);
                Message->Set(MSG_PRESS_ENTER_WHEN_READY);
                Message->Display();
                Message->WaitForUserSignal();
            }

                        if (!dst_top) {

                if (!dst_drive.Initialize(DstNtDriveName)) {

                    // verify that we can access the destination drive:

                    if (dst_drive.QueryLastNtStatus() == STATUS_ACCESS_DENIED) {

                        Message->Set(MSG_DASD_ACCESS_DENIED);
                        Message->Display( "" );
                        return 4;
                    }

                    Message->Set(MSG_DCOMP_SECOND_DISK_BAD);
                    Message->Display();
                    return 3;
                }

                if (dst_drive.QueryMediaType() != src_drive.QueryMediaType()) {
#if defined(FE_SB) && defined(_X86_)
                    switch (src_drive.QueryMediaType()) {
                        case F5_1Pt23_1024:
                            AltMediaType = F3_1Pt23_1024;
                            break;
                        case F3_1Pt23_1024:
                            AltMediaType = F5_1Pt23_1024;
                            break;
                        case F5_1Pt2_512:
                            AltMediaType = F3_1Pt2_512;
                            break;
                        case F3_1Pt2_512:
                            AltMediaType = F5_1Pt2_512;
                            break;
                        case F3_720_512:
                            AltMediaType = F5_720_512;
                            break;
                        case F5_720_512:
                            AltMediaType = F3_720_512;
                            break;
                        case F5_640_512:
                            AltMediaType = F3_640_512;
                            break;
                        case F3_640_512:
                            AltMediaType = F5_640_512;
                            break;
                        default:
                            AltMediaType = src_drive.QueryMediaType();
                            break;
                    }

                    // Second try with AltMediaType
                    if (dst_drive.QueryMediaType() != AltMediaType) {
#endif
                        Message->Set(MSG_DCOMP_NOT_COMPATIBLE);
                        Message->Display();
                        return 4;
#if defined(FE_SB) && defined(_X86_)
                    }
#endif
                }
            }
        }

        if (!dst_secrun.Initialize(&dst_hmem, &dst_drive,
                                   dst_top*sec_per_track, sec_per_track)) {
            return 4;
        }

        if (dst_secrun.Read()) {
            src_pchar = (PCHAR) src_cmem.Acquire(sector_size*sec_per_track);
            dst_pchar = (PCHAR) dst_secrun.GetBuf();

            if (!dst_top) {
                if ((src_pchar[0x26] == 0x28 || src_pchar[0x26] == 0x29) &&
                    (dst_pchar[0x26] == 0x28 || dst_pchar[0x26] == 0x29)) {
                    memcpy(src_pchar + 0x27, dst_pchar + 0x27, sizeof(ULONG));
                }
            }

            if (memcmp(src_pchar, dst_pchar, (UINT) (sector_size*sec_per_track))) {
                Message->Set(MSG_DCOMP_COMPARE_ERROR);
                Message->Display("%d%d", dst_top%heads, dst_top/heads);
                the_same = FALSE;
            }

        } else {

            if (dst_drive.QueryLastNtStatus() == STATUS_NO_MEDIA_IN_DEVICE ||
                dst_drive.QueryLastNtStatus() == STATUS_UNRECOGNIZED_MEDIA) {
                return 3;
            }

            Message->Set(MSG_DCOPY_READ_ERROR);
            Message->Display("%W%d%d", DstDosDriveName,
                                       dst_top%heads, dst_top/heads);
            the_same = FALSE;
        }
    }

    if (the_same) {
        Message->Set(MSG_DCOMP_OK);
        Message->Display();
    }

    return the_same ? 0 : 1;
}


INT __cdecl
main(
    )
/*++

Routine Description:

    Main program for DISKCOMP.

Arguments:

    None.

Return Value:

    0   - The disks are the same.
    1   - The disks are different.
    3   - Fatal hard error.
    4   - Initialization error.

--*/
{
    STREAM_MESSAGE      msg;
    PMESSAGE            message;
    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    STRING_ARGUMENT     progname;
    STRING_ARGUMENT     drive_arg1;
    STRING_ARGUMENT     drive_arg2;
        FLAG_ARGUMENT           slashv;
        FLAG_ARGUMENT           helparg;
    DSTRING             dossource;
    DSTRING             dosdest;
    DSTRING             ntsource;
    DSTRING             ntdest;
    PWSTRING            pwstring;
    DSTRING             colon;
    INT                 result;


    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {
        return 4;
    }

    message = &msg;

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 4;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 4;
    }

    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 4;
    }

    if (!progname.Initialize("*") ||
        !drive_arg1.Initialize("*:") ||
        !drive_arg2.Initialize("*:") ||
                !helparg.Initialize("/?")) {
        return 4;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&drive_arg1) ||
        !arg_array.Put(&drive_arg2) ||
                !arg_array.Put(&helparg)) {
        return 4;
        }

        if (!arglex.DoParsing(&arg_array)) {
                message->Set(MSG_INVALID_PARAMETER);
                message->Display("%W", pwstring = arglex.QueryInvalidArgument());
                DELETE(pwstring);
                return 4;
        }

        if (helparg.QueryFlag()) {
        message->Set(MSG_DCOMP_INFO);
        message->Display();
        message->Set(MSG_DCOMP_USAGE);
        message->Display();
        return 0;
        }

    if (!colon.Initialize(":")) {
        return 4;
    }

    if (drive_arg1.IsValueSet()) {
        if (!dossource.Initialize(drive_arg1.GetString()) ||
            !dossource.Strcat(&colon) ||
            !dossource.Strupr()) {
            return 4;
        }
    } else {
        if (!SYSTEM::QueryCurrentDosDriveName(&dossource)) {
            return 4;
        }
    }

    if (drive_arg2.IsValueSet()) {
        if (!dosdest.Initialize(drive_arg2.GetString()) ||
            !dosdest.Strcat(&colon) ||
            !dosdest.Strupr()) {
            return 4;
        }
    } else {
        if (!SYSTEM::QueryCurrentDosDriveName(&dosdest)) {
            return 4;
        }
    }

    if (SYSTEM::QueryDriveType(&dossource) != RemovableDrive) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (SYSTEM::QueryDriveType(&dosdest) != RemovableDrive) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dossource, &ntsource)) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdest, &ntdest)) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    for (;;) {

        result = DiskComp(&ntsource, &ntdest, &dossource, &dosdest, message);

        if (result > 1) {
            message->Set(MSG_DCOMP_ENDED);
            message->Display();
        }

        message->Set(MSG_DCOMP_ANOTHER);
        message->Display();

        if (!message->IsYesResponse(FALSE)) {
            break;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskcomp\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=diskcomp
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\diskcomp.cxx ..\diskcomp.rc

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

CXXFLAGS=+d
TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\vstring.hpp ===
#ifndef __VSTRING_HPP
#define __VSTRING_HPP

#include "vStandard.h"

// <VDOC<CLASS=VString><DESC=Encapsulates a dynamically allocated C style string><FAMILY=String Processing><AUTHOR=Todd Osborne (todd.osborne@poboxes.com)>VDOC>
class VString
{
public:
    // Default constructor
    VString()
        { m_lpszString = NULL; }
    
    // Construct with existing C string
    VString(LPCTSTR lpszString, int nCount = -1)
        { m_lpszString = NULL; AllocCopy(lpszString, TRUE, nCount); }
    
    // Construct with existing VString reference
    VString(VString& strOriginal, int nCount = -1)
        { m_lpszString = NULL; AllocCopy(strOriginal.GetBuffer(), TRUE, nCount); }

    // Construct with existing VString pointer
    VString(VString* pstrOriginal, int nCount = -1)
        { m_lpszString = NULL; AllocCopy(*pstrOriginal, TRUE, nCount); }

    // Construct by loading string from resouce. If hResource is NULL, VGetResourceHandle() will be used
    VString(UINT nStringID, HINSTANCE hResource = NULL)
        { m_lpszString = NULL; LoadString(nStringID, hResource); }
    
    // Construct by initializing with text from a window
    VString(HWND hWnd)
        { m_lpszString = NULL; GetWindowText(hWnd); }

    // Destructor
    virtual ~VString()
        { Empty(); }

    //  Overloaded Operators 
    
    // Return C style strings
    TCHAR &operator[](int nIndex)
        { assert(m_lpszString);  assert(nIndex < lstrlen(m_lpszString)); return m_lpszString[nIndex]; }

    operator LPTSTR()
        { return m_lpszString; }

    operator LPCTSTR()
        { return m_lpszString; }

    // Assignment
    BOOL operator = (LPCTSTR lpszString)
        { return AllocCopy(lpszString, TRUE); }
    BOOL operator = (VString& string)
        { return AllocCopy((LPCTSTR)string, TRUE); }
    BOOL operator = (VString* pString)
        { return AllocCopy((LPCTSTR)*pString, TRUE); }

    // Concatenation
    BOOL operator += (TCHAR nChar)
        { return AddChar(nChar); }
    BOOL operator += (LPCTSTR lpszString)
        { return AllocCopy(lpszString, FALSE); }
    BOOL operator += (VString& string)
        { return AllocCopy((LPCTSTR)string, FALSE); }
    BOOL operator += (VString* pString)
        { return AllocCopy((LPCTSTR)*pString, FALSE); }

    // Comparison without case
    BOOL operator == (LPCTSTR lpszString)
        { return CompareNoCase(lpszString) == 0; }
    BOOL operator == (VString& string)
        { return CompareNoCase((LPCTSTR)string) == 0; }
    BOOL operator == (VString* pString)
        { return CompareNoCase((LPCTSTR)*pString) == 0; }

    BOOL operator != (LPCTSTR lpszString)
        { return CompareNoCase(lpszString) != 0; }
    BOOL operator != (VString& string)
        { return CompareNoCase((LPCTSTR)string) != 0; }
    BOOL operator != (VString* pString)
        { return CompareNoCase((LPCTSTR)*pString) != 0; }
    
    BOOL operator < (LPCTSTR lpszString)
        { return CompareNoCase(lpszString) == -1; }
    BOOL operator < (VString& string)
        { return CompareNoCase((LPCTSTR)string) == -1; }
    BOOL operator < (VString* pString)
        { return CompareNoCase((LPCTSTR)*pString) == -1; }

    BOOL operator <= (LPCTSTR lpszString)
        { return CompareNoCase(lpszString) != 1; }
    BOOL operator <= (VString& string)
        { return CompareNoCase((LPCTSTR)string) != -1; }
    BOOL operator <= (VString* pString)
        { return CompareNoCase((LPCTSTR)*pString) != -1; }

    BOOL operator > (LPCTSTR lpszString)
        { return CompareNoCase(lpszString) == 1; }
    BOOL operator > (VString& string)
        { return CompareNoCase((LPCTSTR)string) == 1; }
    BOOL operator > (VString* pString)
        { return CompareNoCase((LPCTSTR)*pString) == 1; }

    BOOL operator >= (LPCTSTR lpszString)
        { return CompareNoCase(lpszString) != -1; }
    BOOL operator >= (VString& string)
        { return CompareNoCase((LPCTSTR)string) != -1; }
    BOOL operator >= (VString* pString)
        { return CompareNoCase((LPCTSTR)*pString) != -1; }

    // Add a single character to the end of the string
    // Protected by critical section in AllocCopy()
    BOOL        AddChar(TCHAR nChar)
        { TCHAR sz[] = {nChar, _T('\0')}; return AllocCopy(sz, FALSE); }

    // Case sensitive comparison
    // Returns zero if the strings are identical, -1 if this VString object is less than lpszString, or 1 if this VString object is greater than lpszString
    int         Compare(LPCTSTR lpszString)
        { assert(m_lpszString && lpszString); return lstrcmp(m_lpszString, lpszString); }

    // Compare without case
    // Returns zero if the strings are identical (ignoring case), -1 if this VString object is less than lpszString (ignoring case), or 1 if this VString object is greater than lpszString (ignoring case)
    int         CompareNoCase(LPCTSTR lpszString)
        { assert(m_lpszString && lpszString); return lstrcmpi(m_lpszString, lpszString); }

    // Clear contents of string
    void        Empty()
    { 
        if (NULL != m_lpszString) {
            delete [] m_lpszString; 
            m_lpszString = NULL; 
        }
    }

    // Find first occurence of substring or character in string. Returns index into string if found, -1 otherwise
    int         Find(LPCTSTR lpszSubString)
        { assert(m_lpszString && lpszSubString); LPTSTR lpszFound = _tcsstr(m_lpszString, lpszSubString); return (lpszFound) ? (int)(lpszFound - m_lpszString) : -1; }

    int         Find(TCHAR nChar)
        { assert(m_lpszString); LPTSTR lpszFound = _tcschr(m_lpszString, nChar); return (lpszFound) ? (int)(lpszFound - m_lpszString) : -1; }

    // Get the internal buffer
    LPTSTR      GetBuffer()
        { return m_lpszString; }

    // Get the length of the string
    int         GetLength()
        { return (m_lpszString) ? lstrlen(m_lpszString) : 0; }

    // Set the path of the module in hInstance into VString. If bPathOnly is specified,
    // only the path, including the last backlash will be saved, otherwise the entire path will be.
    // If hInstance is NULL, VGetInstanceHandle() will be used
    BOOL        GetModulePath(HINSTANCE hInstance = NULL, BOOL bPathOnly = TRUE)
    {
        TCHAR sz[MAX_PATH] = {_T('\0')};

        if ( GetModuleFileName((hInstance) ? hInstance : VGetInstanceHandle(), sz, sizeof(sz)/sizeof(TCHAR)) )
        {
            // Terminate after last backslash?
            TCHAR *pszEnd = (bPathOnly) ? _tcsrchr(sz, _T('\\')) : NULL;

            if  ( pszEnd )
                *(pszEnd + 1) = _T('\0');

            return AllocCopy(sz, TRUE);
        }

        return FALSE;
    }

    // Copy text from a window to the VString
    BOOL        GetWindowText(HWND hWnd)
    {
        assert(hWnd && IsWindow(hWnd));
        
        BOOL bResult = TRUE;
        
        if ( hWnd && IsWindow(hWnd) )
        {
            int nLen = (int)::SendMessage(hWnd, WM_GETTEXTLENGTH, 0, 0);
            
            if ( nLen )
            {
                TCHAR   sz[1024];
                LPTSTR  lpszWindowText = sz;
                
                // Dynamic memory alloc only if stack is not sufficient
                if ( nLen > sizeof(sz - 1)/sizeof(TCHAR) )
                    lpszWindowText = new TCHAR[nLen + 1];
                
                if ( lpszWindowText )
                {
                    // Get text and copy to VString
                    ::GetWindowText(hWnd, lpszWindowText, nLen + 1);
                    bResult = AllocCopy(lpszWindowText, TRUE);
                }
                else
                    return FALSE;
                
                // Free if not stack alloc
                if ( lpszWindowText != sz )
                    delete [] lpszWindowText;
            }
            else
                // Empty window text is still valid. VString is reset
                Empty();
        }
        
        return bResult;
    }

    // Is the string empty?
    BOOL        IsEmpty()
        { return (GetLength()) ? FALSE : TRUE; }

    // Substring extraction
    VString     Left(int nCount)
        { VString str; str.AllocCopy(m_lpszString, TRUE, nCount); return str; }

    // Load a string from resources. Returns TRUE on success, FALSE on failure
    // If hResource is NULL, VGetResourceHandle() will be used
    BOOL        LoadString(UINT nStringID, HINSTANCE hResource = NULL)
    {
        TCHAR szTemp[1024];
        BOOL bResult = FALSE;
        
        if ( !hResource )
            hResource = VGetResourceHandle();

        assert(hResource);

        // Attempt to load string into stack buffer first
        int nLen = ::LoadString(hResource, nStringID, szTemp, sizeof(szTemp)/sizeof(TCHAR));

        if ( nLen )
        {
            if (  nLen == sizeof(szTemp)/sizeof(TCHAR) - 1 )
            {
                // Calculate the largest size possible for string block (whole block, not just nStringID)
                HRSRC hRes =    FindResource(hResource, MAKEINTRESOURCE((nStringID >> 4) + 1), RT_STRING);
                DWORD dwSize =  (hRes) ? SizeofResource(hResource, hRes) : 0;
                assert(dwSize);

                // Allocate temporary block equal to the size of the entire string block
                // This is quite wasteful, but WinAPI does not provide a way to extract an
                // exact string length from the resources, and LoadString() will copy only
                // up to the buffer size, truncating longer strings
                LPTSTR lpszNewString = new TCHAR[dwSize + 1];

                if ( lpszNewString )
                {
                    // Load string into temp var and AllocCopy() to set permanently
                    bResult = (::LoadString(hResource, nStringID, lpszNewString, dwSize)) ? AllocCopy(lpszNewString, TRUE) : FALSE;

                    // Free local string
                    delete [] lpszNewString;
                }
            }
            else
                bResult = AllocCopy(szTemp, TRUE);
        }
        
        return bResult;
    }
    
    // Make the string a GetOpenFileName() or GetSaveFileName() filter. That is, replace
    // all occurances of \n in the string with \0 (zero terminators)
    LPCTSTR     MakeFilter()
    {
        int nLen = GetLength();
        
        for ( int i = 0; i < nLen; i++ )
        {
            if ( *(m_lpszString + i) == _T('\n') )
                *(m_lpszString + i) = _T('\0');
        }

        return m_lpszString;
    }

    // Make all characters lower case
    LPCTSTR     MakeLower()
        { assert(m_lpszString); return _tcslwr(m_lpszString); }

    // Make all characters upper case
    LPCTSTR     MakeUpper()
        { assert(m_lpszString); return _tcsupr(m_lpszString); }

    // Substring extraction
    VString     Mid(int nFirst, int nCount)
    {
        assert(m_lpszString);
        assert(nCount >= 0);

        VString str;

        if ( nFirst < GetLength() )
            str.AllocCopy(m_lpszString + nFirst, TRUE, nCount);

        return str;
    }
    
    VString     Mid(int nFirst)
        { return Mid(nFirst, GetLength() - nFirst); }

    VString     Right(int nCount)
    {
        assert(m_lpszString);

        VString str;

        if ( nCount <= GetLength() )
            str.AllocCopy(m_lpszString + (GetLength() - nCount), TRUE, nCount);

        return str;
    }

    // Remote all spaces from left and right side of string
    void        Trim()
        { TrimLeft(); TrimRight(); }

    // Remove all space characters from left side of string
    void        TrimLeft()
    {
        if ( m_lpszString )
        {
            int nIndex = 0;

            while ( m_lpszString[nIndex] && m_lpszString[nIndex] == _T(' '))
                nIndex++;

            if ( nIndex )
                AllocCopy(m_lpszString + nIndex, TRUE);
        }
    }

    // Remove all space characters from right side of string
    void        TrimRight()
    {
        if ( m_lpszString )
        {
            int nLength =   GetLength();
            int nIndex =    nLength - 1;
            
            while ( m_lpszString[nIndex] && m_lpszString[nIndex] == _T(' '))
                nIndex--;

            if ( nIndex < nLength - 1 )
                AllocCopy(m_lpszString, TRUE, nIndex + 1);
        }
    }

protected:
    // Allocate and copy. If nCount is -1, entire string will be copied, otherwise only nCount characters
    BOOL        AllocCopy(LPCTSTR lpszString, BOOL bReplace, int nCount = -1)
    {
        // Fix count of characters to copy if needed
        if ( nCount == -1 )
            nCount = lstrlen(lpszString);

        // Determine length of lpszString
        int nLen = (lpszString) ? lstrlen(lpszString) : 0;

        if ( nLen )
        {
            // nCount should not be less that or equal to 0
            assert(nCount > 0);

            // Use the min of nLen and nCount as the new length
            if ( nCount < nLen )
                nLen = nCount;

            // Allocate memory to new buffer
            LPTSTR lpszNewString = new TCHAR[nLen + 1 + ((bReplace || !GetLength()) ? 0 : GetLength())];
            
            if ( lpszNewString )
            {
                if ( bReplace || !m_lpszString )
                    lstrcpyn(lpszNewString, lpszString, nLen + 1);
                else
                {
                    // Append
                    lstrcpy(lpszNewString, m_lpszString);
                    lstrcpyn(lpszNewString + GetLength(), lpszString, nLen + 1);
                }
                // Free old memory and save new pointer
                Empty();
                m_lpszString = lpszNewString;
            }
            else
                return FALSE;
        }
        else
            Empty();

        return TRUE;
    }
    
private:
    // Embedded Member(s)
    LPTSTR      m_lpszString;
};

#endif  // __VSTRING_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskcopy\diskcopy.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        diskcopy.cxx

Abstract:

        Utility to duplicate a disk

Author:

        Norbert P. Kusters (norbertk) 10-May-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "arg.hxx"
#include "array.hxx"
#include "smsg.hxx"
#include "rtmsg.h"
#include "wstring.hxx"
#include "system.hxx"
#include "ifssys.hxx"
#include "supera.hxx"
#include "hmem.hxx"
#include "cmem.hxx"
#include "ulibcl.hxx"
#include "mldcopy.hxx"

INT __cdecl
main(
    )
/*++

Routine Description:

    Main program for DISKCOPY.

Arguments:

    None.

Return Value:

    0   - Copy was successful.
    1   - A nonfatal read/write error occured.
    3   - Fatal hard error.
    4   - Initialization error.

--*/
{
    STREAM_MESSAGE      msg;
    PMESSAGE            message;
    ARGUMENT_LEXEMIZER  arglex;
    ARRAY               lex_array;
    ARRAY               arg_array;
    STRING_ARGUMENT     progname;
    STRING_ARGUMENT     drive_arg1;
    STRING_ARGUMENT     drive_arg2;
    FLAG_ARGUMENT       slashv;
    FLAG_ARGUMENT       helparg;
    FLAG_ARGUMENT       genvalue;
    DSTRING             dossource;
    DSTRING             dosdest;
    DSTRING             ntsource;
    DSTRING             ntdest;
    DSTRING             currentdrive;
    PWSTRING            pwstring;
    DSTRING             colon;
    INT                 result;

    if (!msg.Initialize(Get_Standard_Output_Stream(),
                        Get_Standard_Input_Stream())) {
        return 4;
    }

    message = &msg;

    if (!lex_array.Initialize() || !arg_array.Initialize()) {
        return 4;
    }

    if (!arglex.Initialize(&lex_array)) {
        return 4;
    }

    arglex.SetCaseSensitive(FALSE);

    if (!arglex.PrepareToParse()) {
        return 4;
    }

    if (!progname.Initialize("*") ||
        !drive_arg1.Initialize("*:") ||
        !drive_arg2.Initialize("*:") ||
        !slashv.Initialize("/v") ||
        !helparg.Initialize("/?") ||
        !genvalue.Initialize("/machinetoken")) {
        return 4;
    }

    if (!arg_array.Put(&progname) ||
        !arg_array.Put(&drive_arg1) ||
        !arg_array.Put(&drive_arg2) ||
        !arg_array.Put(&slashv) ||
        !arg_array.Put(&helparg) ||
        !arg_array.Put(&genvalue)) {
        return 4;
    }

    if (!arglex.DoParsing(&arg_array)) {
        message->Set(MSG_INVALID_PARAMETER);
        message->Display("%W", pwstring = arglex.QueryInvalidArgument());
        DELETE(pwstring);
        return 4;
    }

    if (genvalue.QueryFlag()) {
        message->Set(MSG_ONE_STRING_NEWLINE);
        message->Display("%X", QueryMachineUniqueToken());
        return 0;
    }

    if (helparg.QueryFlag()) {
        message->Set(MSG_DCOPY_INFO);
        message->Display();
        message->Set(MSG_DCOPY_USAGE);
        message->Display();
        message->Set(MSG_DCOPY_SLASH_V);
        message->Display();
        message->Set(MSG_DCOPY_INFO_2);
        message->Display();
        return 0;
    }

    if (!colon.Initialize(":")) {
        return 4;
    }

    if (drive_arg1.IsValueSet()) {
        if (!dossource.Initialize(drive_arg1.GetString()) ||
            !dossource.Strcat(&colon) ||
            !dossource.Strupr()) {
            return 4;
        }
    } else {
        if (!SYSTEM::QueryCurrentDosDriveName(&dossource)) {
            return 4;
        }
    }

    if (drive_arg2.IsValueSet()) {
        if (!dosdest.Initialize(drive_arg2.GetString()) ||
            !dosdest.Strcat(&colon) ||
            !dosdest.Strupr()) {
            return 4;
        }
    } else {
        if (!SYSTEM::QueryCurrentDosDriveName(&dosdest)) {
            return 4;
        }
    }

    if (SYSTEM::QueryDriveType(&dossource) != RemovableDrive) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (SYSTEM::QueryDriveType(&dosdest) != RemovableDrive) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (!SYSTEM::QueryCurrentDosDriveName(&currentdrive) ||
        currentdrive == dosdest) {

        message->Set(MSG_CANT_LOCK_CURRENT_DRIVE);
        message->Display();
        return 4;
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dossource, &ntsource)) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    if (!IFS_SYSTEM::DosDriveNameToNtDriveName(&dosdest, &ntdest)) {
        message->Set(MSG_DCOPY_INVALID_DRIVE);
        message->Display();
        return 4;
    }

    for (;;) {

        result = DiskCopyMainLoop(&ntsource, &ntdest, &dossource, &dosdest,
                                  slashv.QueryFlag(), message);

        if (result > 1) {
            message->Set(MSG_DCOPY_ENDED);
            message->Display();
        }

        message->Set(MSG_DCOPY_ANOTHER);
        message->Display();

        if (!message->IsYesResponse(FALSE)) {
            break;
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\dfrg\inc\vwindow.hpp ===
#ifndef __VWINDOW_HPP
#define __VWINDOW_HPP

#ifndef VWCL_WRAP_WINDOWS_ONLY
	#include "vApplication.hpp"
#endif

#include "vRTTI.hpp"
#include <commctrl.h>

class VWindow;

typedef struct tagVWCL_ENUM_PARAM
{
	UINT	nMessageOrID;
	LPVOID	lpInData;			// Normally input pointer
	LPVOID	lpOutData;			// Normally output pointer

} VWCL_ENUM_PARAM;

// <VDOC<CLASS=VWindow><BASE=VRTTI><DESC=Base window object encapsulation><FAMILY=VWCL Core><AUTHOR=Todd Osborne (todd.osborne@poboxes.com)>VDOC>
class VWindow : public VRTTI
{
#ifndef VWCL_WRAP_WINDOWS_ONLY
	friend class VApplication;
#endif

public:
	VWindow(UINT nRTTI = VWCL_RTTI_WINDOW)
		: VRTTI(nRTTI)
	{
		m_hWindow = NULL;
		
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			m_lpfnOldWndProc = NULL;
		#endif
	}
	
	virtual ~VWindow()
	{
		#ifndef VWCL_WRAP_WINDOWS_ONLY
			DestroyWindow();
		#endif
	}

	// Returns HWND
	operator		HWND ()
		{ return GetSafeWindow(); }

	#ifndef VWCL_WRAP_WINDOWS_ONLY
		// Attach an existing Windows window to a VWindow object, subclassing it routing messages through the object
		BOOL				Attach(HWND hWnd);
	#else
		// Simply assign hWnd to this object, but do not subclass it
		HWND				Attach(HWND hWnd)
			{ assert(hWnd && ::IsWindow(hWnd)); m_hWindow = hWnd; return m_hWindow; }
	#endif

	// Center a window on screen
	void					CenterWindow()
	{
		assert(GetSafeWindow());

		// Center a window on screen
		RECT r;
		GetWindowRect(&r);
		SetWindowPos(	m_hWindow,
    					HWND_TOP,
    					((GetSystemMetrics(SM_CXSCREEN) - (r.right - r.left)) / 2),
    					((GetSystemMetrics(SM_CYSCREEN) - (r.bottom - r.top)) / 2),
						0,
						0,
						SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
	}

	void					CheckDlgButton(int nID, UINT nCheck = BST_CHECKED)
		{ assert(GetSafeWindow()); ::CheckDlgButton(m_hWindow, nID, nCheck); }

	BOOL					ClientToScreen(LPPOINT lpPoint)
		{ assert(GetSafeWindow() && lpPoint); return ::ClientToScreen(m_hWindow, lpPoint); }

	#ifndef VWCL_WRAP_WINDOWS_ONLY
		// Lowest common denominator of window creation functions
		BOOL				Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, LPRECT lpRect, HWND hWndParent, UINT nIDorMenu, BOOL bDontCallPostCreateWindow = FALSE);
	#endif

	virtual BOOL			DestroyWindow()
		{ if ( GetSafeWindow() ) return ::DestroyWindow(m_hWindow); return FALSE; }

	#ifndef VWCL_WRAP_WINDOWS_ONLY
		// Detach an existing Windows window with an associated VWindow object, removing any subclassing, and restore to previous state
		void				Detach();
	#else
		// Simply remove the window handle from object
		void				Detach()
			{ m_hWindow = NULL; }
	#endif

	BOOL					EnableWindow(BOOL bEnable = TRUE)
		{ assert(GetSafeWindow()); return ::EnableWindow(m_hWindow, bEnable); }

	#ifndef VWCL_WRAP_WINDOWS_ONLY
		// Enter a message loop
		WPARAM				EnterMessageLoop(HACCEL hAccel)
		{
			MSG msg;

			// Enter message loop
			while ( GetMessage(&msg, NULL, 0, 0) != 0 )
			{
				if ( hAccel == NULL || hAccel && TranslateAccelerator(m_hWindow, hAccel, &msg) == 0 )
					HandleMessage(&msg);
			}

			return msg.wParam;
		}
	#endif

	// Find a child window when the class is known
	HWND					FindChildWindowByClass(LPCTSTR lpszClass)
	{
		assert(lpszClass && lstrlen(lpszClass));
		
		// Iterate child windows
		VWCL_ENUM_PARAM EnumParam = {ENUM_FIND_CHILD_BY_CLASS, (LPVOID)lpszClass, NULL};
		EnumChildWindows(m_hWindow, (WNDENUMPROC)EnumChildWndProc, (LPARAM)&EnumParam);

		// EnumParam.lpOutData will be non-NULL if a handle was found
		if ( EnumParam.lpOutData )
			return (HWND)EnumParam.lpOutData;
		return NULL;
	}

	HWND					GetDlgItem(int nID)
		{ assert(GetSafeWindow()); return ::GetDlgItem(m_hWindow, nID); }

	UINT					GetDlgItemInt(int nID, LPBOOL lpTranslated = NULL, BOOL bSigned = FALSE)
		{ assert(GetSafeWindow()); return ::GetDlgItemInt(m_hWindow, nID, lpTranslated, bSigned); }

	int						GetDlgItemText(int nID, LPTSTR lpszBuffer, int nSizeOfBuffer)
		{ assert(GetSafeWindow()); return ::GetDlgItemText(m_hWindow, nID, lpszBuffer, nSizeOfBuffer); }

	HFONT					GetFont()
		{ assert(GetSafeWindow()); return (HFONT)::SendMessage(m_hWindow, WM_GETFONT, 0, 0); }

	HMENU					GetMenu()
		{ assert(GetSafeWindow()); return ::GetMenu(m_hWindow); }

	HWND					GetParent()
		{ assert(GetSafeWindow()); return ::GetParent(m_hWindow); }

	HWND					GetSafeWindow()
		{ return (IsWindow()) ? m_hWindow : NULL; }

	LONG					GetStyle()
		{ return GetWindowLong(GWL_STYLE); }

	LONG					GetWindowLong(int nIndex)
		{ assert(GetSafeWindow()); return ::GetWindowLong(m_hWindow, nIndex); }

	#ifdef WIN32
		BOOL				GetClientRect(LPRECT lpRect)
			{ assert(lpRect && GetSafeWindow()); return ::GetClientRect(m_hWindow, lpRect); }
	
		BOOL				GetWindowRect(LPRECT lpRect)
			{ assert(lpRect && GetSafeWindow()); return ::GetWindowRect(m_hWindow, lpRect); }
	#else
		void				GetClientRect(LPRECT lpRect)
			{ assert(lpRect && GetSafeWindow()); ::GetClientRect(m_hWindow, lpRect); }
	
		void				GetWindowRect(LPRECT lpRect)
			{ assert(lpRect && GetSafeWindow()); ::GetWindowRect(m_hWindow, lpRect); }
	#endif	

	#ifndef VWCL_WRAP_WINDOWS_ONLY
		// Called from a VWindow class that implements a message loop
		virtual void		HandleMessage(LPMSG lpMsg)
		{
			assert(lpMsg);

			// Called from a VWindow derived class that implements a message loop
			if ( !PreTranslateMessage(lpMsg) )
			{
				TranslateMessage(lpMsg);
				DispatchMessage(lpMsg);
			}
		}
	#endif

	void					InvalidateRect(LPRECT lpRect = NULL, BOOL bErase = TRUE)
		{ assert(GetSafeWindow()); ::InvalidateRect(m_hWindow, lpRect, bErase); }

	// Return TRUE if the object is a VDialog type (That is, a VDialogXXX class, not all VDialog derivitives)
	BOOL					IsVDialogType()
	{
		switch ( RTTI() )
		{
			// Top level window is a dialog
			case VWindow::VWCL_RTTI_DIALOG:
			case VWindow::VWCL_RTTI_MAIN_DIALOG:
			case VWindow::VWCL_RTTI_SPLIT_MAIN_DIALOG:
			case VWindow::VWCL_RTTI_SPLIT_DIALOG:
				return TRUE;
		}

		return FALSE;
	}

	UINT					IsDlgButtonChecked(int nID)
		{ assert(GetSafeWindow()); return ::IsDlgButtonChecked(m_hWindow, nID); }

	BOOL					IsIconic()
		{ assert(GetSafeWindow()); return ::IsIconic(m_hWindow); }

	BOOL					IsWindow()
		{ return (m_hWindow) ? ::IsWindow(m_hWindow) : FALSE; }

	BOOL					IsWindowEnabled()
		{ assert(GetSafeWindow()); return ::IsWindowEnabled(m_hWindow); }

	BOOL					IsWindowVisible()
		{ assert(GetSafeWindow()); return ::IsWindowVisible(m_hWindow); }

	int						MessageBox(LPCTSTR lpcszText, LPCTSTR lpcszCaption, UINT nType = MB_OK)
		{ int nResult; HWND hWndFocus = GetFocus(); nResult = ::MessageBox(m_hWindow, lpcszText, lpcszCaption, nType); if ( hWndFocus ) ::SetFocus(hWndFocus); return nResult; }

	int						MessageBox(LPCTSTR lpcszText, UINT nType = MB_OK)
		{ return MessageBox(lpcszText, VGetAppTitle(), nType); }

	// If VString.hpp is included, implement these functions
	#ifdef __VSTRING_HPP
		int					MessageBox(UINT nStringID, UINT nType = MB_OK, HINSTANCE hResource = NULL)
			{ return MessageBox(VString(nStringID, hResource), nType); }
		
		int					MessageBox(UINT nStringID, LPCTSTR lpcszCaption, UINT nType = MB_OK, HINSTANCE hResource = NULL)
			{ return MessageBox(VString(nStringID, hResource), lpcszCaption, nType); }

		int					MessageBox(UINT nStringID, UINT nCaptionID, UINT nType, HINSTANCE hResource = NULL)
			{ return MessageBox(VString(nStringID, hResource), VString(nCaptionID, hResource), nType); }
	#endif

	BOOL					MoveWindow(int x, int y, int cx, int cy, BOOL bRedraw = TRUE)
		{ assert(GetSafeWindow()); return ::MoveWindow(m_hWindow, x, y, cx, cy, bRedraw); }

	BOOL					MoveWindow(LPRECT lpRect, BOOL bRedraw = TRUE)
		{ assert(lpRect); assert(GetSafeWindow()); return ::MoveWindow(m_hWindow, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, bRedraw); }

	BOOL					PostMessage(UINT nMessage, WPARAM wParam, LPARAM lParam)
		{ assert(GetSafeWindow()); return ::PostMessage(m_hWindow, nMessage, wParam, lParam); }

	// Override to allow user to call IsDialogMessage() or perform other
	// processing before message is dispatched. Return TRUE if message was processed
	virtual BOOL			PreTranslateMessage(LPMSG lpMsg)
		{ return FALSE; }

	BOOL					ReleaseCapture()
		{ assert(GetSafeWindow()); return ::ReleaseCapture(); }

	BOOL					ScreenToClient(LPPOINT lpPoint)
		{ assert(GetSafeWindow() && lpPoint); return ::ScreenToClient(m_hWindow, lpPoint); }

	LRESULT					SendDlgItemMessage(UINT nID, UINT nMessage, WPARAM wParam, LPARAM lParam)
		{ assert(GetSafeWindow()); return ::SendDlgItemMessage(m_hWindow, nID, nMessage, wParam, lParam); }

	LRESULT					SendMessage(UINT nMessage, WPARAM wParam, LPARAM lParam)
		{ assert(GetSafeWindow()); return ::SendMessage(m_hWindow, nMessage, wParam, lParam); }

	HWND					SetCapture()
		{ assert(GetSafeWindow()); return ::SetCapture(m_hWindow); }
	
	BOOL					SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = FALSE)
		{ assert(GetSafeWindow()); return ::SetDlgItemInt(m_hWindow, nID, nValue, bSigned); }

	#ifdef WIN32
		BOOL				SetDlgItemText(int nID, LPCTSTR lpszText)
			{ assert(GetSafeWindow()); return ::SetDlgItemText(m_hWindow, nID, lpszText); }
	#else
		void				SetDlgItemText(int nID, LPCTSTR lpszText)
			{ assert(GetSafeWindow()); ::SetDlgItemText(m_hWindow, nID, lpszText); }
	#endif

	HWND					SetFocus()
		{ assert(GetSafeWindow()); return ::SetFocus(m_hWindow); }

	BOOL					SetMenu(HMENU hMenu)
		{ assert(GetSafeWindow()); return ::SetMenu(m_hWindow, hMenu); }

	LONG					SetStyle(DWORD dwStyle)
		{ return SetWindowLong(GWL_STYLE, dwStyle); }

	LONG					SetWindowLong(int nIndex, LONG nNewLong)
		{ assert(GetSafeWindow()); return ::SetWindowLong(m_hWindow, nIndex, nNewLong); }

#if defined(_WIN64)
	LONG_PTR				SetWindowLongPtr(int nIndex, LONG_PTR nNewLongPtr)
		{ assert(GetSafeWindow()); return ::SetWindowLongPtr(m_hWindow, nIndex, nNewLongPtr); }
#endif

	#ifdef WIN32
		BOOL				SetWindowText(LPCTSTR lpszText)
			{ assert(GetSafeWindow()); return ::SetWindowText(m_hWindow, lpszText); }
	#else
		void				SetWindowText(LPCTSTR lpszText)
			{ assert(GetSafeWindow()); ::SetWindowText(m_hWindow, lpszText); }
	#endif
	
	BOOL					ShowWindow(int nCmdShow = SW_SHOWNORMAL)
		{ assert(GetSafeWindow()); return ::ShowWindow(m_hWindow, nCmdShow); }

	#ifdef WIN32
		BOOL				UpdateWindow()
			{ assert(GetSafeWindow()); return ::UpdateWindow(m_hWindow); }
	#else
		void				UpdateWindow()
			{ assert(GetSafeWindow()); ::UpdateWindow(m_hWindow); }
	#endif
		
	#ifndef VWCL_WRAP_WINDOWS_ONLY
		// Window procedure
		virtual LRESULT		WindowProc(HWND hWnd, UINT nMessage, WPARAM wParam, LPARAM lParam);
	#endif

	// Fast Runtime Type Information supported on ALL compilers
	// Implemented int VRTTI base class for VWindow and derived classes
	enum	{				VWCL_RTTI_UNKNOWN,
							VWCL_RTTI_BUTTON,
							VWCL_RTTI_CHECKBOX,
							VWCL_RTTI_COMBOBOX,
							VWCL_RTTI_DIALOG,
							VWCL_RTTI_EDIT,
							VWCL_RTTI_GROUPBOX,
							VWCL_RTTI_LISTBOX,
							VWCL_RTTI_LISTVIEW_CTRL,
							VWCL_RTTI_MAIN_DIALOG,
							VWCL_RTTI_MAIN_WINDOW,
							VWCL_RTTI_PAGE_SETUP_DIALOG,
							VWCL_RTTI_PRINT_DIALOG,
							VWCL_RTTI_PRINT_SETUP_DIALOG,
							VWCL_RTTI_RADIO_BUTTON,
							VWCL_RTTI_SCROLLBAR,
							VWCL_RTTI_SPLASH_WINDOW,
							VWCL_RTTI_SPLIT_MAIN_DIALOG,
							VWCL_RTTI_SPLIT_MAIN_WINDOW,
							VWCL_RTTI_SPLIT_WINDOW,
							VWCL_RTTI_SS_TREE_CTRL,
							VWCL_RTTI_STATIC,
							VWCL_RTTI_STATUSBAR_CTRL,
							VWCL_RTTI_TAB_CTRL,
							VWCL_RTTI_TAB_CTRL_WINDOW,
							VWCL_RTTI_TOOLBAR_CTRL,
							VWCL_RTTI_TREE_CTRL,
							VWCL_RTTI_WINDOW,
							VWCL_RTTI_SPLIT_DIALOG,
							VWCL_RTTI_SHELL_TAB_WINDOW,
							VWCL_RTTI_MINI_WINDOW,
							VWCL_RTTI_DIRECTORY_TREE_CTRL,
							VWCL_RTTI_XTREE_CTRL,
							VWCL_RTTI_XEDIT,
							VWCL_RTTI_SS_INDEXED_TREE_CTRL,
							VWCL_RTTI_PROPERTY_SHEET,
							VWCL_RTTI_PROPERTY_PAGE,
							VWCL_RTTI_PROGRESS_CTRL,
			};

	// Handle this object encapsulates
	HWND					m_hWindow;

	#ifndef VWCL_WRAP_WINDOWS_ONLY
		// For subclased windows, the old Window Procedure
		WNDPROC				m_lpfnOldWndProc;
	#endif

	// Enumeration is VWLC_ENUM_PARAM::nMessageOrID in EnumChildWndProc() call
	enum	{				ENUM_FIND_CHILD_BY_CLASS =	WM_USER + 4096,
			};

protected:
	// Enumerate child windows (for various reasons). LPARAM is a pointer to a VWLC_ENUM_PARAM struct
	static BOOL CALLBACK	EnumChildWndProc(HWND hWnd, LPARAM lParam)
	{
		VWCL_ENUM_PARAM* pEnumParam = (VWCL_ENUM_PARAM*)lParam;
		assert(pEnumParam);

		// Determine what we need to do
		switch ( pEnumParam->nMessageOrID )
		{
			case WM_DESTROY:
				::DestroyWindow(hWnd);
				break;

			case ENUM_FIND_CHILD_BY_CLASS:
			{
				// pEnumParam->lpInData is a string
				LPCTSTR lpszFind = (LPCTSTR)pEnumParam->lpInData;
				assert(lpszFind && lstrlen(lpszFind));

				// Get the class of this window
				TCHAR szClass[50];
				::GetClassName(hWnd, szClass, sizeof(szClass)/sizeof(TCHAR));

				// Did we find a hit?
				if ( lstrcmpi(szClass, lpszFind) == 0 )
				{
					// Set the hWnd into the pEnumParam->lpOutData field and quit
					pEnumParam->lpOutData = hWnd;
					return FALSE;
				}

				break;
			}
		}

		return TRUE;
	}

	#ifndef VWCL_WRAP_WINDOWS_ONLY
		// Handler for WM_CLOSE. Default implementation calls DestroyWindow()
		virtual void		OnClose()
			{ DestroyWindow(); }

		// Handler for WM_COMMAND. Return 0 if message was handled
		virtual int			OnCommand(WORD wNotifyCode, WORD wID, HWND hWndControl)
			{ return 1; }

		// Handler for WM_CREATE. Return 0 if message was handled, -1 to stop window creation
		virtual int			OnCreate(LPCREATESTRUCT lpCreateStruct)
			{ return 1; }

		// Handler for WM_DESTROY. Return 0 if message was handled
		virtual int			OnDestroy()
			{ return 1; }

		// Handler for WM_PAINT. Return 0 if message was handled
		virtual int			OnPaint()
			{ return 1; }

		// Handler for WM_SIZE. Return 0 if message was handled
		virtual int			OnSize(WPARAM wFlags, int cx, int cy)
			{ return 1; }

		// Handler for WM_NOTIFY. Return 0 if message was handled
		virtual LRESULT		OnNotify(int nIDControl, LPNMHDR lpNMHDR)
			{ return 1; }

		// Support for reflected WM_NOTIFY messages. Derived class must
		// return 0 is message was handled, -1 if handled and parent should
		// NOT be notified, or 1 if message was not handled and parent should
		// be notified. If -1 if returned, derived classes must also set
		// the lCommonControlResult to the return value expected by the common control
		virtual int			OnReflectedNotify(LPNMHDR lpNMHDR, LPARAM& lCommonControlResult)
			{ return 1; }

		// Called after Attach() returns successfully
		virtual void		PostAttachWindow()
			{;}

		// Called after Create() returns successfully. Returning FALSE from
		// this override will cause the window to be destroyed
		virtual BOOL		PostCreateWindow()
			{ return TRUE;}

		// Called after WM_DESTROY completes. Safe to do a delete this on VWindow object
		virtual void		PostNcDestroy()
			{;}

		// Custom virtual functions for common overrides and default returns
		virtual BOOL		PreCreateWindow(LPCREATESTRUCT lpCreateStruct)
			{ return TRUE; }
	#endif
};					

#endif	// __VWINDOW_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskcopy\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1

TARGETNAME=diskcopy
TARGETPATH=obj
TARGETEXT=com
TARGETTYPE=PROGRAM

SOURCES=..\diskcopy.cxx ..\diskcopy.rc

INCLUDES=..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

CXXFLAGS=+d
TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\bootedit.cxx ===
#include "ulib.hxx"
#include "bootedit.hxx"
#include "bpb.hxx"


extern "C" {
#include <stdio.h>
}


VOID
DOS_BOOT_EDIT::SetBuf(
    IN      HWND    WindowHandle,
    IN OUT  PVOID   Buffer,
    IN      ULONG   Size
    )
{
    _buffer = Buffer;
    _size = Size;
    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);
    InvalidateRect(WindowHandle, NULL, TRUE);
}


VOID
DOS_BOOT_EDIT::Paint(
    IN  HDC     DeviceContext,
    IN  RECT    InvalidRect,
    IN  HWND    WindowHandle
    )
{
    EXTENDED_BIOS_PARAMETER_BLOCK   bios;
    TEXTMETRIC              textmetric;
    INT                     ch, current;
    TCHAR                   buf[1024];

    SetScrollRange(WindowHandle, SB_VERT, 0, 0, FALSE);

    if (!_buffer || _size < 128) {
        return;
    }

    memset(&bios, 0, sizeof(EXTENDED_BIOS_PARAMETER_BLOCK));

    // Unpack the bios
    UnpackExtendedBios(&bios, (PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK)_buffer);

    SelectObject(DeviceContext, GetStockObject(ANSI_FIXED_FONT));
    GetTextMetrics(DeviceContext, &textmetric);
    ch = textmetric.tmExternalLeading + textmetric.tmHeight;
    current = 0;

    swprintf(buf, TEXT("OEM String:                      %c%c%c%c%c%c%c%c"),
                 bios.OemData[0],
                 bios.OemData[1],
                 bios.OemData[2],
                 bios.OemData[3],
                 bios.OemData[4],
                 bios.OemData[5],
                 bios.OemData[6],
                 bios.OemData[7]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Bytes per sector:                %x"), bios.Bpb.BytesPerSector);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per cluster:             %x"), bios.Bpb.SectorsPerCluster);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Reserved Sectors:                %x"), bios.Bpb.ReservedSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of fats:                  %x"), bios.Bpb.Fats);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Root entries:                    %x"), bios.Bpb.RootEntries);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Small sector count:              %x"), bios.Bpb.Sectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Media byte:                      %x"), bios.Bpb.Media);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Sectors per fat:                 %x"), bios.Bpb.SectorsPerFat);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;
       
    if(!bios.Bpb.SectorsPerFat){
   
       swprintf(buf, TEXT("Large sectors per fat:           %x"), bios.Bpb.BigSectorsPerFat);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;
    }
    
    swprintf(buf, TEXT("Sectors per track:               %x"),
        bios.Bpb.SectorsPerTrack);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of heads:                 %x"),
        bios.Bpb.Heads);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Number of hidden sectors:        %x"),
                 bios.Bpb.HiddenSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Large number of sectors:         %x"),
                 bios.Bpb.LargeSectors);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    if(!bios.Bpb.SectorsPerFat){
    
       swprintf(buf, TEXT("Extended flags:                  %x"),
                bios.Bpb.ExtFlags);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;

       swprintf(buf, TEXT("File system version:             %x"),
                 bios.Bpb.FS_Version);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;

       swprintf(buf, TEXT("Root directory start cluster:    %x"), bios.Bpb.RootDirStrtClus);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;

       swprintf(buf, TEXT("File system info sector number:  %x"), bios.Bpb.FSInfoSec);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;

       swprintf(buf, TEXT("Backup boot sector:              %x"), bios.Bpb.BkUpBootSec);
       TextOut(DeviceContext, 0, current, buf, wcslen(buf));
       current += ch;
    
    }

    swprintf(buf, TEXT("Physical drive:                  %x"), bios.PhysicalDrive);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Current head:                    %x"), bios.CurrentHead);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Extended boot signature:         %x"), bios.Signature);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Serial number:                   %x"), bios.SerialNumber);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("Label:                           %c%c%c%c%c%c%c%c%c%c%c"),
                 bios.Label[0],
                 bios.Label[1],
                 bios.Label[2],
                 bios.Label[3],
                 bios.Label[4],
                 bios.Label[5],
                 bios.Label[6],
                 bios.Label[7],
                 bios.Label[8],
                 bios.Label[9],
                 bios.Label[10]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;

    swprintf(buf, TEXT("System id:                       %c%c%c%c%c%c%c%c"),
                 bios.SystemIdText[0],
                 bios.SystemIdText[1],
                 bios.SystemIdText[2],
                 bios.SystemIdText[3],
                 bios.SystemIdText[4],
                 bios.SystemIdText[5],
                 bios.SystemIdText[6],
                 bios.SystemIdText[7]);
    TextOut(DeviceContext, 0, current, buf, wcslen(buf));
    current += ch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\chainio.cxx ===
#include "ulib.hxx"
#include "chainio.hxx"
#include "diskedit.h"
#include "rfatsa.hxx"

extern "C" {
#include <stdio.h>
}

STATIC USHORT   StartingCluster = 0;

BOOLEAN
CHAIN_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    FARPROC proc;
    REAL_FAT_SA fatsa;
    MESSAGE msg;

    proc = MakeProcInstance((FARPROC) ReadChain, Application);
    if (!DialogBox((HINSTANCE)Application, TEXT("ReadChainBox"),
                   WindowHandle, (DLGPROC) proc)) {
        *Error = FALSE;
        return FALSE;
    }
    FreeProcInstance(proc);

    *Error = TRUE;

    _drive = Drive;

    if (!_drive ||
        !StartingCluster ||
        !fatsa.Initialize(_drive, &msg) ||
        !fatsa.FAT_SA::Read() ||
        !_cluster.Initialize(Mem, _drive, &fatsa,
                             fatsa.GetFat(), StartingCluster)) {

        return FALSE;
    }

    _buffer = _cluster.GetBuf();
    _buffer_size = fatsa.QuerySectorsPerCluster()*_drive->QuerySectorSize()*
                    _cluster.QueryLength();

    wsprintf(_header_text, TEXT("DiskEdit - Starting Cluster 0x%X"), StartingCluster);


    return TRUE;
}


BOOLEAN
CHAIN_IO::Read(
    OUT PULONG  pError
    )
{
    *pError = 0;

    if (NULL == _drive) {
        return FALSE;
    }

    if (!_cluster.Read()) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
CHAIN_IO::Write(
    )
{
    return _drive ? _cluster.Write() : FALSE;
}


PVOID
CHAIN_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _buffer_size;
    }

    return _buffer;
}


PTCHAR
CHAIN_IO::GetHeaderText(
    )
{
    return _header_text;
}


BOOL
ReadChain(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    ULONG   tmp;

    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            if (LOWORD(wParam) == IDOK) {

                TCHAR buf[1024];
                INT n;

                n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
                buf[n] = 0;
                swscanf(buf, TEXT("%x"), &tmp);

                StartingCluster = (USHORT) tmp;

                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\attrio.cxx ===
#include "ulib.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "attrio.hxx"
#include "mftfile.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

STATIC ULONG FileNumber = 0;
STATIC ULONG AttributeType = 0;
STATIC TCHAR Name[20];

BOOLEAN
ATTR_IO::Setup(
    IN  PMEM                Mem,
    IN  PLOG_IO_DP_DRIVE    Drive,
    IN  HANDLE              Application,
    IN  HWND                WindowHandle,
    OUT PBOOLEAN            Error
    )
{
    FARPROC proc;
    NTFS_SA ntfssa;
    MESSAGE msg;
    DSTRING attr_name;
    PCWSTRING pcAttrName;
    BOOLEAN error;
    NTFS_MFT_FILE mft;
    NTFS_UPCASE_FILE upcase_file;
    NTFS_ATTRIBUTE upcase_attribute;
    PNTFS_UPCASE_TABLE upcase_table = NULL;

    proc = MakeProcInstance((FARPROC) ReadAttribute, Application);
    if (!DialogBox((HINSTANCE)Application, TEXT("ReadAttributeBox"),
                   WindowHandle, (DLGPROC) proc)) {
        *Error = FALSE;
        return FALSE;
    }
    FreeProcInstance(proc);

    *Error = TRUE;

    if (!Drive) {
        return FALSE;
    }

    if (!ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read() ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
            ntfssa.QueryClusterFactor(), ntfssa.QueryFrsSize(),
            ntfssa.QueryVolumeSectors(), NULL, NULL) ||
        !mft.Read() ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
        !(upcase_table = new NTFS_UPCASE_TABLE) ||
        !upcase_table->Initialize(&upcase_attribute)
        ) {

        delete upcase_table;
        return FALSE;
    }

    mft.GetMasterFileTable()->SetUpcaseTable( upcase_table );

    if (0 == wcslen(Name)) {
        pcAttrName = NULL;
    } else {
        if (!attr_name.Initialize(Name)) {
            return FALSE;
        }

        pcAttrName = &attr_name;
    }

    //
    // NTFS_FILE_RECORD_SEGMENT::QueryAttribute can't query an
    // attribute list, so if that's what we're trying to read we'll
    // do things differently.
    //

    _attr_list_io = (AttributeType == $ATTRIBUTE_LIST);

    if (_attr_list_io) {

        if (!_hmem.Initialize()) {
            return FALSE;
        }

        if (!_frsstruc.Initialize(&_hmem,
                mft.GetMasterFileTable()->GetDataAttribute(), FileNumber,
                ntfssa.QueryClusterFactor(),
                ntfssa.QueryVolumeSectors(),
                ntfssa.QueryFrsSize(),
                NULL) ||
            !_frsstruc.Read()) {

            return FALSE;
        }
        if (!_frsstruc.QueryAttributeList(&_attr_list)) {
            return FALSE;
        }

        _length = _attr_list.QueryValueLength().GetLowPart();


    } else {
        if (!_frs.Initialize((VCN)FileNumber, &mft) ||
            !_frs.Read()) {

            return FALSE;
        }
        if (!_frs.QueryAttribute(&_attr, &error, AttributeType, pcAttrName)) {
            return FALSE;
        }
        _length = _attr.QueryValueLength().GetLowPart();
    }

#if FALSE
    {
        TCHAR String[128];

        wsprintf( String, TEXT("Allocating %x"), _length );
        MessageBox( WindowHandle, String, TEXT("ATTR_IO::Setup"), MB_OK|MB_ICONINFORMATION );
    }
#endif

    _data = Mem->Acquire(_length, Drive->QueryAlignmentMask());

    if (NULL == _data) {

        _length = min( _length, 4 * 1024 * 1024 );

#if FALSE
        {
            TCHAR String[128];

            wsprintf( String, TEXT("Smaller allocation %x"), _length );
            MessageBox( WindowHandle, String, TEXT("ATTR_IO::Setup"), MB_OK|MB_ICONINFORMATION );
        }
#endif

        _data = Mem->Acquire(_length, Drive->QueryAlignmentMask());

        if (NULL == _data) {
            return FALSE;
        }
        wsprintf(_header_text, TEXT("DiskEdit - Reduced Size Attribute %x, %x, \"%s\" "),
            FileNumber, AttributeType, Name);
    } else {
        wsprintf(_header_text, TEXT("DiskEdit - Attribute %x, %x, \"%s\" "),
            FileNumber, AttributeType, Name);
    }


    return TRUE;
}


BOOLEAN
ATTR_IO::Read(
    OUT PULONG  pError
    )
{
    ULONG bytes_read;

    *pError = 0;

    if (_attr_list_io) {
        if (!_attr_list.ReadList()) {
            return FALSE;
        }
        memcpy(_data, (PVOID)_attr_list.GetNextAttributeListEntry(NULL),
            _length);

        return TRUE;
    }


    if (!_attr.Read(_data, 0, _length, &bytes_read) ||
        bytes_read != _length) {
        *pError = _drive->QueryLastNtStatus();
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
ATTR_IO::Write(
    )
{
    ULONG bytes_written;

    if (_attr_list_io) {
       return _attr_list.WriteList(NULL);
    }

    return _attr.Write(_data, 0, _length, &bytes_written, NULL) &&
           bytes_written == _length;
}


PVOID
ATTR_IO::GetBuf(
    OUT PULONG  Size
    )
{
    if (Size) {
        *Size = _length;
    }

    return _data;
}


PTCHAR
ATTR_IO::GetHeaderText(
    )
{
    return _header_text;
}


BOOL
ReadAttribute(
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  UINT    wParam,
    IN  LONG    lParam
    )
{
    UNREFERENCED_PARAMETER(lParam);
    TCHAR String[128];
    extern struct { ULONG Code; PTCHAR Name; } TypeCodeNameTab[];
    HWND hCombo;
    INT i;

    switch (message) {
    case WM_INITDIALOG:

        hCombo = GetDlgItem(hDlg, IDTEXT2);

        for (i = 1; $END != TypeCodeNameTab[i].Code; ++i) {
            swprintf(String, TEXT("%x %s"), TypeCodeNameTab[i].Code,
                TypeCodeNameTab[i].Name);

            SendMessage(hCombo, CB_ADDSTRING, (WPARAM)0, (LPARAM)String);
        }

        return TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) {
            EndDialog(hDlg, FALSE);
            return TRUE;
        }

        if (LOWORD(wParam) == IDOK) {

            TCHAR buf[1024];
            INT n;

            n = GetDlgItemText(hDlg, IDTEXT, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            swscanf(buf, TEXT("%x"), &FileNumber);

            n = GetDlgItemText(hDlg, IDTEXT2, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            swscanf(buf, TEXT("%x"), &AttributeType);

            n = GetDlgItemText(hDlg, IDTEXT3, buf, sizeof(buf)/sizeof(TCHAR));
            buf[n] = 0;
            wcscpy(Name, buf);

            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\crack.cxx ===
#include "ulib.hxx"
#include "drive.hxx"
#include "ifssys.hxx"
#include "ntfssa.hxx"
#include "frs.hxx"
#include "attrib.hxx"
#include "mftfile.hxx"
#include "bitfrs.hxx"
#include "ntfsbit.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "rfatsa.hxx"
#include "rcache.hxx"
#include "hmem.hxx"
#include "recordpg.hxx"
#include "crack.hxx"
#include "diskedit.h"

extern "C" {
#include <stdio.h>
}

extern PLOG_IO_DP_DRIVE Drive;

TCHAR             Path[MAX_PATH];

VOID
CrackNtfsPath(
    IN  HWND    WindowHandle
    )
{
    DSTRING                     path;
    NTFS_SA                     ntfssa;
    MESSAGE                     msg;
    NTFS_MFT_FILE               mft;
    NTFS_BITMAP_FILE            bitmap_file;
    NTFS_ATTRIBUTE              bitmap_attribute;
    NTFS_BITMAP                 volume_bitmap;
    NTFS_UPCASE_FILE            upcase_file;
    NTFS_ATTRIBUTE              upcase_attribute;
    NTFS_UPCASE_TABLE           upcase_table;
    NTFS_FILE_RECORD_SEGMENT    file_record;
    BOOLEAN                     error;
    BOOLEAN                     system_file;
    ULONG                       file_number;
    TCHAR                        buf[100];


    if (!path.Initialize(Path)) {
        wsprintf(buf, TEXT("Out of memory"));
        MessageBox(WindowHandle, buf, TEXT("DiskEdit"), MB_OK|MB_ICONEXCLAMATION);
        return;
    }

    if (!Drive ||
        !ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read() ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                        ntfssa.QueryClusterFactor(),
                        ntfssa.QueryFrsSize(),
                        ntfssa.QueryVolumeSectors(), NULL, NULL) ||
        !mft.Read() ||
        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
        !bitmap_file.Read() ||
        !bitmap_file.QueryAttribute(&bitmap_attribute, &error, $DATA) ||
        !volume_bitmap.Initialize(ntfssa.QueryVolumeSectors() /
              (ULONG) ntfssa.QueryClusterFactor(), FALSE, NULL, 0) ||
        !volume_bitmap.Read(&bitmap_attribute) ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
        !upcase_table.Initialize(&upcase_attribute) ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                        ntfssa.QueryClusterFactor(),
                        ntfssa.QueryFrsSize(),
                        ntfssa.QueryVolumeSectors(),
                        &volume_bitmap,
                        &upcase_table) ||
        !mft.Read()) {

        swprintf(buf, TEXT("Could not init NTFS data structures"));
        MessageBox(WindowHandle, buf, TEXT("DiskEdit"), MB_OK|MB_ICONEXCLAMATION);

        return;
    }
    if (!ntfssa.QueryFrsFromPath(&path, mft.GetMasterFileTable(),
        &volume_bitmap, &file_record, &system_file, &error)) {
        wsprintf(buf, TEXT("File not found."));
        MessageBox(WindowHandle, buf, TEXT("DiskEdit"), MB_OK|MB_ICONINFORMATION);

        return;
    }

    file_number = file_record.QueryFileNumber().GetLowPart();

    wsprintf(buf, TEXT("The given path points to file record 0x%X"), file_number);

    MessageBox(WindowHandle, buf, TEXT("Path Image"), MB_OK);
}

BOOLEAN
BacktrackFrs(
    IN      VCN                     FileNumber,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    OUT     PWCHAR                  PathBuffer,
    IN      ULONG                   BufferLength,
    OUT     PULONG                  PathLength
    )
/*++

Routine Description:

    This function finds a path from the root to a given FRS.

Arguments:

    FileNumber      --  Supplies the file number of the target FRS.
    Mft             --  Supplies the volume's Master File Table.
    PathBuffer      --  Receives a path to the FRS.
    BufferLength    --  Supplies the length (in characters) of
                        the client's buffer.
    PathLength      --  Receives the length (in characters) of
                        the path.

Return Value:

    TRUE upon successful completion.  The returned path may
    not be NULL-terminated.

--*/
{
    NTFS_FILE_RECORD_SEGMENT CurrentFrs;
    NTFS_ATTRIBUTE FileNameAttribute;
    VCN ParentFileNumber;
    PCFILE_NAME FileName;
    ULONG i;
    BOOLEAN Error;

    if( FileNumber == ROOT_FILE_NAME_INDEX_NUMBER ) {

        // This is the root; return a NULL path.
        //
        *PathLength = 0;
        return TRUE;
    }

    // Initialize the FRS and extract a name (any name will do).
    //
    if( !CurrentFrs.Initialize( FileNumber, Mft ) ||
        !CurrentFrs.Read() ||
        !CurrentFrs.QueryAttribute( &FileNameAttribute, &Error, $FILE_NAME ) ||
        !FileNameAttribute.IsResident() ) {

        return FALSE;
    }

    FileName = (PCFILE_NAME)FileNameAttribute.GetResidentValue();

    ParentFileNumber.Set( FileName->ParentDirectory.LowPart,
                          (LONG)FileName->ParentDirectory.HighPart );

    // Now recurse into this file's parent.
    //
    if( !BacktrackFrs( ParentFileNumber,
                       Mft,
                       PathBuffer,
                       BufferLength,
                       PathLength ) ) {

        return FALSE;
    }

    // Add this file's name to the path.
    //
    if( *PathLength + FileName->FileNameLength + 1 > BufferLength ) {

        // Buffer is too small.
        //
        return FALSE;
    }

    PathBuffer[*PathLength] = '\\';

    for( i = 0; i < FileName->FileNameLength; i++ ) {

        PathBuffer[*PathLength+1+i] = FileName->FileName[i];
    }

    *PathLength += 1 + FileName->FileNameLength;

    return TRUE;

}

BOOLEAN
BacktrackFrsFromScratch(
    IN  HWND    WindowHandle,
    IN  VCN     FileNumber
    )
/*++

Routine Description:

    This function finds a path from the root to a given
    FRS; it sets up the MFT and its helper objects as
    needed.

Arguments:

    WindowHandle    --  Supplies a handle to the parent window.
    FileNumber      --  Supplies the file number of the target FRS.

Return Value:

    TRUE upon successful completion.  The returned path may
    not be NULL-terminated.

--*/
{
    WCHAR                       WPath[MAX_PATH];

    NTFS_SA                     ntfssa;
    MESSAGE                     msg;
    NTFS_MFT_FILE               mft;
    NTFS_BITMAP_FILE            bitmap_file;
    NTFS_ATTRIBUTE              bitmap_attribute;
    NTFS_BITMAP                 volume_bitmap;
    NTFS_UPCASE_FILE            upcase_file;
    NTFS_ATTRIBUTE              upcase_attribute;
    NTFS_UPCASE_TABLE           upcase_table;
    BOOLEAN                     error;
    ULONG                       BufferLength, PathLength, i;

    BufferLength = sizeof(WPath);

    if (!Drive ||
        !ntfssa.Initialize(Drive, &msg) ||
        !ntfssa.Read() ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                        ntfssa.QueryClusterFactor(),
                        ntfssa.QueryFrsSize(),
                        ntfssa.QueryVolumeSectors(), NULL, NULL) ||
        !mft.Read() ||
        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
        !bitmap_file.Read() ||
        !bitmap_file.QueryAttribute(&bitmap_attribute, &error, $DATA) ||
        !volume_bitmap.Initialize(Drive->QuerySectors()/
               (ULONG) ntfssa.QueryClusterFactor(), FALSE, NULL, 0) ||
        !volume_bitmap.Read(&bitmap_attribute) ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
        !upcase_table.Initialize(&upcase_attribute) ||
        !mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
                        ntfssa.QueryClusterFactor(),
                        ntfssa.QueryFrsSize(),
                        ntfssa.QueryVolumeSectors(),
                        &volume_bitmap,
                        &upcase_table) ||
        !mft.Read() ||
        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
        !bitmap_file.Read() ||
        !bitmap_file.QueryAttribute(&bitmap_attribute, &error, $DATA) ||
        !volume_bitmap.Initialize(Drive->QuerySectors()/
             (ULONG) ntfssa.QueryClusterFactor(), FALSE, NULL, 0) ||
        !volume_bitmap.Read(&bitmap_attribute) ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attribute, &error, $DATA) ||
        !upcase_table.Initialize(&upcase_attribute) ||
        !BacktrackFrs( FileNumber, mft.GetMasterFileTable(), WPath,
                            BufferLength, &PathLength ) ) {

        return FALSE;
    }

    MessageBox(WindowHandle, WPath, TEXT("Path Image"), MB_OK);

    return TRUE;
}



VOID
CrackFatPath(
    IN  HWND    WindowHandle
    )
{
    DSTRING      path;
    REAL_FAT_SA  fatsa;
    MESSAGE      msg;
    ULONG        cluster_number;
    TCHAR        buf[100];

    if (!path.Initialize(Path) ||
        !Drive ||
        !fatsa.Initialize(Drive, &msg) ||
        !fatsa.FAT_SA::Read()) {

        return;
    }

    cluster_number = fatsa.QueryFileStartingCluster(&path);

    wsprintf(buf, TEXT("The given path points to cluster 0x%X"), cluster_number);

    MessageBox(WindowHandle, buf, TEXT("Path Image"), MB_OK);
}

VOID
CrackLsn(
    IN HWND     WindowHandle
    )
{
    extern LSN  Lsn;
    TCHAR       buf[100];
    LONGLONG    FileOffset;

    (void)GetLogPageSize(Drive);

    LfsTruncateLsnToLogPage(Drive, Lsn, &FileOffset);

    wsprintf(buf, TEXT("page at %x, offset %x, seq %x"), (ULONG)FileOffset,
        LfsLsnToPageOffset(Drive, Lsn) , LfsLsnToSeqNumber(Drive, Lsn));
    MessageBox(WindowHandle, buf, TEXT("LSN"), MB_OK);
}

//
// CrackNextLsn -- given an LSN in the Lsn variable, find the
//      LSN following that one in the log file.  This involves
//      reading the log record for the given lsn to find it's
//      size, and figuring the page and offset of the following
//      lsn from that.
//
BOOLEAN
CrackNextLsn(
    IN HWND     WindowHandle
    )
{
    extern LSN  Lsn;
    TCHAR       buf[100];
    NTFS_SA     ntfssa;
    NTFS_MFT_FILE mft;
    ULONG       PageOffset;
    LONGLONG    FileOffset;
    MESSAGE     msg;
    BOOLEAN     error;
    NTFS_FILE_RECORD_SEGMENT frs;
    NTFS_ATTRIBUTE attrib;

    LFS_RECORD_HEADER RecordHeader;
    ULONG       bytes_read;
    ULONG       RecordLength;
    ULONG       PageSize;
    ULONGLONG   NextLsn;
    ULONG       SeqNumber;

    if (0 == (PageSize = GetLogPageSize(Drive))) {
        return FALSE;
    }

    if (!Drive)
        return FALSE;
    if (!ntfssa.Initialize(Drive, &msg))
        return FALSE;
    if (!ntfssa.Read())
        return FALSE;
    if (!mft.Initialize(Drive, ntfssa.QueryMftStartingLcn(),
            ntfssa.QueryClusterFactor(), ntfssa.QueryFrsSize(),
            ntfssa.QueryVolumeSectors(), NULL, NULL))
        return FALSE;
    if (!mft.Read())
        return FALSE;
    if (!frs.Initialize((VCN)LOG_FILE_NUMBER, &mft))
        return FALSE;
    if (!frs.Read())
        return FALSE;
    if (!frs.QueryAttribute(&attrib, &error, $DATA, NULL)) {
        return FALSE;
    }

    LfsTruncateLsnToLogPage(Drive, Lsn, &FileOffset);
    PageOffset = LfsLsnToPageOffset(Drive, Lsn);
    SeqNumber = (ULONG)LfsLsnToSeqNumber(Drive, Lsn);

    if (!attrib.Read((PVOID)&RecordHeader, ULONG(PageOffset | FileOffset),
        LFS_RECORD_HEADER_SIZE, &bytes_read))
        return FALSE;

    if (bytes_read != LFS_RECORD_HEADER_SIZE) {
        return FALSE;
    }

    RecordLength = LFS_RECORD_HEADER_SIZE + RecordHeader.ClientDataLength;

    if (PageOffset + RecordLength < PageSize &&
        PageSize - (PageOffset + RecordLength) >= LFS_RECORD_HEADER_SIZE) {

        //
        // the current record ends on this page, and the next record begins
        // immediately after
        //

        PageOffset += RecordLength;

    } else if (PageSize - (PageOffset+RecordLength) < LFS_RECORD_HEADER_SIZE) {

        //
        // The next record header will not fit on this page... it
        // will begin on the next page immediately following the page
        // header
        //

        FileOffset += PageSize;
        PageOffset = LFS_PACKED_RECORD_PAGE_HEADER_SIZE;

    } else {
        //
        // the next log record starts on a following page
        //

        ULONG left;
        ULONG page_capacity;

        left = PageSize - (PageOffset + RecordLength);
        page_capacity = PageSize - LFS_PACKED_RECORD_PAGE_HEADER_SIZE;
        PageOffset += (left / page_capacity + 1) * PageSize;
        FileOffset = left % page_capacity + LFS_PACKED_RECORD_PAGE_HEADER_SIZE;
    }

    // create lsn from FileOffset + PageOffset

    NextLsn = LfsFileOffsetToLsn(Drive, FileOffset | PageOffset, SeqNumber);

    wsprintf(buf, TEXT("Next LSN %x:%x, at %x + %x"), ((PLSN)&NextLsn)->HighPart,
        ((PLSN)&NextLsn)->LowPart, (ULONG)FileOffset, (ULONG)PageOffset);
    MessageBox(WindowHandle, buf, TEXT("LSN"), MB_OK);

    return TRUE;
}

struct {
    ULONG Code;
    PTCHAR Name;
} TypeCodeNameTab[] = {
    { $UNUSED,                  TEXT("$UNUSED") },
    { $STANDARD_INFORMATION,    TEXT("$STANDARD_INFORMATION") },
    { $ATTRIBUTE_LIST,          TEXT("$ATTRIBUTE_LIST") },
    { $FILE_NAME,               TEXT("$FILE_NAME") },
    { $OBJECT_ID,           TEXT("$OBJECT_ID") },
    { $SECURITY_DESCRIPTOR,     TEXT("$SECURITY_DESCRIPTOR") },
    { $VOLUME_NAME,             TEXT("$VOLUME_NAME") },
    { $VOLUME_INFORMATION,      TEXT("$VOLUME_INFORMATION") },
    { $DATA,                    TEXT("$DATA") },
    { $INDEX_ROOT,              TEXT("$INDEX_ROOT") },
    { $INDEX_ALLOCATION,        TEXT("$INDEX_ALLOCATION") },
    { $BITMAP,                  TEXT("$BITMAP") },
    { $SYMBOLIC_LINK,           TEXT("$SYMBOLIC_LINK") },
    { $EA_INFORMATION,          TEXT("$EA_INFORMATION") },
    { $EA_DATA,                 TEXT("$EA_DATA") },
    { $END,                     TEXT("$END") }
};

PTCHAR
GetNtfsAttributeTypeCodeName(
    IN  ULONG   Code
    )
{
    for (INT i = 0; $END != TypeCodeNameTab[i].Code; ++i) {
        if (Code == TypeCodeNameTab[i].Code) {
            return TypeCodeNameTab[i].Name;
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\diskedit\atrlsted.cxx ===
#include "ulib.hxx"
#include "untfs.hxx"
#include "frsstruc.hxx"
#include "ntfssa.hxx"
#include "attrrec.hxx"
#include "cmem.hxx"
#include "ntfssa.hxx"
#include "atrlsted.hxx"
#include "crack.hxx"
#include "attrlist.hxx"

extern "C" {
#include <stdio.h>
}

BOOLEAN
ATTR_LIST_EDIT::Initialize(
    IN  HWND                WindowHandle,
    IN  INT                 ClientHeight,
    IN  INT                 ClientWidth,
    IN  PLOG_IO_DP_DRIVE    Drive
    )
{
    TEXTMETRIC  textm