     while (i < sizeof(iPID)/sizeof(iPID[0]))
                {
                    if (iPID[i] != 0)
                    {
                        szPID[i] = szDecrypt[iPID[i]];
                    }
                    else
                    {
                        szPID[i] = '-';
                    }
                    i++;
                }
                szPID[i] = '\0';
                *szOutData = (LPSTR)GlobalAlloc(GPTR, lstrlen(szPID)+1);
                if (*szOutData) 
                {
                    lstrcpy(*szOutData, szPID);
                    hr = S_OK;
                }
            }
        }
    }
    if (szDecrypt)
    {
        GlobalFree(szDecrypt);
    }
    return hr;
}

HRESULT ValidateEncryptedPIDW(LPWSTR szPID, LPWSTR *szOutData)
{
    HRESULT hr = E_FAIL;
    LPSTR  szData = NULL;
    LPSTR  pPid = NULL;

    pPid = (LPBYTE)_PEConvertW2A (szPID, CP_ACP);
    if (pPid != NULL)
    {
        if ((hr = ValidateEncryptedPIDA(pPid, &szData)) == S_OK)
        {
            *szOutData = _PEConvertA2W (szData, CP_ACP);
            if (*szOutData)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
            GlobalFree(szData);
        }
        GlobalFree(pPid);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    return hr;
}

#if 0
void
_stdcall
ModuleEntry(
    VOID
    )
{

    CHAR szInData[256];
    CHAR szPID[] = "Ctpdw-6q4d3-wrgdy-796g2-9vrmq";
	LPSTR szOutData = NULL;
	CHAR *szDecrypt = NULL;
#if 0
    SYSTEMTIME  CurrentTime;
    SYSTEMTIME  UniversalTime;

    GetLocalTime(&UniversalTime);

    wsprintf( szInData, "%s$%02d-%02d-%04d %02d:%02d:%02d",
        szPID,
        UniversalTime.wMonth,
        UniversalTime.wDay,
        UniversalTime.wYear,
        UniversalTime.wHour,
        UniversalTime.wMinute,
        UniversalTime.wSecond);

    WritePrivateProfileStringA("UserData","ProductID", szInData, "f:\\test.ini");
	EncryptDataA((LPSTR)szInData, sizeof(szInData), &szOutData);
    if (szOutData)
    {
        WritePrivateProfileStringA("UserData","ProductIDEncryped", szOutData, "f:\\test.ini");
	    DecryptDataA(szOutData, &szDecrypt);
        if (lstrcmpA(szInData, szDecrypt) == 0)
        {
            WritePrivateProfileStringA("UserData","Compare", "Same", "f:\\test.ini");
        }
        else
        {
            WritePrivateProfileStringA("UserData","Compare", "Different", "f:\\test.ini");
        }
        GlobalFree ((PVOID)szOutData);
        if (szDecrypt)
        {
            WritePrivateProfileStringA("UserData","ProductIDDecypted", szDecrypt, "f:\\test.ini");
            GlobalFree ((PVOID)szDecrypt);
        }
    }
#else
    WritePrivateProfileStringA("UserData","ProductID", szPID, "f:\\test.ini");
    if (PrepareEncryptedPIDA(szPID, 5, &szOutData) == S_OK)
    {
        WritePrivateProfileStringA("UserData","ProductIDEncryped", szOutData, "f:\\test.ini");
        if (ValidateEncryptedPIDA(szOutData, &szDecrypt) == S_OK)
        {
            WritePrivateProfileStringA("UserData","ProductIDDecypted", szDecrypt, "f:\\test.ini");
        }
    }
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\inc\shortsig.h ===
/*++ 

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    shortsig.h

Abstract:

--*/


// MS CD Key
#ifdef __cplusplus
extern "C" {
#endif

typedef int SSRETCODE;  // type for return codes

#define SS_OK 0
#define SS_BAD_KEYLENGTH 1
#define SS_OTHER_ERROR 2
#define SS_INVALID_SIGNATURE 3

// The first DWORD of a Public or Private key is the total length of the key including
// the DWORD length

#ifndef SIG_VERIFY_ONLY ///////////////////////////////////////////////////////

SSRETCODE CryptInit();  // Not needed for CryptVerifySig()

SSRETCODE CryptGetKeyLens(
    LONG cbitSig,       // [IN] count of bits in Sig
    LONG *pcbPrivate,   // [OUT] ptr to number of bytes in the private key
    LONG *pcbPublic);   // [OUT] ptr to number of bytes in the private key

SSRETCODE CryptKeyGen(
    LONG  cbRandom,     // [IN] count of random Bytes
    LPVOID pvRandom,    // [IN] ptr to array of random Bytes
    LONG  cbitsSig,     // [IN] count of bits in Sig
    LPVOID pvKeyPrivate,// [OUT] the generated private key
    LPVOID pvKeyPublic);// [OUT] the generated public key

SSRETCODE CryptSign(
    LONG cbRandom,      // [IN] count of random Bytes
    LPVOID pvRandom,    // [IN] ptr to array of random Bytes
    LONG  cbMsg,        // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to sign
    LONG  cbKeyPrivate, // [IN] number of bytes in private key (from CryptGetKeyLens)
    LPVOID pvKeyPrivate,// [IN] the generated private key (from CryptKeyGen)
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig);       // [OUT] the digital signature

SSRETCODE CryptSignBatch(
    LONG cbRandom,      // [IN] count of random Bytes
    LPVOID pvRandom,    // [IN] ptr to array of random Bytes
    LONG  cbMsg,        // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to sign
    LONG  cbKeyPrivate, // [IN] number of bytes in private key (from CryptGetKeyLens)
    LPVOID pvKeyPrivate,// [IN] the generated private key (from CryptKeyGen)
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig,       // [OUT] the digital signature
    LONG cMsg);         // [IN]  the count of messages to sign

SSRETCODE CryptAuthenticate(
    LONG  cbMsg,        // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to authenticate
    LONG  cbKeyPrivate, // [IN] number of bytes in private key (from CryptGetKeyLens)
    LPVOID pvKeyPrivate,// [IN] the generated private key (from CryptKeyGen)
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig);      // [IN] the digital signature

SSRETCODE CryptVerifySigFast(
    LONG   cbMsg,       // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to Authenticate
    LONG   cbKeyPublic, // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG   cbitsSig,    // [IN] the number of bits in the sig
    LPVOID pvSig);      // [IN] the digital signature

#endif  // ndef SIG_VERIFY_ONLY ///////////////////////////////////////////////

SSRETCODE CryptVerifySig(
    LONG cbMsg,         // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to verify
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig);      // [IN] the digital signature (from CryptSign)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\crcmodel.c ===
/****************************************************************************/
/*							   Start of crcmodel.c							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the implementation (.c) file for the reference 	*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Implementation Notes 													*/
/* -------------------- 													*/
/* To avoid inconsistencies, the specification of each function is not		*/
/* echoed here. See the header file for a description of these functions.	*/
/* This package is light on checking because I want to keep it short and	*/
/* simple and portable (i.e. it would be too messy to distribute my entire	*/
/* C culture (e.g. assertions package) with this package.					*/
/*																			*/
/****************************************************************************/

#include "crcmodel.h"

/****************************************************************************/
/* The following definitions make the code more readable.					*/

#define BITMASK(X) (1L << (X))
#define MASK32 0xFFFFFFFFL
#define LOCAL static

/****************************************************************************/

/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26						*/

LOCAL ulong reflect(
    ulong v,
    int   b)
{
 int   i;
 ulong t = v;
 for (i=0; i<b; i++)
   {
	if (t & 1L)
	   v|=	BITMASK((b-1)-i);
	else
	   v&= ~BITMASK((b-1)-i);

	t>>=1;

   }
 return v;
}

/****************************************************************************/

/* Returns a longword whose value is (2^p_cm->cm_width)-1.	   */
/* The trick is to do this portably (e.g. without doing <<32). */

LOCAL ulong widmask(p_cm_t p_cm)
{
 return (((1L<<(p_cm->cm_width-1))-1L)<<1)|1L;
}

/****************************************************************************/

void cm_ini (p_cm_t p_cm)
{
 p_cm->cm_reg = p_cm->cm_init;
}

/****************************************************************************/

void cm_nxt(p_cm_t p_cm, int ch)
{
 int   i;
 ulong uch	= (ulong) ch;
 ulong topbit = BITMASK(p_cm->cm_width-1);

 if (p_cm->cm_refin) uch = reflect(uch,8);
 p_cm->cm_reg ^= (uch << (p_cm->cm_width-8));
 for (i=0; i<8; i++)
   {
	if (p_cm->cm_reg & topbit)
	   p_cm->cm_reg = (p_cm->cm_reg << 1) ^ p_cm->cm_poly;
	else
	   p_cm->cm_reg <<= 1;
	p_cm->cm_reg &= widmask(p_cm);
   }
}

/****************************************************************************/

void cm_blk(
p_cm_t	 p_cm,
p_ubyte_ blk_adr,
ulong	 blk_len)
{
 while (blk_len--) cm_nxt(p_cm,*blk_adr++);
}

/****************************************************************************/

ulong cm_crc(p_cm_t p_cm)
{
 if (p_cm->cm_refot)
	return p_cm->cm_xorot ^ reflect(p_cm->cm_reg,p_cm->cm_width);
 else
	return p_cm->cm_xorot ^ p_cm->cm_reg;
}

/****************************************************************************/

ulong cm_tab(p_cm_t p_cm, int index)
{
 int   i;
 ulong r;
 ulong topbit = BITMASK(p_cm->cm_width-1);
 ulong inbyte = (ulong) index;

 if (p_cm->cm_refin) inbyte = reflect(inbyte,8);
 r = inbyte << (p_cm->cm_width-8);
 for (i=0; i<8; i++)
	if (r & topbit)
	   r = (r << 1) ^ p_cm->cm_poly;
	else
	   r<<=1;
 if (p_cm->cm_refin) r = reflect(r,p_cm->cm_width);
 return r & widmask(p_cm);
}

/****************************************************************************/
/*							   End of crcmodel.c							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\crc-32.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    crc-32.cpp

Abstract:

--*/


#include <windows.h>
#include "crc-32.h"


DWORD CRC_32(LPBYTE pb, DWORD cb)
{

//      CRC-32 algorithm used in PKZip, AUTODIN II, Ethernet, and FDDI
//      but xor out (xorot) has been changed from 0xFFFFFFFF to 0 so
//      we can store the CRC at the end of the block and expect 0 to be
//      the value of the CRC of the resulting block (including the stored
//      CRC).

    cm_t cmt = {
        32,         // cm_width  Parameter: Width in bits [8,32].
        0x04C11DB7, // cm_poly   Parameter: The algorithm's polynomial.
        0xFFFFFFFF, // cm_init   Parameter: Initial register value.
        TRUE,       // cm_refin  Parameter: Reflect input bytes?
        TRUE,       // cm_refot  Parameter: Reflect output CRC?
        0,          // cm_xorot  Parameter: XOR this to output CRC.
        0           // cm_reg    Context: Context during execution.
    };

    // Documented test case for CRC-32:
    // Checking "123456789" should return 0xCBF43926

    cm_ini(&cmt);
    cm_blk(&cmt, pb, cb);

    return cm_crc(&cmt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\chardwar.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    CHardwar.h

Abstract:

--*/

#ifndef CHARDWARE_H
#define CHARDWARE_H


#ifndef __WINDOWS_H
#include <windows.h>
#endif


// Used Definitions Declarations

#define CHARDWARE_CLASSID 0x13530808L

#define BIOS_DIGIT       0
#define HD_SERIAL_DIGIT  1
#define TOTAL_RAM_DIGIT  2
#define FD_CONFIG_DIGIT  3
#define VIDEO_BIOS_DIGIT 4
#define HARDWARE_ID_SIZE 6

#define HARDWARE_GUID_SIZE 39

#define MAX_BIOS_KEY_LENGTH 2048

#define VWIN32_DIOC_DOS_INT13 4

#define FLAGS_CARRY 1


// Used Type Declarations

typedef struct _DIOC_REGISTERS
{
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS, *PDIOC_REGISTERS;

#pragma pack(1)
typedef struct _DEVICEPARAMS
{
    BYTE  dpSpecFunc;
    BYTE  dpDevType;
    WORD  dpDevAttr;
    WORD  dpCylinders;
    BYTE  dpMediaType;

    WORD  dpBytesPerSec;
    BYTE  dpSecPerClust;
    WORD  dpResSectors;
    BYTE  dpFATs;
    WORD  dpRootDirEnts;
    WORD  dpSectors;
    BYTE  dpMedia;
    WORD  dpFATsecs;
    WORD  dpSecPerTrack;
    WORD  dpHeads;
    DWORD dpHiddenSecs;
    DWORD dpHugeSectors;
} DEVICEPARAMS, *PDEVICEPARAMS;
#pragma pack()


// Class Declaration

class CHardware
{
    public:
        CHardware();
        virtual ~CHardware();

    public:
        LPSTR GetGUID();
        LPSTR GetID();

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        DWORD GetType();
        DWORD GetBiosCrc32() { return m_dwBiosCrc32; };
        DWORD GetVolSer() { return m_dwVolSer; };
        DWORD GetTotalRamMegs() { return m_dwTotalRamMegs; };
        DWORD GetVideoBiosCrc32() { return m_dwVideoBiosCrc32; };
#endif

    public:
        ULONG uClassID;

    private:
#ifndef _WIN64
        DWORD CalculateDriveCapacity95( INT nDrive );
#endif
        DWORD CalculateMemoryRegionChecksum( LPBYTE pbChecksumArea, INT nNumberBytes );
        VOID SetBIOSDigit();
        VOID SetFDConfigDigit();
        VOID SetHDSerialDigit();
        VOID SetTotalRAMDigit();
        VOID SetVideoBIOSDigit();

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
        VOID CalculateHardwareGUID();
#endif ////////////////////////////////////////////////////////////////////////

#if defined(WIN32) || defined(_WIN32)
        static UINT CalculateRegKeyChecksum( LPSTR lpszKey );
        static DWORD CalculateDriveCapacityNT( INT nDrive );
#endif

    private:
        CHAR m_szHardwareID[ HARDWARE_ID_SIZE ];

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
        CHAR m_szHardwareGUID[ HARDWARE_GUID_SIZE ];
#endif ////////////////////////////////////////////////////////////////////////

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        DWORD m_dwBiosCrc32;
        DWORD m_dwVolSer;
        DWORD m_dwTotalRamMegs;
        DWORD m_dwVideoBiosCrc32;
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\crc-32.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    crc-32.h

Abstract:

--*/


#include "crcmodel.h"

DWORD CRC_32(LPBYTE pb, DWORD cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\crc32.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    Crc32.h

Abstract:

--*/

#ifndef CRC32_H
#define CRC32_H

#include <windows.h>

#include <string.h>  // needed by compobj.h

#if defined(WIN32) || defined(_WIN32)

#include <crtdbg.h>

#else

typedef short INT;

#include <assert.h>
#define _ASSERT assert

#include <compobj.h> // needed for 16-bit build

#endif

#include "tchar.h"
#include "CCrc32.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\crc32.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    Crc.cpp

Abstract:

--*/

#include "Crc32.h"


CCrc32::CCrc32()
{
    uClassID = CCRC32_CLASSID;

    InitialiseCRCTable();
}


CCrc32::~CCrc32()
{
}


VOID CCrc32::InitialiseCRCTable()
{
    INT   nIndex;
    INT   nBitIndex;
    ULONG uTableValue;

    for ( nIndex = 0; nIndex < 256; nIndex++ )
    {
        uTableValue = nIndex;

        for ( nBitIndex = 0; nBitIndex < 8; nBitIndex++ )
        {
            if ( ( uTableValue & 1 ) == 1 )
            {
                uTableValue = ( uTableValue >> 1 ) ^ CRC32_POLYNOMIAL;
            } else
            {
                uTableValue = uTableValue >> 1;
            }
        }

        m_uCRC32Table[ nIndex ] = uTableValue;
    }
}


ULONG CCrc32::CalculateBlockCRC(LPVOID lpvBlock, INT nBlockLength)
{
    INT    nIndex;
    LPBYTE lpbBlock;
    ULONG  uCRCValue;

    _ASSERT( nBlockLength > 0 );

    lpbBlock  = (LPBYTE)lpvBlock;
    uCRCValue = 0xFFFFFFFFL;

    for ( nIndex = 0; nIndex < nBlockLength; nIndex++ )
    {
        uCRCValue = ( ( uCRCValue >> 8 ) & 0x00FFFFFFL ) ^ ( m_uCRC32Table[ ( uCRCValue ^ lpbBlock[ nIndex ] ) & 0xFFL ] );
    }

    uCRCValue = uCRCValue ^ 0xFFFFFFFFL;

    return uCRCValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\hardware.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    Hardware.h

Abstract:

--*/

#ifndef HARDWARE_H
#define HARDWARE_H

#define NO_HWID_GUID
#define HWID_DETAIL

#include <string.h>  // needed by compobj.h
#include <windows.h>

#if defined(WIN32) || defined(_WIN32)

#include <crtdbg.h>

#else

typedef short INT;
typedef char CHAR;

#include <toolhelp.h>

#include <assert.h>
#define _ASSERT assert

#include <compobj.h> // needed for 16-bit build
#include <dos.h>

#endif


#include <string.h>

#include "tchar.h"

#if defined(WIN32) || defined(_WIN32)
#include <winioctl.h>
#endif

// #include "LicWiz.h"
#include "CHardwar.h"

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
#include "crc32.h"
#endif

#include "crc-32.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\hardware.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    Hardware.h

Abstract:

--*/

#include "Hardware.h"

#include <stdio.h> // only needed for testing


#if defined(WIN32) || defined(_WIN32)

static inline BOOL IsPlatformNT()
{

    // always do it 'The NT Way'

    return TRUE;

/*/////////////////////////////////////////////////////////////////////////////

    OSVERSIONINFO osvInfo;
    BOOL          fNTPlatformFlag;

    osvInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    GetVersionEx( &osvInfo );

    switch( osvInfo.dwPlatformId )
    {
        case VER_PLATFORM_WIN32_NT:
            fNTPlatformFlag = TRUE;
            break;

        default:
            fNTPlatformFlag = FALSE;
            break;
    }

    return( fNTPlatformFlag );
*//////////////////////////////////////////////////////////////////////////////
}

#else

inline BOOL IsPlatformNT()
{
    return FALSE;
}

extern "C" extern WORD _C000H;
extern "C" extern WORD _F000H;

#endif

CHardware::CHardware()
#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
  : m_dwBiosCrc32(0),
    m_dwVolSer(0),
    m_dwTotalRamMegs(0),
    m_dwVideoBiosCrc32(0)
#endif
{
    uClassID = CHARDWARE_CLASSID;

    ZeroMemory( (LPVOID)m_szHardwareID, HARDWARE_ID_SIZE );

    SetBIOSDigit();
    SetHDSerialDigit();
    SetTotalRAMDigit();
    SetFDConfigDigit();
    SetVideoBIOSDigit();

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
    CalculateHardwareGUID();
#endif ////////////////////////////////////////////////////////////////////////
}


CHardware::~CHardware()
{
}


DWORD CHardware::GetType()
{
    return(IsPlatformNT() ? 1 : 0);
}


LPSTR CHardware::GetID()
{
    return( m_szHardwareID );
}

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
LPSTR CHardware::GetGUID()
{
    return( m_szHardwareGUID );
}
#endif ////////////////////////////////////////////////////////////////////////

VOID CHardware::SetBIOSDigit()
{
    DWORD dwBIOSChecksum;

#if defined(WIN32) || defined(_WIN32)
    if ( IsPlatformNT() )
    {
        dwBIOSChecksum  = CalculateRegKeyChecksum( "SystemBiosDate" );
        dwBIOSChecksum += CalculateRegKeyChecksum( "SystemBiosVersion" );
        m_dwBiosCrc32 = dwBIOSChecksum;
    } else
#endif
    {
        LPBYTE pbMemoryByte;

#if defined(WIN32) || defined(_WIN32)
        pbMemoryByte = (LPBYTE)0xF0000;
#else
        pbMemoryByte = (LPBYTE)MAKELONG(0, &_F000H);
#endif
        dwBIOSChecksum = CalculateMemoryRegionChecksum(pbMemoryByte, 2048);
#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        m_dwBiosCrc32 = CRC_32(pbMemoryByte, 2048);
#endif
    }

    m_szHardwareID[ BIOS_DIGIT ] = (CHAR)( dwBIOSChecksum % 9 ) + '0';
}

#if defined(WIN32) || defined(_WIN32)

UINT CHardware::CalculateRegKeyChecksum(LPSTR lpszKey)
{
    LONG lStatus;
    HKEY hkSystem;
    UINT uChecksum;

    uChecksum = 0;

    lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("HARDWARE\\DESCRIPTION\\System"), 0, KEY_QUERY_VALUE, &hkSystem );

    _ASSERT( lStatus == ERROR_SUCCESS );

    if ( lStatus == ERROR_SUCCESS )
    {
        DWORD dwValueType;
        DWORD dwBufferSize;
        BYTE  Buffer[ MAX_BIOS_KEY_LENGTH ];

        dwBufferSize = MAX_BIOS_KEY_LENGTH;

        lStatus = RegQueryValueExA( hkSystem, lpszKey, NULL, &dwValueType, Buffer, &dwBufferSize );

        // ASSERT( lStatus == ERROR_SUCCESS ); // Not all values are guarenteed to exist

        if ( lStatus == ERROR_SUCCESS )
        {
            UINT nCurrentByte;

            for ( nCurrentByte = 0; nCurrentByte < dwBufferSize; nCurrentByte++ )
            {
                uChecksum += Buffer[ nCurrentByte ];
            }
        }

        RegCloseKey( hkSystem );
    }

    return( uChecksum );
}
#endif

DWORD CHardware::CalculateMemoryRegionChecksum( LPBYTE pbChecksumArea, INT nNumberBytes )
{
    DWORD  dwRegionChecksum = 0;

    while (0 < nNumberBytes)
    {
        dwRegionChecksum += (UINT)( *pbChecksumArea );
        ++pbChecksumArea;
        --nNumberBytes;
    }

    return( dwRegionChecksum );
}

#if !defined(WIN32) && !defined(_WIN32)

#pragma pack(1)
   // Media ID
   typedef struct {
       WORD   wInfoLevel;
       DWORD  dwSerialNum;
       char   achVolLabel[11];
       BYTE   abFileSysType[8];
   } MID, *PMID, FAR* LPMID;
#pragma pack()

#endif


VOID CHardware::SetHDSerialDigit()
{
    m_szHardwareID[ HD_SERIAL_DIGIT ] = '?';
    BOOL  fInfoSuccess;
    DWORD dwVolumeSerialNumber;

#if defined(WIN32) || defined(_WIN32)

    DWORD dwFileSystemFlags;
    DWORD dwMaximumComponentLength;
    CHAR  szBootDrivePath[ MAX_PATH ];

    wsprintfA( szBootDrivePath, "C:\\" );
    fInfoSuccess = GetVolumeInformationA( szBootDrivePath, NULL, 0, &dwVolumeSerialNumber, &dwMaximumComponentLength, &dwFileSystemFlags, NULL, 0 );

    _ASSERT( fInfoSuccess );

#else

    LPMID  pmid;
    union  _REGS regs;
    struct _SREGS segregs;
    DWORD  dwMem;

    dwMem = GlobalDosAlloc(sizeof(MID));

    WORD wMidSelector = LOWORD(dwMem);
    WORD wMidSegment = HIWORD(dwMem);

    pmid = (LPMID)MAKELP(wMidSelector, 0);
    ZeroMemory(pmid, sizeof(MID));

    ZeroMemory(&regs, sizeof(regs));
    ZeroMemory(&segregs, sizeof(segregs));

    regs.x.ax = 0x440d;  // DOS Function 440Dh - IOCTL for Block Device
    regs.h.cl = 0x66;    // Minor Code 66h - Get Media ID
    regs.h.ch = 0x08;    // Device category (must be 08h)
    regs.x.bx = 3;       // Drive C:
    regs.x.dx = 0;       // pmid offset

    segregs.ds = wMidSelector; // wMidSegment;
    segregs.es = wMidSelector; // wMidSegment;

    _intdosx(&regs, &regs, &segregs);

    fInfoSuccess = !regs.x.cflag;

    dwVolumeSerialNumber = pmid->dwSerialNum;
    GlobalDosFree(wMidSelector);
#endif

    if ( fInfoSuccess )
    {
        m_szHardwareID[ HD_SERIAL_DIGIT ] = (CHAR)( dwVolumeSerialNumber % 9 ) + '0';

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        m_dwVolSer = dwVolumeSerialNumber;
#endif

    }
}



VOID CHardware::SetTotalRAMDigit()
{
    DWORD        dwTotalMegabytes;

    m_szHardwareID[ TOTAL_RAM_DIGIT ] = '?';

#if defined(WIN32) || defined(_WIN32)

    MEMORYSTATUS mStatus;

    mStatus.dwLength = sizeof( MEMORYSTATUS );

    GlobalMemoryStatus( &mStatus );

    dwTotalMegabytes  = (DWORD)( mStatus.dwTotalPhys / (1024 * 1024)); // convert to megabytes
    dwTotalMegabytes += 1; // Add 1Mb to produce accurate result due to reserved space

#else
    BYTE abDpmiMemInfo[0x30];

    FillMemory(abDpmiMemInfo, sizeof(abDpmiMemInfo), -1);

    __asm {
                push    di                      ;save regs

                push    ss
                pop     es                      ;make es point to stack
                lea     di,abDpmiMemInfo        ;Get offset of buffer
                mov     ax,0500h                ;DPMI -- Get Free Memory Info
                int     31h                     ;Call DPMI

                pop     di                      ;restore regs
    }

    DWORD dwTotalPages = *(LPDWORD)&abDpmiMemInfo[0x18];

    // check to see if the field is -1 (error) and just use 0
    // we're adding 1 to account for the memory below 1M (I think)
    dwTotalMegabytes = (dwTotalPages == -1) ? 0 : (1 + dwTotalPages/(1024/4));
#endif

    m_szHardwareID[ TOTAL_RAM_DIGIT ] = (CHAR)( dwTotalMegabytes % 9 ) + '0';

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
    m_dwTotalRamMegs = dwTotalMegabytes;
#endif

}


VOID CHardware::SetFDConfigDigit()
{
    DWORD dwFDConfig;

#if defined(WIN32) || defined(_WIN32)
    if ( IsPlatformNT() )
    {
        dwFDConfig  = CalculateDriveCapacityNT( 1 ) << 2;
        dwFDConfig += CalculateDriveCapacityNT( 2 );
    } else
#endif
    {
#ifndef _WIN64
        dwFDConfig  = CalculateDriveCapacity95( 1 ) << 2;
        dwFDConfig += CalculateDriveCapacity95( 2 );
#endif
    }

    m_szHardwareID[ FD_CONFIG_DIGIT ] = (CHAR)( dwFDConfig % 9 ) + '0';
}

#ifndef _WIN64
DWORD CHardware::CalculateDriveCapacity95( INT nDrive )
{
    DWORD   dwDriveCapacity = 0;
    BOOL    fOk;

    UINT    uNumberHeads;
    UINT    uNumberTracks;
    UINT    uBytesPerSector;
    UINT    uSectorsPerTrack;
    LPBYTE  pbDiskParamTable;


#if defined(WIN32) || defined(_WIN32)

    HANDLE         hDevice;
    BOOL           fResult;
    DIOC_REGISTERS DIOCRegs;
    DWORD          dwBytesReturned;

    // Open VWIN32 Device For Access To DOS Int 13h Functions

    hDevice = CreateFile( TEXT("\\\\.\\vwin32"), 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL );
    fOk = (hDevice != INVALID_HANDLE_VALUE);


    if (fOk)
    {
        // Invoke Int 13h Function 08h - Get Drive Parameters

        DIOCRegs.reg_EAX = 0x0800; // Get Drive Parameters
        DIOCRegs.reg_EDX = nDrive - 1; // 0 = A:, 1 = B:

        fResult = DeviceIoControl( hDevice, VWIN32_DIOC_DOS_INT13, &DIOCRegs, sizeof( DIOC_REGISTERS ), &DIOCRegs, sizeof( DIOC_REGISTERS ), &dwBytesReturned, NULL );

        // Determine if Int 13h Call Succeeded
        fOk = (fResult == TRUE && 0 == (DIOCRegs.reg_Flags & FLAGS_CARRY));
    }

    if (fOk)
    {
        // Calculate Drive Capacity if Drive Number is Valid

        if ( ( DIOCRegs.reg_EDX & 0xFF ) >= (UINT)nDrive )
        {

            pbDiskParamTable = (UCHAR *)DIOCRegs.reg_EDI;

            uNumberHeads     = ( ( DIOCRegs.reg_EDX >> 8 ) & 0xFF ) + 1;
            uNumberTracks    = ( ( ( DIOCRegs.reg_ECX << 2 ) & 0x300 ) + ( ( DIOCRegs.reg_ECX >> 8 ) & 0xFF ) ) + 1;
            uSectorsPerTrack = ( DIOCRegs.reg_ECX & 0x3F );
            uBytesPerSector  = ( 128 << ( *( pbDiskParamTable + 3 ) ) );

            dwDriveCapacity = uNumberHeads * uNumberTracks * uSectorsPerTrack * uBytesPerSector;
        }
    }

    if (hDevice != INVALID_HANDLE_VALUE)
    {
        CloseHandle( hDevice );
    }

#else

    union _REGS regs;
    struct _SREGS segregs;

    ZeroMemory(&regs, sizeof(regs));
    ZeroMemory(&segregs, sizeof(segregs));

    regs.h.ah = 0x08;       // BIOS Function 08h - Get drive parameters
    regs.x.dx = nDrive - 1; // 0 = A:, 1 = B:

    _int86x(
        0x13, // BIOS Disk
        &regs,
        &regs,
        &segregs);


    fOk = (!regs.x.cflag);

    if (fOk)
    {
        uNumberHeads = regs.h.dh + 1;
        uNumberTracks = ((regs.h.cl & 0xC0) << 2) + regs.h.ch + 1;
        uSectorsPerTrack = regs.h.cl & 0x3F;

        pbDiskParamTable = (LPBYTE)MAKELP(segregs.es, regs.x.di);

        uBytesPerSector = (128 << pbDiskParamTable[3]);

        dwDriveCapacity = (DWORD)uNumberHeads * uNumberTracks * uSectorsPerTrack * uBytesPerSector;
    }

#endif

    dwDriveCapacity /= ( 1024L * 100L );


    return( dwDriveCapacity );
}
#endif


#if defined(WIN32) || defined(_WIN32)

DWORD CHardware::CalculateDriveCapacityNT(INT nDrive)
{
    BOOL   fDriveExists;
    DWORD  dwDriveCapacity;
    DWORD  dwBytesReturned;
    TCHAR  szDrive[ MAX_PATH ];
    TCHAR  szDriveAssignment[ MAX_PATH ];

    dwDriveCapacity = 0;

    // Determine if Logical Drive Exists

    fDriveExists = FALSE;

    wsprintf( szDrive, TEXT("%c:"), TEXT('A') + ( nDrive - 1 ) );   // Create DOS Drive Identifier (A: or B:)

    dwBytesReturned = QueryDosDevice( szDrive, szDriveAssignment, MAX_PATH );

    if ( dwBytesReturned != 0 )
    {
        LPTSTR lpszWalkString;

        // DBCS-Enabled Terminate String At 2nd Backslash (1st Backslash always at Position 0)

        lpszWalkString = szDriveAssignment;

        do
        {
            lpszWalkString = CharNext( lpszWalkString );

            switch( *lpszWalkString )
            {
                case '\\':
                    *lpszWalkString = 0;
                    break;
            }
        }
        while( *lpszWalkString != 0 );

        // Determine if Logical Drive is Physically Present

        if ( lstrcmp( szDriveAssignment, TEXT("\\Device") ) == 0 )
        {
            fDriveExists = TRUE;
        }
    }

    if ( fDriveExists == TRUE )
    {
        // Get All Supported Media Types for Drive

        HANDLE hDevice;
        BOOL   fResult;

        wsprintf( szDrive, TEXT("\\\\.\\%c:"), TEXT('A') + ( nDrive - 1 ) ); // Create NT Drive Identifier (\\.\A: or \\.\B:)

        hDevice = CreateFile( szDrive, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );

        _ASSERT( hDevice != INVALID_HANDLE_VALUE );

        if ( hDevice != INVALID_HANDLE_VALUE )
        {
            DISK_GEOMETRY dGeometry[ 10 ];

            fResult = DeviceIoControl( hDevice, IOCTL_DISK_GET_MEDIA_TYPES, NULL, 0, (LPVOID)&dGeometry, sizeof( DISK_GEOMETRY ) * 10, &dwBytesReturned, NULL );

            _ASSERT( fResult );

            if ( fResult == TRUE )
            {
                // Calculate Maximum Media Size of Drive in Bytes if No Errors

                INT  nMediaCount;
                INT  nCurrentMedia;
                UINT uCurrentMediaCapacity;

                nMediaCount = dwBytesReturned / sizeof( DISK_GEOMETRY );

                for ( nCurrentMedia = 0; nCurrentMedia < nMediaCount; nCurrentMedia++ )
                {
                    uCurrentMediaCapacity  = (UINT)dGeometry[ nCurrentMedia ].Cylinders.LowPart;
                    uCurrentMediaCapacity *= (UINT)dGeometry[ nCurrentMedia ].TracksPerCylinder;
                    uCurrentMediaCapacity *= (UINT)dGeometry[ nCurrentMedia ].SectorsPerTrack;
                    uCurrentMediaCapacity *= (UINT)dGeometry[ nCurrentMedia ].BytesPerSector;

                    if ( uCurrentMediaCapacity > dwDriveCapacity )
                    {
                        dwDriveCapacity = uCurrentMediaCapacity;
                    }
                }
            }

            CloseHandle( hDevice );
        }
    }

    dwDriveCapacity /= ( 1024 * 100 );

    return( dwDriveCapacity );
}
#endif

VOID CHardware::SetVideoBIOSDigit()
{
    DWORD dwVideoBIOSChecksum;

#if defined(WIN32) || defined(_WIN32)
    if ( IsPlatformNT() )
    {
        dwVideoBIOSChecksum  = CalculateRegKeyChecksum( "VideoBiosDate" );
        dwVideoBIOSChecksum += CalculateRegKeyChecksum( "VideoBiosVersion" );

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        m_dwVideoBiosCrc32 = dwVideoBIOSChecksum;
#endif

    } else
#endif
    {

        LPBYTE pbMemoryByte;

#if defined(WIN32) || defined(_WIN32)
        pbMemoryByte = (LPBYTE)0xC0000;
#else
        pbMemoryByte = (LPBYTE)MAKELONG(0, &_C000H);
#endif
        dwVideoBIOSChecksum = CalculateMemoryRegionChecksum(pbMemoryByte, 2048);

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        m_dwVideoBiosCrc32 = CRC_32(pbMemoryByte, 2048);
#endif

    }

    m_szHardwareID[ VIDEO_BIOS_DIGIT ] = (CHAR)( dwVideoBIOSChecksum % 9 ) + '0';
}

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////

VOID CHardware::CalculateHardwareGUID()
{
    ULONG   uCRC;
    INT     nIndex;
    CHAR    szCRCTemp[ 20 ];

    // Create Empty Template for GUID

    lstrcpyA( m_szHardwareGUID, "{30303030-30DA-0000-0000-0020AFC36E79}" );

    // Add ASCII HWID to GUID

    for ( nIndex = 0; nIndex < lstrlenA( m_szHardwareID ); nIndex++ )
    {
        switch( nIndex )
        {
            case 0:
            case 1:
            case 2:
            case 3:
                m_szHardwareGUID[ 2 + ( nIndex * 2 ) ] = m_szHardwareID[ nIndex ];
                break;

            case 4:
                m_szHardwareGUID[ 11 ] = m_szHardwareID[ nIndex ];
                break;

            default:
                _ASSERT( FALSE );
                break;
        }
    }

    // Calculate GUID CRC

    CCrc32 crc32;

    _ASSERT( crc32.uClassID == CCRC32_CLASSID );

    uCRC = crc32.CalculateBlockCRC( m_szHardwareGUID, lstrlenA( m_szHardwareGUID ) );

    // Add CRC Result To GUID

    wsprintf( szCRCTemp, "%08X", uCRC );

    for ( nIndex = 0; nIndex < lstrlenA( szCRCTemp ); nIndex++ )
    {
        switch( nIndex )
        {
            case 0:
            case 1:
            case 2:
            case 3:
                m_szHardwareGUID[ 15 + nIndex ] = szCRCTemp[ nIndex ];
                break;

            case 4:
            case 5:
            case 6:
            case 7:
                m_szHardwareGUID[ 16 + nIndex ] = szCRCTemp[ nIndex ];
                break;

            default:
                _ASSERT( FALSE );
                break;
        }
    }
}
#endif ////////////////////////////////////////////////////////////////////////


#if 0 /////////////////////////////////////////////////////////////////////////

// Test main() function

int PASCAL WinMain(
    HINSTANCE, // hInstance,  // handle to current instance
    HINSTANCE, // hPrevInstance,  // handle to previous instance
    LPSTR, // lpCmdLine,      // pointer to command line
    int // nCmdShow          // show state of window)
)
{

    CHardware hwid;

    MessageBox(
        NULL,
        (char *)hwid.GetGUID(),
        (char *)hwid.GetID(),
        MB_OK);

    return 0;
}

#endif ////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\main.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    main.cpp

Abstract:

--*/

#include <windows.h>

#include "pidgen.h"

#if !defined(WIN32) && !defined(_WIN32)
#include <string.h>
#endif // !defined(WIN32) && !defined(_WIN32)

#if TESTING_CODE
#include <stdio.h>
#endif

HINSTANCE g_hinst = NULL;

#if defined(WIN32) || defined(_WIN32)
//int main()
//{
//
//    return(0);
//}


BOOL WINAPI DllMain(
    HANDLE hinst,
    ULONG ulReason,
    LPVOID lpReserved)
{

    if (DLL_PROCESS_ATTACH == ulReason)
    {
        g_hinst = (HINSTANCE)hinst;
    }

    return TRUE;
}

#else

extern "C" int STDAPICALLTYPE LibMain(
    HINSTANCE hinst,
    WORD   wDataSeg,
    WORD   cbHeapSize,
    LPSTR  lpszCmdLine)
{
    //  Perform DLL initialization.

    g_hinst = hinst;

    if (cbHeapSize != 0)    // DLL data seg is MOVEABLE
    {
        UnlockData(0);
    }

    return 1;               // return success
}


extern "C" int STDAPICALLTYPE WEP(int nParameter)
{

    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\crcmodel.h ===
/****************************************************************************/
/*							   Start of crcmodel.h							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the header (.h) file for the reference 			*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* How to Use This Package													*/
/* -----------------------													*/
/* Step 1: Declare a variable of type cm_t. Declare another variable		*/
/*		   (p_cm say) of type p_cm_t and initialize it to point to the first*/
/*		   variable (e.g. p_cm_t p_cm = &cm_t). 							*/
/*																			*/
/* Step 2: Assign values to the parameter fields of the structure.			*/
/*		   If you don't know what to assign, see the document cited earlier.*/
/*		   For example: 													*/
/*			  p_cm->cm_width = 16;											*/
/*			  p_cm->cm_poly  = 0x8005L; 									*/
/*			  p_cm->cm_init  = 0L;											*/
/*			  p_cm->cm_refin = TRUE;										*/
/*			  p_cm->cm_refot = TRUE;										*/
/*			  p_cm->cm_xorot = 0L;											*/
/*		   Note: Poly is specified without its top bit (18005 becomes 8005).*/
/*		   Note: Width is one bit less than the raw poly width. 			*/
/*																			*/
/* Step 3: Initialize the instance with a call cm_ini(p_cm);				*/
/*																			*/
/* Step 4: Process zero or more message bytes by placing zero or more		*/
/*		   successive calls to cm_nxt. Example: cm_nxt(p_cm,ch);			*/
/*																			*/
/* Step 5: Extract the CRC value at any time by calling crc = cm_crc(p_cm); */
/*		   If the CRC is a 16-bit value, it will be in the bottom 16 bits.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Design Notes 															*/
/* ------------ 															*/
/* PORTABILITY: This package has been coded very conservatively so that 	*/
/* it will run on as many machines as possible. For example, all external	*/
/* identifiers have been restricted to 6 characters and all internal ones to*/
/* 8 characters. The prefix cm (for Crc Model) is used as an attempt to 	*/
/* avoid namespace collisions. This package is endian independent.			*/
/*																			*/
/* EFFICIENCY: This package (and its interface) is not designed for 		*/
/* speed. The purpose of this package is to act as a well-defined reference */
/* model for the specification of CRC algorithms. If you want speed, cook up*/
/* a specific table-driven implementation as described in the document cited*/
/* above. This package is designed for validation only; if you have found or*/
/* implemented a CRC algorithm and wish to describe it as a set of para-	*/
/* meters to the Rocksoft^tm Model CRC Algorithm, your CRC algorithm imple- */
/* mentation should behave identically to this package under those para-	*/
/* meters.																	*/
/*																			*/
/****************************************************************************/

/* The following #ifndef encloses this entire */
/* header file, rendering it idempotent.	 */

#ifndef CM_DONE
#define CM_DONE

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* The following definitions are extracted from my style header file which	*/
/* would be cumbersome to distribute with this package. The DONE_STYLE is	*/
/* the idempotence symbol used in my style header file. 					*/

#ifndef DONE_STYLE

typedef unsigned long	ulong;
typedef unsigned		ubool;
typedef unsigned char * p_ubyte_;

#ifndef TRUE
#define FALSE 0
#define TRUE  1
#endif

/* Uncomment this definition if you don't have void. */
/* typedef int void; */

#endif

/****************************************************************************/
/* CRC Model Abstract Type													*/
/* -----------------------													*/
/* The following type stores the context of an executing instance of the	*/
/* model algorithm. Most of the fields are model parameters which must be	*/
/* set before the first initializing call to cm_ini.						*/

typedef struct
  {
   int	 cm_width;	 /* Parameter: Width in bits [8,32].	   */
   ulong cm_poly;	 /* Parameter: The algorithm's polynomial. */
   ulong cm_init;	 /* Parameter: Initial register value.	   */
   ubool cm_refin;	 /* Parameter: Reflect input bytes? 	   */
   ubool cm_refot;	 /* Parameter: Reflect output CRC?		   */
   ulong cm_xorot;	 /* Parameter: XOR this to output CRC.	   */

   ulong cm_reg;	 /* Context: Context during execution.	   */
  } cm_t;
typedef cm_t *p_cm_t;

/****************************************************************************/
/* Functions That Implement The Model										*/
/* ----------------------------------										*/
/* The following functions animate the cm_t abstraction.					*/

void cm_ini(p_cm_t p_cm);

/* Initializes the argument CRC model instance. 		 */
/* All parameter fields must be set before calling this. */

void cm_nxt(p_cm_t p_cm, int ch);

/* Processes a single message byte [0,255]. */

void cm_blk(p_cm_t p_cm, p_ubyte_ blk_adr, ulong blk_len);

/* Processes a block of message bytes. */

ulong cm_crc(p_cm_t p_cm);

/* Returns the CRC value for the message bytes processed so far. */

/****************************************************************************/
/* Functions For Table Calculation											*/
/* -------------------------------											*/
/* The following function can be used to calculate a CRC lookup table.		*/
/* It can also be used at run-time to create or check static tables.		*/

ulong cm_tab(p_cm_t p_cm, int index);

/* Returns the i'th entry for the lookup table for the specified algorithm. */
/* The function examines the fields cm_width, cm_poly, cm_refin, and the	*/
/* argument table index in the range [0,255] and returns the table entry in */
/* the bottom cm_width bytes of the return value. */

/****************************************************************************/
/* End of the header file idempotence #ifndef								*/

#ifdef __cplusplus
}
#endif

#endif

/****************************************************************************/
/*							   End of crcmodel.h							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\crtstubs.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    CRTStubs.cpp

Abstract:

--*/

#include <windows.h>

#include <stdlib.h>

#if 0
//=--------------------------------------------------------------------------=
// CRT stubs
//=--------------------------------------------------------------------------=
// these two things are here so the CRTs aren't needed. this is good.
//
// basically, the CRTs define this to get in a bunch of stuff.  we'll just
// define them here so we don't get an unresolved external.
//
// TODO: if you are going to use the CRTs, then remove this line.
//
extern "C" int _fltused = 1;

extern "C" int _cdecl _purecall(void)
{
//  FAIL("Pure virtual function called.");
  return 0;
}

void * _cdecl operator new
(
    size_t    size
)
{
    return HeapAlloc(GetProcessHeap(), 0, size);
}


//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{
    HeapFree(GetProcessHeap(), 0, ptr);
}

#ifndef _X86_
extern "C" void _fpmath() {}
#endif

#ifndef _DEBUG

void * _cdecl malloc(size_t n)
{
#ifdef _MALLOC_ZEROINIT
        void* p = HeapAlloc(g_hHeap, 0, n);
        if (p != NULL)
                ZeroMemory(p, n);
        return p;
#else
        return HeapAlloc(GetProcessHeap(), 0, n);
#endif
}

void * _cdecl calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
        return malloc(n * s);
#else
        void* p = malloc(n * s);
        if (p != NULL)
                ZeroMemory(p, n * s);
        return p;
#endif
}

void* _cdecl realloc(void* p, size_t n)
{
        if (p == NULL)
                return malloc(n);

        return HeapReAlloc(GetProcessHeap(), 0, p, n);
}

void _cdecl free(void* p)
{
        if (p == NULL)
                return;

        HeapFree(GetProcessHeap(), 0, p);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\pidgen.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    pidgen.cpp

Abstract:

   contains PIDGen entrypoint to pidgen dll

--*/

//  v-jhark 07-26-99 added support for OEM RPC/MPC:
//      for OEM if lstrRpc is not NULL, it's used as the first
//      5 characters fo the PID (replacing the Julian Date)
//

// PIDGen.cpp

#define WINDOWS_LEAN_AND_MEAN  // faster compile

#include <windows.h>

#if defined(WIN32) || defined(_WIN32)

#include <tchar.h>
#include "hardware.h"

#else

#include <stdlib.h>
#include <time.h>
#include <dos.h>

#include "..\..\inc\tchar.h"

extern "C" extern WORD _C000H;
extern "C" extern WORD _F000H;

#endif

#include "..\inc\DigPid.h"
#include "..\inc\shortsig.h"

#include "pidgen.h"
#include "util.h"

#include "crc-32.h"

#if TESTING_CODE
#include <stdio.h>
#endif

#include "range.h"

#define MIN(a,b) (((a)<=(b))?(a):(b))

typedef struct {
    DWORD       dwKeyIdx;
    BYTE        abPublicKey[1];
} BINKEY, *PBINKEY, FAR *LPBINKEY;


// returns the count of ch characters in pstr

int StrCountCharA(char *pstr, char ch)
{
   int iCnt = 0;

   while ('\0' != *pstr)
   {
       if (ch == *pstr)
       {
           ++iCnt;
       }
       ++pstr;
   }

   return iCnt;
}

#if defined(WIN32) || defined(_WIN32)

int StrCountCharW(LPWSTR pstr, WCHAR ch)
{
   int iCnt = 0;

   while (L'\0' != *pstr)
   {
       if (ch == *pstr)
       {
           ++iCnt;
       }
       ++pstr;
   }

   return iCnt;
}

#endif // defined(WIN32) || defined(_WIN32)

#if defined(UNICODE) || defined(_UNICODE)
    #define StrCountChar StrCountCharW
#else
    #define StrCountChar StrCountCharA
#endif


// DecodeProdKey is given a string of encoded chars and returns the
// 31-bit data payload or INVALID_PID if there is an error or failure
// to validate.

DWORD DecodeProdKey(
    LPSTR   lpstrEncodedChars,  // ptr to 25-character secure CD-Key
    LPBYTE  pbPublicKey,        // pointer to the public key
    LONG    cbPublicKey,        // size of the public key in bytes
    LPSTR   lpstrDigits,        // custom achDigits array
    LPBYTE  pbBinCdKey,         // if non-NULL return binary version of secure CD-Key
    int     cbBinCdKey)
{
    BOOL fOk = TRUE;
    DWORD dwBinData = INVALID_PID;

    const int iBase = 24;

    // 64 bytes is enough space to decode 111 encoded characters (when iBase is 24)
    BYTE abDecodedBytes[64] = {0};
    int iDecodedBytes;        // index
    int iDecodedBytesMax = 0; // index of highest byte used

    const int iDecodedPidBitCnt = 31;
    BYTE abDecodedPid[iDecodedPidBitCnt/8 + (0 != iDecodedPidBitCnt/8)] = {0};

    // Number of bits that can be encoded in 1000 base 24 digits
    // 1000 * log(24, 2)
    const int iBitsPerKChar = 4585;

    char achDigits[iBase+1] = "BCDFGHJKMPQRTVWXY2346789";
    int  iDigits;  // index

    int iBitCnt = (int)(((long)(lstrlenA(lpstrEncodedChars) - StrCountCharA(lpstrEncodedChars, '-') ) * iBitsPerKChar) / 1000);
    int iByteCnt = iBitCnt/8 + (0 != iBitCnt%8);

    int iSigBitCnt = iBitCnt - iDecodedPidBitCnt;
    int iSigByteCnt = iSigBitCnt/8 + (0 != iSigBitCnt%8);

    if (NULL == lpstrDigits)
    {
        lpstrDigits = achDigits;
    }
    else
    {
        fOk = (lstrlenA(achDigits) == lstrlenA(lpstrDigits));
        if (fOk)
        {
            StrUpperA(lpstrDigits);
        }
    }

    // We requie at least 25 input characters to leave enough bits for the signature
    // and we make sure we're not going to overrun our buffer

    if (fOk && 25 <= lstrlenA(lpstrEncodedChars) && iByteCnt < sizeof(abDecodedBytes))
    {
        StrUpperA(lpstrEncodedChars);

        // first we fill abDecodedBytes with the binary data

        LPCSTR lpstrEncodedCharsCurr = lpstrEncodedChars;
        char chCurEncoded = *lpstrEncodedCharsCurr;

        while (fOk && TEXT('\0') != chCurEncoded)
        {
            // find the character in the list

            if ('-' != chCurEncoded) // we skip any dashes in the input string
            {

                iDigits = 0;

                while (lpstrDigits[iDigits] != chCurEncoded && TEXT('\0') != lpstrDigits[iDigits])
                {
                    ++iDigits;
                }

                if (TEXT('\0') == lpstrDigits[iDigits])
                {
                    fOk = FALSE;
                }
                else
                {
                    iDecodedBytes = 0;
                    unsigned int i = (unsigned int)iDigits;
                    while (iDecodedBytes <= iDecodedBytesMax)
                    {
                        i += iBase * abDecodedBytes[iDecodedBytes];
                        abDecodedBytes[iDecodedBytes] = (unsigned char)i;
                        i /= 256;
                        ++iDecodedBytes;
                    }
                    if (i != 0)
                    {

                        if (iDecodedBytes < sizeof(abDecodedBytes))
                        {
                            abDecodedBytes[iDecodedBytes] = (unsigned char)i;
                            iDecodedBytesMax = iDecodedBytes;
                        }
                        else
                        {
                            // How'd we get here?  Didn't we check the byte length
                            // before we started the outer loop?  We did check *A*
                            // byte length, but it was based on the maximum number
                            // of full bits that could be encoded in riEncodedChars
                            // (given it's length and iByteCnt) but not all values of
                            // riEncodedChars will fit into that many bits. What we
                            // have here is an invalid value

                            fOk = FALSE;
                        }
                    }
                }
            }
            ++lpstrEncodedCharsCurr;
            chCurEncoded = *lpstrEncodedCharsCurr;
        }

        if (fOk)
        {
            // at this point abDecodedBytes is filled with the binary data

            // if the caller wants it, return the binary representation
            if (NULL != pbBinCdKey && 0 < cbBinCdKey)
            {
                ZeroMemory(pbBinCdKey, cbBinCdKey);
                CopyMemory(pbBinCdKey, abDecodedBytes, MIN((int)cbBinCdKey, sizeof(abDecodedBytes)));
            }

            // separate the 31 bit pid that is sitting in the low 31 bits

            abDecodedPid[0] = abDecodedBytes[0];
            abDecodedPid[1] = abDecodedBytes[1];
            abDecodedPid[2] = abDecodedBytes[2];
            abDecodedPid[3] = abDecodedBytes[3] & 0x7F;

            // shift the signature down 31 bits in abDecodedBytes
            int iDecodedBytesMaxOld = iDecodedBytesMax;
            iDecodedBytesMax -= 3;
            if (iDecodedBytesMax < 0)
            {
                iDecodedBytesMax = 0;
            }

            iDecodedBytes = 0;
            while (iDecodedBytes <= iDecodedBytesMax)
            {
                abDecodedBytes[iDecodedBytes] = (unsigned char)
                    ((abDecodedBytes[iDecodedBytes+3] >> 7) |
                    (abDecodedBytes[iDecodedBytes+4] << 1));

                ++iDecodedBytes;
            }

            while (iDecodedBytes <= iDecodedBytesMaxOld)
            {
                abDecodedBytes[iDecodedBytes] = 0;
                ++iDecodedBytes;
            }

            if (0 == abDecodedBytes[iDecodedBytesMax] && 0 < iDecodedBytesMax)
            {
                --iDecodedBytesMax;
            }

            LONG cbPrivate = 0;
            LONG cbPublic = 0;

            fOk = SS_OK == CryptGetKeyLens(
                iSigBitCnt,    // [IN] count of bits in Sig
                &cbPrivate,    // [OUT] ptr to number of bytes in the private key
                &cbPublic);    // [OUT] ptr to number of bytes in the public key

            fOk = fOk && (cbPublic == cbPublicKey);

            fOk = fOk && (SS_OK == CryptVerifySig(
                sizeof(abDecodedPid),   // [IN] number of bytes in message
                abDecodedPid,           // [IN] binary message to sign
                cbPublicKey,            // [IN] number of bytes in public key (from CryptGetKeyLens)
                pbPublicKey,            // [IN] the generated public key (from CryptKeyGen)
                iSigBitCnt,             // [IN] the number of bits in the sig
                abDecodedBytes));       // [IN] the digital signature (from CryptSign)
        }
        if (fOk)
        {
            // verified the signature.  Now we need to return the binary sequence.

            // the following line provides immunity from byte order
            dwBinData =
                (DWORD)abDecodedPid[0] * 0x00000001 +
                (DWORD)abDecodedPid[1] * 0x00000100 +
                (DWORD)abDecodedPid[2] * 0x00010000 +
                (DWORD)abDecodedPid[3] * 0x01000000;

            dwBinData &= 0x7fffffff;
        }
    }

    return dwBinData;
}

// Check site code exclusion list to see if this seq is excluded
// Users can define ranges as well to exclude the keys from valid key ranges
typedef struct {
        DWORD dwSeqStart;
        DWORD dwSeqEnd;
} BLOCK_SEQ_RANGE;

static BOOL IsSeqExcluded(DWORD dwSeq)
{
   BLOCK_SEQ_RANGE aExclusionList[]={
           {640200176,640200176},  // Mexico VL key
           {640000035,640000035},  // Intel VL Key
#ifdef WINXP_SPx_RTM
           {  2000000,  3999999},  // XPSP Beta Product keys
#endif //WINXP_SPx_RTM
   };

    // check for excluded site codes
    // Now there are two types of number on the exclusion list:
    //
    // 1. Numbers less than 1000 (three digit (or less) numbers) are
    // considered site codes and are matched to the first three
    // digits of the 9 digit sequence number.
    //
    // 2. Numbers greater then or equal to 1000 are considered
    // sequence numbers and are matched against the full 9 digit
    // sequence number.
    BOOL fExcluded = FALSE;

    DWORD dwSeq1 = dwSeq / 1000000; // ChannelID, a.k.a. Site Code
    DWORD dwEsclCount = sizeof(aExclusionList)/sizeof(aExclusionList[0]);
    
    while (!fExcluded && dwEsclCount)
    {
        --dwEsclCount;
        if (1000 > aExclusionList[dwEsclCount].dwSeqStart)
        {
                //sitecode (channelID) exclusion
                if (dwSeq1 >= aExclusionList[dwEsclCount].dwSeqStart && dwSeq1 <= aExclusionList[dwEsclCount].dwSeqEnd)
                        fExcluded = TRUE;
        }
        else
        {
                // channelID+seq# exclusion
                if (dwSeq >= aExclusionList[dwEsclCount].dwSeqStart && dwSeq <= aExclusionList[dwEsclCount].dwSeqEnd)
                        fExcluded = TRUE;
        }                            
    }
    return fExcluded;
}


extern "C" DWORD STDAPICALLTYPE PIDGenRc(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrRpc,           // [IN] 5-character Release Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPSTR   lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE  lpbPublicKey,       // [IN] pointer to optional public key or NULL
    DWORD   dwcbPublicKey,      // [IN] byte length of optional public key
    DWORD   dwKeyIdx,           // [IN] key pair index optional public key
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to binary PID3 buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS)              // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)
{
    DWORD dwRet = pgeSuccess;
    LPDIGITALPID pdpid = (LPDIGITALPID)lpbPid3;

    BYTE abBinCdKey[sizeof(pdpid->abCdKey)] = {0};

    if (NULL == lpstrSecureCdKey)
    {
        dwRet = pgeProductKeyNull;
    }
    else if (25 != lstrlenA(lpstrSecureCdKey) - StrCountCharA(lpstrSecureCdKey, '-'))
    {
        dwRet = pgeProductKeyBadLen;
    }
    else if (NULL == lpstrSku)
    {
        dwRet = pgeSkuNull;
    }
    else if (sizeof(pdpid->szSku) <= lstrlenA(lpstrSku))
    {
        dwRet = pgeSkuBadLen;
    }
    else if (NULL == lpstrPid2)
    {
        dwRet = pgePid2Null;
    }
    else if (NULL == pdpid)
    {
        dwRet = pgeDigPidNull;
    }
    else if (pdpid->dwLength < sizeof(DIGITALPID))
    {
        dwRet = pgeDigPidBadLen;
    }
    else if (!fOem && NULL == lpstrRpc)
    {
        dwRet = pgeMpcNull;
    }
    else if (NULL != lpstrRpc && 5 != lstrlenA(lpstrRpc))
    {
        dwRet = pgeMpcBadLen;
    }
    else if (NULL != lpstrOemId && 0 != lstrlenA(lpstrOemId) && 4 != lstrlenA(lpstrOemId))
    {
        dwRet = pgeOemIdBadLen;
    }
    else if (NULL != lpstrLocal24 && 0 != lstrlenA(lpstrLocal24) && 24 != lstrlenA(lpstrLocal24))
    {
        dwRet = pgeLocalBad;
    }
    else
    {
        DWORD dwBinData = INVALID_PID;
        BOOL  fExcluded = FALSE;
        int   iBink = fOem ? 2 : 1;

        HRSRC hrsrcBink = NULL;
        HGLOBAL hresBink = NULL;
        LPBINKEY lpbink = NULL;

        if (NULL != lpbPublicKey)
        {
            dwBinData = DecodeProdKey(
                lpstrSecureCdKey,
                lpbPublicKey,
                dwcbPublicKey,
                lpstrLocal24,
                abBinCdKey,
                sizeof(abBinCdKey));
        }
        else
        {
            // use default public keys
            lpbink = (LPBINKEY)-1;
            for (
                iBink = fOem ? 2 : 1;
                INVALID_PID == dwBinData && NULL != lpbink;
                iBink +=2)
            {
                lpbink = NULL;
                hresBink = NULL;

                hrsrcBink = FindResource(g_hinst, MAKEINTRESOURCE(iBink), TEXT("BINK"));

                if (NULL != hrsrcBink)
                {
                    hresBink = LoadResource(g_hinst, hrsrcBink);
                }

                if (NULL != hresBink)
                {
                    lpbink = (LPBINKEY)LockResource(hresBink);

                    if (NULL != lpbink)
                    {
                        dwKeyIdx = lpbink->dwKeyIdx;
                        lpbPublicKey = lpbink->abPublicKey;
                        dwcbPublicKey = *(LPDWORD)lpbPublicKey;

                        dwBinData = DecodeProdKey(
                            lpstrSecureCdKey,
                            lpbPublicKey,
                            dwcbPublicKey, // byte count of lpbPublicKey
                            lpstrLocal24,
                            abBinCdKey,
                            sizeof(abBinCdKey));

                        UnlockResource(hresBink);
                    }
                    FreeResource(hresBink);
                }
            }
        }

        if (INVALID_PID == dwBinData)
        {
            dwRet = pgeProductKeyInvalid;
        }
        else
        {
            BOOL fCCP = (0 != (dwBinData & 1));
            DWORD dwSeq = dwBinData / 2; // warning: byte order dependent
            DWORD_PTR dwSeq1;
            DWORD dwSeq2;
            char szRand[5+1];

            if (NULL != pfCCP)
            {
                *pfCCP = fCCP;
            }

            if (NULL != lpdwSeq)
            {
                *lpdwSeq = dwSeq;
            }

            if (NULL != pfPSS)
            {
                // Note: this range is different that what shipped
                // with Win98, it's shifted by one.  The old range
                // was (100000 < dwSeq && dwSeq <= 1000000)

                *pfPSS = (100000 <= dwSeq && dwSeq < 1000000);
            }

            ZeroMemory( pdpid, sizeof(*pdpid) );
            pdpid->dwLength = sizeof(*pdpid);

            // version 3.0
            pdpid->wVersionMajor = 3;
            pdpid->wVersionMinor = 0;

            // v-jhark 02-04-97 This is how other software (acme setup and
            // Darwin (msi)) generates random digits for the PID.  It's not
            // the best random number because there may be some clustering
            // of values, but for our purposes this is acceptable.

            pdpid->dwRandom = GetTickCount();

            DWORD dwYear; // last two digits of year
            DWORD dwJday; // day of the year 1 - 366

#if defined(WIN32) || defined(_WIN32)
            {
                SYSTEMTIME st = {0};
                DWORDLONG dwlTime = 0;

                GetLocalTime(&st);
                SystemTimeToFileTime(&st, (LPFILETIME )&dwlTime);

                pdpid->dwTime = FileTimeToTimet((LPFILETIME)&dwlTime);

                if (st.wYear < 1998)
                {
                    dwYear = 98;
                    dwJday = 1;
                }
                else
                {
                    dwYear = st.wYear % 100;
                    dwJday = GetJulianDate(&st);
                }
            }
#else
            {
                time_t lTime = time(NULL);

                pdpid->dwTime = (DWORD) lTime;
                struct tm tmNow = {0};

                struct tm *ptmNow = localtime(&lTime);

                if (NULL != ptmNow)
                {
                    tmNow = *ptmNow;
                }

                if (tmNow.tm_year < 98)
                {
                    dwYear = 98;
                    dwJday = 1;
                }
                else
                {
                    dwYear = tmNow.tm_year % 100;
                    dwJday = tmNow.tm_yday + 1;
                }
            }

#endif // defined(WIN32) || defined(_WIN32)

            if (fOem)
            {
                fExcluded = IsSeqExcluded(dwSeq);
                if (fExcluded)
                {
                    dwRet = pgeProductKeyExcluded;
                }
                else
                {
					pdpid->dwlt = ltOEM;

					dwSeq1 = dwSeq / 100000;
					dwSeq2 = dwSeq % 100000;

					dwSeq1 = AddCheckDigit((DWORD)dwSeq1);

					if (NULL == lpstrRpc)
					{
						wsprintfA(
							lpstrPid2,
							"%05.5ld-OEM-%07.7ld-%05.5ld",
							(LONG)(dwJday * 100 + dwYear % 100),
							(LONG)dwSeq1,
							(LONG)dwSeq2);
					}
					else
					{
						wsprintfA(
							lpstrPid2,
							"%s-OEM-%07.7ld-%05.5ld",
							lpstrRpc,
							(LONG)dwSeq1,
							(LONG)dwSeq2);
					}
                } // if (fExcluded)
            } // if (OEM)
            else
            {
                pdpid->dwlt = (fCCP) ? ltCCP : ltFPP;

                HRSRC hrsrcEscl = NULL;
                HGLOBAL hresEscl = NULL; // Excluded Site Code List
                LPDWORD pdwEscl;

                dwSeq1 = dwSeq / 1000000;
                dwSeq2 = dwSeq % 1000000;

                // check for excluded site codes
                // ESCL is Excluded Site Code List

                fExcluded = IsSeqExcluded(dwSeq);

                if (fExcluded)
                {
                    dwRet = pgeProductKeyExcluded;
                }
                else
                {
                    // check for special site codes

                    // v-jhark 12-10-98
                    //
                    // The PID group (v-jhark reports to manishac reports to richb)
                    // has a reserved block of 10 Site Codes, 980 to 989, which has
                    // been assigned as follows:
                    //
                    //     980 - Special IE 'all random', randomizes site code
                    //     981 - Random for Trial Programs
                    //     982 - Random, reserved for future use as of 12-10-98
                    //     983 - Random, reserved for future use as of 12-10-98
                    //     984 - IE ICP (Internet Content Provider)? 12-10-98
                    //     985 - reserved for future use as of 12-10-98
                    //     986 - reserved for future use as of 12-10-98
                    //     987 - reserved for future use as of 12-10-98
                    //     988 - reserved for future use as of 12-10-98
                    //     989 - reserved for future use as of 12-10-98
                    //
                    // History:
                    //     04-12-99 Revoked: 981 - Random for SBS (Small Business Server)
                    //
                    //

                    if (270 == dwSeq1 || // Select
                        335 == dwSeq1 || // MSDN
                        981 == dwSeq1 || // Trial Programs 04-12-99
                        982 == dwSeq1 || // reserved for future use as of 07-09-98
                        983 == dwSeq1 || // reserved for future use as of 07-09-98
                        980 == dwSeq1 || // IE's "all random" (including site code)
                        460000000 == dwSeq) // special beta code only for this site and seq
                    {
                        // randomize dwSeq2

                        dwSeq2 = 0x7fffffff & pdpid->dwTime;
                        dwSeq2 %= 1000000;    // we only want the last six digits

                        if (270 == dwSeq1)
                        {
                            pdpid->dwlt = ltSelect;
                        }
                        else if (335 == dwSeq1)
                        {
                            pdpid->dwlt = ltMSDN;
                        }
                        else if (980 == dwSeq1)
                        {
                            // Randomize even the PID 2.0's site code
                            // (this is used free downloads like IE, etc.)

                            // each row of the following table contains:
                            //     range start - first site included in range
                            //     range end   - last site included in range
                            //     sum         - place holder for calculated running
                            //                   total of number of site codes
                            //                   including current line
                            //
                            // there must be at least one valid site code in the table
                            // or the randomization is skipped

                            static short aasSiteRanges[][3] = {

                            // These first three groups are reserved for mfg.
                            //
                            //  {  5, 194, 0},
                            //  {200, 235, 0},
                            //  {241, 251, 0},

                                {255, 268, 0},
                                {271, 286, 0},
                                {311, 317, 0},
                                {320, 320, 0},
                                {325, 325, 0},
                                {339, 359, 0},
                                {361, 364, 0},
                                {396, 412, 0},
                                {414, 424, 0},
                                {426, 428, 0},
                                {430, 435, 0},
                                {437, 441, 0},
                                {443, 443, 0},
                                {445, 446, 0},
                                {448, 459, 0},
                                {461, 468, 0},
                                {510, 521, 0},
                                {543, 545, 0},
                                {550, 550, 0},
                                {574, 576, 0},
                                {578, 586, 0},
                                {589, 589, 0},
                                {805, 853, 0},
                                {948, 953, 0}
                            };

                            #if TESTING_CODE
                            FILE *pfLog;

                            pfLog = fopen("TEST.LOG", "w");

                            for (int iSR = 0; iSR < ARRAY_SIZE(aasSiteRanges); ++iSR)
                            {
                                for (
                                    int iSite = aasSiteRanges[iSR][0];
                                    iSite <= aasSiteRanges[iSR][1];
                                    ++iSite)
                                {
                                    fprintf(pfLog, "%.3d\n", (int)iSite);
                                }
                            }
                            fprintf(pfLog,"\n");

                            for (int iTest = 0; iTest < 50000; ++iTest)
                            {
                            #endif 


                            // randomize site code
                            DWORD_PTR dwSeq1Rand = 0;

#if defined(WIN32) || defined(_WIN32)

                            LARGE_INTEGER liCount;

                            if (QueryPerformanceCounter(&liCount))
                            {
                                dwSeq1Rand = liCount.LowPart;
                            }
                            else
                            {
                                // QueryPerformanceCounter failed for some reason
                                // use GlobalMemoryStatus as a backup random source
                                MEMORYSTATUS mst = {sizeof(mst)};

                                GlobalMemoryStatus(&mst);

                                // all we want is a random number
                                dwSeq1Rand =
                                    mst.dwMemoryLoad ^      // percent of memory in use
                                    mst.dwTotalPhys ^       // bytes of physical memory
                                    mst.dwAvailPhys ^       // free physical memory bytes
                                    mst.dwTotalPageFile ^   // bytes of paging file
                                    mst.dwAvailPageFile ^   // free bytes of paging file
                                    mst.dwTotalVirtual ^    // user bytes of address space
                                    mst.dwAvailVirtual;     // free user bytes
                            }

#else

                            // all we want is a random number

                            // first get the VolumeSerialNumber

                            #pragma pack(1)
                               // Media ID
                               typedef struct {
                                   WORD   wInfoLevel;
                                   DWORD  dwSerialNum;
                                   char   achVolLabel[11];
                                   BYTE   abFileSysType[8];
                               } MID, *PMID, FAR* LPMID;
                            #pragma pack()

                            LPMID  pmid;
                            union  _REGS regs;
                            struct _SREGS segregs;
                            DWORD  dwMem;

                            dwMem = GlobalDosAlloc(sizeof(MID));

                            WORD wMidSelector = LOWORD(dwMem);
                            WORD wMidSegment = HIWORD(dwMem);

                            pmid = (LPMID)MAKELP(wMidSelector, 0);
                            memset(pmid, 0, sizeof(MID));

                        ////GetMediaID(3, wMidSelector);

                            memset(&regs, 0, sizeof(regs));
                            memset(&segregs, 0, sizeof(segregs));

                            regs.x.ax = 0x440d;  // DOS Function 440Dh - IOCTL for Block Device
                            regs.h.cl = 0x66;    // Minor Code 66h - Get Media ID
                            regs.h.ch = 0x08;    // Device category (must be 08h)
                            regs.x.bx = 3;       // Drive C:
                            regs.x.dx = 0;       // pmid offset

                            segregs.ds = wMidSelector; // wMidSegment;
                            segregs.es = wMidSelector; // wMidSegment;

                            _intdosx(&regs, &regs, &segregs);

                            BOOL fInfoSuccess = !regs.x.cflag;

                            DWORD dwVolumeSerialNumber = pmid->dwSerialNum;
                            GlobalDosFree(wMidSelector);

                            // now get the drive parameters

                            UINT    uNumberHeads;
                            UINT    uNumberTracks;
                            UINT    uSectorsPerTrack;

                            memset(&regs, 0, sizeof(regs));
                            memset(&segregs, 0, sizeof(segregs));

                            regs.h.ah = 0x08;       // BIOS Function 08h - Get drive parameters
                            regs.x.dx = 2; // 0 = A:, 1 = B:, 2 = C:

                            _int86x(
                                0x13, // BIOS Disk
                                &regs,
                                &regs,
                                &segregs);

                            BOOL fOk = (!regs.x.cflag);

                            if (fOk)
                            {
                                uNumberHeads = regs.h.dh + 1;
                                uNumberTracks = ((regs.h.cl & 0xC0) << 2) + regs.h.ch + 1;
                                uSectorsPerTrack = regs.h.cl & 0x3F;
                            }

                            // build up our random number from chaotic data

                            dwSeq1Rand =
                                GetTickCount() ^        // mSec system has been running
                                dwVolumeSerialNumber ^  // Volume Serial Number
                                uNumberHeads ^          // number of heads
                                uNumberTracks ^         // number of tracks
                                uSectorsPerTrack;       // Sectors per Track

#endif // defined(WIN32) || defined(_WIN32)

                            int i;
                            short sTotal = 0;

                            // Calculate the running total column
                            for (i = 0; i < ARRAY_SIZE(aasSiteRanges); ++i)
                            {
                                sTotal += 1 + aasSiteRanges[i][1] - aasSiteRanges[i][0];
                                aasSiteRanges[i][2] = sTotal;
                            }

                            // pick a random number within the table

                            if (0 < sTotal) // skip this if the table's empty
                            {
                                dwSeq1Rand %= sTotal;

                                // look up actual site code

                                short sTotalPrev = 0;

                                for (i = 0; aasSiteRanges[i][2] <= (short)dwSeq1Rand; ++i)
                                {
                                    sTotalPrev = aasSiteRanges[i][2];
                                }
                                dwSeq1 = aasSiteRanges[i][0] + dwSeq1Rand - sTotalPrev;

                                #if TESTING_CODE
                                fprintf(pfLog, "%.3d, %.3d\n", (int) dwSeq1Rand, (int)dwSeq1);
                                }
                                fclose(pfLog);
                                #endif 
                            }
                        }
                    }

                    dwSeq2 = AddCheckDigit(dwSeq2);

                    wsprintfA(
                        szRand,
                        "%02.2ld%03.3ld",
                        (LONG)(((dwKeyIdx/2)%100)),
                        (LONG)((pdpid->dwRandom/10)%1000L) );

                    wsprintfA(
                        lpstrPid2,
                        "%s-%03.3ld-%07.7ld-%s",
                        lpstrRpc,
                        (LONG)dwSeq1,
                        (LONG)dwSeq2,
                        szRand);
                }
            }

            if (pgeSuccess == dwRet)
            {
                lstrcpyA(pdpid->szPid2, lpstrPid2);

                pdpid->dwKeyIdx = dwKeyIdx;
                CopyMemory(pdpid->abCdKey, abBinCdKey, sizeof(pdpid->abCdKey));
                lstrcpyA(pdpid->szSku, lpstrSku);

                if (NULL != lpstrOemId)
                {
                    lstrcpyA(pdpid->szOemId, lpstrOemId);
                }

#if defined(WIN32) || defined(_WIN32)

                CHardware hwid;

                lstrcpyA(pdpid->aszHardwareIdStatic, hwid.GetID());

                pdpid->dwBiosChecksumStatic = hwid.GetBiosCrc32();
                pdpid->dwVolSerStatic = hwid.GetVolSer();
                pdpid->dwTotalRamStatic = hwid.GetTotalRamMegs();
                pdpid->dwVideoBiosChecksumStatic = hwid.GetVideoBiosCrc32();

#endif // defined(WIN32) || defined(_WIN32)

                pdpid->dwCrc32 = CRC_32((LPBYTE)pdpid, sizeof(*pdpid)-sizeof(pdpid->dwCrc32));

#if defined BUILD_PRO || defined BUILD_VOL || defined BUILD_EVAL
                if( !CheckSkuRange(fOem, dwSeq)) {
                    dwRet = pgeProductKeyExcluded;
                }
#endif
            }
        }
    }

    return dwRet;
}


extern "C" BOOL STDAPICALLTYPE PIDGenA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrRpc,           // [IN] 5-character Release Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPSTR   lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE  lpbPublicKey,       // [IN] pointer to optional public key or NULL
    DWORD   dwcbPublicKey,      // [IN] byte length of optional public key
    DWORD   dwKeyIdx,           // [IN] key pair index optional public key
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to binary PID3 buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS)              // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)
{
    DWORD dwRet;

    dwRet = PIDGenRc(
        lpstrSecureCdKey,
        lpstrRpc,
        lpstrSku,
        lpstrOemId,
        lpstrLocal24,
        lpbPublicKey,
        dwcbPublicKey,
        dwKeyIdx,
        fOem,

        lpstrPid2,
        lpbPid3,
        lpdwSeq,
        pfCCP,
        pfPSS);             // pfPSS,         'PSS Assigned' flag

    return pgeSuccess == dwRet;
}
                        

// Simplified interface to PidGen

extern "C" DWORD STDAPICALLTYPE PIDGenSimpA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrRpc,           // [IN] 5-character Release Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to binary PID3 buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP)              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
{
    DWORD dwRet;

    dwRet = PIDGenRc(
        lpstrSecureCdKey,
        lpstrRpc,
        lpstrSku,
        lpstrOemId,
        NULL,           // lpstrLocal24,  ordered set to use for decode base
        NULL,           // lpbPublicKey,  optional public key
        0,              // dwcbPublicKey, byte length of optional public key
        0,              // dwKeyIdx,      key pair index optional public key
        fOem,

        lpstrPid2,
        lpbPid3,
        lpdwSeq,
        pfCCP,
        NULL);          // pfPSS,         'PSS Assigned' flag

    return dwRet;
}


#if defined(WIN32) || defined(_WIN32)

// ISSUE:vijeshs:08/15/2000 move all error checks into PidGenRc

extern "C" BOOL STDAPICALLTYPE PIDGenW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrRpc,           // [IN] 5-character Release Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPWSTR  lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE lpbPublicKey,        // [IN] pointer to optional public key or NULL
    DWORD  dwcbPublicKey,       // [IN] byte length of optional public key
    DWORD  dwKeyIdx,            // [IN] key pair index optional public key
    BOOL   fOem,                // [IN] is this an OEM install?

    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to DigitalPID. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS)              // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)
{
    char SecureCdKey[25+4+1];
    char RpcCode[5+1];
    char Sku[32];
    char OemId[4+1];
    char Local24[24+1];
    char Pid20Buffer[24+1];
    BOOL rc;
    BOOL used = FALSE;

    // ISSUE:vijeshs:08/15/2000 enforce sizes

    if (!Pid20Buffer || !lpstrSecureCdKey || (!fOem && !lpstrRpc) || !lpstrSku) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!WideCharToMultiByte(CP_ACP,0,lpstrSecureCdKey,-1,SecureCdKey,sizeof(SecureCdKey),"z",&used) || used) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (NULL != lpstrRpc)
    {
        if (!WideCharToMultiByte(CP_ACP,0,lpstrRpc,-1,RpcCode,sizeof(RpcCode),"z",&used) || used) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    if (!WideCharToMultiByte(CP_ACP,0,lpstrSku,-1,Sku,sizeof(Sku),"z",&used) || used) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (lpstrOemId) {
        if (!WideCharToMultiByte(CP_ACP,0,lpstrOemId,-1,OemId,sizeof(OemId),"z",&used) || used) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    if (lpstrLocal24) {
        if (!WideCharToMultiByte(CP_ACP,0,lpstrLocal24,-1,Local24,sizeof(Local24),"z",&used) || used) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    }

    rc = PIDGenA(
        SecureCdKey,
        (NULL == lpstrRpc) ? NULL : RpcCode,
        Sku,
        lpstrOemId ? OemId : NULL,
        lpstrLocal24 ? Local24 : NULL,
        lpbPublicKey,
        dwcbPublicKey,
        dwKeyIdx,
        fOem,

        Pid20Buffer,
        lpbPid3,
        lpdwSeq,
        pfCCP,
        pfPSS);

    if (!rc) {
        *Pid20Buffer = (WCHAR)0;
    } else if (!MultiByteToWideChar( CP_ACP,0,Pid20Buffer,-1,lpstrPid2,25 )) {
        return FALSE;
    }

    return rc;
}

// Simplified interface to PidGen

extern "C" DWORD STDAPICALLTYPE PIDGenSimpW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrRpc,           // [IN] 5-character Release Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPWSTR  lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to binary PID3 buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP)              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
{
    DWORD dwRet;

    dwRet = PIDGenW(
        lpstrSecureCdKey,
        lpstrRpc,
        lpstrSku,
        lpstrOemId,
        NULL,           // lpstrLocal24,  ordered set to use for decode base
        NULL,           // lpbPublicKey,  optional public key
        0,              // dwcbPublicKey, byte length of optional public key
        0,              // dwKeyIdx,      key pair index optional public key
        fOem,

        lpstrPid2,
        lpbPid3,
        lpdwSeq,
        pfCCP,
        NULL);          // pfPSS,         'PSS Assigned' flag

    return dwRet;
}

#endif // defined(WIN32) || defined(_WIN32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\spidgen.cpp ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    spidgen.cpp

Abstract:

   wrapper for PIDGen used by winnt32 and syssetup

--*/


#define WINDOWS_LEAN_AND_MEAN  // faster compile

#include <windows.h>

#if defined(WIN32) || defined(_WIN32)

#include <tchar.h>
#include "hardware.h"

#else

#include <stdlib.h>
#include <time.h>
#include <dos.h>

#include "..\..\inc\tchar.h"

extern "C" extern WORD _C000H;
extern "C" extern WORD _F000H;

#endif

#include "..\inc\DigPid.h"
#include "..\inc\shortsig.h"

#include "pidgen.h"
#include "util.h"

#include "crc-32.h"

#ifdef BUILD_SRV
LPSTR lpstrSelectPidKeyA = "R7MPM-R36DT-F38FC-RPPCX-XJG7M";
LPWSTR lpstrSelectPidKeyW = L"R7MPM-R36DT-F38FC-RPPCX-XJG7M";
#endif

#ifdef BUILD_PRO
LPSTR lpstrSelectPidKeyA = "HB9CF-JTKJF-722HV-VPBRF-9VKVM";
LPWSTR lpstrSelectPidKeyW = L"HB9CF-JTKJF-722HV-VPBRF-9VKVM";
#endif

#ifdef BUILD_PER
LPSTR lpstrSelectPidKeyA = "HB9CF-JTKJF-722HV-VPBRF-9VKVM";
LPWSTR lpstrSelectPidKeyW = L"HB9CF-JTKJF-722HV-VPBRF-9VKVM";
#endif

#ifdef BUILD_DDK
LPSTR lpstrSelectPidKeyA = "R2D43-3DHG9-DQ79W-W3DXQ-929DY";
LPWSTR lpstrSelectPidKeyW = L"R2D43-3DHG9-DQ79W-W3DXQ-929DY";
#endif

#ifdef BUILD_TRIAL
// can't have a trial version of select
LPSTR lpstrSelectPidKeyA = "99999-99999-99999-99999-99999";
LPWSTR lpstrSelectPidKeyW = L"99999-99999-99999-99999-99999";
#endif BUILD_TRIAL

#ifdef BUILD_VOL
LPSTR lpstrSelectPidKeyA = "HB9CF-JTKJF-722HV-VPBRF-9VKVM";
LPWSTR lpstrSelectPidKeyW = L"HB9CF-JTKJF-722HV-VPBRF-9VKVM";
#endif

#ifdef BUILD_EVAL
// can't have a trial version of select
LPSTR lpstrSelectPidKeyA = "99999-99999-99999-99999-99999";
LPWSTR lpstrSelectPidKeyW = L"99999-99999-99999-99999-99999";
#endif BUILD_TRIAL

extern "C" BOOL STDAPICALLTYPE SetupPIDGenA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrRpc,           // [IN] 5-character Release Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    BOOL    fOem,               // [IN] is this an OEM install?
    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to binary PID3 buffer. First DWORD is the length
    LPBOOL  pfCCP)              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
{
    DWORD dwRet;

    // lpstrSecureCdKey must not be NULL
    if ('\0' == lpstrSecureCdKey[0]){
	// if we are passed an empty string, assume it's the select string
	DWORD i;
	// lets not forget that the Secure CD-Key has dashes in it
	for(i=0; i <= 29; i++){
	    lpstrSecureCdKey[i] = lpstrSelectPidKeyA[i];
	}
    }

    dwRet = PIDGenA(
        lpstrSecureCdKey,
        lpstrRpc,
        lpstrSku,
        NULL,
        NULL,
        NULL,
        0,
        0,
        fOem,

        lpstrPid2,
        lpbPid3,
        NULL,
        pfCCP,
        NULL);

    return dwRet;
}

#if defined(WIN32) || defined(_WIN32)

extern "C" BOOL STDAPICALLTYPE SetupPIDGenW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrRpc,           // [IN] 5-character Release Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    BOOL   fOem,                // [IN] is this an OEM install?
    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbPid3,            // [OUT] pointer to DigitalPID. First DWORD is the length
    LPBOOL  pfCCP)              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
{

    DWORD dwRet;

    if (L'\0' == lpstrSecureCdKey[0]){
	// if we are passed an empty key write the select key in.
	DWORD i;
	// don't forget that the SecureCd-Key has dashes in it.
	for(i=0; i <= 29; i++){
	    lpstrSecureCdKey[i] = lpstrSelectPidKeyW[i];
	}
    }

    dwRet = PIDGenW(
        lpstrSecureCdKey,
        lpstrRpc,
        lpstrSku,
        NULL,
        NULL,
        NULL,
        0,
        0,
        fOem,

        lpstrPid2,
        lpbPid3,
        NULL,
        pfCCP,
        NULL);

     return dwRet;
}


#endif // defined(WIN32) || defined(_WIN32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Andrew Ritz (andrewr)

!ENDIF


# Change BETA_PID to 0 for RTM when you are checking in RTM ####.pub files
# to update the public keys 

BETA_PID = 0

##########################


MAJORCOMP=setup
MINORCOMP=winnt32


INCLUDES=\
  $(INCLUDES);\
  ..\..\inc;\
  ..\..\..\inc;\

C_DEFINES=$(C_DEFINES) -DWINXP_SPx_RTM

SOURCES=\
        pidgen.rc  \
        crc-32.cpp \
        PIDGen.cpp \
        spidgen.cpp \
        crcmodel.c \
        hardware.cpp \
        crc32.cpp \
        main.cpp \
        CRTStubs.cpp \
        util.cpp \
        range.cpp \


UMTYPE=windows
NO_NTDLL=1

USE_MSVCRT=1

DLLENTRY=_DllMainCRTStartup

PIDLIB=$(PROJECT_ROOT)\ntsetup\pidgen\lib

TARGETLIBS= \
  $(DS_LIB_PATH)\bignum.lib         \
  $(DS_LIB_PATH)\randlib.lib     \
  $(DS_LIB_PATH)\rsa32.lib          \
  $(PIDLIB)\*\shortsig.lib                    \
  $(SDK_LIB_PATH)\kernel32.lib    \
  $(SDK_LIB_PATH)\user32.lib      \
  $(SDK_LIB_PATH)\advapi32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\rangedat.h ===
/*++

Copyright (c) 1998-2002, Microsoft Corporation

Module Name:


    rangedat.h

Abstract:

--*/

#ifndef _RANGEDATA_H_
#define _RANGEDATA_H_

static const WCHAR szTablet[] = L"TabletPC";


#if defined BUILD_PRO

#ifdef WINXP_SPx_RTM
static SEQUENCE_RANGE srTabletRetail[] = {
    { 360000000, 364999999},
    { 0, 0}
};

static SEQUENCE_RANGE srTabletOem[] = {
    { 170000000, 269999999},
    { 119000300, 119000799},
    { 0, 0}
};
#else
static SEQUENCE_RANGE srTabletRetail[] = {
    { 2400000, 2449999},
    { 0, 0}
};

static SEQUENCE_RANGE srTabletOem[] = {
    { 3400000, 3449999},
    { 119000300, 119000799},
    { 0, 0}
};
#endif

#elif defined BUILD_VOL
static SEQUENCE_RANGE srTabletRetail[] = {
    { 699000000, 699999999},
    { 0, 0}
};

static SEQUENCE_RANGE srTabletOem[] = {
    { 0, 0}
};

#elif defined BUILD_EVAL
static SEQUENCE_RANGE srTabletRetail[] = {
    { 99000000, 100999999},
    { 0, 0}
};

static SEQUENCE_RANGE srTabletOem[] = {
    { 0, 0}
};

#else
// No tablet sku for these
// BUILD_DDK || BUILD_PER || BUILD_TRIAL || BUILD_SRV
static SEQUENCE_RANGE srTabletRetail[] = {
    { 0, 0}
};

static SEQUENCE_RANGE srTabletOem[] = {
    { 0, 0}
};

#endif

static const WCHAR szEhome[] = L"EHome";



#if defined BUILD_PRO
#ifdef WINXP_SPx_RTM
static SEQUENCE_RANGE srEhomeRetail[] = {
    { 365000000, 369999999},
    { 0, 0}
};

static SEQUENCE_RANGE srEhomeOem[] = {
    { 803000000, 899999999},
    { 119000800, 119001799},
    { 0, 0}
};
#else
static SEQUENCE_RANGE srEhomeRetail[] = {
    { 2200000, 2399999},
    { 0, 0}
};

static SEQUENCE_RANGE srEhomeOem[] = {
    { 3200000, 3399999},
    { 119000800, 119001799},
    { 0, 0}
};
#endif

#elif defined BUILD_VOL
static SEQUENCE_RANGE srEhomeRetail[] = {
    { 0, 0}
};

static SEQUENCE_RANGE srEhomeOem[] = {
    { 0, 0}
};
#elif defined BUILD_EVAL
static SEQUENCE_RANGE srEhomeRetail[] = {
    { 97000000, 98999999},
    { 0, 0}
};

static SEQUENCE_RANGE srEhomeOem[] = {
    { 0, 0}
};
#else
// No ehome sku for these
// BUILD_DDK || BUILD_PER || BUILD_TRIAL || BUILD_SRV
static SEQUENCE_RANGE srEhomeRetail[] = {
    { 0, 0}
};

static SEQUENCE_RANGE srEhomeOem[] = {
    { 0, 0}
};

#endif

static SKU_RANGE rangeTable[] = {
    { szTablet, srTabletRetail, srTabletOem},
    { szEhome, srEhomeRetail, srEhomeOem}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\range.h ===
/*++

Copyright (c) 1998-2002, Microsoft Corporation

Module Name:


    range.h

Abstract:

--*/

#ifndef _RANGE_H_
#define _RANGE_H_

/*
Structure to hold ChID and Sequence Number.
*/
typedef struct _SEQUENCE_RANGE {
    DWORD               dwStartSeq;
    DWORD               dwEndSeq;
} SEQUENCE_RANGE, *PSEQUENCE_RANGE;

/* 
Structure to hold range for each sku
*/
typedef struct _SKU_RANGE {
    PCWSTR              pszSKU;
    PSEQUENCE_RANGE     psrRetail;
    PSEQUENCE_RANGE     psrOem;
} SKU_RANGE, *PSKU_RANGE;


static const WCHAR szSKULocationKey[] = L"System\\WPA\\PIDRange";
static const WCHAR szSKULocationValue[] = L"SKURange";

BOOL CheckSkuRange(
    IN BOOL  fOem,
    IN DWORD dwSeq
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PidCa.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\range.cpp ===
/*++

Copyright (c) 1998-2002, Microsoft Corporation

Module Name:

    range.cpp

Abstract:

--*/

#include <windows.h>
#include "pidgen.h"
#include "range.h"
#include "rangedat.h"

LONG
GetSkuName(
    OUT PWCHAR pszSKU,
    IN DWORD cBytes
    )
/*++

Routine Description:

    This routine will read the registry for the PRO variation name, the SKU.

Arguments:

    szSKU - buffer to hold the string to the SKU.
    cBytes - number of bytes buffer can hold.

Return Value:

    ERROR_SUCCESS for success.
    Error code for failure.

--*/
{
    LONG lRet;
    HKEY hKeySKU = NULL;
    DWORD dwType;

    lRet = RegOpenKeyW( HKEY_LOCAL_MACHINE, szSKULocationKey, &hKeySKU);

    if (lRet != ERROR_SUCCESS) {
        goto done;
    }

    lRet = RegQueryValueExW( hKeySKU, szSKULocationValue, NULL, &dwType, (LPBYTE)pszSKU, &cBytes);

    pszSKU[cBytes/sizeof(WCHAR)-1] = L'\0';
    if( lRet != ERROR_SUCCESS) {
        goto done;
    }

    // Must be string type and not empty.
    if( dwType != REG_SZ || !pszSKU[0]) {
        lRet = ERROR_INVALID_DATA;
        goto done;
    }
done:
    if( hKeySKU) {
        RegCloseKey( hKeySKU);
    }
    return lRet;
}


PSEQUENCE_RANGE
GetRange( 
    IN BOOL  fOem,
    IN PCWSTR pszSKU
    )
/*++

Routine Description:

    This routine will return the inclusion range table for the
    given SKU string.

Arguments:

    fOem  - oem or retail
    pszSKU - string to the SKU.

Return Value:

    PSEQUENCE_RANGE - pointer to the inclusion sequence table.

--*/
{
    DWORD dwRangeCount = sizeof(rangeTable)/sizeof(rangeTable[0]);

    while( dwRangeCount) {
        dwRangeCount--;
        if( wcscmp( pszSKU, rangeTable[dwRangeCount].pszSKU) == 0) {
            if( fOem) {
                return( rangeTable[dwRangeCount].psrOem);
            } else {
                return( rangeTable[dwRangeCount].psrRetail);
            }
        }
    }
    return NULL;
}


BOOL
IsSequenceIncluded(
    IN DWORD dwSeq,
    IN PSEQUENCE_RANGE pseqRange
    )
/*++

Routine Description:

    This routine will determine if a sequnce number is within the SKU range.

Arguments:

    dwSeq - sequence to check
    pseqRange - the range

Return Value:

    BOOL - TRUE if in range, FALSE if not in range.

--*/
{
    // We must have a valid range passed in otherwise return false.
    if( !pseqRange) {
        return FALSE;
    }

    // We assume at least one valid range sequence pointed to by pseqRange -not just the empty range which
    // indicates the end of the table.

    while( (pseqRange->dwStartSeq != 0) && (pseqRange->dwEndSeq != 0)) {
        if (dwSeq >= pseqRange->dwStartSeq && dwSeq <= pseqRange->dwEndSeq) {
            return TRUE;
        }
        pseqRange++;
    }

    return FALSE;
}

BOOL CheckSkuRange(
    IN BOOL  fOem,
    IN DWORD dwSeq
    )
/*++

Routine Description:

    This routine will determine if a sequence is valid for the current professional SKU.
    
    The SKU is read from the registry to determine the valid range. The valid range
    per sku is kept in tables in pidgen.

Arguments:

    fOem  - oem or retail
    dwSeq - Sequence to check.

Return Value:

    BOOL, TRUE if sequence is valid, FALSE if sequence is invalid.

--*/
{
    DWORD dwRangeCount = sizeof(rangeTable)/sizeof(rangeTable[0]);
    WCHAR szSKURead[MAX_PATH];
    PSEQUENCE_RANGE pseqRange;
    LONG lRet;

    // Get the name of the sku from the registry.
    lRet = GetSkuName( szSKURead, sizeof(szSKURead) );

    // If we don't find an inclusion range in the registry then 
    // assume all ranges are accepted (in other words plain vanilla pro).
    if( lRet != ERROR_SUCCESS) {
        return( TRUE);
    }

    // Get the inclusion range for this sku.
    pseqRange = GetRange( fOem, szSKURead);

    // If we don't find a range table then assume a new sku (variation of pro) was created
    // which we don't understand so deny cross upgrade.
    if( !pseqRange) {
        return (FALSE);
    }

    // If the product id fits in this range return true.
    return( IsSequenceIncluded( dwSeq, pseqRange));
}

extern "C" DWORD STDAPICALLTYPE VerifyPIDSequenceW( 
    IN BOOL  fOem,
    IN DWORD dwSeq,
    IN PCWSTR pszSKU 
    )
/*++

Routine Description:

    This routine will determine if a sequence is valid for a particular sku.
    
Arguments:

    fOem  - oem or retail
    dwSeq - Sequence to check.
    pszSKU - null terminated string for the SKU.

Return Value:

    pgeSuccess if sequence is in range.
    pgeProductKeyExcluded if sequence is not in range.
    pgeProductKeyInvalid if range table not found.

--*/
{
    PSEQUENCE_RANGE pseqRange;

    // Get the inclusion range for this sku.
    pseqRange = GetRange( fOem, pszSKU);

    // If we don't find a range table then assume a new sku (variation of pro) was created 
    // which we don't understand.
    if( !pseqRange) {
        return (pgeProductKeyInvalid);
    }

    // If the product id fits in this range return true.
    if ( IsSequenceIncluded( dwSeq, pseqRange)) {
        return (pgeSuccess);
    } else {
        return (pgeProductKeyExcluded);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\ccrc32.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    CCrc32.h

Abstract:

--*/

#ifndef CCRC32_H
#define CCRC32_H


#ifndef __WINDOWS_H
#include <windows.h>
#endif


// Used Definitions Declarations

#define CCRC32_CLASSID 0x13420808L

#define CRC32_POLYNOMIAL 0xEDB88320


// Class Declaration

class CCrc32
{
    public:
        CCrc32();
        virtual ~CCrc32();

    public:
        ULONG CalculateBlockCRC( LPVOID lpvBlock, INT nBlockLength );

    public:
        ULONG uClassID;

    private:
        VOID InitialiseCRCTable();

    private:
        ULONG m_uCRC32Table[ 256 ];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\chardwar.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    CHardwar.h

Abstract:

--*/

#ifndef CHARDWARE_H
#define CHARDWARE_H


#ifndef __WINDOWS_H
#include <windows.h>
#endif


// Used Definitions Declarations

#define CHARDWARE_CLASSID 0x13530808L

#define BIOS_DIGIT       0
#define HD_SERIAL_DIGIT  1
#define TOTAL_RAM_DIGIT  2
#define FD_CONFIG_DIGIT  3
#define VIDEO_BIOS_DIGIT 4
#define HARDWARE_ID_SIZE 6

#define HARDWARE_GUID_SIZE 39

#define MAX_BIOS_KEY_LENGTH 2048

#define VWIN32_DIOC_DOS_INT13 4

#define FLAGS_CARRY 1


// Used Type Declarations

typedef struct _DIOC_REGISTERS
{
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS, *PDIOC_REGISTERS;

#pragma pack(1)
typedef struct _DEVICEPARAMS
{
    BYTE  dpSpecFunc;
    BYTE  dpDevType;
    WORD  dpDevAttr;
    WORD  dpCylinders;
    BYTE  dpMediaType;

    WORD  dpBytesPerSec;
    BYTE  dpSecPerClust;
    WORD  dpResSectors;
    BYTE  dpFATs;
    WORD  dpRootDirEnts;
    WORD  dpSectors;
    BYTE  dpMedia;
    WORD  dpFATsecs;
    WORD  dpSecPerTrack;
    WORD  dpHeads;
    DWORD dpHiddenSecs;
    DWORD dpHugeSectors;
} DEVICEPARAMS, *PDEVICEPARAMS;
#pragma pack()


// Class Declaration

class CHardware
{
    public:
        CHardware();
        virtual ~CHardware();

    public:
        LPSTR GetGUID();
        LPSTR GetID();

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        DWORD GetType();
        DWORD GetBiosCrc32() { return m_dwBiosCrc32; };
        DWORD GetVolSer() { return m_dwVolSer; };
        DWORD GetTotalRamMegs() { return m_dwTotalRamMegs; };
        DWORD GetVideoBiosCrc32() { return m_dwVideoBiosCrc32; };
#endif

    public:
        ULONG uClassID;

    private:
#ifndef _WIN64
        DWORD CalculateDriveCapacity95( INT nDrive );
#endif
        DWORD CalculateMemoryRegionChecksum( LPBYTE pbChecksumArea, INT nNumberBytes );
        VOID SetBIOSDigit();
        VOID SetFDConfigDigit();
        VOID SetHDSerialDigit();
        VOID SetTotalRAMDigit();
        VOID SetVideoBIOSDigit();

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
        VOID CalculateHardwareGUID();
#endif ////////////////////////////////////////////////////////////////////////

#if defined(WIN32) || defined(_WIN32)
        static UINT CalculateRegKeyChecksum( LPSTR lpszKey );
        static DWORD CalculateDriveCapacityNT( INT nDrive );
#endif

    private:
        CHAR m_szHardwareID[ HARDWARE_ID_SIZE ];

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
        CHAR m_szHardwareGUID[ HARDWARE_GUID_SIZE ];
#endif ////////////////////////////////////////////////////////////////////////

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        DWORD m_dwBiosCrc32;
        DWORD m_dwVolSer;
        DWORD m_dwTotalRamMegs;
        DWORD m_dwVideoBiosCrc32;
#endif

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\crc32.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    Crc32.h

Abstract:

--*/

#ifndef CRC32_H
#define CRC32_H

#include <windows.h>

#include <string.h>  // needed by compobj.h

#if defined(WIN32) || defined(_WIN32)

#include <crtdbg.h>

#else

typedef short INT;

#include <assert.h>
#define _ASSERT assert

#include <compobj.h> // needed for 16-bit build

#endif

#include "tchar.h"
#include "CCrc32.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\crcmodel.c ===
/****************************************************************************/
/*							   Start of crcmodel.c							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the implementation (.c) file for the reference 	*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Implementation Notes 													*/
/* -------------------- 													*/
/* To avoid inconsistencies, the specification of each function is not		*/
/* echoed here. See the header file for a description of these functions.	*/
/* This package is light on checking because I want to keep it short and	*/
/* simple and portable (i.e. it would be too messy to distribute my entire	*/
/* C culture (e.g. assertions package) with this package.					*/
/*																			*/
/****************************************************************************/

#include "crcmodel.h"

/****************************************************************************/
/* The following definitions make the code more readable.					*/

#define BITMASK(X) (1L << (X))
#define MASK32 0xFFFFFFFFL
#define LOCAL static

/****************************************************************************/

/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26						*/

LOCAL ulong reflect(
    ulong v,
    int   b)
{
 int   i;
 ulong t = v;
 for (i=0; i<b; i++)
   {
	if (t & 1L)
	   v|=	BITMASK((b-1)-i);
	else
	   v&= ~BITMASK((b-1)-i);

	t>>=1;

   }
 return v;
}

/****************************************************************************/

/* Returns a longword whose value is (2^p_cm->cm_width)-1.	   */
/* The trick is to do this portably (e.g. without doing <<32). */

LOCAL ulong widmask(p_cm_t p_cm)
{
 return (((1L<<(p_cm->cm_width-1))-1L)<<1)|1L;
}

/****************************************************************************/

void cm_ini (p_cm_t p_cm)
{
 p_cm->cm_reg = p_cm->cm_init;
}

/****************************************************************************/

void cm_nxt(p_cm_t p_cm, int ch)
{
 int   i;
 ulong uch	= (ulong) ch;
 ulong topbit = BITMASK(p_cm->cm_width-1);

 if (p_cm->cm_refin) uch = reflect(uch,8);
 p_cm->cm_reg ^= (uch << (p_cm->cm_width-8));
 for (i=0; i<8; i++)
   {
	if (p_cm->cm_reg & topbit)
	   p_cm->cm_reg = (p_cm->cm_reg << 1) ^ p_cm->cm_poly;
	else
	   p_cm->cm_reg <<= 1;
	p_cm->cm_reg &= widmask(p_cm);
   }
}

/****************************************************************************/

void cm_blk(
p_cm_t	 p_cm,
p_ubyte_ blk_adr,
ulong	 blk_len)
{
 while (blk_len--) cm_nxt(p_cm,*blk_adr++);
}

/****************************************************************************/

ulong cm_crc(p_cm_t p_cm)
{
 if (p_cm->cm_refot)
	return p_cm->cm_xorot ^ reflect(p_cm->cm_reg,p_cm->cm_width);
 else
	return p_cm->cm_xorot ^ p_cm->cm_reg;
}

/****************************************************************************/

ulong cm_tab(p_cm_t p_cm, int index)
{
 int   i;
 ulong r;
 ulong topbit = BITMASK(p_cm->cm_width-1);
 ulong inbyte = (ulong) index;

 if (p_cm->cm_refin) inbyte = reflect(inbyte,8);
 r = inbyte << (p_cm->cm_width-8);
 for (i=0; i<8; i++)
	if (r & topbit)
	   r = (r << 1) ^ p_cm->cm_poly;
	else
	   r<<=1;
 if (p_cm->cm_refin) r = reflect(r,p_cm->cm_width);
 return r & widmask(p_cm);
}

/****************************************************************************/
/*							   End of crcmodel.c							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\crcmodel.h ===
/****************************************************************************/
/*							   Start of crcmodel.h							*/
/****************************************************************************/
/*																			*/
/* Author : Ross Williams (ross@guest.adelaide.edu.au.).					*/
/* Date   : 3 June 1993.													*/
/* Status : Public domain.													*/
/*																			*/
/* Description : This is the header (.h) file for the reference 			*/
/* implementation of the Rocksoft^tm Model CRC Algorithm. For more			*/
/* information on the Rocksoft^tm Model CRC Algorithm, see the document 	*/
/* titled "A Painless Guide to CRC Error Detection Algorithms" by Ross      */
/* Williams (ross@guest.adelaide.edu.au.). This document is likely to be in */
/* "ftp.adelaide.edu.au/pub/rocksoft".                                      */
/*																			*/
/* Note: Rocksoft is a trademark of Rocksoft Pty Ltd, Adelaide, Australia.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* How to Use This Package													*/
/* -----------------------													*/
/* Step 1: Declare a variable of type cm_t. Declare another variable		*/
/*		   (p_cm say) of type p_cm_t and initialize it to point to the first*/
/*		   variable (e.g. p_cm_t p_cm = &cm_t). 							*/
/*																			*/
/* Step 2: Assign values to the parameter fields of the structure.			*/
/*		   If you don't know what to assign, see the document cited earlier.*/
/*		   For example: 													*/
/*			  p_cm->cm_width = 16;											*/
/*			  p_cm->cm_poly  = 0x8005L; 									*/
/*			  p_cm->cm_init  = 0L;											*/
/*			  p_cm->cm_refin = TRUE;										*/
/*			  p_cm->cm_refot = TRUE;										*/
/*			  p_cm->cm_xorot = 0L;											*/
/*		   Note: Poly is specified without its top bit (18005 becomes 8005).*/
/*		   Note: Width is one bit less than the raw poly width. 			*/
/*																			*/
/* Step 3: Initialize the instance with a call cm_ini(p_cm);				*/
/*																			*/
/* Step 4: Process zero or more message bytes by placing zero or more		*/
/*		   successive calls to cm_nxt. Example: cm_nxt(p_cm,ch);			*/
/*																			*/
/* Step 5: Extract the CRC value at any time by calling crc = cm_crc(p_cm); */
/*		   If the CRC is a 16-bit value, it will be in the bottom 16 bits.	*/
/*																			*/
/****************************************************************************/
/*																			*/
/* Design Notes 															*/
/* ------------ 															*/
/* PORTABILITY: This package has been coded very conservatively so that 	*/
/* it will run on as many machines as possible. For example, all external	*/
/* identifiers have been restricted to 6 characters and all internal ones to*/
/* 8 characters. The prefix cm (for Crc Model) is used as an attempt to 	*/
/* avoid namespace collisions. This package is endian independent.			*/
/*																			*/
/* EFFICIENCY: This package (and its interface) is not designed for 		*/
/* speed. The purpose of this package is to act as a well-defined reference */
/* model for the specification of CRC algorithms. If you want speed, cook up*/
/* a specific table-driven implementation as described in the document cited*/
/* above. This package is designed for validation only; if you have found or*/
/* implemented a CRC algorithm and wish to describe it as a set of para-	*/
/* meters to the Rocksoft^tm Model CRC Algorithm, your CRC algorithm imple- */
/* mentation should behave identically to this package under those para-	*/
/* meters.																	*/
/*																			*/
/****************************************************************************/

/* The following #ifndef encloses this entire */
/* header file, rendering it idempotent.	 */

#ifndef CM_DONE
#define CM_DONE

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* The following definitions are extracted from my style header file which	*/
/* would be cumbersome to distribute with this package. The DONE_STYLE is	*/
/* the idempotence symbol used in my style header file. 					*/

#ifndef DONE_STYLE

typedef unsigned long	ulong;
typedef unsigned		ubool;
typedef unsigned char * p_ubyte_;

#ifndef TRUE
#define FALSE 0
#define TRUE  1
#endif

/* Uncomment this definition if you don't have void. */
/* typedef int void; */

#endif

/****************************************************************************/
/* CRC Model Abstract Type													*/
/* -----------------------													*/
/* The following type stores the context of an executing instance of the	*/
/* model algorithm. Most of the fields are model parameters which must be	*/
/* set before the first initializing call to cm_ini.						*/

typedef struct
  {
   int	 cm_width;	 /* Parameter: Width in bits [8,32].	   */
   ulong cm_poly;	 /* Parameter: The algorithm's polynomial. */
   ulong cm_init;	 /* Parameter: Initial register value.	   */
   ubool cm_refin;	 /* Parameter: Reflect input bytes? 	   */
   ubool cm_refot;	 /* Parameter: Reflect output CRC?		   */
   ulong cm_xorot;	 /* Parameter: XOR this to output CRC.	   */

   ulong cm_reg;	 /* Context: Context during execution.	   */
  } cm_t;
typedef cm_t *p_cm_t;

/****************************************************************************/
/* Functions That Implement The Model										*/
/* ----------------------------------										*/
/* The following functions animate the cm_t abstraction.					*/

void cm_ini(p_cm_t p_cm);

/* Initializes the argument CRC model instance. 		 */
/* All parameter fields must be set before calling this. */

void cm_nxt(p_cm_t p_cm, int ch);

/* Processes a single message byte [0,255]. */

void cm_blk(p_cm_t p_cm, p_ubyte_ blk_adr, ulong blk_len);

/* Processes a block of message bytes. */

ulong cm_crc(p_cm_t p_cm);

/* Returns the CRC value for the message bytes processed so far. */

/****************************************************************************/
/* Functions For Table Calculation											*/
/* -------------------------------											*/
/* The following function can be used to calculate a CRC lookup table.		*/
/* It can also be used at run-time to create or check static tables.		*/

ulong cm_tab(p_cm_t p_cm, int index);

/* Returns the i'th entry for the lookup table for the specified algorithm. */
/* The function examines the fields cm_width, cm_poly, cm_refin, and the	*/
/* argument table index in the range [0,255] and returns the table entry in */
/* the bottom cm_width bytes of the return value. */

/****************************************************************************/
/* End of the header file idempotence #ifndef								*/

#ifdef __cplusplus
}
#endif

#endif

/****************************************************************************/
/*							   End of crcmodel.h							*/
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\hardware.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    Hardware.h

Abstract:

--*/

#ifndef HARDWARE_H
#define HARDWARE_H

#define NO_HWID_GUID
#define HWID_DETAIL

#include <string.h>  // needed by compobj.h
#include <windows.h>

#if defined(WIN32) || defined(_WIN32)

#include <crtdbg.h>

#else

typedef short INT;
typedef char CHAR;

#include <toolhelp.h>

#include <assert.h>
#define _ASSERT assert

#include <compobj.h> // needed for 16-bit build
#include <dos.h>

#endif


#include <string.h>

#include "tchar.h"

#if defined(WIN32) || defined(_WIN32)
#include <winioctl.h>
#endif

// #include "LicWiz.h"
#include "CHardwar.h"

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
#include "crc32.h"
#endif

#include "crc-32.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\crc-32.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    crc-32.cpp

Abstract:

--*/


#include "crcmodel.h"

DWORD CRC_32(LPBYTE pb, DWORD cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\crc-32.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    crc-32.cpp

Abstract:

--*/

#include <windows.h>
#include "crc-32.h"


DWORD CRC_32(LPBYTE pb, DWORD cb)
{

//      CRC-32 algorithm used in PKZip, AUTODIN II, Ethernet, and FDDI
//      but xor out (xorot) has been changed from 0xFFFFFFFF to 0 so
//      we can store the CRC at the end of the block and expect 0 to be
//      the value of the CRC of the resulting block (including the stored
//      CRC).

    cm_t cmt = {
        32,         // cm_width  Parameter: Width in bits [8,32].
        0x04C11DB7, // cm_poly   Parameter: The algorithm's polynomial.
        0xFFFFFFFF, // cm_init   Parameter: Initial register value.
        TRUE,       // cm_refin  Parameter: Reflect input bytes?
        TRUE,       // cm_refot  Parameter: Reflect output CRC?
        0,          // cm_xorot  Parameter: XOR this to output CRC.
        0           // cm_reg    Context: Context during execution.
    };

    // Documented test case for CRC-32:
    // Checking "123456789" should return 0xCBF43926

    cm_ini(&cmt);
    cm_blk(&cmt, pb, cb);

    return cm_crc(&cmt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\util.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    util.h

Abstract:

--*/

#define ARRAY_SIZE(a) (sizeof(a)/sizeof(*(a)))

char * StrUpperA(char *pstr);
TCHAR * StrUpper(TCHAR *pstr);
DWORD AddCheckDigit(DWORD dw);

#if defined(WIN32) || defined(_WIN32)
DWORD FileTimeToTimet(LPFILETIME pft);
DWORD GetJulianDate(LPSYSTEMTIME pst);
#endif // defined(WIN32) || defined(_WIN32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\crc32.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    Crc32.cpp

Abstract:

--*/

#include "Crc32.h"


CCrc32::CCrc32()
{
    uClassID = CCRC32_CLASSID;

    InitialiseCRCTable();
}


CCrc32::~CCrc32()
{
}


VOID CCrc32::InitialiseCRCTable()
{
    INT   nIndex;
    INT   nBitIndex;
    ULONG uTableValue;

    for ( nIndex = 0; nIndex < 256; nIndex++ )
    {
        uTableValue = nIndex;

        for ( nBitIndex = 0; nBitIndex < 8; nBitIndex++ )
        {
            if ( ( uTableValue & 1 ) == 1 )
            {
                uTableValue = ( uTableValue >> 1 ) ^ CRC32_POLYNOMIAL;
            } else
            {
                uTableValue = uTableValue >> 1;
            }
        }

        m_uCRC32Table[ nIndex ] = uTableValue;
    }
}


ULONG CCrc32::CalculateBlockCRC(LPVOID lpvBlock, INT nBlockLength)
{
    INT    nIndex;
    LPBYTE lpbBlock;
    ULONG  uCRCValue;

    _ASSERT( nBlockLength > 0 );

    lpbBlock  = (LPBYTE)lpvBlock;
    uCRCValue = 0xFFFFFFFFL;

    for ( nIndex = 0; nIndex < nBlockLength; nIndex++ )
    {
        uCRCValue = ( ( uCRCValue >> 8 ) & 0x00FFFFFFL ) ^ ( m_uCRC32Table[ ( uCRCValue ^ lpbBlock[ nIndex ] ) & 0xFFL ] );
    }

    uCRCValue = uCRCValue ^ 0xFFFFFFFFL;

    return uCRCValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\debug.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Debug infrastructure for this component.
    (currently inactive)

Author:

    Jim Cavalaris (jamesca) 07-Mar-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "debug.h"


//
// debug infrastructure
// (currently removed)
//

#if 0 //#if DBG // DBG

VOID
DebugMessage(LPTSTR format, ... )
{
    va_list args;
    va_start(args, format);
    _vtprintf(format, args);
}

// flags currently defined for use by debug.h:
// DBGF_ERRORS, DBGF_WARNINGS, DBGF_REGISTRY, DBGF_INFO

DWORD   g_DebugFlag = DBGF_WARNINGS | DBGF_ERRORS | DBGF_INFO;

#endif  // DBG



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\pidset.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    PIDSet.cpp

Abstract:

--*/

#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#include "hardware.h"

#include "tchar.h"
#include "DigPid.h"
#include "crc-32.h"


BOOL PidRead(LPDIGITALPID pdpid, DWORD cbDpid)
{
    BOOL fSuccess = FALSE;

    LONG lStatus;
    HKEY hkey;

    if (NULL != pdpid)
    {
        lStatus = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
            0,
            KEY_QUERY_VALUE,
            &hkey);

        if ( lStatus == ERROR_SUCCESS )
        {
            DWORD dwValueType;

            lStatus = RegQueryValueEx(
                hkey, TEXT("DigitalProductId"), NULL, &dwValueType, (LPBYTE)pdpid, &cbDpid);

            fSuccess = (ERROR_SUCCESS == lStatus);

            RegCloseKey(hkey);
        }
    }
    return fSuccess;
}


BOOL PidWrite(LPDIGITALPID pdpid, DWORD cbDpid)
{
    BOOL fSuccess = FALSE;

    LONG lStatus;
    HKEY hkey;

    if (NULL != pdpid)
    {
        lStatus = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"),
            0,
            KEY_WRITE,
            &hkey);

        if ( lStatus == ERROR_SUCCESS )
        {
            lStatus = RegSetValueEx(
                hkey,                // handle of key to set value for
                TEXT("DigitalProductId"), // name of the value to set
                0,                   // reserved
                REG_BINARY,          // flag for value type
                (LPBYTE)pdpid,       // address of value data
                cbDpid);             // size of value data

            fSuccess = (ERROR_SUCCESS == lStatus);

            RegCloseKey(hkey);
        }
    }
    return fSuccess;
}


int PASCAL WinMain(
    HINSTANCE, // hInstance,  // handle to current instance
    HINSTANCE, // hPrevInstance,  // handle to previous instance
    LPSTR, // lpCmdLine,      // pointer to command line
    int )// nCmdShow          // show state of window)
{
    BOOL fOk = TRUE;
    BYTE abDigPid[1024] = {0};
    LPDIGITALPID pdpid = (LPDIGITALPID)abDigPid;


    fOk = PidRead(pdpid, sizeof(abDigPid));

    // check the version and ensure the HWID has not been set

    if (
        fOk &&
        3 == pdpid->wVersionMajor &&
        '\0' == pdpid->aszHardwareIdStatic[0] &&
        0 == pdpid->dwBiosChecksumStatic &&
        0 == pdpid->dwVolSerStatic &&
        0 == pdpid->dwTotalRamStatic &&
        0 == pdpid->dwVideoBiosChecksumStatic)
    {
        BOOL fCrcGood = ( 0 == CRC_32((LPBYTE)pdpid, sizeof(*pdpid)) );
        CHardware hwid;

        strcpy(pdpid->aszHardwareIdStatic, hwid.GetID());

        pdpid->dwBiosChecksumStatic = hwid.GetBiosCrc32();
        pdpid->dwVolSerStatic = hwid.GetVolSer();
        pdpid->dwTotalRamStatic = hwid.GetTotalRamMegs();
        pdpid->dwVideoBiosChecksumStatic = hwid.GetVideoBiosCrc32();

        if (fCrcGood)
        {
            pdpid->dwCrc32 = CRC_32((LPBYTE)pdpid, sizeof(*pdpid)-sizeof(pdpid->dwCrc32));
        }
        else
        {
            pdpid->dwCrc32 = 0;
        }
        PidWrite(pdpid, pdpid->dwLength);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\util.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    util.cpp

Abstract:

--*/

#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>  // included for both CPP and RC passes
#include <stdio.h>    // printf/wprintf

#if defined(WIN32) || defined(_WIN32)
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#else
#include "..\inc\tchar.h"    // define UNICODE=1 on nmake command line to build UNICODE
#endif // defined(WIN32) || defined(_WIN32)

#include "util.h"


BOOL IsValidCheckDigit(DWORD dw)
{
    // validates check digit given 7-digit sequence + check-digit

    int iLastDigit = dw%10;
    BOOL fIsvalid = TRUE;
    DWORD dwSum = 0;


    switch (dw%10) // last digit
    {
    case 0:
    case 8:
    case 9:
        fIsvalid = FALSE;
        break;

    default:
        while (dw != 0)
        {
            dwSum += dw % 10;
            dw /= 10;
        }
        fIsvalid = (0 == dwSum % 7);
    }
    return fIsvalid;
}


DWORD AddCheckDigit(DWORD dw)
{
    // add a valid check digit to the sequence number

    DWORD dwSum = 0;
    DWORD dwCheckNum = dw;

    while (dwCheckNum != 0)
    {
        dwSum += dwCheckNum%10;
        dwCheckNum /= 10;
    }

    dw = 10 * dw + 7 - dwSum%7;

    return dw;
}

char * StrUpperA(char *pstr)
{
    char *pstrCur = pstr;

    while('\0' != *pstrCur)
    {
        if ('a' <= *pstrCur && *pstrCur <= 'z')
        {
            *pstrCur += 'A' - 'a';
        }
        ++pstrCur;
    }

    return (pstr);
}


TCHAR * StrUpper(TCHAR *pstr)
{
    TCHAR *pstrCur = pstr;

    while('\0' != *pstrCur)
    {
        if ('a' <= *pstrCur && *pstrCur <= 'z')
        {
            *pstrCur += 'A' - 'a';
        }
        ++pstrCur;
    }

    return (pstr);
}

#if defined(WIN32) || defined(_WIN32)

DWORD FileTimeToTimet(LPFILETIME pft)
{
    DWORDLONG dwlTime = *(PDWORDLONG)pft;

    if ((DWORDLONG)116444736000000000 < dwlTime)
    {
        // convert 100-nanoseconds since January 1, 1601 to
        // seconds since January 1, 1970

        dwlTime -= (DWORDLONG)116444736000000000;
        dwlTime /= 10000000;
    }
    else
    {
        // Seems we have a date before January 1, 1970, just
        // return January 1, 1970

        dwlTime = 0;
    }

    return (DWORD)dwlTime;
}


// return day of the year 1 to 366

DWORD GetJulianDate(LPSYSTEMTIME pst)
{
    DWORD dwJday = 0;  // day of the year
    DWORD dwMonth = pst->wMonth - 1; // zero based month

    const static short asMonthStarts[] =
        {  0,  31,  59,
          90, 120, 151,
         181, 212, 243,
         273, 304, 334 };

    if (dwMonth < ARRAY_SIZE(asMonthStarts))
    {
        dwJday = pst->wDay + asMonthStarts[dwMonth];

        // if its past Feb and a leap year
        if (1 < dwMonth &&
            ( (0 == pst->wYear%4 && 0 != pst->wYear%100) || 0 == pst->wYear%400) )
        {
            // adjust for leap year
            ++dwJday;
        }
    }

    return dwJday;
}
#endif // defined(WIN32) || defined(_WIN32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidset\hardware.cpp ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    Hardware.cpp

Abstract:

--*/

#include "Hardware.h"

#include <stdio.h> // only needed for testing


#if defined(WIN32) || defined(_WIN32)

static inline BOOL IsPlatformNT()
{

    // always do it 'The NT Way'

    return TRUE;

/*/////////////////////////////////////////////////////////////////////////////

    OSVERSIONINFO osvInfo;
    BOOL          fNTPlatformFlag;

    osvInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    GetVersionEx( &osvInfo );

    switch( osvInfo.dwPlatformId )
    {
        case VER_PLATFORM_WIN32_NT:
            fNTPlatformFlag = TRUE;
            break;

        default:
            fNTPlatformFlag = FALSE;
            break;
    }

    return( fNTPlatformFlag );
*//////////////////////////////////////////////////////////////////////////////
}

#else

inline BOOL IsPlatformNT()
{
    return FALSE;
}

extern "C" extern WORD _C000H;
extern "C" extern WORD _F000H;

#endif

CHardware::CHardware()
#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
  : m_dwBiosCrc32(0),
    m_dwVolSer(0),
    m_dwTotalRamMegs(0),
    m_dwVideoBiosCrc32(0)
#endif
{
    uClassID = CHARDWARE_CLASSID;

    ZeroMemory( (LPVOID)m_szHardwareID, HARDWARE_ID_SIZE );

    SetBIOSDigit();
    SetHDSerialDigit();
    SetTotalRAMDigit();
    SetFDConfigDigit();
    SetVideoBIOSDigit();

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
    CalculateHardwareGUID();
#endif ////////////////////////////////////////////////////////////////////////
}


CHardware::~CHardware()
{
}


DWORD CHardware::GetType()
{
    return(IsPlatformNT() ? 1 : 0);
}


LPSTR CHardware::GetID()
{
    return( m_szHardwareID );
}

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////
LPSTR CHardware::GetGUID()
{
    return( m_szHardwareGUID );
}
#endif ////////////////////////////////////////////////////////////////////////

VOID CHardware::SetBIOSDigit()
{
    DWORD dwBIOSChecksum;

#if defined(WIN32) || defined(_WIN32)
    if ( IsPlatformNT() )
    {
        dwBIOSChecksum  = CalculateRegKeyChecksum( "SystemBiosDate" );
        dwBIOSChecksum += CalculateRegKeyChecksum( "SystemBiosVersion" );
        m_dwBiosCrc32 = dwBIOSChecksum;
    } else
#endif
    {
        LPBYTE pbMemoryByte;

#if defined(WIN32) || defined(_WIN32)
        pbMemoryByte = (LPBYTE)0xF0000;
#else
        pbMemoryByte = (LPBYTE)MAKELONG(0, &_F000H);
#endif
        dwBIOSChecksum = CalculateMemoryRegionChecksum(pbMemoryByte, 2048);
#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        m_dwBiosCrc32 = CRC_32(pbMemoryByte, 2048);
#endif
    }

    m_szHardwareID[ BIOS_DIGIT ] = (CHAR)( dwBIOSChecksum % 9 ) + '0';
}

#if defined(WIN32) || defined(_WIN32)

UINT CHardware::CalculateRegKeyChecksum(LPSTR lpszKey)
{
    LONG lStatus;
    HKEY hkSystem;
    UINT uChecksum;

    uChecksum = 0;

    lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, "HARDWARE\\DESCRIPTION\\System", 0, KEY_QUERY_VALUE, &hkSystem );

    _ASSERT( lStatus == ERROR_SUCCESS );

    if ( lStatus == ERROR_SUCCESS )
    {
        DWORD dwValueType;
        DWORD dwBufferSize;
        BYTE  Buffer[ MAX_BIOS_KEY_LENGTH ];

        dwBufferSize = MAX_BIOS_KEY_LENGTH;

        lStatus = RegQueryValueEx( hkSystem, lpszKey, NULL, &dwValueType, Buffer, &dwBufferSize );

        // ASSERT( lStatus == ERROR_SUCCESS ); // Not all values are guarenteed to exist

        if ( lStatus == ERROR_SUCCESS )
        {
            UINT nCurrentByte;

            for ( nCurrentByte = 0; nCurrentByte < dwBufferSize; nCurrentByte++ )
            {
                uChecksum += Buffer[ nCurrentByte ];
            }
        }

        RegCloseKey( hkSystem );
    }

    return( uChecksum );
}
#endif

DWORD CHardware::CalculateMemoryRegionChecksum( LPBYTE pbChecksumArea, INT nNumberBytes )
{
    DWORD  dwRegionChecksum = 0;

    while (0 < nNumberBytes)
    {
        dwRegionChecksum += (UINT)( *pbChecksumArea );
        ++pbChecksumArea;
        --nNumberBytes;
    }

    return( dwRegionChecksum );
}

#if !defined(WIN32) && !defined(_WIN32)

#pragma pack(1)
   // Media ID
   typedef struct {
       WORD   wInfoLevel;
       DWORD  dwSerialNum;
       char   achVolLabel[11];
       BYTE   abFileSysType[8];
   } MID, *PMID, FAR* LPMID;
#pragma pack()

#endif


VOID CHardware::SetHDSerialDigit()
{
    m_szHardwareID[ HD_SERIAL_DIGIT ] = '?';
    BOOL  fInfoSuccess;
    DWORD dwVolumeSerialNumber;

#if defined(WIN32) || defined(_WIN32)

    DWORD dwFileSystemFlags;
    DWORD dwMaximumComponentLength;
    CHAR  szBootDrivePath[ MAX_PATH ];

    wsprintf( szBootDrivePath, "C:\\" );
    fInfoSuccess = GetVolumeInformation( szBootDrivePath, NULL, 0, &dwVolumeSerialNumber, &dwMaximumComponentLength, &dwFileSystemFlags, NULL, 0 );

    _ASSERT( fInfoSuccess );

#else

    LPMID  pmid;
    union  _REGS regs;
    struct _SREGS segregs;
    DWORD  dwMem;

    dwMem = GlobalDosAlloc(sizeof(MID));

    WORD wMidSelector = LOWORD(dwMem);
    WORD wMidSegment = HIWORD(dwMem);

    pmid = (LPMID)MAKELP(wMidSelector, 0);
    ZeroMemory(pmid, sizeof(MID));

    ZeroMemory(&regs, sizeof(regs));
    ZeroMemory(&segregs, sizeof(segregs));

    regs.x.ax = 0x440d;  // DOS Function 440Dh - IOCTL for Block Device
    regs.h.cl = 0x66;    // Minor Code 66h - Get Media ID
    regs.h.ch = 0x08;    // Device category (must be 08h)
    regs.x.bx = 3;       // Drive C:
    regs.x.dx = 0;       // pmid offset

    segregs.ds = wMidSelector; // wMidSegment;
    segregs.es = wMidSelector; // wMidSegment;

    _intdosx(&regs, &regs, &segregs);

    fInfoSuccess = !regs.x.cflag;

    dwVolumeSerialNumber = pmid->dwSerialNum;
    GlobalDosFree(wMidSelector);
#endif

    if ( fInfoSuccess )
    {
        m_szHardwareID[ HD_SERIAL_DIGIT ] = (CHAR)( dwVolumeSerialNumber % 9 ) + '0';

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        m_dwVolSer = dwVolumeSerialNumber;
#endif

    }
}



VOID CHardware::SetTotalRAMDigit()
{
    DWORD        dwTotalMegabytes;

    m_szHardwareID[ TOTAL_RAM_DIGIT ] = '?';

#if defined(WIN32) || defined(_WIN32)

    MEMORYSTATUS mStatus;

    mStatus.dwLength = sizeof( MEMORYSTATUS );

    GlobalMemoryStatus( &mStatus );

    dwTotalMegabytes  = (DWORD)( mStatus.dwTotalPhys / (1024 * 1024)); // convert to Megabytes
    dwTotalMegabytes += 1; // Add 1Mb to produce accurate result due to reserved space

#else
    BYTE abDpmiMemInfo[0x30];

    memset(abDpmiMemInfo, -1, sizeof(abDpmiMemInfo));

    __asm {
                push    di                      ;save regs

                push    ss
                pop     es                      ;make es point to stack
                lea     di,abDpmiMemInfo        ;Get offset of buffer
                mov     ax,0500h                ;DPMI -- Get Free Memory Info
                int     31h                     ;Call DPMI

                pop     di                      ;restore regs
    }

    DWORD dwTotalPages = *(LPDWORD)&abDpmiMemInfo[0x18];

    // check to see if the field is -1 (error) and just use 0
    // we're adding 1 to account for the memory below 1M (I think)
    dwTotalMegabytes = (dwTotalPages == -1) ? 0 : (1 + dwTotalPages/(1024/4));
#endif

    m_szHardwareID[ TOTAL_RAM_DIGIT ] = (CHAR)( dwTotalMegabytes % 9 ) + '0';

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
    m_dwTotalRamMegs = dwTotalMegabytes;
#endif

}


VOID CHardware::SetFDConfigDigit()
{
    DWORD dwFDConfig;

#if defined(WIN32) || defined(_WIN32)
    if ( IsPlatformNT() )
    {
        dwFDConfig  = CalculateDriveCapacityNT( 1 ) << 2;
        dwFDConfig += CalculateDriveCapacityNT( 2 );
    } else
#endif
    {
#ifndef _WIN64
        dwFDConfig  = CalculateDriveCapacity95( 1 ) << 2;
        dwFDConfig += CalculateDriveCapacity95( 2 );
#endif
    }

    m_szHardwareID[ FD_CONFIG_DIGIT ] = (CHAR)( dwFDConfig % 9 ) + '0';
}

#ifndef _WIN64
DWORD CHardware::CalculateDriveCapacity95( INT nDrive )
{
    DWORD   dwDriveCapacity = 0;
    BOOL    fOk;

    UINT    uNumberHeads;
    UINT    uNumberTracks;
    UINT    uBytesPerSector;
    UINT    uSectorsPerTrack;
    LPBYTE  pbDiskParamTable;


#if defined(WIN32) || defined(_WIN32)
    HANDLE         hDevice;
    BOOL           fResult;
    DIOC_REGISTERS DIOCRegs;
    DWORD          dwBytesReturned;

    // Open VWIN32 Device For Access To DOS Int 13h Functions

    hDevice = CreateFile( "\\\\.\\vwin32", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL );
    fOk = (hDevice != INVALID_HANDLE_VALUE);


    if (fOk)
    {
        // Invoke Int 13h Function 08h - Get Drive Parameters

        DIOCRegs.reg_EAX = 0x0800; // Get Drive Parameters
        DIOCRegs.reg_EDX = nDrive - 1; // 0 = A:, 1 = B:

        fResult = DeviceIoControl( hDevice, VWIN32_DIOC_DOS_INT13, &DIOCRegs, sizeof( DIOC_REGISTERS ), &DIOCRegs, sizeof( DIOC_REGISTERS ), &dwBytesReturned, NULL );

        // Determine if Int 13h Call Succeeded
        fOk = (fResult == TRUE && 0 == (DIOCRegs.reg_Flags & FLAGS_CARRY));
    }

    if (fOk)
    {
        // Calculate Drive Capacity if Drive Number is Valid

        if ( ( DIOCRegs.reg_EDX & 0xFF ) >= (UINT)nDrive )
        {

            pbDiskParamTable = (UCHAR *)DIOCRegs.reg_EDI;

            uNumberHeads     = ( ( DIOCRegs.reg_EDX >> 8 ) & 0xFF ) + 1;
            uNumberTracks    = ( ( ( DIOCRegs.reg_ECX << 2 ) & 0x300 ) + ( ( DIOCRegs.reg_ECX >> 8 ) & 0xFF ) ) + 1;
            uSectorsPerTrack = ( DIOCRegs.reg_ECX & 0x3F );
            uBytesPerSector  = ( 128 << ( *( pbDiskParamTable + 3 ) ) );

            dwDriveCapacity = uNumberHeads * uNumberTracks * uSectorsPerTrack * uBytesPerSector;
        }
    }

    if (hDevice != INVALID_HANDLE_VALUE)
    {
        CloseHandle( hDevice );
    }

#else

    union _REGS regs;
    struct _SREGS segregs;

    ZeroMemory(&regs, sizeof(regs));
    ZeroMemory(&segregs, sizeof(segregs));

    regs.h.ah = 0x08;       // BIOS Function 08h - Get drive parameters
    regs.x.dx = nDrive - 1; // 0 = A:, 1 = B:

    _int86x(
        0x13, // BIOS Disk
        &regs,
        &regs,
        &segregs);


    fOk = (!regs.x.cflag);

    if (fOk)
    {
        uNumberHeads = regs.h.dh + 1;
        uNumberTracks = ((regs.h.cl & 0xC0) << 2) + regs.h.ch + 1;
        uSectorsPerTrack = regs.h.cl & 0x3F;

        pbDiskParamTable = (LPBYTE)MAKELP(segregs.es, regs.x.di);

        uBytesPerSector = (128 << pbDiskParamTable[3]);

        dwDriveCapacity = (DWORD)uNumberHeads * uNumberTracks * uSectorsPerTrack * uBytesPerSector;
    }

#endif

    dwDriveCapacity /= ( 1024L * 100L );


    return( dwDriveCapacity );
}
#endif

#if defined(WIN32) || defined(_WIN32)

DWORD CHardware::CalculateDriveCapacityNT(INT nDrive)
{
    BOOL   fDriveExists;
    DWORD  dwDriveCapacity;
    DWORD  dwBytesReturned;
    CHAR   szDrive[ MAX_PATH ];
    CHAR   szDriveAssignment[ MAX_PATH ];

    dwDriveCapacity = 0;

    // Determine if Logical Drive Exists

    fDriveExists = FALSE;

    wsprintf( szDrive, "%c:", 'A' + ( nDrive - 1 ) );   // Create DOS Drive Identifier (A: or B:)

    dwBytesReturned = QueryDosDevice( szDrive, szDriveAssignment, MAX_PATH );

    if ( dwBytesReturned != 0 )
    {
        LPTSTR lpszWalkString;

        // DBCS-Enabled Terminate String At 2nd Backslash (1st Backslash always at Position 0)

        lpszWalkString = szDriveAssignment;

        do
        {
            lpszWalkString = CharNext( lpszWalkString );

            switch( *lpszWalkString )
            {
                case '\\':
                    *lpszWalkString = 0;
                    break;
            }
        }
        while( *lpszWalkString != 0 );

        // Determine if Logical Drive is Physically Present

        if ( lstrcmp( szDriveAssignment, "\\Device" ) == 0 )
        {
            fDriveExists = TRUE;
        }
    }

    if ( fDriveExists == TRUE )
    {
        // Get All Supported Media Types for Drive

        HANDLE hDevice;
        BOOL   fResult;

        wsprintf( szDrive, "\\\\.\\%c:", 'A' + ( nDrive - 1 ) ); // Create NT Drive Identifier (\\.\A: or \\.\B:)

        hDevice = CreateFile( szDrive, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );

        _ASSERT( hDevice != INVALID_HANDLE_VALUE );

        if ( hDevice != INVALID_HANDLE_VALUE )
        {
            DISK_GEOMETRY dGeometry[ 10 ];

            fResult = DeviceIoControl( hDevice, IOCTL_DISK_GET_MEDIA_TYPES, NULL, 0, (LPVOID)&dGeometry, sizeof( DISK_GEOMETRY ) * 10, &dwBytesReturned, NULL );

            _ASSERT( fResult );

            if ( fResult == TRUE )
            {
                // Calculate Maximum Media Size of Drive in Bytes if No Errors

                INT  nMediaCount;
                INT  nCurrentMedia;
                UINT uCurrentMediaCapacity;

                nMediaCount = dwBytesReturned / sizeof( DISK_GEOMETRY );

                for ( nCurrentMedia = 0; nCurrentMedia < nMediaCount; nCurrentMedia++ )
                {
                    uCurrentMediaCapacity  = (UINT)dGeometry[ nCurrentMedia ].Cylinders.LowPart;
                    uCurrentMediaCapacity *= (UINT)dGeometry[ nCurrentMedia ].TracksPerCylinder;
                    uCurrentMediaCapacity *= (UINT)dGeometry[ nCurrentMedia ].SectorsPerTrack;
                    uCurrentMediaCapacity *= (UINT)dGeometry[ nCurrentMedia ].BytesPerSector;

                    if ( uCurrentMediaCapacity > dwDriveCapacity )
                    {
                        dwDriveCapacity = uCurrentMediaCapacity;
                    }
                }
            }

            CloseHandle( hDevice );
        }
    }

    dwDriveCapacity /= ( 1024 * 100 );

    return( dwDriveCapacity );
}
#endif

VOID CHardware::SetVideoBIOSDigit()
{
    DWORD dwVideoBIOSChecksum;

#if defined(WIN32) || defined(_WIN32)
    if ( IsPlatformNT() )
    {
        dwVideoBIOSChecksum  = CalculateRegKeyChecksum( "VideoBiosDate" );
        dwVideoBIOSChecksum += CalculateRegKeyChecksum( "VideoBiosVersion" );

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        m_dwVideoBiosCrc32 = dwVideoBIOSChecksum;
#endif

    } else
#endif
    {

        LPBYTE pbMemoryByte;

#if defined(WIN32) || defined(_WIN32)
        pbMemoryByte = (LPBYTE)0xC0000;
#else
        pbMemoryByte = (LPBYTE)MAKELONG(0, &_C000H);
#endif
        dwVideoBIOSChecksum = CalculateMemoryRegionChecksum(pbMemoryByte, 2048);

#ifdef HWID_DETAIL ////////////////////////////////////////////////////////////
        m_dwVideoBiosCrc32 = CRC_32(pbMemoryByte, 2048);
#endif

    }

    m_szHardwareID[ VIDEO_BIOS_DIGIT ] = (CHAR)( dwVideoBIOSChecksum % 9 ) + '0';
}

#ifndef NO_HWID_GUID //////////////////////////////////////////////////////////

VOID CHardware::CalculateHardwareGUID()
{
    ULONG   uCRC;
    INT     nIndex;
    CCrc32 *lpCCrc32;
    CHAR    szCRCTemp[ 20 ];

    // Create Empty Template for GUID

    lstrcpy( m_szHardwareGUID, "{30303030-30DA-0000-0000-0020AFC36E79}" );

    // Add ASCII HWID to GUID

    for ( nIndex = 0; nIndex < lstrlen( m_szHardwareID ); nIndex++ )
    {
        switch( nIndex )
        {
            case 0:
            case 1:
            case 2:
            case 3:
                m_szHardwareGUID[ 2 + ( nIndex * 2 ) ] = m_szHardwareID[ nIndex ];
                break;

            case 4:
                m_szHardwareGUID[ 11 ] = m_szHardwareID[ nIndex ];
                break;

            default:
                _ASSERT( FALSE );
                break;
        }
    }

    // Calculate GUID CRC

    lpCCrc32 = new CCrc32();
    _ASSERT( lpCCrc32->uClassID == CCRC32_CLASSID );

    uCRC = lpCCrc32->CalculateBlockCRC( m_szHardwareGUID, lstrlen( m_szHardwareGUID ) );

    delete lpCCrc32;

    // Add CRC Result To GUID

    wsprintf( szCRCTemp, "%08X", uCRC );

    for ( nIndex = 0; nIndex < lstrlen( szCRCTemp ); nIndex++ )
    {
        switch( nIndex )
        {
            case 0:
            case 1:
            case 2:
            case 3:
                m_szHardwareGUID[ 15 + nIndex ] = szCRCTemp[ nIndex ];
                break;

            case 4:
            case 5:
            case 6:
            case 7:
                m_szHardwareGUID[ 16 + nIndex ] = szCRCTemp[ nIndex ];
                break;

            default:
                _ASSERT( FALSE );
                break;
        }
    }
}
#endif ////////////////////////////////////////////////////////////////////////


#if 0 /////////////////////////////////////////////////////////////////////////

// Test main() function

int PASCAL WinMain(
    HINSTANCE, // hInstance,  // handle to current instance
    HINSTANCE, // hPrevInstance,  // handle to previous instance
    LPSTR, // lpCmdLine,      // pointer to command line
    int // nCmdShow          // show state of window)
)
{

    CHardware hwid;

    MessageBox(
        NULL,
        (char *)hwid.GetGUID(),
        (char *)hwid.GetID(),
        MB_OK);

    return 0;
}

#endif ////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\precomp.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file.

Author:

    Jim Cavalaris (jamesca) 3-07-1999

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Win32 Public Header Files
//
#include <windows.h>


//
// CRT Header Files
//
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\restore.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    restore.c

Abstract:

    This module contains the following Plug and Play registry merge-restore
    routines:

        AsrRestorePlugPlayRegistryData

Author:

    Jim Cavalaris (jamesca) 3-07-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//

#include "precomp.h"
#include "util.h"
#include "debug.h"
#include <regstr.h>
#include <cfgmgr32.h>


//
// private memory allocation definitions
//

#define MyMalloc(size)         LocalAlloc(0, size);
#define MyFree(entry)          LocalFree(entry);
#define MyRealloc(entry,size)  LocalReAlloc(entry, size, 0);

//
// global variables to store the root keys we're working on.
//
// (we really shouldn't have to do this, but it's the easiest way for us to
// reach into one set of keys while recursing through the other set.)
//
HKEY    PnpSifRestoreSourceEnumKeyHandle  = NULL;
HKEY    PnpSifRestoreTargetEnumKeyHandle  = NULL;

HKEY    PnpSifRestoreSourceClassKeyHandle = NULL;
HKEY    PnpSifRestoreTargetClassKeyHandle = NULL;

//
// private definitions
//

// INVALID_FLAGS macro from pnp\inc\cfgmgrp.h
#define INVALID_FLAGS(ulFlags, ulAllowed) ((ulFlags) & ~(ulAllowed))

// private flags for internal RestoreSpecialRegistryData routine
#define PNPSIF_RESTORE_TYPE_DEFAULT                        (0x00000000)
#define PNPSIF_RESTORE_TYPE_ENUM                           (0x00000001)
#define PNPSIF_RESTORE_TYPE_CLASS                          (0x00000002)
#define PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION  (0x00000010)
#define PNPSIF_RESTORE_BITS                                (0x00000013)

// Enum level definitions describing the subkey types for the specified handles.
#define ENUM_LEVEL_ENUMERATORS  (0x0000003)
#define ENUM_LEVEL_DEVICES      (0x0000002)
#define ENUM_LEVEL_INSTANCES    (0x0000001)

// Class level definitions describing the subkey types for the specified handles.
#define CLASS_LEVEL_CLASSGUIDS  (0x0000002)
#define CLASS_LEVEL_DRVINSTS    (0x0000001)

//
// private prototypes
//

BOOL
RestoreEnumKey(
    IN  HKEY  hSourceEnumKey,
    IN  HKEY  hTargetEnumKey
    );

BOOL
RestoreClassKey(
    IN  HKEY  hSourceClassKey,
    IN  HKEY  hTargetClassKey
    );

BOOL
RestoreSpecialRegistryData(
    IN     HKEY   hSourceKey,
    IN     HKEY   hTargetKey,
    IN     ULONG  ulLevel,
    IN OUT PVOID  pContext,
    IN     ULONG  ulFlags
    );

BOOL
MyReplaceKey(
    IN  HKEY  hSourceKey,
    IN  HKEY  hTargetKey
    );

BOOL
IsString4DigitOrdinal(
    IN  LPTSTR  pszSubkeyName
    );

BOOL
IsDeviceConfigured(
    IN  HKEY  hInstanceKey
    );

BOOL
ReplaceClassKeyForInstance(
    IN  HKEY  hSourceInstanceKey,
    IN  HKEY  hSourceRootClassKey,
    IN  HKEY  hTargetRootClassKey
    );

//
// routines
//


BOOL
AsrRestorePlugPlayRegistryData(
    IN  HKEY    SourceSystemKey,
    IN  HKEY    TargetSystemKey,
    IN  DWORD   Flags,
    IN  PVOID   Reserved
    )
/*++

Routine Description:

    This routine restores plug and play data from the the specified source
    SYSTEM key to the specified target SYSTEM key, merging intermediate subkeys
    and values as appropriate.

Arguments:

    SourceSystemKey - Handle to the HKLM\SYSTEM key within the "source"
                      registry, whose data is to be "merged" into the
                      corresponding SYSTEM key of the "target" registry, as
                      specified by TargetSystemKey.

    TargetSystemKey - Handle to the HKLM\SYSTEM key within the "target"
                      registry, that is to receive additional data from the
                      corresponding SYSTEM key of the "source" registry, as
                      specified by SourceSystemKey.

    Flags           - Not used, must be zero.

    Reserved        - Reserved for future use, must be NULL.


Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

Notes:

    This routine was written specifically to assist in the restoration of the
    Plug-and-Play specific registry keys that cannot simply be restored from
    backup.  It is intended to be called within the context of a
    backup-and-restore application's "restore" phase.

    During a backup-and-restore application's "restore" phase, the registry that
    has been backed-up onto backup medium is to become the new system registry.
    Certain Plug and Play values and registry keys, are actually copied into the
    backed-up registry from the current registry.  Rather than using the backup
    registry, or the current registry exclusively, Plug and Play data contained
    in these keys should be merged from the current registry into the backup
    registry in a way that is appropriate for each key.  The backup registry can
    then safely replace the current registry as the system registry.

    In the context of a backup-and-restore application's "restore" phase, the
    "Source" registry key is the one contained in the current running system
    registry.  The "Target" registry is that which has been backed-up, and will
    become the system registry, upon reboot.

    The calling process must have both the SE_BACKUP_NAME and SE_RESTORE_NAME
    privileges.

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hSystemSelectKey = NULL;
    TCHAR  pszRegKeySelect[] = TEXT("Select");
    TCHAR  pszRegValueCurrent[] = TEXT("Current");
    TCHAR  szBuffer[128];
    DWORD  dwType, dwSize;
    DWORD  dwSourceCCS, dwTargetCCS;


    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if (Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make sure that the user supplied us with valid flags.
    //
    if(INVALID_FLAGS(Flags, 0x0)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    //
    // Determine the CurrentControlSet for the source.
    //
    result = RegOpenKeyEx(SourceSystemKey,
                          pszRegKeySelect,
                          0,
                          KEY_READ,
                          &hSystemSelectKey);

    if (result != ERROR_SUCCESS) {
        hSystemSelectKey = NULL;
        goto Clean0;
    }

    dwSize = sizeof(DWORD);
    result = RegQueryValueEx(hSystemSelectKey,
                             pszRegValueCurrent,
                             0,
                             &dwType,
                             (LPBYTE)&dwSourceCCS,
                             &dwSize);

    RegCloseKey(hSystemSelectKey);
    hSystemSelectKey = NULL;

    if ((result != ERROR_SUCCESS) ||
        (dwType != REG_DWORD)) {
        goto Clean0;
    }

    //
    // Determine the CurrentControlSet for the target.
    //
    result = RegOpenKeyEx(TargetSystemKey,
                          pszRegKeySelect,
                          0,
                          KEY_READ,
                          &hSystemSelectKey);

    if (result != ERROR_SUCCESS) {
        hSystemSelectKey = NULL;
        goto Clean0;
    }

    dwSize = sizeof(DWORD);
    result = RegQueryValueEx(hSystemSelectKey,
                             pszRegValueCurrent,
                             0,
                             &dwType,
                             (LPBYTE)&dwTargetCCS,
                             &dwSize);

    RegCloseKey(hSystemSelectKey);
    hSystemSelectKey = NULL;

    if ((result != ERROR_SUCCESS) ||
        (dwType != REG_DWORD)) {
        goto Clean0;
    }

    //
    // Open the source CurrentControlSet\Enum key.
    //
    wsprintf(szBuffer, TEXT("ControlSet%03d\\Enum"), dwSourceCCS);
    result = RegOpenKeyEx(SourceSystemKey,
                          szBuffer,
                          0,
                          KEY_READ, // only need to read from the source
                          &PnpSifRestoreSourceEnumKeyHandle);

    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // Open the target CurrentControlSet\Enum key.
    //
    wsprintf(szBuffer, TEXT("ControlSet%03d\\Enum"), dwTargetCCS);
    result = RegOpenKeyEx(TargetSystemKey,
                          szBuffer,
                          0,
                          KEY_ALL_ACCESS, // need full access to the target
                          &PnpSifRestoreTargetEnumKeyHandle);

    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // Open the source CurrentControlSet\Control\Class key.
    //
    wsprintf(szBuffer, TEXT("ControlSet%03d\\Control\\Class"), dwSourceCCS);
    result = RegOpenKeyEx(SourceSystemKey,
                          szBuffer,
                          0,
                          KEY_READ, // only need to read from the source
                          &PnpSifRestoreSourceClassKeyHandle);

    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // Open the target CurrentControlSet\Control\Class key.
    //
    wsprintf(szBuffer, TEXT("ControlSet%03d\\Control\\Class"), dwTargetCCS);
    result = RegOpenKeyEx(TargetSystemKey,
                          szBuffer,
                          0,
                          KEY_ALL_ACCESS, // need full access to the target
                          &PnpSifRestoreTargetClassKeyHandle);

    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // NOTE: We restore the Enum branch first, then restore the Class branch.
    // The code that restores these keys depends on it, so do not change this!!
    //
    // This order makes sense, because relevant Class keys correspond to exactly
    // one Enum instance key (but an Enum key may or may not have a Class key),
    // so Class keys are only really meaningful in the context of the instance
    // key they belong to.  This behavior should NOT need to change.
    //

    //
    // Do the merge-restore for the Enum keys, ignore any errors.
    //
    if (!RestoreEnumKey(PnpSifRestoreSourceEnumKeyHandle,
                        PnpSifRestoreTargetEnumKeyHandle)) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("PNPSIF: RestoreEnumKey failed with error == 0x%08lx\n"),
                   GetLastError()));
    }

    //
    // Do the merge-restore for the Class keys, ignore any errors.
    //
    if (!RestoreClassKey(PnpSifRestoreSourceClassKeyHandle,
                         PnpSifRestoreTargetClassKeyHandle)) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("PNPSIF: RestoreClassKey failed with error == 0x%08lx\n"),
                   GetLastError()));
    }

 Clean0:
    //
    // Close the open handles.
    //
    if (PnpSifRestoreSourceEnumKeyHandle) {
        RegCloseKey(PnpSifRestoreSourceEnumKeyHandle);
        PnpSifRestoreSourceEnumKeyHandle = NULL;
    }
    if (PnpSifRestoreTargetEnumKeyHandle) {
        RegCloseKey(PnpSifRestoreTargetEnumKeyHandle);
        PnpSifRestoreTargetEnumKeyHandle = NULL;
    }

    if (PnpSifRestoreSourceClassKeyHandle) {
        RegCloseKey(PnpSifRestoreSourceClassKeyHandle);
        PnpSifRestoreSourceClassKeyHandle = NULL;
    }
    if (PnpSifRestoreTargetClassKeyHandle) {
        RegCloseKey(PnpSifRestoreTargetClassKeyHandle);
        PnpSifRestoreTargetClassKeyHandle = NULL;
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }
    return (result == ERROR_SUCCESS);

} // AsrRestorePlugPlayRegistryData()



//
// private worker routines for AsrRestorePlugPlayRegistryData
//


BOOL
RestoreEnumKey(
    IN  HKEY  hSourceEnumKey,
    IN  HKEY  hTargetEnumKey
    )
/*++

Routine Description:

    Restores new device instances in the source (current) Enum key to the target
    Enum key, located in the backup registry to be restored.  By doing this, the
    Enum key from the backup set can safely replace the current Enum key.

    All intermediate values from the source (current) registry are restored to
    the target (backup), to account for the device instance hash values located
    at the root of the Enum key, that have been updated during setup.

    During an ASR backup and restore operation, the hash values in the source
    (current) registry are propogated to the current registry during textmode
    setup, as they are stored the asrpnp.sif file.  Since hash values may be
    modified by setup, the values in the source (current) registry will be more
    relevant than those in the target (backup), so source values should always
    be preseverd.

Arguments:

    hSourceEnumKey - Handle to the HKLM\SYSTEM\CurrentControlSet\Enum key within
                     the "source" registry, whose data is to be "merged" into
                     the corresponding SYSTEM key of the "target" registry, as
                     specified by hTargetEnumKey.

    hTargetEnumKey - Handle to the HKLM\SYSTEM\CurrentControlSet\Enum key within
                     the "target" registry, that is to receive additional data
                     from the corresponding SYSTEM key of the "source" registry,
                     as specified by hSourceEnumKey.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    BOOL bIsRootEnumerated = FALSE;

    return RestoreSpecialRegistryData(hSourceEnumKey,
                                      hTargetEnumKey,
                                      ENUM_LEVEL_ENUMERATORS, // (0x0000003)
                                      (PVOID)&bIsRootEnumerated,
                                      PNPSIF_RESTORE_TYPE_ENUM |
                                      PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION
                                      );

} // RestoreEnumKey



BOOL
RestoreClassKey(
    IN  HKEY  hSourceClassKey,
    IN  HKEY  hTargetClassKey
    )
/*++

Routine Description:

    Restores new elements of the source Class key to the target Class key,
    located in the backup registry to be restored.

    Intermediate values from the source registry are coied to the the target
    registry only when they do not already exist in the target.  Otherwise, the
    target values are preseved.

Arguments:

    hSourceClassKey - Handle to the HKLM\SYSTEM\CurrentControlSet\Control\Class
                      key within the "source" registry, whose data is to be
                      "merged" into the corresponding SYSTEM key of the "target"
                      registry, as specified by hTargetClassKey.

    hTargetClassKey - Handle to the HKLM\SYSTEM\CurrentControlSet\Control\Class
                      key within the "target" registry, that is to receive
                      additional data from the corresponding SYSTEM key of the
                      "source" registry, as specified by hSourceClassKey.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    return RestoreSpecialRegistryData(hSourceClassKey,
                                      hTargetClassKey,
                                      CLASS_LEVEL_CLASSGUIDS, // (0x00000002)
                                      (PVOID)NULL,
                                      PNPSIF_RESTORE_TYPE_CLASS
                                      );

} // RestoreClassKey



BOOL
RestoreSpecialRegistryData(
    IN     HKEY   hSourceKey,
    IN     HKEY   hTargetKey,
    IN     ULONG  ulLevel,
    IN OUT PVOID  pContext,
    IN     ULONG  ulFlags
    )
/*++

Routine Description:

    This routine restores the specified source key to the specified target key,
    merging intermediate subkeys and values.  Values in the subkeys located
    above the specified depth level are merged from the source into the target
    (with collisions handled according to the specified flags).  Subkeys and
    values at and below the level specified are merged from the source key to
    the target key, with subkeys from the sources replacing any corresponding
    subkeys in the target.


Arguments:

    hSourceKey - Handle to a key within the source registry, whose data is to be
                 "merged" into the corresponding key of the target registry, as
                 specified by hTargetKey.

    hTargetKey - Handle to a key within the target registry, that is to receive
                 data from the corresponding key of the source registry, as
                 specified by hSourceKey.

    ulLevel    - Specifies the subkey depth at which "replacement" will
                 take place.  For subkeys above that depth, data in the target
                 registry will be preserved if present, and copied otherwise.
                 For keys at the specified level, data from the specified target
                 key will be replaced by the source key.

    pContext   - Specifies caller-supplied context for the operation that is
                 specific to the type of subkeys being restored (see ulFlags
                 below), and the specified ulLevel parameter.

    ulFlags    - Supplies flags specifying options for the restoration of the
                 registry keys.  May be one of the following values:

                 PNPSIF_RESTORE_TYPE_ENUM:

                     Specifies that the subkeys being restored are subkeys of
                     the SYSTEM\CurrentControlSet\Enum branch.  Device hardware
                     settings can be inspected at the appropriate ulLevel.

                     For Enum branch subkeys, the ulLevel parameter describes
                     also the type of the subkeys contained under the hSourceKey
                     and hTargetKey keys.  May be one of:

                       ENUM_LEVEL_ENUMERATORS
                       ENUM_LEVEL_DEVICES
                       ENUM_LEVEL_INSTANCES

                 PNPSIF_RESTORE_TYPE_CLASS:

                     Specifies that the subkeys being restored are subkeys of
                     the SYSTEM\CurrentControlSet\Control\Class branch.  Setup
                     class or device software settings can be inspected at the
                     appropriate ulLevel.

                     For Class branch subkeys, the ulLevel parameter also
                     describes the type of the subkeys contained under the
                     hSourceKey and hTargetKey keys.  May be one of:

                       CLASS_LEVEL_CLASSGUIDS
                       CLASS_LEVEL_DRVINSTS

                 PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION:

                     When a collision occurs while merging values between the
                     source and target at intermediate levels, replace the
                     target value with that from the source (the default
                     behavior is to preserve existing target values above
                     'ulLevel' in depth from the supplied keys; below 'ulLevel',
                     only source key values will be present.)

                 NOTE: it's probably worth noting that a corresponding flag for
                 replace-target-keys-on-collision is not at all necessary, since
                 such a behavior can already be implemented with the ulLevel
                 parameter. (i.e. the ulLevel parameter actually specifies the
                 level at which all source keys will replace target keys; to
                 specify that this should ALWAYS be done is the same as
                 specifying ulLevel == 0)


Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

Notes:

    This routine was written specifically to assist in the restoration of the
    Plug-and-Play specific registry keys that cannot simply be restored from
    backup.  It is intended to be called within the context of a
    backup-and-restore application's "restore" phase.

    During a backup-and-restore application's "restore" phase, the registry that
    has been backed-up onto backup medium is to become the new system registry.
    Certain Plug and Play values and registry keys, are actually copied into the
    backed-up registry from the current registry.  Rather than using the backup
    registry, or the current registry exclusively, Plug and Play data contained
    in these keys should be merged from the current registry into the backup
    registry in a way that is appropriate for each key.  The backup registry can
    then safely replace the current registry as the system registry.

    In the context of a backup-and-restore application's "restore" phase, the
    "Source" registry key is the one contained in the current running system
    registry.  The "Target" registry is that which has been backed-up, and will
    become the system registry, upon reboot.

    The different restore behaviors required for each of the different sets of
    keys can be specified with the appropriate ulLevel, and ulFlags.

--*/
{
    LONG   result = ERROR_SUCCESS;
    DWORD  dwIndex = 0;
    DWORD  dwSubkeyCount, dwMaxSubkeyNameLength;
    DWORD  dwValueCount, dwMaxValueNameLength, dwMaxValueDataLength;
    DWORD  dwDisposition;
    LPTSTR pszSubkeyName = NULL, pszValueName = NULL;
    LPBYTE pValueData = NULL;
    BOOL   bPossibleRedundantInstanceKeys = FALSE;


    //
    // Validate parameters
    //
    if (INVALID_FLAGS(ulFlags, PNPSIF_RESTORE_BITS)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if ((hTargetKey == NULL) ||
        (hTargetKey == INVALID_HANDLE_VALUE) ||
        (hSourceKey == NULL) ||
        (hSourceKey == INVALID_HANDLE_VALUE)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (ulLevel == 0) {
        //
        // This is the level at which we should stop merging, so just replace
        // hTargetKey with hSourceKey, and we're done.
        //
        return MyReplaceKey(hSourceKey, hTargetKey);


    } else {
        //
        // At levels above the replacement level, perform a non-destructive
        // merge of intermediate subkeys and values; that is, only copy keys and
        // values from the source to the target if they do not already exist at
        // the target.  Otherwise, leave the target keys and values alone, and
        // keep traversing subkeys as necessary.
        //

        //
        // Find out information about the hSourceKey values and subkeys.
        //
        result = RegQueryInfoKey(hSourceKey,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwSubkeyCount,
                                 &dwMaxSubkeyNameLength,
                                 NULL,
                                 &dwValueCount,
                                 &dwMaxValueNameLength,
                                 &dwMaxValueDataLength,
                                 NULL,
                                 NULL);
        if (result != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("PNPSIF: RegQueryInfoKey returned error == 0x%08lx\n"),
                       result));
            goto Clean0;
        }

        //
        // Allocate space to fold the largest hSourceKey subkey, value and data.
        //
        dwMaxSubkeyNameLength++;
        pszSubkeyName = MyMalloc(dwMaxSubkeyNameLength * sizeof(TCHAR));
        if (pszSubkeyName == NULL) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("PNPSIF: MyMalloc failed allocating subkey name string, error == 0x%08lx\n"),
                       result));
            goto Clean0;
        }

        dwMaxValueNameLength++;
        pszValueName = MyMalloc(dwMaxValueNameLength * sizeof(TCHAR));
        if (pszValueName == NULL) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("PNPSIF: MyMalloc failed allocating value name string, error == 0x%08lx\n"),
                       result));
            goto Clean0;
        }

        pValueData = MyMalloc(dwMaxValueDataLength * sizeof(TCHAR));
        if (pValueData == NULL) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("PNPSIF: MyMalloc failed allocating value data buffer, error == 0x%08lx\n"),
                       result));
            goto Clean0;
        }


        //
        // Enumerate all hSourceKey values.
        //
        for (dwIndex = 0; dwIndex < dwValueCount; dwIndex++) {

            DWORD dwValueNameLength = dwMaxValueNameLength;
            DWORD dwValueDataLength = dwMaxValueDataLength;
            DWORD dwType;

            result = RegEnumValue(hSourceKey,
                                  dwIndex,
                                  pszValueName,
                                  &dwValueNameLength,
                                  0,
                                  &dwType,
                                  pValueData,
                                  &dwValueDataLength);

            if (result != ERROR_SUCCESS) {
                //
                // Error enumerating values - whatchya gonna do?
                // Just move on and try to merge subkeys the best we can?
                //
                DBGTRACE( DBGF_ERRORS,
                          (TEXT("PNPSIF: RegEnumValue returned error == 0x%08lx\n"),
                           result));
                goto EnumSubkeys;
            }

            DBGTRACE( DBGF_INFO,
                      (TEXT("PNPSIF: Enumerated value %d == '%ws' on hSourceKey.\n"),
                       dwIndex, pszValueName));

            //
            // Query to see if this value exists in the hTargetKey
            //
            result = RegQueryValueEx(hTargetKey,
                                     pszValueName,
                                     0,
                                     NULL,
                                     NULL,
                                     NULL);

            if ((result == ERROR_SUCCESS) &&
                !(ulFlags & PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION)) {
                //
                // The enumerated value already exists under the target key, and
                // we are NOT supposed to replace it.
                //
                DBGTRACE( DBGF_INFO,
                          (TEXT("PNPSIF: Value '%ws' already exists on hTargetKey.\n"),
                           pszValueName));

            } else if ((result == ERROR_FILE_NOT_FOUND) ||
                       (ulFlags & PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION)){
                //
                // The enumerated value doesn't exist under the target key, or
                // it does and we're supposed to replace it.
                //
                result = RegSetValueEx(hTargetKey,
                                       pszValueName,
                                       0,
                                       dwType,
                                       pValueData,
                                       dwValueDataLength);
                if (result != ERROR_SUCCESS) {
                    //
                    // Error setting value - whatchya gonna do?
                    // Just move on to the next enumerated value.
                    //
                    DBGTRACE( DBGF_ERRORS,
                              (TEXT("PNPSIF: RegSetValueEx failed setting value '%ws', error == 0x%08lx\n"),
                               pszValueName, result));
                }
            } else {
                //
                // RegQueryValueEx returned some other error - weird?
                //
                DBGTRACE( DBGF_ERRORS,
                          (TEXT("PNPSIF: RegQueryValueEx failed for value '%ws', error == 0x%08lx\n"),
                           pszValueName, result));
            }

        }


    EnumSubkeys:

        //
        // Perform special processing of the device instance subkeys.
        //
        if ((ulFlags & PNPSIF_RESTORE_TYPE_ENUM) &&
            (ARGUMENT_PRESENT(pContext)) &&
            (ulLevel == ENUM_LEVEL_INSTANCES)) {

            if (*((PBOOL)pContext)) {
                //
                // For root enumerated devices, check for the possibility that
                // redundant instance keys of a device might have been created
                // in the current registry, in which case we should ignore them
                // when migrating to the target registry.
                //

                //
                // The possibility of redundant root-enumerated device
                // instance keys exists when:
                //
                // - the device is root-enumerated
                //
                // - instances of this device already exist in the target hive
                //
                // a particular device instance is redundant if it is a newly
                // created instance in the target registry for a device where
                // other instances already exist.
                //
                DWORD dwTargetSubkeyCount = 0;
                if (RegQueryInfoKey(hTargetKey,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dwTargetSubkeyCount,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL) != ERROR_SUCCESS) {
                    dwTargetSubkeyCount = 0;
                }
                bPossibleRedundantInstanceKeys = (dwTargetSubkeyCount > 0);
            }
        }

        //
        // Enumerate all hSourceKey subkeys.
        //
        for (dwIndex = 0; dwIndex < dwSubkeyCount; dwIndex++) {

            HKEY  hTargetSubkey = NULL, hSourceSubkey = NULL;
            DWORD dwSubkeyNameLength = dwMaxSubkeyNameLength;

            result = RegEnumKeyEx(hSourceKey,
                                  dwIndex,
                                  pszSubkeyName,
                                  &dwSubkeyNameLength,
                                  0,
                                  NULL,
                                  NULL,
                                  NULL);
            if (result != ERROR_SUCCESS) {
                //
                // Error enumerating subkeys - whatchya gonna do?
                // There is nothing left to do, so just exit.
                //
                DBGTRACE( DBGF_ERRORS,
                          (TEXT("PNPSIF: RegEnumKeyEx returned error == 0x%08lx\n"),
                           result));
                goto Clean0;
            }

            DBGTRACE( DBGF_INFO,
                      (TEXT("PNPSIF: enumerated subkey %d == '%ws' on hSourceKey.\n"),
                       dwIndex, pszSubkeyName));

            //
            // Perform special processing of the Enum subkeys.
            //
            if ((ulFlags & PNPSIF_RESTORE_TYPE_ENUM) &&
                (ARGUMENT_PRESENT(pContext)) &&
                (ulLevel == ENUM_LEVEL_ENUMERATORS)) {
                //
                // At the start of the recursive enumeration for each
                // enumerator subkey, reset our (global) BOOL context
                // variable to keep track of whether subsequent device
                // subkeys represent "ROOT" enumerated devices.
                //
                PBOOL pbIsRootEnumerated = (PBOOL)pContext;

                *pbIsRootEnumerated =
                    (BOOL)(lstrcmpi((LPTSTR)pszSubkeyName,
                                    REGSTR_KEY_ROOTENUM) == 0);

            }

            //
            // Open this subkey in hSourceKey
            //
            result = RegOpenKeyEx(hSourceKey,
                                  pszSubkeyName,
                                  0,
                                  KEY_READ,
                                  &hSourceSubkey);

            if (result == ERROR_SUCCESS) {
                //
                // Attempt to open this subkey in the hTargetKey
                //
                result = RegOpenKeyEx(hTargetKey,
                                      pszSubkeyName,
                                      0,
                                      KEY_READ,
                                      &hTargetSubkey);

                if ((result != ERROR_SUCCESS) &&
                    (bPossibleRedundantInstanceKeys)  &&
                    (IsString4DigitOrdinal(pszSubkeyName))) {
                    //
                    // The subkey is a root-enumerated instance key with a
                    // 4-digit ordinal name (most-likely autogenerated), where
                    // we may have redundant keys.
                    //
                    // If this key doesn't exist in the target registry, it was
                    // likely a redundant, autogenerated instance created during
                    // setup because a previous autogenerated key (i.e. one we
                    // just migrated) already existed, we just won't migrate it.
                    //
                    ASSERT(ulFlags & PNPSIF_RESTORE_TYPE_ENUM);
                    ASSERT(ulLevel == ENUM_LEVEL_INSTANCES);
                    ASSERT((ARGUMENT_PRESENT(pContext)) && (*((PBOOL)pContext)));

                } else {

                    if (result == ERROR_SUCCESS) {
                        //
                        // We successfully opened the target subkey above (we
                        // just weren't supposed to delete it) so we should have
                        // a valid handle.
                        //
                        ASSERT(hTargetSubkey != NULL);
                        dwDisposition = REG_OPENED_EXISTING_KEY;

                    } else {
                        //
                        // Create the target subkey.
                        //
                        ASSERT(hTargetSubkey == NULL);

                        result = RegCreateKeyEx(hTargetKey,
                                                pszSubkeyName,
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_ALL_ACCESS,
                                                NULL,
                                                &hTargetSubkey,
                                                &dwDisposition);

                        if (result == ERROR_SUCCESS) {
                            ASSERT(dwDisposition == REG_CREATED_NEW_KEY);
                        }
                    }

                    if (result == ERROR_SUCCESS) {

                        //
                        // Check if the key had already existed.
                        //

                        if (dwDisposition == REG_CREATED_NEW_KEY) {
                            //
                            // We just created this key in the target to replace it
                            // with the corresponding key in the source.
                            //
                            if (!MyReplaceKey(hSourceSubkey, hTargetSubkey)) {
                                DBGTRACE( DBGF_ERRORS,
                                          (TEXT("PNPSIF: MyReplaceKey failed with error == 0x%08lx\n"),
                                           GetLastError()));
                            }

                        } else if ((ulFlags & PNPSIF_RESTORE_TYPE_ENUM) &&
                                   (ulLevel == ENUM_LEVEL_INSTANCES) &&
                                   (!IsDeviceConfigured(hTargetSubkey)) &&
                                   (IsDeviceConfigured(hSourceSubkey))) {
                            //
                            // If we are enumerating instances, check if the
                            // instance keys in the target and source are
                            // properly configured.
                            //

                            //
                            // If it is not configured in the target, but is
                            // configured in the source - then we DO want to
                            // replace the target instance key, because it might
                            // be some sort of critical device - like a boot
                            // device.  Even if it's not critical, if the device
                            // has not been seen since before the last upgrade
                            // *prior* to backup, we can't really have much
                            // confidence in those settings anyways.  If neither
                            // the target or source are configured, we may as
                            // well just keep the target, like we do for
                            // everything else.
                            //
                            if (MyReplaceKey(hSourceSubkey, hTargetSubkey)) {
                                //
                                // If we successfully replaced the target instance
                                // key for this device with the source, then also
                                // replace the corresponding Class key for this
                                // instance from the target with the Class key from
                                // the source.
                                //
                                // NOTE: this works because we always restore the
                                // Enum branch before retoring the Class branch, so
                                // the Class keys haven't been touched yet.
                                //

                                if (!ReplaceClassKeyForInstance(hSourceSubkey,
                                                                PnpSifRestoreSourceClassKeyHandle,
                                                                PnpSifRestoreTargetClassKeyHandle)) {
                                    DBGTRACE( DBGF_ERRORS,
                                              (TEXT("PNPSIF: ReplaceClassKeyForInstance failed with error == 0x%08lx\n"),
                                               GetLastError()));
                                }

                            } else {
                                DBGTRACE( DBGF_ERRORS,
                                          (TEXT("PNPSIF: MyReplaceKey failed with error == 0x%08lx\n"),
                                           GetLastError()));
                            }

                        } else if ((ulLevel-1) != 0) {
                            //
                            // We're still above the replacement level, and the key
                            // previously existed in the target, so we're not
                            // supposed to replace it.  Since the next level is NOT
                            // the replacement level, just follow the keys down
                            // recursively.
                            //
                            ASSERT(dwDisposition == REG_OPENED_EXISTING_KEY);

                            if (!RestoreSpecialRegistryData(hSourceSubkey,
                                                            hTargetSubkey,
                                                            ulLevel-1,
                                                            (PVOID)pContext,
                                                            ulFlags)) {
                                //
                                // Error handling the subkeys - whatcha gonna do?
                                //
                                DBGTRACE( DBGF_ERRORS,
                                          (TEXT("PNPSIF: RestoreSpecialRegistryData failed for subkey %ws at level %d, error == 0x%08lx\n"),
                                           pszSubkeyName, ulLevel-1,
                                           GetLastError()));
                            }
                        } else {
                            //
                            // The key already exists, so don't replace it.  Also,
                            // the next level is the replacement level, so don't
                            // recurse either (else we'd replace it).  Basically,
                            // just do nothing here.
                            //
                            ASSERT(ulLevel == 1);
                            ASSERT(dwDisposition == REG_OPENED_EXISTING_KEY);
                        }

                        //
                        // Close the open target subkey.
                        //
                        RegCloseKey(hTargetSubkey);

                    } else {
                        //
                        // could not open/create subkey in taget registry.
                        //
                        DBGTRACE( DBGF_ERRORS,
                                  (TEXT("PNPSIF: RegCreateKey failed to create target subkey %s with error == 0x%08lx\n"),
                                   pszSubkeyName, result));
                    }
                }

                //
                // Close the enumerated hSourceKey subkey.
                //
                RegCloseKey(hSourceSubkey);

            } else {
                //
                // Could not open the enumerated hSourceKey subkey.
                //
                DBGTRACE( DBGF_ERRORS,
                          (TEXT("PNPSIF: RegOpenKey failed to open existing subkey %s with error == 0x%08lx\n"),
                           pszSubkeyName, result));
            }

        } // for (dwIndex = 0; dwIndex < dwSubkeyCount; dwIndex++)

    } // (ulLevel != 0)


 Clean0:
    //
    // Free any allocated buffers
    //
    if (pszSubkeyName != NULL) {
        MyFree(pszSubkeyName);
    }
    if (pszValueName != NULL) {
        MyFree(pszValueName);
    }
    if (pValueData != NULL) {
        MyFree(pValueData);
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }
    return (result == ERROR_SUCCESS);

} // RestoreSpecialRegistryData



BOOL
MyReplaceKey(
    IN  HKEY  hSourceKey,
    IN  HKEY  hTargetKey
    )
/*++

Routine Description:

    This routine replaces the target registry key with the source registry key.
    This is done by performing a RegSaveKey on the source registry key to a
    temporary file, and restoring that file to the target registry key.  All
    data contained below the target registry key is lost.  The source registry
    key is not modified by this routine.

Arguments:

    hSourceKey   - Handle to the key that is the source of the restore operation.
                   All values and subkeys of the source key will be restored on
                   top of the target key.

    hTargetKey   - Handle to the key that is the target of the restore operation.
                   All values and subkeys of the source key will be restored on
                   top of this key, and all existing values and data underneath
                   this key will be lost.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

Notes:

    Since this routine uses the RegSaveKey and RegRestoreKey registry APIs, it
    is expected that the calling process have both the SE_BACKUP_NAME and
    SE_RESTORE_NAME privileges.

--*/
{
    LONG  result = ERROR_SUCCESS;
    TCHAR szTempFilePath[MAX_PATH];
    TCHAR szTempFileName[MAX_PATH];
    DWORD dwTemp;


    //
    // Use the temporary directory to store the saved registry key.
    //
    dwTemp = GetTempPath(MAX_PATH, szTempFilePath);
    if ((dwTemp == 0) || (dwTemp > MAX_PATH)) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("PNPSIF: GetTempPath failed, current directory will be specified.\n")));
        // current path specified with trailing '\', as GetTempPath would have.
        lstrcpy(szTempFileName, TEXT(".\\"));
    }

    //
    // Assign the saved registry key a temporary, unique filename.
    //
    if (!GetTempFileName(szTempFilePath,
                         TEXT("PNP"),
                         0, // make sure it's unique
                         szTempFileName)) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("PNPSIF: GetTempFileName failed with error == 0x%08lx, using hardcoded temp file name!\n"),
                   GetLastError()));
        lstrcpy(szTempFileName, szTempFilePath);
        lstrcat(szTempFileName, TEXT("~pnpreg.tmp"));
    }

    DBGTRACE( DBGF_INFO,
              (TEXT("PNPSIF: Using temporary filename: %ws\n"),
               szTempFileName));

    //
    // A side effect of requesting a "unique" filename from GetTempFileName is
    // that it automatically creates the file.  Unfortunately, RegSaveKey will
    // fail if the specified file already exists, so delete the file now.
    //
    if(pSifUtilFileExists(szTempFileName,NULL)) {
        DBGTRACE( DBGF_INFO,
                  (TEXT("PNPSIF: Temporary file %s exists, deleting.\n"),
                   szTempFileName));
        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTempFileName);
    }

    //
    // Save the source key to a file using the temporary file name.
    // (calling process must have the SE_BACKUP_NAME privilege)
    //
    result = RegSaveKey(hSourceKey,
                        szTempFileName,
                        NULL);
    if (result == ERROR_SUCCESS) {
        //
        // Restore the file to the target key.
        // (calling process must have the SE_RESTORE_NAME privilege)
        //
        result = RegRestoreKey(hTargetKey,
                               szTempFileName,
                               REG_FORCE_RESTORE);
        if (result != ERROR_SUCCESS) {
            //
            // Failed to restore the file to the target key!
            //
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("PNPSIF: RegRestoreKey from %ws failed with error == 0x%08lx\n"),
                       szTempFileName, result));
        } else {
            DBGTRACE( DBGF_INFO,
                      (TEXT("PNPSIF: Key replacement successful.\n")));
        }

        //
        // Delete the temporary file we created, now that we're done with it.
        //
        DBGTRACE( DBGF_INFO,
                  (TEXT("PNPSIF: Deleting temporary file %s.\n"),
                   szTempFileName));
        ASSERT(pSifUtilFileExists(szTempFileName,NULL));
        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTempFileName);

    } else {
        //
        // Failed to save the source key.
        //
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("PNPSIF: RegSaveKey to %ws failed with error == 0x%08lx\n"),
                   szTempFileName, result));
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }
    return (result == ERROR_SUCCESS);

} // MyReplaceKey



BOOL
IsString4DigitOrdinal(
    IN  LPTSTR  pszSubkeyName
    )
/*++

Routine Description:

    This routine checks if a subkey name has the form of a 4-digit decimal
    ordinal (e.g. "0000", "0001", ... , "9999"), that are typically given to
    auto-generated root-enumerated device instance ids - i.e. TEXT("%04u").

Arguments:

    pszSubkeyName - Subkey name to check.

Return Value:

    TRUE if the string has the form of a 4-digit ordinal string, FALSE
    otherwise.

--*/
{
    LPTSTR  p;
    ULONG   ulTotalLength = 0;

    if ((!ARGUMENT_PRESENT(pszSubkeyName)) ||
        (pszSubkeyName[0] == TEXT('\0'))) {
        return FALSE;
    }

    for (p = pszSubkeyName; *p; p++) {
        //
        // Count the caharcters in the string, and make sure its not longer than
        // 4 characters.
        //
        ulTotalLength++;
        if (ulTotalLength > 4) {
            return FALSE;
        }

        //
        // Check if the character is non-numeric, non-decimal.
        //
        if ((*p < TEXT('0'))  || (*p > TEXT('9'))) {
            return FALSE;
        }
    }

    if (ulTotalLength != 4) {
        return FALSE;
    }

    return TRUE;

} // IsString4DigitOrdinal



BOOL
IsDeviceConfigured(
    IN  HKEY  hInstanceKey
    )
/*++

Routine Description:

    This routine determines whether the device instance specified by the
    supplied registry key is configured or not. If a device has configflags, and
    CONFIGFLAG_REINSTALL or CONFIGFLAG_FAILEDINSTALL are not set then the
    device is considered configured.

Arguments:

    hInstanceKey  - Handle to a device instance registry key.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    BOOL  bDeviceConfigured = FALSE;
    DWORD dwSize, dwType, dwConfigFlags;

    if ((hInstanceKey == NULL) ||
        (hInstanceKey == INVALID_HANDLE_VALUE)) {
        return FALSE;
    }

    dwSize = sizeof(dwConfigFlags);

    if ((RegQueryValueEx(hInstanceKey,
                         REGSTR_VAL_CONFIGFLAGS,
                         0,
                         &dwType,
                         (LPBYTE)&dwConfigFlags,
                         &dwSize) == ERROR_SUCCESS) &&
        (dwType == REG_DWORD) &&
        !(dwConfigFlags & CONFIGFLAG_REINSTALL) &&
        !(dwConfigFlags & CONFIGFLAG_FAILEDINSTALL)) {

        bDeviceConfigured = TRUE;
    }

    return bDeviceConfigured;

} // IsDeviceConfigured



BOOL
ReplaceClassKeyForInstance(
    IN  HKEY  hSourceInstanceKey,
    IN  HKEY  hSourceRootClassKey,
    IN  HKEY  hTargetRootClassKey
    )
/*++

Routine Description:

    This routine replaces the class key corresponding to the specified device
    instance key (as specified by the "Driver" value in the instance key) in the
    target hive with the class key from the source.

Arguments:

    hSourceInstanceKey  - Handle to a device instance registry key in the source
                          hive.

    hSourceRootClassKey - Handle to the root of the Class branch in the source
                          hive - the same hive as the specified instance key.

    hTargetRootClassKey - Handle to the root of the Class branch in the target
                          hive.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    LONG  result = ERROR_SUCCESS;
    TCHAR szDriverKeyName[MAX_GUID_STRING_LEN + 5]; // "{ClassGUID}\XXXX"
    DWORD dwSize, dwType, dwDisposition;
    HKEY  hSourceClassSubkey = NULL, hTargetClassSubkey = NULL;

    if ((hSourceInstanceKey  == NULL) ||
        (hSourceInstanceKey  == INVALID_HANDLE_VALUE) ||
        (hSourceRootClassKey == NULL) ||
        (hSourceRootClassKey == INVALID_HANDLE_VALUE) ||
        (hTargetRootClassKey == NULL) ||
        (hTargetRootClassKey == INVALID_HANDLE_VALUE)) {
        return FALSE;
    }

    //
    // Read the REGSTR_VAL_DRIVER REG_SZ "Driver" value from the instance key.
    //
    szDriverKeyName[0] = TEXT('\0');
    dwSize = sizeof(szDriverKeyName);

    result = RegQueryValueEx(hSourceInstanceKey,
                             REGSTR_VAL_DRIVER,
                             0,
                             &dwType,
                             (LPBYTE)szDriverKeyName,
                             &dwSize);
    if (result == ERROR_FILE_NOT_FOUND) {
        //
        // No "Driver" value, so there's no class key to migrate, which is fine.
        //
        result = ERROR_SUCCESS;
        goto Clean0;

    } else if ((result != ERROR_SUCCESS) ||
               (dwType != REG_SZ)) {
        //
        // Any other error is a failure to read the value.
        //
        goto Clean0;
    }

    //
    // Open the "Driver" key in the source Class branch.
    //
    result = RegOpenKeyEx(hSourceRootClassKey,
                          szDriverKeyName,
                          0,
                          KEY_READ,
                          &hSourceClassSubkey);
    if (result != ERROR_SUCCESS) {
        //
        // The instance key had a "Driver" value, so a corresponding key
        // *should* exist.  If we couldn't open it, it's from some failure
        // besides that.
        //
        return FALSE;
    }

    //
    // Open / create the corresponding key in the target Class branch.
    //
    result = RegCreateKeyEx(hTargetRootClassKey,
                            szDriverKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hTargetClassSubkey,
                            &dwDisposition);
    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // Replace the target class subkey with the source.
    //
    if (!MyReplaceKey(hSourceClassSubkey, hTargetClassSubkey)) {
        result = GetLastError();
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("PNPSIF: MyReplaceKey failed with error == 0x%08lx\n"),
                   result));
    }

 Clean0:

    if (hTargetClassSubkey) {
        RegCloseKey(hTargetClassSubkey);
    }
    if (hSourceClassSubkey) {
        RegCloseKey(hSourceClassSubkey);
    }
    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }
    return (result == ERROR_SUCCESS);

} // ReplaceClassKeyForInstance



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\debug.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debug infrastructure for this component.
    (currently inactive)

Author:

    Jim Cavalaris (jamesca) 07-Mar-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// debug infrastructure
// (currently removed)
//

#if 0 //#if DBG // DBG

VOID
DebugMessage(LPTSTR format, ... );

#define DBGF_ERRORS                 0x00000001
#define DBGF_WARNINGS               0x00000002
#define DBGF_REGISTRY               0x00000010
#define DBGF_INFO                   0x00000020

extern DWORD   g_DebugFlag;

#define DBGTRACE(l, x)  (g_DebugFlag & (l) ? DebugMessage x : (VOID)0)
#define MYASSERT(x)     ASSERT(x)

#else   // !DBG

#define DBGTRACE(l, x)
#define MYASSERT(x)

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\util.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains the following private utility routines for the Plug and
    Play registry merge-restore routines:

        FileExists

Author:

    Jim Cavalaris (jamesca) 2-10-2000

Environment:

    User-mode only.

Revision History:

    10-February-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"


//
// definitions
//
#define MAX_GUID_STRING_LEN   39          // 38 chars + terminating NULL

//
// Declare data used in GUID->string conversion (from ole32\common\ccompapi.cxx).
//

static const BYTE  GuidMap[]  = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                  8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const TCHAR szDigits[] = TEXT("0123456789ABCDEF");


//
// routines
//


BOOL
pSifUtilFileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )
/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}



BOOL
pSifUtilStringFromGuid(
    IN  CONST GUID *Guid,
    OUT PTSTR       GuidString,
    IN  DWORD       GuidStringSize
    )
/*++

Routine Description:

    This routine converts a GUID into a null-terminated string which represents
    it.  This string is of the form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where x represents a hexadecimal digit.

    This routine comes from ole32\common\ccompapi.cxx.  It is included here to avoid linking
    to ole32.dll.  (The RPC version allocates memory, so it was avoided as well.)

Arguments:

    Guid - Supplies a pointer to the GUID whose string representation is
        to be retrieved.

    GuidString - Supplies a pointer to character buffer that receives the
        string.  This buffer must be _at least_ 39 (MAX_GUID_STRING_LEN) characters
        long.

Return Value:

    Returns TRUE if successful, FALSE if not.
    GetLastError() returns extended error info.

--*/
{
    CONST BYTE *GuidBytes;
    INT i;

    if(GuidStringSize < MAX_GUID_STRING_LEN) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    GuidBytes = (CONST BYTE *)Guid;

    *GuidString++ = TEXT('{');

    for(i = 0; i < sizeof(GuidMap); i++) {

        if(GuidMap[i] == '-') {
            *GuidString++ = TEXT('-');
        } else {
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *GuidString++ = TEXT('}');
    *GuidString   = TEXT('\0');

    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\util.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    util.h

Abstract:

    This module contains utility routines for the PnP registry merge-restore
    routines.

Author:

    Jim Cavalaris (jamesca) 2-10-2000

Environment:

    User-mode only.

Revision History:

    10-February-2000     jamesca

        Creation and initial implementation.

--*/

BOOL
pSifUtilFileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
pSifUtilStringFromGuid(
    IN  CONST GUID *Guid,
    OUT PTSTR       GuidString,
    IN  DWORD       GuidStringSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\migrate.c ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    migrate.c

Abstract:

    This module contains the code necessary for Plug and Play to prepare the
    necessary state during a winnt32.exe upgrade or an ASR (Automated System
    Recovery) backup operation.  Typically, these aspects of the Plug and Play
    registry are saved in a sif for later use, during the text-mode setup
    portion of an upgrade or ASR recovery operation.

Author:

    Jim Cavalaris (jamesca) 07-Mar-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "debug.h"
#include "util.h"

#include <aclapi.h>
#include <regstr.h>
#include <pnpmgr.h>
#include <cfgmgr32.h>


//
// definitions
//

// do the lock/unlock Enum security thing? (as taken from PNPREG)
#define DO_LOCK_UNLOCK 0


//
// memory allocation macros
// (always use LocalAlloc/LocalReAlloc so that the caller can LocalFree the
// returned buffer.)
//

#define MyMalloc(size)         LocalAlloc(0, size);
#define MyFree(entry)          LocalFree(entry);
#define MyRealloc(entry,size)  LocalReAlloc(entry, size, LMEM_MOVEABLE | LMEM_ZEROINIT);


//
// globals for the Enum branch lock/unlock and security routines - taken from PNPREG
// (we only need these if we're doing the Enum lock/unlock thing)
//

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

PSID     g_pAdminSid;
PSID     g_pSystemSid;
PSID     g_pWorldSid;

SECURITY_DESCRIPTOR g_DeviceParametersSD;
PACL     g_pDeviceParametersDacl;

SECURITY_DESCRIPTOR g_LockedPrivateKeysSD;
PACL     g_pLockedPrivateKeysDacl;

#if 0 //#if DBG // DBG
TCHAR   g_szCurrentKeyName[4096];
DWORD   g_dwCurrentKeyNameLength = 0;
#endif  // DBG

#endif  // DO_LOCK_UNLOCK


//
// public prototypes
//

BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    );


//
// private prototypes
//

BOOL
EnumerateDeviceKeys(
    IN     HKEY     CCSEnumKey,
    IN     LPTSTR   Enumerator,
    IN OUT LPTSTR  *pszDeviceInstanceSection,
    IN OUT LPTSTR  *pszDeviceInstanceCurrent,
    IN OUT DWORD   *dwDeviceInstanceSectionLength,
    IN OUT DWORD   *dwDeviceInstanceSectionRemaining
    );

BOOL
EnumerateInstanceKeys(
    IN     HKEY     EnumeratorKey,
    IN     LPTSTR   Enumerator,
    IN     LPTSTR   Device,
    IN OUT LPTSTR  *pszDeviceInstanceSection,
    IN OUT LPTSTR  *pszDeviceInstanceCurrent,
    IN OUT DWORD   *dwDeviceInstanceSectionLength,
    IN OUT DWORD   *dwDeviceInstanceSectionRemaining
    );

BOOL
EnumerateClassSubkeys(
    IN     HKEY     ClassKey,
    IN     LPTSTR   ClassKeyName,
    IN OUT LPTSTR  *pszClassKeySection,
    IN OUT LPTSTR  *pszClassKeyCurrent,
    IN OUT DWORD   *dwClassKeySectionLength,
    IN OUT DWORD   *dwClassKeySectionRemaining
    );

BOOL
CanStringBeMigrated(
    IN LPTSTR       pszBuffer
    );


// we only need these if we're doing the Enum lock/unlock thing
#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

VOID
LockUnlockEnumTree(
    IN  BOOL     bLock
    );

VOID
EnumKeysAndApplyDacls(
    IN HKEY      hParentKey,
    IN LPTSTR    pszKeyName,
    IN DWORD     dwLevel,
    IN BOOL      bInDeviceParameters,
    IN BOOL      bApplyTopDown,
    IN PSECURITY_DESCRIPTOR pPrivateKeySD,
    IN PSECURITY_DESCRIPTOR pDeviceParametersSD
    );

BOOL
CreateSecurityDescriptors(
    VOID
    );

VOID
FreeSecurityDescriptors(
    VOID
    );

#endif // DO_LOCK_UNLOCK


//
// Device instance enumeration routines
//


BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    )
/*++

Routine Description:

    This routine walks the Plug and Play Enum tree in the registry, and collects
    the data that is relevant to restoring this state during textmode setup.

    Specifically, a multi-sz string will be returned to the caller that contains
    migration data for the UniqueParentID, ParentIdPrefix, and Driver registry
    values for all device instances in the Enum tree.

Arguments:

    Buffer - Supplies the address of a character pointer, that on success will
             contain a multi-sz list of device instances and relevant values to
             migrate.

             The caller is responsible for freeing the memory via LocalFree.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hEnumKey = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, i;
    LPTSTR pszEnumerator = NULL;

    LPTSTR pszDeviceInstanceSection = NULL;
    LPTSTR pszDeviceInstanceCurrent = NULL;

    DWORD  dwDeviceInstanceSectionLength = 0;
    DWORD  dwDeviceInstanceSectionRemaining = 0;


    //
    // Initialize the output parameter.
    //
    *Buffer = NULL;

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

    //
    // Unlock the Enum key.
    //
    LockUnlockEnumTree(FALSE);

#endif // DO_LOCK_UNLOCK

    //
    // Allocate storage and initialize variables for the device instance
    // migration section.
    //
    if (pszDeviceInstanceSection == NULL) {

        dwDeviceInstanceSectionLength = dwDeviceInstanceSectionRemaining = 256;
        pszDeviceInstanceSection = MyMalloc(dwDeviceInstanceSectionLength * sizeof(TCHAR));

        if (!pszDeviceInstanceSection) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("MigrateDeviceInstanceData: initial ALLOC for ClassKeySection failed!!\n") ));
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        pszDeviceInstanceCurrent = pszDeviceInstanceSection;
    }

    //
    // Open a handle to the HKLM\SYSTEM\CCS\Enum key.
    //
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_SYSTEMENUM,
                          0,
                          KEY_READ,
                          &hEnumKey);
    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateDeviceInstanceData: failed to open %s, error=0x%08lx\n"),
                   REGSTR_PATH_SYSTEMENUM, result));
        goto Clean0;
    }

    //
    // Query the Enum key for enumerator subkey information.
    //
    result = RegQueryInfoKey(hEnumKey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateDeviceInstanceData: failed to query %s key, error=0x%08lx\n"),
                   REGSTR_PATH_SYSTEMENUM, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest enumerator key name.
    //
    dwMaxSubKeyLength++;
    pszEnumerator = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszEnumerator) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateDeviceInstanceData: failed to allocate buffer for Enum subkeys\n") ));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    //
    // Enumerate the enumerator subkeys.
    //
    for (i = 0; i < dwSubkeyCount; i++) {
        DWORD dwEnumeratorLength = dwMaxSubKeyLength;

        result = RegEnumKeyEx(hEnumKey,
                              i,
                              pszEnumerator,
                              &dwEnumeratorLength,
                              0,
                              NULL,
                              NULL,
                              NULL);
        if (result != ERROR_SUCCESS) {
            //
            // If there was some error enumerating this key, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE( DBGF_WARNINGS,
                      (TEXT("MigrateDeviceInstanceData: failed to enumerate an enumerator subkey, error=0x%08lx\n"),
                       result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Enumerate the devices and device instances for this enumerator, and
        // append the migration data for each to the section buffer.
        //
        if (!EnumerateDeviceKeys(hEnumKey,
                                 pszEnumerator,
                                 &pszDeviceInstanceSection,
                                 &pszDeviceInstanceCurrent,
                                 &dwDeviceInstanceSectionLength,
                                 &dwDeviceInstanceSectionRemaining)) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("MigrateDeviceInstanceData: EnumerateDeviceKeys failed, error=0x%08lx\n"),
                       GetLastError()));
        }

    }

    //
    // Once we've enumerated all device instances, add the final NULL terminator
    // to the multi-sz buffer.  There must be enough space for the final NULL
    // terminator because the buffer is always reallocated unless there is room.
    //
    MYASSERT(dwDeviceInstanceSectionRemaining > 0);

    MYASSERT(pszDeviceInstanceCurrent);
    *pszDeviceInstanceCurrent = TEXT('\0');

    dwDeviceInstanceSectionRemaining -= 1;

 Clean0:

    //
    // Do some cleanup.
    //
    if (pszEnumerator) {
        MyFree(pszEnumerator);
    }

    if (hEnumKey) {
        RegCloseKey(hEnumKey);
    }

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

    //
    // Lock the Enum tree.
    //
    LockUnlockEnumTree(TRUE);

#endif // DO_LOCK_UNLOCK

    //
    // Return the buffer to the caller only if successful.
    //
    if (result == ERROR_SUCCESS) {
        *Buffer = pszDeviceInstanceSection;
    } else {
        SetLastError(result);
        if (pszDeviceInstanceSection) {
            MyFree(pszDeviceInstanceSection);
        }
    }
    return (result == ERROR_SUCCESS);

} // MigrateDeviceInstanceData()



BOOL
EnumerateDeviceKeys(
    IN     HKEY     CCSEnumKey,
    IN     LPTSTR   Enumerator,
    IN OUT LPTSTR  *pszDeviceInstanceSection,
    IN OUT LPTSTR  *pszDeviceInstanceCurrent,
    IN OUT DWORD   *dwDeviceInstanceSectionLength,
    IN OUT DWORD   *dwDeviceInstanceSectionRemaining
    )
/*++

Routine Description:

    Enumerates device keys of an enumerator.
    Worker routine for MigrateDeviceInstanceData.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result;
    HKEY   hEnumeratorKey = NULL;
    LPTSTR pszDeviceName = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, dwDeviceLength, i;


    //
    // Open the enumerator key, under HKLM\SYSTEM\CCS\Enum.
    //
    result = RegOpenKeyEx(CCSEnumKey,
                          Enumerator,
                          0,
                          KEY_READ,
                          &hEnumeratorKey);

    if (result != ERROR_SUCCESS) {
        //
        // If we failed to open the Enumerator key, there's nothing we can do.
        //
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateDeviceKeys: failed to open '%s' enumerator key, error=0x%08lx\n"),
                   Enumerator, result));
        goto Clean0;
    }

    //
    // Query the enumerator key for device subkey information.
    //
    result = RegQueryInfoKey(hEnumeratorKey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateDeviceKeys: failed to query '%s' enumerator key, error=0x%08lx\n"),
                   Enumerator, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest device subkey name.
    //
    dwMaxSubKeyLength++;
    pszDeviceName = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszDeviceName) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateDeviceKeys: failed to allocate buffer for device subkeys of '%s'\n"),
                   Enumerator));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    //
    // Enumerate the enumerator's devices.
    //
    for (i = 0; i < dwSubkeyCount; i++) {
        dwDeviceLength = dwMaxSubKeyLength;
        result = RegEnumKeyEx(hEnumeratorKey,
                              i,
                              pszDeviceName,
                              &dwDeviceLength,
                              0,
                              NULL,
                              NULL,
                              NULL);
        if (result != ERROR_SUCCESS) {
            //
            // If there was some error enumerating this device key, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE( DBGF_WARNINGS,
                      (TEXT("EnumerateDeviceKeys: failed to enumerate device subkey for '%s', error=0x%08lx\n"),
                       Enumerator, result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Enumerate the device instances, and append the migration data for
        // each to the section buffer.
        //
        if (!EnumerateInstanceKeys(hEnumeratorKey,
                                   Enumerator,
                                   pszDeviceName,
                                   pszDeviceInstanceSection,
                                   pszDeviceInstanceCurrent,
                                   dwDeviceInstanceSectionLength,
                                   dwDeviceInstanceSectionRemaining)) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumerateDeviceKeys: EnumerateInstanceKeys failed for %s\\%s, error=0x%08lx\n"),
                       Enumerator, pszDeviceName, GetLastError()));
        }
    }

 Clean0:

    //
    // Do some cleanup
    //
    if (pszDeviceName) {
        MyFree(pszDeviceName);
    }

    if (hEnumeratorKey) {
        RegCloseKey(hEnumeratorKey);
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }

    return (result == ERROR_SUCCESS);

} // EnumerateDeviceKeys()



BOOL
EnumerateInstanceKeys(
    IN     HKEY     EnumeratorKey,
    IN     LPTSTR   Enumerator,
    IN     LPTSTR   Device,
    IN OUT LPTSTR  *pszDeviceInstanceSection,
    IN OUT LPTSTR  *pszDeviceInstanceCurrent,
    IN OUT DWORD   *dwDeviceInstanceSectionLength,
    IN OUT DWORD   *dwDeviceInstanceSectionRemaining
    )
/*++

Routine Description:

    Enumerates instance keys of a device.
    Worker routine for EnumerateDeviceKeys,MigrateDeviceInstanceData.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hDeviceKey = NULL;
    LPTSTR pszDeviceInstanceId = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, dwSpaceNeeded, dwSpaceConsumed, i;
    BOOL   bIsDeviceRootEnumerated;

    //
    // Keep track of whether this is a ROOT enumerated device.
    //
    bIsDeviceRootEnumerated = (lstrcmpi(Enumerator, REGSTR_KEY_ROOTENUM) == 0);

    //
    // If this is a LEGACY_ ROOT enumerated device, don't bother migrating it
    // for textmode setup to see.
    //
    if (bIsDeviceRootEnumerated) {
        if (wcsncmp(Device,
                    TEXT("LEGACY_"),
                    lstrlen(TEXT("LEGACY_"))) == 0) {
            return TRUE;
        }
    }

    //
    // Open the device key, under the enumerator key.
    //
    result = RegOpenKeyEx(EnumeratorKey,
                          Device,
                          0,
                          KEY_READ,
                          &hDeviceKey);

    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateInstanceKeys: failed to open '%s\\%s' device key, error=0x%08lx\n"),
                   Enumerator, Device, result));
        goto Clean0;
    }

    //
    // Query the device key for instance subkey information.
    //
    result = RegQueryInfoKey(hDeviceKey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateInstanceKeys: failed to query '%s\\%s' device key, error=0x%08lx\n"),
                   Enumerator, Device, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest device instance subkey name.
    //
    dwMaxSubKeyLength++;
    pszDeviceInstanceId = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszDeviceInstanceId) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateInstanceKeys: failed to allocate buffer for instance subkeys of '%s\\%s'\n"),
                   Enumerator, Device));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    //
    // Enumerate the device's instances.
    //
    for (i = 0; i < dwSubkeyCount; i++) {

        DWORD  dwInstanceLength, dwType, dwBufferSize;
        DWORD  dwUniqueParentID, dwFirmwareIdentified;
        TCHAR  szParentIdPrefix[MAX_PATH];
        TCHAR  szUniqueParentID[11], szFirmwareIdentified[11];
        TCHAR  szDriver[2*MAX_PATH + 1];
        GUID   classGuid;
        DWORD  dwDrvInst;
        HKEY   hInstanceKey = NULL, hLogConfKey = NULL;
        TCHAR  szService[MAX_PATH];
        PBYTE  pBootConfig = NULL;
        LPTSTR pszBootConfig = NULL;
        DWORD  dwBootConfigSize = 0;

        dwInstanceLength = dwMaxSubKeyLength;
        result = RegEnumKeyEx(hDeviceKey,
                              i,
                              pszDeviceInstanceId,
                              &dwInstanceLength,
                              0,
                              NULL,
                              NULL,
                              NULL);
        if (result != ERROR_SUCCESS) {
            //
            // If there was some error enumerating this key, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE( DBGF_WARNINGS,
                      (TEXT("EnumerateInstanceKeys: failed to enumerate instance subkey of '%s\\%s', error=0x&08lx\n"),
                       Enumerator, Device, result));
            result = ERROR_SUCCESS;
            continue;
        }

        result = RegOpenKeyEx(hDeviceKey,
                              pszDeviceInstanceId,
                              0,
                              KEY_READ,
                              &hInstanceKey);
        if (result != ERROR_SUCCESS) {
            DBGTRACE( DBGF_WARNINGS,
                      (TEXT("EnumerateInstanceKeys: failed to open '%s\\%s\\%s', error=0x%08lx\n"),
                       Enumerator, Device, pszDeviceInstanceId, result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Check for the "UniqueParentID" value
        //
        dwBufferSize = sizeof(dwUniqueParentID);
        result = RegQueryValueEx(hInstanceKey,
                                 REGSTR_VALUE_UNIQUE_PARENT_ID,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwUniqueParentID,
                                 &dwBufferSize);
        if ((result == ERROR_SUCCESS) &&
            (dwType == REG_DWORD)){
            //
            // Write the UniqueParentID value to the sif as a base 16 value.
            // (see admin\ntsetup\textmode\kernel\spsetup.c)
            //
            wsprintf(szUniqueParentID,
                     TEXT("%X"), // base 16
                     dwUniqueParentID);
        } else {
            //
            // No "UniqueParentID" value to migrate.
            //
            *szUniqueParentID = TEXT('\0');
        }

        //
        // Check for the "ParentIdPrefix" value
        //
        dwBufferSize = sizeof(szParentIdPrefix);
        result = RegQueryValueEx(hInstanceKey,
                                 REGSTR_VALUE_PARENT_ID_PREFIX,
                                 0,
                                 &dwType,
                                 (LPBYTE)szParentIdPrefix,
                                 &dwBufferSize);
        if ((result != ERROR_SUCCESS) ||
            (dwType != REG_SZ)) {
            //
            // No "ParentIdPrefix" value to migrate.
            //
            *szParentIdPrefix = TEXT('\0');
            result = ERROR_SUCCESS;
        }

        //
        // Build the device's Driver key name by checking for the GUID and
        // DrvInst values.
        //
        *szDriver = TEXT('\0');
        dwBufferSize = sizeof(classGuid);
        result = RegQueryValueEx(hInstanceKey,
                                 TEXT("GUID"),
                                 0,
                                 &dwType,
                                 (LPBYTE)&classGuid,
                                 &dwBufferSize);

        if ((result == ERROR_SUCCESS) &&
            (dwType == REG_BINARY)) {
            //
            // Get the DrvInst value for the driver key
            //
            dwBufferSize = sizeof(dwDrvInst);
            result = RegQueryValueEx(hInstanceKey,
                                     TEXT("DrvInst"),
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwDrvInst,
                                     &dwBufferSize);
            if ((result == ERROR_SUCCESS) &&
                (dwType == REG_DWORD)) {
                if (pSifUtilStringFromGuid(&classGuid,
                                   szDriver,
                                   sizeof(szDriver)/sizeof(TCHAR))) {
                    //
                    // Build the driver key
                    //
                    wsprintf((LPWSTR)szDriver, TEXT("%s\\%04u"), szDriver, dwDrvInst);
                } else {
                    result = GetLastError();
                }
            } else {
                //
                // Generic error value so we try to find the driver value using
                // the old scheme.
                //
                result = ERROR_INVALID_PARAMETER;
            }
        } else {
            //
            // Generic error value so we try to find the driver value using
            // the old scheme.
            //
            result = ERROR_INVALID_PARAMETER;
        }

        //
        // If this device instance key is not using the new GUID\DrvInst
        // scheme, check for the "Driver" value
        //
        if (result != ERROR_SUCCESS) {
            dwBufferSize = sizeof(szDriver);
            result = RegQueryValueEx(hInstanceKey,
                                     REGSTR_VAL_DRIVER,
                                     0,
                                     &dwType,
                                     (LPBYTE)szDriver,
                                     &dwBufferSize);

            if ((result != ERROR_SUCCESS) ||
                (dwType != REG_SZ)) {
                //
                // No "Driver" value to migrate.
                //
                *szDriver = TEXT('\0');
                result = ERROR_SUCCESS;
            }
        }

        //
        // If this is a ROOT enumerated device, check for Service, BootConfig
        // and FirmwareIdentified values.
        //
        if (bIsDeviceRootEnumerated) {
            //
            // Check for the "Service" value.
            //
            dwBufferSize = sizeof(szService);
            result = RegQueryValueEx(hInstanceKey,
                                     REGSTR_VAL_SERVICE,
                                     0,
                                     &dwType,
                                     (LPBYTE)szService,
                                     &dwBufferSize);
            if ((result != ERROR_SUCCESS) ||
                (dwType != REG_SZ)) {
                //
                // No "Service" value to migrate.
                //
                *szService = TEXT('\0');
                result = ERROR_SUCCESS;
            }

            //
            // Check for the "LogConf\BootConfig" value.
            //
            result = RegOpenKeyEx(hInstanceKey,
                                  REGSTR_KEY_LOGCONF,
                                  0,
                                  KEY_READ,
                                  &hLogConfKey);
            if (result == ERROR_SUCCESS) {
                result = RegQueryValueEx(hLogConfKey,
                                         REGSTR_VAL_BOOTCONFIG,
                                         0,
                                         &dwType,
                                         (LPBYTE)NULL,
                                         &dwBootConfigSize);
                if ((result == ERROR_SUCCESS) &&
                    (dwType == REG_RESOURCE_LIST)) {

                    pBootConfig = MyMalloc(dwBootConfigSize);
                    if (pBootConfig) {
                        result = RegQueryValueEx(hLogConfKey,
                                                 REGSTR_VAL_BOOTCONFIG,
                                                 0,
                                                 &dwType,
                                                 (LPBYTE)pBootConfig,
                                                 &dwBootConfigSize);
                        if ((result == ERROR_SUCCESS) &&
                            (dwType == REG_RESOURCE_LIST)) {
                            //
                            // Allocate a string buffer large enough to store
                            // each nibble of the BootConfig data as a separate
                            // character.
                            //
                            pszBootConfig = MyMalloc((dwBootConfigSize*2 + 1)*sizeof(TCHAR));

                            if (pszBootConfig) {
                                DWORD b;
                                //
                                // Convert the binary BootConfig data to a string
                                // format that we can throw into the sif.
                                //
                                for (b = 0; b < dwBootConfigSize; b++) {
                                    // first write the high-order nibble,
                                    wsprintf((PTCHAR)&pszBootConfig[2*b],
                                             TEXT("%X"),
                                             pBootConfig[b] / (0x10));
                                    // then the low order nibble.
                                    wsprintf((PTCHAR)&pszBootConfig[2*b + 1],
                                             TEXT("%X"),
                                             pBootConfig[b] % (0x10));
                                }
                            }
                        }

                        MyFree(pBootConfig);
                        pBootConfig = NULL;
                    }
                } else {
                    //
                    // No "LogConf\BootConfig" value to migrate.
                    //
                    pszBootConfig = NULL;
                }
                RegCloseKey(hLogConfKey);
            }

            //
            // Check for the "FirmwareIdentified" value
            //
            dwBufferSize = sizeof(dwFirmwareIdentified);
            result = RegQueryValueEx(hInstanceKey,
                                     REGSTR_VAL_FIRMWAREIDENTIFIED,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwFirmwareIdentified,
                                     &dwBufferSize);
            if ((result == ERROR_SUCCESS) &&
                (dwType == REG_DWORD)){
                //
                // Write the FirmwareIdentified value to the sif as a base 16 value.
                // (see admin\ntsetup\textmode\kernel\spsetup.c)
                //
                wsprintf(szFirmwareIdentified,
                         TEXT("%X"), // base 16
                         dwFirmwareIdentified);
            } else {
                //
                // No "FirmwareIdentified" value to migrate.
                //
                *szFirmwareIdentified = TEXT('\0');
            }

        } else {
            //
            // We only migrate Service, BootConfig, and FirmwareIdentified
            // values for Root enumerated devices.
            //
            *szService = TEXT('\0');
            pszBootConfig = NULL;
            *szFirmwareIdentified = TEXT('\0');
        }


        //
        // If there are no values to migrate for this device instance, skip it.
        //
        if (!*szUniqueParentID &&
            !*szDriver &&
            !*szParentIdPrefix &&
            !*szService &&
            !pszBootConfig &&
            !*szFirmwareIdentified) {
            continue;
        }

        //
        // If any of the strings cannot be migrated, skip it.
        //
        if ((!CanStringBeMigrated(szDriver))   ||
            (!CanStringBeMigrated(szService))  ||
            (!CanStringBeMigrated(Enumerator)) ||
            (!CanStringBeMigrated(Device))     ||
            (!CanStringBeMigrated(pszDeviceInstanceId))) {
            continue;
        }

        //
        // This block appends the class key data we want to migrate to a
        // multi-sz style string that will be written to the sif file.
        //

        //
        // Need space in the section buffer for a string of the form:
        //     Enumerator\Device\Instance,UniqueParentID,ParentIdPrefix,DriverKey,Service,BootConfig
        //

        //
        // First, determine the space required by the common parts.
        //
        dwSpaceNeeded = 1 +  // TEXT('\"')
                        lstrlen(Enumerator) +
                        1 +  // TEXT('\\')
                        lstrlen(Device) +
                        1 +  // TEXT('\\')
                        lstrlen(pszDeviceInstanceId) +
                        1 +  // TEXT('\"')
                        1;   // TEXT(',')

        //
        // Next, determine the space required, based on the data we have.
        //
        if (*szFirmwareIdentified) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix) +
                1 +  // TEXT(',')
                lstrlen(szDriver) +
                1 +  // TEXT(',')
                1 +  // TEXT('"')
                lstrlen(szService) +
                1 +  // TEXT('"')
                1 +  // TEXT(',')
                (pszBootConfig ? lstrlen(pszBootConfig) : 0) +
                1 +  // TEXT(',')
                lstrlen(szFirmwareIdentified);
        } else if (pszBootConfig) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix) +
                1 +  // TEXT(',')
                lstrlen(szDriver) +
                1 +  // TEXT(',')
                1 +  // TEXT('"')
                lstrlen(szService) +
                1 +  // TEXT('"')
                1 +  // TEXT(',')
                lstrlen(pszBootConfig);
        } else if (*szService) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix) +
                1 +  // TEXT(',')
                lstrlen(szDriver) +
                1 +  // TEXT(',')
                1 +  // TEXT('"')
                lstrlen(szService) +
                1;   // TEXT('"')
        } else if (*szDriver) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix) +
                1 +  // TEXT(',')
                lstrlen(szDriver);
        } else if (*szParentIdPrefix) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix);
        } else if (*szUniqueParentID) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID);
        }

        //
        // Account for the NULL terminator.
        //
        dwSpaceNeeded += 1;

        if (*dwDeviceInstanceSectionRemaining <= dwSpaceNeeded) {
            //
            // ReAllocate the section block.
            //
            LPTSTR p;
            DWORD  dwTempSectionLength, dwTempSectionRemaining;

            dwTempSectionRemaining = *dwDeviceInstanceSectionRemaining + *dwDeviceInstanceSectionLength;
            dwTempSectionLength = *dwDeviceInstanceSectionLength * 2;

            p = *pszDeviceInstanceSection;
            p = MyRealloc(p,
                          dwTempSectionLength*sizeof(TCHAR));

            if (!p) {
                DBGTRACE( DBGF_ERRORS,
                          (TEXT("EnumerateInstanceKeys: REALLOC failed!!!\n") ));
                result = ERROR_NOT_ENOUGH_MEMORY;
                RegCloseKey(hInstanceKey);
                goto Clean0;
            }

            *pszDeviceInstanceSection = p;
            *dwDeviceInstanceSectionRemaining = dwTempSectionRemaining;
            *dwDeviceInstanceSectionLength = dwTempSectionLength;

            *pszDeviceInstanceCurrent = *pszDeviceInstanceSection +
                (*dwDeviceInstanceSectionLength -
                 *dwDeviceInstanceSectionRemaining);
        }

        //
        // Write the current line to the section block.
        //
        if (*szFirmwareIdentified) {
            dwSpaceConsumed = wsprintf(*pszDeviceInstanceCurrent,
                                       TEXT("\"%s\\%s\\%s\",%s,%s,%s,\"%s\",%s,%s"),
                                       Enumerator, Device, pszDeviceInstanceId,
                                       szUniqueParentID,
                                       szParentIdPrefix,
                                       szDriver,
                                       szService,
                                       (pszBootConfig ? pszBootConfig : TEXT("\0")),
                                       szFirmwareIdentified);
        } else if (pszBootConfig) {
            dwSpaceConsumed = wsprintf(*pszDeviceInstanceCurrent,
                                       TEXT("\"%s\\%s\\%s\",%s,%s,%s,\"%s\",%s"),
                                       Enumerator, Device, pszDeviceInstanceId,
                                       szUniqueParentID,
                                       szParentIdPrefix,
                                       szDriver,
                                       szService,
                                       pszBootConfig);
        } else if (*szService) {
            dwSpaceConsumed = wsprintf(*pszDeviceInstanceCurrent,
                                       TEXT("\"%s\\%s\\%s\",%s,%s,%s,\"%s\""),
                                       Enumerator, Device, pszDeviceInstanceId,
                                       szUniqueParentID,
                                       szParentIdPrefix,
                                       szDriver,
                                       szService);
        } else if (*szDriver) {
            dwSpaceConsumed = wsprintf(*pszDeviceInstanceCurrent,
                                       TEXT("\"%s\\%s\\%s\",%s,%s,%s"),
                                       Enumerator, Device, pszDeviceInstanceId,
                                       szUniqueParentID,
                                       szParentIdPrefix,
                                       szDriver);
        } else if (*szParentIdPrefix) {
            dwSpaceConsumed = wsprintf(*pszDeviceInstanceCurrent,
                                       TEXT("\"%s\\%s\\%s\",%s,%s"),
                                       Enumerator, Device, pszDeviceInstanceId,
                                       szUniqueParentID,
                                       szParentIdPrefix);
        } else if (*szUniqueParentID) {
            dwSpaceConsumed = wsprintf(*pszDeviceInstanceCurrent,
                                       TEXT("\"%s\\%s\\%s\",%s"),
                                       Enumerator, Device, pszDeviceInstanceId,
                                       szUniqueParentID);
        }

        //
        // Free the allocated BootConfig string buffer.
        //
        if (pszBootConfig) {
            MyFree(pszBootConfig);
            pszBootConfig = NULL;
        }

        //
        // Account for the NULL terminator
        //
        dwSpaceConsumed += 1;

        *pszDeviceInstanceCurrent += dwSpaceConsumed;
        *dwDeviceInstanceSectionRemaining -= dwSpaceConsumed;

        //
        // Close the device instance key
        //
        RegCloseKey(hInstanceKey);
    }

 Clean0:

    //
    // Do some cleanup
    //
    if (pszDeviceInstanceId) {
        MyFree(pszDeviceInstanceId);
    }

    if (hDeviceKey != NULL) {
        RegCloseKey(hDeviceKey);
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }

    return (result == ERROR_SUCCESS);

} // EnumerateInstanceKeys()



BOOL
CanStringBeMigrated(
    IN LPTSTR       pszBuffer
    )
{
    LPTSTR p;
    BOOL bStatus;

    try {
        //
        // An empty string can be migrated.
        //
        if (!ARGUMENT_PRESENT(pszBuffer)) {
            bStatus = TRUE;
            goto Clean0;
        }

        for (p = pszBuffer; *p; p++) {
            //
            // Check for the presence of non-migratable characters.
            //
            if ((*p == TEXT('='))  || (*p == TEXT('"'))) {
                bStatus = FALSE;
                goto Clean0;
            }
        }

        //
        // Found no problems with the string.
        //
        bStatus = TRUE;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bStatus = FALSE;
    }

    return bStatus;

} // CanStringBeMigrated


//
// Class key enumeration routines
//


BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    )
/*++

Routine Description:

    This routine walks the Plug and Play setup class branch of the registry, and
    collects the data about what keys currently exist.  This information is
    relevant to maintaining plug and play state during textmode setup, such that
    the names of existing keys are not reassigned before they have been migrated
    to the registry at the end of textmode setup.

    Specifically, a multi-sz string will be returned to the caller that contains
    each subkey of the class branch.

Arguments:

    Buffer - Supplies the address of a character pointer, that on success will
             contain a multi-sz list of setup class subkeys to migrate.

             The caller is responsible for freeing the memory via LocalFree.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hClassKey = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, i;
    LPTSTR pszClassKeyName = NULL;

    LPTSTR pszClassKeySection = NULL;
    LPTSTR pszClassKeyCurrent = NULL;
    DWORD  dwClassKeySectionLength = 0;
    DWORD  dwClassKeySectionRemaining = 0;


    //
    // Initialize the output parameter.
    //
    *Buffer = NULL;

    //
    // Allocate storage and initialize variables for the class Key migration
    // section.
    //
    if (pszClassKeySection == NULL) {

        dwClassKeySectionLength = dwClassKeySectionRemaining = 256;
        pszClassKeySection = MyMalloc(dwClassKeySectionLength * sizeof(TCHAR));

        if (!pszClassKeySection) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("MigrateClassKeys: initial ALLOC for ClassKeySection failed!!\n") ));
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        pszClassKeyCurrent = pszClassKeySection;
    }

    //
    // Open a handle to the HKLM\SYSTEM\CCS\Control\Class key.
    //
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_CLASS_NT,
                          0,
                          KEY_READ,
                          &hClassKey);
    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateClassKeys: failed to open %s, error=0x%08lx\n"),
                   REGSTR_PATH_CLASS_NT, result));
        goto Clean0;
    }

    //
    // Query the Class key for class GUID subkey information.
    //
    result = RegQueryInfoKey(hClassKey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateClassKeys: failed to query %s key, error=0x%08lx\n"),
                   REGSTR_PATH_CLASS_NT, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest setup class GUID subkey name.
    //
    dwMaxSubKeyLength++;
    MYASSERT(dwMaxSubKeyLength == MAX_GUID_STRING_LEN);
    pszClassKeyName = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszClassKeyName) {
        result = ERROR_NOT_ENOUGH_MEMORY;
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateClassKeys: ALLOC for Class GUID key names failed!!\n") ));
        goto Clean0;
    }

    //
    // Enumerate the setup class GUIDs.
    //
    for (i = 0; i < dwSubkeyCount; i++) {
        DWORD dwClassKeyLength;

        dwClassKeyLength = dwMaxSubKeyLength;

        result = RegEnumKeyEx(hClassKey,
                              i,
                              pszClassKeyName,
                              &dwClassKeyLength,
                              0,
                              NULL,
                              NULL,
                              NULL);
        if (result != ERROR_SUCCESS) {
            //
            // If there was some error enumerating this key, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE( DBGF_WARNINGS,
                      (TEXT("MigrateClassKeys: failed to enumerate a class subkey, error=0x%08lx\n"),
                       result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Enumerate all subkeys for a given setup class key, and append them to
        // the section buffer.
        //
        if (!EnumerateClassSubkeys(hClassKey,
                                   pszClassKeyName,
                                   &pszClassKeySection,
                                   &pszClassKeyCurrent,
                                   &dwClassKeySectionLength,
                                   &dwClassKeySectionRemaining)) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumerateClassSubkeys failed, error=0x%08lx\n"),
                       GetLastError()));
        }
    }

    //
    // Once we've enumerated all class subkeys, add the final NULL terminator to
    // the multi-sz buffer.  There must be enough space for the final NULL
    // terminator because the buffer is always reallocated unless there is room.
    //
    MYASSERT(dwClassKeySectionRemaining > 0);

    MYASSERT(pszClassKeyCurrent);
    *pszClassKeyCurrent = TEXT('\0');

    dwClassKeySectionRemaining -= 1;

 Clean0:

    //
    // Do some cleanup.
    //
    if (pszClassKeyName) {
        MyFree(pszClassKeyName);
    }

    if (hClassKey) {
        RegCloseKey(hClassKey);
    }

    //
    // Return the buffer to the caller only if successful.
    //
    if (result == ERROR_SUCCESS) {
        *Buffer = pszClassKeySection;
    } else {
        SetLastError(result);
        if (pszClassKeySection) {
            MyFree(pszClassKeySection);
        }
    }

    return (result == ERROR_SUCCESS);

} // MigrateClassKeys()



BOOL
EnumerateClassSubkeys(
    IN     HKEY     ClassKey,
    IN     LPTSTR   ClassKeyName,
    IN OUT LPTSTR  *pszClassKeySection,
    IN OUT LPTSTR  *pszClassKeyCurrent,
    IN OUT DWORD   *dwClassKeySectionLength,
    IN OUT DWORD   *dwClassKeySectionRemaining
    )
/*++

Routine Description:

    Enumerates subkeys of a setup class key.
    Worker routine for MigrateClassKeys.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hClassSubkey = NULL;
    LPTSTR pszClassSubkey = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, dwSpaceNeeded, dwSpaceConsumed, i;


    //
    // Open the class subkey.
    //
    result = RegOpenKeyEx(ClassKey,
                          ClassKeyName,
                          0,
                          KEY_READ,
                          &hClassSubkey);

    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateClassSubkeys: failed to open '%s' class key, error=0x%08lx\n"),
                   ClassKeyName, result));
        goto Clean0;
    }

    //
    // Query the class GUID key for setup class subkey information.
    //
    result = RegQueryInfoKey(hClassSubkey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateClassSubkeys: failed to query '%s' class key, error=0x%08lx\n"),
                   ClassKeyName, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest setup class subkey name.
    //
    dwMaxSubKeyLength++;
    pszClassSubkey = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszClassSubkey) {
        result = ERROR_NOT_ENOUGH_MEMORY;
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumerateClassSubkeys: ALLOC for Class GUID subkey names failed!!\n") ));
        goto Clean0;
    }

    //
    // Enumerate the setup class's "software" subkeys.
    //
    for (i = 0; i < dwSubkeyCount; i++) {

        DWORD  dwClassSubkeyLength;

        dwClassSubkeyLength = dwMaxSubKeyLength;
        result = RegEnumKeyEx(hClassSubkey,
                              i,
                              pszClassSubkey,
                              &dwClassSubkeyLength,
                              0,
                              NULL,
                              NULL,
                              NULL);

        if ((result != ERROR_SUCCESS) ||
            (dwClassSubkeyLength != 4)) {
            //
            // if there was some error, or this is not an actual "software" key
            // (in the form "XXXX"), skip this key and move on.
            //
            if (result != ERROR_SUCCESS) {
                MYASSERT(result != ERROR_NO_MORE_ITEMS);
                DBGTRACE( DBGF_WARNINGS,
                          (TEXT("EnumerateClassSubkeys: failed to enumerate a '%s' subkey, error=0x%08lx\n"),
                           ClassKeyName, result));
            }
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // This block appends the class key data we want to migrate to a
        // multi-sz style string that will be written to the sif file.
        //

        //
        // Need space in the section buffer for a string of the form:
        //     ClassKeyName\pszClassSubkey
        //
        dwSpaceNeeded = lstrlen(ClassKeyName) +
                        1 +  // TEXT('\\')
                        lstrlen(pszClassSubkey);

        //
        // Account for the NULL terminator.
        //
        dwSpaceNeeded += 1;

        if (*dwClassKeySectionRemaining <= dwSpaceNeeded) {
            //
            // ReAllocate the section block.
            //
            LPTSTR p;
            DWORD  dwTempSectionLength, dwTempSectionRemaining;

            dwTempSectionRemaining = *dwClassKeySectionRemaining + *dwClassKeySectionLength;
            dwTempSectionLength = *dwClassKeySectionLength * 2;

            p = *pszClassKeySection;
            p = MyRealloc(p,
                          dwTempSectionLength*sizeof(TCHAR));

            if (!p) {
                DBGTRACE( DBGF_ERRORS,
                          (TEXT("EnumerateClassSubkeys: REALLOC failed!!!\n") ));
                result = ERROR_NOT_ENOUGH_MEMORY;
                goto Clean0;
            }

            *pszClassKeySection = p;
            *dwClassKeySectionRemaining = dwTempSectionRemaining;
            *dwClassKeySectionLength = dwTempSectionLength;

            *pszClassKeyCurrent = *pszClassKeySection +
                (*dwClassKeySectionLength -
                 *dwClassKeySectionRemaining);
        }

        //
        // Write the current line to the section block.
        //
        dwSpaceConsumed = wsprintf(*pszClassKeyCurrent,
                                   TEXT("%s\\%s"),
                                   ClassKeyName,
                                   pszClassSubkey);

        //
        // Account for the NULL terminator.
        //
        dwSpaceConsumed += 1;

        *pszClassKeyCurrent += dwSpaceConsumed;
        *dwClassKeySectionRemaining -= dwSpaceConsumed;
    }

 Clean0:

    //
    // Do some cleanup.
    //
    if (hClassSubkey != NULL) {
        RegCloseKey(hClassSubkey);
    }

    if (pszClassSubkey) {
        MyFree(pszClassSubkey);
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }

    return (result == ERROR_SUCCESS);

} // EnumerateClassSubkeys()


//
// Hash value migration routines
//


BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    )
/*++

Routine Description:

    This routine searches the Plug and Play Enum key of the registry, and
    collects the data about what hash value entries currently exist.  This
    information is relevant to maintaining plug and play state during textmode
    setup, such that the names of existing device instances are not reassigned
    before they have been migrated to the registry at the end of textmode setup.

    Specifically, a multi-sz string will be returned to the caller that contains
    the name of the hash value, and its count.

Arguments:

    Buffer - Supplies the address of a character pointer, that on success will
             contain a multi-sz list of hash values to migrate.

             The caller is responsible for freeing the memory via LocalFree.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hEnumKey = NULL;
    DWORD  dwValueCount, dwMaxValueNameLength, dwSpaceNeeded, dwSpaceConsumed, i;
    LPTSTR pszHashValueName = NULL;

    LPTSTR pszHashValueSection = NULL;
    LPTSTR pszHashValueCurrent = NULL;

    DWORD  dwHashValueSectionLength = 0;
    DWORD  dwHashValueSectionRemaining = 0;


    //
    // Initialize the output parameter.
    //
    *Buffer = NULL;

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

    //
    // Unlock the Enum key
    //
    LockUnlockEnumTree(FALSE);

#endif // DO_LOCK_UNLOCK

    //
    // Allocate storage and initialize variables for the hash value migration
    // section.
    //
    if (pszHashValueSection == NULL) {

        dwHashValueSectionLength = dwHashValueSectionRemaining = 256;
        pszHashValueSection = MyMalloc(dwHashValueSectionLength * sizeof(TCHAR));

        if (!pszHashValueSection) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("MigrateHashValues: initial ALLOC for HashValueSection failed!!\n") ));
            goto Clean0;
        }

        pszHashValueCurrent = pszHashValueSection;
    }

    //
    // Open a handle to the HKLM\SYSTEM\CCS\Enum key.
    //
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_SYSTEMENUM,
                          0,
                          KEY_READ,
                          &hEnumKey);
    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateHashValues: failed to open %s, error=0x%08lx\n"),
                   REGSTR_PATH_SYSTEMENUM, result));
        goto Clean0;
    }

    //
    // Query the Enum key for hash value information.
    //
    result = RegQueryInfoKey(hEnumKey,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             &dwValueCount,
                             &dwMaxValueNameLength,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateHashValues: failed to query %s key, error=0x%08lx\n"),
                   REGSTR_PATH_SYSTEMENUM, result));
        goto Clean0;
    }

    //
    // Allocate a variable to hold the largest hash value key name.
    //
    dwMaxValueNameLength++;
    pszHashValueName = MyMalloc(dwMaxValueNameLength * sizeof(TCHAR));
    if (!pszHashValueName) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("MigrateHashValues: failed to allocate buffer for Enum key hash values\n") ));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    //
    // Enumerate all values and append them to the supplied buffer.
    //
    for (i = 0; i < dwValueCount; i++) {
        DWORD dwHashValueLength, dwType, dwData, dwSize;
        TCHAR szHashValueData[11];


        dwHashValueLength = dwMaxValueNameLength;
        dwType = REG_DWORD;
        dwData = 0;
        dwSize = sizeof(DWORD);

        result = RegEnumValue(hEnumKey,
                              i,
                              pszHashValueName,
                              &dwHashValueLength,
                              0,
                              &dwType,
                              (LPBYTE)&dwData,
                              &dwSize);

        if ((result != ERROR_SUCCESS) ||
            (dwType != REG_DWORD)     ||
            (dwSize != sizeof(DWORD))) {
            //
            // If there was some error enumerating this value, or the value
            // return was not expected, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE( DBGF_WARNINGS,
                      (TEXT("MigrateHashValues: failed to enumerate Enum values, error=0x%08lx\n"),
                       result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Write the hash value data to the sif as a base 10 value.
        // (see admin\ntsetup\textmode\kernel\spsetup.c)
        //
        wsprintf(szHashValueData,
                 TEXT("%d"), dwData);  // base 10

        //
        // This block appends the class key data we want to migrate to a
        // multi-sz style string that will be written to the sif file.
        //

        //
        // Need space in the section buffer for a string of the form:
        //     HashValueName=HashValueData
        //
        dwSpaceNeeded = lstrlen(pszHashValueName) +
                        1 +  // TEXT('=')
                        lstrlen(szHashValueData);

        //
        // Account for the NULL terminator.
        //
        dwSpaceNeeded += 1;

        if (dwHashValueSectionRemaining <= dwSpaceNeeded) {
            //
            // ReAllocate the section block.
            //
            LPTSTR p;
            DWORD  dwTempSectionLength, dwTempSectionRemaining;

            dwTempSectionRemaining = dwHashValueSectionRemaining + dwHashValueSectionLength;
            dwTempSectionLength = dwHashValueSectionLength * 2;

            p = pszHashValueSection;
            p = MyRealloc(p,
                          dwTempSectionLength*sizeof(TCHAR));

            if (!p) {
                DBGTRACE( DBGF_ERRORS,
                          (TEXT("MigrateHashValues: REALLOC failed!!!\n") ));
                result = ERROR_NOT_ENOUGH_MEMORY;
                goto Clean0;
            }

            pszHashValueSection = p;
            dwHashValueSectionRemaining = dwTempSectionRemaining;
            dwHashValueSectionLength = dwTempSectionLength;

            pszHashValueCurrent = pszHashValueSection +
                (dwHashValueSectionLength -
                 dwHashValueSectionRemaining);
        }

        //
        // Write the current line to the section block.
        //
        dwSpaceConsumed = wsprintf(pszHashValueCurrent,
                                   TEXT("%s=%s"),
                                   pszHashValueName,
                                   szHashValueData);

        //
        // Account for the NULL terminator.
        //
        dwSpaceConsumed += 1;

        pszHashValueCurrent += dwSpaceConsumed;
        dwHashValueSectionRemaining -= dwSpaceConsumed;
    }

    //
    // Once we've enumerated all hash values, add the final NULL terminator to
    // the multi-sz buffer.  There must be enough space for the final NULL
    // terminator because the buffer is always reallocated unless there is room.
    //
    MYASSERT(dwHashValueSectionRemaining > 0);

    MYASSERT(pszHashValueCurrent);
    *pszHashValueCurrent = TEXT('\0');

    dwHashValueSectionRemaining -= 1;

 Clean0:

    //
    // Do some cleanup
    //
    if (pszHashValueName) {
        MyFree(pszHashValueName);
    }

    if (hEnumKey) {
        RegCloseKey(hEnumKey);
    }

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

    //
    // Lock the Enum tree
    //
    LockUnlockEnumTree(TRUE);

#endif // DO_LOCK_UNLOCK

    //
    // Return the buffer to the caller only if successful.
    //
    if (result == ERROR_SUCCESS) {
        *Buffer = pszHashValueSection;
    } else {
        SetLastError(result);
        if (pszHashValueSection) {
            MyFree(pszHashValueSection);
        }
    }

    return (result == ERROR_SUCCESS);

} // MigrateHashValues()



//
// Enum branch lock/unlock and security routines - taken from PNPREG.
// (we only need these if we're doing the Enum lock/unlock thing)
//

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK


VOID
LockUnlockEnumTree(
    IN  BOOL     bLock
    )
/*++

Routine Description:

    This function "locks" or "unlocks" the Plug and Play Enum tree in the
    registry.

Arguments:

    bLock         - If TRUE, specifies that the Enum tree should be "locked".
                    Otherwise, specifies that the Enum tree should be "unlocked".

Return Value:

    None.

--*/
{
    PSECURITY_DESCRIPTOR    pSD;
    HKEY                    hParentKey;
    LONG                    RegStatus;

    if (CreateSecurityDescriptors()) {

        EnumKeysAndApplyDacls(HKEY_LOCAL_MACHINE,
                              REGSTR_PATH_SYSTEMENUM,
                              0,
                              FALSE,
                              !bLock,
                              bLock ? &g_LockedPrivateKeysSD : &g_DeviceParametersSD,
                              &g_DeviceParametersSD);

        FreeSecurityDescriptors();
    }

    return;

} // LockUnlockEnumTree()



VOID
EnumKeysAndApplyDacls(
    IN HKEY      hParentKey,
    IN LPTSTR    pszKeyName,
    IN DWORD     dwLevel,
    IN BOOL      bInDeviceParameters,
    IN BOOL      bApplyTopDown,
    IN PSECURITY_DESCRIPTOR pPrivateKeySD,
    IN PSECURITY_DESCRIPTOR pDeviceParametersSD
    )
/*++

Routine Description:

    This function applies the DACL in pSD to all the keys rooted at hKey
    including hKey itself.

Arguments:

    hParentKey    - Handle to a registry key.

    pszKeyName    - Name of the key.

    dwLevel       - Number of levels remaining to recurse.

    pSD           - Pointer to a security descriptor containing a DACL.

Return Value:

    None.

--*/
{
    LONG        regStatus;
    DWORD       dwMaxSubKeySize;
    LPTSTR      pszSubKey;
    DWORD       index;
    HKEY        hKey;
    BOOL        bNewInDeviceParameters;

#if 0 //#if DBG // DBG
    DWORD       dwStartKeyNameLength = g_dwCurrentKeyNameLength;

    if (g_dwCurrentKeyNameLength != 0)  {
        g_szCurrentKeyName[ g_dwCurrentKeyNameLength++ ] = TEXT('\\');
    }

    _tcscpy(&g_szCurrentKeyName[g_dwCurrentKeyNameLength], pszKeyName);
    g_dwCurrentKeyNameLength += _tcslen(pszKeyName);

#endif  // DBG

    DBGTRACE( DBGF_REGISTRY,
              (TEXT("EnumKeysAndApplyDacls(0x%08X, \"%s\", %d, %s, %s, 0x%08X, 0x%08X)\n"),
              hParentKey,
              g_szCurrentKeyName,
              dwLevel,
              bInDeviceParameters ? TEXT("TRUE") : TEXT("FALSE"),
              bApplyTopDown ? TEXT("TRUE") : TEXT("FALSE"),
              pPrivateKeySD,
              pDeviceParametersSD) );

    if (bApplyTopDown) {

        regStatus = RegOpenKeyEx( hParentKey,
                                  pszKeyName,
                                  0,
                                  WRITE_DAC,
                                  &hKey
                                  );

        if (regStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegOpenKeyEx() failed, error = %d\n"),
                      g_szCurrentKeyName, regStatus));

            return;
        }

        DBGTRACE( DBGF_REGISTRY,
                  (TEXT("Setting security on %s on the way down\n"),
                  g_szCurrentKeyName) );

        //
        // apply the new security to the registry key
        //
        regStatus = RegSetKeySecurity( hKey,
                                       DACL_SECURITY_INFORMATION,
                                       bInDeviceParameters ?
                                           pDeviceParametersSD :
                                           pPrivateKeySD
                                       );

        if (regStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegSetKeySecurity() failed, error = %d\n"),
                      g_szCurrentKeyName, regStatus));
        }

        //
        // Close the key and reopen it later for read (which hopefully was just
        // granted in the DACL we just wrote
        //
        RegCloseKey( hKey );
    }

    regStatus = RegOpenKeyEx( hParentKey,
                              pszKeyName,
                              0,
                              KEY_READ | WRITE_DAC,
                              &hKey
                              );

    if (regStatus != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegOpenKeyEx() failed, error = %d\n"),
                  g_szCurrentKeyName, regStatus));

        return;
    }

    //
    // Determine length of longest subkey
    //
    regStatus = RegQueryInfoKey( hKey,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwMaxSubKeySize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );

    if (regStatus == ERROR_SUCCESS) {

        //
        // Allocate a buffer to hold the subkey names. RegQueryInfoKey returns the
        // size in characters and doesn't include the NUL terminator.
        //
        pszSubKey = LocalAlloc(0, ++dwMaxSubKeySize * sizeof(TCHAR));

        if (pszSubKey != NULL) {

            //
            // Enumerate all the subkeys and then call ourselves recursively for each
            // until dwLevel reaches 0.
            //

            for (index = 0; ; index++) {

                regStatus = RegEnumKey( hKey,
                                        index,
                                        pszSubKey,
                                        dwMaxSubKeySize
                                        );

                if (regStatus != ERROR_SUCCESS) {

                    if (regStatus != ERROR_NO_MORE_ITEMS) {

                        DBGTRACE( DBGF_ERRORS,
                                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegEnumKeyEx() failed, error = %d\n"),
                                  g_szCurrentKeyName,
                                  regStatus) );
                    }

                    break;
                }

                bNewInDeviceParameters = bInDeviceParameters ||
                                         (dwLevel == 3 &&
                                            _tcsicmp( pszSubKey,
                                                      REGSTR_KEY_DEVICEPARAMETERS ) == 0);

                EnumKeysAndApplyDacls( hKey,
                                       pszSubKey,
                                       dwLevel + 1,
                                       bNewInDeviceParameters,
                                       bApplyTopDown,
                                       pPrivateKeySD,
                                       pDeviceParametersSD
                                       );
            }

            LocalFree( pszSubKey );
        }
    }
    else
    {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegQueryInfoKey() failed, error = %d\n"),
                  g_szCurrentKeyName, regStatus));
    }

    if (!bApplyTopDown) {

        DBGTRACE( DBGF_REGISTRY,
                  (TEXT("Setting security on %s on the way back up\n"),
                  g_szCurrentKeyName) );

        //
        // apply the new security to the registry key
        //
        regStatus = RegSetKeySecurity( hKey,
                                       DACL_SECURITY_INFORMATION,
                                       bInDeviceParameters ?
                                           pDeviceParametersSD :
                                           pPrivateKeySD
                                       );

        if (regStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegSetKeySecurity() failed, error = %d\n"),
                      g_szCurrentKeyName, regStatus));
        }
    }

    RegCloseKey( hKey );

#if 0 //#if DBG // DBG
    g_dwCurrentKeyNameLength = dwStartKeyNameLength;
    g_szCurrentKeyName[g_dwCurrentKeyNameLength] = TEXT('\0');
#endif  // DBG

    return;

} // EnumKeysAndApplyDacls()



BOOL
CreateSecurityDescriptors(
    VOID
    )
/*++

Routine Description:

    This function creates a properly initialized Security Descriptor for the
    Device Parameters key and its subkeys.  The SIDs and DACL created by this
    routine must be freed by calling FreeSecurityDescriptors.

Arguments:

    None.

Return Value:

    Pointer to the initialized Security Descriptor.  NULL is returned if an
    error occurs.

--*/

{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    EXPLICIT_ACCESS             ExplicitAccess[3];

    DWORD                       dwError;
    BOOL                        bSuccess;

    DWORD                       i;

    FARPROC                     pSetEntriesInAcl;
    HMODULE                     pAdvApi32;

    pAdvApi32 = LoadLibrary( TEXT("advapi32.dll"));
    if (!pAdvApi32) {
        return(FALSE);
    }

#ifdef UNICODE
    pSetEntriesInAcl = GetProcAddress( pAdvApi32, "SetEntriesInAclW" );
#else
    pSetEntriesInAcl = GetProcAddress( pAdvApi32, "SetEntriesInAclA" );
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }

    //
    // Create SIDs - Admins and System
    //

    bSuccess =             AllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &g_pAdminSid);

    bSuccess = bSuccess && AllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &g_pSystemSid);

    bSuccess = bSuccess && AllocateAndInitializeSid( &WorldAuthority,
                                                     1,
                                                     SECURITY_WORLD_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &g_pWorldSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 3; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;
            ExplicitAccess[i].grfInheritance = CONTAINER_INHERIT_ACE;
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }

        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)g_pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)g_pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_READ;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)g_pWorldSid;

        //
        // Create the DACL with the both the above ACEs for the DeviceParameters
        //
        dwError = (DWORD)pSetEntriesInAcl( 3,
                                           ExplicitAccess,
                                           NULL,
                                           &g_pDeviceParametersDacl );

        if (dwError == ERROR_SUCCESS) {
            //
            // Create the DACL with just the system ACE for the locked private
            // keys.
            //
            dwError = (DWORD)pSetEntriesInAcl( 2,
                                               ExplicitAccess + 1,
                                               NULL,
                                               &g_pLockedPrivateKeysDacl );
        }

        bSuccess = dwError == ERROR_SUCCESS;

    }

    //
    // Initialize the DeviceParameters security descriptor
    //
    bSuccess = bSuccess && InitializeSecurityDescriptor( &g_DeviceParametersSD,
                                                         SECURITY_DESCRIPTOR_REVISION );

    //
    // Set the new DACL in the security descriptor
    //
    bSuccess = bSuccess && SetSecurityDescriptorDacl( &g_DeviceParametersSD,
                                                      TRUE,
                                                      g_pDeviceParametersDacl,
                                                      FALSE);

    //
    // validate the new security descriptor
    //
    bSuccess = bSuccess && IsValidSecurityDescriptor( &g_DeviceParametersSD );


    //
    // Initialize the DeviceParameters security descriptor
    //
    bSuccess = bSuccess && InitializeSecurityDescriptor( &g_LockedPrivateKeysSD,
                                                         SECURITY_DESCRIPTOR_REVISION );

    //
    // Set the new DACL in the security descriptor
    //
    bSuccess = bSuccess && SetSecurityDescriptorDacl( &g_LockedPrivateKeysSD,
                                                      TRUE,
                                                      g_pLockedPrivateKeysDacl,
                                                      FALSE);

    //
    // validate the new security descriptor
    //
    bSuccess = bSuccess && IsValidSecurityDescriptor( &g_LockedPrivateKeysSD );


    if (!bSuccess) {

        FreeSecurityDescriptors();
    }

    FreeLibrary( pAdvApi32 );

    return bSuccess;

} // CreateSecurityDescriptors()



VOID
FreeSecurityDescriptors(
    VOID
    )
/*++

Routine Description:

    This function deallocates the data structures allocated and initialized by
    CreateSecurityDescriptors.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_pDeviceParametersDacl) {
        LocalFree(g_pDeviceParametersDacl);
        g_pDeviceParametersDacl = NULL;
    }

    if (g_pLockedPrivateKeysDacl) {
        LocalFree(g_pLockedPrivateKeysDacl);
        g_pLockedPrivateKeysDacl = NULL;
    }

    if (g_pAdminSid != NULL) {
        FreeSid(g_pAdminSid);
        g_pAdminSid = NULL;
    }

    if (g_pSystemSid != NULL) {
        FreeSid(g_pSystemSid);
        g_pSystemSid = NULL;
    }

    if (g_pWorldSid != NULL) {
        FreeSid(g_pWorldSid);
        g_pWorldSid = NULL;
    }

    return;

} // FreeSecurityDescriptors()

#endif // DO_LOCK_UNLOCK



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\sif.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    sif.c

Abstract:

    This module contains the following routines for manipulating the sif file in
    which Plug and Play migration data will be stored:

        AsrCreatePnpStateFileW
        AsrCreatePnpStateFileA

Author:

    Jim Cavalaris (jamesca) 07-Mar-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "debug.h"
#include "pnpsif.h"

#include <pnpmgr.h>
#include <setupbat.h>


//
// definitions
//

// Maximum length of a line in the sif file
#define MAX_SIF_LINE 4096


//
// private prototypes
//

BOOL
CreateSifFileW(
    IN  PCWSTR        FilePath,
    IN  BOOL          CreateNew,
    OUT LPHANDLE      SifHandle
    );

BOOL
WriteSifSection(
    IN  CONST HANDLE  SifHandle,
    IN  PCTSTR        SectionName,
    IN  PCTSTR        SectionData,
    IN  BOOL          Ansi
    );


//
// routines
//


BOOL
AsrCreatePnpStateFileW(
    IN  PCWSTR    lpFilePath
    )
/*++

Routine Description:

    Creates the ASR PNP state file (asrpnp.sif) at the specified file-path
    during an ASR backup operation.  This sif file is retrieved from the ASR
    floppy disk during the setupldr phase of a clean install, and in used during
    text mode setup.

Arguments:

    lpFilePath - Specifies the path to the file where the state file is to be
                 created.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    BOOL    result = TRUE;
    BOOL    bAnsiSif = TRUE;  // always write ANSI sif files.
    LPTSTR  buffer = NULL;
    HANDLE  sifHandle = NULL;

    //
    // Create an empty sif file using the supplied path name.
    //
    result = CreateSifFileW(lpFilePath,
                            TRUE,  // create a new asrpnp.sif file
                            &sifHandle);
    if (!result) {
        //
        // LastError already set by CreateSifFile.
        //
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("AsrCreatePnpStateFile: CreateSifFileW failed for file %ws, error=0x%08lx\n"),
                   lpFilePath, GetLastError()));
        return FALSE;
    }

    //
    // Do the device instance migration stuff...
    //
    if (MigrateDeviceInstanceData(&buffer)) {

        //
        // Write the device instance section to the sif file.
        //
        result = WriteSifSection(sifHandle,
                                 WINNT_DEVICEINSTANCES,
                                 buffer,
                                 bAnsiSif);   // Write sif section as ANSI
        if (!result) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("AsrCreatePnpStateFile: WriteSifSection failed for [%s], error=0x%08lx\n"),
                       WINNT_DEVICEINSTANCES, GetLastError()));
        }

        //
        // Free the allocated buffer.
        //
        LocalFree(buffer);
        buffer = NULL;

    } else {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("AsrCreatePnpStateFile: MigrateDeviceInstanceData failed, error=0x%08lx\n"),
                   GetLastError()));
    }

    //
    // Do the class key migration stuff...
    //
    if (MigrateClassKeys(&buffer)) {

        //
        // Write the class key section to the sif file.
        //
        result = WriteSifSection(sifHandle,
                                 WINNT_CLASSKEYS,
                                 buffer,
                                 bAnsiSif);   // Write sif section as ANSI

        if (!result) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("AsrCreatePnpStateFile: WriteSifSection failed for [%s], error=0x%08lx\n"),
                       WINNT_CLASSKEYS, GetLastError()));
        }

        //
        // Free the allocated buffer.
        //
        LocalFree(buffer);
        buffer = NULL;
    } else {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("AsrCreatePnpStateFile: MigrateClassKeys failed, error=0x%08lx\n"),
                   GetLastError()));
    }


    //
    // Do the hash value migration stuff...
    //
    if (MigrateHashValues(&buffer)) {

        //
        // Write the hash value section to the sif file.
        //
        result = WriteSifSection(sifHandle,
                                 WINNT_DEVICEHASHVALUES,
                                 buffer,
                                 bAnsiSif);   // Write sif section as ANSI?
        if (!result) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("AsrCreatePnpStateFile: WriteSifSection failed for [%s], error=0x%08lx\n"),
                       WINNT_DEVICEHASHVALUES, GetLastError()));
        }

        //
        // Free the allocated buffer.
        //
        LocalFree(buffer);
        buffer = NULL;
    } else {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("AsrCreatePnpStateFile: MigrateHashValues failed, error=0x%08lx\n"),
                   GetLastError()));
    }

    //
    // Close the sif file.
    //
    if (sifHandle) {
        CloseHandle(sifHandle);
    }

    //
    // Reset the last error as successful in case we encountered a non-fatal
    // error along the way.
    //
    SetLastError(ERROR_SUCCESS);
    return TRUE;

} // AsrCreatePnpStateFile()



BOOL
AsrCreatePnpStateFileA(
    IN  PCSTR    lpFilePath
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.


--*/
{
    WCHAR wszFilePath[MAX_PATH + 1];


    //
    // Validate arguments.
    //
    if (!ARGUMENT_PRESENT(lpFilePath) ||
        strlen(lpFilePath) > MAX_PATH) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert the file path to a wide string.
    //
    memset(wszFilePath, 0, MAX_PATH + 1);

    if (!(MultiByteToWideChar(CP_ACP,
                              0,
                              lpFilePath,
                              -1,
                              wszFilePath,
                              MAX_PATH + 1))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Return the result of calling the wide char version
    //
    return AsrCreatePnpStateFileW(wszFilePath);

} // AsrCreatePnpStateFileA()



BOOL
CreateSifFileW(
    IN  PCWSTR    lpFilePath,
    IN  BOOL      bCreateNew,
    OUT LPHANDLE  lpSifHandle
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.


--*/
{
    HANDLE  sifhandle = NULL;


    //
    // Validate arguments.
    //
    if (!ARGUMENT_PRESENT(lpFilePath) ||
        (wcslen(lpFilePath) > MAX_PATH) ||
        !ARGUMENT_PRESENT(lpSifHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Initialize output paramaters.
    //
    *lpSifHandle = NULL;

    //
    // Create the file. The handle will be closed by the caller, once they are
    // finished with it.
    //
    sifhandle = CreateFileW(lpFilePath,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            bCreateNew ? CREATE_ALWAYS : OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);

    if ((sifhandle == NULL) ||
        (sifhandle == INVALID_HANDLE_VALUE)) {
        //
        // LastError already set by CreateFile.
        //
        return FALSE;
    }

    //
    // Return the sif handle to the caller only if successful.
    //
    *lpSifHandle = sifhandle;
    return TRUE;

} // CreateSifFileW()



BOOL
WriteSifSection(
    IN  CONST HANDLE  SifHandle,
    IN  PCTSTR        SectionName,
    IN  PCTSTR        SectionData,
    IN  BOOL          Ansi
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.


--*/
{
    BYTE    buffer[(MAX_SIF_LINE+1)*sizeof(WCHAR)];
    DWORD   dwSize, dwTempSize;
    PCTSTR  p;


    //
    // Validate the arguments
    //
    if (!ARGUMENT_PRESENT(SifHandle)   ||
        !ARGUMENT_PRESENT(SectionName) ||
        !ARGUMENT_PRESENT(SectionData)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Write the section name to the sif file.
    //
    if (Ansi) {
        //
        // Write ANSI strings to the sif file
        //
#if UNICODE
        wsprintfA((LPSTR)buffer, (LPCSTR)"[%ls]\r\n", SectionName);
#else   // ANSI
        wsprintfA((LPSTR)buffer, (LPCSTR)"[%s]\r\n",  SectionName);
#endif  // UNICODE/ANSI
        dwSize = strlen((PSTR)buffer);
    } else {
        //
        // Write Unicode strings to the sif file
        //
#if UNICODE
        wsprintfW((LPWSTR)buffer, (LPCWSTR)L"[%ws]\r\n", SectionName);
#else   // ANSI
        wsprintfW((LPWSTR)buffer, (LPCWSTR)L"[%S]\r\n",  SectionName);
#endif  // UNICODE/ANSI
        dwSize = wcslen((PWSTR)buffer) * sizeof(WCHAR);
    }

    if (!WriteFile(SifHandle, buffer, dwSize, &dwTempSize, NULL)) {
        //
        // LastError already set by WriteFile
        //
        return FALSE;
    }

    DBGTRACE( DBGF_INFO,
              (TEXT("[%s]\n"), SectionName));


    //
    // Write the multi-sz section data to the file.
    //
    p = SectionData;
    while (*p) {
        if (Ansi) {
            //
            // Write ANSI strings to the sif file
            //
#if UNICODE
            wsprintfA((LPSTR)buffer, (LPCSTR)"%ls\r\n", p);
#else   // ANSI
            wsprintfA((LPSTR)buffer, (LPCSTR)"%s\r\n",  p);
#endif  // UNICODE/ANSI
            dwSize = strlen((PSTR)buffer);
        } else {
            //
            // Write Unicode strings to the sif file
            //
#if UNICODE
            wsprintfW((LPWSTR)buffer, (LPCWSTR)L"%ws\r\n", p);
#else   // ANSI
            wsprintfW((LPWSTR)buffer, (LPCWSTR)L"%S\r\n",  p);
#endif  // UNICODE/ANSI
            dwSize = wcslen((PWSTR)buffer) * sizeof(WCHAR);
        }

        if (!WriteFile(SifHandle, buffer, dwSize, &dwTempSize, NULL)) {
            //
            // LastError already set by WriteFile
            //
            return FALSE;
        }

        DBGTRACE( DBGF_INFO,
                  (TEXT("%s\n"), p));

        //
        // Find the next string in the multi-sz
        //
        p += lstrlen(p) + 1;
    }

    return TRUE;

} // WriteSifSection()



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pnpsif\pnpsif.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pnpsif.h

Abstract:

    This module contains the public prototypes for this module.

    (This header file is not actually included anywhere, it serves to reference
    the routines in this library that are called externally.)

Author:

    Jim Cavalaris (jamesca) 3-07-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// public prototypes for Plug and Play registry migration routines.
// (prototyped in ntsetup\syssetup\asr.c,
// called by syssetup.dll!AsrCreateStateFileW)
//

BOOL
AsrCreatePnpStateFileW(
    IN  PCWSTR    FilePath
    );

//
// public prototypes for Plug and Play registry migration routines.
// (prototyped in ntsetup\winnt32\dll\winnt32.h,
// called by winnt32u.dll!DoWriteParametersFile)
//

BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    );

//
// public prototypes for Plug and Play registry merge-restore routines.
// (prototype - TBD, called by - TBD)
//

BOOL
AsrRestorePlugPlayRegistryData(
    IN  HKEY    SourceSystemKey,
    IN  HKEY    TargetSystemKey,
    IN  DWORD   Flags,
    IN  PVOID   Reserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setexts\crt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    crt.c

Abstract:

    This file implements certain crt apis that are not present in
    libcntpr.lib. This implementation is NOT multi-thread safe.

Author:

    Wesley Witt (wesw) 6-Feb-1994

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

void * __cdecl
malloc(
    size_t sz
    )
{

    return LocalAlloc( LPTR, sz );

}

void __cdecl
free(
    void * ptr
    )
{

    LocalFree( ptr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setexts\ntsdextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>

#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <winsock2.h>
#include <lmerr.h>
#include "oc.h"
#include "ocmdeb.h"

//#include <ntcsrsrv.h>

#define move(dst, src)\
try {\
    ReadMemory((DWORD_PTR) (src), &(dst), sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
try {\
    ReadMemory((DWORD_PTR) (src), &(dst), (size), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PWINDBG_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
//#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (DWORD_PTR)(a), (b), (c), (d) ))

//#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )
#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (DWORD_PTR)(a), (LPVOID)(b), (c), (d) ))

#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;

//
// debuggee typedefs
//
#define HASH_BUCKET_COUNT 509

typedef struct _MY_LOCK {
    HANDLE handles[2];
} MYLOCK, *PMYLOCK;

typedef struct _STRING_TABLE {
    PUCHAR Data;    // First HASH_BUCKET_COUNT DWORDS are StringNodeOffset array.
    DWORD DataSize;
    DWORD BufferSize;
    MYLOCK Lock;
    UINT ExtraDataSize;
} STRING_TABLE, *PSTRING_TABLE;

typedef struct _STRING_NODEA {
    //
    // This is stored as an offset instead of a pointer
    // because the table can move as it's built
    // The offset is from the beginning of the table
    //
    ULONG_PTR NextOffset;
    //
    // This field must be last
    //
    CHAR String[ANYSIZE_ARRAY];
} STRING_NODEA, *PSTRING_NODEA;

typedef struct _STRING_NODEW {
    //
    // This is stored as an offset instead of a pointer
    // because the table can move as it's built
    // The offset is from the beginning of the table
    //
    ULONG_PTR NextOffset;
    //
    // This field must be last
    //
    WCHAR String[ANYSIZE_ARRAY];
} STRING_NODEW, *PSTRING_NODEW;


typedef struct _DISK_SPACE_LIST {

    MYLOCK Lock;

    PVOID DrivesTable;

    UINT Flags;

} DISK_SPACE_LIST, *PDISK_SPACE_LIST;

//
// These structures are stored as data associated with
// paths/filenames in the string table.
//

typedef struct _XFILE {
    //
    // -1 means it doesn't currently exist
    //
    LONGLONG CurrentSize;

    //
    // -1 means it will be deleted.
    //
    LONGLONG NewSize;

} XFILE, *PXFILE;


typedef struct _XDIRECTORY {
    //
    // Value indicating how many bytes will be required
    // to hold all the files in the FilesTable after they
    // are put on a file queue and then the queue is committed.
    //
    // This may be a negative number indicating that space will
    // actually be freed!
    //
    LONGLONG SpaceRequired;

    PVOID FilesTable;

} XDIRECTORY, *PXDIRECTORY;


typedef struct _XDRIVE {
    //
    // Value indicating how many bytes will be required
    // to hold all the files in the space list for this drive.
    //
    // This may be a negative number indicating that space will
    // actually be freed!
    //
    LONGLONG SpaceRequired;

    PVOID DirsTable;

    DWORD BytesPerCluster;

    //
    // This is the amount to skew SpaceRequired, based on
    // SetupAdjustDiskSpaceList(). We track this separately
    // for flexibility.
    //
    LONGLONG Slop;

} XDRIVE, *PXDRIVE;

typedef struct _QUEUECONTEXT {
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;

//
// Make absolutely sure that these structures are DWORD aligned
// because we turn alignment off, to make sure sdtructures are
// packed as tightly as possible into memory blocks.
//

//
// Internal representation of a section in an inf file
//
typedef struct _INF_LINE {

    //
    // Number of values on the line
    // This includes the key if Flags has INF_LINE_HASKEY
    // (In that case the first two entries in the Values array
    // contain the key--the first one in case-insensitive form used
    // for lookup, and the second in case-sensitive form for display.
    // INF lines with a single value (no key) are treated the same way.)
    // Otherwise the first entry in the Values array is the first
    // value on the line
    //
    WORD ValueCount;
    WORD Flags;

    //
    // String IDs for the values on the line.
    // The values are stored in the value block,
    // one after another.
    //
    // The value is the offset within the value block as opposed to
    // an actual pointer. We do this because the value block gets
    // reallocated as the inf file is loaded.
    //
    UINT Values;

} INF_LINE, *PINF_LINE;

//
// INF_LINE.Flags
//
#define INF_LINE_HASKEY     0x0000001
#define INF_LINE_SEARCHABLE 0x0000002

#define HASKEY(Line)       ((Line)->Flags & INF_LINE_HASKEY)
#define ISSEARCHABLE(Line) ((Line)->Flags & INF_LINE_SEARCHABLE)

//
// INF section
// This guy is kept separate and has a pointer to the actual data
// to make sorting the sections a little easier
//
typedef struct _INF_SECTION {
    //
    // String Table ID of the name of the section
    //
    LONG  SectionName;

    //
    // Number of lines in this section
    //
    DWORD LineCount;

    //
    // The section's lines. The line structures are stored packed
    // in the line block, one after another.
    //
    // The value is the offset within the line block as opposed to
    // an actual pointer. We do it this way because the line block
    // gets reallocated as the inf file is loaded.
    //
    UINT Lines;

} INF_SECTION, *PINF_SECTION;

//
// Params for section enumeration
//

typedef struct {
    PTSTR       Buffer;
    UINT        Size;
    UINT        SizeNeeded;
    PTSTR       End;
} SECTION_ENUM_PARAMS, *PSECTION_ENUM_PARAMS;


//
// Define structures for user-defined DIRID storage.
//
typedef struct _USERDIRID {
    UINT Id;
    TCHAR Directory[MAX_PATH];
} USERDIRID, *PUSERDIRID;

typedef struct _USERDIRID_LIST {
    PUSERDIRID UserDirIds;  // may be NULL
    UINT UserDirIdCount;
} USERDIRID_LIST, *PUSERDIRID_LIST;

typedef struct _STRINGSUBST_NODE {
    UINT ValueOffset;
    LONG TemplateStringId;
    BOOL CaseSensitive;
} STRINGSUBST_NODE, *PSTRINGSUBST_NODE;


//
// Version block structure that is stored (packed) in the opaque
// VersionData buffer of a caller-supplied SP_INF_INFORMATION structure.
//
typedef struct _INF_VERSION_BLOCK {
    UINT NextOffset;
    FILETIME LastWriteTime;
    WORD DatumCount;
    WORD OffsetToData; // offset (in bytes) from beginning of Filename buffer.
    UINT DataSize;     // DataSize and TotalSize are both byte counts.
    UINT TotalSize;
    TCHAR Filename[ANYSIZE_ARRAY];
    //
    // Data follows Filename in the buffer
    //
} INF_VERSION_BLOCK, *PINF_VERSION_BLOCK;

//
// Internal version block node.
//
typedef struct _INF_VERSION_NODE {
    FILETIME LastWriteTime;
    UINT FilenameSize;
    CONST TCHAR *DataBlock;
    UINT DataSize;
    WORD DatumCount;
    TCHAR Filename[MAX_PATH];
} INF_VERSION_NODE, *PINF_VERSION_NODE;

//
// Internal representation of an inf file.
//
typedef struct _LOADED_INF {
    DWORD Signature;

    //
    // The following 3 fields are used for precompiled INFs (PNF).
    // If FileHandle is not INVALID_HANDLE_VALUE, then this is a PNF,
    // and the MappingHandle and ViewAddress fields are also valid.
    // Otherwise, this is a plain old in-memory INF.
    //
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID  ViewAddress;

    PVOID StringTable;
    DWORD SectionCount;
    PINF_SECTION SectionBlock;
    PINF_LINE LineBlock;
    PLONG ValueBlock;
    INF_VERSION_NODE VersionBlock;
    BOOL HasStrings;

    //
    // If this INF contains any DIRID references to the system partition, then
    // store the OsLoader path that was used when compiling this INF here.  (This
    // value will always be correct when the INF is loaded.  However, if drive letters
    // are subsequently reassigned, then it will be incorrect until the INF is unloaded
    // and re-loaded.)
    //
    PCTSTR OsLoaderPath;    // may be NULL

    //
    // Remember the location where this INF originally came from (may be a directory
    // path or a URL).
    //
    DWORD  InfSourceMediaType;  // SPOST_PATH or SPOST_URL
    PCTSTR InfSourcePath;       // may be NULL

    //
    // Remember the INF's original filename, before it was installed into
    // %windir%\Inf (i.e., automatically via device installation or explicitly
    // via SetupCopyOEMInf).
    //
    PCTSTR OriginalInfName;     // may be NULL

    //
    // Maintain a list of value offsets that require string substitution at
    // run-time.
    //
    PSTRINGSUBST_NODE SubstValueList;   // may be NULL
    WORD SubstValueCount;

    //
    // Place the style WORD here (immediately following another WORD field),
    // to fill a single DWORD.
    //
    WORD Style;                         // INF_STYLE_OLDNT, INF_STYLE_WIN4

    //
    // Sizes in bytes of various buffers
    //
    UINT SectionBlockSizeBytes;
    UINT LineBlockSizeBytes;
    UINT ValueBlockSizeBytes;

    //
    // Track what language was used when loading this INF.
    //
    DWORD LanguageId;

    //
    // Embedded structure containing information about the current user-defined
    // DIRID values.
    //
    USERDIRID_LIST UserDirIdList;

    //
    // Synchronization.
    //
    MYLOCK Lock;

    //
    // INFs are append-loaded via a doubly-linked list of LOADED_INFs.
    // (list is not circular--Prev of head is NULL, Next of tail is NULL)
    //
    struct _LOADED_INF *Prev;
    struct _LOADED_INF *Next;

} LOADED_INF, *PLOADED_INF;

#define LOADED_INF_SIG   0x24666e49      // Inf$


#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002



//
// debugee prototypes
//

BOOL CheckInterupted(
    VOID
    );


VOID
DumpStringTableHeader(
    PSTRING_TABLE pst
    ) ;

PVOID
GetStringTableData(
    PSTRING_TABLE st
    );

PVOID
GetStringNodeExtraData(
    PSTRING_NODEW node
    );

PSTRING_NODEW
GetNextNode(
    PVOID stdata,
    PSTRING_NODEW node,
    PULONG_PTR offset
    );

PSTRING_NODEW
GetFirstNode(
    PVOID stdata,
    ULONG_PTR offset,
    PULONG_PTR poffset
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setexts\ntsdexts.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#include "ntsdextp.h"

WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        dprintf("GetVersionEx failed - %u\n", GetLastError());
        return;
        }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows NT\\CurrentVersion",
                     0,
                     KEY_READ,
                     &hkey
                    ) == NO_ERROR
       ) {
        cb = sizeof(szCurrentType);
        if (RegQueryValueEx(hkey, "CurrentType", NULL, &dwType, szCurrentType, &cb ) != 0) {
            szCurrentType[0] = '\0';
            }
        RegCloseKey(hkey);
        }
        

    if (VersionInformation.szCSDVersion[0]) {
        sprintf(szCSDString, ": %s", VersionInformation.szCSDVersion);
        }
    else {
        szCSDString[0] = '\0';
        }

    dprintf("Version %d.%d (Build %d%s) %s\n",
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          szCSDString,
          szCurrentType
         );
    return;
}

DECLARE_API( help )
{
    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        dprintf("setupexts help:\n\n");
        dprintf("!version                     - Dump system version and build number\n");
        dprintf("!help                        - This message\n");
        dprintf("!ocm [address] [opt. flag]   - Dump the OC_MANAGER structure at address, flag increased verbosity\n");
        dprintf("!space [address] [opt. flag] - Dump the DISK_SPACE_LIST structure at specified address\n");
        dprintf("!st  [address]               - Dump the contents of a STRING_TABLE structure at specified address\n");
        dprintf("!stfind [address] [element]  - Dump the specified string table element\n");
        dprintf("!queue [address] [opt. flag] - Dump the specified file queue\n");
        dprintf("!qcontext [address]          - Dump the specified default queue context \n");
        dprintf("!infdump [addr] [opt. flag]  - Dump the specified hinf \n");
        dprintf("!winntflags                  - Dump some winnt32 global flags \n");
        dprintf("!winntstr                    - Dump some winnt32 global strings\n");

    }
}

BOOL
CheckInterupted(
    VOID
    )
{
    if ( CheckControlC() ) {
        dprintf( "\nInterrupted\n\n" );
        return TRUE;
    }
    return FALSE;
}


//
// Simple routine to convert from hex into a string of characters.
// Used by debugger extensions.
//
// by scottlu
//

char *
HexToString(
    ULONG dw,
    CHAR *pch
    )
{
    if (dw > 0xf) {
        pch = HexToString(dw >> 4, pch);
        dw &= 0xf;
    }

    *pch++ = ((dw >= 0xA) ? ('A' - 0xA) : '0') + (CHAR)dw;
    *pch = 0;

    return pch;
}

VOID
DumpStringTableHeader(
    PSTRING_TABLE st
    )
{
    //
    // dump the string table header
    //
    dprintf("\tBase Data ptr:\t0x%08x\n",  st->Data);
    dprintf("\tDataSize:\t0x%08x\n",       st->DataSize);
    dprintf("\tBufferSize:\t0x%08x\n",     st->BufferSize);
    dprintf("\tExtraDataSize:\t0x%08x\n",  st->ExtraDataSize);

}

VOID
DumpOcComponent(
    ULONG_PTR offset,
    PSTRING_NODEW node,
    deb_POPTIONAL_COMPONENTW pcomp
    )
{
    DWORD i;
    PLONG count;

    dprintf("OC_COMPONENT Data for node %ws : 0x%p\n", node->String, offset );
    dprintf( "\t InfStringId:\t\t0x%08x\n", pcomp->InfStringId );
    dprintf( "\t TopLevelStringId:\t0x%08x\n", pcomp->TopLevelStringId );
    dprintf( "\t ParentStringId:\t0x%08x\n", pcomp->ParentStringId );
    dprintf( "\t FirstChildStringId:\t0x%08x\n", pcomp->FirstChildStringId );
    dprintf( "\t ChildrenCount:\t\t0x%08x\n", pcomp->ChildrenCount );
    dprintf( "\t NextSiblingStringId:\t0x%08x\n", pcomp->NextSiblingStringId );

    dprintf( "\t NeedsCount:\t\t%d\n", pcomp->NeedsCount );
    count = malloc ( pcomp->NeedsCount * sizeof(LONG) );
    if (count) {
        // read and dump needs list
        ReadMemory((DWORD_PTR) pcomp->NeedsStringIds, count, pcomp->NeedsCount*sizeof(LONG), NULL);
        for (i = 0; i < pcomp->NeedsCount; i++) {
            dprintf("\t NeedsStringIds #%d:\t0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }


    dprintf( "\t NeededByCount:\t\t%d\n", pcomp->NeededByCount );
    count = malloc ( pcomp->NeededByCount * sizeof(LONG) );
    if (count) {
        // read and dump needs list
        ReadMemory((DWORD_PTR) pcomp->NeededByStringIds, count, pcomp->NeededByCount*sizeof(LONG), NULL);
        for (i = 0; i < pcomp->NeededByCount; i++) {
            dprintf("\t NeededByStringIds #%d: 0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf( "\t ExcludeCount:\t\t%d\n", pcomp->ExcludeCount );
    count = malloc ( pcomp->ExcludeCount * sizeof(LONG) );
    if (count) {
        // read and dump Excludes list
        ReadMemory((DWORD_PTR) pcomp->ExcludeStringIds, count, pcomp->ExcludeCount*sizeof(LONG), NULL);
        for (i = 0; i < pcomp->ExcludeCount; i++) {
            dprintf("\t ExcludeStringIds #%d: 0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf( "\t ExcludedByCount:\t%d\n", pcomp->ExcludedByCount );
    count = malloc ( pcomp->ExcludedByCount * sizeof(LONG) );
    if (count) {
        // read and dump Excludes list
        ReadMemory((DWORD_PTR) pcomp->ExcludedByStringIds, count, pcomp->ExcludedByCount*sizeof(LONG), NULL);
        for (i = 0; i < pcomp->ExcludedByCount; i++) {
            dprintf("\t ExcludesStringIds #%d:\t0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf( "\t InternalFlags:\t\t0x%08x\n", pcomp->InternalFlags );

        
    dprintf( "\t SizeApproximation:\t0x%08x\n", pcomp->SizeApproximation );

    dprintf( "\t IconIndex:\t\t0x%08x\n", pcomp->IconIndex );
    dprintf( "\t IconDll:\t\t%ws\n", pcomp->IconDll);
    dprintf( "\t IconResource:\t\t%ws\n", pcomp->IconResource);
    dprintf( "\t SelectionState:\t0x%08x\n", pcomp->SelectionState );
    dprintf( "\t OriginalSelectionState:0x%08x\n", pcomp->OriginalSelectionState );
    dprintf( "\t InstalledState:\t0x%08x\n", pcomp->InstalledState );
    dprintf( "\t ModeBits:\t\t0x%08x\n", pcomp->ModeBits );
    dprintf( "\t Description:\t\t%ws\n", pcomp->Description );
    dprintf( "\t Tip:\t\t\t%ws\n", pcomp->Tip );

    dprintf( "\t InstallationDllName:\t%ws\n", pcomp->InstallationDllName );
    dprintf( "\t InterfaceFunctionName:\t%s\n", pcomp->InterfaceFunctionName );
    dprintf( "\t InstallationDll:\t0x%08x\n", pcomp->InstallationDll );
    //dprintf( "\t InstallationRoutine:\t%s\n", pcomp->InstallationRoutine );
    dprintf( "\t ExpectedVersion:\t0x%08x\n", pcomp->ExpectedVersion );
    dprintf( "\t Exists:\t\t0x%08x\n", pcomp->Exists );
    dprintf( "\t Flags:\t\t\t0x%08x\n\n\n", pcomp->Flags );

}

PVOID
GetStringTableData(
    PSTRING_TABLE st
    )
{
    LPVOID stdata;

    stdata = (PVOID) malloc( st->DataSize );
    if (!stdata) {
        dprintf("error allocation memory (size 0x%08x\n", (ULONG_PTR) st->DataSize);
        return NULL;
    }

    try {
        ReadMemory((DWORD_PTR) st->Data, stdata, st->DataSize, NULL);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        free( stdata );
        return NULL;
    }

    return stdata;
}

PVOID
GetStringNodeExtraData(
    PSTRING_NODEW node
    )
{
    PVOID extraData;
    extraData = node->String + wcslen(node->String) + 1;

    return extraData;

}

PSTRING_NODEW
GetNextNode(
    PVOID stdata,
    PSTRING_NODEW node,
    PULONG_PTR offset
    )
{
    PVOID next;

    if (node->NextOffset == -1) {
        *offset = 0;
        return NULL;
    }

    next = (PSTRING_NODEW)((LPBYTE)stdata + node->NextOffset);
    *offset = node->NextOffset;

    return next;

}

PSTRING_NODEW
GetFirstNode(
    PVOID stdata,
    ULONG_PTR offset,
    PULONG_PTR poffset
    )
{
    PSTRING_NODEW node;

    if (offset == -1) {
        return NULL;
    }

    node = (PSTRING_NODEW) ((LPBYTE)stdata + offset);
    *poffset = offset;

    return node;

}

LPCSTR
GetWizPage(
    DWORD i
    )
{
    LPCSTR  WizPage[] = {
        "WizPagesWelcome",        // welcome page
        "WizPagesMode",           // setup mode page
        "WizPagesEarly",          // pages that come after the mode page and before prenet pages
        "WizPagesPrenet",         // pages that come before network setup
        "WizPagesPostnet",        // pages that come after network setup
        "WizPagesLate",           // pages that come after postnet pages and before the final page
        "WizPagesFinal",          // final page
        "WizPagesTypeMax"
    };

    return WizPage[i];

}


DECLARE_API( st )
/*++

Routine Description:

    This debugger extension dumps a string table at the address specified.

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pst;
    STRING_TABLE st;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    PSTRING_NODEW node;//, prev;


    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pst = (PVOID)GetExpression( lpArgumentString );

    move( st, pst );

    dprintf("Base String Table Address:\t0x%p\n", pst);

    DumpStringTableHeader( &st );

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);
                pextradata = st.Data + offset + (wcslen(node->String) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%08x\n", pextradata );
                        //((LPBYTE)node->String + wcslen(node->String) + 1));
                node = GetNextNode( stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
    free( stdata );

}

DECLARE_API( stfind )
/*++

Routine Description:

    This debugger extension dumps the data for a given string table number

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pst;
    STRING_TABLE st;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    PSTRING_NODEW node;//, prev;
    DWORD_PTR element;


    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pst = (PVOID)GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        element = GetExpression( lpArgumentString );
    } else {
        dprintf("bogus usage\n");
    }


    move( st, pst );

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }
    //
    // search each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {

        } else {

            while (node) {
                if (element == offset) {
                    dprintf("\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);
                    pextradata = st.Data + offset + (wcslen(node->String) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                    dprintf("\tExtra Data:\t0x%08x\n", pextradata );
                    free( stdata );
                    return;
                }

                node = GetNextNode( stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
    free( stdata );

    dprintf("Couldn't find element\n");

}


DECLARE_API( ocm )
/*++

Routine Description:

    This debugger extension dumps an OC_MANAGER (UNICODE!) structure at the specified address

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    deb_OC_MANAGERW ocm;
    PVOID pocm;
    DWORD i;
    DWORD_PTR offset;
    STRING_TABLE inftable,comptable;
    PVOID infdata,compdata;
    PSTRING_NODEW node;
    POC_INF pocinf;
    deb_POPTIONAL_COMPONENTW pcomp;
    DWORD Mask = 0;
    PLONG count;

    INIT_API();


    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pocm = (PVOID)GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        Mask = (DWORD)GetExpression( lpArgumentString );
    }

    move( ocm,(LPVOID)pocm);

    //
    // dump the OCM structure
    //
    dprintf("OC_MANAGER structure at Address:\t0x%08x\n", (ULONG_PTR) pocm);
    dprintf("\tCallbacks :\n");
    dprintf("\t\tFillInSetupDataA:\t0x%08x\n", (ULONG_PTR) ocm.Callbacks.FillInSetupDataA);
    dprintf("\t\tLogError:\t\t0x%08x\n", (ULONG_PTR) ocm.Callbacks.LogError);
    dprintf("\t\tSetReboot:\t\t0x%08x\n", (ULONG_PTR) ocm.Callbacks.SetReboot);
    dprintf("\t\tFillInSetupDataW:\t0x%08x\n", (ULONG_PTR) ocm.Callbacks.FillInSetupDataW);

    dprintf("\tMasterOcInf:\t\t0x%08x\n",    ocm.MasterOcInf);
    dprintf("\tUnattendedInf:\t\t0x%08x\n",  ocm.UnattendedInf);
    dprintf("\tMasterOcInfPath:\t%ws\n",  ocm.MasterOcInfPath);
    dprintf("\tUnattendInfPath:\t%ws\n",  ocm.UnattendedInfPath);
    dprintf("\tSourceDir:\t\t%ws\n",        ocm.SourceDir);
    dprintf("\tSuiteName:\t\t%ws\n",        ocm.SuiteName);
    dprintf("\tSetupPageTitle:\t\t%ws\n",   ocm.SetupPageTitle);
    dprintf("\tWindowTitle:\t%ws\n",      ocm.WindowTitle);
    dprintf("\tInfListStringTable:\t0x%08x\n",      (ULONG_PTR)ocm.InfListStringTable);
    dprintf("\tComponentStringTable:\t0x%08x\n",    (ULONG_PTR)ocm.ComponentStringTable);
    dprintf("\tComponentStringTable:\t0x%08x\n",    (ULONG_PTR)ocm.OcSetupPage);
    dprintf("\tSetupMode:\t\t%d\n",        ocm.SetupMode);
    dprintf("\tTopLevelOcCount:\t%d\n",        ocm.TopLevelOcCount);
    // Issue-vijeshs-09/18/2000: from 1 to count
    count = malloc ( ocm.TopLevelOcCount * sizeof(LONG) );

    if (count) {
        // read and dump needs list
        ReadMemory((LPVOID) ocm.TopLevelOcStringIds, count, ocm.TopLevelOcCount *sizeof(LONG), NULL);
        for (i = 0; i < ocm.TopLevelOcCount; i++) {
            dprintf("\t TopLevelOcStringIds #%d:\t0x%08x\n", i, count[i]);

            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf("\tTopLevelParenOcCount:\t%d\n",        ocm.TopLevelParentOcCount);

    count = malloc ( ocm.TopLevelParentOcCount * sizeof(LONG) );

    if (count) {
        // read and dump needs list
        ReadMemory((LPVOID) ocm.TopLevelParentOcStringIds, count, ocm.TopLevelParentOcCount *sizeof(LONG), NULL);
        for (i = 0; i < ocm.TopLevelParentOcCount; i++) {
            dprintf("\t TopLevelParentOcStringIds #%d:\t0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf("\tSubComponentsPresent:\t%d\n",        ocm.SubComponentsPresent);

    //
    // Issue-vijeshs-09/18/2000:WizardPagesOrder there's not really any way to tell the exact upper bound of
    // each array, though we know that it's <= TopLevelParentOcCount...since this is the case
    // we just dump the point to each array of pages...
    //
    for (i = 0; i < WizPagesTypeMax; i++) {
        dprintf("\tWizardPagesOrder[%i] (%s)\t: 0x%08x\n",
                i,
                GetWizPage(i),
                ocm.WizardPagesOrder[i] );
        if (CheckInterupted()) {
                return;
            }
    }

    dprintf("\tPrivateDataSubkey:\t%ws\n", ocm.PrivateDataSubkey);
    dprintf("\thKeyPrivateData:\t0x%08x\n", ocm.hKeyPrivateData);
    dprintf("\thKeyPrivateDataRoot:\t0x%08x\n", ocm.hKeyPrivateDataRoot);
    dprintf("\tProgressTextWindow:\t0x%08x\n", ocm.ProgressTextWindow);

    dprintf("\tCurrentComponentStringId:\t0x%08x\n", ocm.CurrentComponentStringId);
    dprintf("\tAbortedCount:\t\t%d\n",        ocm.AbortedCount);

    count = malloc ( ocm.AbortedCount * sizeof(LONG) );

    if (count) {
        // read and dump needs list
        ReadMemory((LPVOID) ocm.AbortedComponentIds, count, ocm.AbortedCount *sizeof(LONG), NULL);
        for (i = 0; i < (DWORD)ocm.AbortedCount; i++) {
            dprintf("\t AbortedComponentIds #%d:\t0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf("\tInternalFlags:\t\t0x%08x\n\n\n",        ocm.InternalFlags);

    dprintf("\tSetupData.SetupMode :\t0x%08x\n", ocm.SetupData.SetupMode );
    dprintf("\tSetupData.ProductType :\t0x%08x\n", ocm.SetupData.ProductType );
    dprintf("\tSetupData.OperationFlags :\t0x%08x\n", ocm.SetupData.OperationFlags );
    dprintf("\tSetupData.SourcePath :\t%ws\n", ocm.SetupData.SourcePath );
    dprintf("\tSetupData.UnattendFile :\t%ws\n", ocm.SetupData.UnattendFile );

    if ((Mask&1) && ocm.InfListStringTable) {
        dprintf("\t\t***InfListStringTable***\n");
        move (inftable, ocm.InfListStringTable);
        infdata = GetStringTableData( &inftable );
        if (!infdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        // now, dump each node with data in the string table
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(infdata, ((PULONG_PTR)infdata)[i], &offset );
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                //dprintf("Data at hash bucket %d\n", i);
                while (node) {
                    //dprintf("\tNode Name:%ws\n", node->String);
                    pocinf = (POC_INF) GetStringNodeExtraData( node );
                    if (pocinf) {
                        dprintf("\tNode Data for %ws (0x%08x): 0x%08x\n",
                                node->String,
                                offset,
                                pocinf->Handle
                                );
                    } else {
                        dprintf("\tNo Node Data for %ws\n",
                                node->String
                                );
                    }
                    node = GetNextNode( infdata, node, &offset );
                    if (CheckInterupted()) {
                        return;
                    }
                }
            }
        }
        free( infdata );
        dprintf("\n\n");
    }

    if ((Mask&1) && ocm.ComponentStringTable) {
        dprintf("\t\t***ComponentStringTable***\n");
        move (comptable, ocm.ComponentStringTable);
        compdata = GetStringTableData( &comptable );
        if (!compdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        //
        // dump each node with data in the string table
        //
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(infdata, ((PULONG_PTR)infdata)[i], &offset );
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                //dprintf("Data at hash bucket %d\n", i);
                while (node) {
                    //dprintf("\tNode Name:%ws\n", node->String);
                    pcomp = (deb_POPTIONAL_COMPONENTW) GetStringNodeExtraData( node );
                    if (pcomp) {
                        DumpOcComponent( offset , node, pcomp );
                    } else {
                        dprintf("\tNo Node Data for %ws\n",
                                node->String
                                );
                    }

                    if (CheckInterupted()) {
                       return;
                    }

                    node = GetNextNode( infdata, node, &offset );
                }
            }
        }

        free( compdata );
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setexts\ocmdeb.h ===
// This header can go away once the types in oc.h are fixed to support
// ansi and unicode at the same time.



#ifndef UNICODE
    #define POC_FILL_IN_SETUP_DATA_PROC_W ULONG_PTR
#endif    

typedef struct _deb_OCM_CLIENT_CALLBACKSW {
    //
    // Routine to fill in the setup data structure that provides info
    // about the environment in which the OC Manager is running.
    //
    POC_FILL_IN_SETUP_DATA_PROC_A FillInSetupDataA;

    //
    // Routine to log an error.
    //
    POC_LOG_ERROR LogError;

    //
    // Routine to indicate need to reboot
    //
    POC_SET_REBOOT_PROC SetReboot;
    
    POC_FILL_IN_SETUP_DATA_PROC_W FillInSetupDataW;

} deb_OCM_CLIENT_CALLBACKSW, *deb_POCM_CLIENT_CALLBACKSW;


typedef struct _deb_OCM_CLIENT_CALLBACKSA {
    //
    // Routine to fill in the setup data structure that provides info
    // about the environment in which the OC Manager is running.
    //
    POC_FILL_IN_SETUP_DATA_PROC_A FillInSetupDataA;

    //
    // Routine to log an error.
    //
    POC_LOG_ERROR LogError;

    //
    // Routine to indicate need to reboot
    //
    POC_SET_REBOOT_PROC SetReboot;

} deb_OCM_CLIENT_CALLBACKSA, *deb_POCM_CLIENT_CALLBACKSA;

typedef struct _deb_OPTIONAL_COMPONENTA {
    //
    // String id of name of inf file in the OC Manager's
    // InfListStringTable string table. If -1, then
    // the subcomponent does not appear on the OC page.
    //
    LONG InfStringId;

    //
    // Backpointer to top level component
    //
    LONG TopLevelStringId;

    //
    // String id of parent component, -1 if none.
    //
    LONG ParentStringId;

    //
    // String id of first child, -1 if none.
    //
    LONG FirstChildStringId;

    //
    // Count of children.
    //
    UINT ChildrenCount;

    //
    // String id of next sibling, -1 if none.
    //
    LONG NextSiblingStringId;

    //
    // String ids of needs and needed by.
    //
    PLONG NeedsStringIds;
    UINT NeedsCount;
    PLONG NeededByStringIds;
    UINT NeededByCount;

    // String ids of exclude and excluded by

    PLONG ExcludeStringIds;
    UINT ExcludeCount;
    PLONG ExcludedByStringIds;
    UINT ExcludedByCount;

    //
    // Misc flags.
    //
    UINT InternalFlags;

    //
    // Approximation of required disk space.
    //
    LONGLONG SizeApproximation;

    //
    // Icon index of the component.
    // -1 means we're supposed to get it from the component itself.
    // -2 means we're supposed to use IconDll and IconResource
    //
    UINT IconIndex;
    CHAR IconDll[MAX_PATH];
    CHAR IconResource[50];

    //
    // Selection state (SELSTATE_xxx constants).
    //
    UINT SelectionState;
    UINT OriginalSelectionState;

    // Installation Flag as obtained from the inf

    UINT InstalledState;

    //
    // Mode bits.
    //
    UINT ModeBits;

    //
    // Human-readable stuff describing the component.
    //
    CHAR Description[MAXOCDESC];
    CHAR Tip[MAXOCTIP];

    //
    // From here down, stuff is meaningful only for top-level components.
    //

    //
    // Stuff describing the OC's installation DLL and how to call it.
    //
    CHAR InstallationDllName[MAX_PATH];
    CHAR InterfaceFunctionName[MAX_PATH];

    HMODULE InstallationDll;
    POCSETUPPROC InstallationRoutine;

    //
    // Version of the OC Manager to which this component was written.
    //
    UINT ExpectedVersion;

    // this flag indicates whether the subcomponent was intialialized

    BOOL Exists;

    //
    // Flags: ANSI/Unicode, etc.
    //
    UINT Flags;

} deb_OPTIONAL_COMPONENTA, *deb_POPTIONAL_COMPONENTA;

//
// locale info
//
typedef struct _deb_LOCALEA {
    LCID    lcid;
    CHAR   DecimalSeparator[4];
} deb_LOCALEA, *deb_PLOCALEA;
    
//
// Define structure corresponding to an instance of the OC Manager.
// This is actually somewhat broken, in that this actually closely corresponds
// to a master OC INF, and we might want to consider breaking out the string
// tables into another structure, so we can more easily achieve a unified
// namespace if we have multiple master OC INFs at play simultaneously.
//
typedef struct _deb_OC_MANAGERA {
	//
    // Callbacks into OC Manaer client.
    //
    deb_OCM_CLIENT_CALLBACKSA Callbacks;

    //
    // Handle of Master OC INF.
    //
    HINF MasterOcInf;

    //
    // unattended inf handle
    //
    HINF UnattendedInf;

    //
    // Master OC Inf file, and unattended file
    //
    CHAR MasterOcInfPath[MAX_PATH];
    CHAR UnattendedInfPath[MAX_PATH];

    // we run from whatever directory the master inf is in

    CHAR SourceDir[MAX_PATH];

    //
    // Name of "suite" -- in other words, a shortname that
    // is unique to the master OC inf that this structure represents.
    // We base it on the name of the master OC inf itself.
    //
    CHAR SuiteName[MAX_PATH];

    //
    // page titles
    //
    CHAR SetupPageTitle[MAX_PATH];

    // window title

    CHAR WindowTitle[MAX_PATH];
    
    //
    // List of per-component OC INFs currently loaded.
    // Each inf's name is in the string table and the extra data
    // for each is an OC_INF structure.
    //
    PVOID InfListStringTable;

    //
    // String table for names of all components and subcomponents.
    // Extra data for each is an OPTIONAL_COMPONENT structure.
    //
    PVOID ComponentStringTable;

    //
    // pointer to OcSetupPage structure so we can free this data
    // if the user cancels before we get to the wizard page.
    //
    PVOID OcSetupPage;


    //
    // Setup mode (custom, typical, etc)
    //
    UINT SetupMode;

    //
    // List of top-level optional component string IDs.
    // This is necessary because we need to preserve ordering
    // from the master OC Inf.
    //
    UINT TopLevelOcCount;
    PLONG TopLevelOcStringIds;
    UINT TopLevelParentOcCount;
    PLONG TopLevelParentOcStringIds;


    //
    // Are there subcomponents on the details page?
    //
    BOOL SubComponentsPresent;

    //
    // Each element in this array points to an array that
    // gives ordering for querying wizard pages from the optional components.
    //
    PLONG WizardPagesOrder[WizPagesTypeMax];

    //
    // Subkey relative to szPrivateDataRoot where private
    // data for components plugged into the OC will live.
    // 2 8-char DWORD representations plus a separator and nul.
    //
    CHAR PrivateDataSubkey[18];
    HKEY hKeyPrivateData;
    HKEY hKeyPrivateDataRoot;

    //
    // If we are completing installation, this item is the window handle
    // of the progress text control.
    //
    HWND ProgressTextWindow;

    //
    // String id of component currently processing an interface routine.
    // -1 means the OC manager is not currently processing one.
    //
    LONG CurrentComponentStringId;

    // Component Ids of aborted components

    LONG *AbortedComponentIds;
    UINT   AbortedCount;

    //
    // Various flags
    //
    UINT InternalFlags;

    //
    // setup data
    //

    SETUP_DATA SetupData;

} deb_OC_MANAGERA, *deb_POC_MANAGERA;



typedef struct _deb_OPTIONAL_COMPONENTW {
    //
    // String id of name of inf file in the OC Manager's
    // InfListStringTable string table. If -1, then
    // the subcomponent does not appear on the OC page.
    //
    LONG InfStringId;

    //
    // Backpointer to top level component
    //
    LONG TopLevelStringId;

    //
    // String id of parent component, -1 if none.
    //
    LONG ParentStringId;

    //
    // String id of first child, -1 if none.
    //
    LONG FirstChildStringId;

    //
    // Count of children.
    //
    UINT ChildrenCount;

    //
    // String id of next sibling, -1 if none.
    //
    LONG NextSiblingStringId;

    //
    // String ids of needs and needed by.
    //
    PLONG NeedsStringIds;
    UINT NeedsCount;
    PLONG NeededByStringIds;
    UINT NeededByCount;

    // String ids of exclude and excluded by

    PLONG ExcludeStringIds;
    UINT ExcludeCount;
    PLONG ExcludedByStringIds;
    UINT ExcludedByCount;

    //
    // Misc flags.
    //
    UINT InternalFlags;

    //
    // Approximation of required disk space.
    //
    LONGLONG SizeApproximation;

    //
    // Icon index of the component.
    // -1 means we're supposed to get it from the component itself.
    // -2 means we're supposed to use IconDll and IconResource
    //
    UINT IconIndex;
    WCHAR IconDll[MAX_PATH];
    WCHAR IconResource[50];

    //
    // Selection state (SELSTATE_xxx constants).
    //
    UINT SelectionState;
    UINT OriginalSelectionState;

    // Installation Flag as obtained from the inf

    UINT InstalledState;

    //
    // Mode bits.
    //
    UINT ModeBits;

    //
    // Human-readable stuff describing the component.
    //
    WCHAR Description[MAXOCDESC];
    WCHAR Tip[MAXOCTIP];

    //
    // From here down, stuff is meaningful only for top-level components.
    //

    //
    // Stuff describing the OC's installation DLL and how to call it.
    //
    WCHAR InstallationDllName[MAX_PATH];
    CHAR InterfaceFunctionName[MAX_PATH];

    HMODULE InstallationDll;
    POCSETUPPROC InstallationRoutine;

    //
    // Version of the OC Manager to which this component was written.
    //
    UINT ExpectedVersion;

    // this flag indicates whether the subcomponent was intialialized

    BOOL Exists;

    //
    // Flags: ANSI/Unicode, etc.
    //
    UINT Flags;

} deb_OPTIONAL_COMPONENTW, *deb_POPTIONAL_COMPONENTW;

//
// locale info
//
typedef struct _deb_LOCALEW {
    LCID    lcid;
    WCHAR   DecimalSeparator[4];
} deb_LOCALEW, *deb_PLOCALEW;
    
//
// Define structure corresponding to an instance of the OC Manager.
// This is actually somewhat broken, in that this actually closely corresponds
// to a master OC INF, and we might want to consider breaking out the string
// tables into another structure, so we can more easily achieve a unified
// namespace if we have multiple master OC INFs at play simultaneously.
//
typedef struct _deb_OC_MANAGERW {
	//
    // Callbacks into OC Manaer client.
    //
    deb_OCM_CLIENT_CALLBACKSW Callbacks;

    //
    // Handle of Master OC INF.
    //
    HINF MasterOcInf;

    //
    // unattended inf handle
    //
    HINF UnattendedInf;

    //
    // Master OC Inf file, and unattended file
    //
    WCHAR MasterOcInfPath[MAX_PATH];
    WCHAR UnattendedInfPath[MAX_PATH];

    // we run from whatever directory the master inf is in

    WCHAR SourceDir[MAX_PATH];

    //
    // Name of "suite" -- in other words, a shortname that
    // is unique to the master OC inf that this structure represents.
    // We base it on the name of the master OC inf itself.
    //
    WCHAR SuiteName[MAX_PATH];

    //
    // page titles
    //
    WCHAR SetupPageTitle[MAX_PATH];

    // window title

    WCHAR WindowTitle[MAX_PATH];
    
    //
    // List of per-component OC INFs currently loaded.
    // Each inf's name is in the string table and the extra data
    // for each is an OC_INF structure.
    //
    PVOID InfListStringTable;

    //
    // String table for names of all components and subcomponents.
    // Extra data for each is an OPTIONAL_COMPONENT structure.
    //
    PVOID ComponentStringTable;

    //
    // pointer to OcSetupPage structure so we can free this data
    // if the user cancels before we get to the wizard page.
    //
    PVOID OcSetupPage;

    //
    // Setup mode (custom, typical, etc)
    //
    UINT SetupMode;

    //
    // List of top-level optional component string IDs.
    // This is necessary because we need to preserve ordering
    // from the master OC Inf.
    //
    UINT TopLevelOcCount;
    PLONG TopLevelOcStringIds;
    UINT TopLevelParentOcCount;
    PLONG TopLevelParentOcStringIds;


    //
    // Are there subcomponents on the details page?
    //
    BOOL SubComponentsPresent;

    //
    // Each element in this array points to an array that
    // gives ordering for querying wizard pages from the optional components.
    //
    PLONG WizardPagesOrder[WizPagesTypeMax];

    //
    // Subkey relative to szPrivateDataRoot where private
    // data for components plugged into the OC will live.
    // 2 8-char DWORD representations plus a separator and nul.
    //
    WCHAR PrivateDataSubkey[18];
    HKEY hKeyPrivateData;
    HKEY hKeyPrivateDataRoot;

    //
    // If we are completing installation, this item is the window handle
    // of the progress text control.
    //
    HWND ProgressTextWindow;

    //
    // String id of component currently processing an interface routine.
    // -1 means the OC manager is not currently processing one.
    //
    LONG CurrentComponentStringId;

    // Component Ids of aborted components

    LONG *AbortedComponentIds;
    int   AbortedCount;

    //
    // Various flags
    //
    UINT InternalFlags;

    //
    // setup data
    //

    SETUP_DATAW SetupData;

} deb_OC_MANAGERW, *deb_POC_MANAGERW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setexts\winnt32.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#include "ntsdextp.h"

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;


VOID
PrintFlagValue(
    LPCTSTR lpString
    )
{

    BOOL retval= FALSE;
    PVOID p;
    TCHAR Argument[100];

    sprintf( Argument, "winnt32u!%s", lpString );

    p = (PVOID) GetExpression( Argument );
    if (!p) {
        sprintf( Argument, "winnt32a!%s", lpString );
        p = (PVOID) GetExpression( Argument );
    }

    if (p) {
        move( retval, p );
        dprintf( "%s : %s (at address 0x%08x)\n", lpString, retval ? "TRUE" : "FALSE", p );
    } else {
        dprintf( "Couldn't find global flag %s\n" , lpString );
    }


}

#define ANSIFORMAT          "%s : %s (at address 0x%08x)\n"
#define UNICODEFORMAT       "%s : %ws (at address 0x%08x)\n"
#define ANSIARRAYFORMAT     "%s[%i] : %s (at address 0x%08x)\n"
#define UNICODEARRAYFORMAT  "%s[%i] : %ws (at address 0x%08x)\n"
#define MAX_OPTIONALDIRS    20
#define MAX_SOURCE_COUNT    8

VOID
PrintStringBufferValue(
    LPCTSTR lpString
    )
{

    WCHAR Data[MAX_PATH];
    PVOID p;
    TCHAR Argument[100];
    BOOL fUnicode = TRUE;

    sprintf( Argument, "winnt32u!%s", lpString );

    p = (PVOID) GetExpression( Argument );
    if (!p) {
        sprintf( Argument, "winnt32a!%s", lpString );
        p = (PVOID) GetExpression( Argument );
        fUnicode = FALSE;
    }

    if (p) {
        move( Data, p );
        dprintf( fUnicode ? UNICODEFORMAT : ANSIFORMAT, lpString, Data, p );
    } else {
        dprintf( "Couldn't find global string buffer %s\n" , lpString );
    }

}

VOID
PrintStringBufferArrayValue(
    LPCTSTR lpString,
    DWORD ElementSize,
    DWORD ArraySize
    )
{

    WCHAR Data[MAX_PATH];
    PVOID p;
    TCHAR Argument[100];
    TCHAR Format[100];
    BOOL fUnicode = TRUE;
    DWORD i;

    sprintf( Argument, "winnt32u!%s", lpString );

    p = (PVOID) GetExpression( Argument );
    if (!p) {
        sprintf( Argument, "winnt32a!%s", lpString );
        p = (PVOID) GetExpression( Argument );
        fUnicode = FALSE;
    }

    if (p) {
        for (i = 0; i< ArraySize; i++) {
            move( Data, ((LPBYTE)p+(i*ElementSize* (fUnicode) ? sizeof(WCHAR) : sizeof(CHAR))) );
            dprintf( fUnicode ? UNICODEARRAYFORMAT : ANSIARRAYFORMAT ,
                     lpString, i, Data, p );
        }
        
    } else {
        dprintf( "Couldn't find global string buffer %s\n" , lpString );
    }

}






DECLARE_API( winntflags )
/*++

Routine Description:

    This debugger extension dumps winnt32 flags

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pst;
    
    DWORD i, offset;
    PVOID stdata,pextradata;
    
    //BOOL val;

    INIT_API();

    dprintf("\t\t****winnt32 global flags****\n");
    PrintFlagValue( "Server" );
    PrintFlagValue( "Upgrade" );
    PrintFlagValue( "UnattendedOperation" );
    dprintf("\n");
    
    PrintFlagValue( "CheckUpgradeOnly" );           
    PrintFlagValue( "Aborted" );           
    PrintFlagValue( "Cancelled" );
    PrintFlagValue( "CancelPending" );           
    dprintf("\n");

    PrintFlagValue( "ChoosePartition" );           
    PrintFlagValue( "Floppyless" );           
    PrintFlagValue( "ForceNTFSConversion" );           
    PrintFlagValue( "NTFSConversionChanged" );           
    PrintFlagValue( "HideWinDir" );           
    PrintFlagValue( "MakeBootMedia" );           
    PrintFlagValue( "MakeLocalSource" );           
    PrintFlagValue( "OemPreinstall" );           
    PrintFlagValue( "RunFromCD" );           
    dprintf("\n");

    PrintFlagValue( "BlockOnNotEnoughSpace" );           
    PrintFlagValue( "SkipLocaleCheck" );           
    PrintFlagValue( "AccessibleKeyboard" );           
    PrintFlagValue( "AccessibleMagnifier" );           
    PrintFlagValue( "AccessibleReader" );           
    PrintFlagValue( "AccessibleSetup" );           
    PrintFlagValue( "AccessibleVoice" );           
    PrintFlagValue( "AutomaticallyShutDown" );           
    PrintFlagValue( "AutoSkipMissingFiles" );           
    dprintf("\n");
            
    PrintFlagValue( "GlobalResult" );                              
    dprintf("\n");

}

DECLARE_API( winntstr )
/*++

Routine Description:

    This debugger extension dumps winnt32 string global info

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pst;
    
    DWORD i, offset;
    PVOID stdata,pextradata;
    
    //BOOL val;

    INIT_API();

    dprintf("\t\t****winnt32 global strings****\n");
    PrintStringBufferValue( "AccessibleScriptFile" );
    PrintStringBufferValue( "AlternateSourcePath" );
    PrintStringBufferValue( "FirstFloppyDriveLetter" );
    PrintStringBufferValue( "ForcedSystemPartition" );
    PrintStringBufferValue( "InfName" );
    PrintStringBufferValue( "InstallDir" );
    PrintStringBufferValue( "LocalBackupDirectory" );
    PrintStringBufferValue( "LocalBootDirectory" );
    PrintStringBufferValue( "LocalSourceDirectory" );
    PrintStringBufferValue( "LocalSourceDrive" );
    PrintStringBufferValue( "LocalSourceWithPlatform" );
    PrintStringBufferValue( "ProductId" );
    PrintStringBufferValue( "SystemPartitionDriveLetter" );
    PrintStringBufferValue( "SystemPartitionDriveLetters" );
    PrintStringBufferValue( "UserSpecifiedLocalSourceDrive" );
    PrintStringBufferArrayValue( "OptionalDirectories", MAX_PATH, MAX_OPTIONALDIRS );
    PrintStringBufferArrayValue( "SourcePaths", MAX_PATH, MAX_SOURCE_COUNT );
    
    dprintf("\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setexts\setupapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    setupapi.c

Abstract:

    This function contains the setupapi debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#include "ntsdextp.h"
#include <setupapi.h>

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;


VOID
DumpXFile(
    PXFILE pxf,
    DWORD mask
    )
{
    PVOID pst;
    DWORD i, offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;

    if ((mask & 4) == 0 ) {
        return;
    }

    dprintf( "\t\t     ***XFILE structure***\n" );
    dprintf( "\t\t      CurrentSize : 0x%x", pxf->CurrentSize );
    if (pxf->CurrentSize == -1) {
        dprintf( " (doesn't currently exist)" );
    }
    dprintf( "\n\t\t      NewSize : 0x%x", pxf->NewSize );
    if (pxf->NewSize == -1) {
        dprintf( " (will be deleted)" );
    }
    dprintf("\n");

}


VOID
DumpXDirectory(
    PXDIRECTORY pxd,
    DWORD mask
    )
{
    PVOID pst;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;
    PXFILE pxf;

    if ((mask & 2) == 0 ) {
        return;
    }

    dprintf( "\t\t   ***XDIRECTORY structure***\n", pxd );
    dprintf( "\t\t    SpaceRequired : 0x%x\n", pxd->SpaceRequired );
    dprintf( "\t\t    FilesTable : 08%08x\n", pxd->FilesTable );

    move ( st, pxd->FilesTable ) ;

    dprintf("\t\t    ***FilesTable***\n");

    dprintf("\t\t    Base Data ptr:\t0x%08x\n",  st.Data);
    dprintf("\t\t    DataSize:\t0x%08x\n",       st.DataSize);
    dprintf("\t\t    BufferSize:\t0x%08x\n",     st.BufferSize);
    dprintf("\t\t    ExtraDataSize:\t0x%08x\n",  st.ExtraDataSize);

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("\t\t    Data at hash bucket %d\n", i);
            while (node) {
                dprintf("\t\t     Entry Name:\t%ws (0x%08x)\n", node->String, offset);

                pxf = (PXFILE) GetStringNodeExtraData( node );
                DumpXFile( pxf, mask );
                free(pxf);

                node = GetNextNode( stdata, node, &offset );
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
            return;
        }

    }

    free( stdata );

}


VOID
DumpXDrive(
    PXDRIVE pxd,
    DWORD mask
    )
{
    PVOID pst;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;
    PXDIRECTORY pxdir;

    if ((mask & 1) == 0) {
        return;
    }

    dprintf( "\t\t***XDRIVE structure***\n", pxd );
    dprintf( "\t\t SpaceRequired : 0x%x\n", pxd->SpaceRequired );
    dprintf( "\t\t BytesPerCluster : 08%08x\n", pxd->BytesPerCluster );
    dprintf( "\t\t Slop : 08%x\n", pxd->Slop );
    dprintf( "\t\t DirsTable : 08%08x\n", pxd->DirsTable );

    move ( st, pxd->DirsTable ) ;

    dprintf("\t\t ***DirsTable***\n");

    dprintf("\t\t  Base Data ptr:\t0x%08x\n",  st.Data);
    dprintf("\t\t  DataSize:\t0x%08x\n",       st.DataSize);
    dprintf("\t\t  BufferSize:\t0x%08x\n",     st.BufferSize);
    dprintf("\t\t  ExtraDataSize:\t0x%08x\n",  st.ExtraDataSize);

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("\t\t  Data at hash bucket %d\n", i);
            while (node) {
                dprintf("\t\t   Entry Name:\t%ws (0x%08x)\n", node->String, offset);

                pxdir = (PXDIRECTORY) GetStringNodeExtraData( node );
                DumpXDirectory( pxdir, mask );
                free(pxdir);

                node = GetNextNode( stdata, node, &offset );
                if (CheckInterupted()) {
                    return;
                }
            }
        }
        if (CheckInterupted()) {
            return;
        }
    }

    free( stdata );

}


DECLARE_API( space )
/*++

Routine Description:

    This debugger extension dumps the data related to a HDSKSPC structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pds,pst;
    DISK_SPACE_LIST dsl;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;
    PXDRIVE pxd;
    DWORD Mask = 0;


    //BOOL val;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pds = (PVOID)GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        Mask = (DWORD)GetExpression( lpArgumentString );
    }

    move( dsl , pds );

    dprintf("DISK_SPACE_LIST at :\t0x%08x\n", (ULONG_PTR) pds);
    dprintf("\tLock[0] : 0x%08x\n", dsl.Lock.handles[0]);
    dprintf("\tLock[1] : 0x%08x\n", dsl.Lock.handles[1]);
    dprintf("\tDrivesTable : 0x%08x\n", dsl.DrivesTable );
    dprintf("\tFlags : 0x%08x\n", dsl.Flags);

    move ( st, dsl.DrivesTable ) ;

    dprintf("\t ***DrivesTable***\n");
    DumpStringTableHeader( &st );

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("\t\tData at hash bucket %d\n", i);
            while (node) {
                dprintf("\t\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);

                pxd = (PXDRIVE) GetStringNodeExtraData( node );
                DumpXDrive( pxd, Mask );
                free(pxd);

                node = GetNextNode( stdata, node, &offset );
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }
    free( stdata );



}

#define TRACK_ARG_DECLARE
#define TRACK_ARG_COMMA

#include "cntxtlog.h"
#include "backup.h"
#include "fileq.h"

VOID DumpAltPlatformInfo( PSP_ALTPLATFORM_INFO api, DWORD mask );
VOID DumpFileQueueNodeList( PSP_FILE_QUEUE_NODE pfqn, DWORD mask, BOOL recursive ) ;
VOID DumpSourceMediaInfoList( PSOURCE_MEDIA_INFO smi, DWORD mask, BOOL recursive );
VOID DumpCatalogInfoList( PSPQ_CATALOG_INFO ci, DWORD mask, BOOL recursive );
VOID DumpUnwindList( PSP_UNWIND_NODE pun, DWORD mask, BOOL recursive );
VOID DumpDelayMoveList( PSP_DELAYMOVE_NODE pdn, DWORD mask, BOOL recursive );

VOID
DumpAltPlatformInfo(
    PSP_ALTPLATFORM_INFO api,
    DWORD mask
    )
{
    //if ((mask & 4) == 0 ) {
    //    return;
    //}

    dprintf( "\t\t***SP_ALT_PLATFORM_INFO structure***\n" );
    dprintf( "\t\t cbSize : 0x%x\n", api->cbSize );
    dprintf( "\t\t Platform : 0x%x\n", api->Platform );
    dprintf( "\t\t MajorVersion : 0x%x\n", api->MajorVersion );
    dprintf( "\t\t MinorVersion : 0x%x\n", api->MinorVersion );
    dprintf( "\t\t ProcessorArchitecture : 0x%x\n", api->ProcessorArchitecture );
    dprintf( "\t\t Reserved : 0x%x\n", api->Reserved );

}

VOID
DumpFileQueueNodeList(
    PSP_FILE_QUEUE_NODE pfqn,
    DWORD mask,
    BOOL recursive
    )
{
    //PVOID pst;
    //DWORD i, offset;
    //PVOID stdata,pextradata;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;

    //if ((mask & 4) == 0 ) {
    //    return;
    //}

    SP_FILE_QUEUE_NODE next;
    SOURCE_MEDIA_INFO smi;
    SPQ_CATALOG_INFO ci;

    dprintf( "\t\t***SP_FILE_QUEUE_NODE structure***\n" );
    dprintf( "\t\t Next : 0x%x\n", pfqn->Next );
    dprintf( "\t\t Operation : 0x%x ( %s )\n", pfqn->Operation,
             (pfqn->Operation == FILEOP_DELETE) ? "DELETE" :
             (pfqn->Operation == FILEOP_RENAME) ? "RENAME" :
             "COPY" );


    dprintf( "\t\t SourceRootPath : 0x%x\n", pfqn->SourceRootPath );
    dprintf( "\t\t SourcePath : 0x%x\n", pfqn->SourcePath );
    dprintf( "\t\t SourceFilename : 0x%x\n", pfqn->SourceFilename );
    dprintf( "\t\t TargetDirectory : 0x%x\n", pfqn->TargetDirectory );
    dprintf( "\t\t SecurityDesc : 0x%x\n", pfqn->SecurityDesc );

    dprintf( "\t\t SourceMediaInfo : 0x%x\n", pfqn->SourceMediaInfo );
    if (pfqn->SourceMediaInfo  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move( smi, pfqn->SourceMediaInfo );
        DumpSourceMediaInfoList( &smi, mask, FALSE );
    }

    dprintf( "\t\t StyleFlags : 0x%x\n", pfqn->StyleFlags );
    dprintf( "\t\t InternalFlags : 0x%x\n", pfqn->InternalFlags );

    dprintf( "\t\t CatalogInfo : 0x%x\n", pfqn->CatalogInfo );
    if (pfqn->CatalogInfo  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move( ci, pfqn->CatalogInfo);
        DumpCatalogInfoList( &ci, mask, FALSE  );
    }

    if (pfqn->Next && recursive) {
        move( next, pfqn->Next );
        DumpFileQueueNodeList( &next, mask, TRUE );
    }

}

VOID
DumpSourceMediaInfoList(
    PSOURCE_MEDIA_INFO smi,
    DWORD mask,
    BOOL recursive
    )
{
    //PVOID pst;
    //DWORD i, offset;
    //PVOID stdata,pextradata;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;

    //if ((mask & 4) == 0 ) {
    //    return;
    //}

    SOURCE_MEDIA_INFO next;
    SP_FILE_QUEUE_NODE queue;

    dprintf( "\t\t***SOURCE_MEDIA_INFO structure***\n" );
    dprintf( "\t\t Next : 0x%x\n", smi->Next );
    dprintf( "\t\t Description : 0x%x\n", smi->Description );
    dprintf( "\t\t DescriptionDisplayName : 0x%x\n", smi->DescriptionDisplayName );
    dprintf( "\t\t Tagfile : 0x%x\n", smi->Tagfile );
    dprintf( "\t\t SourceRootPath : 0x%x\n", smi->SourceRootPath );
    dprintf( "\t\t CopyQueue : 0x%x\n", smi->CopyQueue );

    if (smi->CopyQueue && (mask & 8)  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move ( queue, smi->CopyQueue ) ;
        DumpFileQueueNodeList( &queue, mask, FALSE );
    }

    dprintf( "\t\t CopyNodeCount : 0x%x\n", smi->CopyNodeCount );
    dprintf( "\t\t Flags : 0x%x\n", smi->Flags );

    if (smi->Next && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move ( next, smi->Next ) ;
        DumpSourceMediaInfoList( &next, mask, TRUE );
    }

}

VOID
DumpCatalogInfoList(
    PSPQ_CATALOG_INFO ci,
    DWORD mask,
    BOOL recursive
    )
{
    //PVOID pst;
    //DWORD i, offset;
    //PVOID stdata,pextradata;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;

    //if ((mask & 4) == 0 ) {
    //    return;
    //}

    SPQ_CATALOG_INFO next;

    dprintf( "\t\t***SPQ_CATALOG_INFO structure***\n" );
    dprintf( "\t\t Next : 0x%x\n", ci->Next );
    dprintf( "\t\t CatalogFileFromInf : 0x%x\n", ci->CatalogFileFromInf );
    dprintf( "\t\t AltCatalogFileFromInf : 0x%x\n", ci->AltCatalogFileFromInf );
    dprintf( "\t\t AltCatalogFileFromInfPending : 0x%x\n", ci->AltCatalogFileFromInfPending );
    dprintf( "\t\t InfFullPath : 0x%x\n", ci->InfFullPath );
    dprintf( "\t\t InfOriginalName : 0x%x\n", ci->InfOriginalName );
    dprintf( "\t\t InfFinalPath : 0x%x\n", ci->InfFinalPath );
    dprintf( "\t\t VerificationFailureError : 0x%x\n", ci->VerificationFailureError );
    dprintf( "\t\t Flags : 0x%x\n", ci->Flags );
    dprintf( "\t\t CatalogFilenameOnSystem : %ws\n", ci->CatalogFilenameOnSystem  );

    if (ci->Next && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move(next, ci->Next );
        DumpCatalogInfoList( &next, mask, TRUE ) ;
    }

}

VOID
DumpUnwindList(
    PSP_UNWIND_NODE pun,
    DWORD mask,
    BOOL recursive
    )
{
    SP_UNWIND_NODE next;

    dprintf( "\t\t***SP_UNWIND_NODE structure***\n" );
    dprintf( "\t\t NextNode : 0x%x\n", pun->NextNode );
    dprintf( "\t\t TargetID : 0x%x\n", pun->TargetID );
    dprintf( "\t\t SecurityDesc : 0x%x\n", pun->SecurityDesc );
    dprintf( "\t\t CreateTime : 0x%x 0x%x\n",
             pun->CreateTime.dwLowDateTime,
             pun->CreateTime.dwHighDateTime );

    dprintf( "\t\t AccessTime : 0x%x 0x%x\n",
             pun->AccessTime.dwLowDateTime,
             pun->AccessTime.dwHighDateTime );

    dprintf( "\t\t WriteTime : 0x%x 0x%x\n",
             pun->WriteTime.dwLowDateTime,
             pun->WriteTime.dwHighDateTime );

    if (pun->NextNode && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move(next, pun->NextNode);
        DumpUnwindList( &next, mask, TRUE );
    }

}

VOID
DumpTargetEnt(
    PSP_TARGET_ENT pte,
    DWORD mask
    )
{
    dprintf( "\t\t***SP_TARGET_ENT structure***\n" );
    dprintf( "\t\t TargetRoot : 0x%x\n", pte->TargetRoot );
    dprintf( "\t\t TargetSubDir : 0x%x\n", pte->TargetSubDir );
    dprintf( "\t\t TargetFilename : 0x%x\n", pte->TargetFilename );
    dprintf( "\t\t BackupRoot : 0x%x\n", pte->BackupRoot );
    dprintf( "\t\t BackupSubDir : 0x%x\n", pte->BackupSubDir );
    dprintf( "\t\t BackupFilename : 0x%x\n", pte->BackupFilename );
    dprintf( "\t\t NewTargetFilename : 0x%x\n", pte->NewTargetFilename );
    dprintf( "\t\t InternalFlags : 0x%x\n", pte->InternalFlags );
}

VOID
DumpDelayMoveList(
    PSP_DELAYMOVE_NODE pdn,
    DWORD mask,
    BOOL recursive
    )
{
    SP_DELAYMOVE_NODE next;

    dprintf( "\t\t***SP_DELAYMOVE_NODE structure***\n" );
    dprintf( "\t\t NextNode : 0x%x\n", pdn->NextNode );
    dprintf( "\t\t SourceFilename : 0x%x\n", pdn->SourceFilename );
    dprintf( "\t\t TargetFilename : 0x%x\n", pdn->TargetFilename );
    dprintf( "\t\t SecurityDesc (stringtable index) : 0x%x\n", pdn->SecurityDesc );

    if (pdn->NextNode && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move(next,pdn->NextNode);
        DumpDelayMoveList( &next, mask, TRUE );
    }

}

DECLARE_API( queue )
/*++

Routine Description:

    This debugger extension dumps the data related to a HSPFILEQ

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pfq,pst;
    SP_FILE_QUEUE fq;
    PSP_TARGET_ENT pte;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;
    DWORD Mask = 0;


    //BOOL val;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pfq = (PVOID)GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        Mask = (DWORD)GetExpression( lpArgumentString );
    }

    move( fq , pfq );

    dprintf("SP_FILE_QUEUE at :\t0x%08x\n", (ULONG_PTR) pfq);
    dprintf("\t BackupQueue : 0x%08x\n", fq.BackupQueue);
    dprintf("\t DeleteQueue : 0x%08x\n", fq.DeleteQueue);
    dprintf("\t RenameQueue : 0x%08x\n", fq.RenameQueue);

    dprintf("\t CopyNodeCount : 0x%08x\n", fq.CopyNodeCount);
    dprintf("\t DeleteNodeCount : 0x%08x\n", fq.DeleteNodeCount);
    dprintf("\t RenameNodeCount : 0x%08x\n", fq.RenameNodeCount);
    dprintf("\t BackupNodeCount : 0x%08x\n", fq.BackupNodeCount);

    dprintf("\t SourceMediaList : 0x%08x\n", fq.SourceMediaList);
    dprintf("\t SourceMediaCount : 0x%08x\n", fq.SourceMediaCount);

    dprintf("\t CatalogList : 0x%08x\n", fq.CatalogList);
    dprintf("\t DriverSigningPolicy : 0x%08x (%s)\n",
            fq.DriverSigningPolicy,
            (fq.DriverSigningPolicy == DRIVERSIGN_BLOCKING) ? "DRIVERSIGN_BLOCKING" :
            (fq.DriverSigningPolicy == DRIVERSIGN_WARNING) ? "DRIVERSIGN_WARNING" :
            "DRIVERSIGN_NONE" );

    dprintf("\t hWndDriverSigningUi : 0x%08x\n", fq.hWndDriverSigningUi);
    dprintf("\t DeviceDescStringId : 0x%08x\n", fq.DeviceDescStringId);
    dprintf("\t AltPlatformInfo : 0x%08x\n", fq.AltPlatformInfo);

    DumpAltPlatformInfo( &fq.AltPlatformInfo, Mask );

    dprintf("\t AltCatalogFile : 0x%08x\n", fq.AltCatalogFile);

    dprintf("\t StringTable : 0x%08x\n", fq.StringTable);

    dprintf("\t LockRefCount : 0x%08x\n", fq.LockRefCount);
    dprintf("\t Flags : 0x%08x\n", fq.Flags);

    dprintf("\t SisSourceHandle : 0x%08x\n", fq.SisSourceHandle);
    dprintf("\t SisSourceDirectory : 0x%08x\n", fq.SisSourceDirectory);

    dprintf("\t BackupInfID : 0x%08x\n", fq.BackupInfID);
    dprintf("\t TargetLookupTable : 0x%08x\n", fq.TargetLookupTable);
    dprintf("\t UnwindQueue : 0x%08x\n", fq.UnwindQueue);
    dprintf("\t DelayMoveQueue : 0x%08x\n", fq.DelayMoveQueue);
    dprintf("\t DelayMoveQueueTail : 0x%08x\n", fq.DelayMoveQueueTail);

    dprintf("\t Signature : 0x%08x (%s)\n",
            fq.Signature,
            (fq.Signature == SP_FILE_QUEUE_SIG) ? "VALID" : "INVALID" );

    //
    // dump the queue nodes
    //

    if (Mask & 1) {
        SP_FILE_QUEUE_NODE qnode;
        SOURCE_MEDIA_INFO smi;

        if (fq.BackupQueue) {
            move(qnode, fq.BackupQueue);
            dprintf("\t ***BackupQueue***\n");
            DumpFileQueueNodeList( &qnode, Mask, TRUE );
        }

        if (fq.DeleteQueue) {
            move(qnode, fq.DeleteQueue);
            dprintf("\t ***DeleteQueue***\n");
            DumpFileQueueNodeList( &qnode, Mask, TRUE );
        }

        if (fq.RenameQueue) {
            move(qnode, fq.RenameQueue);
            dprintf("\t ***RenameQueue***\n");
            DumpFileQueueNodeList( &qnode, Mask, TRUE );
        }

        if (fq.SourceMediaList) {
            move(smi, fq.SourceMediaList);
            dprintf("\t ***source media list***\n");
            DumpSourceMediaInfoList( &smi, Mask, TRUE );
        }
    }

    //
    // dump the catalog info
    //
    if (Mask & 2) {
        SPQ_CATALOG_INFO ci;

        if (fq.CatalogList) {
            move(ci, fq.CatalogList);
            dprintf("\t ***CatalogList***\n");
            DumpCatalogInfoList( &ci, Mask, TRUE );
        }
    }

    //
    // dump the string table
    //
    if (Mask & 4) {
        dprintf("\t ***StringTable***\n");

        move ( st, fq.StringTable ) ;
        DumpStringTableHeader( &st );

        stdata = GetStringTableData( &st );
        if (!stdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        //
        // now, dump each node in the string table
        //
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                dprintf("\t\tData at hash bucket %d\n", i);
                while (node) {
                    dprintf("\t\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);

                    pextradata = st.Data + offset + (wcslen(node->String) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                    dprintf("\tExtra Data:\t0x%p\n", pextradata );

                    node = GetNextNode( stdata, node, &offset );
                    if (CheckInterupted()) {
                        return;
                    }
                }
            }

            if (CheckInterupted()) {
                    return;
            }
        }
        free( stdata );


        dprintf("\t ***TargetLookupTable***\n");

        move ( st, fq.TargetLookupTable ) ;
        DumpStringTableHeader( &st );

        stdata = GetStringTableData( &st );
        if (!stdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        //
        // now, dump each node in the string table
        //
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                dprintf("\t\tData at hash bucket %d\n", i);
                while (node) {
                    dprintf("\t\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);

                    pte = GetStringNodeExtraData( node );
                    DumpTargetEnt( pte, Mask );
                    free( pte );

                    node = GetNextNode( stdata, node, &offset );
                    if (CheckInterupted()) {
                        return;
                    }
                }
            }

            if (CheckInterupted()) {
                    return;
            }
        }
        free( stdata );

    }

    //
    // backup stuff
    //
    if (Mask & 8) {
        SP_UNWIND_NODE un;
        SP_DELAYMOVE_NODE dnode;

        if (fq.UnwindQueue) {
            move(un, fq.UnwindQueue);
            dprintf("\t ***UnwindQueue***\n");
            DumpUnwindList( &un, Mask, TRUE );
        }

        if (fq.DelayMoveQueue) {
            move(dnode, fq.DelayMoveQueue);
            dprintf("\t ***DelayMoveQueue***\n");
            DumpDelayMoveList( &dnode, Mask, TRUE );
        }

        if (fq.DelayMoveQueueTail) {
            move(dnode, fq.DelayMoveQueueTail);
            dprintf("\t ***DelayMoveQueueTail***\n");
            DumpDelayMoveList( &dnode, Mask, TRUE );
        }
    }
}


DECLARE_API( qcontext )
/*++

Routine Description:

    This debugger extension dumps the data related to a queue context structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pqc;
    QUEUECONTEXT qc;

    DWORD i, offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;

    //BOOL val;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pqc = (PVOID)GetExpression( lpArgumentString );

    move( qc , pqc );

    dprintf("QUEUECONTEXT at :\t0x%08x\n", (ULONG_PTR) pqc);
    dprintf("\t OwnerWindow : 0x%08x\n", qc.OwnerWindow);
    dprintf("\t MainThreadId : 0x%08x\n", qc.MainThreadId);
    dprintf("\t ProgressDialog : 0x%08x\n", qc.ProgressDialog);
    dprintf("\t ProgressBar : 0x%08x\n", qc.ProgressBar);
    dprintf("\t Cancelled : 0x%08x\n", qc.Cancelled);
    dprintf("\t CurrentSourceName : %ws\n", qc.CurrentSourceName);
    dprintf("\t ScreenReader : 0x%08x\n", qc.ScreenReader);
    dprintf("\t MessageBoxUp : 0x%08x\n", qc.MessageBoxUp);
    dprintf("\t PendingUiType : 0x%08x\n", qc.PendingUiType);
    dprintf("\t PendingUiParameters : 0x%08x\n", qc.PendingUiParameters);
    dprintf("\t CancelReturnCode : 0x%08x\n", qc.CancelReturnCode);
    dprintf("\t DialogKilled : 0x%08x\n", qc.DialogKilled);
    dprintf("\t AlternateProgressWindow : 0x%08x\n", qc.AlternateProgressWindow);
    dprintf("\t ProgressMsg : 0x%08x\n", qc.ProgressMsg);
    dprintf("\t NoToAllMask : 0x%08x\n", qc.NoToAllMask);
    dprintf("\t UiThreadHandle : 0x%08x\n", qc.UiThreadHandle);

}


//#include "inf.h"

VOID
DumpInfLine(
    PINF_LINE line,
    PBYTE valuedata
    )
{
    DWORD i;
    PVOID ptr;
    ULONG_PTR data;

//    dprintf("***INF_LINE***\n");
    dprintf("\t  ValueCount : 0x%x\n", line->ValueCount);
    dprintf("\t  Flags : 0x%x\n", line->Flags);
    dprintf("\t  Values : 0x%x\n", line->Values);

    if (line->Flags > 3) {
        return;
    }

    for (i = 0; i< line->ValueCount; i++) {
        ptr = valuedata + (ULONG_PTR)(line->Values *sizeof(ULONG_PTR)) + (ULONG_PTR)(i*sizeof(ULONG_PTR));
        move ( data, valuedata + (ULONG_PTR)(line->Values *sizeof(ULONG_PTR)) + (ULONG_PTR)(i*sizeof(ULONG_PTR)) );
        dprintf("\t data [%d] : 0x%x [0x%x]\n", i, ptr,data );

        if (CheckInterupted()) {
            return;
        }
    }
}


VOID
DumpInfSection(
    PINF_SECTION section,
    PBYTE linedata,
    PBYTE valuedata
    )
{
    DWORD i;
    INF_LINE line;
    PBYTE data;

    dprintf("***INF_SECTION***\n");
    dprintf("\t  SectionName : 0x%x\n", section->SectionName);
    dprintf("\t  LineCount : 0x%x\n", section->LineCount);
    dprintf("\t  Lines : 0x%x\n", section->Lines);

    for (i = 0; i< section->LineCount; i++) {

        data = linedata + (sizeof(INF_LINE)*section->Lines) + (ULONG_PTR)(sizeof(INF_LINE)*i);
        dprintf("***INF_LINE [%i] at 0x%x***\n",i, data);
        moveBlock ( line, (PBYTE) linedata + (sizeof(INF_LINE)*section->Lines) + (ULONG_PTR)(sizeof(INF_LINE)*i), sizeof(INF_LINE) );
        DumpInfLine(&line, valuedata);

        if (CheckInterupted()) {
            return;
        }

    }

}


VOID
DumpInfVersionNode(
    PINF_VERSION_NODE ver
    )
{

    PWSTR Data;

    dprintf("***INF_VERSION_NODE***\n");
    dprintf("\t  FilenameSize : 0x%x\n", ver->FilenameSize);
    dprintf("\t  DataBlock : 0x%x\n", ver->DataBlock);
    dprintf("\t  DataSize : 0x%x\n", ver->DataSize);
    dprintf("\t  DatumCount : 0x%x\n", ver->DatumCount);
    dprintf("\t  Filename : %ws\n", ver->Filename);

    return;

    Data = malloc(ver->DataSize);
    if (!Data) {
        return;
    }
    moveBlock(Data, ver->DataBlock, ver->DataSize);


    dprintf("\t %ws\n", Data );

    free( Data );


}


VOID
DumpUserDirId(
    PUSERDIRID dirid
    )
{
    dprintf("***USERDIRID***\n");
    dprintf("\t  Id : 0x%x\n", dirid->Id);
    dprintf("\t  Directory : %ws\n", dirid->Directory);

}

VOID
DumpUserDirIdList(
    PUSERDIRID_LIST list
    )
{
    USERDIRID dirid;
    UINT i;

    dprintf("***USERDIRID_LIST***\n");
    dprintf("\t  UserDirIds : 0x%x\n", list->UserDirIds);
    dprintf("\t  UserDirIdCount : 0x%x\n", list->UserDirIdCount);

    for (i = 0; i < list->UserDirIdCount; i++) {
        moveBlock(dirid, ((LPBYTE)list->UserDirIds) + (ULONG_PTR)(sizeof(ULONG_PTR)*i) , sizeof(USERDIRID));
        DumpUserDirId(&dirid);
        if (CheckInterupted()) {
            return;
        }
    }


}

VOID
DumpStringSubstNode(
    PSTRINGSUBST_NODE node
    )
{
    dprintf("***STRINGSUBST_NODE***\n");
    dprintf("\t  ValueOffset : 0x%x\n", node->ValueOffset);
    dprintf("\t  TemplateStringId : 0x%x\n", node->TemplateStringId);
    dprintf("\t  CaseSensitive : 0x%x\n", node->CaseSensitive);


}


DECLARE_API( infdump )
/*++

Routine Description:

    This debugger extension dumps the data related to an HINF  structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pinf;
    LOADED_INF inf;
    INF_SECTION InfSection;
    INF_LINE InfLine;

    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;

    //BOOL val;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pinf = (PVOID)GetExpression( lpArgumentString );

    move( inf , pinf );

    dprintf("LOADED_INF at :\t0x%x\n", (ULONG_PTR) pinf);
    dprintf("\t Signature : 0x%08x ( %s )\n", inf.Signature,
            inf.Signature == LOADED_INF_SIG ? "Valid" : "Invalid");
    if (inf.Signature != LOADED_INF_SIG) {
        return;
    }

    dprintf("\t FileHandle : 0x%x\n", inf.FileHandle);
    dprintf("\t MappingHandle : 0x%x\n", inf.MappingHandle);
    dprintf("\t ViewAddress : 0x%x\n", inf.ViewAddress);

    if (inf.FileHandle == INVALID_HANDLE_VALUE) {
        dprintf(" *** In memory INF ***\n" );
    } else {
        dprintf(" *** PNF ***\n" );
    }

    dprintf("\t StringTable : 0x%x\n", inf.StringTable);
    dprintf("\t SectionCount : 0x%x\n", inf.SectionCount);

    dprintf("\tSectionBlock : 0x%x\n", inf.SectionBlock);
    for (i = 0; i < inf.SectionCount; i++) {

        dprintf("***INF_SECTION [%d] at 0x%x***\n",i, (PBYTE)inf.SectionBlock + (ULONG_PTR)(sizeof(INF_SECTION)*i));
        move (InfSection, (PBYTE)inf.SectionBlock + (ULONG_PTR)(sizeof(INF_SECTION)*i) );
        DumpInfSection( &InfSection, (PBYTE)inf.LineBlock, (PBYTE)inf.ValueBlock );

        if (CheckInterupted()) {
            return;
        }
    }

    dprintf("\tLineBlock : 0x%x\n", inf.LineBlock);
//    move (InfLine, inf.LineBlock );
//    DumpInfLine( &InfLine ) ;

    dprintf("\t ValueBlock : 0x%x\n", inf.ValueBlock);

    DumpInfVersionNode(&inf.VersionBlock);

    dprintf("\t HasStrings : 0x%x\n", inf.HasStrings);
    dprintf("\t OsLoaderPath : %ws\n", inf.OsLoaderPath);

    dprintf("\t InfSourceMediaType : 0x%x ( ", inf.InfSourceMediaType);
    if (inf.InfSourceMediaType) {
        if (inf.InfSourceMediaType & SPOST_PATH ) {
            dprintf("SPOST_PATH ");
        }
        if (inf.InfSourceMediaType & SPOST_URL) {
            dprintf("SPOST_URL ");
        }
    } else {
        dprintf("SPOST_NONE ");
    }

    dprintf(")\n");

    dprintf("\t InfSourcePath : %ws\n", inf.InfSourcePath);
    dprintf("\t OriginalInfName : %ws\n", inf.OriginalInfName);
    dprintf("\t SubstValueList : 0x%x\n", inf.SubstValueList);
    dprintf("\t SubstValueCount : 0x%x\n", inf.SubstValueCount);
    dprintf("\t Style : 0x%x ( ", inf.Style);

    if (inf.Style & INF_STYLE_OLDNT) {
        dprintf("INF_STYLE_OLDNT ");
    }
    if (inf.Style & INF_STYLE_WIN4) {
        dprintf("INF_STYLE_WIN4 ");
    }

    dprintf(")\n");

    dprintf("\t SectionBlockSizeBytes : 0x%x\n", inf.SectionBlockSizeBytes);
    dprintf("\t LineBlockSizeBytes : 0x%x\n", inf.LineBlockSizeBytes);
    dprintf("\t ValueBlockSizeBytes : 0x%x\n", inf.ValueBlockSizeBytes);
    dprintf("\t LanguageId : 0x%x\n", inf.LanguageId);

    dprintf("\t UserDirIdList : 0x%x\n", inf.UserDirIdList);
    dprintf("\tLock[0] : 0x%x\n", inf.Lock.handles[0]);
    dprintf("\tLock[1] : 0x%x\n", inf.Lock.handles[1]);

    dprintf("\tPrev : 0x%x\n", inf.Prev);
    dprintf("\tNext : 0x%x\n", inf.Next);

    move ( st, inf.StringTable ) ;
    DumpStringTableHeader( &st );

    dprintf("***STRING_TABLE***\n");
    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("\t\tData at hash bucket %d\n", i);
            while (node) {
                dprintf("\t\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);

                pextradata = st.Data + offset + (wcslen(node->String) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%08x\n", pextradata );

                node = GetNextNode( stdata, node, &offset );
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

    free( stdata );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setupapi\wrapper\setupapi.hpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    setupapi.hpp

Abstract:

    Wrapper class library for setup api

Author:

    Vijay Jayaseelan (vijayj) 04 Aug 2000

Revision History:

    None

--*/

#pragma once

//
// Disable the compiler warning for long names
//
#pragma warning( disable : 4786 )

extern "C" {

#include <windows.h>
#include <setupapi.h>
#include <spapip.h>

}

#include <iostream>
#include <vector>
#include <map>
#include <string>

//
// Wide string output routine
//
std::string& 
ToAnsiString(std::string &lhs, const std::wstring &rhs);

std::ostream& 
operator<<(std::ostream &lhs, const std::basic_string<WCHAR> &rhs);

std::ostream& 
operator<<(std::ostream &lhs, PCWSTR rhs);

//
// Exception classes
//

template<class T>
class BaseException { 
public:
    BaseException(){}
    BaseException(const std::basic_string<T> &Info) 
        : ExceptionInfo(Info) {}

    virtual ~BaseException(){}
    
    virtual void Dump(std::ostream &os) = 0;

protected:
    std::basic_string<T> ExceptionInfo;

};

template<class T>
class InvalidValueIndex : public BaseException<T>{
public:
    InvalidValueIndex(unsigned int Idx) : Index(Idx){}

    void Dump(std::ostream &os) {
        os << "Invalid value index : (" << std::dec 
           << Index << ")" << std::endl;
    }           

private:
    unsigned int    Index;
};

template<class T>
class InvalidValueKey : public BaseException<T>{
public:
    InvalidValueKey(const std::basic_string<T> &SecName,
            const std::basic_string<T> &Key) : SectionName(SecName), KeyName(Key){}

    void Dump(std::ostream &os) {
        os << "Invalid value key name (" << KeyName << ")"  
           << " in " << SectionName << " section." << std::endl;
    }           

private:
    std::basic_string<T> SectionName, KeyName;
};

//
// Abstracts a Win32 error
//
template <class T>
class W32Exception : public BaseException<T> {
public:
    W32Exception(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}

    void Dump(std::ostream &os) {
        T   MsgBuffer[4096];

        MsgBuffer[0] = NULL;

        DWORD CharCount;

        if (sizeof(T) == sizeof(WCHAR)) {
            CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (PWSTR)MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

            if (CharCount) {
                std::wstring Msg((PWSTR)MsgBuffer);

                os << Msg;
            } else {
                os << std::hex << ErrorCode;
            }
        } else {
            CharCount = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (PSTR)MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(CHAR),
                                NULL);
                                
            if (CharCount) {
                std::string Msg((PCSTR)MsgBuffer);

                os << Msg;
            } else {
                os << std::hex << ErrorCode;
            }
        }
    }

    DWORD GetErrorCode() const { return ErrorCode; }

protected:
    DWORD   ErrorCode;

};


template<class T>
class Section;

template<class T>
class SectionValues {
public:
    SectionValues(Section<T> &Sec, ULONG LineIdx, bool New = false);
    SectionValues(Section<T> &Sec, const std::basic_string<T> &Key,
            ULONG LineIdx, bool New = false);

    void PutValue(ULONG Index, const std::basic_string<T> &Val) {
        Values[Index] = Val;
        GetContainer().GetContainer().SetDirty();
    }
    
    const std::basic_string<T>& GetValue(ULONG Index) const {
        return Values[Index];
    }
    
    void AppendValue(const std::basic_string<T> &Val) {
        Values.push_back(Val);
        GetContainer().GetContainer().SetDirty();
    }

    void ClearValues() {
        Values.clear();
        GetContainer().GetContainer().SetDirty();
    }        

    ULONG Count() const {
        return Values.size();
    }        

    Section<T>& GetContainer() { return Container; }

    const std::basic_string<T>& GetName() const { return Name; }
    ULONG GetIndex() const { return Index; }

    friend std::ostream& operator<<(std::ostream &os, SectionValues<T> &rhs);  
    
protected:    
    //
    // data members
    //
    ULONG                               Index;
    std::basic_string<T>                Name;
    std::vector< std::basic_string<T> > Values;
    Section<T>                          &Container;
};


template<class T>
struct InvalidInfSection : public BaseException<T> {
public:
    InvalidInfSection(const std::basic_string<T> &SecName,
        const std::basic_string<T> &InfName) 
            : Name(SecName), FileName(InfName){}

    std::basic_string<T> Name;
    std::basic_string<T> FileName;
    

    void Dump(std::ostream &os) {
        os << "InvalidInfSection : " << Name << " in "
           << FileName << std::endl;
    }
};

//
// forward declaration
//

template<class T>
class InfFile;

template<class T>
class Section {
public:
    Section(InfFile<T> &file, const std::basic_string<T> &name);

    Section(InfFile<T> &file, const std::basic_string<T> &name, bool NoKey) :
        File(file), Name(name), Keyless(NoKey) {}

    ~Section(){}

    const std::basic_string<T>& GetName() const{
        return Name;
    }

    SectionValues<T>& GetValue(const std::basic_string<T> &Key) {
        std::vector< SectionValues<T> *>::iterator Iter = Lines.begin();
        SectionValues<T> *Values = NULL;

        while (Iter != Lines.end()) {
            Values = (*Iter);
            
            if (sizeof(T) == sizeof(CHAR)) {
                if (!_stricmp((PCSTR)Values->GetName().c_str(), 
                        (PCSTR)Key.c_str())) {
                    break;
                }                    
            } else {
                if (!_wcsicmp((PCWSTR)Values->GetName().c_str(), 
                        (PCWSTR)Key.c_str())) {
                    break;
                }                    
            }

            Iter++;
        }

        if (Iter == Lines.end()) {
            throw new InvalidValueKey<T>(Name, Key);
        }

        return *Values;
    }


    //
    // Note : For the following scenario
    //
    // [Section]
    // a
    // b,c
    //
    // a & b are treated as Keys i.e. for keyless sections
    // the first value is treated as a key
    //
    bool IsKeyPresent(const std::basic_string<T> &Key) const {
        bool Result = false;
        
        if (!IsKeyless()) {
            std::vector< SectionValues<T> *>::const_iterator Iter = Lines.begin();
            SectionValues<T> *Values = NULL;

            while (Iter != Lines.end()) {
                Values = (*Iter);
                
                if (sizeof(T) == sizeof(CHAR)) {
                    if (!_stricmp((PCSTR)Values->GetName().c_str(), 
                            (PCSTR)Key.c_str())) {
                        break;
                    }                    
                } else {
                    if (!_wcsicmp((PCWSTR)Values->GetName().c_str(), 
                            (PCWSTR)Key.c_str())) {
                        break;
                    }                    
                }

                Iter++;
            }

            Result = (Iter != Lines.end());
        } else {
            std::vector< SectionValues<T> *>::const_iterator Iter = KeylessLines.begin();
            SectionValues<T> *Values = NULL;

            while (Iter != KeylessLines.end()) {
                Values = (*Iter);
                
                if (sizeof(T) == sizeof(CHAR)) {
                    if (!_stricmp((PCSTR)Values->GetValue(0).c_str(), 
                            (PCSTR)Key.c_str())) {
                        break;
                    }                    
                } else {
                    if (!_wcsicmp((PCWSTR)Values->GetValue(0).c_str(), 
                            (PCWSTR)Key.c_str())) {
                        break;
                    }                    
                }

                Iter++;
            }

            Result = (Iter != KeylessLines.end());
        }

        return Result;
    }
    
    SectionValues<T>& GetValue(ULONG Index) {
        return *(KeylessLines[Index]);
    }
    
    InfFile<T>& GetContainer() { return File; }

    bool IsKeyless() const { return Keyless; }

    Section<T>& operator+=(Section<T> &rhs) {
        if (IsKeyless() == rhs.IsKeyless()) {
            //
            // add entries with key
            //
            std::vector< SectionValues<T> *>::iterator Iter = rhs.Lines.begin();

            while (Iter != rhs.Lines.end()) {
                Lines.push_back(*Iter);
                Iter++;
            }

            //
            // add entries without key
            //
            std::vector< SectionValues<T> *>::iterator KlIter = rhs.KeylessLines.begin();
                    
            while (KlIter != rhs.KeylessLines.end()) {
                KeylessLines.push_back(*KlIter);
                KlIter++;
            }
        } else {
            throw new InvalidInfSection<T>(File.GetName(), rhs.GetName());
        }

        return *this;
    }

    SectionValues<T>* AddLine(const std::basic_string<T> &Key) {                                
        SectionValues<T> *Value = NULL;
        
        if (Key.length() && !IsKeyless()) { 
            Value = new SectionValues<T>(*this, Key, 0, true);

            if (Value) {
                Lines.push_back(Value);
            }           
        } else {
            Value = new SectionValues<T>(*this, KeylessLines.size(), true);        

            if (Value) {
                KeylessLines.push_back(Value);
            }                    
        }        

        File.SetDirty();

        return Value;
    }                        
   

    friend std::ostream& operator<<(std::ostream &os, Section<T> &rhs);    

    //
    // Callback function pointer for
    // working on each section element
    //
    typedef void (*ELEMENT_WORKER)(
        SectionValues<T> &Values,
        void *ContextData
      );

    void DoForEach(ELEMENT_WORKER Worker, void *ContextData);

    //
    // Iterator
    //
    class Iterator{
        public:    
            Iterator(std::vector< SectionValues<T> *> *Collect = NULL) {
                Collection = Collect;

                if (Collection) {
                    Iter = (*Collection).begin();
                }                    
            }

            Iterator& begin() {
                if (Collection) {
                    Iter = Collection->begin();
                }                    

                return *this;
            }

            bool end() {
                return Collection? (Iter == Collection->end()) : true;
            }
            
            Iterator& operator++(int) {
                if (Collection) {
                    Iter++;
                }
                
                return *this;
            }

            friend SectionValues<T> * operator*(Iterator &lhs) {
                return lhs.Collection ? *(lhs.Iter): NULL;
            }       

            friend Section<T>;

        protected:
            void Init(std::vector< SectionValues<T> *> *Collect) {
                Collection = Collect;
                Iter = (*Collection).begin();
            }

        private:
            //
            // data members
            //
            std::vector< SectionValues<T> * >::iterator Iter;
            std::vector< SectionValues<T> *> *Collection;            
    };

    Iterator begin(void) {
        Iterator Iter;

        if (IsKeyless()) {
            if (KeylessLines.size()) {
                Iter.Init(&KeylessLines);
            }
        } else {
            if (Lines.size()) {
                Iter.Init(&Lines);
            }
        }

        return Iter;
    }
        
    

protected:
    
    //
    // data members
    //
    InfFile<T>              &File;
    std::basic_string<T>    Name;
    std::vector< SectionValues<T> *> Lines;
    std::vector< SectionValues<T> *> KeylessLines;
    bool    Keyless;
};


template<class T>
class InvalidInfFile : public BaseException<T> {
public:
    InvalidInfFile() : ErrorCode(0){}

    InvalidInfFile(const std::basic_string<T> &Name) : 
        FileName(Name), ErrorCode(0) {}

    InvalidInfFile(const std::basic_string<T> &Name, DWORD ErrCode) : 
        FileName(Name), ErrorCode(ErrCode) {}

    void Dump(std::ostream &os) {
        os << "Invalid INF file " << FileName;

        if (ErrorCode) {
            os << " (" << std::dec << ErrorCode << ") ";
        }            

        os << std::endl;
    }

protected:
    std::basic_string<T>    FileName;
    DWORD                   ErrorCode;
};

template<class T>
class InvalidInfFormat : public InvalidInfFile<T> {
public:
    InvalidInfFormat(const std::basic_string<T> &Name, UINT Line) : 
        InvalidInfFile<T>(Name), ErrorLine(Line) {}

    void Dump(std::ostream &os) {
        os << "Invalid INF format at " << std::dec 
           << ErrorLine << " line of " << FileName << std::endl;
    }

    UINT    ErrorLine;
};

//
// Inf file abstraction
//
template <class T>
class InfFile {
public:
    InfFile(const std::basic_string<T> &name);

    virtual ~InfFile() {
        if (InfHandle && (InfHandle != INVALID_HANDLE_VALUE)) {
            SetupCloseInfFile(InfHandle);
        }

        if (Dirty) {
            //CommitChanges();
        }

        SetupApiUseCount--;

        if (!SetupApiUseCount) {
            FreeLibrary(SetupApiModuleHandle);
            GetInfSections = NULL;
        }            
    }

    const std::basic_string<T>& GetName() const { 
        return Name;
    }

    friend bool operator==(const InfFile<T> &lhs, const InfFile<T> &rhs) {
        return lhs.GetName() == rhs.GetName();
    }

    friend bool operator!=(const InfFile<T> &lhs, const InfFile<T> &rhs) {
        return !(lhs == rhs);
    }

    void GetLines(Section<T> &Sec,
            std::vector< SectionValues<T> *> &Lines,
            std::vector< SectionValues<T> *> &KeylessLines);
            
    void GetValues(Section<T> &Sec, 
                SectionValues<T> &SecValues,
                std::vector< std::basic_string<T> > &Values);


    friend std::ostream& operator<<(std::ostream &os, InfFile<T> &rhs) {
        InfFile<T>::Iterator Iter = rhs.begin();

        while (!Iter.end()) {
            os << **Iter << std::endl;
            Iter++;            
        }

        return os;
    }    

    Section<T>* AddSection(const std::basic_string<T> &SecName, bool Keyless) {
        Section<T> *NewSection = NULL;
        
        try {
            NewSection = GetSection(SecName);
        } catch(...) {
        }

        if (!NewSection) {            
            Sections[SecName] = NewSection = 
                new Section<T>(*this, SecName, Keyless);
            SetDirty();
        }            

        return NewSection;
    }
    
    Section<T>* GetSection(const std::basic_string<T> &SecName) {
        std::map< std::basic_string<T>, Section<T> *>::iterator Iter = Sections.find(SecName);
        Section<T>* Sec = NULL;

        if (Iter != Sections.end()) {
            Sec = (*Iter).second;
        }

        return Sec;
    }

    void GetSections(std::map< std::basic_string<T>, Section<T> *> &Secs) {
        Secs = Sections;
    }

    void SetDirty() { Dirty = true; }

    const HINF GetInfHandle() const { return InfHandle; }

    //
    // Callback function pointer for
    // working on each section 
    //
    typedef void (*ELEMENT_WORKER)(
        Section<T> &Section,
        void *ContextData
      );

    void DoForEach(ELEMENT_WORKER Worker, void *ContextData);          

    //
    // Iterator
    //
    class Iterator{
        public:    
            Iterator(std::map< std::basic_string<T>, Section<T> *> *Collect = NULL) {
                Collection = Collect;

                if (Collection) {
                    Iter = (*Collection).begin();
                }                    
            }

            Iterator& begin() {
                if (Collection) {
                    Iter = Collection->begin();
                }                    

                return *this;
            }

            bool end() {
                return Collection? (Iter == Collection->end()) : true;
            }
            
            Iterator& operator++(int) {
                if (Collection) {
                    Iter++;
                }
                
                return *this;
            }

            friend Section<T> * operator*(Iterator &lhs) {
                return lhs.Collection ? (*(lhs.Iter)).second: NULL;
            }       

            friend Section<T>;

        protected:
            void Init(std::map< std::basic_string<T>, Section<T> *> *Collect) {
                Collection = Collect;
                Iter = (*Collection).begin();
            }

        private:
            //
            // data members
            //
            std::map< std::basic_string<T>, Section<T> *>::iterator Iter;
            std::map< std::basic_string<T>, Section<T> *> *Collection;            
    };

    Iterator begin(void) {
        return Iterator(&(this->Sections));
    }
   
protected:

    HINF OpenFile() {
        HINF InfHandle = NULL;
        UINT ErrorLine = 0;

        if (sizeof(T) == sizeof(CHAR)) {            
            InfHandle = SetupOpenInfFileA((const CHAR*)(GetName().c_str()),
                            NULL,
                            INF_STYLE_WIN4,
                            &ErrorLine);
        } else {
            InfHandle = SetupOpenInfFileW((const WCHAR*)(GetName().c_str()),
                            NULL,
                            INF_STYLE_WIN4,
                            &ErrorLine);
        }

        if (InfHandle == INVALID_HANDLE_VALUE) {
            DWORD   ErrorCode = ::GetLastError();
            
            if (ErrorLine) {
                throw new InvalidInfFormat<T>(GetName(), ErrorLine);
            } else {            
                throw new InvalidInfFile<T>(GetName(), ErrorCode);
            }
        }

        return InfHandle;
    }

    typedef BOOL (* GetInfSectionsRoutine)(HINF, T*, UINT, UINT *);

    //
    // data members
    //
    std::basic_string<T>    Name;
    HINF                    InfHandle;
    bool                    Dirty;
    static GetInfSectionsRoutine    GetInfSections;
    static HMODULE                  SetupApiModuleHandle;
    static ULONG                    SetupApiUseCount;
    std::map< std::basic_string<T>, Section<T> *> Sections; 
};

template <class T>
SectionValues<T>::SectionValues(Section<T> &Sec, 
    const std::basic_string<T> &Key,  ULONG LineIdx, bool New) 
        : Container(Sec), Name(Key), Index(LineIdx) {        

    if (!New) {        
        GetContainer().GetContainer().GetValues(Sec, *this, Values);
    }        
}

template <class T>
SectionValues<T>::SectionValues(Section<T> &Sec, ULONG LineIdx, bool New) 
        : Container(Sec), Index(LineIdx) {        
    BYTE Buffer[64] = {0};            

    if (sizeof(T) == sizeof(CHAR)) {
        Name = std::basic_string<T>((const T*)_ltoa(Index, (char *)Buffer, 10));
    } else {
        Name = std::basic_string<T>((const T*)_ltow(Index, (wchar_t*)Buffer, 10));
    }


    if (!New) {        
        GetContainer().GetContainer().GetValues(Sec, *this, Values);
    }        
}


template <class T>
std::ostream& 
operator<<(std::ostream &os, SectionValues<T> &rhs) {
    os << rhs.GetName() << " = ";

    std::vector< std::basic_string<T> >::iterator Iter = rhs.Values.begin();

    while (Iter != rhs.Values.end()) {
        os << *Iter << ", ";
        Iter++;
    }

    os << std::endl;

    return os;
}    

template <class T>
Section<T>::Section(InfFile<T> &file, const std::basic_string<T> &name) 
        : Name(name), File(file), Keyless(false) {
    INFCONTEXT  InfContext;
    BOOL        Result;
    const HINF  InfHandle = GetContainer().GetInfHandle();

    if (sizeof(T) == sizeof(CHAR)) {
        Result = SetupFindFirstLineA((HINF)InfHandle,
                        (PCSTR)GetName().c_str(),
                        NULL,
                        &InfContext);                        
    } else {
        Result = SetupFindFirstLineW((HINF)InfHandle,
                        (PCWSTR)GetName().c_str(),
                        NULL,
                        &InfContext);                        
    }

    //std::cout << Name << " is " << Keyless << std::endl;

    if (Result) {
        BYTE  Buffer[4096], Buffer1[4096];    
        bool KeyPresent = false;
                
        //
        // NOTE : singular values in section are treated as keys
        // by setupapi so take care of such cases correctly
        // as keyless entries
        //
        // ISSUE : because of the way we are trying to determine
        // keyless section a sections with first entry a = a will
        // be treated as keyless section wrongly.
        //
        if (sizeof(T) == sizeof(CHAR)) {
            *((PSTR)Buffer) = '\0';
            *((PSTR)Buffer1) = '\0';
            
            if (SetupGetStringFieldA(&InfContext,
                    0,
                    (PSTR)Buffer,
                    sizeof(Buffer) / sizeof(T),
                    NULL) &&
                SetupGetStringFieldA(&InfContext,
                    1,
                    (PSTR)Buffer1,
                    sizeof(Buffer1) / sizeof(T),
                    NULL)) {
                KeyPresent = (_stricmp((PCSTR)Buffer, (PCSTR)Buffer1) != 0);
            }
        } else {
            *((PWSTR)Buffer) = L'\0';
            *((PWSTR)Buffer1) = L'\0';
            
            if (SetupGetStringFieldW(&InfContext,
                    0,
                    (PWSTR)Buffer,
                    sizeof(Buffer) / sizeof(T),
                    NULL) && 
                SetupGetStringFieldW(&InfContext,
                    1,
                    (PWSTR)Buffer1,
                    sizeof(Buffer1) / sizeof(T),
                    NULL)) {
                KeyPresent = (_wcsicmp((PCWSTR)Buffer, (PCWSTR)Buffer1) != 0);
            }
        }   

        // If we cannot read 0th value, then we
        // assume that the whole section is
        // doesnot have entries with key
        //
        Keyless = !KeyPresent;
    }
        
    GetContainer().GetLines(*this, Lines, KeylessLines);

    //std::cout << Name << " is " << Keyless << std::endl;
}

template <class T>
std::ostream& 
operator<<(std::ostream &os, Section<T> &rhs){
    os << "[" << rhs.GetName() << "]" << std::endl;                 

    Section<T>::Iterator Iter = rhs.begin();
    SectionValues<T> *Values;

    while (!Iter.end()) {    
        Values = *Iter;

        if (Values) {
            os << *Values;
        }
        
        Iter++;
    }

    return os;
}    


template<class T>
void 
Section<T>::DoForEach(Section<T>::ELEMENT_WORKER Worker, 
                void *ContextData) {
    if (IsKeyless()) {
        std::vector< SectionValues<T> * >::iterator Iter = KeylessLines.begin();    
        SectionValues<T> *Value;

        while (Iter != KeylessLines.end()) {
            Value = *Iter;

            if (Value) {
                Worker(*Value, ContextData);
            }
            
            Iter++;
        }
    } else {
        std::vector< SectionValues<T> *>::iterator Iter = Lines.begin();    
        SectionValues<T> *Value;

        while (Iter != Lines.end()) {
            Value = *Iter;

            if (Value) {
                Worker(*Value, ContextData);
            }
            
            Iter++;
        }        
    }
}


template <class T>
InfFile<T>::InfFile(const std::basic_string<T> &name) : Name(name) {
    Dirty = false;
    InfHandle = OpenFile();

    if (!GetInfSections) {
        SetupApiModuleHandle = LoadLibrary(TEXT("setupapi.dll"));

        if (SetupApiModuleHandle) {
            GetInfSections = (GetInfSectionsRoutine)(GetProcAddress(SetupApiModuleHandle,
                                        "pSetupGetInfSections"));

            if (!GetInfSections) {
                GetInfSections = (GetInfSectionsRoutine)(GetProcAddress(SetupApiModuleHandle,
                                            "SetupGetInfSections"));
            }
        }

        if (!GetInfSections) {
            throw new W32Exception<T>();
        }
    }

    SetupApiUseCount++;

    //
    // get hold of all the sections     
    //
    UINT    CurrSize = 4096;
    UINT    SizeNeeded = 0;
    DWORD   LastError = 0;
    WCHAR   *Buffer = new WCHAR[CurrSize];

    memset(Buffer, 0, CurrSize);
    
    BOOL    Result = GetInfSections(InfHandle, Buffer, CurrSize, &SizeNeeded);
    
    if (!Result && (SizeNeeded > CurrSize)) {
        delete []Buffer;
        Buffer = new WCHAR[SizeNeeded];
        memset(Buffer, 0, SizeNeeded);
        CurrSize = SizeNeeded;
        
        Result = GetInfSections(InfHandle, Buffer, CurrSize, &SizeNeeded);
    }

    std::vector<std::basic_string<T> >  SectionNames;
    
    if (Result) {        
        while (Buffer && *Buffer) {        
            std::basic_string<WCHAR> WNextSection((const WCHAR*)Buffer);

            if (sizeof(T) == sizeof(CHAR)) {
                std::basic_string<T> NextSection;

                ToAnsiString((std::basic_string<char> &)NextSection, WNextSection);
                
                SectionNames.push_back(NextSection);
            } else {
                std::basic_string<T> NextSection((const T *)WNextSection.c_str());
                                    
                SectionNames.push_back(NextSection);
            }                    
                                    
            Buffer += (WNextSection.length() + 1);
        }
    } else {
        LastError = ::GetLastError();
    }

    if (Result && SectionNames.size()) {
        std::vector<std::basic_string<T> >::iterator NameIter = SectionNames.begin();

        while (NameIter != SectionNames.end()) {
            // std::cout << *NameIter << std::endl;
            Sections[*NameIter] = new Section<T>(*this, *NameIter);
            NameIter++;
        }
    }
    
    if (!Result) {
        throw new InvalidInfFile<T>(GetName(), LastError);
    }
}

template<class T>
void 
InfFile<T>::DoForEach(
    InfFile<T>::ELEMENT_WORKER Worker, 
    void *ContextData
    ) 
{
    std::map< std::basic_string<T>, Section<T> *>::iterator 
            Iter = Sections.begin();
            
    while (Iter != Sections.end()) {
        Worker(*(*Iter).second, ContextData);
        Iter++;
    }        
}


template <class T>
void 
InfFile<T>::GetLines(
    Section<T> &Sec,
    std::vector< SectionValues<T> *> &Values,
    std::vector< SectionValues<T> *> &KeylessValues
    ) 
{
    std::vector< SectionValues<T>* >::iterator MapIter = Values.begin();

    //
    // delete the old values (if any)
    //
    while (MapIter != Values.end()) {
        if (*MapIter) {
            delete (*MapIter);
        }            

        MapIter++;            
    }
        
    Values.clear();

    std::vector< SectionValues<T>* >::iterator KeylessIter = KeylessValues.begin();

    //
    // delete the old values (if any)
    //
    while (KeylessIter != KeylessValues.end()) {
        if (*KeylessIter) {
            delete (*KeylessIter);
        }            

        KeylessIter++;            
    }
        
    KeylessValues.clear();
    
    //
    // locate the first line
    //    
    INFCONTEXT  InfContext;
    BOOL        Result;
    DWORD   LineCount;

    if (sizeof(T) == sizeof(CHAR)) {
        LineCount = SetupGetLineCountA(InfHandle,
                            (PCSTR)Sec.GetName().c_str());
    } else {
        LineCount = SetupGetLineCountW(InfHandle,
                            (PCWSTR)Sec.GetName().c_str());                                
    }

    if (LineCount) {        
        if (sizeof(T) == sizeof(CHAR)) {
            Result = SetupFindFirstLineA(InfHandle,
                            (PCSTR)Sec.GetName().c_str(),
                            NULL,
                            &InfContext);                        
        } else {
            Result = SetupFindFirstLineW(InfHandle,
                            (PCWSTR)Sec.GetName().c_str(),
                            NULL,
                            &InfContext);                        
        }

        if (Result) {
            BYTE  Buffer[4096];        
            bool Read = false;
            BOOL NextLine = TRUE;
            DWORD Index = 0;
            bool Keyless = Sec.IsKeyless();
            
            for (Index=0; (NextLine && (Index < LineCount)); Index++) {
                Buffer[0] = Buffer[1] = 0;
                Read = false;

                if (!Keyless) {
                    if (sizeof(T) == sizeof(CHAR)) {
                        if (SetupGetStringFieldA(&InfContext,
                                0,
                                (PSTR)Buffer,
                                sizeof(Buffer) / sizeof(T),
                                NULL)) {
                            Read = true;                        
                        }
                    } else {
                        if (SetupGetStringFieldW(&InfContext,
                                0,
                                (PWSTR)Buffer,
                                sizeof(Buffer) / sizeof(T),
                                NULL)) {
                            Read = true;                        
                        }
                    }            
                }                

                if (Read) {
                    std::basic_string<T> Key((const T *)Buffer);

                    //std::cout << Key << std::endl;

                    Values.push_back(new SectionValues<T>(Sec, Key, Index));                
                } else { 
                    KeylessValues.push_back(new SectionValues<T>(Sec, Index));
                }            

                NextLine = SetupFindNextLine(&InfContext, &InfContext);
            }

            if (!NextLine && (Index < LineCount)) {
                throw new InvalidInfSection<T>(Sec.GetName(), GetName());
            }        
        } else {
            throw new InvalidInfSection<T>(Sec.GetName(), GetName());
        }
    }
}

template <class T>
void 
InfFile<T>::GetValues(
    Section<T> &Sec, 
    SectionValues<T> &SecValues,
    std::vector<std::basic_string<T> > &Values
    ) 
{
    const std::basic_string<T> &SecName = Sec.GetName();
    const std::basic_string<T> &Key = SecValues.GetName();

    INFCONTEXT  InfContext;
    BOOL        Result = TRUE;
    ULONG       Lines = 0;

    Values.clear();    

    if (sizeof(T) == sizeof(CHAR)) {
        Lines = SetupGetLineCountA(InfHandle,
                    (PCSTR)SecName.c_str());        
    } else {
        Lines = SetupGetLineCountW(InfHandle,
                    (PCWSTR)SecName.c_str());
    }                    

    if (Lines) {        
        if (sizeof(T) == sizeof(CHAR)) {
            Result = SetupGetLineByIndexA(InfHandle,
                            (PCSTR)SecName.c_str(),
                            SecValues.GetIndex(),
                            &InfContext);                        
        } else {
            Result = SetupGetLineByIndexW(InfHandle,
                            (PCWSTR)SecName.c_str(),
                            SecValues.GetIndex(),
                            &InfContext);                        
        }        

        if (Result) {
            DWORD FieldCount = SetupGetFieldCount(&InfContext);
            BYTE  Buffer[2048];

            for (DWORD Index=0; Index < FieldCount; Index++) {
                Buffer[0] = Buffer[1] = 0;

                if (sizeof(T) == sizeof(CHAR)) {
                    if (SetupGetStringFieldA(&InfContext,
                            Index + 1,
                            (PSTR)Buffer,
                            sizeof(Buffer) / sizeof(T),
                            NULL)) {
                        Values.push_back((const T *)Buffer);
                    }
                } else {
                    if (SetupGetStringFieldW(&InfContext,
                            Index + 1,
                            (PWSTR)Buffer,
                            sizeof(Buffer) / sizeof(T),
                            NULL)) {
                        Values.push_back((const T *)Buffer);
                    }
                }
            }
        } else {
            throw new InvalidInfSection<T>(SecName, GetName());
        }
    }        
}


typedef InfFile<CHAR>   InfFileA;
typedef InfFile<WCHAR>  InfFileW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setupapi\wrapper\queue.hpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    queue.hpp

Abstract:

    Abstracts setupapi's file queue

Author:

    Vijay Jayaseelan (vijayj) 08 Oct 2000

Revision History:

    None

--*/

#pragma once

//
// Disable the compiler warning for long names
//
#pragma warning( disable : 4786 )

#include <setupapi.hpp>

template <class T>
class FileQueue {
public:
    FileQueue() {
        QueueHandle = SetupOpenFileQueue();

        if (QueueHandle == INVALID_HANDLE_VALUE) {
            throw new W32Exception();
        }
    }        

    void AddForCopy(const std::basic_string<T> &SourceRoot,
                    const std::basic_string<T> &SourcePath,
                    const std::basic_string<T> &SourceFileName,
                    const std::basic_string<T> &DestPath,
                    const std::basic_string<T> &DestFileName,
                    DWORD CopyFlags) {
        BOOL Result = FALSE;

        /*
        if (sizeof(T) == sizeof(WCHAR)) {
            Result = SetupQueueCopyW(QueueHandle,
                        (PCWSTR)SourceRoot.c_str(),
                        (PCWSTR)SourcePath.c_str(),
                        (PCWSTR) // Left editing here ...
        */                        
    }                    
                        
    void AddForCopy(const SectionValues<T> &RecordToCopy,
                    const std::basic_string<T> &DirSectionName,
                    const std::basic_string<T> &SourceRoot,
                    DWORD CopyStyle) {
        BOOL    Result = FALSE;
        InfFile<T>  &File = RecordToCopy.GetContainer().GetContainer();
        Section<T>  *DirSection = File.GetSection(DirSectionName);
        
        if (sizeof(T) == sizeof(WCHAR)) {
            Result = SetupQueueCopyW(QueueHandle,
                        (PCWSTR)SourceRoot.c_str(),
                        (PCWSTR)RecordToCopy.GetValue(1).c_str(),
                        (PCWSTR)RecordToCopy.GetName().c_str(),
                        NULL,
                        NULL,
                        (PCWSTR)DirSection->GetValue(RecordToCopy.GetValue(7).c_str()).GetValue(0).c_str(),
                        (PCWSTR)RecordToCopy.GetValue(10).c_str(),
                        CopyStyle);
        } else {
            Result = SetupQueueCopyA(QueueHandle,
                        (PCSTR)SourceRoot.c_str(),
                        (PCSTR)RecordToCopy.GetValue(1).c_str(),
                        (PCSTR)RecordToCopy.GetName().c_str(),
                        NULL,
                        NULL,
                        (PCSTR)DirSection->GetValue(RecordToCopy.GetValue(7).c_str()).GetValue(0).c_str(),
                        (PCSTR)RecordToCopy.GetValue(10).c_str(),
                        CopyStyle);
        }    

        if (!Result) {
            throw new W32Exception();
        }            
    }

    void AddForCopy(const Section<T> &SectionToCopy,
                    const std::basic_string<T> &DirSectionName,
                    const std::basic_string<T> &SourceRoot,
                    DWORD CopyStyle) {
        CopyWorkerState State(*this, DirSectionName, SourceRoot, CopyStyle);
        SectionToCopy->DoForEach(SectionCopyWorker, &State);
    }
       
    void Commit() {
        if (!SetupCommitFileQueue(NULL,
                QueueHandle,
                SetupDefaultQueueCallback,
                NULL)) {
            throw new W32Exception();                
        }                
    }

    virtual ~FileQueue() {
        if (QueueHandle != INVALID_HANDLE_VALUE) {
            SetupCloseFileQueue(QueueHandle);
        }
    }

protected:
    struct CopyWorkerState {
        FileQueue<T>                &Queue;
        const std::basic_string<T>  &DirSectionName;
        const std::basic_string<T>  &SourceRoot;
        DWORD                       CopyState;

        CopyWorkerState(FileQueue<T> &Que, const std::basic_string<T> &DirSecName,
                        const std::basic_string<T> &SrcRoot, DWORD Copy) : Queue(Que),
                            DirSectionName(DirSecName), SourceRoot(SrcRoot),
                            CopyState(Copy){}                            
    };                            
                        
    static void SectionCopyWorker(SectionValues<T> &Value, void *ContextData) {
        CopyWorkerState *State = (CopyWorkerState  *)ContextData;

        if (Queue) {
            Queue->AddForCopy(State->Queue,
                        State->DirSectionName,
                        State->SourceRoot);
        }
    }        
        
    
    
    //
    // data members
    //
    HSPFILEQ    QueueHandle;    
};


typedef FileQueue<CHAR>     FileQueueA;
typedef FileQueue<WCHAR>    FileQueueW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setuplog\sources.inc ===
MAJORCOMP=setup
MINORCOMP=log

TARGETNAME=setuplog
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOURCES=\
        setuplog.c  \
        setuplog.rc

INCLUDES=..\..\inc

USE_MSVCRT=1

UMRES=$(O)\setuplog.res
OPTIONAL_UMTEST=x
UMTYPE=windows
UMENTRY=winmain
UMLIBS=$(SDK_LIB_PATH)\syssetup.lib     \
       $(SDK_LIB_PATH)\setupapi.lib     \
       $(SDK_LIB_PATH)\comctl32.lib     \
       $(PROJECT_ROOT)\ntsetup\setuplog\$(O)\setuplog.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setupapi\wrapper\test\testwrap.cpp ===
#include <setupapi.hpp>
#include <queue.hpp>

struct InvalidArguments : BaseException<char>{
    void Dump(std::ostream &os) {
        os << "Invalid Arguments" << std::endl;
    }
};

template<class T>
struct ProgramArguments {
    std::basic_string<T>    FileName;

    ProgramArguments(int Argc, T *Argv[]) {
        if (Argc > 1) {
            FileName = Argv[1];
        } else {
            throw new InvalidArguments();
        }            
    }

    ~ProgramArguments(){}
};

//
// ANSI Arguments
//
typedef ProgramArguments<char>      AnsiArgs;       
typedef ProgramArguments<wchar_t>   UnicodeArgs;


//
//  Prototypes
//
bool 
ReadTest(
    IN InfFileW &TestInfFile
    );

bool
WriteTest(
    IN InfFileW &TestInfFile
    );

bool
AppendTest(
    IN InfFileW &TestInfFile
    );    

//
// main() entry point
//
int 
__cdecl
wmain(int Argc, wchar_t *Argv[]) {
    int Result = 0;

    try{
        UnicodeArgs PrgArgs(Argc, Argv);
        InfFileW    TestInf(PrgArgs.FileName);

        if (!WriteTest(TestInf)) {
            std::cout << "WriteTest failed" << std::endl;
        }

        if (!AppendTest(TestInf)) {
            std::cout << "AppendTest failed" << std::endl;
        }

        if (!ReadTest(TestInf)) {
            std::cout << "ReadTest failed" << std::endl;
        }                
    }
    catch(BaseException<char> *Exp) {
        Exp->Dump(std::cout);
        delete Exp;
    }
    catch(exception *exp) {
        std::cout << exp->what() << std::endl;
        delete exp;
    }

    return Result;
}


bool
ReadTest(
    IN InfFileW &TestInfFile
    )
{
    bool Result = true;
    
    std::cout << TestInfFile.GetName() << " was opened correctly"
              << std::endl;

    std::cout << TestInfFile;                  

    return Result;
}

bool
WriteTest(
    IN InfFileW &TestInfFile
    )
{
    bool Result = false;
    
    Section<wchar_t>  *NewSection = TestInfFile.AddSection(L"Testing", false);    

    if (NewSection) {
        SectionValues<wchar_t> * NewValues = NewSection->AddLine(L"TestValueKey");

        if (NewValues) {
            NewValues->AppendValue(L"Value1");
            NewValues->AppendValue(L"Value2");

            Result = true;
        }
    }

    return Result;
}

bool
AppendTest(
    IN InfFileW &TestInfFile
    )
{
    bool Result = false;
    
    Section<wchar_t>  *AppSection = TestInfFile.GetSection(L"appendtest");    

    if (AppSection) {
        std::cout << *AppSection << std::endl;
        
        SectionValues<wchar_t> &OldValue = AppSection->GetValue(L"Key");

        std::wstring Value = OldValue.GetValue(0);

        OldValue.PutValue(0, L"\"This is new string\"");

        std::cout << *AppSection << std::endl;
        Result = true;
    }

    return Result;
}

/*
bool
QueueTest(
    VOID
    )
{
    FileQueueW   TestQueue();

    return false;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setupapi\wrapper\setupapi.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    setupapi.hpp

Abstract:

    Wrapper class library for setup api

Author:

    Vijay Jayaseelan (vijayj) 04 Aug 2000

Revision History:

    None

--*/


#include <setupapi.hpp>
#include <queue.hpp>


//
// InfFile<T>'s static data
//
InfFileW::GetInfSectionsRoutine InfFileW::GetInfSections = NULL;
HMODULE InfFileW::SetupApiModuleHandle = NULL;
ULONG InfFileW::SetupApiUseCount = 0;

InfFileA::GetInfSectionsRoutine InfFileA::GetInfSections = NULL;
HMODULE InfFileA::SetupApiModuleHandle = NULL;
ULONG InfFileA::SetupApiUseCount = 0;

//
// Helper methods
//
std::ostream& 
operator<<(std::ostream &os, PCWSTR rhs) {
    return os << std::wstring(rhs);
}    

std::string& 
ToAnsiString(std::string &lhs, const std::wstring &rhs) {
    ULONG Length = rhs.length();

    if (Length){
        DWORD   Size = 0;
        CHAR    *String = new CHAR[Size = ((Length + 1) * 2)];

        if (::WideCharToMultiByte(CP_ACP, 0, rhs.c_str(), Length + 1,
                                String, Size, 0, 0)) {
            lhs = String;
        }

        delete []String;
    }

    return lhs;
}

std::ostream& 
operator<<(std::ostream &os, const std::basic_string<WCHAR> &rhs) {
    std::string AnsiStr;

    ToAnsiString(AnsiStr, rhs);

    return (os << AnsiStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setuplog\setuplog.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setuplog.c

Abstract:

    Routines for logging actions and errors during setup.

Author:

    Steve Owen (SteveOw) 1-Sep-1996

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "setuplog.h"

#if DBG

VOID
SetupLogAssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    CHAR Msg[4096];

    wsprintfA(
        Msg,
        "SetupLog: Assertion failure at line %u in file %s: %s\r\n",
        LineNumber,
        FileName,
        Condition
        );

    OutputDebugStringA(Msg);
    DebugBreak();
}

#define MYASSERT(x)     if(!(x)) { SetupLogAssertFail(__FILE__,__LINE__,#x); }

#else
#define MYASSERT(x)
#endif


//
// Pointer to structure given to us during initialization that provides all
// the callbacks and global info we need.
//
PSETUPLOG_CONTEXT   Context = NULL;

BOOL
pLogAction (
    IN  LPCTSTR             Message
    )

/*++

Routine Description:

    Writes an entry into the Setup Action Log.  This routine is responsible
    for setting the format of the log file entries.

Arguments:

    Message - Buffer that contains the text to write.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    return Context->Write (Context->hActionLog, Message);
}

BOOL
pLogError (
    IN  LogSeverity         Severity,
    IN  LPCTSTR             Message
    )

/*++

Routine Description:

    Writes an entry into the Setup Error Log.  This routine is responsible
    for setting the format of the log file entries.

Arguments:

    Message - Buffer that contains the text to write.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    BOOL    b;

    Context->Lock(Context->Mutex);

    //
    // Write the severity description.
    //
    if(Context->SeverityDescriptions[Severity]) {
        b = Context->Write (Context->hErrorLog,
            Context->SeverityDescriptions[Severity]);
        b = b && Context->Write (Context->hErrorLog, TEXT(":\r\n"));
    } else {
        b = TRUE;
    }

    //
    // Write the text.
    //
    b = b && Context->Write (Context->hErrorLog, Message);

    //
    // Write a terminating marker.
    //
    b = b && Context->Write (Context->hErrorLog, SETUPLOG_ITEM_TERMINATOR);

    Context->Unlock(Context->Mutex);

    return(b);
}

PTSTR
pFormatMessage (
    IN  PSETUPLOG_CONTEXT   MyContext,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    ...
    )

/*++

Routine Description:

    Wrapper for Context->Format callback routine.  This routine passes its
    variable argument list to Context->Format as a va_list.


Arguments:

    MyContext - provides callback routines.

    MessageId - supplies message-table identifier or win32 error code
        for the message.

Return Value:

    Pointer to a buffer containing the formatted string.

--*/

{
    va_list arglist;
    PTSTR   p;

    va_start(arglist, MessageId);
    p = MyContext->Format (MessageString,MessageId,&arglist);
    va_end(arglist);
    return(p);
}

BOOL
SetuplogInitializeEx(
    IN  PSETUPLOG_CONTEXT   SetuplogContext,
    IN  BOOL                WipeLogFile,
    IN  LPCTSTR             ActionFilename,
    IN  LPCTSTR             ErrorFilename,
    IN  PVOID               Reserved1,
    IN  DWORD               Reserved2
    )

/*++

Routine Description:

    Opens the Setup log files.

Arguments:

    SetuplogContext - pointer to a context that has been filled in with the
        required callback routines by the caller.

    WipeLogFile - Boolean indicating whether any existing log files should be
        deleted (TRUE) or whether we should append onto existing files (FALSE).

    ActionFilename - filename to be used for the Action Log.

    ErrorFilename - filename to be used for the Error Log.

    Reserved1 - Reserved for future use--must be NULL.

    Reserved2 - Reserved for future use--must be 0.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    if(Reserved1 || Reserved2) {
        return FALSE;
    }

    Context = SetuplogContext;
    Context->WorstError = LogSevInformation;

    Context->hActionLog = Context->OpenFile(
        ActionFilename, WipeLogFile);

    Context->hErrorLog = Context->OpenFile(
        ErrorFilename, WipeLogFile);

    return (Context->hActionLog != INVALID_HANDLE_VALUE &&
        Context->hErrorLog != INVALID_HANDLE_VALUE);
}

BOOL
SetuplogInitialize(
    IN  PSETUPLOG_CONTEXT   SetuplogContext,
    IN  BOOL                WipeLogFile
    )

/*++

Routine Description:

    Opens the Setup log files with default file names.

Arguments:

    SetuplogContext - pointer to a context that has been filled in with the
        required callback routines by the caller.

    WipeLogFile - Boolean indicating whether any existing log files should be
        deleted (TRUE) or whether we should append onto existing files (FALSE).

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    return SetuplogInitializeEx(
        SetuplogContext,
        WipeLogFile,
        SETUPLOG_ACTION_FILENAME,
        SETUPLOG_ERROR_FILENAME,
        NULL,
        0
        );
}

PTSTR
SetuplogFormatMessageWithContextV(
    IN  PSETUPLOG_CONTEXT   MyContext,
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    IN  va_list             *ArgumentList
    )

/*++

Routine Description:

    Formats a specified message with caller-supplied arguments.  The message
    can contain any number of imbedded messages.

Arguments:

    MyContext - provides callback routines.  This parameter is provided so that
        messages can be formatted even the global Context has not been
        initialized because we're not in Setup.  This ability is needed by the
        Add/Remove Programs applet.  The only fields that we use in this
        structure are AllocMem, FreeMem, and Format.

    Flags - Optional flags that can modify how the formatting is performed.

    MessageString - pointer to a buffer containing unformatted message text.
        If this value is SETUPLOG_USE_MESSAGEID, then MessageId is used to
        generate the message text.  Otherwise, MessageId is unused.

    MessageID - ID of the outer level message to be formatted

    ArgumentList - list of strings to be substituted into the message.  The
        order of items in the ArgumentList is given by:
        ArgumentList = Arg1,...,ArgN,NULL,{ImbeddedMessage},NULL
        ImbeddedMessage = MessageID,Arg1,...,ArgN,NULL,{ImbeddedMessage}
        where Arg1,...,ArgN are the arguments for MessageID

Return Value:

    Pointer to a buffer containing the formatted string.  If an error prevented
    the routine from completing successfully, NULL is returned.  The caller
    can free the buffer with Context->MyFree().

--*/

{
    va_list     major_ap, minor_ap;
    UINT        NumberOfArguments, i;
    UINT        MinorMessageId;
    PVOID       p, *MajorArgList;
    PTSTR       MajorMessage, MinorMessage, MinorMessageString;


    //
    // Handle a single message first.
    //
    if(Flags & SETUPLOG_SINGLE_MESSAGE) {
        return MyContext->Format (MessageString, MessageId, ArgumentList);
    }

    //
    // Count the number of arguments that go with the major message (MessageID)
    // and get ready to process the minor (imbedded) message if there is one
    //
    minor_ap = *ArgumentList;
    NumberOfArguments = 0;
    major_ap = minor_ap;
    while (p=va_arg(minor_ap, PVOID)) {
        NumberOfArguments++;
    }
    MYASSERT (NumberOfArguments < 7);

    MinorMessageString = va_arg(minor_ap, PTSTR);
    if (MinorMessageString) {

        //
        // We've got a minor message, so process it first
        //
        MinorMessageId = va_arg(minor_ap, UINT);
        MinorMessage = SetuplogFormatMessageWithContextV (
            MyContext,
            Flags,
            MinorMessageString,
            MinorMessageId,
            &minor_ap);

        if (!MinorMessage) {
            return NULL;
        }

        //
        // Now we handle the major message
        // Ugly hack: since we don't know how to bulid a va_list, we've
        // got to let the compiler do it.
        //
        MajorArgList = MyContext->AllocMem ((NumberOfArguments) * sizeof(PVOID));
        if (!MajorArgList) {
            MyContext->FreeMem (MinorMessage);
            return NULL;
        }
        for (i=0; i<NumberOfArguments; i++) {
            MajorArgList[i] = va_arg (major_ap, PVOID);
        }
        switch (NumberOfArguments) {
        case 0:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MinorMessage);
            break;
        case 1:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MinorMessage);
            break;
        case 2:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MinorMessage);
            break;
        case 3:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MajorArgList[2],
                MinorMessage);
            break;
        case 4:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MajorArgList[2],
                MajorArgList[3],
                MinorMessage);
            break;
        case 5:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MajorArgList[2],
                MajorArgList[3],
                MajorArgList[4],
                MinorMessage);
            break;
        case 6:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MajorArgList[2],
                MajorArgList[3],
                MajorArgList[4],
                MajorArgList[5],
                MinorMessage);
            break;
        default:
            MajorMessage = NULL;
            MYASSERT (0);
        }
        MyContext->FreeMem (MajorArgList);
        MyContext->FreeMem (MinorMessage);
    } else {
        MajorMessage = MyContext->Format (MessageString, MessageId, &major_ap);
    }

    return MajorMessage;
}

PTSTR
SetuplogFormatMessageV(
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    IN  va_list             *ArgumentList
    )

/*++

Routine Description:

    Wrapper for SetuplogFormatMessageWithContextV.

Arguments:

    See FormatMessageWithContextV.

Return Value:

    See FormatMessageWithContextV.

--*/

{
    //
    // Make sure we've been initialized
    //
    if(!Context) {
        return NULL;
    }

    return SetuplogFormatMessageWithContextV(
        Context,
        Flags,
        MessageString,
        MessageId,
        ArgumentList
        );
}

PTSTR
SetuplogFormatMessage(
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    ...
    )

/*++

Routine Description:

    Wrapper for SetuplogFormatMessageWithContextV.  This routine passes its
    variable argument list to SetuplogFormatMessageV as a va_list.


Arguments:

    See FormatMessageWithContextV.

Return Value:

    See FormatMessageWithContextV.

--*/

{
    va_list arglist;
    PTSTR p;

    //
    // Make sure we've been initialized
    //
    if(!Context) {
        return NULL;
    }
    va_start(arglist,MessageId);
    p = SetuplogFormatMessageWithContextV(
        Context,
        Flags,
        MessageString,
        MessageId,
        &arglist);
    va_end(arglist);

    return(p);
}

BOOL
SetuplogErrorV(
    IN  LogSeverity         Severity,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,      OPTIONAL
    IN  va_list             *ArgumentList
    )

/*++

Routine Description:

    Writes an entry to the Setup Error Log.

Arguments:

    Severity - Severity of the error.  The low word contains the actual number
        of the severity.  The high word contains any flags that affect how the
        message is formatted.

    MessageString - pointer to a buffer containing unformatted message text.
        If this value is SETUPLOG_USE_MESSAGEID, then MessageId is used to
        generate the message text.  Otherwise, MessageId is unused.

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    BOOL    Status = FALSE;
    LPCTSTR Message;

    if(Context) {

        if(Message = SetuplogFormatMessageV (
            Severity,
            MessageString,
            MessageId,
            ArgumentList)) {

            //
            // Now validate the Severity.  Note that we don't have to do this
            // for SetuplogFormatMessageV, since it just looks at the flags
            // set in the high word.
            //
            Severity = LOWORD(Severity);
            if(Severity < LogSevMaximum) {
                Status = TRUE;
            } else {
                MYASSERT (Severity < LogSevMaximum);
                Severity = LogSevInformation;
                Status = FALSE;
            }
            Context->WorstError = max (Context->WorstError, Severity);

            //
            // Write the message(s).
            //
            Status = pLogAction (Message) && Status;
            if(Severity != LogSevInformation) {
                Status = pLogError (Severity, Message) && Status;
            }
            Context->FreeMem (Message);
        }
    }

#if DBG
    if(!Status) {
        OutputDebugStringA("SETUPLOG: Unable to log a message.\n");
    }
#endif
    return Status;
}

BOOL
SetuplogError(
    IN  LogSeverity         Severity,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,      OPTIONAL
    ...
    )

/*++

    Wrapper for SetuplogErrorV
    Make sure to pass two NULLs to end the arglist.
    Otherwise SetuplogFormatMessageWithContextV will cause an exception.

--*/

{
    va_list arglist;
    BOOL    Status;

    va_start(arglist, MessageId);
    Status = SetuplogErrorV (Severity, MessageString, MessageId, &arglist);
    va_end(arglist);

    return Status;
}

BOOL
SetuplogTerminate(
    VOID
    )

/*++

Routine Description:

    Closes the Setup log files.

Arguments:

    None.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    BOOL    Status = FALSE;

    if(Context) {
        Context->CloseFile(Context->hActionLog);
        Context->CloseFile(Context->hErrorLog);

        Context = NULL;
        Status = TRUE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setuplog\x.c ===
#include "setuplog.h"
#include <wtypes.h>     // to define HRESULT for richedit.h
#include <richedit.h>
#include <malloc.h>
#include <assert.h>
#pragma hdrstop

SETUPLOG_CONTEXT    SetuplogContext;
PSETUPLOG_CONTEXT   Context;

LPCTSTR pszAppName = TEXT("ViewLog");                // class name
HANDLE  hModule;                                // handle of this instance
HANDLE  hRichedDLL;                             // DLL used for rich edit
HANDLE  hWndMain;                               // handle to main window


VOID
ReportError (
    IN LogSeverity Severity,
    ...
    );

static PVOID
pOpenFileCallback(
    IN  LPCTSTR Filename,
    IN  BOOL    WipeLogFile
    )
{
    WCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;

    //
    // Form the pathname of the logfile.
    //
    GetWindowsDirectory(CompleteFilename,MAX_PATH);
    ConcatenatePaths(CompleteFilename,Filename,MAX_PATH,NULL);

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes(CompleteFilename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile(
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    return (PVOID)hFile;
}


static BOOL
pWriteFile (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    )
{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   BytesWritten;

    if(AnsiBuffer = UnicodeToAnsi (Buffer)) {
        Status = WriteFile (
            LogFile,
            AnsiBuffer,
            lstrlenA(AnsiBuffer),
            &BytesWritten,
            NULL
            );
        MyFree (AnsiBuffer);
    } else {
        Status = FALSE;
    }

    return Status;

}


VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

     Initialize the setup action log. This file is a textual description
     of actions performed during setup.

     The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    WipeLogFile - if TRUE, any existing log file is deleted before logging
        begins.

Return Value:

    Boolean value indicating whether initialization was sucessful.

--*/

{
    UINT    i;

    Context->OpenFile = pOpenFileCallback;
    Context->CloseFile = CloseHandle;
    Context->AllocMem = malloc;
    Context->FreeMem = free;
    Context->Format = RetrieveAndFormatMessageV;
    Context->Write = pWriteFile;

    //
    // Initialize the log severity descriptions.
    //
    Context->SeverityDescriptions[0] = TEXT("Information");
    Context->SeverityDescriptions[1] = TEXT("Warning");
    Context->SeverityDescriptions[2] = TEXT("Error");
    Context->SeverityDescriptions[3] = TEXT("Fatal Error");

    SetuplogInitialize (Context, TRUE);
    SetuplogError(
        LogSevInformation,
        TEXT("This is the beginning of the Setup Log.\r\n"),
        0,0,0);
}

static VOID
CreateLog (
    )
{
#if 0
    InitializeSetupActionLog(TRUE);
    LogItem(LogSevInformation, L"STO test: Information\r\n");
    LogItem(LogSevWarning, L"STO test: Warning\r\n");
    LogItem(LogSevError, L"STO test: Error\r\n");
    LogItem(LogSevFatalError, L"STO test: Fatal Error\r\n");
    LogItem0(LogSevError,MSG_LOG_INF_CORRUPT,L"INF File Name");
    LogItem1(LogSevWarning,MSG_LOG_PRINTUPG_FAILED,MSG_LOG_X_RETURNED_WINERR,
        L"GetPrinterDriverDirectory",(DWORD)123);
    LogItem2(
        LogSevWarning,
        MSG_LOG_CREATESVC_FAIL,
        L"Service Name",
        MSG_LOG_X_RETURNED_WINERR,
        L"OpenSCManager",
        (DWORD) 123
        );
    LogItem3(
        LogSevError,
        MSG_LOG_SAVEHIVE_FAIL,
        L"Subkey",
        L"Filename",
        MSG_LOG_X_RETURNED_WINERR,
        L"RegSaveKey",
        (LONG) 123
        );
    ReportError (LogSevError,MSG_LOG_INF_CORRUPT,L"INF File Name",0,0);
    ReportError (LogSevWarning,MSG_LOG_PRINTUPG_FAILED,0,
        MSG_LOG_X_RETURNED_WINERR,
        L"GetPrinterDriverDirectory",(DWORD)123,0,0);
    ReportError (
        LogSevWarning,
        MSG_LOG_CREATESVC_FAIL,
        L"Service Name",0,
        MSG_LOG_X_RETURNED_WINERR,
        L"OpenSCManager",
        (DWORD) 123,0,0
        );
    ReportError (
        LogSevError,
        MSG_LOG_SAVEHIVE_FAIL,
        L"Subkey",
        L"Filename",0,
        MSG_LOG_X_RETURNED_WINERR,
        L"RegSaveKey",
        (LONG) 123,0,0
        );
    ReportError (LogSevError, MSG_LOG_OPTIONAL_COMPONENT_ERROR, 0,
        ERROR_NOT_ENOUGH_MEMORY, 0,0);
    ReportError (LogSevError, MSG_LOG_CANT_OPEN_INF,
        L"optional.inf", 0,0);
    ReportError (LogSevError, MSG_LOG_BAD_SECTION, L"SectionName",
        L"InfFileName", 0, 5, 0,0);
    ReportError (LogSevError, MSG_LOG_OC_REGISTRY_ERROR, L"RegKeyName", 0,
        5, 0,0);
    TerminateSetupActionLog();
#endif

    Context = &SetuplogContext;
    InitializeSetupLog (Context);
#if 0 // MSG_* not defined
    SetuplogError(
        LogSevError,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_CANT_OPEN_INF,
        L"optional.inf",
        0,0);
    ReportError(
        LogSevError,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_OC_REGISTRY_ERROR,
        L"RegKeyName", 0,
        SETUPLOG_USE_MESSAGEID,
        5, 0,0);
#endif
    SetuplogError(
        LogSevInformation,
        L"This is a string info message.\r\n",
        0,0,0);
    SetuplogError(
        LogSevWarning,
        L"This is a string warning message.\r\n",
        0,0,0);
    ReportError(
        LogSevError,
        L"This is a reported string error message.\r\n", 0,0,0);
    ReportError(
        LogSevError,
        L"This is a reported string error message %1.\r\n", 0,0,
        L"with an embedded message",0,0,0);
    ReportError(
        LogSevError,
        L"This is a reported string error message %1.\r\n", 0,0,
        L"with an embedded message %1", 0,0,
        L"in an embedded message",0,0,0);
    SetuplogTerminate();
}



LONG
MainWndProc (
    IN HWND     hwnd,
    IN UINT     message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rect;

    switch (message) {

    case WM_CREATE:
#if 0
        ViewSetupActionLog (hwnd, NULL, NULL);
        ViewSetupActionLog (hwnd, L"d:\\WinNt40\\SetUpLog.TXT", L"My Heading");
        ViewSetupActionLog (hwnd, L"MyFile", NULL);
#endif
        PostQuitMessage (0);
        break;

    case WM_PAINT:
        hdc = BeginPaint (hwnd, &ps);
        GetClientRect (hwnd, &rect);
        DrawText (hdc, L"Hello, Windows!", -1, &rect,
            DT_SINGLELINE | DT_CENTER | DT_VCENTER);
        EndPaint (hwnd, &ps);
        break;

    case WM_DESTROY:
        PostQuitMessage (0);
        break;

    default:
        return DefWindowProc (hwnd, message, wParam, lParam);
    }

    return 0;
}



static BOOL
InitMainWindow (
    )
{
    WNDCLASS wc;

    //
    // Initialize the window class.
    //

    hModule = GetModuleHandle (NULL);

    if (TRUE || FindWindow (pszAppName, NULL) == NULL) {
        wc.style            = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc      = MainWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = (HINSTANCE) hModule;
        wc.hIcon            = LoadIcon (NULL, IDI_APPLICATION);
        wc.hCursor          = LoadCursor (NULL, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName     = pszAppName;
        wc.lpszClassName    = pszAppName;

        if (!RegisterClass (&wc)) {
            return FALSE;
        }
    }


    //
    // Create the window and display it.
    //
    hWndMain = CreateWindow (
        pszAppName,
        L"The Hello Program",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, 0,
        CW_USEDEFAULT, 0,
        NULL, NULL,
        (HINSTANCE) hModule,
        NULL
    );
    if (!hWndMain) {
        return FALSE;
    }

    ShowWindow (hWndMain, SW_SHOWNORMAL);
    UpdateWindow (hWndMain);
    return TRUE;

}


INT WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    INT nCmdShow)

{
    MSG     msg;

    CreateLog ();

    // Initialize everything
    //
    if (!InitMainWindow ()) {
        assert(FALSE);
        return FALSE;
    }

    // Process messages
    //
    while (GetMessage (&msg, NULL, 0, 0)) {
        TranslateMessage (&msg);
        DispatchMessage (&msg);
    }

    return (msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\setupmsi\makefile.inc ===
# THIS BUILDS THE OPK.MSI WITH VERSION INFORMATION
#

$(O)\buildno.txt: buildno.txt
          tok_bldnum.cmd $(PROJECT_ROOT)\ntsetup\setupmsi\$(O)\buildno.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\srvpack_binary_release\sources.inc ===
!IF 0

Copyright (c) 2002  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Rick Goodwill (richg)  2/14/2002

!ENDIF


!IF "$(LANG)" != "USA" && "$(LANG)" != "usa"
ALT_PROJECT_TARGET=$(LANG)
!ENDIF

BINPLACE_PLACEFILE=..\..\placefil.txt


TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

!ifndef BDIR
BDIR=fre
!endif

SOURCES=

MISCFILES =  \
    $(BDIR)\spmsg.dll    \
    $(BDIR)\spcustom.dll \
    $(BDIR)\spuninst.exe \
    $(BDIR)\update.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\svcpack\svcpack.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	svcpack.h

 --*/

#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wtypes.h>
#include <tchar.h>
#include <setupapi.h>
#include <spapip.h>
#include <cfgmgr32.h>
#include <regstr.h>
#include <winuser.h>
#include <commctrl.h>
#include <richedit.h>
#include <winsvc.h>
#include <prsht.h>

//
// Defining the EXPORT qualifier
//

BOOL
CALLBACK
SvcPackCallbackRoutine(
    IN  DWORD dwSetupInterval,
    IN  DWORD dwParam1,
    IN  DWORD dwParam2,
    IN  DWORD dwParam3
    )   ;

#define SVCPACK_PHASE_1 1
#define SVCPACK_PHASE_2 2
#define SVCPACK_PHASE_3 3
#define SVCPACK_PHASE_4 4

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\stripinf\stripinf.c ===
#include <stdio.h>
#include <stdlib.h>


/*
   This program reads NT SETUP INF files and removes:

        o   blank lines
        o   lines whose first non-white-space character is ';'
        o   all data after and including a non-quoted ';'
            character in a line


   Command line:

        stripinf  <input INF name>  <output INF name>

 */

#define MAX_CHARACTERS_PER_LINE    1000

#if !defined(TRUE)
    #define TRUE  1
    #define FALSE 0
#endif

typedef int bool ;

void die ( char * pszMsg )
{
    fprintf( stderr, "STRIPINF error: %s", pszMsg ) ;
    exit(3);
}


int processInf ( FILE * fIn, FILE * fOut )
{
    char chLine [ MAX_CHARACTERS_PER_LINE ] ;
    char * pch,
         * pchComment ;
    bool bKeep,
         bQuote,
         bStop ;

    for ( ; (! feof(fIn)) && (pch = fgets( chLine, sizeof chLine, fIn )) ; )
    {
        bStop = bQuote = bKeep = FALSE ;
        pchComment = NULL ;

        for ( ; *pch && (! bStop) ; pch++ )
        {
            switch ( *pch )
            {
            case '\n':
                 bStop = TRUE ;
                 break ;

            case '\0':
                 die( "input line longer than 1000 characters" ) ;
                 break ;

            case '\"':
                 bQuote = ! bQuote ;
                 bKeep = TRUE ;
                 break ;

            case ' ':
            case '\t':
                 break ;

            case ';':
                 if ( bQuote )
                     break ;
                 if ( bKeep )
                 {
                     *pch++ = '\n' ;
                     *pch   = '\0' ;
                 }
                 bStop = TRUE ;
                 break ;
	    case 0x1a: /* control-Z */
		 *pch = '\0';
		 break;

            default:
                 bKeep = TRUE ;
                 break ;
            }
        }

        if ( bKeep )
        {
            if ( fputs( chLine, fOut ) == EOF )
                die("failure writing output file") ;
        }
    }

    return TRUE ;
}

int
__cdecl
main ( int argc, char * argv[], char * envp[] )

{
    int i ;
    char * pchIn  = NULL,
         * pchOut = NULL,
         chOpt ;
    FILE * fIn, * fOut ;

    for ( i = 1 ; argv[i] ; i++ )
    {
         switch ( chOpt = argv[i][0] )
         {
         case '-':
         case '/':
             die( "invalid option" ) ;
             break;

         default:
             if ( pchIn == NULL )
                 pchIn = argv[i] ;
             else
             if ( pchOut == NULL )
                 pchOut = argv[i] ;
             else
                 die( "too many file specifications" ) ;

             break;
         }
    }

    if ( pchIn == NULL || pchOut == NULL )
        die( "too few file specifications" ) ;


    fIn = fopen( pchIn, "r" ) ;
    if ( ! fIn )
        die( "input file failed to open" ) ;

    fOut = fopen( pchOut, "w" );
    if ( ! fOut )
        die( "output file failed to open" );

    if ( ! processInf( fIn, fOut ) )
        die( "internal failure in processing" );

    fclose( fOut ) ;
    fclose( fIn ) ;

    return 0 ;
}

// End of STRIPINF.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\svcpack\svcpack.c ===
#include "svcpack.h"

//
// The module instance and name
//
HINSTANCE   hDllInstance;

//
// The path to the OS Source
//
TCHAR OsSourcePath[MAX_PATH];


//
// Function declarations
//
BOOL
DoPhaseOneWork(VOID);

BOOL
DoPhaseTwoWork(VOID);

BOOL
DoPhaseThreeWork(VOID);

BOOL
DoPhaseFourWork(VOID);

BOOL
InitializeSourcePath(
    PTSTR SourcePath,
    HINF  hInf
    );

BOOL
MyInstallProductCatalog(
    LPCTSTR PathToCatalog,
    LPCTSTR CatalogNoPath
    );

LPTSTR
CombinePaths(
    IN  LPTSTR ParentPath,
    IN  LPCTSTR ChildPath,
    OUT LPTSTR  TargetPath   // can be same as ParentPath if want to append
    );

BOOL
SpawnProcessAndWaitForItToComplete(
    IN  LPTSTR CommandLine,
    OUT PDWORD ReturnCode OPTIONAL
    );

BOOL
RunInfProcesses(
    IN     HINF     hInf
    );

BOOL
GetInfValue(
    IN  HINF   hInf,
    IN  LPTSTR SectionName,
    IN  LPTSTR KeyName,
    OUT PDWORD pdwValue
    );

BOOL
DoesInfVersionInfoMatch(
    IN     HINF     hInf
    );


BOOL
CALLBACK
SvcPackCallbackRoutine(
    IN  DWORD dwSetupInterval,
    IN  DWORD dwParam1,
    IN  DWORD dwParam2,
    IN  DWORD dwParam3
    )   

{

    switch ( dwSetupInterval ) {
        case SVCPACK_PHASE_1:
             //
             // install catalogs, etc.
             // 
             DoPhaseOneWork();
        case SVCPACK_PHASE_2:
        case SVCPACK_PHASE_3:
             break;

        case SVCPACK_PHASE_4:
             //
             // Do registry changes, etc.
             //
             DoPhaseFourWork();
             break;

    }

    return TRUE;

}




BOOL
WINAPI
DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvResreved)
{

    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            //
            // Save the module instance and name
            //
            hDllInstance = hInstance;

            break;

        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            break;
        case DLL_THREAD_ATTACH:
        default:
            break;
    }
    return TRUE;
}

BOOL
DoPhaseOneWork(
    VOID
    )
/*++

Routine Description:

    Routine installs the catalogs listed in the svcpack.inf's
    [ProductCatalogsToInstall] section.  It is assumed that these
    catalogs are present at the os source path.
    

Arguments:

    None.


Return Value:

    TRUE if the catalogs were successfully installed.

--*/
{
    HINF hInf;
    TCHAR CatalogSourcePath[MAX_PATH];
    INFCONTEXT InfContext;
    BOOL RetVal = TRUE;
    
    //
    // Open the svcpack.inf so we can install items from it.
    //
    hInf = SetupOpenInfFile(
                        TEXT("SVCPACK.INF"),
                        NULL,
                        INF_STYLE_WIN4,
                        NULL);
    if (hInf == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    //
    // Make sure the INF has matching version info
    // Return TRUE even if the versions don't match so setup doesn't barf.
    //
    if (!DoesInfVersionInfoMatch(hInf)) {
        goto e0;        
    }

    //
    // Initialize the source path global variable and save it off for later.
    //
    if (!InitializeSourcePath(OsSourcePath,hInf)) {
        RetVal = FALSE;
        goto e0;        
    }


    //
    // see if we actually have any catalogs to install
    //
    if (SetupFindFirstLine(
                        hInf,
                        TEXT("ProductCatalogsToInstall"),
                        NULL,
                        &InfContext)) {
        UINT Count,Total;
        //
        // we have catalogs in the section, so let's install them.
        //
        Total = SetupGetLineCount(hInf, TEXT("ProductCatalogsToInstall"));

        for (Count = 0; Count < Total; Count++) {
            PCTSTR CatalogNoPath;

             //
             // retrieve a catalog name
             //
             if(SetupGetLineByIndex(
                            hInf, 
                            TEXT("ProductCatalogsToInstall"),
                            Count,
                            &InfContext)) {
                 CatalogNoPath = pSetupGetField(&InfContext,1);


                 //
                 // build the full path to the catalog
                 //
                 _tcscpy(CatalogSourcePath,OsSourcePath);
                 CombinePaths(
                         CatalogSourcePath,
                         CatalogNoPath,
                         CatalogSourcePath);

                 //
                 // now install the catalog
                 // 
                 if (!MyInstallProductCatalog(
                                    CatalogSourcePath,
                                    CatalogNoPath)) {
                    RetVal = FALSE;
                 }
             } else {
                 RetVal = FALSE;
             }
        }        
    }

e0:
    SetupCloseInfFile( hInf );    
    return(RetVal);
}

BOOL 
MyInstallProductCatalog(
    LPCTSTR PathToCatalog,
    LPCTSTR CatalogSourceNoPath
    )
/*++

Routine Description:

    Routine installs the specified catalog with the given source name.
    
    The routine will copy (and if necessary, expand) the catalog file.
    It then validates and installs the catalog.
    

Arguments:

    PathToCatalog - full path to catalog
    CatalogSourceNoPath - just the filename part of the catalog, which we use
                          as the filename of the catalog to be installed.


Return Value:

    TRUE if the catalogs were successfully installed.

--*/

{
    TCHAR CatalogDestPath[MAX_PATH];
    TCHAR CatalogDestWithPath[MAX_PATH];
    BOOL RetVal = FALSE;
    SetupapiVerifyProblem Problem = SetupapiVerifyCatalogProblem;

    //
    // we need to copy (and potentially expand) the catalog from the source,
    // and we use %windir% as a working directory.
    //
    if(GetWindowsDirectory(
                    CatalogDestPath, 
                    sizeof(CatalogDestPath)/sizeof(CatalogDestPath[0]))
        && GetTempFileName(
                    CatalogDestPath, 
                    TEXT("SETP"), 
                    0, 
                    CatalogDestWithPath)) {

        //
        // assume that media is already present -- since product catalogs
        // we installed just prior to this, we know that media was present
        // just a few moments ago
        //
        if ((SetupDecompressOrCopyFile(
                                PathToCatalog,
                                CatalogDestWithPath,
                                NULL) == NO_ERROR)

            && (pSetupVerifyCatalogFile(CatalogDestWithPath) == NO_ERROR)
            && (pSetupInstallCatalog(
                        CatalogDestWithPath,
                        CatalogSourceNoPath,
                        NULL) == NO_ERROR)) {
            RetVal = TRUE;
        }

        //
        // cleanup the temp file.
        //
        DeleteFile(CatalogDestWithPath);

    }

    return(RetVal);

}

BOOL
InitializeSourcePath(
    PTSTR SourcePath,
    HINF hInf
    )
/*++

Routine Description:

    Routine retrieves the os source path from the registry, then appends
    the subdirectory in the specified inf.    

Arguments:

    None.


Return Value:

    TRUE if the catalogs were successfully installed.

--*/

{
    HKEY hKey = NULL;
    TCHAR TempPath[MAX_PATH];
    TCHAR MyAnswerFile[MAX_PATH];
    DWORD Type,Size = MAX_PATH;
    INFCONTEXT InfContext;
    BOOL RetVal = FALSE;
    
    //
    // if it was already initialized to something, just return TRUE.
    //
    if (*SourcePath != (TCHAR)TEXT('\0')) {
        RetVal = TRUE;
        goto e0;
    }

        GetSystemDirectory(MyAnswerFile, MAX_PATH);
        CombinePaths( MyAnswerFile, TEXT("$winnt$.inf"), MyAnswerFile );

        GetPrivateProfileString( TEXT("Data"),
                                 TEXT("DosPath"),
                                 TEXT(""),
                                 TempPath,
                                 sizeof(TempPath)/sizeof(TCHAR),
                                 MyAnswerFile );
        _tcscpy(SourcePath,TempPath);
        RetVal = TRUE;

        //
        // now append the subdirectory specified in the inf (if any)
        //
        if (hInf && SetupFindFirstLine(
                            hInf,
                            TEXT("SetupData"),
                            TEXT("CatalogSubDir"),
                            &InfContext)) {
            PCTSTR p = pSetupGetField(&InfContext,1);

            CombinePaths(
                SourcePath,
                p,
                SourcePath);                        
        } 

e0:
    return(RetVal);
}


BOOL
DoPhaseFourWork(VOID)
{

    BOOL    Success = TRUE;
    HINF    hInf = NULL;

    //
    // Attempt to open the SVCPACK.INF file.
    // If found, and no problems with it, do
    // the associated work.
    //
    hInf = SetupOpenInfFile (
                TEXT("SVCPACK.INF"),
                NULL,
                INF_STYLE_WIN4,
                NULL
                );

    if (( hInf == NULL ) || ( hInf == INVALID_HANDLE_VALUE )) {
        Success = FALSE;
        goto exit0;
    }

    //
    // Make sure the INF has matching version info.
    // Return TRUE even if the versions don't match so setup doesn't barf.
    //
    if (!DoesInfVersionInfoMatch(hInf)) {
        goto exit1;
    }

    Success = RunInfProcesses( hInf );

exit1:
    SetupCloseInfFile( hInf );
exit0:
    return Success;

}


BOOL
SpawnProcessAndWaitForItToComplete(
    IN  LPTSTR CommandLine,
    OUT PDWORD ReturnCode OPTIONAL
    )
    {
    LPTSTR InternalCommandLine = NULL;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO StartupInfo;
    BOOL Success;

    //
    //  CreateProcess needs a non-const command line buffer because it likes
    //  to party on it.
    //
    InternalCommandLine = malloc( MAX_PATH );

    if ( InternalCommandLine == NULL ) {
        return FALSE;
    }

    _tcscpy( InternalCommandLine, CommandLine );

    ZeroMemory( &StartupInfo, sizeof( StartupInfo ));
    StartupInfo.cb = sizeof( StartupInfo );

    Success = CreateProcess(
                  NULL,
                  InternalCommandLine,
                  NULL,
                  NULL,
                  FALSE,
                  0,
                  NULL,
                  NULL,
                  &StartupInfo,
                  &ProcessInfo
                  );

    if ( ! Success ) {
        free( InternalCommandLine );
        return FALSE;
        }

    WaitForSingleObject( ProcessInfo.hProcess, INFINITE );

    if ( ReturnCode != NULL ) {
        GetExitCodeProcess( ProcessInfo.hProcess, ReturnCode );
        }

    CloseHandle( ProcessInfo.hProcess );
    CloseHandle( ProcessInfo.hThread );
    free( InternalCommandLine );

    return TRUE;
    }


LPTSTR
CombinePaths(
    IN  LPTSTR ParentPath,
    IN  LPCTSTR ChildPath,
    OUT LPTSTR  TargetPath   // can be same as ParentPath if want to append
    )
    {
    ULONG ParentLength = _tcslen( ParentPath );
    LPTSTR p;

    if ( ParentPath != TargetPath ) {
        memcpy( TargetPath, ParentPath, ParentLength * sizeof(TCHAR) );
        }

    p = TargetPath + ParentLength;

    if (( ParentLength > 0 )   &&
        ( *( p - 1 ) != '\\' ) &&
        ( *( p - 1 ) != '/'  )) {
        *p++ = '\\';
        }

    _tcscpy( p, ChildPath );

    return TargetPath;
    }



BOOL
RunInfProcesses(
    IN     HINF     hInf
    )
{

    LPTSTR  SectionName = TEXT("SetupHotfixesToRun");
    LPTSTR  szFileName;
    LPTSTR  szFullPath;
    INFCONTEXT InfContext;
    BOOL Success = TRUE;

    //
    // Loop through all the lines in the SetupHotfixesToRun section,
    // spawning off each one.
    //
    szFileName = malloc( MAX_PATH );
    if (szFileName == NULL) {
       Success = FALSE;
       goto exit0;
    }

    szFullPath = malloc( MAX_PATH );
    if (szFullPath == NULL) {
       Success = FALSE;
       goto exit1;
    }
    
    Success = SetupFindFirstLine( hInf, SectionName, NULL, &InfContext ) &&
             SetupGetLineText( &InfContext, NULL, NULL, NULL, szFileName, MAX_PATH, NULL );
    
    while ( Success ) {
    
       *szFullPath = 0;
       CombinePaths( OsSourcePath, szFileName, szFullPath );
    
       //
       // OK, spawn the EXE, and ignore any errors returned
       //
       SpawnProcessAndWaitForItToComplete( szFullPath, NULL );
    
       Success = SetupFindNextLine( &InfContext, &InfContext ) &&
                 SetupGetLineText( &InfContext, NULL, NULL, NULL, szFileName, MAX_PATH, NULL );
    }
    
    Success = TRUE;
    free( (PVOID)szFullPath );         
exit1:
    free( (PVOID)szFileName );    
exit0:
    return Success;

}


BOOL
GetInfValue(
    IN  HINF   hInf,
    IN  LPTSTR SectionName,
    IN  LPTSTR KeyName,
    OUT PDWORD pdwValue
    )
    {
    BOOL Success;
    TCHAR TextBuffer[MAX_PATH];

    Success = SetupGetLineText(
                  NULL,
                  hInf,
                  SectionName,
                  KeyName,
                  TextBuffer,
                  sizeof( TextBuffer ),
                  NULL
                  );

    *pdwValue = _tcstoul( TextBuffer, NULL, 0 );

    return Success;
    }



BOOL
DoesInfVersionInfoMatch(
    IN     HINF     hInf
    )
{

    DWORD dwBuildNumber, dwMajorVersion, dwMinorVersion;
    OSVERSIONINFOEX OsVersionInfo;

    if (( ! GetInfValue( hInf, TEXT("Version"), TEXT("BuildNumber"),  &dwBuildNumber )) ||
        ( ! GetInfValue( hInf, TEXT("Version"), TEXT("MajorVersion"), &dwMajorVersion )) ||
        ( ! GetInfValue( hInf, TEXT("Version"), TEXT("MinorVersion"), &dwMinorVersion ))) {

        return FALSE;
    }

    OsVersionInfo.dwOSVersionInfoSize = sizeof( OsVersionInfo );
    if (!GetVersionEx( (LPOSVERSIONINFO) &OsVersionInfo )) {

        return FALSE;
    }

    if ((OsVersionInfo.dwBuildNumber  != dwBuildNumber) ||
        (OsVersionInfo.dwMajorVersion != dwMajorVersion) ||
        (OsVersionInfo.dwMinorVersion != dwMinorVersion)) {

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\applyacl.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    applyacl.c

Abstract:

    Routines to apply default ACLs to system files and directories
    during setup.

Author:

    Ted Miller (tedm) 16-Feb-1996

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#define MAXULONG    0xffffffff

//
// Universal well known SIDs
//
PSID NullSid;
PSID WorldSid;
PSID LocalSid;
PSID CreatorOwnerSid;
PSID CreatorGroupSid;

//
// SIDs defined by NT
//
PSID DialupSid;
PSID NetworkSid;
PSID BatchSid;
PSID InteractiveSid;
PSID ServiceSid;
PSID LocalSystemSid;
PSID AliasAdminsSid;
PSID AliasUsersSid;
PSID AliasGuestsSid;
PSID AliasPowerUsersSid;
PSID AliasAccountOpsSid;
PSID AliasSystemOpsSid;
PSID AliasPrintOpsSid;
PSID AliasBackupOpsSid;
PSID AliasReplicatorSid;


typedef struct _ACE_DATA {
    ACCESS_MASK AccessMask;
    PSID        *Sid;
    UCHAR       AceType;
    UCHAR       AceFlags;
} ACE_DATA, *PACE_DATA;

//
// This structure is valid for access allowed, access denied, audit,
// and alarm ACEs.
//
typedef struct _ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    //
    // The SID follows in the buffer
    //
} ACE, *PACE;


//
// Number of ACEs currently defined for files and directories.
//
#define DIRS_AND_FILES_ACE_COUNT 19

//
// Table describing the data to put into each ACE.
//
// This table will be read during initialization and used to construct a
// series of ACEs.  The index of each ACE in the Aces array defined below
// corresponds to the ordinals used in the ACL section of perms.inf
//
ACE_DATA AceDataTableForDirsAndFiles[DIRS_AND_FILES_ACE_COUNT] = {

    //
    // Index 0 is unused
    //
    { 0,NULL,0,0 },

    //
    // ACE 1
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasAccountOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 2
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 3
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 4
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &CreatorOwnerSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 5
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &NetworkSid,
        ACCESS_DENIED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 6
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &AliasPrintOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 7
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasReplicatorSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 8
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_EXECUTE,
        &AliasReplicatorSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 9
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &AliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 10
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
    },

    //
    // ACE 11
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 12
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 13
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
    },

    //
    // ACE 14
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_EXECUTE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 15
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_EXECUTE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
    },

    //
    // ACE 16
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
    },

    //
    // ACE 17
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &LocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 18
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    }
};


//
// Array of ACEs to be applied to the objects (files and directories).
// They will be initialized during program startup based on the data in the
// AceDataTable. The index of each element corresponds to the
// ordinals used in the [ACL] section of perms.inf.
//
PACE AcesForDirsAndFiles[DIRS_AND_FILES_ACE_COUNT];

//
// Array that contains the size of each ACE in the
// array AcesForDirsAndFiles. These sizes are needed
// in order to allocate a buffer of the right size
// when we build an ACL.
//
ULONG AceSizesForDirsAndFiles[DIRS_AND_FILES_ACE_COUNT];



VOID
TearDownAces(
    IN OUT PACE*        AcesArray,
    IN     ULONG        ArrayCount
    );


VOID
TearDownSids(
    VOID
    );


DWORD
InitializeSids(
    VOID
    )

/*++

Routine Description:

    This function initializes the global variables used by and exposed
    by security.

Arguments:

    None.

Return Value:

    Win32 error indicating outcome.

--*/

{
    SID_IDENTIFIER_AUTHORITY NullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority         = SECURITY_NT_AUTHORITY;

    BOOL b = TRUE;

    //
    // Ensure the SIDs are in a well-known state
    //
    NullSid = NULL;
    WorldSid = NULL;
    LocalSid = NULL;
    CreatorOwnerSid = NULL;
    CreatorGroupSid = NULL;
    DialupSid = NULL;
    NetworkSid = NULL;
    BatchSid = NULL;
    InteractiveSid = NULL;
    ServiceSid = NULL;
    LocalSystemSid = NULL;
    AliasAdminsSid = NULL;
    AliasUsersSid = NULL;
    AliasGuestsSid = NULL;
    AliasPowerUsersSid = NULL;
    AliasAccountOpsSid = NULL;
    AliasSystemOpsSid = NULL;
    AliasPrintOpsSid = NULL;
    AliasBackupOpsSid = NULL;
    AliasReplicatorSid = NULL;

    //
    // Allocate and initialize the universal SIDs
    //
    b = b && AllocateAndInitializeSid(
                &NullSidAuthority,
                1,
                SECURITY_NULL_RID,
                0,0,0,0,0,0,0,
                &NullSid
                );

    b = b && AllocateAndInitializeSid(
                &WorldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0,0,0,0,0,0,0,
                &WorldSid
                );

    b = b && AllocateAndInitializeSid(
                &LocalSidAuthority,
                1,
                SECURITY_LOCAL_RID,
                0,0,0,0,0,0,0,
                &LocalSid
                );

    b = b && AllocateAndInitializeSid(
                &CreatorSidAuthority,
                1,
                SECURITY_CREATOR_OWNER_RID,
                0,0,0,0,0,0,0,
                &CreatorOwnerSid
                );

    b = b && AllocateAndInitializeSid(
                &CreatorSidAuthority,
                1,
                SECURITY_CREATOR_GROUP_RID,
                0,0,0,0,0,0,0,
                &CreatorGroupSid
                );

    //
    // Allocate and initialize the NT defined SIDs
    //
    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_DIALUP_RID,
                0,0,0,0,0,0,0,
                &DialupSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_NETWORK_RID,
                0,0,0,0,0,0,0,
                &NetworkSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_BATCH_RID,
                0,0,0,0,0,0,0,
                &BatchSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_INTERACTIVE_RID,
                0,0,0,0,0,0,0,
                &InteractiveSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_SERVICE_RID,
                0,0,0,0,0,0,0,
                &ServiceSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &LocalSystemSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &AliasAdminsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_USERS,
                0,0,0,0,0,0,
                &AliasUsersSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_GUESTS,
                0,0,0,0,0,0,
                &AliasGuestsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_POWER_USERS,
                0,0,0,0,0,0,
                &AliasPowerUsersSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                0,0,0,0,0,0,
                &AliasAccountOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_SYSTEM_OPS,
                0,0,0,0,0,0,
                &AliasSystemOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_PRINT_OPS,
                0,0,0,0,0,0,
                &AliasPrintOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_BACKUP_OPS,
                0,0,0,0,0,0,
                &AliasBackupOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_REPLICATOR,
                0,0,0,0,0,0,
                &AliasReplicatorSid
                );

    if(!b) {
        TearDownSids();
    }

    return(b ? NO_ERROR : GetLastError());
}


VOID
TearDownSids(
    VOID
    )
{
    if(NullSid) {
        FreeSid(NullSid);
    }
    if(WorldSid) {
        FreeSid(WorldSid);
    }
    if(LocalSid) {
        FreeSid(LocalSid);
    }
    if(CreatorOwnerSid) {
        FreeSid(CreatorOwnerSid);
    }
    if(CreatorGroupSid) {
        FreeSid(CreatorGroupSid);
    }
    if(DialupSid) {
        FreeSid(DialupSid);
    }
    if(NetworkSid) {
        FreeSid(NetworkSid);
    }
    if(BatchSid) {
        FreeSid(BatchSid);
    }
    if(InteractiveSid) {
        FreeSid(InteractiveSid);
    }
    if(ServiceSid) {
        FreeSid(ServiceSid);
    }
    if(LocalSystemSid) {
        FreeSid(LocalSystemSid);
    }
    if(AliasAdminsSid) {
        FreeSid(AliasAdminsSid);
    }
    if(AliasUsersSid) {
        FreeSid(AliasUsersSid);
    }
    if(AliasGuestsSid) {
        FreeSid(AliasGuestsSid);
    }
    if(AliasPowerUsersSid) {
        FreeSid(AliasPowerUsersSid);
    }
    if(AliasAccountOpsSid) {
        FreeSid(AliasAccountOpsSid);
    }
    if(AliasSystemOpsSid) {
        FreeSid(AliasSystemOpsSid);
    }
    if(AliasPrintOpsSid) {
        FreeSid(AliasPrintOpsSid);
    }
    if(AliasBackupOpsSid) {
        FreeSid(AliasBackupOpsSid);
    }
    if(AliasReplicatorSid) {
        FreeSid(AliasReplicatorSid);
    }
}



DWORD
InitializeAces(
    IN OUT PACE_DATA    DataTable,
    IN OUT PACE*        AcesArray,
    IN OUT PULONG       AceSizesArray,
    IN     ULONG        ArrayCount
    )

/*++

Routine Description:

    Initializes the array of ACEs as described in the DataTable

Arguments:

    DataTable - Pointer to the array that contains the data
                describing each ACE.
    AcesArray - Array that will contain the ACEs.

    AceSizesArray - Array that contains the sizes for each ACE.

    ArrayCount - Number of elements in each array.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    unsigned u;
    DWORD Length;
    DWORD rc;
    BOOL b;
    DWORD SidLength;

    //
    // Initialize to a known state.
    //
    ZeroMemory(AcesArray,ArrayCount*sizeof(PACE));

    //
    // Create ACEs for each item in the data table.
    // This involves merging the ace data with the SID data, which
    // are initialized in an earlier step.
    //
    for(u=1; u<ArrayCount; u++) {

        SidLength = GetLengthSid(*(DataTable[u].Sid));
        Length = SidLength + sizeof(ACE) + sizeof(ACCESS_MASK)- sizeof(ULONG);
        AceSizesArray[u] = Length;

        AcesArray[u] = malloc(Length);
        if(!AcesArray[u]) {
            TearDownAces(AcesArray, ArrayCount);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        AcesArray[u]->Header.AceType  = DataTable[u].AceType;
        AcesArray[u]->Header.AceFlags = DataTable[u].AceFlags;
        AcesArray[u]->Header.AceSize  = (WORD)Length;

        AcesArray[u]->Mask = DataTable[u].AccessMask;

        b = CopySid(
                SidLength,                           // Length - sizeof(ACE) + sizeof(ULONG),
                (PUCHAR)AcesArray[u] + sizeof(ACE),
                *(DataTable[u].Sid)
                );

        if(!b) {
            rc = GetLastError();
            TearDownAces(AcesArray, ArrayCount);
            return(rc);
        }
    }

    return(NO_ERROR);
}



VOID
TearDownAces(
    IN OUT PACE*        AcesArray,
    IN     ULONG        ArrayCount
    )

/*++

Routine Description:

    Destroys the array of ACEs as described in the DataTable

Arguments:

    None

Return Value:

    None

--*/

{
    unsigned u;


    for(u=1; u<ArrayCount; u++) {

        if(AcesArray[u]) {
            free(AcesArray[u]);
        }
    }
}


ULONG
ApplyAclToDirOrFile(
    IN PCWSTR FullPath,
    IN PULONG AcesToApply,
    IN ULONG  ArraySize
    )

/*++

Routine Description:

    Applies an ACL to a specified file or directory.

Arguments:

    FullPath - supplies full win32 path to the file or directory
        to receive the ACL

    AcesIndexArray - Array that contains the index to the ACEs to be used in the ACL.

    ArraySize - Number of elements in the array.

Return Value:

--*/

{
    DWORD AceCount;
    DWORD Ace;
    INT AceIndex;
    DWORD rc;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Acl;
    UCHAR AclBuffer[2048];
    BOOL b;
    PCWSTR AclSection;
    ACL_SIZE_INFORMATION AclSizeInfo;

    //
    // Initialize a security descriptor and an ACL.
    // We use a large static buffer to contain the ACL.
    //
    Acl = (PACL)AclBuffer;
    if(!InitializeAcl(Acl,sizeof(AclBuffer),ACL_REVISION2)
    || !InitializeSecurityDescriptor(&SecurityDescriptor,SECURITY_DESCRIPTOR_REVISION)) {
        return(GetLastError());
    }


    //
    // Build up the DACL from the indices on the list we just looked up
    // in the ACL section.
    //
    rc = NO_ERROR;
    AceCount = ArraySize;
    for(Ace=0; Ace < AceCount; Ace++) {
       AceIndex = AcesToApply[ Ace ];
       if((AceIndex == 0) || (AceIndex >= DIRS_AND_FILES_ACE_COUNT)) {
          return(ERROR_INVALID_DATA);
       }

        b = AddAce(
                Acl,
                ACL_REVISION2,
                MAXULONG,
                AcesForDirsAndFiles[AceIndex],
                AcesForDirsAndFiles[AceIndex]->Header.AceSize
                );

        //
        // Track first error we encounter.
        //
        if(!b) {
            rc = GetLastError();
        }
    }

    if(rc != NO_ERROR) {
        return(rc);
    }

    //
    // Truncate the ACL, since only a fraction of the size we originally
    // allocated for it is likely to be in use.
    //
    if(!GetAclInformation(Acl,&AclSizeInfo,sizeof(ACL_SIZE_INFORMATION),AclSizeInformation)) {
        return(GetLastError());
    }
    Acl->AclSize = (WORD)AclSizeInfo.AclBytesInUse;

    //
    // Add the ACL to the security descriptor as the DACL
    //
    if(!SetSecurityDescriptorDacl(&SecurityDescriptor,TRUE,Acl,FALSE)) {
        return(GetLastError());
    }

    //
    // Finally, apply the security descriptor.
    //
    rc = SetFileSecurity(FullPath,DACL_SECURITY_INFORMATION,&SecurityDescriptor)
       ? NO_ERROR
       : GetLastError();

    return(rc);
}



DWORD
ApplySecurityToRepairInfo(
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD d, TempError;
    WCHAR Directory[MAX_PATH];
    BOOL SetAclsNt;
    DWORD FsFlags;
    DWORD Result;
    BOOL b;
    ULONG Count;
    PWSTR  Files[] = {
        L"sam",
        L"security",
        L"software",
        L"system",
        L"default",
        L"ntuser.dat",
        L"sam._",
        L"security._",
        L"software._",
        L"system._",
        L"default._",
        L"ntuser.da_"
        };

    //
    // Get the file system of the system drive.
    // On x86 get the file system of the system partition.
    //
    d = NO_ERROR;
    SetAclsNt = FALSE;
    Result = GetWindowsDirectory(Directory,MAX_PATH);
    if(Result == 0) {
        MYASSERT(FALSE);
        return( GetLastError());
    }
    Directory[3] = 0;


    //
    //  ApplySecurity to directories and files, if needed
    //

    b = GetVolumeInformation(Directory,NULL,0,NULL,NULL,&FsFlags,NULL,0);
    if(b && (FsFlags & FS_PERSISTENT_ACLS)) {
        SetAclsNt = TRUE;
    }

    if(SetAclsNt) {
        //
        // Initialize SIDs
        //
        d = InitializeSids();
        if(d != NO_ERROR) {
            return(d);
        }
        //
        // Initialize ACEs
        //
        d = InitializeAces(AceDataTableForDirsAndFiles, AcesForDirsAndFiles, AceSizesForDirsAndFiles, DIRS_AND_FILES_ACE_COUNT);
        if(d != NO_ERROR) {
            TearDownSids();
            return(d);
        }
        //
        // Go do the real work.
        //
        for( Count = 0; Count < sizeof( Files ) / sizeof( PWSTR ); Count++ ) {
            ULONG   AcesToApply[] = {  2,
                                      17
                                    };

            GetWindowsDirectory(Directory,MAX_PATH);
            wcscat( Directory, L"\\repair\\" );
            wcscat( Directory, Files[ Count ] );
            TempError = ApplyAclToDirOrFile( Directory, AcesToApply, sizeof( AcesToApply) / sizeof( ULONG ) );
            if( TempError != NO_ERROR ) {
                if( d == NO_ERROR ) {
                    d = TempError;
                }
            }
        }

        //
        // Clean up.
        //
        TearDownAces(AcesForDirsAndFiles, DIRS_AND_FILES_ACE_COUNT);
        TearDownSids();
    }
    return(d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\arc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    arc.c

Abstract:

    Routines relating to boot.ini.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


PWSTR
ArcDevicePathToNtPath(
    IN PCWSTR ArcPath
    )

/*++

Routine Description:

    Convert an ARC path (device only) to an NT path.

Arguments:

    ArcPath - supplies path to be converted.

Return Value:

    Converted path. Caller must free with MyFree().

--*/

{
    NTSTATUS Status;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UCHAR Buffer[1024];
    PWSTR arcPath;
    PWSTR ntPath;

    //
    // Assume failure
    //
    ntPath = NULL;

    arcPath = MyMalloc(((lstrlen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(L"\\ArcName"));
    if( !arcPath ) {
        return NULL;
    }

    lstrcpy(arcPath,L"\\ArcName\\");
    lstrcat(arcPath,ArcPath);

    RtlInitUnicodeString(&UnicodeString,arcPath);
    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenSymbolicLinkObject(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {

        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = (PWSTR)Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer);

        Status = NtQuerySymbolicLinkObject(ObjectHandle,&UnicodeString,NULL);
        if(NT_SUCCESS(Status)) {

            ntPath = MyMalloc(UnicodeString.Length+sizeof(WCHAR));
            if( ntPath ) {
                CopyMemory(ntPath,UnicodeString.Buffer,UnicodeString.Length);

                ntPath[UnicodeString.Length/sizeof(WCHAR)] = 0;
            }
        }

        NtClose(ObjectHandle);
    }

    MyFree(arcPath);

    return(ntPath);
}


PWSTR
NtFullPathToDosPath(
    IN PCWSTR NtPath
    )
{
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE DosDevicesDir;
    HANDLE DosDevicesObj;
    PWSTR dosPath;
    PWSTR currentDosPath;
    ULONG Context;
    ULONG Length;
    BOOLEAN RestartScan;
    CHAR Buffer[1024];
    WCHAR LinkSource[2*MAX_PATH];
    WCHAR LinkTarget[2*MAX_PATH];
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    UINT PrefixLength;
    UINT NtPathLength;
    WCHAR canonNtPath[MAX_PATH];
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    PWSTR ntPath;

    //
    // Canonicalize the NT path by following the symbolic link.
    //

    ntPath = (PWSTR) NtPath;
    dosPath = NULL;

    RtlInitUnicodeString(&UnicodeString,ntPath);
    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    NtPathLength = UnicodeString.Length/sizeof(WCHAR);
    PrefixLength = UnicodeString.Length/sizeof(WCHAR);

    for (;;) {

        Status = NtOpenSymbolicLinkObject(
                    &ObjectHandle,
                    READ_CONTROL | SYMBOLIC_LINK_QUERY,
                    &Obja
                    );

        if (NT_SUCCESS(Status)) {

            UnicodeString.Buffer = canonNtPath;
            UnicodeString.Length = 0;
            UnicodeString.MaximumLength = sizeof(WCHAR)*MAX_PATH;

            RtlZeroMemory(canonNtPath, UnicodeString.MaximumLength);

            Status = NtQuerySymbolicLinkObject(ObjectHandle,&UnicodeString,NULL);
            if(NT_SUCCESS(Status)) {
                if (NtPathLength > PrefixLength) {
                    RtlCopyMemory((PCHAR) canonNtPath + UnicodeString.Length,
                                  ntPath + PrefixLength,
                                  (NtPathLength - PrefixLength)*sizeof(WCHAR));
                }
                ntPath = canonNtPath;
            }

            NtClose(ObjectHandle);
            break;
        }

        RtlInitUnicodeString(&UnicodeString,ntPath);

        PrefixLength--;
        while (PrefixLength > 0) {
            if (ntPath[PrefixLength] == '\\') {
                break;
            }
            PrefixLength--;
        }

        if (!PrefixLength) {
            break;
        }

        UnicodeString.Length = (USHORT)(PrefixLength*sizeof(WCHAR));

        InitializeObjectAttributes(
            &Obja,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
    }

    NtPathLength = lstrlen(ntPath);

    //
    // Open \DosDevices directory.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\DosDevices");
    InitializeObjectAttributes(&Attributes,&UnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    Status = NtOpenDirectoryObject(&DosDevicesDir,DIRECTORY_QUERY,&Attributes);
    if(!NT_SUCCESS(Status)) {
        return(NULL);
    }

    //
    // Iterate each object in that directory.
    //
    Context = 0;
    RestartScan = TRUE;

    Status = NtQueryDirectoryObject(
                DosDevicesDir,
                Buffer,
                sizeof(Buffer),
                TRUE,
                RestartScan,
                &Context,
                &Length
                );

    RestartScan = FALSE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

    while(NT_SUCCESS(Status)) {

        DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
        DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;

        //
        // Skip this entry if it's not a symbolic link.
        //
        if(DirInfo->Name.Length && !lstrcmpi(DirInfo->TypeName.Buffer,L"SymbolicLink")) {

            //
            // Get this \DosDevices object's link target.
            //
            UnicodeString.Buffer = LinkSource;
            UnicodeString.Length = sizeof(L"\\DosDevices\\") - sizeof(WCHAR);
            UnicodeString.MaximumLength = sizeof(LinkSource);
            lstrcpy(LinkSource,L"\\DosDevices\\");
            RtlAppendUnicodeStringToString(&UnicodeString,&DirInfo->Name);

            InitializeObjectAttributes(&Attributes,&UnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);
            Status = NtOpenSymbolicLinkObject(
                        &DosDevicesObj,
                        READ_CONTROL|SYMBOLIC_LINK_QUERY,
                        &Attributes
                        );

            if(NT_SUCCESS(Status)) {

                UnicodeString.Buffer = LinkTarget;
                UnicodeString.Length = 0;
                UnicodeString.MaximumLength = sizeof(LinkTarget);
                Status = NtQuerySymbolicLinkObject(DosDevicesObj,&UnicodeString,NULL);
                CloseHandle(DosDevicesObj);
                if(NT_SUCCESS(Status)) {
                    //
                    // Make sure LinkTarget is nul-terminated.
                    //
                    PrefixLength = UnicodeString.Length/sizeof(WCHAR);
                    UnicodeString.Buffer[PrefixLength] = 0;

                    //
                    // See if it's a prefix of the path we're converting,
                    //
                    if(!_wcsnicmp(ntPath,LinkTarget,PrefixLength)) {
                        //
                        // Got a match.
                        //
                        currentDosPath = dosPath;
                        if(dosPath = MyMalloc(DirInfo->Name.Length + ((NtPathLength - PrefixLength + 1)*sizeof(WCHAR)))) {
                            lstrcpy(dosPath,DirInfo->Name.Buffer);
                            lstrcat(dosPath,ntPath + PrefixLength);
                        }
                        if (currentDosPath) {
                            if (lstrlen(currentDosPath) < lstrlen(dosPath)) {
                                MyFree(dosPath);
                                dosPath = currentDosPath;
                            } else {
                                MyFree(currentDosPath);
                            }
                        }
                    }
                }
            }
        }

        //
        // Go on to next object.
        //
        Status = NtQueryDirectoryObject(
                    DosDevicesDir,
                    Buffer,
                    sizeof(Buffer),
                    TRUE,
                    RestartScan,
                    &Context,
                    &Length
                    );
    }

    CloseHandle(DosDevicesDir);
    return dosPath;
}


BOOL
SetNvRamVariable(
    IN PCWSTR VarName,
    IN PCWSTR VarValue
    )
{
    UNICODE_STRING VarNameU,VarValueU;
    NTSTATUS Status;

    //
    // Set up unicode strings.
    //
    RtlInitUnicodeString(&VarNameU ,VarName );
    RtlInitUnicodeString(&VarValueU,VarValue);

    pSetupEnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE);
    Status = NtSetSystemEnvironmentValue(&VarNameU,&VarValueU);
    return(NT_SUCCESS(Status));
}


BOOL
ChangeBootTimeoutNvram(
    IN UINT Timeout
    )

/*++

Routine Description:

    Changes the boot countdown value in nv-ram.
    The non-ARC version (which operates on boot.ini) is in i386\bootini.c.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{
    WCHAR TimeoutValue[24];

    wsprintf(TimeoutValue,L"%u",Timeout);

    if(!SetNvRamVariable(L"COUNTDOWN",TimeoutValue)) {
        return(FALSE);
    }

    return(SetNvRamVariable(L"AUTOLOAD",L"YES"));
}

#if defined(EFI_NVRAM_ENABLED)

BOOL
ChangeBootTimeoutEfiNvram(
    IN UINT Timeout
    )

/*++

Routine Description:

    Changes the boot countdown value in EFI nv-ram.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    BOOT_OPTIONS BootOptions;

    ASSERT(IsEfi());

    BootOptions.Version = BOOT_OPTIONS_VERSION;
    BootOptions.Length = sizeof(BootOptions);
    BootOptions.Timeout = Timeout;

    pSetupEnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE);
    Status = NtSetBootOptions(&BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
    return(NT_SUCCESS(Status));
}

#endif // defined(EFI_NVRAM_ENABLED)

#if defined(_X86_)
BOOL
IsArc(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an Arc system. We attempt to read an
    Arc variable using the Hal. This will fail for Bios based systems.

Arguments:

    None

Return Value:

    True = This is an Arc system.

--*/

{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    WCHAR Buffer[4096];

    if(!pSetupEnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE))
        return(FALSE); // need better error handling?

    //
    // Get the env var into the temp buffer.
    //
    RtlInitUnicodeString(&UnicodeString, L"OSLOADER");

    Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR),
                        NULL
                        );


    return(NT_SUCCESS(Status) ? TRUE: FALSE);
}
#endif


BOOL
ChangeBootTimeout(
    IN UINT Timeout
    )
/*++

Routine Description:

    Changes the boot countdown value; decides whether
    to use ARC or non-ARC version.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{

#if defined(EFI_NVRAM_ENABLED)

    if (IsEfi()) {
        return ChangeBootTimeoutEfiNvram(Timeout);
    }

#endif


    if (IsArc()) {
        return ChangeBootTimeoutNvram(Timeout);

    }

#if defined(_X86_)

    return ChangeBootTimeoutBootIni(Timeout);

#else

    return FALSE;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\asrpriv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

File Name:

    asrpriv.c

Abstract:

    Private header file containing definitions and function 
    prototypes for items used across the ASR Files.

Notes:

    Naming conventions:
        _AsrpXXX    private ASR Macros
        AsrpXXX     private ASR routines
        AsrXXX      Publically defined and documented routines

Author:

    Guhan Suriyanarayanan (guhans)  27-May-2000

Revision History:
    
    27-May-2000 guhans  
        Moved common items from asr.c to asrpriv.h


--*/


#ifndef _INC_ASRPRIV_H_
#define _INC_ASRPRIV_H_

#include <ntddscsi.h>   // PSCSI_ADDRESS


//
// --------
// #defines and constants common to the ASR modules.
// --------
//

//
// Size of temporary buffers used in ASR.
//
#define ASR_BUFFER_SIZE                 4096

//
// Maximum length of \??\Volume{Guid}
//
#define ASR_CCH_MAX_VOLUME_GUID         64

//
// Maximum length of \Device\Harddisk1234\Partition1234
//
#define ASR_CCH_DEVICE_PATH_FORMAT      60
extern const WCHAR ASR_WSZ_DEVICE_PATH_FORMAT[];

//
// \??\Volume{
//
extern const WCHAR ASR_WSZ_VOLUME_PREFIX[];

extern const WCHAR ASR_SIF_SYSTEM_SECTION[];
extern const WCHAR ASR_SIF_BUSES_SECTION[];
extern const WCHAR ASR_SIF_MBR_DISKS_SECTION[];
extern const WCHAR ASR_SIF_GPT_DISKS_SECTION[];
extern const WCHAR ASR_SIF_MBR_PARTITIONS_SECTION[];
extern const WCHAR ASR_SIF_GPT_PARTITIONS_SECTION[];


//
// --------
// typedefs common to the ASR modules.
// --------
//

typedef struct _ASR_PTN_INFO {

    //
    // The GUID of the volume on this partition.  For 0x42 parititions,
    // this value is a blank string.
    //
    WCHAR       szVolumeGuid[ASR_CCH_MAX_VOLUME_GUID];

    //
    // next pointer in chain sorted by starting offset
    //
    struct _ASR_PTN_INFO    *pOffsetNext;   

    // 
    // next pointer in chain sorted by partition length
    //
    struct _ASR_PTN_INFO    *pLengthNext;   

    // 
    // The index into the PartitionEntry[] array
    //
    DWORD       SlotIndex;                  


    DWORD       ClusterSize;

    //
    // Special flags for the partition that we're interested in.
    // Currently, the values defined are
    //  0: not interesting
    //  1: Boot partition
    //  2: System partition
    //
    // Care must be taken that this partition flag is in sync with
    // the partition flags defined in setupdd.sys
    //
    USHORT      PartitionFlags;

    //
    // FAT, FAT32, NTFS 
    //
    UCHAR       FileSystemType;

    UCHAR       Reserved;

    //
    // The partition table entry for this partition.
    //
    PARTITION_INFORMATION_EX PartitionInfo;


} ASR_PTN_INFO, *PASR_PTN_INFO;


typedef struct _ASR_PTN_INFO_LIST {

    //
    // This list is sorted by the starting offset of the partitions
    //
    PASR_PTN_INFO    pOffsetHead;
    PASR_PTN_INFO    pOffsetTail;

    //
    // This chain is through the same list, but is sorted by the
    // partition lengths.
    //
    PASR_PTN_INFO    pLengthHead;
    PASR_PTN_INFO    pLengthTail;

    DWORD       numTotalPtns;

    DWORD       numExtendedPtns;

} ASR_PTN_INFO_LIST, *PASR_PTN_INFO_LIST;


//
// Info about each disk on the system.  An ASR_DISK_INFO
// struct will exist for each physical disk that exists
// on the system.
//
typedef struct _ASR_DISK_INFO {

    struct _ASR_DISK_INFO       *pNext;

    //
    // Device Path used to open the Disk.
    // Obtained from SetupDiGetDeviceInterfaceDetail
    //
    PWSTR                       DevicePath;

    //
    // Partition layout information for partitions on the disk
    //
    PDRIVE_LAYOUT_INFORMATION_EX pDriveLayoutEx;

    //
    // Geometry: obtained from IOCTL_GET_DRIVE_GEOMETRY call
    //
    PDISK_GEOMETRY              pDiskGeometry;

    //
    //
    // Information about partition 0 = the entire disk
    //
    PPARTITION_INFORMATION_EX   pPartition0Ex;

    //
    // Additional Information about the partitions, including volume Guid, FS-Type, etc
    //
    PASR_PTN_INFO               PartitionInfoTable;

    PSCSI_ADDRESS               pScsiAddress;

    // For sif disks, this points to the physical disk they've been assigned
    // to, and vice versa.  Used only at restore time.
    //
    struct _ASR_DISK_INFO       *AssignedTo;

    DWORD                       sizeDriveLayoutEx;
    DWORD                       sizeDiskGeometry;
    DWORD                       sizePartition0Ex;
    DWORD                       sizePartitionInfoTable;

    //
    // Device number for disk, constant through sessions
    //
    ULONG                       DeviceNumber;

    ULONG                       SifDiskKey;


    ULONG                       SifBusKey;

    DEVINST                     ParentDevInst;

    //
    // Flag on whether this disk is Critical.  At backup time, the backup
    // app provides us with this info.  At restore time, the Critical disks
    // are expected to be restored by textmode Setup, before
    // RestoreNonCriticalDisks is called.  Critical disks are not
    // re-partitioned by RestoreNonCriticalDisks.
    //
    BOOL                        IsCritical;

    //
    // A flag set to TRUE (at restore time) if a disk has the same signature
    // (or DiskId, for GPT disks) as specified in asr.sif, and if all the
    // partitions specified in asr.sif exist.  Intact disks are not re-partitioned
    // by RestoreNonCriticalDisks.
    //
    BOOL                        IsIntact;

    //
    // If the struct is packed
    //
    BOOL                        IsPacked;

    BOOL                        IsClusterShared;

    BOOL                        IsAligned;

    //
    // This is needed at restore time, since the signature is read in before
    // the drive layout is created (and we need a temporary holding place).
    //
    DWORD                       TempSignature;

    WORD                        wReserved;
    //
    // Information about the bus this disk is on.  This is only
    // used to group all the disks on a bus together.
    //
    STORAGE_BUS_TYPE            BusType;

    //
    // GPT or MBR
    //
    PARTITION_STYLE             Style;


} ASR_DISK_INFO, *PASR_DISK_INFO;


//
// Info about the system--only one struct exists globally.
//
typedef struct _ASR_SYSTEM_INFO {
    //
    // Boot (Windows) Directory
    //
    PWSTR   BootDirectory;

    //
    // OsLoader Path
    //
    PWSTR   SystemPath;

    //
    // Platform = x86 or ia64
    //
    PWSTR   Platform;

    // Name of the backup app
    // Passed in by backup app
 //   PWSTR  Provider;

    PWSTR   pwReserved;

    //
    // Disk Auto-extension:
    // Passed in by backup app
    //
    BOOL AutoExtendEnabled;

    DWORD   sizeComputerName;
    //
    // Obtained from GetComputerName
    //
    WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    //
    // Obtained from GetOsVersionEx
    //
    OSVERSIONINFOEX   OsVersionEx;

    //
    // TimeZone info we save and restore
    //
    TIME_ZONE_INFORMATION TimeZoneInformation;


} ASR_SYSTEM_INFO, *PASR_SYSTEM_INFO;


//
// --------
// Macros common to the ASR modules.
// --------
//

//
//  Macro Description:
//      This macro wraps calls that are expected to return SUCCESS (retcode).
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Result of some function call or conditional expression.
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // An ErrorCode specific to the error and calling function
//
#define _AsrpErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {   \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}


// 
// Simple macro to check a pointer, free it if non-NULL, and set it to NULL.
// 
#define _AsrpHeapFree( p )              \
    if ( p ) {                          \
        HeapFree(heapHandle, 0L, p);   \
        p = NULL;                       \
    }


//
// Simple macro to check if a handle is valid and close it
//
#define _AsrpCloseHandle( h )   \
    if ((h) && (INVALID_HANDLE_VALUE != h)) {   \
        CloseHandle(h);         \
        h = NULL;               \
    }


#define _AsrpIsVolumeGuid(data, numBytes)                                 \
    (                                                                   \
        ((96 == numBytes) || ((98 == numBytes) && data[48] == '\\')) &&     \
        (!_wcsnicmp(L"\\??\\Volume{", data, 11)) &&                     \
        L'-' == data[19] &&                                             \
        L'-' == data[24] &&                                             \
        L'-' == data[29] &&                                             \
        L'-' == data[34] &&                                             \
        L'}' == data[47]                                                \
    )



//
// --------
// debug #defines
// --------
//

#define _asrerror   THIS_MODULE, __LINE__, DPFLTR_ERROR_LEVEL
#define _asrwarn    THIS_MODULE, __LINE__, DPFLTR_WARNING_LEVEL
#define _asrlog     THIS_MODULE, __LINE__, DPFLTR_TRACE_LEVEL

//
// In pre-release mode, let's log everything so it's easier to debug
//
#ifdef PRERELEASE
#define _asrinfo    THIS_MODULE, __LINE__, DPFLTR_TRACE_LEVEL
#else
#define _asrinfo    THIS_MODULE, __LINE__, DPFLTR_INFO_LEVEL
#endif

//
// --------
// routines common to the ASR modules.
// --------
//

//
// Implemented in asrback.c
//
BOOL
AsrpGetMountPoints(
    IN PCWSTR       DeviceName,
    IN CONST DWORD  SizeDeviceName,
    PMOUNTMGR_MOUNT_POINTS  *pMountPointsOut        // caller must free this
    );
    
BOOL
AsrpInitLayoutInformation(
    IN CONST PASR_SYSTEM_INFO pSystemInfo,
    IN PASR_DISK_INFO pDiskList,
    OUT PULONG  MaxDeviceNumber,
    IN BOOL AllDetails
    );

BOOL
AsrpInitDiskInformation(
    OUT PASR_DISK_INFO   *ppDiskList
    );

BOOL
AsrpFreeNonFixedMedia(
    IN OUT PASR_DISK_INFO *ppDiskList
    );

VOID
AsrpFreeStateInformation(
    IN OUT PASR_DISK_INFO   *ppDiskList,
    IN OUT PASR_SYSTEM_INFO pSystemInfo
    );

VOID
AsrpFreePartitionList(
    IN OUT PASR_PTN_INFO_LIST *ppPtnList
    );


//
// Implemented in asrclus.c
//
BOOL
AsrpInitClusterSharedDisks(
    IN PASR_DISK_INFO OriginalDiskList
    );


//
// Implemented in setupasr.c
//
PWSTR   // must be freed by caller
AsrpExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    );

BOOL
AsrIsEnabled(VOID);

VOID
AsrpInitialiseLogFile();

VOID
AsrpInitialiseErrorFile();

VOID
AsrpPrintDbgMsg(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN PCSTR FormatString,
    ...);

VOID
AsrpCloseLogFiles();


#endif  // _INC_ASRPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\afpnp.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    afpnp.c

Abstract:

    Routines to manage installation of devices via the answer file.

    The main entry points are:

        CreateAfDriverTable
        DestroyAfDriverTable
        SyssetupInstallAnswerFileDriver
        CountAfDrivers

    The rest of the functions are utilities or routines used by outside
    callers only in a special case of some sort.

Author:

    Jim Schmidt (jimschm) 20-Mar-1998

Revision History:


--*/

#include "setupp.h"
#pragma hdrstop

//
// Contants
//

#if DBG
#define PNP_DEBUG  1
#else
#define PNP_DEBUG  0
#endif

#if PNP_DEBUG
#define PNP_DBGPRINT(x) DebugPrintWrapper x
#else
#define PNP_DBGPRINT(x)
#endif

//
// Local prototypes
//

BOOL
pBuildAfDriverAttribs (
    IN OUT  PAF_DRIVER_ATTRIBS Attribs
    );

BOOL
pAddAfDriver (
    IN      PAF_DRIVER_ATTRIBS Driver,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    IN      BOOL First
    );

PAF_DRIVER_ATTRIBS
pGetSelectedSourceDriver (
    IN      PAF_DRIVERS Drivers,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Implementation
//

#if DBG

VOID
DebugPrintWrapper (
    PCSTR FormatStr,
    ...
    )
{
    va_list list;
    WCHAR OutStr[2048];
    WCHAR UnicodeFormatStr[256];

    //
    // Args are wchar by default!!
    //

    MultiByteToWideChar (CP_ACP, 0, FormatStr, -1, UnicodeFormatStr, 256);

    va_start (list, FormatStr);
    vswprintf (OutStr, UnicodeFormatStr, list);
    va_end (list);

    SetupDebugPrint (OutStr);
}

#endif

HINF
pOpenAnswerFile (
    VOID
    )
{
    HINF AnswerInf;
    WCHAR AnswerFile[MAX_PATH];

    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    AnswerInf = SetupOpenInfFile(AnswerFile,NULL,INF_STYLE_OLDNT,NULL);
    return AnswerInf;
}


#define S_DEVICE_DRIVERSW       L"DeviceDrivers"

VOID
MySmartFree (
    PCVOID p
    )
{
    if (p) {
        MyFree (p);
    }
}


PVOID
MySmartAlloc (
    PCVOID Old,     OPTIONAL
    UINT Size
    )
{
    if (Old) {
        return MyRealloc ((PVOID) Old, Size);
    }

    return MyMalloc (Size);
}


PVOID
ReusableAlloc (
    IN OUT  PBUFFER Buf,
    IN      UINT SizeNeeded
    )
{
    if (!Buf->Buffer || Buf->Size < SizeNeeded) {
        Buf->Size = SizeNeeded - (SizeNeeded & 1023) + 1024;

        if (Buf->Buffer) {
            MyFree (Buf->Buffer);
        }

        Buf->Buffer = (PWSTR) MyMalloc (Buf->Size);
        if (!Buf->Buffer) {
            PNP_DBGPRINT (( "SETUP: Mem alloc failed for %u bytes. \n", Buf->Size ));
            Buf->Size = 0;
            return NULL;
        }
    }

    return Buf->Buffer;
}


VOID
ReusableFree (
    IN OUT  PBUFFER Buf
    )
{
    MySmartFree (Buf->Buffer);
    ZeroMemory (Buf, sizeof (BUFFER));
}


PWSTR
MultiSzAppendString (
    IN OUT  PMULTISZ MultiSz,
    IN      PCWSTR String
    )
{
    UINT BytesNeeded;
    UINT NewSize;
    PWSTR p;

    BytesNeeded = (UINT)((PBYTE) MultiSz->End - (PBYTE) MultiSz->Start);
    BytesNeeded += (UINT)(((PBYTE) wcschr (String, 0)) - (PBYTE) String) + sizeof (WCHAR);
    BytesNeeded += sizeof (WCHAR);

    if (!MultiSz->Start || MultiSz->Size < BytesNeeded) {
        NewSize = BytesNeeded - (BytesNeeded & 0xfff) + 0x1000;

        p = (PWSTR) MySmartAlloc (MultiSz->Start, NewSize);
        if (!p) {
            PNP_DBGPRINT (( "SETUP: Mem alloc failed for %u bytes", NewSize ));
            return NULL;
        }

        MultiSz->End = p + (MultiSz->End - MultiSz->Start);
        MultiSz->Start = p;
        MultiSz->Size = BytesNeeded;
    }

    p = MultiSz->End;
    lstrcpyW (p, String);
    MultiSz->End = wcschr (p, 0) + 1;

    MYASSERT (((PBYTE) MultiSz->Start + BytesNeeded) >= ((PBYTE) MultiSz->End + sizeof (WCHAR)));
    *MultiSz->End = 0;

    return p;
}


VOID
MultiSzFree (
    IN OUT  PMULTISZ MultiSz
    )
{
    MySmartFree (MultiSz->Start);
    ZeroMemory (MultiSz, sizeof (MULTISZ));
}


BOOL
EnumFirstMultiSz (
    IN OUT  PMULTISZ_ENUM EnumPtr,
    IN      PCWSTR MultiSz
    )
{
    EnumPtr->Start = MultiSz;
    EnumPtr->Current = MultiSz;

    return MultiSz && *MultiSz;
}


BOOL
EnumNextMultiSz (
    IN OUT  PMULTISZ_ENUM EnumPtr
    )
{
    if (!EnumPtr->Current || *EnumPtr->Current == 0) {
        return FALSE;
    }

    EnumPtr->Current = wcschr (EnumPtr->Current, 0) + 1;
    return *EnumPtr->Current;
}


BOOL
pBuildAfDriverAttribs (
    IN OUT  PAF_DRIVER_ATTRIBS Attribs
    )

/*++

Routine Description:

  pBuildAfDriverAttribs updates the driver attribute structure by setting all
  the members of the structure.  If the members were previously set, this
  function is a NOP.

Arguments:

  Attribs - Specifies the answer file driver attribute structure, which does
            not need to be empty.  Receives the attributes.

Return Value:

  TRUE if the driver is valid, or FALSE if something went wrong during
  attribute gathering.

--*/

{
    PWSTR p;
    INFCONTEXT ic;
    BUFFER Buf = BUFFER_INIT;

    if (Attribs->Initialized) {
        return TRUE;
    }

    Attribs->Initialized = TRUE;

    //
    // Compute paths
    //

    Attribs->FilePath = pSetupDuplicateString (Attribs->InfPath);

    p = wcsrchr (Attribs->FilePath, L'\\');
    if (p) {
        *p = 0;
    }

    Attribs->Broken = (Attribs->InfPath == NULL) ||
                      (Attribs->FilePath == NULL);

    //
    // Open the INF and look for ClassInstall32
    //

    if (!Attribs->Broken) {
        Attribs->InfHandle = SetupOpenInfFile (Attribs->InfPath, NULL, INF_STYLE_WIN4, NULL);
        Attribs->Broken = (Attribs->InfHandle == INVALID_HANDLE_VALUE);
    }

    if (!Attribs->Broken) {

#if defined _X86_
        Attribs->ClassInstall32Section = L"ClassInstall32.NTx86";
#elif defined _AMD64_
        Attribs->ClassInstall32Section = L"ClassInstall32.NTAMD64";
#elif defined _IA64_
        Attribs->ClassInstall32Section = L"ClassInstall32.NTIA64";
#else
#error "No Target Architecture"
#endif

        if (!SetupFindFirstLine (
                Attribs->InfHandle,
                Attribs->ClassInstall32Section,
                NULL,
                &ic
                )) {

            Attribs->ClassInstall32Section = L"ClassInstall32.NT";

            if (!SetupFindFirstLine (
                    Attribs->InfHandle,
                    Attribs->ClassInstall32Section,
                    NULL,
                    &ic
                    )) {

                Attribs->ClassInstall32Section = L"ClassInstall32";

                if (!SetupFindFirstLine (
                        Attribs->InfHandle,
                        Attribs->ClassInstall32Section,
                        NULL,
                        &ic
                        )) {

                    Attribs->ClassInstall32Section = NULL;

                }
            }
        }
    }

    if (!Attribs->Broken && Attribs->ClassInstall32Section) {
        //
        // ClassInstall32 was found, so there's got to be a GUID
        //

        if (SetupFindFirstLine (
                Attribs->InfHandle,
                L"Version",
                L"ClassGUID",
                &ic
                )) {

            p = (PWSTR) SyssetupGetStringField (&ic, 1, &Buf);
            if (!p) {
                PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Invalid GUID line. \n" ));
            } else {
                if (!pSetupGuidFromString (p, &Attribs->Guid)) {
                    PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Invalid GUID. \n" ));
                }
            }
        }
        else {
            PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: ClassInstall32 found but GUID not found. \n" ));
        }
    }

    ReusableFree (&Buf);

    return !Attribs->Broken;
}


PCWSTR
SyssetupGetStringField (
    IN      PINFCONTEXT InfContext,
    IN      DWORD Field,
    IN OUT  PBUFFER Buf
    )

/*++

Routine Description:

  SyssetupGetStringField is a wrapper for SetupGetStringField.   It uses the
  BUFFER structure to minimize allocation requests.

Arguments:

  InfContext - Specifies the INF context as provided by other Setup API
               functions.
  Field      - Specifies the field to query.
  Buf        - Specifies the buffer to reuse.  Any previously allocated
               pointers to this buffer's data are invalid.  The caller must
               free the buffer.

Return Value:

  A pointer to the string, allocated in Buf, or NULL if the field does not
  exist or an error occurred.

--*/

{
    DWORD SizeNeeded;
    DWORD BytesNeeded;
    PWSTR p;

    if (!SetupGetStringField (InfContext, Field, NULL, 0, &SizeNeeded)) {
        return NULL;
    }

    BytesNeeded = (SizeNeeded + 1) * sizeof (WCHAR);
    p = ReusableAlloc (Buf, BytesNeeded);

    if (p) {
        if (!SetupGetStringField (InfContext, Field, p, SizeNeeded, NULL)) {
            return NULL;
        }
    }

    return p;
}


INT
CountAfDrivers (
    IN      PAF_DRIVERS Drivers,
    OUT     INT *ClassInstallers        OPTIONAL
    )

/*++

Routine Description:

  CountAfDrivers enumerates the drivers in the table specified and returns
  the count.  The caller can also receive the number of class installers (a
  subset of the driver list).  Querying the number of class installers may
  take a little time if there are a lot of drivers listed in the answer file
  and the driver INFs have not been opened yet.  (Otherwise this routine is
  very fast.)

Arguments:

  Drivers         - Specifies the driver table to process.
  ClassInstallers - Receives a count of the number of class installers
                    specified in the answer file.

Return Value:

  The number of drivers specified in the answer file.

--*/

{
    AF_DRIVER_ENUM e;
    INT UniqueDriverDirs;

    MYASSERT (Drivers && Drivers->DriverTable);

    //
    // Count entries in the DriverTable string table, and open each one to look for
    // a ClassInstall32 section
    //

    UniqueDriverDirs = 0;
    *ClassInstallers  = 0;

    if (EnumFirstAfDriver (&e, Drivers)) {
        do {
            if (ClassInstallers) {
                if (e.Driver->ClassInstall32Section) {
                    *ClassInstallers += 1;
                }
            }

            UniqueDriverDirs++;

        } while (EnumNextAfDriver (&e));
    }

    return UniqueDriverDirs;
}


PAF_DRIVERS
CreateAfDriverTable (
    VOID
    )

/*++

Routine Description:

  CreateAfDriverTable generates a string table populated with the paths
  to device driver INFs specified in the answer file.  This is the first step
  in processing the [DeviceDrivers] section of unattend.txt.

  The caller must destroy a non-NULL driver table via DestroyAfDriverTable
  to free memory used by the table and each entry in the table.

Arguments:

  None.

Return Value:

  A pointer to the populated string table, or NULL if no entries exist.

--*/

{
    PAF_DRIVERS Drivers;
    HINF AnswerInf;
    PVOID NewDriverTable;
    INFCONTEXT ic;
    PWSTR InfPath;
    PCWSTR OriginalInstallMedia;
    PWSTR PnpId;
    PWSTR p;
    BOOL FoundOne = FALSE;
    PAF_DRIVER_ATTRIBS Attribs;
    PAF_DRIVER_ATTRIBS FirstAttribs = NULL;
    BUFFER b1, b2, b3;
    LONG Index;

    //
    // Init
    //

    AnswerInf = pOpenAnswerFile();
    if (AnswerInf == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    NewDriverTable = pSetupStringTableInitializeEx (sizeof (PAF_DRIVER_ATTRIBS), 0);
    if (!NewDriverTable) {
        PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: String table alloc failed. \n" ));
        SetupCloseInfFile (AnswerInf);
        return NULL;
    }

    ZeroMemory (&b1, sizeof (b1));
    ZeroMemory (&b2, sizeof (b2));
    ZeroMemory (&b3, sizeof (b3));

    //
    // Build a list of unique INF paths that are in the [DeviceDrivers]
    // section of the answer file, if any.
    //

    if (SetupFindFirstLine (AnswerInf, S_DEVICE_DRIVERSW, NULL, &ic)) {
        do {
            //
            // Get the data from the answer file
            //

            p = (PWSTR) SyssetupGetStringField (&ic, 0, &b1);
            if (!p) {
                PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Invalid answer file line ignored. \n" ));
                continue;
            }

            PnpId = p;

            p = (PWSTR) SyssetupGetStringField (&ic, 1, &b2);
            if (!p) {
                PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Invalid answer file line ignored. \n" ));
                continue;
            }

            InfPath = p;

            p = (PWSTR) SyssetupGetStringField (&ic, 2, &b3);
            if (!p) {
                PNP_DBGPRINT (( "SETUP: No original media path; assuming floppy \n" ));
                OriginalInstallMedia = IsNEC_98 ? L"C:\\" : L"A:\\";
            } else {
                OriginalInstallMedia = p;
            }

            //
            // Check to see if INF path has already been added.  If so, add PNP
            // ID to list of IDs, and continue to next PNP ID.
            //

            Index = pSetupStringTableLookUpString (
                        NewDriverTable,
                        InfPath,
                        STRTAB_CASE_INSENSITIVE
                        );

            if (Index != -1) {
                //
                // Get the Attribs struct
                //

                if (!pSetupStringTableGetExtraData (
                        NewDriverTable,
                        Index,
                        &Attribs,
                        sizeof (Attribs)
                        )) {
                    PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: String table extra data failure. \n" ));
                    continue;
                }

                MultiSzAppendString (&Attribs->PnpIdList, PnpId);
                continue;
            }

            //
            // New INF path: Allocate an attribute structure and put the path in a
            // string table.
            //

            Attribs = (PAF_DRIVER_ATTRIBS) MyMalloc (sizeof (AF_DRIVER_ATTRIBS));
            if (!Attribs) {
                PNP_DBGPRINT ((
                    "SETUP: CreateAfDriverTable: Mem alloc failed for %u bytes. \n",
                    sizeof (AF_DRIVER_ATTRIBS)
                    ));

                break;
            }

            ZeroMemory (Attribs, sizeof (AF_DRIVER_ATTRIBS));
            Attribs->InfHandle = INVALID_HANDLE_VALUE;
            Attribs->InfPath  = pSetupDuplicateString (InfPath);
            Attribs->OriginalInstallMedia = pSetupDuplicateString (OriginalInstallMedia);
            MultiSzAppendString (&Attribs->PnpIdList, PnpId);

            Attribs->Next = FirstAttribs;
            FirstAttribs = Attribs;

            pSetupStringTableAddStringEx (
                NewDriverTable,
                InfPath,
                STRTAB_CASE_INSENSITIVE,
                &Attribs,
                sizeof (Attribs)
                );

            FoundOne = TRUE;

        } while (SetupFindNextLine (&ic, &ic));
    }

    //
    // Clean up and exit
    //

    SetupCloseInfFile (AnswerInf);

    ReusableFree (&b1);
    ReusableFree (&b2);
    ReusableFree (&b3);

    if (FoundOne) {
        Drivers = (PAF_DRIVERS) MyMalloc (sizeof (AF_DRIVERS));
        if (Drivers) {
            Drivers->DriverTable = NewDriverTable;
            Drivers->FirstDriver = FirstAttribs;

            //
            // Exit with success
            //

            return Drivers;
        }
        else {
            PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Can't allocate %u bytes. \n", sizeof (AF_DRIVERS) ));
        }
    }

    //
    // Failure or empty
    //

    pSetupStringTableDestroy (NewDriverTable);
    return NULL;
}


VOID
DestroyAfDriverTable (
    IN      PAF_DRIVERS Drivers
    )

/*++

Routine Description:

  DestroyAfDriverTable enumerates the specified driver table and cleans up
  all memory used by the table.

Arguments:

  Drivers - Specifies the table to clean up.  Caller should not use table
            handle after this routine completes.

Return Value:

  None.

--*/

{
    AF_DRIVER_ENUM e;

    if (!Drivers) {
        return;
    }

    MYASSERT (Drivers->DriverTable);

    if (EnumFirstAfDriverEx (&e, Drivers, TRUE)) {
        do {
            MySmartFree (e.Driver->InfPath);
            MySmartFree (e.Driver->FilePath);
            MultiSzFree (&e.Driver->PnpIdList);

            if (e.Driver->InfHandle != INVALID_HANDLE_VALUE) {
                SetupCloseInfFile (e.Driver->InfHandle);
            }
        } while (EnumNextAfDriver (&e));
    }

    pSetupStringTableDestroy (Drivers->DriverTable);
}


BOOL
EnumFirstAfDriver (
    OUT     PAF_DRIVER_ENUM EnumPtr,
    IN      PAF_DRIVERS Drivers
    )

/*++

Routine Description:

  EnumFirstAfDriver returns attributes for the first answer file-supplied
  driver.  The driver is returned in the enum structure.

Arguments:

  EnumPtr - Receives a pointer to the first valid driver (supplied in the
            answer file).
  Drivers - Specifies the driver table to enumerate.

Return Value:

  TRUE if a driver was enumerated, or FALSE if none exist.

--*/

{
    return EnumFirstAfDriverEx (EnumPtr, Drivers, FALSE);
}


BOOL
EnumFirstAfDriverEx (
    OUT     PAF_DRIVER_ENUM EnumPtr,
    IN      PAF_DRIVERS Drivers,
    IN      BOOL WantAll
    )

/*++

Routine Description:

  EnumFirstAfDriverEx works the same as EnumFirstAfDriver, except it
  optionally enumerates all drivers (i.e., those considered "broken").

Arguments:

  EnumPtr - Receives the first driver supplied in the answer file.
  Drivers - Specifies the driver table to enumerate.
  WantAll - Specifies TRUE if broken drivers should be enumerated, or FALSE
            if they should be skipped.

Return Value:

  TRUE if a driver was enumerated, or FALSE if none exist.

--*/

{
    if (!Drivers) {
        return FALSE;
    }

    MYASSERT (Drivers->DriverTable);

    EnumPtr->Driver  = Drivers->FirstDriver;
    EnumPtr->WantAll = WantAll;

    if (!WantAll && EnumPtr->Driver) {
        //
        // Make sure attribs are accurate
        //

        pBuildAfDriverAttribs (EnumPtr->Driver);
    }

    if (!WantAll && EnumPtr->Driver && EnumPtr->Driver->Broken) {
        return EnumNextAfDriver (EnumPtr);
    }

    return EnumPtr->Driver != NULL;
}


BOOL
EnumNextAfDriver (
    IN OUT  PAF_DRIVER_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumNextAfDriver continues an enumeration started by
  EnumFirstAfDriver(Ex).

Arguments:

  EnumPtr - Specifies the enumeration to continue.  Receives the next driver
            pointer.

Return Value:

  TRUE if another driver was enumerated, or FALSE if no more drivers exist.

--*/

{
    if (!EnumPtr->Driver) {
        return FALSE;
    }

    do {

        EnumPtr->Driver = EnumPtr->Driver->Next;

        if (!EnumPtr->WantAll && EnumPtr->Driver) {
            //
            // Make sure attribs are accurate
            //

            pBuildAfDriverAttribs (EnumPtr->Driver);
        }

    } while (EnumPtr->Driver && EnumPtr->Driver->Broken && !EnumPtr->WantAll);

    return EnumPtr->Driver != NULL;
}


PWSTR
pMyGetDeviceRegistryProperty (
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    IN      DWORD Property,
    IN OUT  PBUFFER Buf
    )
{
    DWORD SizeNeeded;
    DWORD Type;
    PBYTE p;

    SizeNeeded = 0;

    SetupDiGetDeviceRegistryProperty (
        hDevInfo,
        DeviceInfoData,
        Property,
        &Type,
        NULL,
        0,
        &SizeNeeded
        );

    if (!SizeNeeded) {
        return NULL;
    }

    if (Type != REG_MULTI_SZ) {
        PNP_DBGPRINT (( "SETUP: Device ID not REG_MULTI_SZ. \n" ));
        return NULL;
    }

    p = ReusableAlloc (Buf, SizeNeeded);
    if (!p) {
        return NULL;
    }

    if (!SetupDiGetDeviceRegistryProperty (
            hDevInfo,
            DeviceInfoData,
            Property,
            NULL,
            p,
            SizeNeeded,
            NULL
            )) {
        return NULL;
    }

    return (PWSTR) p;
}


VOID
pAddIdsToStringTable (
    IN OUT  PVOID StringTable,
    IN      PWSTR IdString
    )
{
    MULTISZ_ENUM e;

    if (EnumFirstMultiSz (&e, IdString)) {
        do {
            PNP_DBGPRINT (( "SETUP: Device has PNP ID %s \n", e.Current));
            pSetupStringTableAddString (StringTable, (PWSTR) e.Current, STRTAB_CASE_INSENSITIVE);
        } while (EnumNextMultiSz (&e));
    }
}


PSP_DRVINFO_DETAIL_DATA
pMyGetDriverInfoDetail (
    IN     HDEVINFO         hDevInfo,
    IN     PSP_DEVINFO_DATA DeviceInfoData,
    IN     PSP_DRVINFO_DATA DriverInfoData,
    IN OUT PBUFFER Buf
    )
{
    PSP_DRVINFO_DETAIL_DATA Ptr;
    DWORD SizeNeeded = 0;

    SetupDiGetDriverInfoDetail (
        hDevInfo,
        DeviceInfoData,
        DriverInfoData,
        NULL,
        0,
        &SizeNeeded
        );

    if (!SizeNeeded) {
        PNP_DBGPRINT (( "SETUP: SetupDiGetDriverInfoDetail failed to get size for answer file driver, error 0%Xh. \n", GetLastError() ));
        return NULL;
    }

    Ptr = (PSP_DRVINFO_DETAIL_DATA) ReusableAlloc (Buf, SizeNeeded);

    if (!Ptr) {
        return NULL;
    }

    Ptr->cbSize = sizeof (SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail (
            hDevInfo,
            DeviceInfoData,
            DriverInfoData,
            Ptr,
            SizeNeeded,
            NULL
            )) {
        PNP_DBGPRINT (( "SETUP: SetupDiGetDriverInfoDetail failed for answer file driver, error 0%Xh. \n", GetLastError() ));
        return NULL;
    }

    return Ptr;
}


BOOL
SyssetupInstallAnswerFileDriver (
    IN      PAF_DRIVERS Drivers,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    OUT     PAF_DRIVER_ATTRIBS *AfDriver
    )

/*++

Routine Description:

    SyssetupInstallAnswerFileDriver builds a device list from each
    answer file-specified driver and tests it against the current
    device.  If support is found, the device is installed.

Arguments:

    Drivers - Specifies the structure that maintains answer file-supplied
              driver attributes.  If Drivers is NULL, no processing is
              performed.

    hDevInfo - Specifies the device info handle for the device being
               processed

    DeviceInfoData - Specifies device state.

    AfDriver - Receives a pointer to the selected answer file driver
               details, or NULL if no answer file driver was selected.

Return Value:

    Returns TRUE if a driver was successfully installed.

--*/

{
    AF_DRIVER_ENUM e;
    PVOID PnpIdTable;
    BUFFER Buf = BUFFER_INIT;
    BOOL b = FALSE;
    PWSTR IdString;
    MULTISZ_ENUM AfId;
    BOOL First = TRUE;
    WCHAR CurrentId[512];
    PWSTR p;
    SP_DEVINSTALL_PARAMS deviceInstallParams;

    *AfDriver = NULL;

    PnpIdTable = pSetupStringTableInitialize();
    if (!PnpIdTable) {
        return FALSE;
    }

    __try {
        //
        // Enumeration will fail if there are no drivers specified in the answer file
        //

        if (!EnumFirstAfDriver (&e, Drivers)) {
            __leave;
        }

        //
        // Determine IDs of the device
        //

        IdString = pMyGetDeviceRegistryProperty (
                        hDevInfo,
                        DeviceInfoData,
                        SPDRP_HARDWAREID,
                        &Buf
                        );

        if (IdString) {
            pAddIdsToStringTable (PnpIdTable, IdString);
        }

        IdString = pMyGetDeviceRegistryProperty (
                        hDevInfo,
                        DeviceInfoData,
                        SPDRP_COMPATIBLEIDS,
                        &Buf
                        );

        if (IdString) {
            pAddIdsToStringTable (PnpIdTable, IdString);
        }

        //
        // For each af-supplied driver, compare driver IDs against device IDs
        //

        do {
            //
            // Look for PNP match
            //

            if (EnumFirstMultiSz (&AfId, e.Driver->PnpIdList.Start)) {
                do {
                    if (-1 != pSetupStringTableLookUpString (
                                    PnpIdTable,
                                    (PWSTR) AfId.Current,
                                    STRTAB_CASE_INSENSITIVE
                                    )) {

                        //
                        // Found match, add INF to the list of choices
                        //

                        if (!pAddAfDriver (e.Driver, hDevInfo, DeviceInfoData, First)) {
                            __leave;
                        }

                        First = FALSE;

                    }
                } while (EnumNextMultiSz (&AfId));
            }

        } while (EnumNextAfDriver (&e));

        //
        // If First is still TRUE, then we have no match
        //

        if (First) {
            __leave;
        }

        //
        // Prepare for driver install by choosing the driver
        //

        b = SetupDiCallClassInstaller (
                DIF_SELECTBESTCOMPATDRV,
                hDevInfo,
                DeviceInfoData
                );

        if (!b) {
            PNP_DBGPRINT (( "SETUP: SetupDiCallClassInstaller failed for answer file driver, error 0%Xh. \n", GetLastError() ));

            //
            // reset the struct
            //
            deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams (hDevInfo, DeviceInfoData, &deviceInstallParams)) {
                ZeroMemory (deviceInstallParams.DriverPath, sizeof (deviceInstallParams.DriverPath));
                deviceInstallParams.Flags &= ~DI_ENUMSINGLEINF;
                deviceInstallParams.FlagsEx &= ~DI_FLAGSEX_APPENDDRIVERLIST;

                if (SetupDiSetDeviceInstallParams (hDevInfo, DeviceInfoData, &deviceInstallParams)) {
                    if (!SetupDiDestroyDriverInfoList (hDevInfo, DeviceInfoData, SPDIT_COMPATDRIVER)) {
                        PNP_DBGPRINT (( "SETUP: SyssetupInstallAnswerFileDriver: SetupDiDestroyDriverInfoList() failed. Error = 0%Xh \n", GetLastError() ));
                    }
                } else {
                    PNP_DBGPRINT (( "SETUP: SyssetupInstallAnswerFileDriver: SetupDiSetDeviceInstallParams() failed. Error = 0%Xh \n", GetLastError() ));
                }
            } else {
                PNP_DBGPRINT (( "SETUP: SyssetupInstallAnswerFileDriver: SetupDiGetDeviceInstallParams() failed. Error = 0%Xh \n", GetLastError() ));
            }
        } else {

            //
            // Identify which driver of ours, if any, was chosen
            //

            *AfDriver = pGetSelectedSourceDriver (Drivers, hDevInfo, DeviceInfoData);

            if (*AfDriver == NULL) {
                PNP_DBGPRINT (( "SETUP: WARNING: Answer File Driver was not chosen for its device. \n" ));
            }
        }

    }
    __finally {

        pSetupStringTableDestroy (PnpIdTable);
        ReusableFree (&Buf);

    }

    return b;

}


BOOL
pAddAfDriver (
    IN      PAF_DRIVER_ATTRIBS Driver,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    IN      BOOL First
    )

/*++

Routine Description:

  pAddAfDriver adds the INF specified in the answer file to the list of INFs.
  This causes the PNP setup code to include it when finding the best device
  driver.

Arguments:

  Driver         - Specifies the attributes of the answer file-supplied driver

  hDevInfo       - Specifies the current device

  DeviceInfoData - Specifies current device info

  First          - TRUE if this is the first answer file-supplied INF for the
                   device, otherwise FALSE

Return Value:

  TRUE if the INF was added to the device install parameters, FALSE otherwise

--*/

{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HKEY Key;

    //
    // Fill in DeviceInstallParams struct
    //

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (!SetupDiGetDeviceInstallParams (hDevInfo, DeviceInfoData, &DeviceInstallParams)) {
        PNP_DBGPRINT (( "SETUP: pAddAfDriver: SetupDiGetDeviceInstallParams() failed. Error = 0%Xh \n", GetLastError() ));
        return FALSE;
    }

    //
    // Modify the struct
    //

    MYASSERT (!DeviceInstallParams.DriverPath[0]);
    lstrcpynW (DeviceInstallParams.DriverPath, Driver->InfPath, MAX_PATH);
    DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_APPENDDRIVERLIST;

    //
    // Tell setup api where to find the driver
    //

    if (!SetupDiSetDeviceInstallParams (hDevInfo, DeviceInfoData, &DeviceInstallParams)) {
        PNP_DBGPRINT (( "SETUP: pAddAfDriver: SetupDiSetDeviceInstallParams() failed. Error = 0%Xh \n", GetLastError() ));
        return FALSE;
    }

    if( !SetupDiBuildDriverInfoList( hDevInfo, DeviceInfoData, SPDIT_COMPATDRIVER ) ) {
        PNP_DBGPRINT (( "SETUP: pAddAfDriver: SetupDiBuildDriverInfoList() failed. Error = 0%Xh \n", GetLastError() ));
        return FALSE;
    }

    //
    // Install ClassInstall32 if necessary
    //

    if (Driver->ClassInstall32Section) {
        //
        // Is class already installed?
        //

        Key = SetupDiOpenClassRegKey (&Driver->Guid, KEY_READ);
        if (Key == (HKEY) INVALID_HANDLE_VALUE || !Key) {
            //
            // No, install class.
            //

            if (!SetupDiInstallClass (NULL, Driver->InfPath, DI_FORCECOPY, NULL)) {
                PNP_DBGPRINT (( "SETUP: pAddAfDriver: SetupDiInstallClass() failed. Error = 0%Xh \n", GetLastError() ));
            }
        } else {
            RegCloseKey (Key);
        }
    }

    return TRUE;
}


PAF_DRIVER_ATTRIBS
pGetSelectedSourceDriver (
    IN      PAF_DRIVERS Drivers,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

  pGetSelectedSourceDriver finds which answer file driver was selected, if
  any.

Arguments:

  Drivers        - Specifies the answer file driver table, as created by
                   CreateAfDriverTable

  hDevInfo       - Specifies the current device.  The driver for this
                   device must be selected, but not yet installed.

  DeviceInfoData - Specifies the device data

Return Value:

  A pointer to the answer file driver attributes, or NULL if no answer file
  driver was selected for the device.

--*/

{
    SP_DRVINFO_DATA DriverData;
    PAF_DRIVER_ATTRIBS OurDriver = NULL;
    PSP_DRVINFO_DETAIL_DATA DetailData;
    BUFFER Buf = BUFFER_INIT;
    AF_DRIVER_ENUM e;

    __try {
        //
        // After the PNP subsystem installs a driver for the device, we get the
        // actual installed device INF path, and see if it was one of our
        // answer file-supplied drivers.
        //

        DriverData.cbSize = sizeof(SP_DRVINFO_DATA);

        if (!SetupDiGetSelectedDriver (hDevInfo, DeviceInfoData, &DriverData)) {
            PNP_DBGPRINT (( "SETUP: SetupDiGetSelectedDriver failed for answer file driver, error 0%Xh. \n", GetLastError() ));
        } else {
            DetailData = pMyGetDriverInfoDetail (hDevInfo, DeviceInfoData, &DriverData, &Buf);

            if (DetailData) {

                //
                // Check our driver list
                //

                if (EnumFirstAfDriver (&e, Drivers)) {
                    do {

                        if (!lstrcmpi (e.Driver->InfPath, DetailData->InfFileName)) {
                            //
                            // Match found
                            //

                            OurDriver = e.Driver;
                            break;
                        }
                    } while (EnumNextAfDriver (&e));
                }

            } else {
                PNP_DBGPRINT (( "SETUP: No driver details available, error 0%Xh. \n", GetLastError() ));
            }
        }

    }
    __finally {
        ReusableFree (&Buf);
    }

    return OurDriver;
}


BOOL
SyssetupFixAnswerFileDriverPath (
    IN      PAF_DRIVER_ATTRIBS Driver,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

  SyssetupFixAnswerFileDriverPath calls SetupCopyOEMFile to copy the device
  INF over itself.  The source is the same as the destination, which causes
  the PNF to be rebuilt, and doesn't cause any copy
  activity.


Arguments:

  Driver         - Specifies the attributes of the answer file-supplied driver
  hDevInfo       - Specifies the device.  The driver for this device must
                   already be installed.
  DeviceInfoData - Specifies the device info

Return Value:

  TRUE if the PNF was updated, FALSE otherwise.

--*/

{
    HKEY Key = NULL;
    LONG rc;
    DWORD Type;
    DWORD DataSize;
    WCHAR Data[MAX_PATH - 48];
    WCHAR WinDir[48];
    WCHAR FullNtInfPath[MAX_PATH];
    BOOL b = FALSE;


    __try {
        //
        // Now the driver in the temp dir has been installed.  We must
        // get the PNF to point to the original media.  We do this by
        // recopying the INF over itself.
        //

        Key = SetupDiOpenDevRegKey (
                    hDevInfo,
                    DeviceInfoData,
                    DICS_FLAG_GLOBAL,
                    0,
                    DIREG_DRV,
                    KEY_READ
                    );

        if (!Key) {
            PNP_DBGPRINT (( "SETUP: Can't open key for device, error 0%Xh. \n", GetLastError() ));
            __leave;
        }

        DataSize = sizeof (Data);

        rc = RegQueryValueEx (
                Key,
                REGSTR_VAL_INFPATH,
                NULL,
                &Type,
                (PBYTE) Data,
                &DataSize
                );

        if (rc != ERROR_SUCCESS) {
            PNP_DBGPRINT (( "SETUP: Can't query value for device, error 0%Xh. \n", rc ));
            __leave;
        }

        if (!GetSystemWindowsDirectory (WinDir, sizeof (WinDir) / sizeof (WinDir[0]))) {
            MYASSERT (FALSE);
            PNP_DBGPRINT (( "SETUP: Can't get %%windir%%, error 0%Xh. \n", GetLastError() ));
            __leave;
        }

        wsprintfW (FullNtInfPath, L"%s\\INF\\%s", WinDir, Data);

        MYASSERT (GetFileAttributes (FullNtInfPath) != 0xFFFFFFFF);

        //
        // We now have the installed INF path.  Recopy the INF so we can
        // change the original media path.
        //

        b = SetupCopyOEMInf (
                FullNtInfPath,
                Driver->OriginalInstallMedia,
                SPOST_PATH,
                SP_COPY_SOURCE_ABSOLUTE|SP_COPY_NOSKIP|SP_COPY_NOBROWSE,
                NULL,
                0,
                NULL,
                NULL
                );

        if (!b) {
            PNP_DBGPRINT (( "SETUP: pFixSourceInfPath: SetupCopyOEMInf() failed. Error = 0%Xh \n", GetLastError() ));
            b = TRUE;
        }

    }
    __finally {
        if (Key) {
            RegCloseKey (Key);
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\asrclus.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    asrclus.c

Abstract:

    This module contains ASR routines specifically
    implemented for clusters.

Notes:

    Naming conventions:
        _AsrpXXX    private ASR Macros
        AsrpXXX     private ASR routines
        AsrXXX      Publically defined and documented routines

Author:

    Guhan Suriyanarayanan (guhans)  27-May-2000

Environment:

    User-mode only.

Revision History:

    27-May-2000 guhans
        Moved cluster-related routines from asr.c to asrclus.c

    01-Mar-2000 guhans
        Initial implementation for cluster-specific routines
        in asr.c

--*/
#include "setupp.h"
#pragma hdrstop

#include <mountmgr.h>   // mountmgr ioctls
#include <clusstor.h>   // Cluster API's
#include <resapi.h>     // Cluster ResUtilEnumResources

#define THIS_MODULE 'C'
#include "asrpriv.h"    // Private ASR definitions and routines

//
// --------
// typedef's local to this module
// --------
//

//
// The cluster resource related typdefs
//
typedef DWORD (* PFN_CLUSTER_RESOURCE_CONTROL) (
    IN HRESOURCE hResource,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD cbInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD lpcbBytesReturned
    );

typedef DWORD (* PFN_RES_UTIL_ENUM_RESOURCES) (
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    );


//
// ---------
// global variables used within this module.
// --------
//
PFN_CLUSTER_RESOURCE_CONTROL pfnClusterResourceControl;


//
// ---------
// constants used within this module.
// --------
//
const WCHAR ASR_CLUSTER_PHYSICAL_DISK[] = L"Physical Disk";
const WCHAR ASR_CLUSTER_CLUSAPI_DLL_NAME[] = L"clusapi.dll";
const WCHAR ASR_CLUSTER_RESUTILS_DLL_NAME[] = L"resutils.dll";

//
// The following must be single-byte ansi chars
//
const CHAR ASR_CLUSTER_DLL_MODULE_NAME[]    = "%SystemRoot%\\system32\\syssetup.dll";
const CHAR ASR_CLUSTER_DLL_PROC_NAME[]      = "AsrpGetLocalDiskInfo";
const CHAR ASR_CLUSTER_CLUSAPI_PROC_NAME[] = "ClusterResourceControl";
const CHAR ASR_CLUSTER_RESUTILS_PROC_NAME[] = "ResUtilEnumResources";


//
// --------
// function implementations
// --------
//


//
// --- AsrpGetLocalVolumeInfo and related helper functions
//

//
// The disk info struct we get back from the remote nodes on the cluster will have
// offsets instead of pointers--we can convert this back to pointers by just adding
// back the base address.  We also mark that this struct is packed--so we should just
// free the entire struct instead of freeing each pointer in the struct.
//
BOOL
AsrpUnPackDiskInfo(
    IN PVOID InBuffer
    )
{

    PASR_DISK_INFO pBuffer = (PASR_DISK_INFO) InBuffer;

/*    if (!((pBuffer->pDriveLayoutEx) && (pBuffer->pDiskGeometry) && (pBuffer->pPartition0Ex))) {
        return FALSE;
    }
*/

    pBuffer->IsPacked = TRUE;

    if (pBuffer->pDriveLayoutEx) {
        pBuffer->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) ((LPBYTE)pBuffer + PtrToUlong(pBuffer->pDriveLayoutEx));
    }

    if (pBuffer->pDiskGeometry) {
        pBuffer->pDiskGeometry = (PDISK_GEOMETRY) ((LPBYTE)pBuffer +  PtrToUlong((LPBYTE)pBuffer->pDiskGeometry));
    }

    if (pBuffer->pPartition0Ex) {
        pBuffer->pPartition0Ex = (PPARTITION_INFORMATION_EX) ((LPBYTE)pBuffer + PtrToUlong(pBuffer->pPartition0Ex));
    }

    if (pBuffer->PartitionInfoTable) {
        pBuffer->PartitionInfoTable = (PASR_PTN_INFO) ((LPBYTE)pBuffer + PtrToUlong(pBuffer->PartitionInfoTable));
    }

    if (pBuffer->pScsiAddress) {
        pBuffer->pScsiAddress = (PSCSI_ADDRESS) ((LPBYTE)pBuffer + PtrToUlong(pBuffer->pScsiAddress));
    }

    return TRUE;
}


//
// Copies the info in pLocalDisk to a flat buffer pointed to by lpOutBuffer.
// The pointers are changed to offsets from the start of the buffer.
//
DWORD
AsrpPackDiskInfo(
    IN  PASR_DISK_INFO pLocalDisk,
    OUT PVOID lpOutBuffer,
    IN  DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
{

    DWORD reqdSize = 0;
    PASR_DISK_INFO pBuffer = NULL;
    DWORD offset = 0;

    MYASSERT(pLocalDisk);

    //
    // Calculate required size
    //
    reqdSize = sizeof (ASR_DISK_INFO) +
        pLocalDisk->sizeDriveLayoutEx +
        pLocalDisk->sizeDiskGeometry +
        pLocalDisk->sizePartition0Ex +
        pLocalDisk->sizePartitionInfoTable;

    if (pLocalDisk->pScsiAddress) {
        reqdSize += sizeof(SCSI_ADDRESS);
    }

    if (lpBytesReturned) {
        *lpBytesReturned = reqdSize;
    }

    if (reqdSize > nOutBufferSize) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the ASR_DISK_INFO struct over to outBuffer
    //
    memcpy(lpOutBuffer, pLocalDisk, sizeof(ASR_DISK_INFO));
    pBuffer = (PASR_DISK_INFO) lpOutBuffer;
    offset = sizeof(ASR_DISK_INFO); // offset where the next struct will be copied

    //
    // Now, we go through the buffer and convert all pointers to offsets,
    // and copy over the structs they were pointing to.
    //

    //
    // First pointer:  PWSTR DevicePath;
    // Since the DevicePath makes sense only in the context of the local node,
    // we return NULL to the remote node.
    //
    pBuffer->DevicePath = NULL;

    //
    // Next pointer:  PDRIVE_LAYOUT_INFORMATION_EX pDriveLayoutEx;
    //
    if (pLocalDisk->pDriveLayoutEx) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->pDriveLayoutEx,
            pLocalDisk->sizeDriveLayoutEx
            );

        pBuffer->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) UlongToPtr(offset);
        offset += pLocalDisk->sizeDriveLayoutEx;
    }

    //
    // Next pointer:  PDISK_GEOMETRY pDiskGeometry;
    //
    if (pLocalDisk->pDiskGeometry) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->pDiskGeometry,
            pLocalDisk->sizeDiskGeometry
            );

        pBuffer->pDiskGeometry = (PDISK_GEOMETRY) UlongToPtr(offset);
        offset += pLocalDisk->sizeDiskGeometry;
    }

    //
    // Next pointer:  PPARTITION_INFORMATION_EX pPartition0Ex;
    //
    if (pLocalDisk->pPartition0Ex) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->pPartition0Ex,
            pLocalDisk->sizePartition0Ex
            );

        pBuffer->pPartition0Ex= (PPARTITION_INFORMATION_EX) UlongToPtr(offset);
        offset += pLocalDisk->sizePartition0Ex;
    }

    //
    // Next pointer:  PASR_PTN_INFO PartitionInfoTable;
    //
    if (pLocalDisk->PartitionInfoTable) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->PartitionInfoTable,
            pLocalDisk->sizePartitionInfoTable
            );

        pBuffer->PartitionInfoTable = (PASR_PTN_INFO) UlongToPtr(offset);
        offset += pLocalDisk->sizePartitionInfoTable;
    }

    //
    // Last pointer:  PSCSI_ADDRESS pScsiAddress;
    //
    if (pLocalDisk->pScsiAddress) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->pScsiAddress,
            sizeof(SCSI_ADDRESS)
            );

        pBuffer->pScsiAddress = (PSCSI_ADDRESS) UlongToPtr(offset);
        offset += sizeof(SCSI_ADDRESS);
    }

    MYASSERT(offset <= nOutBufferSize);

    return ERROR_SUCCESS;
}


DWORD
WINAPI
AsrpGetLocalDiskInfo(
    IN LPSTR lpszDeviceName,
    IN LPSTR lpszContextString,    // not used
    OUT PVOID lpOutBuffer,
    IN  DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
{
    PASR_DISK_INFO  pLocalDisk = NULL;
    HANDLE heapHandle = NULL;
    DWORD status = ERROR_SUCCESS;
    BOOL result = FALSE;
    ULONG MaxDeviceNumber = 0;
    DWORD cchReqdSize = 0;

    heapHandle = GetProcessHeap();

    //
    // Either the BytesReturned must be non-null (he's getting the required size),
    // or the lpOutBuffer must be non-null (he's getting the data).
    //
    _AsrpErrExitCode(!(lpOutBuffer || lpBytesReturned), status, ERROR_INVALID_PARAMETER);
    if (lpBytesReturned) {
        *lpBytesReturned = 0;
    }

    pLocalDisk = (PASR_DISK_INFO) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (ASR_DISK_INFO)
        );
    _AsrpErrExitCode(!pLocalDisk, status, ERROR_NOT_ENOUGH_MEMORY);

    cchReqdSize = MultiByteToWideChar(CP_ACP,
        0,
        lpszDeviceName,
        -1,
        NULL,
        0
        );

    pLocalDisk->DevicePath = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (cchReqdSize + 1) * (sizeof(WCHAR))
        );
    _AsrpErrExitCode(!(pLocalDisk->DevicePath), status, ERROR_NOT_ENOUGH_MEMORY);

    result = MultiByteToWideChar(CP_ACP,
        0,
        lpszDeviceName,
        -1,
        pLocalDisk->DevicePath,
        (cchReqdSize + 1)
        );
    _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);

    //
    // Get the disk layout information
    //
    result = AsrpInitLayoutInformation(NULL, pLocalDisk, &MaxDeviceNumber, TRUE);
    _AsrpErrExitCode(!result, status, GetLastError());
//    _AsrpErrExitCode(result && GetLastErr      what if createfile fails?

    result = AsrpFreeNonFixedMedia(&pLocalDisk);
    _AsrpErrExitCode(!result, status, GetLastError());
    _AsrpErrExitCode(!pLocalDisk, status, ERROR_SUCCESS);

    //
    // Copy it to the out buffer without any pointers
    //
    status = AsrpPackDiskInfo(pLocalDisk, lpOutBuffer, nOutBufferSize, lpBytesReturned);


EXIT:
    AsrpFreeStateInformation(&pLocalDisk, NULL);

    return status;
}


//
// ---- AsrpInitClusterSharedDisks and related helper functions
//

BOOL
AsrpIsClusteredDiskSame(
    IN PASR_DISK_INFO currentDisk,
    IN PASR_DISK_INFO clusterDisk
    )
{

    if (!clusterDisk || !currentDisk) {
        MYASSERT(0 && L"Invalid parameter, Disk is NULL");
        return FALSE;
    }

    if (currentDisk->Style != clusterDisk->Style) {
        return FALSE;
    }

    if (PARTITION_STYLE_MBR == clusterDisk->Style) { // currently always true
        if (clusterDisk->pDriveLayoutEx) {
            if (currentDisk->pDriveLayoutEx) {
                return (currentDisk->pDriveLayoutEx->Mbr.Signature == clusterDisk->pDriveLayoutEx->Mbr.Signature);
            }
            else {
                return (currentDisk->TempSignature == clusterDisk->pDriveLayoutEx->Mbr.Signature);
            }
        }
        else {
            MYASSERT(0 && L"Cluster disk drive layout is NULL");
            return FALSE;
        }

    }
    else {
        if (clusterDisk->pDriveLayoutEx && currentDisk->pDriveLayoutEx) {
            return (IsEqualGUID(&(currentDisk->pDriveLayoutEx->Gpt.DiskId), &(clusterDisk->pDriveLayoutEx->Gpt.DiskId)));
        }
        else {
            return FALSE;
        }
    }

    return FALSE;
}


DWORD
AsrpResourceCallBack(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    )
{
    DISK_DLL_EXTENSION_INFO inBuffer;

    PBYTE outBuffer = NULL;

    DWORD sizeOutBuffer = 0,
        bytesReturned = 0;

    DWORD status = ERROR_SUCCESS;

    PASR_DISK_INFO currentDisk = (PASR_DISK_INFO) lpParams,
        clusterDisk = NULL,
        prevDisk = NULL;

    HANDLE heapHandle = NULL;
    BOOL done = FALSE;

    if (!lpParams) {
        //
        // The system must have at least one disk that has been enumerated
        // already (the system disk, at least!), so our disk list shouldn't be NULL.
        //
        return ERROR_INVALID_PARAMETER;
    }

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    //
    // Allocate a reasonably-sized memory for the out buffer.  If this isn't
    // big enough, we'll re-allocate.
    //
    sizeOutBuffer = ASR_BUFFER_SIZE;
    outBuffer = (PBYTE) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeOutBuffer
        );
    _AsrpErrExitCode(!outBuffer, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Call AsrpGetLocalDiskInfo on the node owning this disk resource
    //
    ZeroMemory(&inBuffer, sizeof(inBuffer));
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy(inBuffer.DllModuleName, ASR_CLUSTER_DLL_MODULE_NAME);
    strcpy(inBuffer.DllProcName, ASR_CLUSTER_DLL_PROC_NAME);

    status = (pfnClusterResourceControl) (hResource,
        NULL,
        CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
        &inBuffer,
        sizeof(DISK_DLL_EXTENSION_INFO),
        (PVOID) outBuffer,
        sizeOutBuffer,
        &bytesReturned
        );

    if (ERROR_INSUFFICIENT_BUFFER == status) {
        //
        // The buffer wasn't big enough, re-allocate as needed
        //
        _AsrpHeapFree(outBuffer);

        sizeOutBuffer = bytesReturned;
        outBuffer = (PBYTE) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeOutBuffer
            );
        _AsrpErrExitCode(!outBuffer, status, ERROR_NOT_ENOUGH_MEMORY);

        status = (pfnClusterResourceControl) (
            hResource,
            NULL,
            CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
            &inBuffer,
            sizeof(DISK_DLL_EXTENSION_INFO),
            (PVOID) outBuffer,
            sizeOutBuffer,
            &bytesReturned
            );
    }
    _AsrpErrExitCode((ERROR_SUCCESS != status), status, status);

    //
    // outBuffer has a packed disk info struct (ie the pointers are offsets).
    //
    AsrpUnPackDiskInfo(outBuffer);

    clusterDisk = (PASR_DISK_INFO) outBuffer;
    clusterDisk->IsClusterShared = TRUE;
    clusterDisk->IsPacked = TRUE;       // so that we free this properly

    //
    // Check if clusterDisk already has info in our list (ie is owned
    // locally)
    //
    // Note that for now, clusterDisk is always MBR (since clusters don't
    // support shared GPT disks).  We don't care here, we handle GPT as well.
    //
    done = FALSE;
    prevDisk = NULL;
    while (currentDisk && !done) {

        if (AsrpIsClusteredDiskSame(currentDisk, clusterDisk)) {

            if (currentDisk->pDriveLayoutEx) {
                //
                // This disk is owned by the local node (correct?), since
                // we would not have gotten the pDriveLayout otherwise
                //
                currentDisk->IsClusterShared = TRUE;
                currentDisk->IsPacked = FALSE;

                //
                // We don't need the info returned by clusterDisk, we have
                // it in currentDisk already.
                //
                _AsrpHeapFree(clusterDisk); // it's packed.

            }
            else {
                //
                // This disk is owned by a remote node.  So we add clusterDisk
                // in to our list now.  We'll remove currentDisk from our
                // list later (in RemoveNonFixedDevices).
                //
                // First though, we copy over DevicePath and DeviceNumber
                // from currentDisk, since these are relative to the local
                // machine
                //
                if (currentDisk->DevicePath) {

                    clusterDisk->DevicePath = (PWSTR) HeapAlloc(
                        heapHandle,
                        HEAP_ZERO_MEMORY,
                        sizeof(WCHAR) * (wcslen(currentDisk->DevicePath) + 1)
                        );

                    wcscpy(clusterDisk->DevicePath, currentDisk->DevicePath);
                }

                clusterDisk->DeviceNumber = currentDisk->DeviceNumber;
                //
                // Don't bother freeing currentDisk, it'll get taken care
                // of in RemoveNonFixedDevices.
                //
                clusterDisk->pNext = currentDisk->pNext;
                currentDisk->pNext = clusterDisk;

                currentDisk = clusterDisk;  // move forward by one (don't really need to since done will be set to TRUE and we'll get out of the loop)
            }

            done = TRUE;
        }

        prevDisk = currentDisk;
        currentDisk = currentDisk->pNext;
    }


    if (!done) {
        //
        // This disk was not found in our list (strange), let's add
        // it in at the end
        //
//        MYASSERT(0 && L"Clustered disk not found in OriginalDiskList, adding it to the end");
        clusterDisk->pNext = NULL;
        prevDisk->pNext = clusterDisk;
    }


EXIT:
    //
    // Free up outBuffer on failure.  On success, outBuffer shouldn't
    // be freed, it will either be part of OriginalDiskList or already
    // be freed.
    //
    if (ERROR_SUCCESS != status) {
        _AsrpHeapFree(outBuffer);
    }

    return status;
}


BOOL
AsrpInitClusterSharedDisks(
    IN PASR_DISK_INFO OriginalDiskList
    )
{
    DWORD status = ERROR_SUCCESS,
        dwOldError;

    HMODULE hClusApi = NULL,
        hResUtils = NULL;

    PFN_RES_UTIL_ENUM_RESOURCES pfnResUtilEnumResources = NULL;

    dwOldError = GetLastError();

    if (!OriginalDiskList)  {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hClusApi = LoadLibraryW(ASR_CLUSTER_CLUSAPI_DLL_NAME);
    _AsrpErrExitCode(!hClusApi, status, GetLastError());

    pfnClusterResourceControl = (PFN_CLUSTER_RESOURCE_CONTROL) GetProcAddress(
        hClusApi,
        ASR_CLUSTER_CLUSAPI_PROC_NAME
        );
    _AsrpErrExitCode(!pfnClusterResourceControl, status, GetLastError());

    hResUtils = LoadLibraryW(ASR_CLUSTER_RESUTILS_DLL_NAME);
    _AsrpErrExitCode(!hResUtils, status, GetLastError());

    pfnResUtilEnumResources = (PFN_RES_UTIL_ENUM_RESOURCES) GetProcAddress(
        hResUtils,
        ASR_CLUSTER_RESUTILS_PROC_NAME
        );
    _AsrpErrExitCode(!pfnResUtilEnumResources, status, GetLastError());

    status = (pfnResUtilEnumResources) (NULL,
        ASR_CLUSTER_PHYSICAL_DISK,
        AsrpResourceCallBack,
        OriginalDiskList
        );

EXIT:
    if (hClusApi) {
        FreeLibrary(hClusApi);
    }

    if (hResUtils) {
        FreeLibrary(hResUtils);
    }

    // ResUtil will fail if we aren't on a cluster, but that's fine.
    SetLastError(dwOldError);
    return TRUE;
}


//
// --- AsrpGetLocalVolumeInfo and related helper functions
//

//
// The following two definitions are from asr_fmt:dr_state.cpp.  This MUST be
// kept in sync.
//
typedef struct _ASRFMT_CLUSTER_VOLUME_INFO {

    UINT driveType;

    DWORD PartitionNumber;

    ULONG FsNameOffset;
    USHORT FsNameLength;

    ULONG LabelOffset;
    USHORT LabelLength;

    ULONG SymbolicNamesOffset;
    USHORT SymbolicNamesLength;

    DWORD dwClusterSize;

} ASRFMT_CLUSTER_VOLUME_INFO, *PASRFMT_CLUSTER_VOLUME_INFO;


typedef struct _ASRFMT_CLUSTER_VOLUMES_TABLE {

    DWORD DiskSignature;

    DWORD NumberOfEntries;

    ASRFMT_CLUSTER_VOLUME_INFO VolumeInfoEntry[1];

} ASRFMT_CLUSTER_VOLUMES_TABLE, *PASRFMT_CLUSTER_VOLUMES_TABLE;


BOOL
AsrpFmtGetVolumeDetails(
    IN  PWSTR lpVolumeGuid,
    OUT PWSTR lpFsName,
    IN  DWORD cchFsName,
    OUT PWSTR lpVolumeLabel,
    IN  DWORD cchVolumeLabel,
    OUT LPDWORD lpClusterSize
    )
{
    DWORD dwFSFlags = 0,
        dwSectorsPerCluster = 0,
        dwBytesPerSector = 0,
        dwNumFreeClusters = 0,
        dwTotalNumClusters = 0;

    BOOL result1 = TRUE,
        result2 = TRUE;

    *lpFsName = 0;
    *lpVolumeLabel = 0;
    *lpClusterSize = 0;

    SetErrorMode(SEM_FAILCRITICALERRORS);

    result1 = GetVolumeInformationW(lpVolumeGuid,
        lpVolumeLabel,
        cchVolumeLabel,
        NULL,   // no need for serial number
        NULL,   // max file name length
        &dwFSFlags, // !! we might need to store some of this ...
        lpFsName,
        cchFsName
        );

    result2 = GetDiskFreeSpaceW(lpVolumeGuid,
        &dwSectorsPerCluster,
        &dwBytesPerSector,
        &dwNumFreeClusters,
        &dwTotalNumClusters
        );

    *lpClusterSize = dwSectorsPerCluster * dwBytesPerSector;

    return (result1 && result2);
}


DWORD
WINAPI
AsrpGetLocalVolumeInfo(
    IN LPSTR lpszDeviceName,
    IN LPSTR lpszContextString,    // not used
    OUT PVOID lpOutBuffer,
    IN  DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
{
    PASR_DISK_INFO  pLocalDisk = NULL;
    HANDLE heapHandle = NULL;
    DWORD status = ERROR_SUCCESS;
    BOOL result = FALSE;
    ULONG MaxDeviceNumber = 0;
    DWORD cchReqdSize = 0,
        cchGuid = 0,
        offset = 0,
        index = 0,
        i = 0;

    USHORT
        cbFsName = 0,
        cbLabel = 0,
        cbLinks = 0;

    PMOUNTMGR_MOUNT_POINTS mountPointsOut = NULL;

    WCHAR devicePath[MAX_PATH + 1];
    WCHAR volumeGuid[MAX_PATH + 1];
    WCHAR fileSystemName[MAX_PATH + 1];
    WCHAR volumeLabel[MAX_PATH + 1];
    UINT driveType = DRIVE_UNKNOWN;
    DWORD clusterSize = 0;

    BOOL bufferFull = FALSE,
        foundGuid = FALSE;

    PPARTITION_INFORMATION_EX  currentPartitionEx = NULL;
    PASRFMT_CLUSTER_VOLUMES_TABLE pTable = NULL;

    heapHandle = GetProcessHeap();

    //
    // Either the BytesReturned must be non-null (he's getting the required size),
    // or the lpOutBuffer must be non-null (he's getting the data).
    //
    _AsrpErrExitCode(!(lpOutBuffer || lpBytesReturned), status, ERROR_INVALID_PARAMETER);
    if (lpBytesReturned) {
        *lpBytesReturned = 0;
    }

    //
    // Zero the out buffer
    //
    if ((lpOutBuffer) && (nOutBufferSize > 0)) {
        ZeroMemory(lpOutBuffer, nOutBufferSize);
    }

    pLocalDisk = (PASR_DISK_INFO) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (ASR_DISK_INFO)
        );
    _AsrpErrExitCode(!pLocalDisk, status, ERROR_NOT_ENOUGH_MEMORY);

    cchReqdSize = MultiByteToWideChar(CP_ACP,
        0,
        lpszDeviceName,
        -1,
        NULL,
        0
        );

    pLocalDisk->DevicePath = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (cchReqdSize + 1) * (sizeof(WCHAR))
        );
    _AsrpErrExitCode(!(pLocalDisk->DevicePath), status, ERROR_NOT_ENOUGH_MEMORY);

    result = MultiByteToWideChar(CP_ACP,
        0,
        lpszDeviceName,
        -1,
        pLocalDisk->DevicePath,
        (cchReqdSize + 1)
        );
    _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);

    //
    // Get the disk layout information
    //
    result = AsrpInitLayoutInformation(NULL, pLocalDisk, &MaxDeviceNumber, FALSE); // basic info will suffice
    _AsrpErrExitCode(!result, status, GetLastError());
    _AsrpErrExitCode(!(pLocalDisk->pDriveLayoutEx), status, ERROR_SUCCESS);

    //
    //
    //
    offset = sizeof(ASRFMT_CLUSTER_VOLUMES_TABLE) +
        (sizeof(ASRFMT_CLUSTER_VOLUME_INFO) * (pLocalDisk->pDriveLayoutEx->PartitionCount - 1));
    pTable = (PASRFMT_CLUSTER_VOLUMES_TABLE) lpOutBuffer;

    if ((!lpOutBuffer) || (offset > nOutBufferSize)) {
        bufferFull = TRUE;
    }

    if (!bufferFull) {

        if (PARTITION_STYLE_MBR == pLocalDisk->pDriveLayoutEx->PartitionStyle) {
            pTable->DiskSignature = pLocalDisk->pDriveLayoutEx->Mbr.Signature;
        }
        else {
            //
            // At the moment, only MBR disks are cluster shared disks, and so
            // we don't handle GPT disks here.  If GPT disks are allowed to
            // be on a shared bus in a cluster, change this.
            //
            _AsrpErrExitCode(FALSE, status, ERROR_SUCCESS);
        }

        pTable->NumberOfEntries = pLocalDisk->pDriveLayoutEx->PartitionCount;
    }


    for (index = 0; index < pLocalDisk->pDriveLayoutEx->PartitionCount; index++) {

        currentPartitionEx = &(pLocalDisk->pDriveLayoutEx->PartitionEntry[index]);
        mountPointsOut = NULL;
        foundGuid = FALSE;

        //
        // For each partition, AsrpGetMountPoints gives a list of all mount points,
        // then use that to AsrpFmtGetVolumeDetails
        //

        // get the volumeGuid

        if (!(currentPartitionEx->PartitionNumber)) {
            //
            // Container partitions have partitionNumber = 0, and have no volume Guids.
            //
            continue;
        }

        memset(volumeGuid, 0, (MAX_PATH + 1) * sizeof(WCHAR));
        swprintf(devicePath,
            ASR_WSZ_DEVICE_PATH_FORMAT,
            pLocalDisk->DeviceNumber,
            currentPartitionEx->PartitionNumber
            );

        result = AsrpGetMountPoints(
            devicePath,
            (wcslen(devicePath) + 1)* sizeof(WCHAR),    // including \0, in bytes
            &mountPointsOut
            );
        if (!result || !(mountPointsOut)) {
            continue;
        }

        //
        // Go through the list of mount points, and pick out one that
        // looks like a volume Guid (starts with \??\Volume)
        //
        cbLinks = sizeof(WCHAR);  // \0 at the end
        for (i = 0; i < mountPointsOut->NumberOfMountPoints; i++) {

            PWSTR linkName = (PWSTR) (
                ((LPBYTE) mountPointsOut) +
                mountPointsOut->MountPoints[i].SymbolicLinkNameOffset
                );

            USHORT sizeLinkName = (UINT) (mountPointsOut->MountPoints[i].SymbolicLinkNameLength);

            if (!wcsncmp(ASR_WSZ_VOLUME_PREFIX, linkName, wcslen(ASR_WSZ_VOLUME_PREFIX)) &&
                !foundGuid) {
                wcsncpy(volumeGuid, linkName, sizeLinkName / sizeof(WCHAR));
                foundGuid = TRUE;
            }

            cbLinks += sizeLinkName + (USHORT) sizeof(WCHAR);
        }

        //
        // GetDriveType needs the volume guid in the dos-name-space, while the
        // mount manager gives the volume guid in the nt-name-space.  Convert
        // the name by changing the \??\ at the beginning to \\?\, and adding
        // a back-slash at the end.
        //
        cchGuid = wcslen(volumeGuid);
        volumeGuid[1] = L'\\';
        volumeGuid[cchGuid] = L'\\';    // Trailing back-slash
        volumeGuid[cchGuid+1] = L'\0';

        driveType = GetDriveTypeW(volumeGuid);
        //
        // Get the FS Label, cluster size, and so on.
        //
        result = AsrpFmtGetVolumeDetails(volumeGuid,
            fileSystemName,
            MAX_PATH + 1,
            volumeLabel,
            MAX_PATH + 1,
            &clusterSize
            );
        if (!result) {
            continue;
        }

        cbFsName = wcslen(fileSystemName) * sizeof(WCHAR);
        cbLabel = wcslen(volumeLabel) * sizeof(WCHAR);

        if (bufferFull) {
            offset += (cbFsName + cbLabel + cbLinks);
        }
        else {
            if (offset + cbFsName + cbLabel + cbLinks > nOutBufferSize) {
                bufferFull = TRUE;
            }
            else {

                if (cbFsName) {
                    CopyMemory(((LPBYTE)lpOutBuffer + offset),
                        fileSystemName,
                        cbFsName
                        );
                    pTable->VolumeInfoEntry[index].FsNameOffset = offset;
                    pTable->VolumeInfoEntry[index].FsNameLength = cbFsName;
                    offset += cbFsName;
                }

                if (cbLabel) {
                    CopyMemory(((LPBYTE)lpOutBuffer + offset),
                        volumeLabel,
                        cbLabel
                        );
                    pTable->VolumeInfoEntry[index].LabelOffset = offset;
                    pTable->VolumeInfoEntry[index].LabelLength = cbLabel;
                    offset += cbLabel;
                }

                //
                // Copy the symbolic links, separated by zeroes
                //
                if (mountPointsOut->NumberOfMountPoints > 0) {
                    pTable->VolumeInfoEntry[index].SymbolicNamesOffset = offset;
                }

                for (i = 0; i < mountPointsOut->NumberOfMountPoints; i++) {

                    PWSTR linkName = (PWSTR) (
                        ((LPBYTE) mountPointsOut) +
                        mountPointsOut->MountPoints[i].SymbolicLinkNameOffset
                        );

                    UINT sizeLinkName = (UINT) (mountPointsOut->MountPoints[i].SymbolicLinkNameLength);

                    CopyMemory(((LPBYTE)lpOutBuffer + offset),
                        linkName,
                        sizeLinkName
                        );
                    offset += (sizeLinkName + sizeof(WCHAR));
                }

                offset += sizeof(WCHAR);   // second \0 at the end
                pTable->VolumeInfoEntry[index].SymbolicNamesLength = cbLinks;

                pTable->VolumeInfoEntry[index].driveType = driveType;
                pTable->VolumeInfoEntry[index].PartitionNumber = currentPartitionEx->PartitionNumber;
                pTable->VolumeInfoEntry[index].dwClusterSize = clusterSize;
            }
        }

        _AsrpHeapFree(mountPointsOut);

    }

    if (lpBytesReturned) {
        *lpBytesReturned = offset;
    }

EXIT:
    AsrpFreeStateInformation(&pLocalDisk, NULL);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\asrrest.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    asrrest.c

Abstract:

    This module contains the following ASR routine:
        AsrRestoreNonCriticalDisks{A|W}

    This routine is called in GUI mode ASR, to reconfigure
    the non-critical storage devices on the target machine.

Notes:

    Naming conventions:
        _AsrpXXX    private ASR Macros
        AsrpXXX     private ASR routines
        AsrXXX      Publically defined and documented routines

Author:

    Guhan Suriyanarayanan (guhans)  27-May-2000

Environment:

    User-mode only.

Revision History:
    
    27-May-2000 guhans  
        Moved AsrRestoreNonCriticalDisks and other restore-time 
        routines from asr.c to asrrest.c

    01-Jan-2000 guhans
        Initial implementation for AsrRestoreNonCriticalDisks
        in asr.c

--*/
#include "setupp.h"
#pragma hdrstop


#include <diskguid.h>   // GPT partition type guids
#include <mountmgr.h>   // mountmgr ioctls
#include <winasr.h>     // ASR public routines

#define THIS_MODULE 'R'
#include "asrpriv.h"    // Private ASR definitions and routines


//
// --------
// typedefs and constants used within this module
// --------
//
typedef enum _ASR_SORT_ORDER {
    SortByLength,
    SortByStartingOffset
} ASR_SORT_ORDER;


typedef struct _ASR_REGION_INFO {

    struct _ASR_REGION_INFO *pNext;
    
    LONGLONG    StartingOffset;
    LONGLONG    RegionLength;
    DWORD       Index;

} ASR_REGION_INFO, *PASR_REGION_INFO;

#define ASR_AUTO_EXTEND_MAX_FREE_SPACE_IGNORED (1024 * 1024 * 16)


//
// --------
// function implementations
// --------
//

LONGLONG
AsrpRoundUp(
    IN CONST LONGLONG Number,
    IN CONST LONGLONG Base
    )

/*++

Routine Description:

    Helper function to round-up a number to a multiple of a given base.

Arguments:

    Number - The number to be rounded up.

    Base - The base using which Number is to be rounded-up.

Return Value:

    The first multiple of Base that is greater than or equal to Number.

--*/

{
    if (Number % Base) {
        return (Number + Base - (Number % Base));
    }
    else {
        return Number;        // already a multiple of Base.
    }
}


VOID
AsrpCreatePartitionTable(
    IN OUT PDRIVE_LAYOUT_INFORMATION_EX pDriveLayoutEx,
    IN PASR_PTN_INFO_LIST pPtnInfoList,
    IN DWORD BytesPerSector
    )

/*++

Routine Description:

    This creates a partition table based on the partition information 
    (pPtnInfoList) passed in 

Arguments:

          // needed to convert between sector count and byte offset

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    DWORD index = 0,
        NumEntries = 0;

    PPARTITION_INFORMATION_EX currentPtn = NULL;
    PASR_PTN_INFO               pPtnInfo = NULL;

    MYASSERT(pDriveLayoutEx);
    if (!pDriveLayoutEx || !pPtnInfoList || !(pPtnInfoList->pOffsetHead)) {
        return;
    }

    if (PARTITION_STYLE_GPT == pDriveLayoutEx->PartitionStyle) {
        NumEntries = pDriveLayoutEx->Gpt.MaxPartitionCount;
    }
    else if (PARTITION_STYLE_MBR == pDriveLayoutEx->PartitionStyle) {
        NumEntries = pDriveLayoutEx->PartitionCount;
    }
    else {
        MYASSERT(0 && L"Unrecognised partitioning style (neither MBR nor GPT)");
        return;
    }

    //
    // Zero out the entire partition table first
    //
    for (index = 0; index < NumEntries; index++) {

        currentPtn = &(pDriveLayoutEx->PartitionEntry[index]);

        currentPtn->StartingOffset.QuadPart = 0;
        currentPtn->PartitionLength.QuadPart = 0;

    }

    //
    // Now go through each of the partitions in the list, and add their entry
    // to the partition table (at index = SlotIndex)
    //
    pPtnInfo = pPtnInfoList->pOffsetHead;

    while (pPtnInfo) {

        //
        // For GPT partitions, SlotIndex is 0-based without holes
        //
        currentPtn = &(pDriveLayoutEx->PartitionEntry[pPtnInfo->SlotIndex]);

        MYASSERT(0 == currentPtn->StartingOffset.QuadPart);        // this entry better be empty

        //
        // Convert the StartSector and SectorCount to BYTE-Offset and BYTE-Count ...
        //
        pPtnInfo->PartitionInfo.StartingOffset.QuadPart *= BytesPerSector;
        pPtnInfo->PartitionInfo.PartitionLength.QuadPart *= BytesPerSector;

        //
        // Copy the partition-information struct over
        //
        memcpy(currentPtn, &(pPtnInfo->PartitionInfo), sizeof(PARTITION_INFORMATION_EX));

        currentPtn->RewritePartition = TRUE;
        currentPtn->PartitionStyle = pDriveLayoutEx->PartitionStyle;

        pPtnInfo = pPtnInfo->pOffsetNext;
    }
}


//
//
//
ULONG64
AsrpStringToULong64(
    IN PWSTR String
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    ULONG64 result = 0, base = 10;
    BOOL negative = FALSE, done = FALSE;

    if (!String) {
        return 0;
    }

    if (L'-' == *String) {  // But this is ULONG!
        negative = TRUE;
        String++;
    }

    if (L'0' == *String &&
        (L'x' ==  *(String + 1) || L'X' == *(String + 1))
        ) {
        // Hex
        base = 16;
        String += 2;
    }

    while (!done) {
        done = TRUE;

        if (L'0' <= *String && L'9' >= *String) {
            result = result*base + (*String - L'0');
            String++;
            done = FALSE;
        }
        else if (16==base) {
            if (L'a' <= *String && L'f' >= *String) {
                result = result*base + (*String - L'a') + 10;
                String++;
                done = FALSE;

            }
            else if (L'A' <= *String && L'F' >= *String) {
                result = result*base + (*String - L'A') + 10;
                String++;
                done = FALSE;
            }
        }
    }

    if (negative) {
        result = 0 - result;
    }

    return result;
}


LONGLONG
AsrpStringToLongLong(
    IN PWSTR String
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    LONGLONG result = 0, base = 10;
    BOOL negative = FALSE, done = FALSE;

    if (!String) {
        return 0;
    }

    if (L'-' == *String) {
        negative = TRUE;
        String++;
    }

    if (L'0' == *String &&
        (L'x' ==  *(String + 1) || L'X' == *(String + 1))
        ) {
        // Hex
        base = 16;
        String += 2;
    }

    while (!done) {
        done = TRUE;

        if (L'0' <= *String && L'9' >= *String) {
            result = result*base + (*String - L'0');
            String++;
            done = FALSE;
        }
        else if (16==base) {
            if (L'a' <= *String && L'f' >= *String) {
                result = result*base + (*String - L'a') + 10;
                String++;
                done = FALSE;

            }
            else if (L'A' <= *String && L'F' >= *String) {
                result = result*base + (*String - L'A') + 10;
                String++;
                done = FALSE;
            }
        }
    }

    if (negative) {
        result = 0 - result;
    }

    return result;
}


DWORD
AsrpStringToDword(
    IN PWSTR String
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    DWORD result = 0, base = 10;
    BOOL negative = FALSE, done = FALSE;
    if (!String) {
        return 0;
    }
    if (L'-' == *String) {  // but this is unsigned!
        negative = TRUE;
        String++;
    }
    if (L'0' == *String &&
        (L'x' ==  *(String + 1) || L'X' == *(String + 1))
        ) {
        // Hex
        base = 16;
        String += 2;
    }
    while (!done) {
        done = TRUE;

        if (L'0' <= *String && L'9' >= *String) {
            result = result*base + (*String - L'0');
            String++;
            done = FALSE;
        }
        else if (16==base) {
            if (L'a' <= *String && L'f' >= *String) {
                result = result*base + (*String - L'a') + 10;
                String++;
                done = FALSE;

            }
            else if (L'A' <= *String && L'F' >= *String) {
                result = result*base + (*String - L'A') + 10;
                String++;
                done = FALSE;
            }
        }
    }
    if (negative) {
        result = 0 - result;
    }
    return result;
}


ULONG
AsrpStringToULong(
    IN PWSTR String
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    ULONG result = 0, base = 10;
    BOOL negative = FALSE, done = FALSE;
    if (!String) {
        return 0;
    }
    if (L'-' == *String) {  // but this is unsigned!
        negative = TRUE;
        String++;
    }
    if (L'0' == *String &&
        (L'x' ==  *(String + 1) || L'X' == *(String + 1))
        ) {
        // Hex
        base = 16;
        String += 2;
    }
    while (!done) {
        done = TRUE;

        if (L'0' <= *String && L'9' >= *String) {
            result = result*base + (*String - L'0');
            String++;
            done = FALSE;
        }
        else if (16==base) {
            if (L'a' <= *String && L'f' >= *String) {
                result = result*base + (*String - L'a') + 10;
                String++;
                done = FALSE;

            }
            else if (L'A' <= *String && L'F' >= *String) {
                result = result*base + (*String - L'A') + 10;
                String++;
                done = FALSE;
            }
        }
    }
    if (negative) {
        result = 0 - result;
    }
    return result;
}


VOID
AsrpInsertSortedPartitionLengthOrder(
    IN PASR_PTN_INFO_LIST pPtnInfoList,
    IN PASR_PTN_INFO    pPtnInfo
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    PASR_PTN_INFO pPreviousPtn = NULL,
        pCurrentPtn = NULL;


    //
    // Insert this in the sorted PartitionLength order ...
    //
    pCurrentPtn = pPtnInfoList->pLengthHead;
    if (!pCurrentPtn) {
        //
        // First item in the list
        //
        pPtnInfoList->pLengthHead = pPtnInfo;
        pPtnInfoList->pLengthTail = pPtnInfo;
    }
    else {

        while (pCurrentPtn) {

             if (pCurrentPtn->PartitionInfo.PartitionLength.QuadPart
                <= pPtnInfo->PartitionInfo.PartitionLength.QuadPart) {

                pPreviousPtn = pCurrentPtn;
                pCurrentPtn = pCurrentPtn->pLengthNext;
            }

            else {
                //
                // We found the spot, let's add it in.
                //
                if (!pPreviousPtn) {
                    //
                    // This is the first node
                    //
                    pPtnInfoList->pLengthHead = pPtnInfo;
                }
                else {
                    pPreviousPtn->pLengthNext = pPtnInfo;
                }
                pPtnInfo->pLengthNext = pCurrentPtn;
                break;
            }

        }

        if (!pCurrentPtn) {
            //
            // We reached the end and didn't add this node in.
            //
            MYASSERT(pPtnInfoList->pLengthTail == pPreviousPtn);
            pPtnInfoList->pLengthTail = pPtnInfo;
            pPreviousPtn->pLengthNext = pPtnInfo;
        }
    }
}


VOID
AsrpInsertSortedPartitionStartOrder(
    IN PASR_PTN_INFO_LIST pPtnInfoList,
    IN PASR_PTN_INFO    pPtnInfo
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    None
   
--*/

{

    PASR_PTN_INFO pPreviousPtn = NULL,
        pCurrentPtn = NULL;


    //
    // Insert this in the sorted Start-Sector order ...
    //
    pCurrentPtn = pPtnInfoList->pOffsetHead;
    if (!pCurrentPtn) {
        //
        // First item in the list
        //
        pPtnInfoList->pOffsetHead = pPtnInfo;
        pPtnInfoList->pOffsetTail = pPtnInfo;
    }
    else {

        while (pCurrentPtn) {

             if (pCurrentPtn->PartitionInfo.StartingOffset.QuadPart
                <= pPtnInfo->PartitionInfo.StartingOffset.QuadPart) {

                pPreviousPtn = pCurrentPtn;
                pCurrentPtn = pCurrentPtn->pOffsetNext;
            }

            else {
                //
                // We found the spot, let's add it in.
                //
                if (!pPreviousPtn) {
                    //
                    // This is the first node
                    //
                    pPtnInfoList->pOffsetHead = pPtnInfo;
                }
                else {
                    pPreviousPtn->pOffsetNext = pPtnInfo;
                }
                pPtnInfo->pOffsetNext = pCurrentPtn;
                break;
            }

        }

        if (!pCurrentPtn) {
            //
            // We reached the end and didn't add this node in.
            //
            MYASSERT(pPtnInfoList->pOffsetTail == pPreviousPtn);
            pPtnInfoList->pOffsetTail = pPtnInfo;
            pPreviousPtn->pOffsetNext = pPtnInfo;
        }
    }
}


//
// Build the original MBR disk info from the sif file
//
BOOL
AsrpBuildMbrSifDiskList(
    IN  PCWSTR              sifPath,
    OUT PASR_DISK_INFO      *ppSifDiskList,
    OUT PASR_PTN_INFO_LIST  *ppSifMbrPtnList,
    OUT BOOL                *lpAutoExtend
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    HINF hSif = NULL;
    
    INFCONTEXT infSystemContext,
        infDiskContext,
        infBusContext,
        infPtnContext;

    BOOL result = FALSE;

    DWORD reqdSize = 0,
        diskCount = 0,
        status = ERROR_SUCCESS;

    INT tempInt = 0;

    UINT errorLine = 0;

    PASR_DISK_INFO pNewSifDisk = NULL,
        currentDisk = NULL;
    
    PASR_PTN_INFO_LIST pMbrPtnList = NULL;
    
    PASR_PTN_INFO pPtnInfo = NULL;
    
    HANDLE  heapHandle = GetProcessHeap();

    WCHAR tempBuffer[ASR_SIF_ENTRY_MAX_CHARS + 1];

    ZeroMemory(&infSystemContext, sizeof(INFCONTEXT));
    ZeroMemory(&infDiskContext, sizeof(INFCONTEXT));
    ZeroMemory(&infBusContext, sizeof(INFCONTEXT));
    ZeroMemory(&infPtnContext, sizeof(INFCONTEXT));
    ZeroMemory(tempBuffer, sizeof(WCHAR)*(ASR_SIF_ENTRY_MAX_CHARS+1));

    //    *ppSifDiskList = NULL;

    //
    // Open the sif
    //
    hSif = SetupOpenInfFileW(sifPath, NULL, INF_STYLE_WIN4, &errorLine);
    if (NULL == hSif || INVALID_HANDLE_VALUE == hSif) {

        AsrpPrintDbgMsg(_asrerror, 
            "The ASR state file \"%ws\" could not be opened.  Error:%lu.  Line: %lu.\r\n",
            sifPath,
            GetLastError(), 
            errorLine
            );
        
        return FALSE;       // sif file couldn't be opened
    }

    *lpAutoExtend = TRUE; // enable by default
    //
    // Get the AutoExtend value
    //
    result = SetupFindFirstLineW(hSif, ASR_SIF_SYSTEM_SECTION, NULL, &infSystemContext);
    if (!result) {

        AsrpPrintDbgMsg(_asrerror, 
            "The ASR state file \"%ws\" is corrupt (section %ws not be found).\r\n",
            sifPath,
            ASR_SIF_SYSTEM_SECTION
            );
        
        return FALSE;        // no system section
    }
    result = SetupGetIntField(&infSystemContext, 5, (PINT) (lpAutoExtend));
    if (!result) {
        *lpAutoExtend = TRUE;        // TRUE by default
    }

    result = SetupFindFirstLineW(hSif, ASR_SIF_MBR_DISKS_SECTION, NULL, &infDiskContext);
    if (!result) {

        AsrpPrintDbgMsg(_asrinfo, 
            "Section [%ws] is empty.  Assuming no MBR disks.\r\n", 
            ASR_SIF_MBR_DISKS_SECTION
            );

        return TRUE;        // no mbr disks section
    }

    //
    // First, we go through the [DISKS.MBR] section.  At the end of this loop,
    // we'll have a list of all MBR sif-disks.  (*ppSifDiskList will point to
    // a linked list of ASR_DISK_INFO's, one for each disk).
    //
    do {
        ++diskCount;
        //
        // Create a new sif disk for this entry
        //
        pNewSifDisk = (PASR_DISK_INFO) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_DISK_INFO)
            );
        _AsrpErrExitCode(!pNewSifDisk, status, ERROR_NOT_ENOUGH_MEMORY);

        pNewSifDisk->pNext = *ppSifDiskList;
        *ppSifDiskList = pNewSifDisk;

        //
        // Now fill in the fields in the struct.  Since we zeroed the struct while
        // allocating mem, all pointers in the struct are NULL by default, and
        // all flags in the struct are FALSE.
        //
        pNewSifDisk->pDiskGeometry = (PDISK_GEOMETRY) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(DISK_GEOMETRY)
            );
        _AsrpErrExitCode(!pNewSifDisk->pDiskGeometry, status, ERROR_NOT_ENOUGH_MEMORY);

        pNewSifDisk->pPartition0Ex = (PPARTITION_INFORMATION_EX) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(PARTITION_INFORMATION_EX)
            );
        _AsrpErrExitCode(!pNewSifDisk->pPartition0Ex, status, ERROR_NOT_ENOUGH_MEMORY);

        // This is an MBR disk
        pNewSifDisk->Style = PARTITION_STYLE_MBR;

        //
        // Index 0 is the key to the left of the = sign
        //
        result = SetupGetIntField(&infDiskContext, 0, (PINT) &(pNewSifDisk->SifDiskKey));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        //
        // Index 1 is the system key, it must be 1.  We ignore it.
        // Index 2 - 6 are the bus key, critical flag, signature,
        //      bytes-per-sector, sector-count
        //
        result = SetupGetIntField(&infDiskContext, 2, (PINT) &(pNewSifDisk->SifBusKey));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infDiskContext, 3, (PINT) &(tempInt));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->IsCritical = (tempInt ? TRUE: FALSE);

        result = SetupGetStringFieldW(&infDiskContext, 4, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        
        pNewSifDisk->TempSignature = AsrpStringToDword(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 5, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        
        pNewSifDisk->pDiskGeometry->BytesPerSector = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 6, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->pDiskGeometry->SectorsPerTrack = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 7, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->pDiskGeometry->TracksPerCylinder = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 8, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->pPartition0Ex->PartitionLength.QuadPart = AsrpStringToLongLong(tempBuffer);

        // convert from sector count to byte count
        pNewSifDisk->pPartition0Ex->PartitionLength.QuadPart *= pNewSifDisk->pDiskGeometry->BytesPerSector;

        //
        // Get the bus-type related to this disk.  LineByIndex is 0 based, our bus key is 1-based.
        //
        result = SetupGetLineByIndexW(hSif, ASR_SIF_BUSES_SECTION, pNewSifDisk->SifBusKey - 1, &infBusContext);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infBusContext, 2, (PINT) &(pNewSifDisk->BusType));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupFindNextLine(&infDiskContext, &infDiskContext);

    } while (result);


    AsrpPrintDbgMsg(_asrinfo, 
        "Found %lu records in section [%ws].\r\n", 
        diskCount,
        ASR_SIF_MBR_DISKS_SECTION
        );

    //
    // Now, enumerate all the [PARTITIONS.MBR] section.  This will give us a list
    // of all the partitions (all) the MBR disks contained.
    //
    result = SetupFindFirstLineW(hSif, ASR_SIF_MBR_PARTITIONS_SECTION, NULL, &infPtnContext);
    if (result) {

        DWORD   diskKey = 0;
        //
        // Init the table of partion lists.
        //
        pMbrPtnList = (PASR_PTN_INFO_LIST) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_PTN_INFO_LIST) * (diskCount + 1)
            );
        _AsrpErrExitCode(!pMbrPtnList, status, ERROR_NOT_ENOUGH_MEMORY);

        // hack.
        // The 0'th entry of our table is not used, since the disk indices
        // begin with 1.  Since we have no other way of keeping track of
        // how big this table is (so that we can free it properly), we can
        // use the 0th entry to store this.
        //
        pMbrPtnList[0].numTotalPtns = diskCount + 1;       // size of table

        do {

            pPtnInfo = (PASR_PTN_INFO) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(ASR_PTN_INFO)
                );
            _AsrpErrExitCode(!pPtnInfo, status, ERROR_NOT_ENOUGH_MEMORY);

            //
            //  Read in the information.  The format of this section is:
            //
            //  [PARTITIONS.MBR]
            //  0.partition-key = 1.disk-key, 2.slot-index, 3.boot-sys-flag,
            //                  4."volume-guid", 5.active-flag, 6.partition-type,
            //                  7.file-system-type, 8.start-sector, 9.sector-count
            //
            result = SetupGetIntField(&infPtnContext, 1, &diskKey);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 2, (PINT) &(pPtnInfo->SlotIndex));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 3, (PINT) &(pPtnInfo->PartitionFlags));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetStringFieldW(&infPtnContext, 4, pPtnInfo->szVolumeGuid, ASR_CCH_MAX_VOLUME_GUID, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 5, (PINT) &tempInt);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            pPtnInfo->PartitionInfo.Mbr.BootIndicator = (tempInt ? TRUE: FALSE);

                // converting from int to uchar
            result = SetupGetIntField(&infPtnContext, 6, (PINT) &(pPtnInfo->PartitionInfo.Mbr.PartitionType));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 7, (PINT) &(pPtnInfo->FileSystemType));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            //
            // Note, we read in the start SECTOR and SECTOR count.  We'll convert these to
            // their byte values later (in AsrpCreatePartitionTable)
            //
            result = SetupGetStringFieldW(&infPtnContext, 8, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            pPtnInfo->PartitionInfo.StartingOffset.QuadPart = AsrpStringToLongLong(tempBuffer);

            result = SetupGetStringFieldW(&infPtnContext, 9, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            pPtnInfo->PartitionInfo.PartitionLength.QuadPart = AsrpStringToLongLong(tempBuffer);

            //
            // Add this in the sorted starting-offset order.
            //
            AsrpInsertSortedPartitionStartOrder(&(pMbrPtnList[diskKey]), pPtnInfo);

            //
            // Add this in the sorted partition length order as well.  This isn't really used for
            // MBR disks at present, only for GPT disks.
            //
            AsrpInsertSortedPartitionLengthOrder(&(pMbrPtnList[diskKey]), pPtnInfo);

            (pMbrPtnList[diskKey].numTotalPtns)++;

            if (IsContainerPartition(pPtnInfo->PartitionInfo.Mbr.PartitionType)) {
                (pMbrPtnList[diskKey].numExtendedPtns)++;
            }

            result = SetupFindNextLine(&infPtnContext, &infPtnContext);

        } while (result);

        //
        // Now, we have the table of all the MBR partition lists, and a list of
        // all MBR disks.  The next step is to "assign" the partitions to their respective
        // disks--and update the DriveLayoutEx struct for the disks.
        //
        currentDisk = *(ppSifDiskList);

        while (currentDisk) {
            DWORD           PartitionCount  = 0,
                            count           = 0;

            if (PARTITION_STYLE_MBR != currentDisk->Style) {
                currentDisk = currentDisk->pNext;
                continue;
            }

            PartitionCount = ((pMbrPtnList[currentDisk->SifDiskKey].numExtendedPtns) * 4) + 4;
            currentDisk->sizeDriveLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX)*(PartitionCount-1));

            currentDisk->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                currentDisk->sizeDriveLayoutEx
                );
            _AsrpErrExitCode(!currentDisk->pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

            //
            // Initialise the DriveLayout struct.
            //
            currentDisk->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_MBR;
            currentDisk->pDriveLayoutEx->PartitionCount = PartitionCount;
            currentDisk->pDriveLayoutEx->Mbr.Signature = currentDisk->TempSignature;

            AsrpCreatePartitionTable(currentDisk->pDriveLayoutEx,
                &(pMbrPtnList[currentDisk->SifDiskKey]),
                currentDisk->pDiskGeometry->BytesPerSector
                );

            currentDisk = currentDisk->pNext;
        }
    }
    else {

        DWORD count = 0;

        AsrpPrintDbgMsg(_asrinfo, 
            "Section [%ws] is empty.  Assuming MBR disks have no partitions.\r\n", 
            ASR_SIF_MBR_PARTITIONS_SECTION
            );

        //
        // The partitions section is empty.  Initialise each disk's drive layout
        // accordingly
        //
        currentDisk = *ppSifDiskList;

        while (currentDisk) {

            if (PARTITION_STYLE_MBR != currentDisk->Style) {
                currentDisk = currentDisk->pNext;
                continue;
            }

            currentDisk->sizeDriveLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX) * 3);
            currentDisk->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                currentDisk->sizeDriveLayoutEx
                );
            _AsrpErrExitCode(!currentDisk->pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

            currentDisk->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_MBR;
            currentDisk->pDriveLayoutEx->PartitionCount = 4;
            currentDisk->pDriveLayoutEx->Mbr.Signature = currentDisk->TempSignature;

            for (count = 0; count < currentDisk->pDriveLayoutEx->PartitionCount ; count++) {
                currentDisk->pDriveLayoutEx->PartitionEntry[count].PartitionStyle = PARTITION_STYLE_MBR;
                currentDisk->pDriveLayoutEx->PartitionEntry[count].RewritePartition = TRUE;

            }

            currentDisk = currentDisk->pNext;
        }
    }

EXIT:

    *ppSifMbrPtnList = pMbrPtnList;

    if ((hSif) && (INVALID_HANDLE_VALUE != hSif)) {
        SetupCloseInfFile(hSif);
        hSif = NULL;
    }

    return (BOOL) (ERROR_SUCCESS == status);
}


//
// Build the original disk info for GPT disks from the sif file
//
BOOL
AsrpBuildGptSifDiskList(
    IN  PCWSTR              sifPath,
    OUT PASR_DISK_INFO      *ppSifDiskList,
    OUT PASR_PTN_INFO_LIST  *ppSifGptPtnList
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    HINF hSif = NULL;

    BOOL result = FALSE;

    DWORD reqdSize = 0,
        diskCount = 0,
        status = ERROR_SUCCESS;

    INFCONTEXT infDiskContext,
        infBusContext,
        infPtnContext;

    INT tempInt = 0;

    UINT errorLine = 0;

    PASR_DISK_INFO pNewSifDisk = NULL,
        currentDisk = NULL;

    HANDLE heapHandle = NULL;

    PASR_PTN_INFO pPtnInfo = NULL;

    RPC_STATUS rpcStatus = RPC_S_OK;

    PASR_PTN_INFO_LIST pGptPtnList = NULL;

    WCHAR tempBuffer[ASR_SIF_ENTRY_MAX_CHARS+1];

    heapHandle = GetProcessHeap();

    ZeroMemory(&infDiskContext, sizeof(INFCONTEXT));
    ZeroMemory(&infBusContext, sizeof(INFCONTEXT));
    ZeroMemory(&infPtnContext, sizeof(INFCONTEXT));
    ZeroMemory(tempBuffer, sizeof(WCHAR)*(ASR_SIF_ENTRY_MAX_CHARS+1));

    //
    // Open the sif
    //
    hSif = SetupOpenInfFileW(sifPath, NULL, INF_STYLE_WIN4, &errorLine);
    if (NULL == hSif || INVALID_HANDLE_VALUE == hSif) {
        
        AsrpPrintDbgMsg(_asrerror, 
            "The ASR state file \"%ws\" could not be opened.  Error:%lu.  Line: %lu.\r\n",
            sifPath,
            GetLastError(), 
            errorLine
            );

        return FALSE;       // sif file couldn't be opened
    }

    result = SetupFindFirstLineW(hSif, ASR_SIF_GPT_DISKS_SECTION, NULL, &infDiskContext);
    if (!result) {

        AsrpPrintDbgMsg(_asrinfo, 
            "Section [%ws] is empty.  Assuming no GPT disks.\r\n", 
            ASR_SIF_GPT_DISKS_SECTION
            );

        return TRUE;        // no disks section
    }

    //
    // First, we go through the [DISKS.GPT] section.  At the end of this loop,
    // we'll have a list of all GPT sif-disks.  (*ppSifDiskList will point to
    // a linked list of ASR_DISK_INFO's, one for each disk).
    //
    do {

        ++diskCount;

        //
        // Create a new sif disk for this entry
        //
        pNewSifDisk = (PASR_DISK_INFO) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_DISK_INFO)
            );
        _AsrpErrExitCode(!pNewSifDisk, status, ERROR_NOT_ENOUGH_MEMORY);

        pNewSifDisk->pNext = *ppSifDiskList;
        *ppSifDiskList = pNewSifDisk;

        //
        // Now fill in the fields in the struct.  Since we zeroed the struct while
        // allocating mem, all pointers in the struct are NULL by default, and
        // all flags in the struct are FALSE.
        //
        pNewSifDisk->pDiskGeometry = (PDISK_GEOMETRY) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(DISK_GEOMETRY)
            );
        _AsrpErrExitCode(!pNewSifDisk->pDiskGeometry, status, ERROR_NOT_ENOUGH_MEMORY);

        pNewSifDisk->pPartition0Ex = (PPARTITION_INFORMATION_EX) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(PARTITION_INFORMATION_EX)
            );
        _AsrpErrExitCode(!pNewSifDisk->pPartition0Ex, status, ERROR_NOT_ENOUGH_MEMORY);

        // This is a GPT disk
        pNewSifDisk->Style = PARTITION_STYLE_GPT;

        //
        // Index 0 is the key to the left of the = sign
        //
        result = SetupGetIntField(&infDiskContext, 0, (PINT) &(pNewSifDisk->SifDiskKey));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        //
        // Index 1 is the system key, it must be 1.  We ignore it.
        // Index 2 - 7 are:
        //  2: bus key
        //  3: critical flag
        //  4: disk-guid
        //  5: max-partition-count
        //  6: bytes-per-sector
        //  7: sector-count
        //
        result = SetupGetIntField(&infDiskContext, 2, (PINT) &(pNewSifDisk->SifBusKey)); // BusKey
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infDiskContext, 3, (PINT) &(tempInt));                // IsCritical
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->IsCritical = (tempInt ? TRUE: FALSE);

        result = SetupGetStringFieldW(&infDiskContext, 4, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize); // DiskGuid
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infDiskContext, 5, (PINT) &(tempInt));    // MaxPartitionCount
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        //
        //  Allocate a drive layout struct, now that we know the max partition count
        //
        pNewSifDisk->sizeDriveLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX)*(tempInt-1));

        pNewSifDisk->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            pNewSifDisk->sizeDriveLayoutEx
            );
        _AsrpErrExitCode(!pNewSifDisk->pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

        // This is a GPT disk
        pNewSifDisk->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_GPT;

        //
        // Set the MaxPartitionCount and DiskGuid fields
        //
        pNewSifDisk->pDriveLayoutEx->Gpt.MaxPartitionCount = tempInt;
        rpcStatus = UuidFromStringW(tempBuffer, &(pNewSifDisk->pDriveLayoutEx->Gpt.DiskId));
        _AsrpErrExitCode((RPC_S_OK != rpcStatus), status, rpcStatus);


        result = SetupGetStringFieldW(&infDiskContext, 6, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->pDiskGeometry->BytesPerSector = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 7, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        pNewSifDisk->pDiskGeometry->SectorsPerTrack = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 8, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        pNewSifDisk->pDiskGeometry->TracksPerCylinder = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 9, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        pNewSifDisk->pPartition0Ex->PartitionLength.QuadPart = AsrpStringToLongLong(tempBuffer);

        // convert from sector count to byte count
        pNewSifDisk->pPartition0Ex->PartitionLength.QuadPart *= pNewSifDisk->pDiskGeometry->BytesPerSector; // TotalBytes

        //
        // Get the bus-type related to this disk.  LineByIndex is 0 based, our bus key is 1-based.
        //
        result = SetupGetLineByIndexW(hSif, ASR_SIF_BUSES_SECTION, pNewSifDisk->SifBusKey - 1, &infBusContext);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infBusContext, 2, (PINT) &(pNewSifDisk->BusType)); // bus type
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupFindNextLine(&infDiskContext, &infDiskContext);

    } while(result);

    AsrpPrintDbgMsg(_asrinfo, 
        "Found %lu records in section [%ws].\r\n", 
        diskCount,
        ASR_SIF_MBR_DISKS_SECTION
        );


    //
    // Now, enumerate all the [PARTITIONS.GPT] section.  This will give us a list
    // of all the partitions (all) the GPT disks contained.
    //
    result = SetupFindFirstLineW(hSif, ASR_SIF_GPT_PARTITIONS_SECTION, NULL, &infPtnContext);
    if (result) {
        DWORD   diskKey = 0;
        //
        // Init the table of partion lists.
        //
        pGptPtnList = (PASR_PTN_INFO_LIST) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_PTN_INFO_LIST) * (diskCount + 1)
            );
        _AsrpErrExitCode(!pGptPtnList, status, ERROR_NOT_ENOUGH_MEMORY);

        // hack.
        // The 0'th entry of our table is not used, since the disk indices
        // begin with 1.  Since we have no other way of keeping track of
        // how big this table is (so that we can free it properly), we can
        // use the 0th entry to store this.
        //
        pGptPtnList[0].numTotalPtns = diskCount + 1;       // size of table

        do {

            pPtnInfo = (PASR_PTN_INFO) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(ASR_PTN_INFO)
                );
            _AsrpErrExitCode(!pPtnInfo, status, ERROR_NOT_ENOUGH_MEMORY);
            //
            // This is a GPT partition
            //
            pPtnInfo->PartitionInfo.PartitionStyle = PARTITION_STYLE_GPT;

            //
            // Read in the values.  The format of this section is:
            //
            // [PARTITIONS.GPT]
            // 0.partition-key = 1.disk-key, 2.slot-index, 3.boot-sys-flag,
            //      4."volume-guid", 5."partition-type-guid", 6."partition-id-guid"
            //      7.gpt-attributes, 8."partition-name", 9.file-system-type,
            //      10.start-sector, 11.sector-count
            //
            result = SetupGetIntField(&infPtnContext, 1, &diskKey);  // 1. disk-key
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 2, (PINT) &(pPtnInfo->SlotIndex));     // 2. slot-index
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 3, (PINT) &(pPtnInfo->PartitionFlags));   // 3. boot-sys-flag
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetStringFieldW(&infPtnContext, 4, pPtnInfo->szVolumeGuid, ASR_CCH_MAX_VOLUME_GUID, &reqdSize); // volume-guid
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetStringFieldW(&infPtnContext, 5, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS + 1, &reqdSize);   // partition-type-guid
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            rpcStatus = UuidFromStringW(tempBuffer, &(pPtnInfo->PartitionInfo.Gpt.PartitionType));
            _AsrpErrExitCode((RPC_S_OK != rpcStatus), status, rpcStatus);

            result = SetupGetStringFieldW(&infPtnContext, 6, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS + 1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            rpcStatus = UuidFromStringW(tempBuffer, &(pPtnInfo->PartitionInfo.Gpt.PartitionId));
            _AsrpErrExitCode((RPC_S_OK != rpcStatus), status, rpcStatus);

            //
            // Note, we read in the start SECTOR and SECTOR count.  We'll convert these to
            // their byte values later (in AsrpCreatePartitionTable)
            //
            result = SetupGetStringFieldW(&infPtnContext, 7, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            pPtnInfo->PartitionInfo.Gpt.Attributes = AsrpStringToULong64(tempBuffer);

            result = SetupGetStringFieldW(&infPtnContext, 8,  pPtnInfo->PartitionInfo.Gpt.Name, 36, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 9, (PINT) &(pPtnInfo->FileSystemType));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            //
            // Note, we read in the start SECTOR and SECTOR count.  We'll convert it to the
            // BYTE offset and BYTE length later (in AsrpCreatePartitionTable)
            //
            result = SetupGetStringFieldW(&infPtnContext, 10, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
            pPtnInfo->PartitionInfo.StartingOffset.QuadPart = AsrpStringToLongLong(tempBuffer);

            result = SetupGetStringFieldW(&infPtnContext, 11, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
            pPtnInfo->PartitionInfo.PartitionLength.QuadPart = AsrpStringToLongLong(tempBuffer);

            //
            // Add this in the sorted partition starting-offset order.
            //
            AsrpInsertSortedPartitionStartOrder(&(pGptPtnList[diskKey]), pPtnInfo);

            //
            // Add this in the sorted partition length order as well.  This is useful
            // later when we try to fit in the partitions on the disk.
            //
            AsrpInsertSortedPartitionLengthOrder(&(pGptPtnList[diskKey]), pPtnInfo);

            (pGptPtnList[diskKey].numTotalPtns)++;

            result = SetupFindNextLine(&infPtnContext, &infPtnContext);

        } while (result);

        //
        // Now, we have the table of all the partition lists, and a list of
        // all disks.  The next task is to update the DriveLayoutEx struct for
        // the disks.
        //
        currentDisk = *(ppSifDiskList);

        while (currentDisk) {

            if (PARTITION_STYLE_GPT != currentDisk->Style) {
                currentDisk = currentDisk->pNext;
                continue;
            }
            //
            // Initialise the DriveLayoutEx struct.
            //
            currentDisk->pDriveLayoutEx->PartitionCount = pGptPtnList[currentDisk->SifDiskKey].numTotalPtns;

            AsrpCreatePartitionTable(currentDisk->pDriveLayoutEx,
                &(pGptPtnList[currentDisk->SifDiskKey]),
                currentDisk->pDiskGeometry->BytesPerSector
                );

            currentDisk = currentDisk->pNext;
        }
    }
    else {

        DWORD count = 0;

        AsrpPrintDbgMsg(_asrinfo, 
            "Section [%ws] is empty.  Assuming GPT disks have no partitions.\r\n", 
            ASR_SIF_GPT_PARTITIONS_SECTION
            );

        //
        // The partitions section is empty.  Initialise each disk's drive layout
        // accordingly
        //
        currentDisk = *ppSifDiskList;

        while (currentDisk) {

            if (PARTITION_STYLE_GPT != currentDisk->Style) {
                currentDisk = currentDisk->pNext;
                continue;
            }

            currentDisk->pDriveLayoutEx->PartitionCount = 0;

            for (count = 0; count < currentDisk->pDriveLayoutEx->Gpt.MaxPartitionCount ; count++) {
                currentDisk->pDriveLayoutEx->PartitionEntry[count].PartitionStyle = PARTITION_STYLE_GPT;
                currentDisk->pDriveLayoutEx->PartitionEntry[count].RewritePartition = TRUE;

            }
            currentDisk = currentDisk->pNext;
        }
    }

EXIT:

    *ppSifGptPtnList = pGptPtnList;

    if ((hSif) && (INVALID_HANDLE_VALUE != hSif)) {
        SetupCloseInfFile(hSif);
        hSif = NULL;
    }

    return (BOOL) (ERROR_SUCCESS == status);
}


//
// Returns
//  TRUE    if pSifDisk and pPhysicalDisk have the exact same partition layout,
//  FALSE   otherwise
//
BOOL
AsrpIsDiskIntact(
    IN PASR_DISK_INFO pSifDisk,
    IN PASR_DISK_INFO pPhysicalDisk
    ) 

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    ULONG index = 0,
        physicalIndex = 0;
    PPARTITION_INFORMATION_EX pSifPtnEx = NULL,
        pPhysicalPtnEx = NULL;

    if (pSifDisk->Style != pPhysicalDisk->Style) {
        return FALSE;           // different partitioning styles
    }

    if (PARTITION_STYLE_MBR == pSifDisk->Style) {
        //
        // For MBR disks, we expect to find the same number of partitions,
        // and the starting-offset and partition-length for each of those
        // partitions must be the same as they were in the sif
        //
        if (pSifDisk->pDriveLayoutEx->Mbr.Signature 
            != pPhysicalDisk->pDriveLayoutEx->Mbr.Signature) {
            return FALSE;       // different signatures
        }

        if (pSifDisk->pDriveLayoutEx->PartitionCount
            != pPhysicalDisk->pDriveLayoutEx->PartitionCount) {
            return FALSE;       // different partition counts
        }


        for (index =0; index < pSifDisk->pDriveLayoutEx->PartitionCount; index++) {

            pSifPtnEx      = &(pSifDisk->pDriveLayoutEx->PartitionEntry[index]);
            pPhysicalPtnEx = &(pPhysicalDisk->pDriveLayoutEx->PartitionEntry[index]);

            if ((pSifPtnEx->StartingOffset.QuadPart != pPhysicalPtnEx->StartingOffset.QuadPart) ||
                (pSifPtnEx->PartitionLength.QuadPart != pPhysicalPtnEx->PartitionLength.QuadPart)
                ) {
                //
                // The partition offset or length didn't match, ie the disk
                // isn't intact
                //
                return FALSE;
            }
        } // for
    }
    else if (PARTITION_STYLE_GPT == pSifDisk->Style) {
        BOOL found = FALSE;
        //
        // For GPT disks, the partitions must have the same partition-Id's, in
        // addition to the start sector and sector count.  We can't rely on their
        // partition table entry order being the same, though--so we have to go
        // through all the partition entries from the beginning ...
        //
        for (index = 0; index < pSifDisk->pDriveLayoutEx->PartitionCount; index++) {

            pSifPtnEx = &(pSifDisk->pDriveLayoutEx->PartitionEntry[index]);

            found = FALSE;
            for (physicalIndex = 0;
                (physicalIndex < pPhysicalDisk->pDriveLayoutEx->PartitionCount)
//                    && (pSifPtnEx->StartingOffset.QuadPart >= pPhysicalDisk->pDriveLayoutEx->PartitionEntry[physicalIndex].StartingOffset.QuadPart) // entries are in ascending order
                    && (!found);
                physicalIndex++) {

                pPhysicalPtnEx = &(pPhysicalDisk->pDriveLayoutEx->PartitionEntry[physicalIndex]);

                if (IsEqualGUID(&(pSifPtnEx->Gpt.PartitionId), &(pPhysicalPtnEx->Gpt.PartitionId)) &&
                    (pSifPtnEx->StartingOffset.QuadPart == pPhysicalPtnEx->StartingOffset.QuadPart) &&
                    (pSifPtnEx->PartitionLength.QuadPart == pPhysicalPtnEx->PartitionLength.QuadPart)
                    ) {
                    //
                    // The partition GUID, offset and length matched, this partition exists
                    //
                    found = TRUE;
                }
            } // for

            if (!found) {
                //
                // At least one partition wasn't found
                //
                return FALSE;
            }
        }
    }

    return TRUE;
}


LONGLONG
AsrpCylinderAlignMbrPartitions(
    IN PASR_DISK_INFO   pSifDisk,
    IN PDRIVE_LAYOUT_INFORMATION_EX pAlignedLayoutEx,
    IN DWORD            StartIndex,      // index in the partitionEntry table to start at
    IN LONGLONG         StartingOffset,
    IN PDISK_GEOMETRY   pPhysicalDiskGeometry
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    LONGLONG nextEnd = 0,
        endingOffset = 0,
        bytesPerTrack = 0,
        bytesPerCylinder = 0,
        currentMax = 0,
        maxEndingOffset = 0;

    DWORD   index = 0,
        tempIndex = 0,
        tempIndex2 = 0;

    PPARTITION_INFORMATION_EX alignedPtn = NULL,
        sifPtn = NULL,
        tempPtn = NULL;

    if (PARTITION_STYLE_MBR != pSifDisk->Style) {
        //
        // This routine only supports MBR disks.  For GPT disks, we don't need to
        // cylinder-align partitions, so this routine shouldn't be called.
        //
        return -1;
    }

    if (0 == pSifDisk->pDriveLayoutEx->PartitionCount) {
        //
        //  (boundary case) No partitions on disk to align
        //
        return 0;
    }

    MYASSERT(AsrpRoundUp(StartIndex,4) == StartIndex);
    MYASSERT(pSifDisk && pAlignedLayoutEx);
    if (!pSifDisk || !pAlignedLayoutEx) {
        return -1;
    }

    bytesPerTrack = pPhysicalDiskGeometry->BytesPerSector * pPhysicalDiskGeometry->SectorsPerTrack;
    bytesPerCylinder = bytesPerTrack * (pPhysicalDiskGeometry->TracksPerCylinder);

    //
    // The first partition entry in each MBR/EBR always starts at the 
    // cylinder-boundary plus one track.  So, add one track to the starting 
    // offset.
    //
    // The exception (there had to be one, of course) is if the first 
    // partition entry in the MBR/EBR itself is a container partition (0x05 or
    // 0x0f), then it starts on the next cylinder.
    //
    if (IsContainerPartition(pSifDisk->pDriveLayoutEx->PartitionEntry[StartIndex].Mbr.PartitionType)) {
        StartingOffset += (bytesPerCylinder);
    }
    else {
        StartingOffset += (bytesPerTrack);
    }


    for (index = 0; index < 4; index++) {

        alignedPtn = &(pAlignedLayoutEx->PartitionEntry[index + StartIndex]);
        sifPtn = &(pSifDisk->pDriveLayoutEx->PartitionEntry[index + StartIndex]);

        MYASSERT(PARTITION_STYLE_MBR == sifPtn->PartitionStyle);
        //
        // Set the fields of interest
        //
        alignedPtn->PartitionStyle = PARTITION_STYLE_MBR;
        alignedPtn->RewritePartition = TRUE;

        alignedPtn->Mbr.PartitionType = sifPtn->Mbr.PartitionType;
        alignedPtn->Mbr.BootIndicator = sifPtn->Mbr.BootIndicator;
        alignedPtn->Mbr.RecognizedPartition = sifPtn->Mbr.RecognizedPartition;

        if (PARTITION_ENTRY_UNUSED != sifPtn->Mbr.PartitionType)  {

            alignedPtn->StartingOffset.QuadPart = StartingOffset;
            endingOffset = AsrpRoundUp(sifPtn->PartitionLength.QuadPart + StartingOffset, bytesPerCylinder);

            alignedPtn->PartitionLength.QuadPart = endingOffset - StartingOffset;

            if (IsContainerPartition(alignedPtn->Mbr.PartitionType)) {
                //
                // This is a container partition (0x5 or 0xf), so we have to try and
                // fit the logical drives inside this partition to get the
                // required size of this partition.
                //
                nextEnd = AsrpCylinderAlignMbrPartitions(pSifDisk,
                    pAlignedLayoutEx,
                    StartIndex + 4,
                    StartingOffset,
                    pPhysicalDiskGeometry
                    );

                if (-1 == nextEnd) {
                    //
                    // Propogate error upwards
                    //
                    return nextEnd;
                }

                if (StartIndex < 4) {
                    //
                    // We're dealing with the primary container partition
                    //
                    if (nextEnd > endingOffset) {
                        MYASSERT(AsrpRoundUp(nextEnd, bytesPerCylinder) == nextEnd);
                        alignedPtn->PartitionLength.QuadPart = nextEnd - StartingOffset;
                        endingOffset = nextEnd;
                    }

                    //
                    // If the primary container partition ends beyond cylinder 
                    // 1024, it should be of type 0xf, else it should be of
                    // type 0x5.
                    //
                    if (endingOffset > (1024 * bytesPerCylinder)) {
                        alignedPtn->Mbr.PartitionType = PARTITION_XINT13_EXTENDED;
                    }
                    else {
                        alignedPtn->Mbr.PartitionType = PARTITION_EXTENDED;
                    }
                }
                else {
                    //
                    // We're dealing with a secondary container.  This 
                    // container should only be big enough to hold the
                    // next logical drive.
                    //
                    alignedPtn->Mbr.PartitionType = PARTITION_EXTENDED;

                    tempIndex = (DWORD) AsrpRoundUp((StartIndex + index), 4);
                    currentMax = 0;

                    for (tempIndex2 = 0; tempIndex2 < 4; tempIndex2++) {

                        tempPtn = &(pSifDisk->pDriveLayoutEx->PartitionEntry[tempIndex + tempIndex2]);

                        if ((PARTITION_ENTRY_UNUSED != tempPtn->Mbr.PartitionType) &&
                            !IsContainerPartition(tempPtn->Mbr.PartitionType)
                            ) {
                            
                            if (tempPtn->StartingOffset.QuadPart + tempPtn->PartitionLength.QuadPart
                                > currentMax
                                ) {
                                currentMax = tempPtn->StartingOffset.QuadPart + tempPtn->PartitionLength.QuadPart;
                            }
                        }
                    }

                    if (currentMax > endingOffset) {
                        MYASSERT(AsrpRoundUp(currentMax, bytesPerCylinder) == currentMax);
                        alignedPtn->PartitionLength.QuadPart = currentMax - StartingOffset;
                        endingOffset = currentMax;
                    }

                }

                if (nextEnd > maxEndingOffset) {
                    maxEndingOffset = nextEnd;
                }
            }

            if (endingOffset > maxEndingOffset) {
                maxEndingOffset = endingOffset;
            }

            StartingOffset += (alignedPtn->PartitionLength.QuadPart);
        }
        else {
            alignedPtn->StartingOffset.QuadPart = 0;
            alignedPtn->PartitionLength.QuadPart = 0;
        }
    }

    return maxEndingOffset;
}


VOID
AsrpFreeRegionInfo(
    IN PASR_REGION_INFO RegionInfo
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO temp = RegionInfo;
    HANDLE heapHandle = GetProcessHeap();

    while (temp) {
        RegionInfo = temp->pNext;
        _AsrpHeapFree(temp);
        temp = RegionInfo;
    }
}


BOOL
AsrpIsOkayToErasePartition(
    IN PPARTITION_INFORMATION_EX pPartitionInfoEx
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    GUID typeGuid = pPartitionInfoEx->Gpt.PartitionType;

    //
    // For now, this checks the partition type against all the known ("recognised")
    // partition types.  If the partition type is recognised (except the system partition),
    // it's okay to erase it.
    //
    if (IsEqualGUID(&(typeGuid), &(PARTITION_ENTRY_UNUSED_GUID))) {
        return TRUE;
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_SYSTEM_GUID))) {
        return FALSE; // Cannot erase EFI system partition.
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_MSFT_RESERVED_GUID))) {
        return TRUE;
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_BASIC_DATA_GUID))) {
        return TRUE;
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_LDM_METADATA_GUID))) {
        return TRUE;
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_LDM_DATA_GUID))) {
        return TRUE;
    }

    //
    // It is okay to erase other, unrecognised partitions.
    //
    return TRUE;
}


//
// Checks if it's okay to erase all the partitions on a disk.  Returns TRUE for MBR disks.
// Returns TRUE for GPT disks if all the partitions on it are erasable.  A partition that
// we don't recognise  (including OEM partitions, ESP, etc) is considered non-erasable.
//
BOOL
AsrpIsOkayToEraseDisk(
    IN PASR_DISK_INFO pPhysicalDisk
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    DWORD index;

    if (PARTITION_STYLE_GPT != pPhysicalDisk->pDriveLayoutEx->PartitionStyle) {
        return TRUE;
    }

    for (index = 0; index < pPhysicalDisk->pDriveLayoutEx->PartitionCount; index++) {
        if (!AsrpIsOkayToErasePartition(&(pPhysicalDisk->pDriveLayoutEx->PartitionEntry[index]))) {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL
AsrpInsertSortedRegion(
    IN OUT PASR_REGION_INFO *Head,
    IN LONGLONG StartingOffset,
    IN LONGLONG RegionLength,
    IN DWORD Index,
    IN LONGLONG MaxLength,          // 0 == don't care
    IN ASR_SORT_ORDER SortBy
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO previousRegion = NULL,
        newRegion = NULL,
        currentRegion = *Head;

    if (RegionLength < (1024*1024)) {
        return TRUE;
    }
    //
    // Alloc mem for the new region and set the fields of interest
    //
    newRegion = (PASR_REGION_INFO) HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        sizeof(ASR_REGION_INFO)
        );
    if (!newRegion) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    newRegion->StartingOffset = StartingOffset;
    newRegion->RegionLength = RegionLength;
    newRegion->Index = Index;
    newRegion->pNext = NULL;

    if (!currentRegion) {
        //
        // First item in the list
        //
        *Head = newRegion;
    }
    else {

        while (currentRegion) {

             if (((SortByLength == SortBy) && (currentRegion->RegionLength <= RegionLength))
                || ((SortByStartingOffset == SortBy) && (currentRegion->StartingOffset <= StartingOffset))
                ) {

                previousRegion = currentRegion;
                currentRegion = currentRegion->pNext;
            }

            else {
                //
                // We found the spot, let's add it in.
                //

                //
                // If this is sorted based on start sectors, make sure there's
                // enough space to add this region in, ie that the regions don't overlap.
                //
                if (SortByStartingOffset == SortBy) {
                    //
                    // Make sure this is after the end of the previous sector
                    //
                    if (previousRegion) {
                        if ((previousRegion->StartingOffset + previousRegion->RegionLength) > StartingOffset) {
                            return FALSE;
                        }
                    }

                    //
                    // And that this ends before the next sector starts
                    //
                    if ((StartingOffset + RegionLength) > (currentRegion->StartingOffset)) {
                        return FALSE;
                    }
                }


                if (!previousRegion) {
                    //
                    // This is the first node
                    //
                    *Head = newRegion;
                }
                else {
                    previousRegion->pNext = newRegion;
                }

                newRegion->pNext = currentRegion;
                break;
            }

        }

        if (!currentRegion) {
            //
            // We reached the end and didn't add this node in.
            //
            MYASSERT(NULL == previousRegion->pNext);

            //
            // Make sure this is after the end of the previous sector
            //
            if (previousRegion && (MaxLength > 0)) {
                if ((previousRegion->StartingOffset + previousRegion->RegionLength) > MaxLength) {
                    return FALSE;
                }
            }

            previousRegion->pNext = newRegion;
        }
    }

    return TRUE;
}


BOOL
AsrpBuildFreeRegionList(
    IN PASR_REGION_INFO PartitionList,
    OUT PASR_REGION_INFO *FreeList,
    IN LONGLONG UsableStartingOffset,
    IN LONGLONG UsableLength
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO currentRegion = PartitionList,
        previousRegion = NULL;
    LONGLONG previousEnd = UsableStartingOffset;

    while (currentRegion) {

        if (!AsrpInsertSortedRegion(FreeList,
            previousEnd,                // free region start offset
            currentRegion->StartingOffset - previousEnd,  // free region length,
            0,                          // index--not meaningful for this list
            0,
            SortByLength
            ) ) {

            return FALSE;
        }

        previousEnd = currentRegion->StartingOffset + currentRegion->RegionLength;
        currentRegion = currentRegion->pNext;
    }

    //
    // Add space after the last partition till the end of the disk to
    // our free regions list
    //
    return AsrpInsertSortedRegion(FreeList, // list head
        previousEnd,  // free region start offset
        UsableStartingOffset + UsableLength - previousEnd, // free region length
        0, // slot index in the partition entry table--not meaningful for this list
        0,
        SortByLength
        );
}


//
// Both partitions and regions are sorted by sizes
//
BOOL
AsrpFitPartitionToFreeRegion(
    IN PASR_REGION_INFO PartitionList,
    IN PASR_REGION_INFO FreeRegionList
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO partition = PartitionList,
        hole = FreeRegionList;

    while (partition) {

        while (hole && (partition->RegionLength > hole->RegionLength)) {
            hole = hole->pNext;
        }

        if (!hole) {
            //
            // We ran out of holes and have unassigned partitions
            //
            return FALSE;
        }

        partition->StartingOffset = hole->StartingOffset;

        hole->RegionLength -= partition->RegionLength;
        hole->StartingOffset += partition->RegionLength;

        partition = partition->pNext;
    }

    return TRUE;
}


//
// For optimisation purposes, this routine should only be called if:
// PhysicalDisk and SifDisk are both GPT
// PhysicalDisk is bigger than SifDisk
// PhysicalDisk has non-erasable partitions
//
BOOL
AsrpFitGptPartitionsToRegions(
    IN PASR_DISK_INFO SifDisk,
    IN PASR_DISK_INFO PhysicalDisk,
    IN BOOL Commit
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO partitionList = NULL,
        collisionList = NULL,
        freeRegionList = NULL;

    LONGLONG StartingUsableOffset = 0,
        UsableLength = 0;

    DWORD index = 0;

    BOOL result = TRUE;

    if ((PARTITION_STYLE_GPT != SifDisk->Style) || (PARTITION_STYLE_GPT != PhysicalDisk->Style)) {
        return TRUE;
    }

    StartingUsableOffset = PhysicalDisk->pDriveLayoutEx->Gpt.StartingUsableOffset.QuadPart;
    UsableLength = PhysicalDisk->pDriveLayoutEx->Gpt.UsableLength.QuadPart;

    //
    // First, go through the existing non-erasable partitions, and add them to our list
    // sorted by start sectors.
    //
    for (index = 0; index < PhysicalDisk->pDriveLayoutEx->PartitionCount; index++) {
        if (!AsrpIsOkayToErasePartition(&(PhysicalDisk->pDriveLayoutEx->PartitionEntry[index]))) {

            PPARTITION_INFORMATION_EX currentPtn = &(PhysicalDisk->pDriveLayoutEx->PartitionEntry[index]);

            if (!AsrpInsertSortedRegion(&partitionList,
                currentPtn->StartingOffset.QuadPart,
                currentPtn->PartitionLength.QuadPart,
                index,
                (StartingUsableOffset + UsableLength),
                SortByStartingOffset
                )) {
                result = FALSE;
                break;
            }
        }
    }

    if (partitionList && result) {
        //
        // Then, go through the sif partitions, and add them to a list, sorted by start sectors.
        // For partitions that cannot be added, add them to another list sorted by sizes
        //
        for (index = 0; index < SifDisk->pDriveLayoutEx->PartitionCount; index++) {
            PPARTITION_INFORMATION_EX currentPtn = &(SifDisk->pDriveLayoutEx->PartitionEntry[index]);

            if (!AsrpInsertSortedRegion(&partitionList,
                currentPtn->StartingOffset.QuadPart,
                currentPtn->PartitionLength.QuadPart,
                index,
                (StartingUsableOffset + UsableLength),
                SortByStartingOffset
                )) {

                if (!AsrpInsertSortedRegion(&collisionList,
                    currentPtn->StartingOffset.QuadPart,
                    currentPtn->PartitionLength.QuadPart,
                    index,
                    0,
                    SortByLength
                    )) {

                    result = FALSE;
                    break;
                }
            }
        }
    }

    if (collisionList && result) {
        //
        // Go through first list and come up with a list of free regions, sorted by sizes
        //
        result = AsrpBuildFreeRegionList(partitionList, &freeRegionList, StartingUsableOffset, UsableLength);

    }


    if (collisionList && result) {
        //
        // Try adding partitions from list 2 to regions from list 3.  If any
        // are left over, return FALSE.
        //
        result = AsrpFitPartitionToFreeRegion(collisionList, freeRegionList);

        if (Commit && result) {
            PASR_REGION_INFO pCurrentRegion = collisionList;
            //
            // Go through the collision list, and update the start sectors of the
            // PartitionEntries in DriveLayoutEx's table.
            //
            while (pCurrentRegion) {

                MYASSERT(SifDisk->pDriveLayoutEx->PartitionEntry[pCurrentRegion->Index].PartitionLength.QuadPart == pCurrentRegion->RegionLength);

                SifDisk->pDriveLayoutEx->PartitionEntry[pCurrentRegion->Index].StartingOffset.QuadPart =
                    pCurrentRegion->StartingOffset;

                pCurrentRegion = pCurrentRegion->pNext;
            }
        }

    }

    AsrpFreeRegionInfo(partitionList);
    AsrpFreeRegionInfo(collisionList);
    AsrpFreeRegionInfo(freeRegionList);

    return result;
}


BOOL
AsrpIsThisDiskABetterFit(
    IN PASR_DISK_INFO CurrentBest,
    IN PASR_DISK_INFO PhysicalDisk,
    IN PASR_DISK_INFO SifDisk,
    IN PDRIVE_LAYOUT_INFORMATION_EX pTempDriveLayoutEx,
    OUT BOOL *IsAligned
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    LONGLONG endingOffset;

    if (ARGUMENT_PRESENT(IsAligned)) {
        *IsAligned = FALSE;
    }

    //
    // Make sure the bytes-per-sector values match
    //
    if (PhysicalDisk->pDiskGeometry->BytesPerSector != SifDisk->pDiskGeometry->BytesPerSector) {
        return FALSE;
    }

    if (PhysicalDisk->pPartition0Ex->PartitionLength.QuadPart >=
        SifDisk->pPartition0Ex->PartitionLength.QuadPart) {

        if ((!CurrentBest) ||
            (PhysicalDisk->pPartition0Ex->PartitionLength.QuadPart <
            CurrentBest->pPartition0Ex->PartitionLength.QuadPart)) {

            //
            // This disk is smaller than our current best (or we don't have a 
            // current best).  Now try laying out the partitions to see if 
            // they fit.
            //

            if (PARTITION_STYLE_GPT == SifDisk->Style) {
                //
                // If the disk has no partitions that need to be preserved,
                // we can use all of it.
                if (AsrpIsOkayToEraseDisk(PhysicalDisk)) {
                    return TRUE;
                }
                else {
                    //
                    // This disk has some regions that need to be preserved.  So
                    // we try to fit our partitions in the holes
                    //
                    return AsrpFitGptPartitionsToRegions(SifDisk, PhysicalDisk, FALSE); // No commmit
                }
            }
            else if (PARTITION_STYLE_MBR == SifDisk->Style) {

                if (!pTempDriveLayoutEx) {
                    //
                    // Caller doesn't want to try cylinder-aligning partitions
                    //
                    return TRUE;
                }
                    
                //
                // For MBR disks, the partitions have to be cylinder aligned
                //
                // AsrpCylinderAlignMbrPartitions(,,0,,) returns the ending offset (bytes)
                // of the entries in the MBR.
                //
                endingOffset = AsrpCylinderAlignMbrPartitions(SifDisk,
                    pTempDriveLayoutEx,
                    0,      // starting index--0 for the MBR
                    0,      // starting offset, assume the partitions begin at the start of the disk
                    PhysicalDisk->pDiskGeometry
                    );

                if ((endingOffset != -1) &&
                    (endingOffset <= SifDisk->pPartition0Ex->PartitionLength.QuadPart)
                    ) {

                    if (ARGUMENT_PRESENT(IsAligned)) {
                        *IsAligned = TRUE;
                    }

                    return TRUE;

                }
                else {

                    //
                    // We couldn't fit the partitions on to the disk when we 
                    // tried to cylinder align them.  If the disk geometries
                    // are the same, this may still be okay.
                    //

                    if ((SifDisk->pDiskGeometry->BytesPerSector == PhysicalDisk->pDiskGeometry->BytesPerSector) &&
                        (SifDisk->pDiskGeometry->SectorsPerTrack == PhysicalDisk->pDiskGeometry->SectorsPerTrack) &&
                        (SifDisk->pDiskGeometry->TracksPerCylinder == PhysicalDisk->pDiskGeometry->TracksPerCylinder)
                        ) {

                        return TRUE;
                    }

                    else {
                        return FALSE;
                    }
                }
            }
            else {
                MYASSERT(0 && L"Unrecognised partitioning style (neither MBR nor GPT)");
            }
        }
    }

    return FALSE;
}


//
// Assigns sif-disks to physical disks with matching signatures, if
// any exist.  If the disk is critical, or the partition-layout matches,
// the disk is marked as intact.
//
// Returns
//  FALSE   if a critical disk is absent
//  TRUE    if all critical disks are present
//
BOOL
AsrpAssignBySignature(
    IN OUT PASR_DISK_INFO   pSifDiskList,
    IN OUT PASR_DISK_INFO   pPhysicalDiskList,
    OUT    PULONG           pMaxPartitionCount
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    BOOL    result  = TRUE,
            done    = FALSE,
            found   = FALSE,
            isAligned = FALSE;

    PASR_DISK_INFO  sifDisk          = pSifDiskList,
                    physicalDisk     = pPhysicalDiskList;

    PDRIVE_LAYOUT_INFORMATION_EX pAlignedLayoutTemp = NULL;

    ULONG   tableSize = 128;    // start off at a reasonably high size

    HANDLE heapHandle = GetProcessHeap();

    pAlignedLayoutTemp = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof(DRIVE_LAYOUT_INFORMATION) + (tableSize * sizeof(PARTITION_INFORMATION_EX))
        );
    if (!pAlignedLayoutTemp) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        result = FALSE;
        goto EXIT;
    }


    *pMaxPartitionCount = 0;

    //
    // For now, this is O(n-squared), since both lists are unsorted.
    //
    while (sifDisk && !done) {

        if (!(sifDisk->pDriveLayoutEx) || !(sifDisk->pDriveLayoutEx->Mbr.Signature)) {
            //
            // we won't assign disks with no signature here
            //
            sifDisk = sifDisk->pNext;
            continue;
        }


        if (sifDisk->pDriveLayoutEx->PartitionCount > *pMaxPartitionCount) {
            *pMaxPartitionCount = sifDisk->pDriveLayoutEx->PartitionCount;
        }

        if (sifDisk->pDriveLayoutEx->PartitionCount > tableSize) {
            tableSize = sifDisk->pDriveLayoutEx->PartitionCount + 128;

            _AsrpHeapFree(pAlignedLayoutTemp);
            pAlignedLayoutTemp = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(DRIVE_LAYOUT_INFORMATION) + (tableSize * sizeof(PARTITION_INFORMATION_EX))
                );
            if (!pAlignedLayoutTemp) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                result = FALSE;
                goto EXIT;
            }
        }

        found = FALSE;
        physicalDisk = pPhysicalDiskList;

        while (physicalDisk && !found) {
            //
            // For MBR disks, we use the signature
            // For GPT disks, we use the disk ID
            //
            if (sifDisk->Style == physicalDisk->Style) {

                if ((PARTITION_STYLE_MBR == sifDisk->Style) &&
                    (physicalDisk->pDriveLayoutEx->Mbr.Signature == sifDisk->pDriveLayoutEx->Mbr.Signature)
                    ) {
                    //
                    // MBR disks, signatures match
                    //
                    found = TRUE;

                    AsrpPrintDbgMsg(_asrlog, 
                        "Harddisk %lu matched disk %lu in section [%ws] of the ASR state file.  (MBR signatures 0x%x match).\r\n", 
                        physicalDisk->DeviceNumber, 
                        sifDisk->SifDiskKey,
                        ASR_SIF_MBR_DISKS_SECTION,
                        sifDisk->pDriveLayoutEx->Mbr.Signature
                        );


                }
                else if (
                    (PARTITION_STYLE_GPT == sifDisk->Style) &&
                    IsEqualGUID(&(sifDisk->pDriveLayoutEx->Gpt.DiskId), &(physicalDisk->pDriveLayoutEx->Gpt.DiskId))
                    ) {

                    found = TRUE;

                    AsrpPrintDbgMsg(_asrlog, 
                        "Harddisk %lu matched disk %lu in section [%ws] of the ASR state file.  (GPT Disk-ID's match).\r\n", 
                        physicalDisk->DeviceNumber, 
                        sifDisk->SifDiskKey,
                        ASR_SIF_GPT_DISKS_SECTION
                        );

                }
                else {
                    physicalDisk = physicalDisk->pNext;
                }

            }
            else {
                physicalDisk = physicalDisk->pNext;
            }
        }

        if (sifDisk->IsCritical) {
            if (found) {

                sifDisk->AssignedTo = physicalDisk;
                physicalDisk->AssignedTo = sifDisk;
                
                //
                // We don't check the partition layout on critical disks since they
                // may have been repartitioned in text-mode Setup.
                //
                sifDisk->IsIntact = TRUE;
                sifDisk->AssignedTo->IsIntact = TRUE;
            }
            else {
                //
                // Critical disk was not found.  Fatal error.
                //
                SetLastError(ERROR_DEVICE_NOT_CONNECTED);
                result = FALSE;
                done = TRUE;

                AsrpPrintDbgMsg(_asrerror, 
                    "Critical disk not found (Entry %lu in section [%ws]).\r\n", 
                    sifDisk->SifDiskKey,
                    ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                    );

            }
        }
        else {
            if (found) {
                //
                // We found a disk with matching signature.  Now let's just 
                // make sure that the partitions actually fit on the disk
                // before assigning it
                //
                isAligned = FALSE;
                if ((sifDisk->pDriveLayoutEx->PartitionCount == 0) ||           // disk has no partitions
                    AsrpIsThisDiskABetterFit(NULL, physicalDisk, sifDisk, pAlignedLayoutTemp, &isAligned) // partitions fit on disk
                    ) {

                    sifDisk->AssignedTo = physicalDisk;
                    physicalDisk->AssignedTo = sifDisk;

                    sifDisk->IsAligned = isAligned;
                    physicalDisk->IsAligned = isAligned;

                    if (AsrpIsDiskIntact(sifDisk, physicalDisk)) {
                        sifDisk->IsIntact = TRUE;
                        sifDisk->AssignedTo->IsIntact = TRUE;
                    }
                }
                else {

                    AsrpPrintDbgMsg(_asrlog, 
                        "Harddisk %lu is not big enough to contain the partitions on disk %lu in section [%ws] of the ASR state file.\r\n", 
                        physicalDisk->DeviceNumber, 
                        sifDisk->SifDiskKey,
                        ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                        );

                }
            }
        }

        sifDisk = sifDisk->pNext;

    }   // while


EXIT:
    _AsrpHeapFree(pAlignedLayoutTemp);

   return result;
}


//
// Attempts to assign remaining sif disks to physical disks that
// are on the same bus as the sif disk originally was (ie if
// any other disk on that bus has been assigned, this tries to assign
// this disk to the same bus)
//
BOOL
AsrpAssignByBus(
    IN OUT PASR_DISK_INFO pSifDiskList,
    IN OUT PASR_DISK_INFO pPhysicalDiskList,
    IN PDRIVE_LAYOUT_INFORMATION_EX pTempDriveLayoutEx
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    PASR_DISK_INFO  sifDisk = pSifDiskList,
        physicalDisk = NULL,
        currentBest = NULL,
        tempSifDisk = NULL;

    BOOL done = FALSE,
        isAligned = FALSE,
        isAlignedTemp = FALSE;

    ULONG  targetBusId = 0;

    while (sifDisk) {
        //
        // Skip disks that have already found a home, and disks for which
        // we didn't have any bus/group info even on the original system
        //
        if ((NULL != sifDisk->AssignedTo) ||    // already assigned
            (0 == sifDisk->SifBusKey)           // this disk couldn't be grouped
            ) {
           sifDisk = sifDisk->pNext;
           continue;
        }

        //
        // Find another (sif) disk that used to be on the same (sif) bus,
        // and has already been assigned to a physical disk.
        //
        targetBusId = 0;
        tempSifDisk = pSifDiskList;
        done = FALSE;

        while (tempSifDisk && !done) {

            if ((tempSifDisk->SifBusKey == sifDisk->SifBusKey) &&   // same bus
                (tempSifDisk->AssignedTo != NULL)                   // assigned
                ) {
                targetBusId = tempSifDisk->AssignedTo->SifBusKey;   // the physical bus

                //
                // If this physical disk is on an unknown bus,
                // (target id = sifbuskey = 0) then we want to try and look
                // for another disk on the same (sif) bus.  Hence done is
                // TRUE only if targetId != 0
                //
                if (targetBusId) {
                    done = TRUE;
                }
            }

            tempSifDisk = tempSifDisk->pNext;

        }   // while


        if (targetBusId) {      // we found another disk on the same bus
            //
            // Go through the physical disks on the same bus, and try to
            // find the best fit for this disk.  Best fit is the smallest
            // disk on the bus that's big enough for us.
            //
            physicalDisk = pPhysicalDiskList;
            currentBest  = NULL;

            while (physicalDisk) {

                if ((NULL == physicalDisk->AssignedTo) &&       // not assigned
                    (physicalDisk->SifBusKey == targetBusId) && // same bus
                    (AsrpIsThisDiskABetterFit(currentBest, physicalDisk, sifDisk, pTempDriveLayoutEx, &isAlignedTemp))
                    ) {

                    isAligned = isAlignedTemp;
                    currentBest = physicalDisk;
                }

                physicalDisk = physicalDisk->pNext;
            }   // while

            sifDisk->AssignedTo = currentBest;  // may be null if no match was found
            sifDisk->IsAligned = isAligned;

            if (currentBest) {

                currentBest->AssignedTo = sifDisk;
                currentBest->IsAligned = isAligned;

                AsrpPrintDbgMsg(_asrlog, 
                    "Harddisk %lu assigned to disk %lu in section [%ws] of the ASR state file.  (Based on storage bus).\r\n", 
                    currentBest->DeviceNumber, 
                    sifDisk->SifDiskKey,
                    ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                    );

            }
       }

        sifDisk = sifDisk->pNext;
    }   // while sifdisk

    return TRUE;

}


//
// Attempts to assign remaining sif disks to physical disks that
// are on any bus of the same type (SCSI, IDE, etc) as the sif disk
// originally was
//
BOOL
AsrpAssignByBusType(
    IN OUT PASR_DISK_INFO pSifDiskList,
    IN OUT PASR_DISK_INFO pPhysicalDiskList,
    IN PDRIVE_LAYOUT_INFORMATION_EX pTempDriveLayoutEx
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_DISK_INFO  sifDisk = pSifDiskList,
        physicalDisk = NULL,
        currentBest = NULL;

    STORAGE_BUS_TYPE targetBusType;

    BOOL isAligned = FALSE,
        isAlignedTemp = FALSE;

    while (sifDisk) {
        //
        // Skip disks that have already found a home, and disks for which
        // we didn't have any bus/group info even on the original system
        //
        if ((NULL != sifDisk->AssignedTo) ||     // already assigned
            (BusTypeUnknown == sifDisk->BusType) // this disk couldn't be grouped
            ) {
           sifDisk = sifDisk->pNext;
           continue;
        }

        //
        // Go through the physical disks, and try to
        // find the best fit for this disk.  Best fit is the smallest
        // disk on any bus of the same bus type that's big enough for us.
        //
        physicalDisk = pPhysicalDiskList;
        currentBest  = NULL;

        while (physicalDisk) {

            if ((NULL == physicalDisk->AssignedTo) &&       // not assigned
                (physicalDisk->BusType == sifDisk->BusType) && // same bus type
                (AsrpIsThisDiskABetterFit(currentBest, physicalDisk, sifDisk, pTempDriveLayoutEx, &isAlignedTemp))
                ) {

                isAligned = isAlignedTemp;
                currentBest = physicalDisk;
            }

            physicalDisk = physicalDisk->pNext;
        }   // while

        sifDisk->AssignedTo = currentBest;  // may be null if no match was found
        sifDisk->IsAligned = isAligned;

        if (currentBest) {
            currentBest->AssignedTo = sifDisk;
            currentBest->IsAligned = isAligned;


            AsrpPrintDbgMsg(_asrlog, 
                "Harddisk %lu assigned to disk %lu in section [%ws] of the ASR state file.  (Based on storage bus type).\r\n", 
                currentBest->DeviceNumber, 
                sifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            AsrpAssignByBus(pSifDiskList, pPhysicalDiskList, pTempDriveLayoutEx);
        }

        sifDisk = sifDisk->pNext;
    }   // while sifdisk

    return TRUE;

}


//
// Okay, so by now we've tried putting disks on the same bus, and
// the same bus type.  For disks that didn't fit using either of those
// rules (or for which we didn't have any bus info at all), let's just
// try to fit them where ever possible on the system.
//
BOOL
AsrpAssignRemaining(
    IN OUT PASR_DISK_INFO pSifDiskList,
    IN OUT PASR_DISK_INFO pPhysicalDiskList,
    IN PDRIVE_LAYOUT_INFORMATION_EX pTempDriveLayoutEx
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_DISK_INFO  sifDisk = pSifDiskList,
        physicalDisk = NULL,
        currentBest = NULL;

    BOOL isAligned = FALSE,
        isAlignedTemp = FALSE;

    while (sifDisk) {
        //
        // Skip disks that have already found a home
        //
        if (NULL != sifDisk->AssignedTo) {
           sifDisk = sifDisk->pNext;
           continue;
        }

        //
        // Go through the physical disks, and try to find the best
        // fit for this disk.  Best fit is the smallest disk anywhere
        // on the system that's big enough for us.
        //
        physicalDisk = pPhysicalDiskList;
        currentBest  = NULL;

        while (physicalDisk) {

            if ((NULL == physicalDisk->AssignedTo) &&       // not assigned
                (AsrpIsThisDiskABetterFit(currentBest, physicalDisk, sifDisk, pTempDriveLayoutEx, &isAlignedTemp))
                ) {

                isAligned = isAlignedTemp;
                currentBest = physicalDisk;
            }

            physicalDisk = physicalDisk->pNext;
        }   // while

        sifDisk->AssignedTo = currentBest;  // may be null if no match was found
        sifDisk->IsAligned = isAligned;

        if (currentBest) {
            currentBest->AssignedTo = sifDisk;
            currentBest->IsAligned = isAligned;

            AsrpPrintDbgMsg(_asrlog, 
                "Harddisk %lu assigned to disk %lu in section [%ws] of the ASR state file.  (Based on size).\r\n", 
                currentBest->DeviceNumber, 
                sifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            AsrpAssignByBus(pSifDiskList, pPhysicalDiskList, pTempDriveLayoutEx);
            AsrpAssignByBusType(pSifDiskList, pPhysicalDiskList, pTempDriveLayoutEx);
        }

        sifDisk = sifDisk->pNext;
    }   // while sifdisk

    return TRUE;

}


BOOL
AsrpIsPartitionExtendible(
    IN CONST UCHAR PartitionType
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    switch (PartitionType) {
    case PARTITION_EXTENDED:

    case PARTITION_IFS:
    
    case PARTITION_XINT13:
    case PARTITION_XINT13_EXTENDED:

        return TRUE;

    default:
        return FALSE;
    }

    return FALSE;

}


BOOL
AsrpAutoExtendMbrPartitions(
    IN PASR_DISK_INFO pSifDisk,
    IN PASR_DISK_INFO pPhysicalDisk,
    IN LONGLONG LastUsedPhysicalDiskOffset
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    PDISK_GEOMETRY physicalGeometry = NULL;

    IN PDRIVE_LAYOUT_INFORMATION_EX sifLayout = NULL,
        physicalLayout = NULL;

    LONGLONG MaxSifDiskOffset = 0,
        MaxPhysicalDiskOffset = 0,
        LastUsedSifDiskOffset = 0;

    DWORD count = 0;

    BOOL madeAChange = FALSE;

    //
    // Find the last sector of the disk
    //
    MaxSifDiskOffset = pSifDisk->pPartition0Ex->PartitionLength.QuadPart;

    physicalGeometry = pPhysicalDisk->pDiskGeometry;
    MaxPhysicalDiskOffset = (physicalGeometry->BytesPerSector) *
        (physicalGeometry->SectorsPerTrack) * 
        (physicalGeometry->TracksPerCylinder) *
        (physicalGeometry->Cylinders.QuadPart);

    //
    // Did the old disk have empty space at the end?
    //
    sifLayout = pSifDisk->pDriveLayoutEx;
    for (count = 0; count < sifLayout->PartitionCount; count++) {

        if (((sifLayout->PartitionEntry[count].StartingOffset.QuadPart) + 
                (sifLayout->PartitionEntry[count].PartitionLength.QuadPart))
            > LastUsedSifDiskOffset) {

            LastUsedSifDiskOffset = (sifLayout->PartitionEntry[count].StartingOffset.QuadPart + 
                sifLayout->PartitionEntry[count].PartitionLength.QuadPart);
        }
    }

    if ((LastUsedSifDiskOffset + ASR_AUTO_EXTEND_MAX_FREE_SPACE_IGNORED) >= MaxSifDiskOffset) {
        //
        // No, it didn't.  Extend the last partition.
        //
        physicalLayout = pPhysicalDisk->pDriveLayoutEx;
        for (count = 0; count < physicalLayout->PartitionCount; count++) {

            if (((physicalLayout->PartitionEntry[count].StartingOffset.QuadPart) + 
                    (physicalLayout->PartitionEntry[count].PartitionLength.QuadPart))
                == LastUsedPhysicalDiskOffset
                ) {
                if (AsrpIsPartitionExtendible(physicalLayout->PartitionEntry[count].Mbr.PartitionType)) {

                    physicalLayout->PartitionEntry[count].PartitionLength.QuadPart += 
                        (MaxPhysicalDiskOffset - LastUsedPhysicalDiskOffset);
                    madeAChange = TRUE;
                }
            }
        }
    }

    if (madeAChange) {
        AsrpPrintDbgMsg(_asrlog, 
            "Extended partitions on Harddisk %lu (assigned to disk %lu in section [%ws]).\r\n", 
            pPhysicalDisk->DeviceNumber, 
            pSifDisk->SifDiskKey,
            ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
            );
    }
    else {
        AsrpPrintDbgMsg(_asrinfo, 
            "Did not extend partitions on Harddisk %lu (assigned to disk %lu in section [%ws]).\r\n", 
            pPhysicalDisk->DeviceNumber, 
            pSifDisk->SifDiskKey,
            ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
            );
    }

    return madeAChange;

}

//
// Try to determine which sif disks end up on which physical disk.
//
BOOL
AsrpAssignDisks(
    IN OUT PASR_DISK_INFO pSifDiskList,
    IN OUT PASR_DISK_INFO pPhysicalDiskList,
    IN PASR_PTN_INFO_LIST pSifMbrPtnList,
    IN PASR_PTN_INFO_LIST pSifGptPtnList,
    IN BOOL AllOrNothing,
    IN BOOL AllowAutoExtend
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    ULONG maxSifPartitionCount = 0;
    PDRIVE_LAYOUT_INFORMATION_EX pAlignedLayoutTemp = NULL;
    LONGLONG endingOffset = 0;
    BOOL reAlloc = TRUE;
    HANDLE heapHandle = GetProcessHeap();
    PASR_DISK_INFO sifDisk = NULL;
    PASR_PTN_INFO pCurrentPtn = NULL;
    PPARTITION_INFORMATION_EX pCurrentEntry = NULL;
    DWORD index = 0, preserveIndex = 0;

    if (!AsrpAssignBySignature(pSifDiskList, pPhysicalDiskList, &maxSifPartitionCount)) {
        //
        // Critical disks were not found
        //
        return FALSE;
    }

    pAlignedLayoutTemp = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof(DRIVE_LAYOUT_INFORMATION) + (maxSifPartitionCount * sizeof(PARTITION_INFORMATION_EX))
        );
    if (!pAlignedLayoutTemp) {
        return FALSE;
    }

    AsrpAssignByBus(pSifDiskList, pPhysicalDiskList, pAlignedLayoutTemp);

    AsrpAssignByBusType(pSifDiskList, pPhysicalDiskList, pAlignedLayoutTemp);

    AsrpAssignRemaining(pSifDiskList, pPhysicalDiskList, pAlignedLayoutTemp);

    _AsrpHeapFree(pAlignedLayoutTemp);

    //
    // All disks should be assigned by now, we now cylinder-snap
    // the partition boundaries.  If AllOrNothing is TRUE,
    // we return false if any sif-disk couldn't be assigned.
    //
    sifDisk = pSifDiskList;

    while (sifDisk) {

        if (sifDisk->IsIntact || sifDisk->IsCritical) {
            //
            // We won't be re-partitioning critical disks or disks that are 
            // intact, so it's no point trying to cylinder-align them.
            //
            sifDisk = sifDisk->pNext;
            continue;
        }

        if (NULL == sifDisk->AssignedTo) {

            AsrpPrintDbgMsg(_asrlog, 
                "Disk %lu in section [%ws] could not be restored (no matching disks found).\r\n", 
                sifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            //
            // This disk couldn't be assigned.  If AllOrNothing is set, we return
            // FALSE, since we couldn't assign All.
            //
            if (AllOrNothing) {
                SetLastError(ERROR_NOT_FOUND);
                return FALSE;
            }
            else {
                sifDisk = sifDisk->pNext;
                continue;
            }
        }


        if (PARTITION_STYLE_MBR == sifDisk->Style) {
            //
            // Assume that we need to re-allocate mem for the physical disk's
            // partition table.
            //
            reAlloc = TRUE;

            if (sifDisk->AssignedTo->pDriveLayoutEx) {
                if (sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount ==
                    sifDisk->pDriveLayoutEx->PartitionCount) {
                    //
                    // If the physical drive happened to have the same number of
                    // partitions, the drive layout struct is exactly the right
                    // size, so we don't have to re-allocate it.
                    //
                    reAlloc = FALSE;

                    //
                    // consistency check.  If the partition counts are
                    // the same, the size of the drive layout stucts must be the same, too.
                    //
                    MYASSERT(sifDisk->AssignedTo->sizeDriveLayoutEx == sifDisk->sizeDriveLayoutEx);
                }
            }

            if (reAlloc) {
                //
                //  The partition tables are of different sizes
                //
                _AsrpHeapFree(sifDisk->AssignedTo->pDriveLayoutEx);

                sifDisk->AssignedTo->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                    heapHandle,
                    HEAP_ZERO_MEMORY,
                    sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                        ((sifDisk->pDriveLayoutEx->PartitionCount - 1) * sizeof(PARTITION_INFORMATION_EX))
                    );
                if (!sifDisk->AssignedTo->pDriveLayoutEx) {

                    AsrpPrintDbgMsg(_asrerror, "Out of memory.\r\n");
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
            }

            //
            // Set the fields of interest
            //
            sifDisk->AssignedTo->sizeDriveLayoutEx = sifDisk->sizeDriveLayoutEx;
            sifDisk->AssignedTo->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_MBR;

            if (sifDisk->IsAligned) {
                sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount = sifDisk->pDriveLayoutEx->PartitionCount;
                sifDisk->AssignedTo->pDriveLayoutEx->Mbr.Signature = sifDisk->pDriveLayoutEx->Mbr.Signature;

                //
                // Cylinder-snap the partition boundaries
                //
                endingOffset = AsrpCylinderAlignMbrPartitions(
                    sifDisk,
                    sifDisk->AssignedTo->pDriveLayoutEx,
                    0,      // starting index--0 for the MBR
                    0,      // starting offset, assume the partitions begin at the start of the disk
                    sifDisk->AssignedTo->pDiskGeometry
                    );

                MYASSERT(endingOffset != -1);
                if (-1 == endingOffset) {

                    AsrpPrintDbgMsg(_asrlog, 
                        "Partitions on disk %lu in section [%ws] could not be restored.\r\n", 
                        sifDisk->SifDiskKey,
                        ASR_SIF_MBR_DISKS_SECTION
                        );

                    if (AllOrNothing) {
                        SetLastError(ERROR_HANDLE_DISK_FULL);
                        return FALSE;
                    }
                    else {
                        sifDisk = sifDisk->pNext;
                        continue;
                    }

                }

                MYASSERT(endingOffset <= sifDisk->AssignedTo->pPartition0Ex->PartitionLength.QuadPart);
                if ((endingOffset) > (sifDisk->AssignedTo->pPartition0Ex->PartitionLength.QuadPart)) {

                    AsrpPrintDbgMsg(_asrlog, 
                        "Partitions on disk %lu in section [%ws] could not be restored.\r\n", 
                        sifDisk->SifDiskKey,
                        ASR_SIF_MBR_DISKS_SECTION
                        );
 
                    if (AllOrNothing) {
                        SetLastError(ERROR_HANDLE_DISK_FULL);
                        return FALSE;
                    }
                    else {
                        sifDisk = sifDisk->pNext;
                        continue;
                    }

                }

                if (AllowAutoExtend) {
                    AsrpAutoExtendMbrPartitions(sifDisk, sifDisk->AssignedTo, endingOffset);
                }

                //
                // Now, we need to go through our partition list, and update the start sector
                // for the partitions in that list.  This is needed since we use the start
                // sector later to assign the volume guids to the partitions.
                //
                pCurrentPtn = pSifMbrPtnList[sifDisk->SifDiskKey].pOffsetHead;
                while (pCurrentPtn) {

                    pCurrentPtn->PartitionInfo.StartingOffset.QuadPart =
                        sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[pCurrentPtn->SlotIndex].StartingOffset.QuadPart;

                    pCurrentPtn->PartitionInfo.PartitionLength.QuadPart =
                        sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[pCurrentPtn->SlotIndex].PartitionLength.QuadPart;

                    pCurrentPtn = pCurrentPtn->pOffsetNext;
                }
            }
            else {
                //
                // The partitions didn't fit when we cylinder-aligned them.  
                // However, the current disk geometry is identical to the 
                // original disk geometry, so we can recreate the partitions
                // exactly the way they were before.  Let's just copy over
                // the partition layout.
                //
                CopyMemory(sifDisk->AssignedTo->pDriveLayoutEx, 
                    sifDisk->pDriveLayoutEx, 
                    sifDisk->sizeDriveLayoutEx
                    );

                for (index = 0; index < sifDisk->pDriveLayoutEx->PartitionCount; index++) {

                    sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[index].RewritePartition = TRUE;

                }
            }

        }
        else if (PARTITION_STYLE_GPT == sifDisk->Style) {
            DWORD sizeNewDriveLayoutEx = 0;
            PDRIVE_LAYOUT_INFORMATION_EX pNewDriveLayoutEx = NULL;

/*

            The MaxPartitionCount values are different for the two disks.  We can't do
            much here, so we'll just ignore it.
          
            if ((PARTITION_STYLE_GPT == sifDisk->AssignedTo->Style) &&
                (sifDisk->pDriveLayoutEx->Gpt.MaxPartitionCount
                > sifDisk->AssignedTo->pDriveLayoutEx->Gpt.MaxPartitionCount)) {

                MYASSERT(0 && L"Not yet implemented: sifdisk MaxPartitionCount > physicalDisk->MaxPartitionCount");
                sifDisk = sifDisk->pNext;
                continue;
            }
*/
            //
            // Allocate a pDriveLayoutEx struct large enough to hold all the partitions on both
            // the sif disk and the physical disk.
            //
            sizeNewDriveLayoutEx =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                (sizeof(PARTITION_INFORMATION_EX) *
                (sifDisk->pDriveLayoutEx->PartitionCount +
                sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount - 1 )
                );

            pNewDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeNewDriveLayoutEx
                );
            if (!pNewDriveLayoutEx) {
                return FALSE;
            }

            preserveIndex = 0;
            if (!sifDisk->IsIntact && !AsrpIsOkayToEraseDisk(sifDisk->AssignedTo)) {

                //
                // This disk is not intact, but it has partitions that must be preserved.
                //
                if (!AsrpFitGptPartitionsToRegions(sifDisk, sifDisk->AssignedTo, TRUE)) {

                    AsrpPrintDbgMsg(_asrlog, 
                        "Partitions on disk %lu in section [%ws] could not be restored.\r\n", 
                        sifDisk->SifDiskKey,
                        ASR_SIF_GPT_DISKS_SECTION
                        );
 
                    MYASSERT(0 && L"AsrpFitGptPartitionsToRegions failed for assigned disk");

                    if (AllOrNothing) {
                        SetLastError(ERROR_HANDLE_DISK_FULL);
                        return FALSE;
                    }
                    else {
                        sifDisk = sifDisk->pNext;
                        continue;
                    }

                 }

                //
                // Now, we need to go through our partition list, and update the start sector
                // for the partitions in that list.  This is needed since we use the start
                // sector later to assign the volume guids to the partitions.
                //
                // The start sectors could've changed because the physical disk may have had
                // un-erasable partitions.
                //
                pCurrentPtn = pSifGptPtnList[sifDisk->SifDiskKey].pOffsetHead;
                while (pCurrentPtn) {

                    pCurrentPtn->PartitionInfo.StartingOffset.QuadPart =
                        sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[pCurrentPtn->SlotIndex].StartingOffset.QuadPart;

                    pCurrentPtn->PartitionInfo.PartitionLength.QuadPart =
                        sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[pCurrentPtn->SlotIndex].PartitionLength.QuadPart;

                    pCurrentPtn = pCurrentPtn->pOffsetNext;

                }


                //
                // Move the non-erasable partitions on the physical disks up to the beginning.
                //
                for (index = 0; index < sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount; index++) {

                    pCurrentEntry = &(sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[index]);

                    if (!AsrpIsOkayToErasePartition(pCurrentEntry)) {

                        if (preserveIndex == index) {
                            preserveIndex++;
                            continue;
                        }

                        memmove(&(pNewDriveLayoutEx->PartitionEntry[preserveIndex]),
                            &(sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[index]),
                            sizeof(PARTITION_INFORMATION_EX)
                            );
                        preserveIndex++;

                    }
                    else {
                        //
                        // This partition can be erased.
                        //
                        pCurrentEntry->StartingOffset.QuadPart = 0;
                        pCurrentEntry->PartitionLength.QuadPart = 0;
                    }
                }   // for

            }  // if !IsIntact

            //
            // Now that we've copied over entries of interest to the new
            // drivelayoutex struct, we can get rid of the old one.
            //
            _AsrpHeapFree(sifDisk->AssignedTo->pDriveLayoutEx);
            sifDisk->AssignedTo->sizeDriveLayoutEx = sizeNewDriveLayoutEx;
            sifDisk->AssignedTo->pDriveLayoutEx = pNewDriveLayoutEx;

            //
            // Copy over the sif partition table to the physicalDisk
            //
            memcpy(&(sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[preserveIndex]),
                &(sifDisk->pDriveLayoutEx->PartitionEntry[0]),
                sizeof(PARTITION_INFORMATION_EX) * (sifDisk->pDriveLayoutEx->PartitionCount)
                );

            sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount = sifDisk->pDriveLayoutEx->PartitionCount + preserveIndex;
            sifDisk->AssignedTo->sizeDriveLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX) * (sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount - 1));

            sifDisk->AssignedTo->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_GPT;

            memcpy(&(sifDisk->AssignedTo->pDriveLayoutEx->Gpt.DiskId),
                &(sifDisk->pDriveLayoutEx->Gpt.DiskId),
                sizeof(GUID)
                );

        }
        else {
            MYASSERT(0 && L"Unrecognised partitioning style (neither MBR nor GPT)");
        }

        sifDisk = sifDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpCreateMountPoint(
    IN DWORD DiskNumber,
    IN DWORD PartitionNumber,
    IN PCWSTR szVolumeGuid
    )


/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PMOUNTMGR_CREATE_POINT_INPUT inputCreatePoint = NULL;
    PMOUNTMGR_MOUNT_POINT inputDeletePoint = NULL;
    PMOUNTMGR_MOUNT_POINTS outputDeletePoint = NULL;
    WCHAR deviceName[ASR_CCH_DEVICE_PATH_FORMAT];
    PMOUNTMGR_MOUNT_POINTS  mountPointsOut  = NULL;

    INT attempt = 0;
    
    DWORD cbName = 0;
    PWSTR lpName = NULL;
    DWORD cbDeletePoint = 0;

    USHORT sizeGuid = 0,
        sizeDeviceName = 0;

    DWORD bytes = 0, index = 0,
        status = ERROR_SUCCESS;

    HANDLE mpHandle = NULL,
        heapHandle = GetProcessHeap();

    BOOL result = TRUE;

    if (!szVolumeGuid || !wcslen(szVolumeGuid)) {
        return TRUE;
    }

    //
    // Open the mount manager
    //
    mpHandle = CreateFileW(
        (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,      // lpFileName
        GENERIC_READ | GENERIC_WRITE,           // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE,     // dwShareMode
        NULL,                       // lpSecurityAttributes
        OPEN_EXISTING,              // dwCreationFlags
        FILE_ATTRIBUTE_NORMAL,      // dwFlagsAndAttributes
        INVALID_HANDLE_VALUE        // hTemplateFile
        );
    _AsrpErrExitCode((!mpHandle || INVALID_HANDLE_VALUE == mpHandle), status, GetLastError());

    swprintf(deviceName, ASR_WSZ_DEVICE_PATH_FORMAT, DiskNumber, PartitionNumber);
    
    sizeDeviceName = wcslen(deviceName) * sizeof(WCHAR);
    sizeGuid = wcslen(szVolumeGuid) * sizeof(WCHAR);


    //
    // There is a small window after a partition is created in which the 
    // device-path to it (\Device\HarddiskX\PartitionY) doesn't exist, and
    // a small window in which the device-path is actually pointing to 
    // the wrong object.  (Partmgr first creates the path, <small window>,
    // assigns it to the correct object)
    // 
    // Since this will cause CREATE_POINT to fail later with FILE_NOT_FOUND,
    // lets wait till mountmgr sees the device object.
    //
    result = FALSE;
    while ((!result) && (++attempt < 120)) {

        result = AsrpGetMountPoints(deviceName, sizeDeviceName + sizeof(WCHAR), &mountPointsOut);
        if (!result) {
            Sleep(500);
        }
    }

    outputDeletePoint = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        ASR_BUFFER_SIZE
        );
    _AsrpErrExitCode(!outputDeletePoint, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // The mountmgr assigns a volume-GUID symbolic link (\??\Volume{Guid}) to
    // a basic partition as soon as it's created.  In addition, we will re-
    // create the symbolic link that the partition originally used to have 
    // (as stored in asr.sif).
    //
    // This will lead to the partition having two volume-GUID's at the end.
    // This is wasteful, but generally harmless to the system--however, the 
    // ASR test verification scripts get numerous false hits because of the
    // additional GUID.
    //
    // To fix this, we delete the new mountmgr assigned-GUID before restoring 
    // the original GUID for the partition from asr.sif.  
    //
    if ((result) && (mountPointsOut)) {

        for (index = 0; index < mountPointsOut->NumberOfMountPoints; index++) {

            lpName = (PWSTR) (((LPBYTE)mountPointsOut) + mountPointsOut->MountPoints[index].SymbolicLinkNameOffset);
            cbName = (DWORD) mountPointsOut->MountPoints[index].SymbolicLinkNameLength;

            if (!_AsrpIsVolumeGuid(lpName, cbName)) {
                continue;
            }

            //
            // We found a link that looks like a volume GUID 
            //
            cbDeletePoint = sizeof(MOUNTMGR_MOUNT_POINT) +
                mountPointsOut->MountPoints[index].SymbolicLinkNameLength +
                mountPointsOut->MountPoints[index].UniqueIdLength +
                mountPointsOut->MountPoints[index].DeviceNameLength;

            inputDeletePoint = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                cbDeletePoint
                );
            _AsrpErrExitCode(!inputDeletePoint, status, ERROR_NOT_ENOUGH_MEMORY);

            //
            // Set the fields to match the current link
            //
            inputDeletePoint->SymbolicLinkNameOffset = 
                sizeof(MOUNTMGR_MOUNT_POINT);
            inputDeletePoint->SymbolicLinkNameLength = 
                mountPointsOut->MountPoints[index].SymbolicLinkNameLength;
            CopyMemory(
                ((LPBYTE)inputDeletePoint) + 
                    inputDeletePoint->SymbolicLinkNameOffset,
                ((LPBYTE)mountPointsOut) + 
                    mountPointsOut->MountPoints[index].SymbolicLinkNameOffset,
                inputDeletePoint->SymbolicLinkNameLength);

            inputDeletePoint->UniqueIdOffset = 
                inputDeletePoint->SymbolicLinkNameOffset + 
                inputDeletePoint->SymbolicLinkNameLength;
            inputDeletePoint->UniqueIdLength = 
                mountPointsOut->MountPoints[index].UniqueIdLength;
            CopyMemory(
                ((LPBYTE)inputDeletePoint) + 
                    inputDeletePoint->UniqueIdOffset,
                ((LPBYTE)mountPointsOut) + 
                    mountPointsOut->MountPoints[index].UniqueIdOffset,
                inputDeletePoint->UniqueIdLength);

            inputDeletePoint->DeviceNameOffset = 
                inputDeletePoint->UniqueIdOffset +
                inputDeletePoint->UniqueIdLength;
            inputDeletePoint->DeviceNameLength = 
                mountPointsOut->MountPoints[index].DeviceNameLength;
            CopyMemory((
                (LPBYTE)inputDeletePoint) + 
                    inputDeletePoint->DeviceNameOffset,
                ((LPBYTE)mountPointsOut) + 
                    mountPointsOut->MountPoints[index].DeviceNameOffset,
                inputDeletePoint->DeviceNameLength);

            //
            // And delete this link ...
            //
            result = DeviceIoControl(
                mpHandle,
                IOCTL_MOUNTMGR_DELETE_POINTS,
                inputDeletePoint,
                cbDeletePoint,
                outputDeletePoint,
                ASR_BUFFER_SIZE,
                &bytes,
                NULL
                );
            //
            // It's okay if the delete fails.
            //

            GetLastError();     // for debug

            _AsrpHeapFree(inputDeletePoint);
        }
    }


    //
    // Alloc the MountMgr points we need
    //
    inputCreatePoint = (PMOUNTMGR_CREATE_POINT_INPUT) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (MOUNTMGR_CREATE_POINT_INPUT) + sizeDeviceName + sizeGuid
        );
    _AsrpErrExitCode(!inputCreatePoint, status, ERROR_NOT_ENOUGH_MEMORY);

    inputDeletePoint = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof(MOUNTMGR_MOUNT_POINT) + sizeGuid
        );
    _AsrpErrExitCode(!inputDeletePoint, status, ERROR_NOT_ENOUGH_MEMORY);


    //
    // We should delete this volume guid if some other partition
    // already has it, else we'll get an ALREADY_EXISTS error
    // when we try to create it.
    //
    inputDeletePoint->DeviceNameOffset = 0;
    inputDeletePoint->DeviceNameLength = 0;

    inputDeletePoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    inputDeletePoint->SymbolicLinkNameLength = sizeGuid;

    CopyMemory((((LPBYTE)inputDeletePoint) + inputDeletePoint->SymbolicLinkNameOffset),
        ((LPBYTE)szVolumeGuid), 
        inputDeletePoint->SymbolicLinkNameLength
        );

    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_DELETE_POINTS,
        inputDeletePoint,
        sizeof (MOUNTMGR_MOUNT_POINT) + sizeGuid,
        outputDeletePoint,
        ASR_BUFFER_SIZE,
        &bytes,
        NULL
        );
    //
    // It's okay if this fails.
    //
//    _AsrpErrExitCode(!result, status, GetLastError());

    GetLastError();     // for Debug

    //
    // Call IOCTL_MOUNTMGR_CREATE_POINT
    //
    inputCreatePoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    inputCreatePoint->SymbolicLinkNameLength = sizeGuid;

    inputCreatePoint->DeviceNameOffset = inputCreatePoint->SymbolicLinkNameOffset + inputCreatePoint->SymbolicLinkNameLength;
    inputCreatePoint->DeviceNameLength = sizeDeviceName;

    CopyMemory(((LPBYTE)inputCreatePoint) + inputCreatePoint->SymbolicLinkNameOffset,
               szVolumeGuid, inputCreatePoint->SymbolicLinkNameLength);

    CopyMemory(((LPBYTE)inputCreatePoint) + inputCreatePoint->DeviceNameOffset,
               deviceName, inputCreatePoint->DeviceNameLength);

    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_CREATE_POINT,
        inputCreatePoint,
        sizeof (MOUNTMGR_CREATE_POINT_INPUT) + sizeDeviceName + sizeGuid,
        NULL,
        0,
        &bytes,
        NULL
        );
    _AsrpErrExitCode(!result, status, GetLastError());

    //
    // We're done.
    //

EXIT:
    _AsrpCloseHandle(mpHandle);
    _AsrpHeapFree(mountPointsOut);
    _AsrpHeapFree(inputCreatePoint);
    _AsrpHeapFree(inputDeletePoint);
    _AsrpHeapFree(outputDeletePoint);

    return (BOOL) (ERROR_SUCCESS == status);
}


//
// Assigns the volume guid's stored in the partition-list to partitions
// on the physical disk, based on the start sectors
//
BOOL
AsrpAssignVolumeGuids(
    IN PASR_DISK_INFO  pPhysicalDisk,
    IN HANDLE          hDisk,           // open handle to the physical disk
    IN PASR_PTN_INFO   pPtnInfo         // list of partitions--with vol guids ...
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PDRIVE_LAYOUT_INFORMATION_EX pDriveLayoutEx = NULL;
    DWORD sizeDriveLayoutEx = pPhysicalDisk->sizeDriveLayoutEx;

    DWORD index = 0,
        status = ERROR_SUCCESS,
        bytes = 0;

    BOOL result = FALSE,
        found = FALSE;

    PASR_PTN_INFO currentPtn = NULL;

    HANDLE heapHandle = GetProcessHeap();

    //
    // Get the new layout for the physical disk.
    //
    pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeDriveLayoutEx
        );
    _AsrpErrExitCode(!pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

    while (!result) {

        result = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
            NULL,
            0L,
            pDriveLayoutEx,
            sizeDriveLayoutEx,
            &bytes,
            NULL
            );

        if (!result) {
            status = GetLastError();

            _AsrpHeapFree(pDriveLayoutEx);

            // 
            // If the buffer is of insufficient size, resize the buffer.
            //
            if ((ERROR_MORE_DATA == status) || (ERROR_INSUFFICIENT_BUFFER == status)) {

                status = ERROR_SUCCESS;
                sizeDriveLayoutEx += sizeof(PARTITION_INFORMATION_EX) * 4;

                pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                    heapHandle,
                    HEAP_ZERO_MEMORY,
                    sizeDriveLayoutEx
                    );
                _AsrpErrExitCode(!pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);
            }
            else {

                AsrpPrintDbgMsg(_asrlog, 
                    "The drive layout on Harddisk %lu (%ws) could not be determined (%lu).  The volumes on this disk may not be restored completely.\r\n", 
                    pPhysicalDisk->DeviceNumber,
                    pPhysicalDisk->DevicePath,
                    GetLastError()
                    );

                _AsrpErrExitCode(status, status, GetLastError());
            }
        }
    }

    //
    // We have the drive layout.  Now each partition in our list should have
    // an entry in the partition table.  We use the mount manager to set it's
    // volume guid.
    //
    currentPtn = pPtnInfo;
    result = TRUE;
    while (currentPtn) {

        //
        // We only care about partitions that have a volume-guid
        //
        if ((currentPtn->szVolumeGuid) && 
            (wcslen(currentPtn->szVolumeGuid) > 0)
            ) {
        
            //
            // Go through all the partitions on the disk, and find one that 
            // starts at the offset we expect it to.
            //
            found = FALSE;
            index = 0;

            while (!found && (index < pDriveLayoutEx->PartitionCount)) {

                if (pDriveLayoutEx->PartitionEntry[index].StartingOffset.QuadPart
                    == currentPtn->PartitionInfo.StartingOffset.QuadPart) {
                    //
                    // We found the partition, let's set its GUID now
                    //
                    AsrpCreateMountPoint(
                        pPhysicalDisk->DeviceNumber,    // disk number
                        pDriveLayoutEx->PartitionEntry[index].PartitionNumber, // partition number
                        currentPtn->szVolumeGuid    // volumeGuid
                        );

                    found = TRUE;
                }
                else {
                    index++;
                }
            }

            if (!found) {
                result = FALSE;
            }

        }

        currentPtn = currentPtn->pOffsetNext;
    }

    if (!result) {
        //
        // We didn't find a partition
        //

        AsrpPrintDbgMsg(_asrlog, 
            "One or more partitions on Harddisk %lu (%ws) could not be recreated.  The volumes on this disk may not be restored completely.\r\n", 
            pPhysicalDisk->DeviceNumber,
            pPhysicalDisk->DevicePath
            );

        _AsrpErrExitCode(status, status, ERROR_BAD_DEVICE);
    }


EXIT:
    _AsrpHeapFree(pDriveLayoutEx);

    return (BOOL) (ERROR_SUCCESS == status);
}


//
// Re-partitions the disks
//
BOOL
AsrpRecreateDisks(
    IN PASR_DISK_INFO pSifDiskList,
    IN PASR_PTN_INFO_LIST pSifMbrPtnList,
    IN PASR_PTN_INFO_LIST pSifGptPtnList,
    IN BOOL AllOrNothing
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{


    PASR_DISK_INFO  pSifDisk        = pSifDiskList;

    DWORD           bytesReturned   = 0,
                    status          = ERROR_SUCCESS;

    HANDLE          hDisk           = NULL;

    BOOL            result          = TRUE;

    //
    // For each sif disk that isn't intact, go to the physical
    // disk it's assigned to, and recreate that disk
    //
    while (pSifDisk) {

        if (!(pSifDisk->AssignedTo)) {

            AsrpPrintDbgMsg(_asrinfo, 
                "Not recreating disk %lu in section [%ws] (no matching disk found).\r\n", 
                pSifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            if (AllOrNothing) {
                return FALSE;
            }
            else {
                pSifDisk = pSifDisk->pNext;
                continue;
            }
        }

        if ((pSifDisk->IsCritical) ||
            (pSifDisk->AssignedTo->IsCritical)) {

            AsrpPrintDbgMsg(_asrinfo, 
                "Not recreating Harddisk %lu (disk %lu in section [%ws]) (critical disk).\r\n", 
                pSifDisk->AssignedTo->DeviceNumber,
                pSifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            pSifDisk = pSifDisk->pNext;
            continue;
        }

        //
        // Open physical disk
        //
        hDisk = CreateFileW(
            pSifDisk->AssignedTo->DevicePath,   // lpFileName
            GENERIC_WRITE | GENERIC_READ,       // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,           // lpSecurityAttributes
            OPEN_EXISTING,  // dwCreationFlags
            0,              // dwFlagsAndAttributes
            NULL            // hTemplateFile
            );
        if ((!hDisk) || (INVALID_HANDLE_VALUE == hDisk)) {
            //
            // We couldn't open the disk.
            //

            AsrpPrintDbgMsg(_asrlog, 
                "Unable to open Harddisk %lu (%ws) (disk %lu in section [%ws]) (0%lu).\r\n", 
                pSifDisk->AssignedTo->DeviceNumber,
                pSifDisk->AssignedTo->DevicePath,
                pSifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION),
                GetLastError()
                );

            if (AllOrNothing) {
                return FALSE;
            }
            else {
                pSifDisk = pSifDisk->pNext;
                continue;
            }
        }


        if (!(pSifDisk->IsIntact) &&            // disk is not intact
            (pSifDisk->AssignedTo) &&           // matching physical disk was found
            ((PARTITION_STYLE_MBR == pSifDisk->Style) || (PARTITION_STYLE_GPT == pSifDisk->Style))    // not recognised partitioning style
            ) {

            //
            // Delete the old drive layout
            //
            result = DeviceIoControl(
                hDisk,
                IOCTL_DISK_DELETE_DRIVE_LAYOUT,
                NULL,
                0L,
                NULL,
                0L,
                &bytesReturned,
                NULL
                );
            if (!result) {

                AsrpPrintDbgMsg(_asrlog, 
                    "Unable to delete layout on Harddisk %lu (%ws) (disk %lu in section [%ws]) (%lu).\r\n", 
                    pSifDisk->AssignedTo->DeviceNumber,
                    pSifDisk->AssignedTo->DevicePath,
                    pSifDisk->SifDiskKey,
                    ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION),
                    GetLastError()
                    );

                GetLastError();
            }

            //
            //  If we're converting an MBR to a GPT, then we need to call
            //  IOCTL_DISK_CREATE_DISK first
            //

            if ((PARTITION_STYLE_GPT == pSifDisk->Style) &&
                (PARTITION_STYLE_MBR == pSifDisk->AssignedTo->Style)) {

                CREATE_DISK CreateDisk;

                CreateDisk.PartitionStyle = PARTITION_STYLE_GPT;
                memcpy(&(CreateDisk.Gpt.DiskId), &(pSifDisk->pDriveLayoutEx->Gpt.DiskId), sizeof(GUID));
                CreateDisk.Gpt.MaxPartitionCount =  pSifDisk->pDriveLayoutEx->Gpt.MaxPartitionCount;

                result = DeviceIoControl(
                    hDisk,
                    IOCTL_DISK_CREATE_DISK,
                    &(CreateDisk),
                    sizeof(CREATE_DISK),
                    NULL,
                    0L,
                    &bytesReturned,
                    NULL
                    );

                if (!result) {
                    //
                    // CREATE_DISK failed
                    //

                    status = GetLastError();
                    AsrpPrintDbgMsg(_asrlog, 
                        "Unable to initialize disk layout on Harddisk %lu (%ws) (disk %lu in section [%ws]) (0%lu).\r\n", 
                        pSifDisk->AssignedTo->DeviceNumber,
                        pSifDisk->AssignedTo->DevicePath,
                        pSifDisk->SifDiskKey,
                        ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION),
                        GetLastError()
                        );

                    _AsrpCloseHandle(hDisk);
                    SetLastError(status);

                    if (AllOrNothing) {
                        return FALSE;
                    }
                    else {
                        pSifDisk = pSifDisk->pNext;
                        continue;
                    }
                }
            }

            //
            // Set the new drive layout
            //
            result = DeviceIoControl(
                hDisk,
                IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                pSifDisk->AssignedTo->pDriveLayoutEx,
                pSifDisk->AssignedTo->sizeDriveLayoutEx,
                NULL,
                0L,
                &bytesReturned,
                NULL
                );

            if (!result) {
                //
                // SET_DRIVE_LAYOUT failed
                //
                status = GetLastError();
                AsrpPrintDbgMsg(_asrlog, 
                    "Unable to set drive layout on Harddisk %lu (%ws) (disk %lu in section [%ws]) (0%lu).\r\n", 
                    pSifDisk->AssignedTo->DeviceNumber,
                    pSifDisk->AssignedTo->DevicePath,
                    pSifDisk->SifDiskKey,
                    ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION),
                    GetLastError()
                    );

                _AsrpCloseHandle(hDisk);
                SetLastError(status);

                if (AllOrNothing) {
                    return FALSE;
                }
                else {
                    pSifDisk = pSifDisk->pNext;
                    continue;
                }
            }
        }

        //
        // Now we need to recreate the volumeGuids for each partition
        //
        result = AsrpAssignVolumeGuids(
            pSifDisk->AssignedTo,
            hDisk,
            ((PARTITION_STYLE_MBR == pSifDisk->Style) ?
                (pSifMbrPtnList[pSifDisk->SifDiskKey].pOffsetHead) :
                (pSifGptPtnList[pSifDisk->SifDiskKey].pOffsetHead))
            );

        //
        // We don't care about the result ...
        //
        MYASSERT(result && L"AsrpAssignVolumeGuids failed");

        _AsrpCloseHandle(hDisk);

        //
        // Get the next drive from the drive list.
        //
        pSifDisk = pSifDisk->pNext;
    }

    return TRUE;
}


//
//  Restore Non Critical Disks
//
//
BOOL
AsrpRestoreNonCriticalDisksW(
    IN PCWSTR   lpSifPath,
    IN BOOL     bAllOrNothing
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    BOOL    result = FALSE;

    PWSTR   asrSifPath      = NULL;

    //
    // We have two lists of disks--one of all the physical disks
    // currently on the system, and the other constructed from the
    // sif file.  The goal is to reconfigure non-critical disks in
    // the pPhysicalDiskList to match the pSifDiskList
    //
    PASR_DISK_INFO pSifDiskList = NULL,
        pPhysicalDiskList = NULL;

    PASR_PTN_INFO_LIST  pSifMbrPtnList = NULL,
        pSifGptPtnList = NULL;

    DWORD  cchAsrSifPath = 0,
        MaxDeviceNumber = 0,     // not used
        status = ERROR_SUCCESS;

    BOOL    bAutoExtend = FALSE,
        allOrNothing = FALSE;

    HANDLE  heapHandle = GetProcessHeap();

    SetLastError(ERROR_CAN_NOT_COMPLETE);

    if (!AsrIsEnabled()) {
        //
        // If we're not in GUI-mode ASR, we need to open the log files first
        //
        AsrpInitialiseErrorFile();
        AsrpInitialiseLogFile();
    }

    AsrpPrintDbgMsg(_asrlog, "Attempting to restore non-critical disks.\r\n");

    if (!lpSifPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto EXIT;
    }

    cchAsrSifPath = wcslen(lpSifPath);
    //
    // Do a sanity check:  we don't want to allow a file path
    // more than 4096 characters long.
    //
    if (cchAsrSifPath > ASR_SIF_ENTRY_MAX_CHARS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto EXIT;
    }

    asrSifPath = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        ((cchAsrSifPath + 1) * sizeof(WCHAR))
        );
    _AsrpErrExitCode(!asrSifPath, status, ERROR_NOT_ENOUGH_MEMORY);

    wcsncpy(asrSifPath, lpSifPath, cchAsrSifPath);

    allOrNothing = bAllOrNothing;

    AsrpPrintDbgMsg(_asrlog, "ASR state file: \"%ws\".  AllOrNothing: %lu\r\n",
        asrSifPath, allOrNothing);

    //
    // The function calls are AND'ed below, hence if one fails, the
    // calls after it will not be executed (exactly the behaviour we
    // want).
    //
    result = (

        //
        // Build the original disk info from the sif file
        //
        AsrpBuildMbrSifDiskList(asrSifPath, &pSifDiskList, &pSifMbrPtnList, &bAutoExtend)

        && AsrpBuildGptSifDiskList(asrSifPath, &pSifDiskList, &pSifGptPtnList)

        //
        // Build the list of current disks present on the target machine
        //
        && AsrpInitDiskInformation(&pPhysicalDiskList)

        //
        // Fill in the partition info for the fixed disks on the target machine
        // and remove non-fixed devices
        //
        && AsrpInitLayoutInformation(NULL, pPhysicalDiskList, &MaxDeviceNumber, TRUE)

        && AsrpFreeNonFixedMedia(&pPhysicalDiskList)

        //
        // Try to determine which sif disk should end up on which physical disk.
        //
        && AsrpAssignDisks(pSifDiskList, pPhysicalDiskList, pSifMbrPtnList, pSifGptPtnList, allOrNothing, bAutoExtend)

        //
        // Finally, repartition the disks and assign the volume guids
        //
        && AsrpRecreateDisks(pSifDiskList, pSifMbrPtnList, pSifGptPtnList, allOrNothing)
    );

    status = GetLastError();
    AsrpFreeStateInformation(&pSifDiskList, NULL);
    AsrpFreeStateInformation(&pPhysicalDiskList, NULL);
    AsrpFreePartitionList(&pSifMbrPtnList);
    AsrpFreePartitionList(&pSifGptPtnList);
    SetLastError(status);

EXIT:

    status = GetLastError();

    if (result) {
        AsrpPrintDbgMsg(_asrinfo, "Done restoring non-critical disks.\r\n");
    }
    else {
        
        AsrpPrintDbgMsg(_asrerror, "Error restoring non-critical disks.  (0x%x)\r\n", status);
        
        if (ERROR_SUCCESS == status) {
            //
            // We're going to return failure, but we haven't set the LastError to 
            // a failure code.  This is bad, since we have no clue what went wrong.
            //
            // We shouldn't ever get here, because the function returning FALSE above
            // should set the LastError as it sees fit.
            // 
            // But I've added this in just to be safe.  Let's set it to a generic
            // error.
            //
            MYASSERT(0 && L"Returning failure, but LastError is not set");
            status = ERROR_CAN_NOT_COMPLETE;
        }
    }

    if (!AsrIsEnabled()) {
        AsrpCloseLogFiles();
    }

    _AsrpHeapFree(asrSifPath);

    SetLastError(status);
    return result;
}


BOOL
AsrpRestoreTimeZoneInformation(
    IN PCWSTR   lpSifPath
    )
/*++

Routine Description:

    Sets the current time-zone, based on the information stored in the SYSTEMS
    section of the ASR state file.

Arguments:

    lpSifPath - Null-terminated string containing the full path to the ASR
            state file (including file name).

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    HINF hSif = NULL;

    BOOL result = FALSE;

    DWORD reqdSize = 0,
        status = ERROR_SUCCESS;

    INFCONTEXT infSystemContext;

    TIME_ZONE_INFORMATION TimeZoneInformation;

    WCHAR szTimeZoneInfo[ASR_SIF_ENTRY_MAX_CHARS+1];

    ZeroMemory(&infSystemContext, sizeof(INFCONTEXT));
    ZeroMemory(&TimeZoneInformation, sizeof(TIME_ZONE_INFORMATION));
    ZeroMemory(&szTimeZoneInfo, sizeof(WCHAR)*(ASR_SIF_ENTRY_MAX_CHARS+1));

    //
    // Open the sif
    //
    hSif = SetupOpenInfFileW(lpSifPath, NULL, INF_STYLE_WIN4, NULL);
    if (NULL == hSif || INVALID_HANDLE_VALUE == hSif) {
        return FALSE;       // sif file couldn't be opened
    }

    //
    // Get the TimeZone strings value
    //
    result = SetupFindFirstLineW(hSif, ASR_SIF_SYSTEM_SECTION, NULL, &infSystemContext);
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // no system section: corrupt asr.sif?
 
    result = SetupGetStringFieldW(&infSystemContext, 7, szTimeZoneInfo, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

    swscanf(szTimeZoneInfo,
        L"%ld %ld %ld %hd-%hd-%hd-%hd %hd:%hd:%hd.%hd %hd-%hd-%hd-%hd %hd:%hd:%hd.%hd",
        &(TimeZoneInformation.Bias),
        &(TimeZoneInformation.StandardBias),
        &(TimeZoneInformation.DaylightBias),

        &(TimeZoneInformation.StandardDate.wYear),
        &(TimeZoneInformation.StandardDate.wMonth),
        &(TimeZoneInformation.StandardDate.wDayOfWeek),
        &(TimeZoneInformation.StandardDate.wDay),

        &(TimeZoneInformation.StandardDate.wHour),
        &(TimeZoneInformation.StandardDate.wMinute),
        &(TimeZoneInformation.StandardDate.wSecond),
        &(TimeZoneInformation.StandardDate.wMilliseconds),

        &(TimeZoneInformation.DaylightDate.wYear),
        &(TimeZoneInformation.DaylightDate.wMonth),
        &(TimeZoneInformation.DaylightDate.wDayOfWeek),
        &(TimeZoneInformation.DaylightDate.wDay),

        &(TimeZoneInformation.DaylightDate.wHour),
        &(TimeZoneInformation.DaylightDate.wMinute),
        &(TimeZoneInformation.DaylightDate.wSecond),
        &(TimeZoneInformation.DaylightDate.wMilliseconds)
        );

    result = SetupGetStringFieldW(&infSystemContext, 8, TimeZoneInformation.StandardName, 32, &reqdSize);
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

    result = SetupGetStringFieldW(&infSystemContext, 9, TimeZoneInformation.DaylightName, 32, &reqdSize);
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

    result = SetTimeZoneInformation(&TimeZoneInformation);
    if (!result) {
        GetLastError();
    }
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

EXIT:

    if (ERROR_SUCCESS != status) {
        SetLastError(status);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\asrbkup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    asrbkup.c

Abstract:

    This module contains the following ASR routines:
        AsrCreateStateFile{A|W}
        AsrAddSifEntry{A|W}
        AsrFreeContext


Author:

    Guhan Suriyanarayanan (guhans)  27-May-2000

Environment:

    User-mode only.

Notes:

    Naming conventions:
        _AsrpXXX    private ASR Macros
        AsrpXXX     private ASR routines
        AsrXXX      Publically defined and documented routines

Revision History:
    
    27-May-2000 guhans  
        Moved ASR-backup related routines from asr.c to 
        asrbkup.c

    01-Jan-2000 guhans
        Initial implementation for Asr routines in asr.c

--*/
#include "setupp.h"
#pragma hdrstop

#include <initguid.h>   // DiskClassGuid
#include <diskguid.h>   // GPT partition type guids
#include <ntddvol.h>    // ioctl_volume_query_failover_set
#include <setupapi.h>   // SetupDi routines
#include <mountmgr.h>   // mountmgr ioctls
#include <rpcdce.h>     // UuidToStringW, RpcStringFreeW
#include <winasr.h>     // ASR public routines

#define THIS_MODULE 'B'
#include "asrpriv.h"    // Private ASR definitions and routines


//
// --------
// constants local to this module. These are not accessed outside this file.
// --------
//

//
// The Setup Key to find the system partition from
//
const WCHAR ASR_REGKEY_SETUP[]              = L"SYSTEM\\SETUP";
const WCHAR ASR_REGVALUE_SYSTEM_PARTITION[] = L"SystemPartition";

//
// The ASR registry entries.  Currently, this is used to look 
// up the commands to run during an Asr backup, but we could
// have other settings here later.
//
const WCHAR ASR_REGKEY_ASR_COMMANDS[]   
    = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\Commands";

const WCHAR ASR_REGKEY_ASR[]            
    = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\";

const WCHAR ASR_REGVALUE_TIMEOUT[]          = L"ProcessTimeOut";

//
// File to save the PnP information in.
//
const WCHAR ASR_DEFAULT_SIF_PATH[]          = L"\\\\?\\%systemroot%\\repair\\asr.sif";
const WCHAR ASRPNP_DEFAULT_SIF_NAME[]       = L"asrpnp.sif";

//
// We only support x86, AMD64, and IA64 architectures.
//
const WCHAR ASR_PLATFORM_X86[]              = L"x86";
const WCHAR ASR_PLATFORM_AMD64[]            = L"AMD64";
const WCHAR ASR_PLATFORM_IA64[]             = L"IA64";

//
// This is the suffix that we add when launching the apps registered for ASR.
// Remember to change the length if you're changing this.  The length should
// include space for 20 digits (max 64-bit int) + null + space at the beginning.
//
#define ASR_COMMANDLINE_SUFFIX_LEN  35
const WCHAR ASR_COMMANDLINE_SUFFIX[]        = L" /context=%I64u";

//
// Miscellaneous constants
//
const WCHAR ASR_DOS_DEVICES_PREFIX[]        = L"\\DosDevices\\";
const WCHAR ASR_DEVICE_PATH_PREFIX[]        = L"\\Device\\Harddisk";

//
// Sections in asr.sif
//
const WCHAR ASR_SIF_VERSION_SECTION_NAME[]          = L"[VERSION]";
const WCHAR ASR_SIF_SYSTEM_SECTION_NAME[]           = L"[SYSTEMS]";
const WCHAR ASR_SIF_BUSES_SECTION_NAME[]            = L"[BUSES]";
const WCHAR ASR_SIF_MBR_DISKS_SECTION_NAME[]        = L"[DISKS.MBR]";
const WCHAR ASR_SIF_GPT_DISKS_SECTION_NAME[]        = L"[DISKS.GPT]";
const WCHAR ASR_SIF_MBR_PARTITIONS_SECTION_NAME[]   = L"[PARTITIONS.MBR]";
const WCHAR ASR_SIF_GPT_PARTITIONS_SECTION_NAME[]   = L"[PARTITIONS.GPT]";


const WCHAR ASR_SIF_PROVIDER_PREFIX[]       = L"Provider=";

// wcslen("Provider=""\r\n\0")
#define ASR_SIF_CCH_PROVIDER_STRING 14


//
// While launching registered applications during an ASR backup, we
// add two environment variables to the environment block for the 
// process being launched:  the AsrContext and the critical volume
// list.
//
#define ASR_CCH_ENVBLOCK_ASR_ENTRIES (32 + 1 + 28 + 2)
const WCHAR ASR_ENVBLOCK_CONTEXT_ENTRY[]    = L"_AsrContext=%I64u";

const WCHAR ASR_ENVBLOCK_CRITICAL_VOLUME_ENTRY[] 
    = L"_AsrCriticalVolumeList=";

//
// Pre-defined flags designating the boot and system partitions
// in the partitions section of asr.sif.  Remember to change the
// counter-parts in setupdd.sys if you change these!
//
const BYTE  ASR_FLAGS_BOOT_PTN              = 1;
const BYTE  ASR_FLAGS_SYSTEM_PTN            = 2;

//
// For now, we only allow one system per sif file.  If a sif
// already exists at the location AsrCreateStateFile is called,
// the existing sif is deleted.  The asr.sif architecture does
// allow for multiple systems per sif file, but
// - I don't see any compelling reason to support this, and
// - It would be a test nightmare
//
const BYTE  ASR_SYSTEM_KEY                  = 1;

//
// _AsrpCheckTrue: primarily used with WriteFile calls.
//
#define _AsrpCheckTrue( Expression )    \
    if (!Expression) {                  \
        return FALSE;                   \
    }                               

//
// --------
// constants used across asr modules.
// --------
//
const WCHAR ASR_SIF_SYSTEM_SECTION[]            = L"SYSTEMS";
const WCHAR ASR_SIF_BUSES_SECTION[]             = L"BUSES";
const WCHAR ASR_SIF_MBR_DISKS_SECTION[]         = L"DISKS.MBR";
const WCHAR ASR_SIF_GPT_DISKS_SECTION[]         = L"DISKS.GPT";
const WCHAR ASR_SIF_MBR_PARTITIONS_SECTION[]    = L"PARTITIONS.MBR";
const WCHAR ASR_SIF_GPT_PARTITIONS_SECTION[]    = L"PARTITIONS.GPT";

const WCHAR ASR_WSZ_VOLUME_PREFIX[]             
    = L"\\??\\Volume";

const WCHAR ASR_WSZ_DEVICE_PATH_FORMAT[]    
    = L"\\Device\\Harddisk%d\\Partition%d";

//
// --------
// function prototypes
// --------
//

//
// Function prototype for AsrCreatePnpStateFileW.
// (linked into syssetup.dll from pnpsif.lib)
//
BOOL
AsrCreatePnpStateFileW(
    IN  PCWSTR    lpFilePath
    );


//
// --------
// private functions
// --------
//

BOOL
AsrpGetMountPoints(
    IN  PCWSTR DeviceName,
    IN  CONST DWORD  SizeDeviceName,
    OUT PMOUNTMGR_MOUNT_POINTS  *pMountPointsOut
    )

/*++

Routine Description:

    Returns the current list of mount-points for DeviceName, by querying the 
    mount manager.

Arguments:

    DeviceName - The device name that the mount-point list is requested for.  
            Typically, this is something of the form 
            \Device\HarddiskX\PartitionY or \DosDevices\X:

    SizeDeviceName - The size, in bytes, of DeviceName.  This includes the
            terminating null character.

    pMountPointsOut - Receives the output list of mount-points.  The caller 
            must free this memory by calling HeapFree for the current process 
            heap.

Return Values:
   
    TRUE, if everything went well.  MountPointsOut contains the promised data.

    FALSE, if the mount manager returned an error.  MountPoints is NULL.  Call
            GetLastError() for more information.

--*/

{
    PMOUNTMGR_MOUNT_POINT   mountPointIn    = NULL;
    PMOUNTMGR_MOUNT_POINTS  mountPointsOut  = NULL;
    MOUNTMGR_MOUNT_POINTS   mountPointsTemp;
    DWORD   mountPointsSize                 = 0;

    HANDLE  mpHandle                        = NULL;
    HANDLE  heapHandle                      = NULL;

    ULONG   index                           = 0;
    LONG    status                          = ERROR_SUCCESS;
    BOOL    result                          = FALSE;

    memset(&mountPointsTemp, 0L, sizeof(MOUNTMGR_MOUNT_POINTS));

    MYASSERT(pMountPointsOut);
    *pMountPointsOut = NULL;

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    mountPointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (MOUNTMGR_MOUNT_POINT) + (SizeDeviceName - sizeof(WCHAR))
        );
    _AsrpErrExitCode((!mountPointIn), status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Try with a decently sized mountPoints out: if it isn't big
    // enough, we'll realloc as needed
    //
    mountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (MAX_PATH + 1) * (sizeof(WCHAR))
        );
    _AsrpErrExitCode(!mountPointsOut, status, ERROR_NOT_ENOUGH_MEMORY);

    // 
    // Get a handle to the mount manager
    //
    mpHandle = CreateFileW(
        MOUNTMGR_DOS_DEVICE_NAME,      // lpFileName
        0,                           // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE,     // dwShareMode
        NULL,                       // lpSecurityAttributes
        OPEN_EXISTING,              // dwCreationFlags
        FILE_ATTRIBUTE_NORMAL,      // dwFlagsAndAttributes
        NULL                        // hTemplateFile
        );
    _AsrpErrExitCode((!mpHandle || INVALID_HANDLE_VALUE == mpHandle), 
        status, 
        GetLastError()
        );

    // 
    // put the DeviceName right after struct mountPointIn
    //
    wcsncpy((PWSTR) (mountPointIn + 1), 
        DeviceName, 
        (SizeDeviceName / sizeof(WCHAR)) - 1
        );
    mountPointIn->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    mountPointIn->DeviceNameLength = (USHORT)(SizeDeviceName - sizeof(WCHAR));

    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        mountPointIn,
        sizeof(MOUNTMGR_MOUNT_POINT) + mountPointIn->DeviceNameLength,
        &mountPointsTemp,
        sizeof(MOUNTMGR_MOUNT_POINTS),
        &mountPointsSize,
        NULL
        );

    while (!result) {

        status = GetLastError();
        
        if (ERROR_MORE_DATA == status) {
            //
            // The buffer is not big enough, re-size and try again
            //
            status = ERROR_SUCCESS;
            _AsrpHeapFree(mountPointsOut);

            mountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                mountPointsTemp.Size
                );
            _AsrpErrExitCode((!mountPointsOut), 
                status, 
                ERROR_NOT_ENOUGH_MEMORY);

            result = DeviceIoControl(
                mpHandle,
                IOCTL_MOUNTMGR_QUERY_POINTS,
                mountPointIn,
                sizeof(MOUNTMGR_MOUNT_POINT) + mountPointIn->DeviceNameLength,
                mountPointsOut,
                mountPointsTemp.Size,
                &mountPointsSize,
                NULL
                );
            _AsrpErrExitCode((!mountPointsSize), status, GetLastError());

        }
        else {
            //
            // If some other error occurred, EXIT.
            //
            result = TRUE;
            status = GetLastError();
//            _AsrpErrExitCode(status, status, GetLastError());
        }
    }


EXIT:
    //
    // Free up locally allocated memory
    //
    _AsrpHeapFree(mountPointIn);

    if (ERROR_SUCCESS != status) {
        //
        // On failure, free up mountPointsOut as well
        //
        _AsrpHeapFree(mountPointsOut);
    }

    _AsrpCloseHandle(mpHandle);

    *pMountPointsOut = mountPointsOut;

    return (BOOL) (ERROR_SUCCESS == status);
}


BOOL
AsrpGetMorePartitionInfo(
    IN  PCWSTR                  DeviceName,
    IN  CONST DWORD             SizeDeviceName,
    IN  CONST PASR_SYSTEM_INFO  pSystemInfo         OPTIONAL,
    OUT PWSTR                   pVolumeGuid,
    OUT USHORT*                 pPartitionFlags     OPTIONAL,
    OUT UCHAR*                  pFileSystemType     OPTIONAL,
    OUT LPDWORD                 pClusterSize        OPTIONAL
    )

/*++

Routine Description:

    Gets additional information about the partition specified by DeviceName, 
    including the volume guid (if any) for the volume that maps to the 
    partition specified by DeviceName.

    If the partition is the current system or boot drive, pPartitionFlags and 
    pFileSystemType are set appropriately.

Arguments:

    DeviceName - A null terminated string containing the device path to the 
            partition, typically of the form \Device\HarddiskX\PartitionY

    SizeDeviceName - Size, in bytes, of DeviceName, including \0 at the end

    pSystemInfo - The SYSTEM_INFO structure for the current system; used for 
            finding out the current system partition.

            This is an optional parameter.  If absent, pPartitionFlags will 
            not have the SYSTEM_FLAG set, even if DeviceName is in fact the 
            system partition.

    pVolumeGuid - Receives a null-terminated string containing the GUID for 
            the volume on this partition.  This is only relevant for basic 
            disks, where volumes and partitions have a one-on-one 
            relationship.  

            This will be set to a blank null-terminated string if there is no 
            volume (or multiple volumes) on this partition.


    *** Note that if ANY of three of the OPTIONAL parameters are not present, 
    NONE of them will be filled with valid data.

    pPartitionFlags - If the current partition is a partition of interest,
            this receives the appropriate flags, IN ADDITION TO THE FLAGS
            ALREADY SET when the routine is called (i.e., caller should 
            usually zero this out). Currently, the two flags of interest are:
            ASR_FLAGS_BOOT_PTN      for the boot partition
            ASR_FLAGS_SYSTEM_PTN    for (you guessed it) the system partition

    pFileSystemType - If (and ONLY if) the current partition is a partition of 
            interest, this will contain a UCHAR to the file-system type of the 
            partition.  Currently, the three file-systems this recognises are:
            PARTITION_HUGE  (FAT)
            PARTITION_FAT32 (FAT32)
            PARTITION_IFS   (NTFS)

    pClusterSize - The file-system cluster size.  Set to 0 if the information
            could not be obtained.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    PMOUNTMGR_MOUNT_POINTS  mountPointsOut  = NULL;
    HANDLE  heapHandle                      = NULL;

    ULONG   index                           = 0;
    LONG    status                          = ERROR_SUCCESS;
    BOOL    result                          = FALSE;
    BOOL    volumeGuidSet                   = FALSE;

    //
    // set OUT variables to known values.
    //
    MYASSERT(pVolumeGuid);
    wcscpy(pVolumeGuid, L"");

/*    if (ARGUMENT_PRESENT(pPartitionFlags)) {
        *pPartitionFlags = 0;
    }
*/

    if (ARGUMENT_PRESENT(pClusterSize)) {
        *pClusterSize = 0;
    }

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    //
    // Open the mount manager, and get a list of all the symbolic links
    // this partition
    //
    result = AsrpGetMountPoints(DeviceName, SizeDeviceName, &mountPointsOut);
    _AsrpErrExitCode((!result), status, GetLastError());
    _AsrpErrExitCode((!mountPointsOut), status, ERROR_SUCCESS);

    //
    // Check if this is the system partition, by comparing the
    // device path with the one stored in the Setup key.
    //
    if (ARGUMENT_PRESENT(pSystemInfo) && ARGUMENT_PRESENT(pPartitionFlags)) {
        
        PWSTR deviceName = (PWSTR) (
            ((LPBYTE) mountPointsOut) +
            mountPointsOut->MountPoints[index].DeviceNameOffset
            );

        UINT sizeDeviceName = 
            (UINT)(mountPointsOut->MountPoints[index].DeviceNameLength);

        if ((pSystemInfo->SystemPath) && 
            (wcslen(pSystemInfo->SystemPath)==sizeDeviceName/sizeof(WCHAR)) && 
            (!wcsncmp(pSystemInfo->SystemPath, deviceName, 
                sizeDeviceName/sizeof(WCHAR)))
            ) {
            *pPartitionFlags |= ASR_FLAGS_SYSTEM_PTN;
        }
    }

    for (index = 0; index < mountPointsOut->NumberOfMountPoints; index++) {

        //
        // Go through the list of mount points returned, and find the one 
        // that looks like an nt volume guid 
        //
        PWSTR linkName = (PWSTR) (((LPBYTE) mountPointsOut) +
            mountPointsOut->MountPoints[index].SymbolicLinkNameOffset
            );

        UINT sizeLinkName = 
            (UINT)(mountPointsOut->MountPoints[index].SymbolicLinkNameLength);

        if ((!volumeGuidSet) &&
            
            !wcsncmp(ASR_WSZ_VOLUME_PREFIX, 
                linkName, 
                wcslen(ASR_WSZ_VOLUME_PREFIX))
            
            ) {
            
            wcsncpy(pVolumeGuid, linkName, sizeLinkName / sizeof(WCHAR));
            volumeGuidSet = TRUE;   // we got a GUID, no need to check again

        }
        else if (
            ARGUMENT_PRESENT(pSystemInfo) && 
            ARGUMENT_PRESENT(pPartitionFlags)
            ) {

            //
            // Also, if this link isn't a GUID, it might be a drive letter.
            // use the boot directory's drive letter to check if this
            // is the boot volume, and mark it if so.
            //

            if (!wcsncmp(ASR_DOS_DEVICES_PREFIX, 
                    linkName, 
                    wcslen(ASR_DOS_DEVICES_PREFIX))
                ) {

                if ((pSystemInfo->BootDirectory) &&
                    (pSystemInfo->BootDirectory[0] 
                        == linkName[wcslen(ASR_DOS_DEVICES_PREFIX)])
                    ) {
                    
                    *pPartitionFlags |= ASR_FLAGS_BOOT_PTN;

                }
            }
        }
    }


EXIT:
    //
    // If this is a partition of interest, we need to get the file-system 
    // type as well
    //
    if (ARGUMENT_PRESENT(pFileSystemType) && 
        ARGUMENT_PRESENT(pPartitionFlags) && 
        ARGUMENT_PRESENT(pClusterSize)
        ) {

        if (*pPartitionFlags) {
            WCHAR fsName[20];
            DWORD dwSectorsPerCluster = 0,
                dwBytesPerSector = 0,
                dwNumFreeClusters = 0,
                dwTotalNumClusters = 0;
            
            // 
            // Convert the NT Volume-GUID (starts with \??\) to a DOS 
            // Volume (begins with a \\?\, and ends with a back-slash),
            // since GetVolumeInformation needs it in this format.
            //
            pVolumeGuid[1] = L'\\'; 
            wcscat(pVolumeGuid, L"\\");

            memset(fsName, 0L, 20*sizeof(WCHAR));
            result = GetVolumeInformationW(pVolumeGuid, NULL, 0L, 
                    NULL, NULL, NULL, fsName, 20);

            if (result) {
                if (!wcscmp(fsName, L"NTFS")) {
                    *pFileSystemType = PARTITION_IFS;
                }
                else if (!wcscmp(fsName, L"FAT32")) {
                    *pFileSystemType = PARTITION_FAT32;
                }
                else if (!wcscmp(fsName, L"FAT")) {
                    *pFileSystemType = PARTITION_HUGE;
                }
                else {
                    *pFileSystemType = 0;
                }
            }
            else {
                GetLastError(); // debug
            }

           result = GetDiskFreeSpace(pVolumeGuid,
                &dwSectorsPerCluster,
                &dwBytesPerSector,
                &dwNumFreeClusters,
                &dwTotalNumClusters
                );
           if (result) {
                *pClusterSize = dwSectorsPerCluster * dwBytesPerSector;
           }
           else {
               GetLastError();  // debug
           }

            // 
            // Convert the guid back to NT namespace, by changing \\?\
            // to \??\ and removing the trailing slash.
            //
            pVolumeGuid[1] = L'?';  
            pVolumeGuid[wcslen(pVolumeGuid)-1] = L'\0';
        }
    }


    //
    // Free up locally allocated data
    //
    _AsrpHeapFree(mountPointsOut);

    //
    // If we hit errors, make sure the VolumeGuid is a blank string.
    //
    if (status != ERROR_SUCCESS) {
        wcscpy(pVolumeGuid, L"");
    }

    return (BOOL) (status == ERROR_SUCCESS);
}


BOOL
AsrpDetermineBuses(
    IN PASR_DISK_INFO pDiskList
    )

/*++

Routine Description:

    This attempts to group the disks based on which bus they are on.  For 
        SCSI disks, this is relatively easy, since it can be based on the 
    location info (port).

    For other disks, we attempt to get the PnP parent node of the disks, and 
    group all disks having the same parent.

    The groups are identified by the SifBusKey field of each disk structure--
    i.e., all disks that have SifBusKey == 1 are on one bus, SifBusKey == 2 
    are on another bus, and so on.  The SifBusKey values are guaranteed to be
    sequential, and not have any holes (i.e., For a system with "n" buses, 
    the SifBusKey values will be 1,2,3,...,n).

    At the end SifBusKey is zero for disks which couldn't be grouped.  

Arguments:

    pDiskList - The ASR_DISK_INFO list of disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/    
    
{
    BOOL    done    = FALSE,
            newPass = TRUE;
    
    ULONG   port = 0,
            sifBusKey = 0;

    DEVINST parent;

    STORAGE_BUS_TYPE busType = BusTypeUnknown;
    PASR_DISK_INFO   pCurrentDisk = pDiskList;

    //
    // The first pass goes through and groups all the scsi disks together.  
    // Note that this works for IDE too, since IDE disks respond to the 
    // IOCTL_SCSI_GET_ADDRESS and appear to us to have valid location info.
    //
    do {

        sifBusKey++;
        pCurrentDisk = pDiskList;
        done    = TRUE;
        newPass = TRUE;

        while (pCurrentDisk) {

            if ((BusTypeUnknown == pCurrentDisk->BusType) ||
                (!pCurrentDisk->pScsiAddress)) {
                pCurrentDisk = pCurrentDisk->pNext;
                continue;
            }

            if (0 == pCurrentDisk->SifBusKey) {

                done = FALSE;

                if (newPass) {
                    pCurrentDisk->SifBusKey = sifBusKey;
                    port = pCurrentDisk->pScsiAddress->PortNumber;
                    busType = pCurrentDisk->BusType;
                    newPass = FALSE;
                }
                else {
                    if ((pCurrentDisk->pScsiAddress->PortNumber == port) &&
                        (pCurrentDisk->BusType == busType)) {
                        pCurrentDisk->SifBusKey = sifBusKey;
                    }
                }
            }

            pCurrentDisk = pCurrentDisk->pNext;
        }
    } while (!done);

    //
    //  By now, the only disks with SifBusKey is 0 are disks for which
    //  pScsiAddress is NULL, ie (most-likely) non SCSI/IDE disks.  Attempt
    //  to group them on the basis of their parent dev node (which is usually
    //  the bus).  We may have to loop through multiple times again.
    //
    --sifBusKey;  // compensate for the last pass above
    do {
        sifBusKey++;
        pCurrentDisk = pDiskList;
        done    = TRUE;
        newPass = TRUE;

        while (pCurrentDisk) {

            if ((BusTypeUnknown == pCurrentDisk->BusType) ||
                (!pCurrentDisk->pScsiAddress)) {

                if ((0 == pCurrentDisk->SifBusKey) 
                    && (pCurrentDisk->ParentDevInst)) {

                    done = FALSE;

                    if (newPass) {
                        pCurrentDisk->SifBusKey = sifBusKey;
                        parent = pCurrentDisk->ParentDevInst;
                        newPass = FALSE;
                    }
                    else {
                        if (pCurrentDisk->ParentDevInst == parent) {
                            pCurrentDisk->SifBusKey = sifBusKey;
                        }
                    }
                }
            }

            pCurrentDisk = pCurrentDisk->pNext;
        }

    } while (!done);

    //
    // Disks that still have SifBusKey = 0 couldn't be grouped.  Either the 
    // BusType is unknown, or the parent node couldn't be found.
    //
    return TRUE;
}


BOOL
AsrpGetDiskLayout(
    IN  CONST HANDLE hDisk,
    IN  CONST PASR_SYSTEM_INFO pSystemInfo,
    OUT PASR_DISK_INFO pCurrentDisk,
    IN  BOOL AllDetails
    )
/*++

Routine Description:

    Fills in the fields of the pCurrentDisk structure with the relevant 
    information about the disk represented by hDisk, by querying the system 
    with the appropriate IOCTL's.

Arguments:

    hDisk - handle to the disk of interest.

    pSystemInfo - The SYSTEM_INFO structure for the current system.
        
    pCurrentDisk - Receives the information about the disk represented by 
            hDisk

    AllDetails - If FALSE, only the pDriveLayout information of pCurrentDisk 
            is filled in.  This is an optimisation that comes in handy when 
            we're dealing with disks on a shared cluster bus.

            If TRUE, all the fields of pCurrentDisk are filled in.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/    
{
    DWORD   index = 0,
            status              = ERROR_SUCCESS;

    DWORD   dwBytesReturned     = 0L,
            bufferLength        = 0L;

    BOOL    result              = FALSE;

    PDISK_GEOMETRY               diskGeometry       = NULL;
    DWORD                        sizeDiskGeometry   = 0L;

    PDRIVE_LAYOUT_INFORMATION_EX driveLayoutEx      = NULL;
    DWORD                        sizeDriveLayoutEx  = 0L;

    STORAGE_DEVICE_NUMBER        deviceNumber;
    DWORD                        sizeDeviceNumber   = 0L;

    PPARTITION_INFORMATION_EX    partition0Ex       = NULL;
    DWORD                        sizePartition0Ex   = 0L;

    PASR_PTN_INFO                pPartitionTable    = NULL;
    DWORD                        sizePartitionTable = 0L;

    STORAGE_PROPERTY_QUERY       propertyQuery;
    STORAGE_DEVICE_DESCRIPTOR    *deviceDesc        = NULL;
    STORAGE_BUS_TYPE             busType            = BusTypeUnknown;

    PSCSI_ADDRESS                scsiAddress        = NULL;

    HANDLE  heapHandle = GetProcessHeap();  // For memory allocations
    MYASSERT(heapHandle);                   // It better not be NULL

    MYASSERT(pCurrentDisk);
    MYASSERT((hDisk) && (INVALID_HANDLE_VALUE != hDisk));

    // 
    // Initialize OUT variables to known values
    //
    pCurrentDisk->Style             = PARTITION_STYLE_RAW;

    pCurrentDisk->pDriveLayoutEx    = NULL;
    pCurrentDisk->sizeDriveLayoutEx = 0L;

    pCurrentDisk->pDiskGeometry     = NULL;
    pCurrentDisk->sizeDiskGeometry  = 0L;

    pCurrentDisk->pPartition0Ex     = NULL;
    pCurrentDisk->sizePartition0Ex  = 0L;

    pCurrentDisk->pScsiAddress      = NULL;
    pCurrentDisk->BusType           = BusTypeUnknown;

    pCurrentDisk->SifBusKey         = 0L;

    SetLastError(ERROR_SUCCESS);

    //
    // Get the device number for this device.  This should succeed even if 
    // this is a clustered disk that this node doesn't own.
    //
    result = DeviceIoControl(
        hDisk,
        IOCTL_STORAGE_GET_DEVICE_NUMBER,
        NULL,
        0,
        &deviceNumber,
        sizeof(STORAGE_DEVICE_NUMBER),
        &sizeDeviceNumber,
        NULL
        );
    _AsrpErrExitCode(!result, status, GetLastError());

    pCurrentDisk->DeviceNumber      = deviceNumber.DeviceNumber;

    //
    // The output buffer for IOCTL_DISK_GET_DRIVE_LAYOUT_EX consists of a
    // DRIVE_LAYOUT_INFORMATION_EX structure as a header, followed by an 
    // array of PARTITION_INFORMATION_EX structures.
    //
    // We initially allocate enough space for the DRIVE_LAYOUT_INFORMATION_EX
    // struct, which contains a single PARTITION_INFORMATION_EX struct, and
    // 3 more PARTITION_INFORMATION_EX structs, since each (MBR) disk will
    // have a minimum of four partitions, even if they are not all in use. 
    // If the disk contains more than four partitions, we'll increase the 
    // buffer size as needed
    //
    bufferLength = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + 
        (sizeof(PARTITION_INFORMATION_EX) * 3);

    driveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        bufferLength
        );
    _AsrpErrExitCode(!driveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

    result = FALSE;
    while (!result) {

        result = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
            NULL,
            0L,
            driveLayoutEx,
            bufferLength,
            &sizeDriveLayoutEx,
            NULL
            );

        if (!result) {
            status = GetLastError();
            _AsrpHeapFree(driveLayoutEx);

            // 
            // If the buffer is of insufficient size, resize the buffer.  
            // Note that get-drive-layout-ex could return error-insufficient-
            // buffer (instead of? in addition to? error-more-data)
            //
            if ((ERROR_MORE_DATA == status) || 
                (ERROR_INSUFFICIENT_BUFFER == status)
                ) {
                status = ERROR_SUCCESS;
                bufferLength += sizeof(PARTITION_INFORMATION_EX) * 4;

                driveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                    heapHandle,
                    HEAP_ZERO_MEMORY,
                    bufferLength
                    );
                _AsrpErrExitCode(!driveLayoutEx, 
                    status, 
                    ERROR_NOT_ENOUGH_MEMORY
                    );
            }
            else {
                // 
                // some other error occurred, EXIT, and go to the next drive.
                //
                result = TRUE;
                status = ERROR_SUCCESS;
            }
        }
        else {

            if (!AllDetails) {
                //
                // If we don't want all the details for this disk, just exit 
                // now.  This is used in the case of clusters, where we don't
                // want to get all the details twice even if the current node 
                // owns the disk
                //
                pCurrentDisk->pDriveLayoutEx    = driveLayoutEx;
                pCurrentDisk->sizeDriveLayoutEx = sizeDriveLayoutEx;

                //
                // Jump to EXIT
                //
                _AsrpErrExitCode(TRUE, status, ERROR_SUCCESS);
            }

            //
            // The disk geometry: so that we can match the bytes-per-sector 
            // value during restore.
            //
            diskGeometry = (PDISK_GEOMETRY) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(DISK_GEOMETRY)
                );
            _AsrpErrExitCode(!diskGeometry, status, ERROR_NOT_ENOUGH_MEMORY);

            result = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                diskGeometry,
                sizeof(DISK_GEOMETRY),
                &sizeDiskGeometry,
                NULL
                );
            _AsrpErrExitCode(!result, status, ERROR_READ_FAULT);


           partition0Ex = (PPARTITION_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(PARTITION_INFORMATION_EX)
                );
           _AsrpErrExitCode(!partition0Ex, status, ERROR_NOT_ENOUGH_MEMORY);

           //
           // Information about partition 0 (the whole disk), to get the true 
           // sector count of the disk
           //
           result = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_PARTITION_INFO_EX,
                NULL,
                0,
                partition0Ex,
                sizeof(PARTITION_INFORMATION_EX),
                &sizePartition0Ex,
                NULL
                );
            _AsrpErrExitCode(!result, status, ERROR_READ_FAULT);

            //
            // Figure out the bus that this disk is on.  This will only be 
            // used to group the disks--all the disks on a bus will be 
            // restored to the same bus if possible
            //
            propertyQuery.QueryType     = PropertyStandardQuery;
            propertyQuery.PropertyId    = StorageDeviceProperty;

            deviceDesc = (STORAGE_DEVICE_DESCRIPTOR *) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                ASR_BUFFER_SIZE
                );
            _AsrpErrExitCode(!deviceDesc, status, ERROR_NOT_ENOUGH_MEMORY);

            result = DeviceIoControl(
                hDisk,
                IOCTL_STORAGE_QUERY_PROPERTY,
                &propertyQuery,
                sizeof(STORAGE_PROPERTY_QUERY),
                deviceDesc,
                ASR_BUFFER_SIZE,
                &dwBytesReturned,
                NULL
                );
            if (result) {
               busType = deviceDesc->BusType;
            }
            _AsrpHeapFree(deviceDesc);

            scsiAddress = (PSCSI_ADDRESS) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(SCSI_ADDRESS)
                );
            _AsrpErrExitCode(!scsiAddress, status, ERROR_NOT_ENOUGH_MEMORY);

            result = DeviceIoControl(
                hDisk,
                IOCTL_SCSI_GET_ADDRESS,
                NULL,
                0,
                scsiAddress,
                sizeof(SCSI_ADDRESS),
                &dwBytesReturned,
                NULL
                );
            if (!result) {      // Not fatal--expected for non SCSI/IDE disks
                _AsrpHeapFree(scsiAddress);
                result = TRUE;
            }
        }
    }

    if (driveLayoutEx) {
        PPARTITION_INFORMATION_EX currentPartitionEx = NULL;
        WCHAR devicePath[MAX_PATH + 1];

        pCurrentDisk->Style = driveLayoutEx->PartitionStyle;

        sizePartitionTable = sizeof(ASR_PTN_INFO) *
            (driveLayoutEx->PartitionCount);

        pPartitionTable = (PASR_PTN_INFO) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizePartitionTable
            );
        _AsrpErrExitCode(!pPartitionTable, status, ERROR_NOT_ENOUGH_MEMORY);

        for (index = 0; index < driveLayoutEx->PartitionCount; index++) {

            currentPartitionEx = &driveLayoutEx->PartitionEntry[index];
            pPartitionTable[index].SlotIndex = index;

            if (currentPartitionEx->PartitionNumber) {
                swprintf(devicePath,
                    ASR_WSZ_DEVICE_PATH_FORMAT,
                    deviceNumber.DeviceNumber,
                    currentPartitionEx->PartitionNumber
                    );

                pPartitionTable[index].PartitionFlags = 0;

                //
                // Check specially for the EFI system partition
                //
                if ((PARTITION_STYLE_GPT == driveLayoutEx->PartitionStyle) &&
                    IsEqualGUID(&(currentPartitionEx->Gpt.PartitionType), &(PARTITION_SYSTEM_GUID))
                    ) { 

                    pPartitionTable[index].PartitionFlags |= ASR_FLAGS_SYSTEM_PTN;
                }

                AsrpGetMorePartitionInfo(
                    devicePath,
                    (wcslen(devicePath)+1) * sizeof(WCHAR), // cb including \0
                    pSystemInfo,
                    pPartitionTable[index].szVolumeGuid,
                    &(pPartitionTable[index].PartitionFlags),
                    &(pPartitionTable[index].FileSystemType),
                    &(pPartitionTable[index].ClusterSize)
                    );

                //
                // Make sure that the file-system type for the EFI system 
                // partition is set to FAT
                //
                if ((PARTITION_STYLE_GPT == driveLayoutEx->PartitionStyle) &&
                    IsEqualGUID(&(currentPartitionEx->Gpt.PartitionType), &(PARTITION_SYSTEM_GUID))
                    ) { 

                    pPartitionTable[index].FileSystemType = PARTITION_HUGE;
                }

                if (pPartitionTable[index].PartitionFlags) {
                    pCurrentDisk->IsCritical = TRUE;
                }
            }
        }
    }

    pCurrentDisk->pDriveLayoutEx    = driveLayoutEx;
    pCurrentDisk->sizeDriveLayoutEx = sizeDriveLayoutEx;

    pCurrentDisk->pDiskGeometry     = diskGeometry;
    pCurrentDisk->sizeDiskGeometry  = sizeDiskGeometry;

    pCurrentDisk->DeviceNumber      = deviceNumber.DeviceNumber;

    pCurrentDisk->pPartition0Ex     = partition0Ex;
    pCurrentDisk->sizePartition0Ex  = sizePartition0Ex;

    pCurrentDisk->pScsiAddress      = scsiAddress;
    pCurrentDisk->BusType           = busType;

    pCurrentDisk->PartitionInfoTable = pPartitionTable;
    pCurrentDisk->sizePartitionInfoTable = sizePartitionTable;

EXIT:
    // 
    // Free up locally allocated memory on failure
    //
    if (status != ERROR_SUCCESS) {
        _AsrpHeapFree(driveLayoutEx);
        _AsrpHeapFree(diskGeometry);
        _AsrpHeapFree(partition0Ex);
        _AsrpHeapFree(scsiAddress);
        _AsrpHeapFree(pPartitionTable);
    }

    //
    // Make sure the last error is set if we are going to return FALSE
    //
    if ((ERROR_SUCCESS != status) && (ERROR_SUCCESS == GetLastError())) {
        SetLastError(status);
    }

    return (BOOL) (status == ERROR_SUCCESS);
}


BOOL
AsrpGetSystemPath(
    IN PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Gets the system partition DevicePath, and fills in the SystemPath field
    of the ASR_SYSTEM_INFO struct, by looking up the HKLM\Setup registry key.
    This key is updated at every boot with the path to the current system 
    device.  The path is of the form
    \Device\Harddisk0\Partition1                (basic disks)
    \Device\HarddiskDmVolumes\DgName\Volume1    (dynamic disks)

Arguments:
    
    pSystemInfo - The SystemPath field of this struct will be filled with
            a pointer to the path to the current system device

Return Value:

    If the function succeeds, the return value is a nonzero value. 
            pSystemInfo->SystemPath is a pointer to a null-terminated string 
            containing the path to the current system device.  The caller is 
            reponsible for freeing this memory with a call to 
            HeapFree(GetProcessHeap(),...).

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError(). pSystemInfo->SystemPath is set 
            to NULL.

--*/

{
    HKEY    regKey              = NULL;
    DWORD   type                = 0L;

    HANDLE  heapHandle          = NULL;
    DWORD   status              = ERROR_SUCCESS;

    PWSTR   systemPartition     = NULL;
    DWORD   cbSystemPartition   = 0L;

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    MYASSERT(pSystemInfo);
    if (!pSystemInfo) {
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    pSystemInfo->SystemPath = NULL;

    // 
    // Open the reg key to find the system partition
    //
    status = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, // hKey
        ASR_REGKEY_SETUP,   // lpSubKey
        0,                  // ulOptions--Reserved, must be 0
        MAXIMUM_ALLOWED,    // samDesired
        &regKey             // phkResult    
        );
    _AsrpErrExitCode(status, status, ERROR_REGISTRY_IO_FAILED);

    //
    // Allocate a reasonably sized buffer for the system partition, to
    // start off with.  If this isn't big enough, we'll re-allocate as
    // needed.
    //
    cbSystemPartition = (MAX_PATH + 1) * sizeof(WCHAR);
    systemPartition = HeapAlloc(heapHandle, 
        HEAP_ZERO_MEMORY, 
        cbSystemPartition
        );

    _AsrpErrExitCode((!systemPartition), status, ERROR_NOT_ENOUGH_MEMORY);

    // 
    // Get the system partition device Name. This is of the form
    //      \Device\Harddisk0\Partition1                (basic disks)
    //      \Device\HarddiskDmVolumes\DgName\Volume1    (dynamic disks)
    //
    status = RegQueryValueExW(
        regKey,
        ASR_REGVALUE_SYSTEM_PARTITION,
        NULL,
        &type,
        (LPBYTE)systemPartition,
        &cbSystemPartition        // \0 is included
        );
    _AsrpErrExitCode((type != REG_SZ), status, ERROR_REGISTRY_IO_FAILED);

    while (ERROR_MORE_DATA == status) {
        //
        // Our buffer wasn't big enough, cbSystemPartition contains 
        // the required size.
        //
        _AsrpHeapFree(systemPartition);
        systemPartition = HeapAlloc(heapHandle, 
            HEAP_ZERO_MEMORY, 
            cbSystemPartition
            );
        _AsrpErrExitCode((!systemPartition), status, ERROR_NOT_ENOUGH_MEMORY);

        status = RegQueryValueExW(
            regKey,
            ASR_REGVALUE_SYSTEM_PARTITION,
            NULL,
            &type,
            (LPBYTE)systemPartition,
            &cbSystemPartition        // \0 is included
            );
    }

EXIT:
    if (regKey) {
        RegCloseKey(regKey);
        regKey = NULL;
    }

    if (ERROR_SUCCESS != status) {
        _AsrpHeapFree(systemPartition);
        return FALSE;
    }
    else {
        pSystemInfo->SystemPath = systemPartition;
        return TRUE;
    }
}


BOOL
AsrpInitSystemInformation(
    IN OUT PASR_SYSTEM_INFO pSystemInfo,
    IN CONST BOOL bEnableAutoExtend
    )

/*++

Routine Description:

    Initialisation routine to allocate memory for various fields in the
    ASR_SYSTEM_INFO structure, and fill them in with the relevant information.

Arguments:
    pSystemInfo - The struct to be filled in with info about the current 
            system.

Return Value:

    If the function succeeds, the return value is a nonzero value.  The caller
            is responsible for freeing memory pointed to by the various 
            pointers in the struct, using HeapFree(GetProcessHeap(),...).

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().  The caller is still responsible
            for checking the fields and releasing any non-NULL pointers using
            HeapFree(GetProcessHeap(),...).

--*/

{
    DWORD cchBootDirectory = 0L,
        reqdSize = 0L;

    BOOL result = FALSE;

    HANDLE heapHandle = GetProcessHeap();

    //
    // Initialise the structure to zeroes
    //
    memset(pSystemInfo, 0L, sizeof (ASR_SYSTEM_INFO));

    //
    //  The auto-extension feature
    //
    pSystemInfo->AutoExtendEnabled = bEnableAutoExtend;

    // 
    // Get the machine name
    //
    pSystemInfo->sizeComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerNameW(pSystemInfo->ComputerName, 
            &(pSystemInfo->sizeComputerName)
        )) {
        //
        // GetComputerName sets LastError
        //
        return FALSE;
    }

    // 
    // Get the Processor Architecture.  We expect the process architecture
    // to be a either x86, amd64, or ia64, so if it doesn't fit in our buffer of
    // six characters, we don't support it anyway.
    //
    pSystemInfo->Platform = HeapAlloc(heapHandle, 
        HEAP_ZERO_MEMORY, 
        6*sizeof(WCHAR)
        );

    if (!pSystemInfo->Platform) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    reqdSize = GetEnvironmentVariableW(L"PROCESSOR_ARCHITECTURE",
        pSystemInfo->Platform,
        6
        );

    if (0 == reqdSize) {
        //
        // We couldn't find the PROCESSOR_ARCHITECTURE variable
        //
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    if (reqdSize > 6) {
        //
        // The architecture didn't fit in our buffer
        //
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    // 
    // Get the OS version
    //
    pSystemInfo->OsVersionEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    result = GetVersionEx((LPOSVERSIONINFO) (&(pSystemInfo->OsVersionEx)));
    if (!result) {
        //
        // GetVersionEx sets the LastError
        //
        return FALSE;
    }

    //
    // Get the boot directory
    //
    pSystemInfo->BootDirectory = HeapAlloc(heapHandle, 
        HEAP_ZERO_MEMORY, 
        (MAX_PATH+1)*sizeof(WCHAR)
        );

    if (!(pSystemInfo->BootDirectory)) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    cchBootDirectory = GetWindowsDirectoryW(pSystemInfo->BootDirectory, 
        MAX_PATH + 1
        );
    if (0 == cchBootDirectory) {
        // 
        // GetWindowsDirectory sets LastError
        //
        return FALSE;
    }

    if (cchBootDirectory > 
        ASR_SIF_ENTRY_MAX_CHARS - MAX_COMPUTERNAME_LENGTH - 26) {
        //
        // We can't write out sif lines that are more than 
        // ASR_SIF_ENTRY_MAX_CHARS chars long
        //
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    if (cchBootDirectory > MAX_PATH) {
        UINT cchNewSize = cchBootDirectory + 1;
        //
        // Our buffer wasn't big enough, free and re-alloc as needed
        //
        _AsrpHeapFree(pSystemInfo->BootDirectory);
        pSystemInfo->BootDirectory = HeapAlloc(heapHandle, 
            HEAP_ZERO_MEMORY, 
            (cchNewSize + 1) * sizeof(WCHAR)
            );
        if (!(pSystemInfo->BootDirectory)) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        cchBootDirectory = GetWindowsDirectoryW(pSystemInfo->BootDirectory, 
            MAX_PATH + 1
            );
        if (!cchBootDirectory) {
            // 
            // GetWindowsDirectory sets LastError
            //
            return FALSE;
        }

        if (cchBootDirectory > cchNewSize) {
            SetLastError(ERROR_BAD_ENVIRONMENT);
            return FALSE;
        }
    }

    // 
    // Get the system directory
    //
    if (!AsrpGetSystemPath(pSystemInfo)) {
        //
        // AsrpGetSystemPath sets LastError
        //
        return FALSE;
    }

    //
    // Get the time-zone information.   We need to save and restore this since
    // GUI-mode Setup (ASR) will otherwise default to GMT, and the file-time
    // stamps on all the restored files will be off, since most back-up apps 
    // assume that they're restoring in the same time-zone that they backed 
    // up in and do nothing special to restore the time-zone first.
    //
    GetTimeZoneInformation(&(pSystemInfo->TimeZoneInformation));


    return TRUE;
}


BOOL
AsrpInitLayoutInformation(
    IN CONST PASR_SYSTEM_INFO pSystemInfo,
    IN OUT PASR_DISK_INFO pDiskList,
    OUT PULONG MaxDeviceNumber OPTIONAL,
    IN BOOL AllDetails
    )

/*++

Routine Description:
    
    Initialisation routine to fill in layout and other interesting information 
    about the disks on the system.

Arguments:

    pSystemInfo - the ASR_SYSTEM_INFO for the current system

    pDiskList - ASR_DISK_INFO list of disks on the current system, with 
            the DevicePath field for each disk pointing to a null terminated 
            path to the disk, that can be used to open a handle to the disk.

            The other fields of the structure are filled in by this routine,
            if the disk could be accessed and the appropriate info could be
            obtained.

    MaxDeviceNumber - Receives the max device number of all the disks on the
            system.  This can be used as an optimisation to allocate memory
            for a table of disks based on the device number.

            This is an optional argument.

    AllDetails - If FALSE, only the pDriveLayout information is filled in for
            each disk.  This is an optimisation that comes in handy when 
            we're dealing with disks on a shared cluster bus.

            If TRUE, all the fields are filled in for each disk.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    BOOL   result = FALSE;
    HANDLE hDisk  = NULL;
    PASR_DISK_INFO currentDisk = pDiskList;

    if (ARGUMENT_PRESENT(MaxDeviceNumber)) {
        *MaxDeviceNumber = 0;
    }

        while (currentDisk) {
        //
        // Open the disk.  If an error occurs, get the next
        // disk from the disk list and continue.
        //
        hDisk = CreateFileW(
            currentDisk->DevicePath,        // lpFileName
            0,                   // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,                           // lpSecurityAttributes
            OPEN_EXISTING,                  // dwCreationFlags
            FILE_ATTRIBUTE_NORMAL,          // dwFlagsAndAttributes
            NULL                            // hTemplateFile
            );

        if ((!hDisk) || (INVALID_HANDLE_VALUE == hDisk)) {
            //
            // We couldn't open the disk.  If this is a critical disk, we'll
            // fail later in AsrpMarkCriticalDisks, so it's okay to ignore 
            // this error for now.
            //
            currentDisk = currentDisk->pNext;
            continue;
        }

        //
        // Get the layout and other interesting info for this disk.  
        // If this fails, we must abort.
        //
        result = AsrpGetDiskLayout(hDisk, 
            pSystemInfo, 
            currentDisk, 
            AllDetails
            );
        if (!result) {
            DWORD status = GetLastError();
            _AsrpCloseHandle(hDisk);    // this may change LastError. 
            SetLastError(status);
            return FALSE;
        }

        _AsrpCloseHandle(hDisk);

        //
        // Set the max device number if needed
        //
        if (ARGUMENT_PRESENT(MaxDeviceNumber) &&
            (currentDisk->DeviceNumber > *MaxDeviceNumber)
            ) {
            *MaxDeviceNumber = currentDisk->DeviceNumber;
        }

        //
        // Get the next drive from the drive list.
        //
        currentDisk = currentDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpInitDiskInformation(
    OUT PASR_DISK_INFO  *ppDiskList
    )

/*++

Routine Description:

    Initialisation routine to get a list of disks present on the system.  This
    routine allocates a ASR_DISK_INFO struct for each disk on the machine, and
    fills in the DevicePath and ParentDevInst fields of each with a path to 
    the disk.  It is expected that the other fields will be filled in with a 
    subsequent call to AsrpInitLayoutInformation().

Arguments:
    ppDiskList - Receives the location of the first ASR_DISK_INFO struct.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().  ppDiskList may point to an 
            incomplete list of disks on the system, and it is the caller's 
            responsibility to free the memory allocated, if any, using
            HeapFree(GetProcessHeap(),...).

--*/

{
    DWORD count = 0,
        status = ERROR_SUCCESS;

    HDEVINFO hdevInfo = NULL;

    BOOL result = FALSE;

    PASR_DISK_INFO pNewDisk = NULL;

    HANDLE heapHandle = NULL;

    PSP_DEVICE_INTERFACE_DETAIL_DATA_W pDiDetail = NULL;

    SP_DEVICE_INTERFACE_DATA devInterfaceData;
    
    DWORD sizeDiDetail = 0;

    SP_DEVINFO_DATA devInfoData;

    //
    // Initialise stuff to zeros
    //
    memset(&devInterfaceData, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
    *ppDiskList = NULL;

    heapHandle = GetProcessHeap();    // used for HeapAlloc functions
    MYASSERT(heapHandle);

    //
    // Get a device interface set which includes all Disk devices
    // present on the machine. DiskClassGuid is a predefined GUID that
    // will return all disk-type device interfaces
    //
    hdevInfo = SetupDiGetClassDevsW(
        &DiskClassGuid,
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
        );
    _AsrpErrExitCode(
        ((NULL == hdevInfo) || (INVALID_HANDLE_VALUE == hdevInfo)),
        status,
        ERROR_IO_DEVICE
        );

    //
    // Iterate over all devices interfaces in the set
    //
    for (count = 0; ; count++) {

        // must set size first
        devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA); 

        //
        // Retrieve the device interface data for each device interface
        //
        result = SetupDiEnumDeviceInterfaces(
            hdevInfo,
            NULL,
            &DiskClassGuid,
            count,
            &devInterfaceData
            );

        if (!result) {
            //
            // If we retrieved the last item, break
            //
            status = GetLastError();

            if (ERROR_NO_MORE_ITEMS == status) {
                status = ERROR_SUCCESS;
                break;
            }
            else {
                //
                // Some other error occured, goto EXIT.  We overwrite the 
                // last error.
                //
                _AsrpErrExitCode(status, status, ERROR_IO_DEVICE);
            }
        }

        //
        // Get the required buffer-size for the device path
        //
        result = SetupDiGetDeviceInterfaceDetailW(
            hdevInfo,
            &devInterfaceData,
            NULL,
            0,
            &sizeDiDetail,
            NULL
            );

        if (!result) {

            status = GetLastError();
            //
            // If a value other than "insufficient buffer" is returned,
            // an error occured
            //
            _AsrpErrExitCode((ERROR_INSUFFICIENT_BUFFER != status), 
                status, 
                ERROR_IO_DEVICE
                );
        }
        else {
            //
            // The call should have failed since we're getting the
            // required buffer size.  If it doesn't, and error occurred.
            //
            _AsrpErrExitCode(status, status, ERROR_IO_DEVICE);
        }

        //
        // Allocate memory for the buffer
        //
        pDiDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA_W) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeDiDetail
            );
        _AsrpErrExitCode(!pDiDetail, status, ERROR_NOT_ENOUGH_MEMORY);

        // must set the struct's size member
        pDiDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Finally, retrieve the device interface detail info
        //
        result = SetupDiGetDeviceInterfaceDetailW(
            hdevInfo,
            &devInterfaceData,
            pDiDetail,
            sizeDiDetail,
            NULL,
            &devInfoData
            );
        _AsrpErrExitCode(!result, status, GetLastError());

        //
        // Okay, now alloc a struct for this disk, and fill in the DevicePath
        // field with the Path from the interface detail.
        //
        pNewDisk = (PASR_DISK_INFO) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_DISK_INFO)
            );
        _AsrpErrExitCode(!pNewDisk, status, ERROR_NOT_ENOUGH_MEMORY);

        //
        // Insert at the head so this is O(1) and not O(n!)
        //
        pNewDisk->pNext = *ppDiskList;
        *ppDiskList = pNewDisk;

        pNewDisk->DevicePath = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(WCHAR) * (wcslen(pDiDetail->DevicePath) + 1)
            );
        _AsrpErrExitCode(!(pNewDisk->DevicePath), 
            status, 
            ERROR_NOT_ENOUGH_MEMORY
            );
        wcscpy(pNewDisk->DevicePath, pDiDetail->DevicePath);

        //
        // Get the PnP parent of this disk, so we can use it for grouping 
        // disks later based on the bus they are on.
        //
        CM_Get_Parent(&(pNewDisk->ParentDevInst),
            devInfoData.DevInst,
            0
            );

        _AsrpHeapFree(pDiDetail);
    }

EXIT:
    //
    // Free local mem allocs
    //
    _AsrpHeapFree(pDiDetail);

    if ((hdevInfo) && (INVALID_HANDLE_VALUE != hdevInfo)) {
        SetupDiDestroyDeviceInfoList(hdevInfo);
        hdevInfo = NULL;
    }

    return (BOOL) (status == ERROR_SUCCESS);
}


BOOL
AsrpMarkCriticalDisks(
    IN PASR_DISK_INFO pDiskList,
    IN PCWSTR         CriticalVolumeList,
    IN ULONG          MaxDeviceNumber
    )

/*++

Routine Description:
  
   Sets the IsCritical flag of each of the critical disks on the system.  A 
   disk is deemed "critical" if it is part of part of the failover set for 
   any of the critical volumes present on the system.

Arguments:

    pDiskList - The list of disks on the current system.

    CriticalVolumeList - A multi-string containing a list of the volume GUID's
            of each of the critical volumes present on the system.  The GUID's
            must be in the NT name-space, i.e., must be of the form:
            \??\Volume{GUID}

    MaxDeviceNumber - The highest storage device number of the disks present 
            in the disk list, as determined by calling 
            IOCTL_STORAGE_GET_DEVICE_NUMBER for each of them.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    PCWSTR volGuid = NULL;

    PASR_DISK_INFO currentDisk = NULL;
    
    PVOLUME_FAILOVER_SET failoverSet = NULL;
    
    DWORD index = 0, 
        reqdSize=0, 
        sizeFailoverSet = 0,
        status = ERROR_SUCCESS;

    BOOL result = TRUE,
        *criticalDiskTable = NULL;

    WCHAR devicePath[ASR_CCH_DEVICE_PATH_FORMAT + 1];

    HANDLE heapHandle = NULL, 
        hDevice = NULL;

    memset(devicePath, 0L, (ASR_CCH_DEVICE_PATH_FORMAT+1)*sizeof(WCHAR));

    if (!CriticalVolumeList) {
        //
        //  No critical volumes:
        //
#ifdef PRERELEASE
        return TRUE;
#else
        return FALSE;
#endif
    }

    if (!pDiskList) {
        //
        //  No disks on machine?!
        //
        MYASSERT(0 && L"DiskList is NULL");
        return FALSE;
    }

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    //
    //  criticalDiskTable is our table of BOOL values.
    //
    criticalDiskTable = (BOOL *) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (BOOL) * (MaxDeviceNumber + 1)
        );
    _AsrpErrExitCode(!criticalDiskTable, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Try with a reasonable sized buffer first--say 10 disks.  We'll
    // realloc as needed if this isn't enough.
    //
    sizeFailoverSet = sizeof(VOLUME_FAILOVER_SET) +  (10 * sizeof(ULONG));
    failoverSet = (PVOLUME_FAILOVER_SET) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeFailoverSet
        );
    _AsrpErrExitCode(!failoverSet, status, ERROR_NOT_ENOUGH_MEMORY);

    volGuid = CriticalVolumeList;
    while (*volGuid) {
        //
        // Convert the \??\ to \\?\ so that CreateFile can use it
        //
        wcsncpy(devicePath, volGuid, ASR_CCH_DEVICE_PATH_FORMAT);
        devicePath[1] = L'\\';

        //
        //  Get a handle so we can send the ioctl
        //
        hDevice = CreateFileW(
            devicePath,       // lpFileName
            0,       // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,               // lpSecurityAttributes
            OPEN_EXISTING,      // dwCreationFlags
            0,                  // dwFlagsAndAttributes
            NULL                // hTemplateFile
            );
        _AsrpErrExitCode(((!hDevice) || (INVALID_HANDLE_VALUE == hDevice)),
            status,
            GetLastError());

        result = DeviceIoControl(
            hDevice,
            IOCTL_VOLUME_QUERY_FAILOVER_SET,
            NULL,
            0,
            failoverSet,
            sizeFailoverSet,
            &reqdSize,
            NULL
            );

        //
        // We're doing this in a while loop because if the disk configuration  
        // changes in the small interval between when we get the reqd buffer 
        // size and when we send the ioctl again with a buffer of the "reqd" 
        // size, we may still end up with a buffer that isn't big enough.
        //
        while (!result) {
            status = GetLastError();

            if (ERROR_MORE_DATA == status) {
                //
                // The buffer was too small, reallocate the reqd size.
                //
                status = ERROR_SUCCESS;

                sizeFailoverSet = (sizeof(VOLUME_FAILOVER_SET)  + 
                    ((failoverSet->NumberOfDisks) * sizeof(ULONG)));

                _AsrpHeapFree(failoverSet);

                failoverSet = (PVOLUME_FAILOVER_SET) HeapAlloc(
                    heapHandle,
                    HEAP_ZERO_MEMORY,
                    sizeFailoverSet
                    );
                _AsrpErrExitCode(!failoverSet, 
                    status, 
                    ERROR_NOT_ENOUGH_MEMORY
                    );

                result = DeviceIoControl(
                    hDevice,
                    IOCTL_VOLUME_QUERY_FAILOVER_SET,
                    NULL,
                    0,
                    failoverSet,
                    sizeFailoverSet,
                    &reqdSize,
                    NULL
                    );
            }
            else {
                //
                // The IOCTL failed because of something else, this is
                // fatal since we can't find the critical disk list now.
                //
                _AsrpErrExitCode((TRUE), status, status);
            }
        }

        //
        // Mark the appropriate entries in our table
        //
        for (index = 0; index < failoverSet->NumberOfDisks; index++) {
            criticalDiskTable[failoverSet->DiskNumbers[index]] = 1;
        }
        _AsrpCloseHandle(hDevice);

        //
        // Repeat for next volumeguid in list
        //
        volGuid += (wcslen(CriticalVolumeList) + 1);
    }

    //
    // Now go through the list of disks, and mark the critical flags.
    //
    currentDisk = pDiskList;
    while (currentDisk) {

        if (currentDisk->IsClusterShared) {
            //
            // By definition, cluster shared disks cannot be critical.
            //
            currentDisk = currentDisk->pNext;
            continue;
        }
    
        currentDisk->IsCritical = 
            (criticalDiskTable[currentDisk->DeviceNumber] ? TRUE : FALSE);

        //
        // Increment the entry, so that we can track how many critical volumes
        // reside on this disk, and--more importantly--ensure that all the
        // critical disks exist on the system (next loop below)
        //
        if (currentDisk->IsCritical) {
            ++(criticalDiskTable[currentDisk->DeviceNumber]);
        }

        currentDisk = currentDisk->pNext;

    }

    //
    // Finally, we want to make sure that we don't have any critical disks
    // in our table that we didn't find physical disks for.  (I.e., make  
    // sure that the system has no "missing" critical disks)
    //
    for (index = 0; index < MaxDeviceNumber; index++) {
        if (1 == criticalDiskTable[index]) {
            //
            // If the table still has "1" for the value, it was never 
            // incremented in the while loop above, ie our diskList doesn't 
            // have a disk corresponding to this.
            //
            _AsrpErrExitCode(TRUE, status, ERROR_DEV_NOT_EXIST);
        }
    }

EXIT:
    _AsrpHeapFree(failoverSet);
    _AsrpHeapFree(criticalDiskTable);
    _AsrpCloseHandle(hDevice);

    return (BOOL)(ERROR_SUCCESS == status);
}


PASR_DISK_INFO
AsrpFreeDiskInfo(
    PASR_DISK_INFO  pCurrentDisk
    )

/*++

Routine Description:

    Helper function to free memory pointed to by various pointers in the
    ASR_DISK_INFO struct, and then free the struct itself.

Arguments:

    pCurrentDisk - the struct to be freed

Return Value:

    pCurrentDisk->Next, which is a pointer to the next disk in the list

--*/

{
    HANDLE          heapHandle  = NULL;
    PASR_DISK_INFO  pNext       = NULL;

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    if (pCurrentDisk) {

        pNext = pCurrentDisk->pNext;
        //
        // If it's a packed struct, then we only need to free the struct 
        // itself.  If not, we need to free the memory the pointers point 
        // to as well.
        //
        if (!pCurrentDisk->IsPacked) {
            _AsrpHeapFree(pCurrentDisk->DevicePath);
            _AsrpHeapFree(pCurrentDisk->pDriveLayoutEx);
            _AsrpHeapFree(pCurrentDisk->pDiskGeometry);
            _AsrpHeapFree(pCurrentDisk->pPartition0Ex);
            _AsrpHeapFree(pCurrentDisk->pScsiAddress);
            _AsrpHeapFree(pCurrentDisk->PartitionInfoTable);
        }

        _AsrpHeapFree(pCurrentDisk);
    }

    return pNext;
}


BOOL
AsrpIsRemovableOrInaccesibleMedia(
    IN PASR_DISK_INFO pDisk
    ) 
/*++

Routine Description:

    Checks if the disk represented by pDisk should be removed from our list
    of disks that we'll store information on in the state file.  

    Disks that should be removed include disks that are removable, or disks
    that we couldn't access.
 
Arguments:

    pDisk - the disk structure to be checked

Return Value:

    TRUE if the device is removable, or some key information about the disk is 
            missing.  Since code depends on the driveLayout being non-NULL, 
            for instance, we shall just remove the disk from the list if we 
            couldn't get it's drive layout.  We shall therefore not backup 
            information about any disk whose drive geo or layout we couldn't 
            get, and not restore to any such disk.

    FALSE if the structure contains all the required information, and is not
            a removable device.

--*/

{

    if ((NULL == pDisk->pDiskGeometry) ||
        (NULL == pDisk->pDriveLayoutEx) ||
        (NULL == pDisk->pPartition0Ex) ||
        (FixedMedia != pDisk->pDiskGeometry->MediaType)
        ) {
        
        return TRUE;
    }

    return FALSE;
}


BOOL
AsrpFreeNonFixedMedia(
    IN OUT PASR_DISK_INFO *ppDiskList
    )

/*++

Routine Description:
    
    Removes removable media, and disks that are inaccessible, from the list of
    disks passed in.

Arguments:

    ppDiskList - a pointer to the address of the first disk in the list of all
            the disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().  
            
    Currently, this function always succeeds.

--*/

{
    PASR_DISK_INFO  prevDisk = NULL,
        currentDisk = *ppDiskList;

    while (currentDisk) {

        if (AsrpIsRemovableOrInaccesibleMedia(currentDisk)) {
            //
            // Disk is not Fixed, we should remove it from out list
            //
            if (NULL == prevDisk) {      // this is the first disk in the list
                *ppDiskList = currentDisk->pNext;
            }
            else {
                prevDisk->pNext = currentDisk->pNext;
            }

            //
            // Free it and get a pointer to the next disk
            //
            currentDisk = AsrpFreeDiskInfo(currentDisk);
        }
        else {
            //
            // Disk is okay, move on to the next disk
            //
            prevDisk = currentDisk;
            currentDisk = currentDisk->pNext;

        }
    }

    return TRUE;
}


VOID
AsrpFreeStateInformation(
    IN OUT PASR_DISK_INFO *ppDiskList OPTIONAL,
    IN OUT PASR_SYSTEM_INFO pSystemInfo OPTIONAL
    )

/*++

Routine Description:
    
    Frees the memory addressed by pointers in the ASR_DISK_INFO and 
    ASR_SYSTEM_INFO structs.

    Frees the list of disks pointed to by the ASR_DISK_INFO struct.

Arguments:
    
    ppDiskList - Pointer to the address of the first Disk in the DiskList 
            being freed.  The address is set to NULL after the list is freed,
            to prevent further unintended accesses to the freed object.

    pSystemInfo - A pointer to the ASR_SYSTEM_INFO struct, containing the
            pointers to be freed.

Return Value:

    If the function succeeds, the return value is a nonzero value.  
            *ppDiskList is set to NULL.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

    Currently, this function always succeeds.

--*/

{
    PASR_DISK_INFO  pTempDisk = NULL;

    HANDLE heapHandle = GetProcessHeap();
    
    MYASSERT(heapHandle);

    if (ARGUMENT_PRESENT(ppDiskList)) {

        pTempDisk = *ppDiskList;

        while (pTempDisk) {
            pTempDisk = AsrpFreeDiskInfo(pTempDisk);
        }

        *ppDiskList = NULL;
    }

    if (ARGUMENT_PRESENT(pSystemInfo)) {
        _AsrpHeapFree(pSystemInfo->SystemPath);
        _AsrpHeapFree(pSystemInfo->BootDirectory);
    }
}


VOID
AsrpFreePartitionList(
    IN OUT PASR_PTN_INFO_LIST *ppPtnList OPTIONAL
    )

/*++

Routine Description:

    Frees the list of partitions, along with memory addressed by all the 
    pointers in the list.

Arguments:

    ppPtnList - Pointer to the address of the first partition in the list
            being freed.  The address is set to NULL after the list is freed,
            to prevent further unintended accesses to the freed object.

Return Value:

    If the function succeeds, the return value is a nonzero value.  
            *ppPtnList is set to NULL.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

    Currently, this function always succeeds.

--*/

{
    DWORD index = 0,
        numberOfPartitions = 0;

    PASR_PTN_INFO_LIST pList = NULL;

    PASR_PTN_INFO pCurrent = NULL,
        pNext = NULL;

    HANDLE  heapHandle = GetProcessHeap();

    if (!ARGUMENT_PRESENT(ppPtnList) || !(*ppPtnList)) {
        return;
    }

    pList = *ppPtnList;

    numberOfPartitions = pList[0].numTotalPtns;

    for (index = 0; index < numberOfPartitions; index++) {

        pCurrent = pList[index].pOffsetHead;

        while (pCurrent) {
            //
            // Save a pointer to the next
            //
            pNext = pCurrent->pOffsetNext;

            //
            // No pointers in PASR_PTN_INFO, okay to free as-is.
            //
            _AsrpHeapFree(pCurrent);

            pCurrent = pNext;
        }
    }

    _AsrpHeapFree(pList);
    *ppPtnList = NULL;
}


BOOL
AsrpWriteVersionSection(
    IN CONST HANDLE SifHandle,
    IN PCWSTR Provider OPTIONAL
    )

/*++

Routine Description:

    Creates the VERSION section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    Provider - Pointer to a null-terminated string containing the name of the
            application creating the asr.sif.  The length of this string must
            not exceed (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING)
            characters.

            This is an optional argument.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{

    WCHAR   infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];
    DWORD   size;

    // 
    // Write out the section name
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_VERSION_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Section Entries
    //
    wcscpy(infstring, L"Signature=\"$Windows NT$\"\r\n");
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    wcscpy(infstring, L"ASR-Version=\"1.0\"\r\n");
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    if (ARGUMENT_PRESENT(Provider)) {
        if (wcslen(Provider) > 
            (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING)
            ) {
            //
            // This string is too long to fit into one line in asr.sif
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        swprintf(infstring, L"%ws\"%.*ws\"\r\n", 
            ASR_SIF_PROVIDER_PREFIX, 
            (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING), 
            Provider
            );
        _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
            wcslen(infstring)*sizeof(WCHAR), &size, NULL));
    }

    return TRUE;
}


BOOL
AsrpWriteSystemsSection(
    IN CONST HANDLE SifHandle,
    IN CONST PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Creates the SYSTEMS section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pSystemInfo - Pointer to information about the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];
    DWORD size = 0, SKU = 0;

    if ((!pSystemInfo) || (!pSystemInfo->BootDirectory)) {
        //
        // We need a boot directory
        //
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    // 
    // Write out the section name
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_SYSTEM_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    SKU = (DWORD) (pSystemInfo->OsVersionEx.wProductType);
    SKU = SKU << 16;            // shift the ProductType left 2 bytes
    SKU = SKU | (DWORD) (pSystemInfo->OsVersionEx.wSuiteMask);
    //
    // Create the section entry, and write it out to file.
    //
    swprintf(infstring,
        L"1=\"%ws\",\"%ws\",\"%d.%d\",\"%ws\",%d,0x%08x,\"%ld %ld %ld %hd-%hd-%hd-%hd %hd:%02hd:%02hd.%hd %hd-%hd-%hd-%hd %hd:%02hd:%02hd.%hd\",\"%ws\",\"%ws\"\r\n",
        pSystemInfo->ComputerName,
        pSystemInfo->Platform,
        pSystemInfo->OsVersionEx.dwMajorVersion,
        pSystemInfo->OsVersionEx.dwMinorVersion,
        pSystemInfo->BootDirectory,
        ((pSystemInfo->AutoExtendEnabled) ? 1 : 0),

        // Product SKU
        SKU, 

        // Time-zone stuff
        pSystemInfo->TimeZoneInformation.Bias,
        pSystemInfo->TimeZoneInformation.StandardBias,
        pSystemInfo->TimeZoneInformation.DaylightBias,

        pSystemInfo->TimeZoneInformation.StandardDate.wYear,
        pSystemInfo->TimeZoneInformation.StandardDate.wMonth,
        pSystemInfo->TimeZoneInformation.StandardDate.wDayOfWeek,
        pSystemInfo->TimeZoneInformation.StandardDate.wDay,

        pSystemInfo->TimeZoneInformation.StandardDate.wHour,
        pSystemInfo->TimeZoneInformation.StandardDate.wMinute,
        pSystemInfo->TimeZoneInformation.StandardDate.wSecond,
        pSystemInfo->TimeZoneInformation.StandardDate.wMilliseconds,

        pSystemInfo->TimeZoneInformation.DaylightDate.wYear,
        pSystemInfo->TimeZoneInformation.DaylightDate.wMonth,
        pSystemInfo->TimeZoneInformation.DaylightDate.wDayOfWeek,
        pSystemInfo->TimeZoneInformation.DaylightDate.wDay,

        pSystemInfo->TimeZoneInformation.DaylightDate.wHour,
        pSystemInfo->TimeZoneInformation.DaylightDate.wMinute,
        pSystemInfo->TimeZoneInformation.DaylightDate.wSecond,
        pSystemInfo->TimeZoneInformation.DaylightDate.wMilliseconds,

        pSystemInfo->TimeZoneInformation.StandardName,
        pSystemInfo->TimeZoneInformation.DaylightName
        );

    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    return TRUE;
}


BOOL
AsrpWriteBusesSection(
    IN CONST HANDLE SifHandle,
    IN CONST PASR_DISK_INFO pDiskList
    )

/*++

Routine Description:

    Creates the BUSES section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD size = 0,
        busKey = 1;

    BOOL done = FALSE;
    
    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    PASR_DISK_INFO pCurrentDisk = NULL;

    // 
    // Write out the section name
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_BUSES_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Create the list of buses.  This routine fills in the SifBusKey field
    // for each disk.
    //
    AsrpDetermineBuses(pDiskList);

    //
    // Go through the list of disks now, and add one entry in asr.sif for each
    // bus present on the system (i.e., each unique SifBusKey value).  Note 
    // that we won't care about disks for which we couldn't get any bus info--
    // SifBusKey is 0 for such disks, and we start here from SifBusKey == 1.
    //
    // Also, we assume that SifBusKey values have no holes.
    //
    while (!done) {

        done = TRUE;    // assume that we've been through all the buses.
        //
        // Start from the beginning of the list
        //
        pCurrentDisk = pDiskList;

        while (pCurrentDisk) {

            if (pCurrentDisk->SifBusKey > busKey) {
                //
                // There are SifBusKeys we haven't covered yet.
                //
                done = FALSE;
            }

            if (pCurrentDisk->SifBusKey == busKey) {
                //
                // This is the SifBusKey we're looking for, so lets write 
                // out the bus type to file.
                //
                swprintf(infstring, L"%lu=%d,%lu\r\n",
                    busKey,
                    ASR_SYSTEM_KEY,
                    pCurrentDisk->BusType
                    );
                _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
                    wcslen(infstring)*sizeof(WCHAR), &size, NULL));

                //
                // We've already covered this SifBusKey, lets move on to the 
                // next.
                //
                ++busKey;
            }

            pCurrentDisk = pCurrentDisk->pNext;
        }
    }

    return TRUE;
}


BOOL
AsrpWriteMbrDisksSection(
    IN CONST HANDLE         SifHandle,       // handle to the state file
    IN CONST PASR_DISK_INFO pDiskList
    )

/*++

Routine Description:

    Creates the DISKS.MBR section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD  size = 0,
        diskKey = 1;

    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    PASR_DISK_INFO  pCurrentDisk = pDiskList;

    // 
    // Write out the section name: [DISKS.MBR]
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_MBR_DISKS_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Go through the list of disks, and write one entry for each MBR disk
    // on the list.
    //
        while (pCurrentDisk) {

        if (PARTITION_STYLE_MBR != 
                pCurrentDisk->pDriveLayoutEx->PartitionStyle
            ) {
            //
                    // Skip non-MBR (i.e., GPT) disks.
                    //
            pCurrentDisk = pCurrentDisk->pNext;
            continue;
        }

        pCurrentDisk->SifDiskKey = diskKey;
        swprintf(infstring, L"%lu=%d,%lu,%lu,0x%08x,%lu,%lu,%lu,%I64u\r\n",
            diskKey,
            ASR_SYSTEM_KEY,
            pCurrentDisk->SifBusKey,
            pCurrentDisk->IsCritical,
            pCurrentDisk->pDriveLayoutEx->Mbr.Signature,
            pCurrentDisk->pDiskGeometry->BytesPerSector,
            pCurrentDisk->pDiskGeometry->SectorsPerTrack,
            pCurrentDisk->pDiskGeometry->TracksPerCylinder,
            (ULONG64)(pCurrentDisk->pPartition0Ex->PartitionLength.QuadPart /
                pCurrentDisk->pDiskGeometry->BytesPerSector)
            );
        _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
            wcslen(infstring)*sizeof(WCHAR), &size, NULL));

        ++diskKey;
        pCurrentDisk = pCurrentDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpWriteGptDisksSection(
    IN CONST HANDLE         SifHandle,       // handle to the state file
    IN CONST PASR_DISK_INFO pDiskList
    )

/*++

Routine Description:

    Creates the DISKS.GPT section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD  size = 0,
        diskKey = 1;

    PWSTR lpGuidString = NULL;

    RPC_STATUS rpcStatus = RPC_S_OK;

    PASR_DISK_INFO  pCurrentDisk = pDiskList;

    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    // 
    // Write out the section name: [DISKS.GPT]
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_GPT_DISKS_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Go through the list of disks, and write one entry for each GPT disk
    // on the list.
    //
        while (pCurrentDisk) {

        if (PARTITION_STYLE_GPT != 
                pCurrentDisk->pDriveLayoutEx->PartitionStyle
            ) {
            //
                    // Skip non-GPT (i.e., MBR) disks.
                    //
            pCurrentDisk = pCurrentDisk->pNext;
            continue;
        }

        //
        // Convert the DiskId to a printable string
        //
        rpcStatus = UuidToStringW(
            &pCurrentDisk->pDriveLayoutEx->Gpt.DiskId, 
            &lpGuidString
            );
        if (rpcStatus != RPC_S_OK) {
            if (lpGuidString) {
                RpcStringFreeW(&lpGuidString);
            }
            //
            // The only error from UuidToStringW is RPC_S_OUT_OF_MEMORY
            //
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        pCurrentDisk->SifDiskKey = diskKey;
        swprintf(infstring, L"%lu=%d,%lu,%lu,%ws%ws%ws,%lu,%lu,%lu,%lu,%I64u\r\n", 
            diskKey,
            ASR_SYSTEM_KEY,
            pCurrentDisk->SifBusKey,
            pCurrentDisk->IsCritical,
            (lpGuidString ? L"\"" : L""),
            (lpGuidString ? lpGuidString : L""),
            (lpGuidString ? L"\"" : L""),
            pCurrentDisk->pDriveLayoutEx->Gpt.MaxPartitionCount,
            pCurrentDisk->pDiskGeometry->BytesPerSector,
            pCurrentDisk->pDiskGeometry->SectorsPerTrack,
            pCurrentDisk->pDiskGeometry->TracksPerCylinder,
            (ULONG64) (pCurrentDisk->pPartition0Ex->PartitionLength.QuadPart /
                pCurrentDisk->pDiskGeometry->BytesPerSector)
            );
        _AsrpCheckTrue(WriteFile(SifHandle, infstring, wcslen(infstring)*sizeof(WCHAR), &size, NULL));

        if (lpGuidString) {
            RpcStringFreeW(&lpGuidString);
            lpGuidString = NULL;
        }

        ++diskKey;
        pCurrentDisk = pCurrentDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpWriteMbrPartitionsSection(
    IN CONST HANDLE SifHandle,       // handle to the state file
    IN CONST PASR_DISK_INFO pDiskList,
    IN CONST PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Creates the PARTITIONS.MBR section of the ASR state file, and writes 
    out the entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

    pSystemInfo - Info about the current system, used to determine the current
            boot and system partitions (and mark them appropriately in 
            asr.sif)

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{

    DWORD size = 0,
        index = 0,
        partitionKey = 1;

    UCHAR fsType = 0;
    
    PWSTR volumeGuid = NULL;

    BOOL writeVolumeGuid = FALSE;

    PASR_DISK_INFO pCurrentDisk = pDiskList;

    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    PPARTITION_INFORMATION_EX currentPartitionEx = NULL;

    //
    // Write out the section name: [PARTITIONS.MBR]
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_MBR_PARTITIONS_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Go through the list of disks, and write one entry for each partition on
    // each of the MBR disks on the list.
    //
    while (pCurrentDisk) {

        if (pCurrentDisk->pDriveLayoutEx) {

            if (PARTITION_STYLE_MBR != 
                    pCurrentDisk->pDriveLayoutEx->PartitionStyle
                ) {
                //
                // Skip non-MBR (i.e., GPT) disks
                //
                pCurrentDisk = pCurrentDisk->pNext;
                continue;
            }

            //
            // Enumerate partitions on the disk.  We expect to find only 
            // MBR partitions.
            //
            for (index =0; 
                index < pCurrentDisk->pDriveLayoutEx->PartitionCount; 
                index++
                ) {

                currentPartitionEx = 
                    &pCurrentDisk->pDriveLayoutEx->PartitionEntry[index];
                
                MYASSERT(currentPartitionEx->PartitionStyle == 
                    PARTITION_STYLE_MBR);

                if (currentPartitionEx->Mbr.PartitionType == 0) {
                    //
                    // Empty partition table entry.
                    //
                    continue;
                }

                fsType = 
                    pCurrentDisk->PartitionInfoTable[index].FileSystemType;

                volumeGuid = 
                    pCurrentDisk->PartitionInfoTable[index].szVolumeGuid;
                
                //
                // We only want to write out the Volume GUID for basic
                // (recognized) partitions/volumes, since it does not make 
                // sense in the context of LDM or other unknown partition 
                // types which would need special handling from their 
                // respective recovery agents such as asr_ldm in GUI-mode 
                // Setup.
                //
                writeVolumeGuid = (wcslen(volumeGuid) > 0) &&
                    IsRecognizedPartition(currentPartitionEx->Mbr.PartitionType);

                // 
                // Create the entry and write it to file.
                //
                swprintf(
                    infstring,
                    L"%d=%d,%d,%lu,%ws%ws%ws,0x%02x,0x%02x,0x%02x,%I64u,%I64u,0x%x\r\n",
                    partitionKey,
                    pCurrentDisk->SifDiskKey,
                    index,
                    pCurrentDisk->PartitionInfoTable[index].PartitionFlags,
                    (writeVolumeGuid ? L"\"" : L""),
                    (writeVolumeGuid ? volumeGuid : L""),
                    (writeVolumeGuid ? L"\"" : L""),
                    (currentPartitionEx->Mbr.BootIndicator)?0x80:0,
                    currentPartitionEx->Mbr.PartitionType,
                    
                    ((fsType) ? fsType : 
                        currentPartitionEx->Mbr.PartitionType),
                    
                    (ULONG64) ((currentPartitionEx->StartingOffset.QuadPart)/
                        (pCurrentDisk->pDiskGeometry->BytesPerSector)),

                    (ULONG64) ((currentPartitionEx->PartitionLength.QuadPart)/
                        (pCurrentDisk->pDiskGeometry->BytesPerSector)),

                    pCurrentDisk->PartitionInfoTable[index].ClusterSize
                    );

                _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
                    wcslen(infstring)*sizeof(WCHAR), &size, NULL));

                ++partitionKey;
            }
        }

        pCurrentDisk = pCurrentDisk->pNext;
    }
    return TRUE;
}


BOOL
AsrpWriteGptPartitionsSection(
    IN CONST HANDLE SifHandle,
    IN CONST PASR_DISK_INFO pDiskList,
    IN CONST PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Creates the PARTITIONS.GPT section of the ASR state file, and writes 
    out the entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

    pSystemInfo - Info about the current system, used to determine the current
            boot and system partitions (and mark them appropriately in 
            asr.sif)

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD size = 0,
        index  = 0,
        partitionKey = 1;

    UCHAR fsType = 0;

    PWSTR volumeGuid = NULL,
        partitionId  = NULL,
        partitionType = NULL;

    BOOL writeVolumeGuid = FALSE;

    RPC_STATUS rpcStatus = RPC_S_OK;

    PASR_DISK_INFO pCurrentDisk = pDiskList;

    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    PPARTITION_INFORMATION_EX currentPartitionEx = NULL;

    //
    // Write out the section name: [PARTITIONS.GPT]
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_GPT_PARTITIONS_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Go through the list of disks, and write one entry for each partition on
    // each of the GPT disks on the list.
    //
    while (pCurrentDisk) {

        if (pCurrentDisk->pDriveLayoutEx) {

            if (PARTITION_STYLE_GPT != 
                    pCurrentDisk->pDriveLayoutEx->PartitionStyle
                ) {
                //
                // Skip non-GPT (i.e., MBR) disks.
                //
                pCurrentDisk = pCurrentDisk->pNext;
                continue;
            }

            //
            // Enumerate partitions on the disk. We expect to find only 
            // GPT partitions.
            //
            for (index =0; 
                index < pCurrentDisk->pDriveLayoutEx->PartitionCount; 
                index++) {

                currentPartitionEx = 
                    &pCurrentDisk->pDriveLayoutEx->PartitionEntry[index];
                
                MYASSERT(currentPartitionEx->PartitionStyle == 
                    PARTITION_STYLE_GPT);

                //
                // Convert the Guids to printable strings
                //
                rpcStatus = UuidToStringW(
                    &currentPartitionEx->Gpt.PartitionType, 
                    &partitionType
                    );
                if (rpcStatus != RPC_S_OK) {
                    
                    if (partitionType) {
                        RpcStringFreeW(&partitionType);
                        partitionType = NULL;
                    }
                    
                    //
                    // The only error from UuidToString is RPC_S_OUT_OF_MEMORY
                    //
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }

                rpcStatus = UuidToStringW(
                    &currentPartitionEx->Gpt.PartitionId, 
                    &partitionId
                    );
                if (rpcStatus != RPC_S_OK) {
                    
                    if (partitionType) {
                        RpcStringFreeW(&partitionType);
                        partitionType = NULL;
                    }
                    
                    if (partitionId) {
                        RpcStringFreeW(&partitionId);
                        partitionId = NULL;
                    }

                    //
                    // The only error from UuidToString is RPC_S_OUT_OF_MEMORY
                    //
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }

                fsType = 
                    pCurrentDisk->PartitionInfoTable[index].FileSystemType;

                volumeGuid = 
                    pCurrentDisk->PartitionInfoTable[index].szVolumeGuid;

                //
                // We only want to write out the Volume GUID for basic
                // (recognized) partitions/volumes, since it does not make 
                // sense in the context of LDM or other unknown partition 
                // types which would need special handling from their 
                // respective recovery agents such as asr_ldm in GUI-mode 
                // Setup.
                //
                writeVolumeGuid = (wcslen(volumeGuid) > 0) &&
                    IsEqualGUID(&(partitionType), &(PARTITION_BASIC_DATA_GUID));

                // 
                // Create the entry and write it to file.
                //
                swprintf(
                    infstring,
                    L"%d=%d,%d,%d,%ws%ws%ws,%ws%ws%ws,%ws%ws%ws,0x%I64x,%ws%ws%ws,0x%02x,%I64u,%I64u,0x%x\r\n",

                    partitionKey,
                    pCurrentDisk->SifDiskKey,
                    index,      //slot-index
                    pCurrentDisk->PartitionInfoTable[index].PartitionFlags,

                    (writeVolumeGuid ? L"\"" : L""),
                    (writeVolumeGuid ? volumeGuid : L""),
                    (writeVolumeGuid ? L"\"" : L""),

                    (partitionType ? L"\"" :  L""),
                    (partitionType ? partitionType : L""),
                    (partitionType ? L"\"" :  L""),

                    (partitionId ? L"\"" :  L""),
                    (partitionId ? partitionId : L""),
                    (partitionId ? L"\"" :  L""),

                    currentPartitionEx->Gpt.Attributes,

                    (currentPartitionEx->Gpt.Name ? L"\"" :  L""),
                    (currentPartitionEx->Gpt.Name ? 
                        currentPartitionEx->Gpt.Name : L""),
                    (currentPartitionEx->Gpt.Name ? L"\"" :  L""),

                    //
                    // ISSUE-2000/04/12-guhans: GetVolumeInformation does not 
                    // work on GPT and fstype is always zero
                    //
                    fsType,

                    (ULONG64) ((currentPartitionEx->StartingOffset.QuadPart)/
                        (pCurrentDisk->pDiskGeometry->BytesPerSector)),
                    
                    (ULONG64) ((currentPartitionEx->PartitionLength.QuadPart)/
                        (pCurrentDisk->pDiskGeometry->BytesPerSector)),

                    pCurrentDisk->PartitionInfoTable[index].ClusterSize                    
                    );

                _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
                    wcslen(infstring)*sizeof(WCHAR), &size, NULL));

                if (partitionType) {
                    RpcStringFreeW(&partitionType);
                    partitionType = NULL;
                }
                if (partitionId) {
                    RpcStringFreeW(&partitionId);
                    partitionId = NULL;
                }

                ++partitionKey;
            }
        }

        pCurrentDisk = pCurrentDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpCreateEnvironmentBlock(
    IN  PCWSTR  CriticalVolumeList,
    IN  HANDLE  SifHandle,
    OUT PWSTR   *NewBlock
    )

/*++

Routine Description:

    Creates a new environment block that is passed in to apps launched as part 
    of an ASR backup.  This routine retrieves the current process's 
    environment block, adds the ASR environment variables to it, and creates a
    multi-sz suitable for being passed in as the lpEnvironment parameter of 
    CreateProcess.
    

Arguments:

    CriticalVolumeList - A multi-string containing a list of the volume GUID's
            of each of the critical volumes present on the system.  The GUID's
            must be in the NT name-space, i.e., must be of the form:
            \??\Volume{GUID}

            This multi-sz is used to create the semi-colon separated list of 
            volumes in the "_AsrCriticalVolumeList" variable in NewBlock.

    SifHandle - A (duplicate) handle to asr.sif, the ASR state file.  This is
            used in creating the "_AsrContext" variable in NewBlock.

    NewBlock - Receives the new environment block.  In addition to all the 
            environment variables in the current process environment block, 
            this block contains two additional "ASR" variables:
            _AsrContext=<DWORD_PTR value>
            _AsrCriticalVolumeList=<volumeguid>;<volumeguid>;...;<volumeguid>

            The caller is responsible for freeing this block when it is no
            longer needed, using HeapFree(GetProcessHeap(),...).

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().  (*NewBlock) is set to NULL.

--*/

{
    PCWSTR lpTemp = CriticalVolumeList;

    PWSTR lpCurrentEnvStrings = NULL;

    DWORD cchContextEntry = 0,
        cchEnvBlock = 0,
        cbEnvBlock = 0,
        cbCurrentProcessEnvBlock = 0,
        status = ERROR_SUCCESS;

    HANDLE heapHandle = GetProcessHeap();

    MYASSERT(NewBlock);

    //
    // Find out how much space the environment block will need
    //

    //
    // For _AsrContext=1234 and _AsrCriticalVolumes="..." entries
    //
    lpTemp = CriticalVolumeList;
    if (CriticalVolumeList) {
        while (*lpTemp) {
            lpTemp += (wcslen(lpTemp) + 1);
        }
    }
    cbEnvBlock = (DWORD) ((lpTemp - CriticalVolumeList + 1) * sizeof(WCHAR));
    cbEnvBlock += ASR_CCH_ENVBLOCK_ASR_ENTRIES * sizeof(WCHAR);

    //
    // For all the current environment strings
    //
    lpCurrentEnvStrings = GetEnvironmentStringsW();
    lpTemp = lpCurrentEnvStrings;
    if (lpCurrentEnvStrings ) {
        while (*lpTemp) {
            lpTemp += (wcslen(lpTemp) + 1);
        }
    }
    cbCurrentProcessEnvBlock = (DWORD) ((lpTemp - lpCurrentEnvStrings + 1) * sizeof(WCHAR));
    cbEnvBlock += cbCurrentProcessEnvBlock;

    //
    // And allocate the space
    //
    *NewBlock = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        cbEnvBlock
        );
    _AsrpErrExitCode(!(*NewBlock), status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // First, add the AsrContext=1234 entry in the environment block
    //
    swprintf(
        (*NewBlock),
        ASR_ENVBLOCK_CONTEXT_ENTRY,
        (ULONG64) (SifHandle)
        );
    
    //
    // Keep track of where this entry ends, so we can add a NULL at this
    // index later.
    //
    cchContextEntry = wcslen((*NewBlock));    
    wcscat((*NewBlock), L" "); // this character will be replaced by a NULL later

    //
    // Append each critical volume GUID, separated by a semi-colon.
    //
    wcscat((*NewBlock), ASR_ENVBLOCK_CRITICAL_VOLUME_ENTRY);
    if (CriticalVolumeList) {
        lpTemp = CriticalVolumeList;
        while (*lpTemp) {
            wcscat((*NewBlock), lpTemp);
            wcscat((*NewBlock), L";");
            lpTemp += (wcslen(lpTemp) + 1);
        }
    }
    else {
        wcscat((*NewBlock), L";");
    }

    //
    // Mark the end with two NULL's
    //
    cchEnvBlock = wcslen(*NewBlock) - 1;
//    (*NewBlock)[cchEnvBlock - 1] = L'"';
    (*NewBlock)[cchEnvBlock] = L'\0';

    //
    // Separate the two entries with a NULL
    //
    (*NewBlock)[cchContextEntry] = L'\0';

    //
    // Copy over the current environment strings
    //
    RtlCopyMemory(&(*NewBlock)[cchEnvBlock + 1],
        lpCurrentEnvStrings,
        cbCurrentProcessEnvBlock
        );

EXIT:
    if (lpCurrentEnvStrings) {
        FreeEnvironmentStringsW(lpCurrentEnvStrings);
        lpCurrentEnvStrings = NULL;
    }

    if (ERROR_SUCCESS != status) {
        _AsrpHeapFree((*NewBlock));
    }

    return (BOOL) (ERROR_SUCCESS == status);
}


BOOL
AsrpLaunchRegisteredCommands(
    IN HANDLE SifHandle,
    IN PCWSTR CriticalVolumeList
) 

/*++

Routine Description:

    This launches apps that have registered to be part of an ASR-backup.  The 
    commands are read from the following ASR-Commands key:
    "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\Commands"

    This key contains a REG_EXPAND_SZ entry for each application to be 
    launched, with the data containing the full command-line to be invoked:
    ApplicationName::REG_EXPAND_SZ::<Command-line with parameters>

    Such as:
    ASR utility::REG_EXPAND_SZ::"%systemroot%\\system32\\asr_fmt.exe /backup"

    When invoking the app, we expand out all the environment variables in the
    command-line.  In addition, we append a "context" parameter to the command
    line, which the app is expected to use in calls to AsrAddSifEntry.  
    The above entry would thus translate something like:

    c:\windows\system32\asr_fmt.exe /backup /context=2000

    The environment block of the process is a duplicate of the current process
    environment block, with one exception--it contains two additional "Asr"
    variables:
    _AsrContext=<DWORD_PTR value>
    _AsrCriticalVolumeList=<volumeguid>;<volumeguid>;...;<volumeguid>

    Each application invoked must complete in the allowed time-out value.  
    The time-out is configurable in the registry, by changing the value of the
    "ProcessTimeOut" value under the ASR key.  We ship with a default of 3600
    seconds, but the sys-admin can change it if needed.  (0=infinite).

Arguments:

    SifHandle - A handle to asr.sif, the ASR state file.  A duplicate of this
            handle is passed in to applications as the "context" parameter,
            and as the "_AsrContext" variable in the environment block.

    CriticalVolumeList - A multi-string containing a list of the volume GUID's
            of each of the critical volumes present on the system.  The GUID's
            must be in the NT name-space, i.e., must be of the form:
            \??\Volume{GUID}

            This multi-sz is used to create the semi-colon separated list of 
            volumes in the "_AsrCriticalVolumeList" variable in the env
            block of the new processes.

            Applications (such as volume-managers) can use this list to 
            determine if they manage any critical volumes, and make a note of
            it in the asr.sif.  This way, they can intelligently decide to
            abort the ASR restore process if needed.

Return Value:

    If the function succeeds, the return value is a nonzero value.  This 
            implies that all the applications invoked were successful (i.e.,
            returned an exit code of 0).

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

    Note that if any of the applications returned an exit code other than 0, 
            we interpret that as a fatal error, and will return an error.

--*/

{
    HKEY    regKey          = NULL;

    DWORD   status          = ERROR_SUCCESS,
            waitResult      = WAIT_ABANDONED,

            lpcValues       = 0L,
            index           = 0L,

            cbData          = 0L,
            cbMaxDataLen    = 0L,

            cchValueName    = 0L,
            cchMaxValueLen  = 0L,

            cbCommand       = 0L,
            cchReqd         = 0L,

            timeLeft        = 0L,
            maxTimeOutValue = 0L;

    HANDLE  heapHandle      = NULL,
            processHandle   = NULL,
            dupSifHandle    = NULL;

    PWSTR   valueName       = NULL,
            data            = NULL,
            command         = NULL,
            lpEnvBlock      = NULL;

    WCHAR   cmdLineSuffix[ASR_COMMANDLINE_SUFFIX_LEN + 1];

    BOOL    result          = FALSE;

    STARTUPINFOW        startUpInfo;

    PROCESS_INFORMATION processInfo;

    heapHandle      = GetProcessHeap();
    processHandle   = GetCurrentProcess();
    MYASSERT(heapHandle && processHandle);

    ZeroMemory(cmdLineSuffix, (ASR_COMMANDLINE_SUFFIX_LEN + 1) * sizeof(WCHAR));
    ZeroMemory(&startUpInfo, sizeof(STARTUPINFOW));
    ZeroMemory(&processInfo, sizeof(PROCESS_INFORMATION));

    //
    // Get the time out value for processes, if set in the registry
    // If the key is missing, or is set to "0", the timeout is set
    // to INFINITE.
    //
    status = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, // hKey
        ASR_REGKEY_ASR,         // lpSubKey
        0,                  // ulOptions--Reserved, must be 0
        MAXIMUM_ALLOWED,    // samDesired
        &regKey             // phkResult
        );

    if ((regKey) && (ERROR_SUCCESS == status)) {
        DWORD type = 0L,
            timeOut = 0L,
            cbTimeOut = (sizeof(DWORD));

        status = RegQueryValueExW(
            regKey,     // hKey
            ASR_REGVALUE_TIMEOUT,   // lpValueName
            NULL,       // lpReserved
            &type,      // lpType
            (LPBYTE) &timeOut,      // lpData
            &cbTimeOut  // lpcbData
            );
            
        if ((ERROR_SUCCESS == status) && (REG_DWORD == type)) {
            maxTimeOutValue = timeOut;
        }
    }

    if (regKey) {
        RegCloseKey(regKey);
        regKey = NULL;
    }

    //
    //  Open and enumerate the entries in the ASR command key. If
    //  the key doesn't exist, we don't have to execute anything
    //
    status = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,  // hKey
        ASR_REGKEY_ASR_COMMANDS, // lpSubKey
        0,                   // ulOptions--Reserved, must be 0
        MAXIMUM_ALLOWED,     // samDesired
        &regKey              // phkResult
        );

    if ((!regKey) || (ERROR_SUCCESS != status)) {
        return TRUE;
    }

    //
    // Get the max ValueName and Data entries, and
    // allocate memory for them
    //
    status = RegQueryInfoKey(
        regKey,
        NULL,       // class
        NULL,       // lpcClass
        NULL,       // lpReserved
        NULL,       // lpcSubKeys
        NULL,       // lpcMaxSubKeyLen
        NULL,       // lpcMaxClassLen,
        &lpcValues, // number of values
        &cchMaxValueLen,    // max value length, in cch
        &cbMaxDataLen,      // max data length, in cb
        NULL,       // lpcbSecurityDescriptor
        NULL        // lpftLastWriteTime
        );
    _AsrpErrExitCode((ERROR_SUCCESS != status), status, status);
    _AsrpErrExitCode((0 == lpcValues), status, ERROR_SUCCESS);  // Key is empty, we're done

    valueName = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (cchMaxValueLen + 1) * sizeof (WCHAR)   // cch not cb
        );
    _AsrpErrExitCode(!valueName, status, ERROR_NOT_ENOUGH_MEMORY);

    data = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        cbMaxDataLen + ((ASR_COMMANDLINE_SUFFIX_LEN + 2) * sizeof(WCHAR))
        );
    _AsrpErrExitCode(!data, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // "command" will contain the full command string, after any environment
    // variables (eg %systemroot%) in "data" have been expanded.  We'll start
    // off with "command" being MAX_PATH characters longer than "data", and
    // we'll re-allocate a bigger buffer if/when needed
    //
    cbCommand = cbMaxDataLen + 
        ((ASR_COMMANDLINE_SUFFIX_LEN + MAX_PATH + 2) * sizeof(WCHAR));

    command = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        cbCommand
        );
    _AsrpErrExitCode(!command, status, ERROR_NOT_ENOUGH_MEMORY);

    do {
        cchValueName = cchMaxValueLen + 1;
        cbData       = cbMaxDataLen + sizeof(WCHAR);

        //
        // Enumerate the commands, and execute them one after the other
        //
        status = RegEnumValueW(
            regKey,         // hKey
            index++,        // dwIndex
            valueName,      // lpValueName
            &cchValueName,  // lpcValueName
            NULL,           // lpReserved
            NULL,           // lpType
            (LPBYTE)data,   // lpData
            &cbData         // lpcbData
            );
        _AsrpErrExitCode((ERROR_NO_MORE_ITEMS == status), 
            status, 
            ERROR_SUCCESS
            );   // done with enum
        _AsrpErrExitCode((ERROR_SUCCESS != status), status, status);

        //
        // Create a copy of the sif handle to pass to the app launched.
        // We clean-up close the handle after the app is done.
        //
        result = DuplicateHandle(
            processHandle,
            SifHandle,
            processHandle,
            &dupSifHandle,
            0L,
            TRUE,
            DUPLICATE_SAME_ACCESS
            );
        _AsrpErrExitCode((!result), status, GetLastError());

        //
        // Append the "/context=<duplicate-sif-handle>" to
        // the command line
        //
        swprintf(cmdLineSuffix, 
            ASR_COMMANDLINE_SUFFIX, 
            (ULONG64)(dupSifHandle)
            );
        wcscat(data, cmdLineSuffix);

        //
        // Expand any environment strings in the command line
        //
        cchReqd = ExpandEnvironmentStringsW(data, 
            command, 
            (cbCommand / sizeof(WCHAR))
            );
        _AsrpErrExitCode((!cchReqd), status, GetLastError());

        if ((cchReqd * sizeof(WCHAR)) > cbCommand) {
            //
            // Our "command" buffer wasn't big enough, re-allocate as needed
            //
            _AsrpHeapFree(command);
            cbCommand = ((cchReqd + 1) * sizeof(WCHAR));

            command = HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, cbCommand);
            _AsrpErrExitCode(!command, status, ERROR_NOT_ENOUGH_MEMORY);

            //
            // Try expanding the env strings again ...
            //
            cchReqd = ExpandEnvironmentStringsW(data, 
                command, 
                (cbCommand / sizeof(WCHAR))
                );
            _AsrpErrExitCode(
                ((!cchReqd) || (cchReqd * sizeof(WCHAR)) > cbCommand),
                status, 
                GetLastError()
                );
        }

        //
        // Create the environment block to be passed to the
        // process being launched.  The environment block
        // contains the entries:
        // _AsrCriticalVolumes=\??\Volume{Guid1};\??\Volume{Guid2}
        // _AsrContext=<duplicate-sif-handle>
        //
        // in addition to all the environment strings in the current process.
        //
        result = AsrpCreateEnvironmentBlock(CriticalVolumeList, 
            dupSifHandle, 
            &lpEnvBlock
            );
        _AsrpErrExitCode((!result), status, GetLastError());

        //
        // Execute the command as a separate process
        //
        memset(&startUpInfo, 0L, sizeof (startUpInfo));
        result = CreateProcessW(
            NULL,           // lpApplicationName
            command,        // lpCommandLine
            NULL,           // lpProcessAttributes
            NULL,           // lpThreadAttributes
            TRUE,           // bInheritHandles
            CREATE_UNICODE_ENVIRONMENT, // dwCreationFlags
            lpEnvBlock,           // new environment block
            NULL,           // current directory name (null=current dir)
            &startUpInfo,   // statup information
            &processInfo    // process information
            );
        _AsrpErrExitCode((!result), 
            status, 
            GetLastError()
            );    // process couldn't be launched

        //
        // Process was launched: start the timer countdown if a maximum 
        // timeout was specified in the registry.  Loop till either the 
        // process completes, or the timer expires
        //
        timeLeft = maxTimeOutValue; 
        if (timeLeft) {
            do {
                waitResult = WaitForSingleObject(processInfo.hProcess, 1000);   // 1000 ms = 1 sec
                --timeLeft;
            } while ((WAIT_TIMEOUT == waitResult) && (timeLeft));

            if (!timeLeft) {
                //
                // The process did not terminate in the allowed time. We treat 
                // this as a fatal error--terminate the process, and set its
                // error code to ERROR_TIMEOUT
                //
                TerminateProcess(processInfo.hProcess, ERROR_TIMEOUT);
            }
        }
        else {
            //
            // No timeout was specified in the registry, wait for process to
            // complete.
            //
            waitResult = WaitForSingleObject(processInfo.hProcess, INFINITE);

        }

        //
        // Check if the wait failed above.  If last error is something useful,
        // we don't want to destroy it--if it's ERROR_SUCCESS, we'll set it to
        // ERROR_TIMEOUT
        //
        status = GetLastError();
        _AsrpErrExitCode((WAIT_OBJECT_0!=waitResult), status, 
            (ERROR_SUCCESS == status ? ERROR_TIMEOUT : status));    // wait failed above

        //
        // Get the process's exit code: if it doesn't return ERROR_SUCCESS,
        // we exit the loop, set the last error to the error returned,
        // and return FALSE
        //
        GetExitCodeProcess(processInfo.hProcess, &status);
        _AsrpErrExitCode((ERROR_SUCCESS != status), status, status);

        _AsrpCloseHandle(dupSifHandle);
        _AsrpHeapFree(lpEnvBlock);
    
    } while (ERROR_SUCCESS == status);


EXIT:
    //
    // Clean-up
    //
    if (regKey) {
        RegCloseKey(regKey);
        regKey = NULL;
    }
    
    _AsrpCloseHandle(dupSifHandle);
    _AsrpHeapFree(valueName);
    _AsrpHeapFree(data);
    _AsrpHeapFree(command);
    _AsrpHeapFree(lpEnvBlock);
    
    if (ERROR_SUCCESS != status) {
        SetLastError(status);
        return FALSE;
    }
    else {
        return TRUE;
    }
}


BOOL
AsrpIsSupportedConfiguration(
    IN CONST PASR_DISK_INFO   pDiskList,
    IN CONST PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Checks if ASR backup can be performed on the system.  We do not support
    systems that have:
    -  PROCESSOR_ARCHITECTURE other than "x86", "amd64", or "ia64"
    -  any FT volumes present anywhere on the system

Arguments:

    pDiskList - The list of disks on the system.

    pSystemInfo - System information for this system.

Return Value:

    If we support this ASR configuration, the return value is non-zero.

    If this configuration is not supported, the return value is zero. 
            GetLastError() will return ERROR_NOT_SUPPORTED.

--*/

{

    PASR_DISK_INFO  pCurrentDisk         = pDiskList;
    ULONG           index;

    // 
    // 1. platform must be x86, amd64, or ia64
    //
    if (wcscmp(pSystemInfo->Platform, ASR_PLATFORM_X86) &&
        wcscmp(pSystemInfo->Platform, ASR_PLATFORM_AMD64) &&
        wcscmp(pSystemInfo->Platform, ASR_PLATFORM_IA64)) {

        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    // 
    // 2. System cannot any FT volumes.  All mirrors, stripes and so on are
    // expected to be LDM volumes on dynamic disks.
    //
    while (pCurrentDisk) {

        if (!(pCurrentDisk->pDriveLayoutEx) || !(pCurrentDisk->pDiskGeometry)) {
            MYASSERT(0);
            pCurrentDisk = pCurrentDisk->pNext;
            continue;
        }

        if (pCurrentDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR) {

            for (index =0; index < pCurrentDisk->pDriveLayoutEx->PartitionCount; index++) {

                MYASSERT(pCurrentDisk->pDriveLayoutEx->PartitionEntry[index].PartitionStyle == PARTITION_STYLE_MBR);

                if (IsFTPartition(pCurrentDisk->pDriveLayoutEx->PartitionEntry[index].Mbr.PartitionType)) {

                    SetLastError(ERROR_NOT_SUPPORTED);
                    return FALSE;
                }

            }
        }
        else if (pCurrentDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT) {
            //
            // GPT disks can't have FT Mirrors.
            //
        }

        pCurrentDisk = pCurrentDisk->pNext;
    }

    return TRUE;
}



//
// -----
// The following routines are helpers for AsrAddSifEntry
// -----
//

BOOL
AsrpSifCheckSectionNameSyntax(
    IN  PCWSTR  lpSectionName
    )

/*++

Routine Description:

    Performs some basic validation of lpSectionName to make sure that
    it conforms to the expected format for a section header

Arguments:
    
    lpSectionName - The null-terminated string to be checked.

Return Value:

    If lpSectionName appears to be a valid section name, the return value is a
            nonzero value.

    If lpSectionName does not pass our basic validation, the return value is 
            zero.  Note that GetLastError will NOT return additional error
            information in this case.

--*/

{
    UINT    i   = 0;
    WCHAR   wch = 0;

    // 
    // Must be non-null
    //
    if (!lpSectionName) {
        return FALSE;
    }

    // 
    // Must have atleast 3 chars, ([.]) and at most ASR_SIF_ENTRY_MAX_CHARS 
    // chars
    //
    if ((ASR_SIF_ENTRY_MAX_CHARS < wcslen(lpSectionName)) ||
        3 > wcslen(lpSectionName)) {
        return FALSE;
    }

    // 
    // First char must be [, and last char must be ].
    //
    if (L'[' != lpSectionName[0]                     ||
        L']' != lpSectionName[wcslen(lpSectionName)-1]) {
        return FALSE;
    }

    // 
    // Check for illegal characters.  Legal set of chars: A-Z a-z . _
    //
    for (i = 1; i < wcslen(lpSectionName)-1; i++) {

        wch = lpSectionName[i];
        if ((wch < L'A' || wch > 'Z') &&
            (wch < L'a' || wch > 'z') &&
            (wch < L'0' || wch > '9') &&
            (wch != L'.') &&
            (wch != '_')) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
AsrpSifCheckCommandsEntrySyntax(
    PCWSTR  pwszEntry
    )

/*++

Routine Description:

    Performs some basic validation of pwszEntry to make sure that it conforms 
    to the expected entry format for the Commands section

Arguments:
    
    pwszEntry - The null-terminated string to be checked.

Return Value:

    If pwszEntry appears to be a valid section name, the return value is a
            nonzero value.

    If pwszEntry does not pass our basic validation, the return value is 
            zero.  Note that GetLastError will NOT return additional error
            information in this case.

--*/

{
    BOOL fValid = FALSE;

    if (!pwszEntry) {
        return TRUE;    // NULL is okay
    }

    //
    // COMMANDS section entry format:
    // system-key,sequence-number,action-on-completion,"command","parameters"
    // system-key must be 1
    // 1000 <= sequence-number <= 4999
    // 0 <= action-on-completion <= 1
    // command:     no syntax check
    // parameters:  no syntax check
    //
    fValid = (
        // must be atleast 10 chars (1,0000,0,c)
        10    <= wcslen(pwszEntry) &&

        // system-key must be 1
        L'1' == pwszEntry[0] &&
        L',' == pwszEntry[1] &&

        // 1000 <= sequence-number <= 4999
        L'1' <= pwszEntry[2] &&
        L'4' >= pwszEntry[2] &&

        L'0' <= pwszEntry[3] &&
        L'9' >= pwszEntry[3] &&

        L'0' <= pwszEntry[4] &&
        L'9' >= pwszEntry[4] &&

        L'0' <= pwszEntry[5] &&
        L'9' >= pwszEntry[5] &&

        L',' == pwszEntry[6] &&

        // action-on-completion = [0|1]
        L'0' <= pwszEntry[7] &&
        L'1' >= pwszEntry[7]
        );

    return fValid;
}


INT
AsrpSkipMatchingQuotes(
    IN PCWSTR pwszEntry,
    IN const INT StartingOffset
    ) 

/*++

Routine Description:

    Checks if this entry starts with a quote.  If it does, it finds the ending
    quote, and returns the index of the char after the ending quote (usually 
    is a comma).

Arguments:

    pwszEntry - The null-terminated string to check.

    StartingOffset - The index of the starting-quote in pwszEntry.

Return Value:

    If the character at StartingOffset is a quote, this returns the index of
            the character after the next quote (the matching end-quote) in the
            string.  If a matching end-quote is not found, it returns -1.

    If the character at StartingOffset is not a quote, this returns
            StartingOffset.

    Essentially, this returns the position where we expect the next comma in 
            the sif entry to be.
    
--*/

{
    INT offset = StartingOffset;

    if (pwszEntry[offset] == L'"') {
        // 
        // Find the ending quote and make sure we don't go out of bounds.
        //
        while ( (pwszEntry[++offset]) &&
                (pwszEntry[offset] != L'\"')) {
            ;
        }

        if (!pwszEntry[offset]) {
            //
            // We didn't find the closing quotes--we went out of bounds
            //
            offset = -1;
        }
        else {
            //
            // Found closing quote
            //
            offset++;
        }
    }

    return offset;
}


BOOL
AsrpSifCheckInstallFilesEntrySyntax(
    IN PCWSTR   pwszEntry,
    OUT PINT    DestinationFilePathIndex OPTIONAL
    )

/*++

Routine Description:

    Performs some basic validation of pwszEntry to make sure that it conforms 
    to the expected entry format for the InstallFiles section

Arguments:
    
    pwszEntry - The null-terminated string to be checked.

    DestinationFilePathIndex - This receives the index at which the 
            destination-file-path field in the sif entry (pwszEntry) begins.

            This is an optional parameter.

Return Value:

    If pwszEntry appears to be a valid section name, the return value is a
            nonzero value.

    If pwszEntry does not pass our basic validation, the return value is 
            zero.  Note that GetLastError will NOT return additional error
            information in this case.

--*/

{

    INT offset = 0;

    if (ARGUMENT_PRESENT(DestinationFilePathIndex)) {
        *DestinationFilePathIndex = 0;
    }

    // 
    // NULL is okay
    //
    if (!pwszEntry) {
        return TRUE;
    }

    // 
    // INSTALLFILES section entry format:
    // system-key,source-media-label,source-device,
    //    source-file-path,destination-file-path,vendor-name,flags
    //
    // system-key must be 1
    //
    // must be atleast 10 chars (1,m,d,p,,v)
    //
    if (wcslen(pwszEntry) < 10) {
        return FALSE;
    }

    // 
    // system-key must be 1
    //
    if (L'1' != pwszEntry[0] || L',' != pwszEntry[1] || L'"' != pwszEntry[2]) {
        return FALSE;
    }

    offset = 2;

    //
    // source-media-label
    //
    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if ((offset < 0) || L',' != pwszEntry[offset]) {
        return FALSE;
    }

    //
    // source-device
    //
    if (L'"' != pwszEntry[++offset]) {
        return FALSE;
    }
    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if ((offset < 0) || L',' != pwszEntry[offset]) {
        return FALSE;
    }

    //
    // source-file-path, must be enclosed in quotes.
    //
    if (L'"' != pwszEntry[++offset]) {
        return FALSE;
    }
    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if ((offset < 0) || L',' != pwszEntry[offset]) {
        return FALSE;
    }

    //
    // destination-file-path, must be enclosed in quotes.
    //
    if (L'"' != pwszEntry[++offset]) {
        return FALSE;
    }
    if (ARGUMENT_PRESENT(DestinationFilePathIndex)) {
        *DestinationFilePathIndex = offset;
    }

    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if ((offset < 0) || L',' != pwszEntry[offset]) {
        return FALSE;
    }

    //
    // vendor-name, must be enclosed in quotes.
    //
    if (L'"' != pwszEntry[++offset]) {
        return FALSE;
    }
    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if (offset < 0) {
        return FALSE;
    }

    return TRUE;
}


BOOL
AsrpIsRunningOnPersonalSKU(
    VOID
    )

/*++
Routine Description:

    This function checks the system to see if we are running on the personal 
    version of the operating system.

    The personal version is denoted by the product id equal to WINNT, which is
    really workstation, and the product suite containing the personal suite 
    string.

    This is lifted from "IsRunningOnPersonal" by WesW.

Arguments:

    None.

Return Value:

    TRUE if we are running on personal, FALSE otherwise.

--*/

{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

    return VerifyVersionInfo(&OsVer,
        VER_PRODUCT_TYPE | VER_SUITENAME,
        ConditionMask
        );
}


BOOL 
AsrpIsInGroup(
    IN CONST DWORD dwGroup
    )
/*++
Routine Description:

    This function checks to see if the specified SID is enabled
    in the primary access token for the current thread.

    This is based on a similar function in dmadmin.exe.

Arguments:

    dwGroup - The SID to be checked for

Return Value:

    TRUE if the specified SID is enabled, FALSE otherwise.

--*/
{

    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    
    PSID sidGroup = NULL;
        
    BOOL bResult = FALSE,
        bIsInGroup = TRUE;

    //
    //  Build the SID for the Administrators group
    //
        bResult = AllocateAndInitializeSid(&sidAuth, 
        2, 
        SECURITY_BUILTIN_DOMAIN_RID,
        dwGroup, 
        0, 
        0, 
        0, 
        0, 
        0, 
        0, 
        &sidGroup
        );
    if (!bResult) {
        return FALSE;
    }
                
        // 
    // Check the current thread token membership
    //
    bResult = CheckTokenMembership(NULL, sidGroup, &bIsInGroup);

    FreeSid(sidGroup);

    return (bResult && bIsInGroup);
}


BOOL
AsrpHasPrivilege(
    CONST PCWSTR szPrivilege
    )
/*++
Routine Description:

    This function checks to see if the specified privilege is enabled
    in the primary access token for the current thread.

    This is based on a similar function in dmadmin.exe.

Arguments:

    szPrivilege - The privilege to be checked for

Return Value:

    TRUE if the specified privilege is enabled, FALSE otherwise.

--*/
{
    LUID luidValue;     // LUID (locally unique ID) for the privilege

    BOOL bResult = FALSE, 
        bHasPrivilege = FALSE;

    HANDLE  hToken = NULL;
    
    PRIVILEGE_SET privilegeSet;

    //
    // Get the LUID for the privilege from the privilege name
    //
    bResult = LookupPrivilegeValue(
        NULL, 
        szPrivilege, 
        &luidValue
        );
    if (!bResult) {
        return FALSE;
    }

    //
    // We want to use the token for the current process
    //
    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );
    if (!bResult) {
        return FALSE;
    }

    //
    // And check for the privilege
    //
        privilegeSet.PrivilegeCount = 1;
        privilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
        privilegeSet.Privilege[0].Luid = luidValue;
        privilegeSet.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
        
        bResult = PrivilegeCheck(hToken, &privilegeSet, &bHasPrivilege);

    CloseHandle(hToken);

    return (bResult && bHasPrivilege);
}



BOOL
AsrpCheckBackupPrivilege(
    VOID
    )
/*++
Routine Description:

    This function checks to see if the current process has the
    SE_BACKUP_NAME privilege enabled.

    This is based on a similar function in dmadmin.exe.

Arguments:

    None.

Return Value:

    TRUE if the SE_BACKUP_NAME privilege is enabled, FALSE otherwise.

--*/
{

    BOOL bHasPrivilege = FALSE;

    bHasPrivilege = AsrpHasPrivilege(SE_BACKUP_NAME);

/*
    //
    // Don't give up yet--check for the local administrator rights
    //
    if (!bHasPrivilege) {
        bHasPrivilege = AsrpIsInGroup(DOMAIN_ALIAS_RID_ADMINS);
    }
*/

    if (!bHasPrivilege) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
    }

    return bHasPrivilege;
}




//
// -------------------
// Public functions 
// -------------------
//
//  The functions below are for use by external backup and 
//  restore applications supporting ASR. 
//


//
//  ---- AsrCreateStateFile
//
BOOL
AsrCreateStateFileW(
    IN  PCWSTR      lpFilePath          OPTIONAL,
    IN  PCWSTR      lpProviderName      OPTIONAL,
    IN  CONST BOOL  bEnableAutoExtend,
    IN  PCWSTR      mszCriticalVolumes,
    OUT DWORD_PTR   *lpAsrContext
    )

/*--

Routine Description:

    AsrCreateStateFile creates an ASR state file with basic information about 
    the system, and launches third-party applications that have been 
    registered to be run as part of an ASR backup.

Arguments:

    lpFileName - Pointer to a null-terminated string that specifies the 
            full path where the ASR state-file is to be created.  If a file 
            already exists at the location pointed to by this parameter, it is
            over-written.

            This parameter can be NULL.  If it is NULL, the ASR state-file is 
            created at the default location (%systemroot%\repair\asr.sif). 

    lpProviderName - Pointer to a null-terminated string that specifies the 
            full name and version of the backup-and-restore application 
            calling AsrCreateStateFile.  There is a string size limit of 
            (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING) characters 
            for this parameter. 

            This parameter can be NULL.  If it is NULL, a "Provider=" entry is
            not created in the Version section of the ASR state file.

    bEnableAutoExtend - Indicates whether partitions are to be auto-extended 
            during an ASR restore.  If this parameter is TRUE, partitions will be 
            auto-extended during the ASR restore.  If this is FALSE, 
            partitions will not be extended.

    lpCriticalVolumes - Pointer to a multi-string containing volume-GUIDs for
            the critical volumes.  This list is used to obtain the list of 
            critical disks in the system that must be restored for a 
            successful ASR.

            The volume-GUID's must be in the NT-namespace, of the form
            \??\Volume{Guid}

            This parameter cannot be NULL.  

    lpAsrContext - Pointer to a variable receiving an ASR context. The 
            context returned should be used in calls to the other ASR API, 
            including AsrAddSifEntry.  The calling application must call 
            AsrFreeContext to free this context when it is no longer needed.

            This parameter cannot be NULL.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    BOOL    result          = FALSE;

    DWORD   status          = ERROR_SUCCESS,
            size            = 0;
    
    ULONG   maxDeviceNumber = 0;

    HANDLE  sifhandle       = NULL,
            heapHandle      = NULL;

    PWSTR   asrSifPath      = NULL,
            pnpSifPath      = NULL,
            tempPointer     = NULL;

    UINT    cchAsrSifPath = 0;

    char    UnicodeFlag[3];

    WCHAR   infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    SECURITY_ATTRIBUTES     securityAttributes;
    ASR_SYSTEM_INFO         SystemInfo;
    PASR_DISK_INFO          OriginalDiskList = NULL;


    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (!AsrpCheckBackupPrivilege()) {
        //
        // The caller needs to first acquire SE_BACKUP_NAME 
        //
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    //
    // Check the IN parameters:
    //
#ifdef PRERELEASE
    //
    // Don't enforce "CriticalVolumes must be non-NULL" for test
    //
    if (!(lpAsrContext)) 
#else 
    if (!(lpAsrContext && mszCriticalVolumes)) 
#endif
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Set the OUT paramaters to known error values
    //
    *lpAsrContext = 0;

    // 
    // Guard ourselves against returning ERROR_SUCCESS if we encountered
    // an unexpected error.  We should never actually return this, since
    // we always SetLastError whereever we return FALSE from.
    //
    SetLastError(ERROR_CAN_NOT_COMPLETE); 

    //
    // Zero out structs
    //
    memset(&SystemInfo, 0L, sizeof (SYSTEM_INFO));

    heapHandle = GetProcessHeap();

    //
    // Determine the file-path.  If lpFilePath is provided, copy it over to 
    // locally allocated memory and use it, else use the default path.
    //
    if (ARGUMENT_PRESENT(lpFilePath)) {
        cchAsrSifPath = wcslen(lpFilePath);
        //
        // Do a sanity check:  we don't want to allow a file path
        // more than 4096 characters long.
        //
        if (cchAsrSifPath > ASR_SIF_ENTRY_MAX_CHARS) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        asrSifPath = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            ((cchAsrSifPath + 1) * sizeof(WCHAR))
            );
        _AsrpErrExitCode(!asrSifPath, status, ERROR_NOT_ENOUGH_MEMORY);

        wcsncpy(asrSifPath, lpFilePath, cchAsrSifPath);

    }
    else {
        //
        // lpFilePath is NULL, form the default path (of the form
        // \\?\c:\windows\repair\asr.sif)
        //

        //
        // Try with a reasonably sized buffer to begin with.
        //
        asrSifPath = AsrpExpandEnvStrings(ASR_DEFAULT_SIF_PATH);
        _AsrpErrExitCode(!asrSifPath, status, ERROR_BAD_ENVIRONMENT);

        //
        // Set cchAsrSifPath to the size of the asrSif buffer, since we 
        // use this in determining the size of the pnpSif buffer below.
        //
        cchAsrSifPath = wcslen(asrSifPath);
    }

    //
    // Determine the file-path of the asrpnp.sif file, based on the location
    // of the asr.sif file.
    //
    pnpSifPath = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        ((cchAsrSifPath + 1 + wcslen(ASRPNP_DEFAULT_SIF_NAME))* sizeof(WCHAR))
        );
    _AsrpErrExitCode(!pnpSifPath, status, ERROR_NOT_ENOUGH_MEMORY);

    wcscpy(pnpSifPath, asrSifPath);

    tempPointer = pnpSifPath;
    while (*tempPointer) {
        tempPointer++;
    }
    while ((*tempPointer != L'\\') 
        && (*tempPointer != L':') 
        && (tempPointer >= pnpSifPath)
        ) {
        tempPointer--;
    }
    tempPointer++;
    wcscpy(tempPointer, ASRPNP_DEFAULT_SIF_NAME);

    //
    // We need to make the handle to asr.sif inheritable, since it will
    // be passed (in the guise of the "AsrContext") to apps that have 
    // registered to be run as part of ASR.
    //
    securityAttributes.nLength              = sizeof(SECURITY_ATTRIBUTES);
    securityAttributes.lpSecurityDescriptor = NULL;
    securityAttributes.bInheritHandle       = TRUE;

    //
    // Create the file. The handle will be closed by the calling backup-app.
    //
    sifhandle = CreateFileW(
        asrSifPath,                     // lpFileName
        GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode
        &securityAttributes,            // lpSecurityAttributes
        CREATE_ALWAYS,                  // dwCreationFlags
        FILE_FLAG_BACKUP_SEMANTICS,     // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );
    if (!sifhandle || INVALID_HANDLE_VALUE == sifhandle) {
        // 
        // LastError is set by CreateFile
        //
        _AsrpErrExitCode(TRUE, status, GetLastError());
    }

    //
    // File was successfully created.  Add the unicode flag at the beginning
    // of the file, followed by comments.
    //
    sprintf(UnicodeFlag, "%c%c", 0xFF, 0xFE);
    result = WriteFile(sifhandle, UnicodeFlag, 
        strlen(UnicodeFlag)*sizeof(char), &size, NULL);
    _AsrpErrExitCode(!result, status, GetLastError());

    wcscpy(infstring, 
        L";\r\n; Microsoft Windows Automated System Recovery State Information File\r\n;\r\n");
    result = WriteFile(sifhandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL);
    _AsrpErrExitCode(!result, status, GetLastError());

    //
    // Beyond this point, we must zero out asr.sif on any failure.  Also, if 
    // there's any failure, we must be careful not to make further system 
    // calls that could change the error returned by GetLastError().
    //

    //
    // Since the function return values below are and-ed, if any of the calls 
    // fails, we won't execute the ones following it.
    //
    result = (
        //
        // Initialise the global structures
        //
        AsrpInitSystemInformation(&SystemInfo, bEnableAutoExtend)
        
        && AsrpInitDiskInformation(&OriginalDiskList)
        
        && AsrpInitLayoutInformation(&SystemInfo, 
            OriginalDiskList, 
            &maxDeviceNumber, 
            TRUE
            )

        && AsrpInitClusterSharedDisks(OriginalDiskList)

        && AsrpFreeNonFixedMedia(&OriginalDiskList)

        && AsrpMarkCriticalDisks(OriginalDiskList, 
            mszCriticalVolumes, 
            maxDeviceNumber
            )

        //
        // Check if the system configuration is supported
        //
        && AsrpIsSupportedConfiguration(OriginalDiskList, &SystemInfo)

        //
        // Write the required sections to asr.sif
        //
        && AsrpWriteVersionSection(sifhandle, lpProviderName)
        && AsrpWriteSystemsSection(sifhandle, &SystemInfo)
        && AsrpWriteBusesSection(sifhandle, OriginalDiskList)
        && AsrpWriteMbrDisksSection(sifhandle, OriginalDiskList)
        && AsrpWriteGptDisksSection(sifhandle, OriginalDiskList)

        && AsrpWriteMbrPartitionsSection(sifhandle, 
            OriginalDiskList, 
            &SystemInfo
            )

        && AsrpWriteGptPartitionsSection(sifhandle, 
            OriginalDiskList, 
            &SystemInfo
            )

        && FlushFileBuffers(sifhandle)

        //
        // Create asrpnp.sif, containing entries needed to recover the PnP 
        // entries in the registry
        //
        && AsrCreatePnpStateFileW(pnpSifPath)

        );

    if (result) {
        // everything above succeeded

        //
        // Launch the apps registered to be run as part of ASR-backup.  If any
        // of these apps don't complete successfully, we'll fail the ASR-
        // backup.
        //
        result = (
            AsrpLaunchRegisteredCommands(sifhandle, mszCriticalVolumes)

            && FlushFileBuffers(sifhandle)
            );
            
    }

    if (!result) {
        //
        // One of the functions above failed--we'll make asr.sif zero-length
        // and return the error. CreateFileW or CloseHandle might over-write
        // the LastError, so we save our error now and set it at the end.
        //
        status = GetLastError();

#ifndef PRERELEASE

        //
        // On release versions, we  wipe out the asr.sif if we hit an error, 
        // so that the user doesn't unknowingly end up with an incomplete 
        // asr.sif
        //
        // We don't want to delete the incomplete asr.sif during test cycles,
        // though, since the sif may be useful for debugging.  
        //
        _AsrpCloseHandle(sifhandle);

        //
        // Delete asr.sif and create it again, so that we have a zero-length 
        // asr.sif
        //
        DeleteFileW(asrSifPath);
/*        sifhandle = CreateFileW(
            asrSifPath,             // lpFileName
            GENERIC_WRITE,          // dwDesiredAccess
            0,                      // dwShareMode
            &securityAttributes,    // lpSecurityAttributes
            CREATE_ALWAYS,          // dwCreationFlags
            FILE_ATTRIBUTE_NORMAL,  // dwFlagsAndAttributes
            NULL                    // hTemplateFile
            );

        _AsrpCloseHandle(sifhandle);
*/
#endif
        SetLastError(status);
    }


EXIT:
    //
    // Clean up
    //
    _AsrpHeapFree(asrSifPath);
    _AsrpHeapFree(pnpSifPath);

    AsrpFreeStateInformation(&OriginalDiskList, &SystemInfo);


    //
    // Set the OUT parameters
    //
    *lpAsrContext = (DWORD_PTR)sifhandle;
    
    if (ERROR_SUCCESS != status) {
        SetLastError(status);
    }

    if (!result) {
        if (ERROR_SUCCESS == GetLastError()) {
            //
            // We're going to return failure, but we haven't set the LastError to 
            // a failure code.  This is bad, since we have no clue what went wrong.
            //
            // We shouldn't ever get here, because the function returning FALSE above
            // should set the LastError as it sees fit.
            // 
            // But I've added this in just to be safe.  Let's set it to a generic
            // error.
            //
            MYASSERT(0 && L"Returning failure, but LastError is not set");
            SetLastError(ERROR_CAN_NOT_COMPLETE);
        }
    }

    return ((result) && (ERROR_SUCCESS == status));
}


BOOL
AsrCreateStateFileA(
    IN  LPCSTR      lpFilePath,
    IN  LPCSTR      lpProviderName,
    IN  CONST BOOL  bEnableAutoExtend,
    IN  LPCSTR      mszCriticalVolumes,
    OUT DWORD_PTR   *lpAsrContext
    )
/*++
Routine Description:

    This is the ANSI wrapper for AsrCreateStateFile.  Please see 
    AsrCreateStateFileW for a detailed description.

Arguments:
                                         

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    PWSTR   asrSifPath              = NULL,
            providerName            = NULL,
            lpwszCriticalVolumes    = NULL;

    DWORD   cchString               = 0,
            status                  = ERROR_SUCCESS;

    BOOL    result                  = FALSE;

    HANDLE  heapHandle              = GetProcessHeap();

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (!AsrpCheckBackupPrivilege()) {
        //
        // The caller needs to first acquire SE_BACKUP_NAME 
        //
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    //
    // Check the IN parameters
    //
#ifdef PRERELEASE
    //
    // Don't enforce "CriticalVolumes must be non-NULL" for test
    //
    if (!(lpAsrContext)) {
#else 
    if (!(lpAsrContext && mszCriticalVolumes)) {
#endif

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // if lpFilePath is not NULL, allocate a big enough buffer to hold 
    // it, and convert it to wide char
    //
    if (lpFilePath) {
        cchString = strlen(lpFilePath);
        //
        // Do a sanity check:  we don't want to allow a file path
        // more than 4096 characters long.
        //
        _AsrpErrExitCode(
            (cchString > ASR_SIF_ENTRY_MAX_CHARS),
            status,
            ERROR_INVALID_PARAMETER
            );

        //
        // Allocate a big enough buffer, and copy it over
        //
        asrSifPath = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            ((cchString + 1) * sizeof(WCHAR))
            );
        _AsrpErrExitCode(!asrSifPath, status, ERROR_NOT_ENOUGH_MEMORY);

        result = MultiByteToWideChar(CP_ACP,    // CodePage
            0,                      // dwFlags
            lpFilePath,             // lpMultiByteStr
            -1,                     // cbMultiByte: -1 since lpMultiByteStr is null terminated
            asrSifPath,             // lpWideCharStr
            (cchString + 1)         // cchWideChar 
            );
        _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);
    }

    //
    // if lpProviderName is not NULL, make sure it isn't insanely long, 
    // and convert it to wide char 
    //
    if (lpProviderName) {
         cchString = strlen(lpProviderName);
        //
        // Do a sanity check:  we don't want to allow an entry
        // more than 4096 characters long.
        //
        _AsrpErrExitCode(
            (cchString > (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING)),
            status,
            ERROR_INVALID_PARAMETER
            );
       
        // 
        // Allocate a big enough buffer, and copy it over
        //
        providerName = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            ((cchString + 1) * sizeof(WCHAR))
            );
        _AsrpErrExitCode(!providerName, status, ERROR_NOT_ENOUGH_MEMORY);

        //
        // Convert to wide string
        //
        result = MultiByteToWideChar(CP_ACP,
            0,
            lpProviderName,
            -1,
            providerName,
            cchString + 1
            );
        _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);

    }

    if (mszCriticalVolumes) {
        //
        // Find the total length of mszCriticalVolumes
        //
        LPCSTR lpVolume = mszCriticalVolumes;

        while (*lpVolume) {
            lpVolume += (strlen(lpVolume) + 1);
        }

        //
        //  Convert the string to wide-chars
        //
        cchString = (DWORD) (lpVolume - mszCriticalVolumes + 1);
        lpwszCriticalVolumes = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            cchString * sizeof(WCHAR)
            );
        _AsrpErrExitCode(!lpwszCriticalVolumes, status, ERROR_NOT_ENOUGH_MEMORY);

        result = MultiByteToWideChar(CP_ACP,
            0,
            mszCriticalVolumes,
            cchString,
            lpwszCriticalVolumes,
            cchString * sizeof(WCHAR)
            );
        _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);
    }

    result = AsrCreateStateFileW(
        asrSifPath,
        providerName,
        bEnableAutoExtend,
        lpwszCriticalVolumes,
        lpAsrContext
        );

EXIT:
    _AsrpHeapFree(asrSifPath);
    _AsrpHeapFree(providerName);
    _AsrpHeapFree(lpwszCriticalVolumes);

    return ((result) && (ERROR_SUCCESS == status));
}


//
// ---- AsrAddSifEntry
//
BOOL
AsrAddSifEntryW(
    IN  DWORD_PTR   AsrContext,
    IN  PCWSTR      lpSectionName,
    IN  PCWSTR      lpSifEntry  OPTIONAL
    )
/*++

Routine Description:

    The AsrSifEntry function adds entries to the ASR state file.  It can be 
    used by applications that need to save application-specific information
    in the ASR state file.

Arguments:

    AsrContext - A valid ASR context.  See the notes for more information 
            about this parameter.

    lpSectionName - Pointer to a null-terminated string that specifies the 
            section name.  This parameter cannot be NULL.

            The section name has a string size limit of ASR_MAX_SIF_LINE 
            characters.  This limit is related to how the AsrAddSifEntry 
            function parses entries in the ASR state file.

            The section name is case-insensitive.  It is converted to all-caps
            before being added to the state file. The section name must not 
            contain spaces or non-printable characters.  The valid character 
            set for section name is limited to letters (A-Z, a-z), numbers 
            (0-9), and the following special characters: underscore ("_") 
            and period (".").  If the state file does not contain a section
            with the section name pointed to by lpSectionName, a new 
            section is created with this section name.

    lpSifEntry - Pointer to a null-terminated string that is to be added to 
            the state file in the specified section. If *lpSifEntry is a 
            valid entry, there is a string size limit of 
            ASR_SIF_ENTRY_MAX_CHARS characters.  This limit is related 
            to how the AsrAddSifEntry function parses entries in the 
            ASR state file.

            If lpSifEntry parameter is NULL, an empty section with the 
            section name pointed to by lpSectionName is created if it 
            doesn't already exist.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

Notes:

    The application calling AsrAddSifEntry obtains the ASR context by one of 
    two methods:
     -  If the application is the backup-and-restore application that creates 
        the ASR state file, it receives the context as a parameter returned by 
        AsrCreateStateFile.
     -  If the application is launched by AsrCreateStateFile as part of an ASR
        backup, it receives the context to the state file as the /context 
        command-line parameter.  The application is responsible for reading 
        this parameter to get the value of the context.

    AsrAddSifEntry will fail if the section name is that of a reserved section 
    that applications are not allowed to add entries to.  The following sections 
    in the ASR state file are reserved: 
     -  Version, System, Disks.Mbr, Disk.Gpt, Partitions.Mbr and Partitions.Gpt

    If the section name is recognised (Commands or InstallFiles), AsrAddSifEntry 
    will check the syntax of *lpSifEntry to ensure that it is in the proper 
    format.  In addition, AsrAddSifEntry will check to ensure that there are no 
    filename collisions for the InstallFiles section.  If a collision is 
    detected, the API returns ERROR_ALREADY_EXISTS. Applications must
    use the following pre-defined values to access the recognised sections:
     -  ASR_COMMANDS_SECTION_NAME_W for the Commands section, and
     -  ASR_INSTALLFILES_SECTION_NAME for the InstallFiles section.

--*/
{
    DWORD   status              = ERROR_SUCCESS,
            nextKey             = 0,
            fileOffset          = 0,
            size                = 0,
            fileSize            = 0,
            bufferSize          = 0,
            destFilePos         = 0;

    HANDLE  sifhandle           = NULL;

    WCHAR   sifstring[ASR_SIF_ENTRY_MAX_CHARS *2 + 1],
            ucaseSectionName[ASR_SIF_ENTRY_MAX_CHARS + 1]; // lpSectionName converted to upper case

    PWSTR   buffer              = NULL,
            sectionStart        = NULL,
            lastEqual           = NULL,
            nextSection         = NULL,
            nextChar            = NULL,
            sectionName         = NULL;

    BOOL    commandsSection     = FALSE,
            installFilesSection = FALSE,
            result              = FALSE;

    HANDLE  heapHandle          = NULL;

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (!AsrpCheckBackupPrivilege()) {
        //
        // The caller needs to first acquire SE_BACKUP_NAME 
        //
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    //
    // Zero out local structs
    //
    memset(sifstring, 0, (ASR_SIF_ENTRY_MAX_CHARS *2 + 1) * sizeof(WCHAR));
    memset(ucaseSectionName, 0, (ASR_SIF_ENTRY_MAX_CHARS + 1) * (sizeof (WCHAR)));

    //
    // No OUT parameters
    //

    //
    // Check the IN parameters: The SectionName should meet
    // syntax requirements, SifEntry shouldn't be too long,
    // and the sifhandle should be valid.
    //
    if ((!AsrpSifCheckSectionNameSyntax(lpSectionName))            ||
        
        (ARGUMENT_PRESENT(lpSifEntry) 
            && (wcslen(lpSifEntry) > ASR_SIF_ENTRY_MAX_CHARS))      ||

        ((!AsrContext) || 
            (INVALID_HANDLE_VALUE == (HANDLE)AsrContext))

        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    while (lpSectionName[size]) {
        if ((lpSectionName[size] >= L'a') && (lpSectionName[size] <= L'z')) {
            ucaseSectionName[size] = lpSectionName[size] - L'a' + L'A';
        }
        else {
            ucaseSectionName[size] = lpSectionName[size];
        }
        size++;
    }

    //
    // If the section is a recognised section (COMMANDS or INSTALLFILES),
    // we check the format of the sif entry.
    //
    if (!wcscmp(ucaseSectionName, ASR_SIF_SECTION_COMMANDS_W)) {

        // COMMANDS section
        if (!AsrpSifCheckCommandsEntrySyntax(lpSifEntry)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        commandsSection = TRUE;
    }
    else if(!wcscmp(ucaseSectionName, ASR_SIF_SECTION_INSTALLFILES_W)) {

        // INSTALLFILES section
        if (!AsrpSifCheckInstallFilesEntrySyntax(lpSifEntry, &destFilePos)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        installFilesSection = TRUE;
    }

    //
    // We do not allow anyone to write to reserved sections:
    // VERSION, SYSTEMS, DISKS.[MBR|GPT], PARTITIONS.[MBR|GPT]
    //
    else if (
        !wcscmp(ucaseSectionName, ASR_SIF_VERSION_SECTION_NAME) ||
        !wcscmp(ucaseSectionName, ASR_SIF_SYSTEM_SECTION_NAME) ||
        !wcscmp(ucaseSectionName, ASR_SIF_MBR_DISKS_SECTION_NAME)   ||
        !wcscmp(ucaseSectionName, ASR_SIF_GPT_DISKS_SECTION_NAME)   ||
        !wcscmp(ucaseSectionName, ASR_SIF_MBR_PARTITIONS_SECTION_NAME) ||
        !wcscmp(ucaseSectionName, ASR_SIF_GPT_PARTITIONS_SECTION_NAME)
        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    }

    sectionName = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (wcslen(ucaseSectionName) + 5) * sizeof (WCHAR)
        );
    _AsrpErrExitCode(!sectionName, status, ERROR_NOT_ENOUGH_MEMORY);

    swprintf(sectionName, L"\r\n%ws\r\n", ucaseSectionName);

    sifhandle = (HANDLE) AsrContext;

    //
    // The algorithm to add to the middle of asr.sif is rather ugly
    // at the moment: we read the entire file into memory, make our
    // necessary changes, and write back the changed portion of the
    // file to disk.  This is inefficient, but it's okay for now since
    // we expect asr.sif to be about 5 or 6 KB at the most.
    //
    // We should revisit this if the performance is unacceptably poor.
    //

    //
    // Allocate memory for the file
    //
    fileSize = GetFileSize(sifhandle, NULL);
    GetLastError();
    _AsrpErrExitCode((fileSize == 0xFFFFFFFF), status, ERROR_INVALID_DATA);

    SetFilePointer(sifhandle, 0, NULL, FILE_BEGIN);

    buffer = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        fileSize + 2
        );
    _AsrpErrExitCode(!buffer, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // And read file into memory.
    //
    result = ReadFile(sifhandle, buffer, fileSize, &size, NULL);
    _AsrpErrExitCode(!result, status, GetLastError());

    //
    // Try to locate ucaseSectionName in the file
    //
    sectionStart = wcsstr(buffer, sectionName);

    if (!sectionStart) {

        //
        // sectionName was not found, ie the section does not exist
        // Add it at the end, and add the SifEntry right after it.
        //
        swprintf(sifstring,
            L"\r\n%ws\r\n%ws%ws\r\n",
            ucaseSectionName,
            ((commandsSection || installFilesSection) ? L"1=" : L""),
            (ARGUMENT_PRESENT(lpSifEntry) ? lpSifEntry : L"")
            );

        //
        // File pointer already points to the end (because of ReadFile above)
        //
        if (!WriteFile(sifhandle, sifstring, 
                wcslen(sifstring)*sizeof (WCHAR), &size, NULL)) {
            status = GetLastError();
        }

        // We're done

    }
    else {

        //
        // The section exists, if lpSifEntry is NULL, we're done
        //
        if (ARGUMENT_PRESENT(lpSifEntry)) {

            //
            // SifEntry is not NULL, we'll add it at the end of the section
            //
            nextChar = sectionStart + 4;    // Move pointer from \r to . in \r\n[.
            nextKey = 1;

            //
            // Find where this section ends--look either for the start
            // of the next section, or for the end of the file
            //
            while(*nextChar && *nextChar != L'[') {

                //
                // If this is a recognised section, we need to generate
                // the <key> to add the entry in a <key>=<entry> format.
                // We go through each line, and find the last key that
                // already exists.  The new key will be last key + 1.
                //
                if (commandsSection || installFilesSection) {

                    UINT    commaCount = 0;
                    BOOL    tracking = FALSE;
                    UINT    count = 0;
                    WCHAR   c1, c2;

                    while (*nextChar && (*nextChar != L'[') && (*nextChar != L'\n')) {

                        if (installFilesSection) {
                            if (*nextChar == L',') {
                                commaCount++;
                            }

                            if ((commaCount > 2) && (L'"' == *nextChar)) {
                                if (tracking) {
                                    // duplicate file name
                                    _AsrpErrExitCode((L'"'== lpSifEntry[destFilePos + count]), status, ERROR_ALREADY_EXISTS);
                                }
                                else {
                                    tracking = TRUE;
                                    count = 0;
                                }
                            }

                            if (tracking) {

                                c1 = *nextChar;
                                if (c1 >= L'a' && c1 <= L'z') {
                                    c1 = c1 - L'a' + L'A';
                                }

                                c2 = lpSifEntry[destFilePos + count];
                                if (c2 >= L'a' && c2 <= L'z') {
                                    c2 = c2 - L'a' + L'A';
                                }

                                if (c1 == c2) {
                                    count++;
                                }
                                else {
                                    tracking = FALSE;
                                }
                            }
                        }

                        nextChar++;
                    }

                    if (*nextChar == L'\n') {

                        ++nextChar;

                        if (*nextChar >= L'0' && *nextChar <= L'9') {
                            nextKey = 0;

                            while (*nextChar >= L'0' && *nextChar <= L'9') {
                                nextKey = nextKey*10 + (*nextChar - L'0');
                                nextChar++;
                            }

                            nextKey++;
                        }
                    }
                }
               else {
                   nextChar++;
               }
            }

            //
            // We save a pointer to the next section in the sif, since we
            // need to write it out to disk.
            //
            if (*nextChar) {
                nextSection = nextChar;
            }
            else {
                nextSection = NULL;
            }

            if (commandsSection || installFilesSection) {

                //
                // Form the <key>=<entry> string
                //
                swprintf(
                    sifstring,
                    L"%lu=%ws\r\n",
                    nextKey,
                    lpSifEntry
                    );
            }
            else {

                //
                // Not a recognised section: don't add the <key>=<entry>
                // format, keep the string exactly as passed in
                //
                wcscpy(sifstring, lpSifEntry);
                wcscat(sifstring, L"\r\n");
            }


            if (nextSection) {
                //
                // There are sections following the section we're adding to
                // We need to mark the point where the new entry is added.
                // While writing out to disk, we'll start from this point.
                //
                fileOffset = (DWORD) (((LPBYTE)nextSection) - ((LPBYTE)buffer) - sizeof(WCHAR)*2);
                             // section start      - file start       - "\r\n"
                SetFilePointer(sifhandle, fileOffset, NULL, FILE_BEGIN);
            }

            //
            // file pointer points to where the entry must be added
            //
            if (!WriteFile(sifhandle, sifstring, wcslen(sifstring)*sizeof(WCHAR), &size, NULL)) {
                status = GetLastError();
            }
            else  if (nextSection) {
                //
                // write out all sections following this entry
                //
                if (!WriteFile(
                    sifhandle,
                    ((LPBYTE)nextSection) - (sizeof(WCHAR)*2),
                    fileSize - fileOffset,
                    &size,
                    NULL
                    )) {
                    status = GetLastError();
                }
            }
        }
    }

EXIT:
    _AsrpHeapFree(sectionName);
    _AsrpHeapFree(buffer);

    return (BOOL) (ERROR_SUCCESS == status);
}


BOOL
AsrAddSifEntryA(
    IN  DWORD_PTR   AsrContext,
    IN  LPCSTR      lpSectionName,
    IN  LPCSTR      lpSifEntry OPTIONAL
    )
/*++

    This is the ANSI wrapper for AsrAddSifEntry.
    See AsrAddSifEntryW for a full description.

--*/
{
    WCHAR   wszSectionName[ASR_SIF_ENTRY_MAX_CHARS + 1];
    WCHAR   wszSifEntry[ASR_SIF_ENTRY_MAX_CHARS + 1];

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (!AsrpCheckBackupPrivilege()) {
        //
        // The caller needs to first acquire SE_BACKUP_NAME 
        //
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    memset(wszSectionName, 0L, ASR_SIF_ENTRY_MAX_CHARS + 1);
    memset(wszSifEntry, 0L, ASR_SIF_ENTRY_MAX_CHARS + 1);

    //
    // lpSectionName must be non-NULL
    //
    if ((!lpSectionName) || !(MultiByteToWideChar(
        CP_ACP,
        0,
        lpSectionName,
        -1,
        wszSectionName,
        ASR_SIF_ENTRY_MAX_CHARS + 1
        ))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // lpSifEntry is allowed to be NULL
    //
    if (ARGUMENT_PRESENT(lpSifEntry) && !(MultiByteToWideChar(
        CP_ACP,
        0,
        lpSifEntry,
        -1,
        wszSifEntry,
        ASR_SIF_ENTRY_MAX_CHARS + 1
        ))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return AsrAddSifEntryW(
        AsrContext,
        wszSectionName,
        wszSifEntry
        );
}


//
// ---- AsrFreeContext
//
BOOL
AsrFreeContext(
    IN OUT DWORD_PTR *lpAsrContext
    )

/*++

Routine Description:
  
    AsrFreeContext frees the Asr Context, and sets lpAsrContext 
    to NULL.

Arguments:

    lpAsrContext    This is the Asr context to be freed.  This argument must
                    not be NULL.

                    AsrFreeContext will set this value to NULL after freeing 
                    it, to prevent further unintended accesses to the freed 
                    object.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    BOOL result = FALSE;

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    //
    // Essentially, the lpAsrContext is just a file handle, and all we need
    // to do to free it is call CloseHandle.
    //
    if ((lpAsrContext) && 
        (*lpAsrContext) && 
        (INVALID_HANDLE_VALUE != (HANDLE)(*lpAsrContext))
        ) {
        result = CloseHandle((HANDLE)*lpAsrContext);
        *lpAsrContext = 0;
    }
    else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\billbrd.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    billbrd.c

Abstract:

    Routines for displaying Windows that are static in nature.

Author:

    Ted Miller (tedm) 8-Jun-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Define structure we pass around to describe a billboard.
//
typedef struct _BILLBOARD_PARAMS {
    UINT MessageId;
    va_list *arglist;
    HWND Owner;
    DWORD NotifyThreadId;
} BILLBOARD_PARAMS, *PBILLBOARD_PARAMS;

//
// Custom window messages
//
#define WMX_BILLBOARD_DISPLAYED     (WM_USER+243)
#define WMX_BILLBOARD_TERMINATE     (WM_USER+244)

#define ID_REBOOT_TIMER         10


//
// Import the entry point used to check whether setup is executing within an
// ASR context.
//

extern BOOL
AsrIsEnabled( VOID );


INT_PTR
BillboardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static BOOL Initializing;
    HWND Animation = GetDlgItem(hdlg,IDA_SETUPINIT);
    static HANDLE   hBitmap;
    static HCURSOR  hCursor;


    switch(msg) {

    case WM_INITDIALOG:
        {
            PBILLBOARD_PARAMS BillParams;
            PWSTR p;
            BOOL b;


            BillParams = (PBILLBOARD_PARAMS)lParam;

            if(BillParams->MessageId == MSG_INITIALIZING) {
                Initializing = TRUE;
                b = TRUE;
                hCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
                ShowCursor( TRUE );
                Animate_Open(Animation,MAKEINTRESOURCE(IDA_SETUPINIT));
                hBitmap = LoadBitmap (MyModuleHandle, MAKEINTRESOURCE(IDB_INIT_WORKSTATION));
                SendDlgItemMessage(hdlg,IDC_BITMAP,STM_SETIMAGE,IMAGE_BITMAP,(LPARAM)hBitmap);
            } else {
                Initializing = FALSE;
                if(p = RetrieveAndFormatMessageV(SETUPLOG_USE_MESSAGEID,
                    BillParams->MessageId,BillParams->arglist)) {

                    b = SetDlgItemText(hdlg,IDT_STATIC_1,p);
                    MyFree(p);
                } else {
                    b = FALSE;
                }
            }


            if(b) {
                //
                // Center the billboard relative to the window that owns it.
                //
                // if we have the BB window, do the positioning on that. 
                // MainWindowHandle point to that window
                //
                if (GetBBhwnd())
                    CenterWindowRelativeToWindow(hdlg, MainWindowHandle, FALSE);
                else
                    pSetupCenterWindowRelativeToParent(hdlg);
                //
                // Post ourselves a message that we won't get until we've been
                // actually displayed on the screen. Then when we process that message,
                // we inform the thread that created us that we're up. Note that
                // once that notification has been made, the BillParams we're using
                // now will go away since they are stored in local vars (see
                // DisplayBillboard()).
                //
                PostMessage(hdlg,WMX_BILLBOARD_DISPLAYED,0,(LPARAM)BillParams->NotifyThreadId);
                //
                // Tell Windows not to process this message.
                //
                return(FALSE);
            } else {
                //
                // We won't post the message, but returning -1 will get the
                // caller of DialogBox to post it for us.
                //
                EndDialog(hdlg,-1);
            }
        }
        break;

    case WMX_BILLBOARD_DISPLAYED:

        if(Initializing) {
            Animate_Play(Animation,0,-1,-1);
        }

        PostThreadMessage(
            (DWORD)lParam,
            WMX_BILLBOARD_DISPLAYED,
            TRUE,
            (LPARAM)hdlg
            );

        break;

    case WMX_BILLBOARD_TERMINATE:

        if(Initializing) {
            SetCursor( hCursor );
            ShowCursor( FALSE );
            Animate_Stop(Animation);
            Animate_Close(Animation);
            DeleteObject(hBitmap);
        }
        EndDialog(hdlg,0);
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


DWORD
BillboardThread(
    IN PVOID ThreadParam
    )
{
    PBILLBOARD_PARAMS BillboardParams;
    INT_PTR i;

    BillboardParams = ThreadParam;

    //
    // For the "initializing" case, we use a different dialog.
    //
    if( AsrIsEnabled() ) {
        i = DialogBoxParam(
                        MyModuleHandle,
                        (BillboardParams->MessageId == MSG_INITIALIZING) ?
                        MAKEINTRESOURCE(IDD_SETUPINIT_ASR) :
                        MAKEINTRESOURCE(IDD_BILLBOARD1),
                        BillboardParams->Owner,
                        BillboardDlgProc,
                        (LPARAM)BillboardParams
                        );
    } else {
        i = DialogBoxParam(
                        MyModuleHandle,
                        (BillboardParams->MessageId == MSG_INITIALIZING) ?
                        MAKEINTRESOURCE(IDD_SETUPINIT) :
                        MAKEINTRESOURCE(IDD_BILLBOARD1),
                        BillboardParams->Owner,
                        BillboardDlgProc,
                        (LPARAM)BillboardParams
                        );
    }

    //
    // If the dialog box call failed, we have to tell the
    // main thread about it here. Otherwise the dialog proc
    // tells the main thread.
    //
    if(i == -1) {
        PostThreadMessage(
            BillboardParams->NotifyThreadId,
            WMX_BILLBOARD_DISPLAYED,
            FALSE,
            (LPARAM)NULL
            );
    }

    return(0);
}


HWND
DisplayBillboard(
    IN HWND Owner,
    IN UINT MessageId,
    ...
    )
{
    HANDLE ThreadHandle;
    DWORD ThreadId;
    BILLBOARD_PARAMS ThreadParams;
    va_list arglist;
    HWND hwnd;
    MSG msg;

    hwnd = NULL;
    // If we have a billboard, we should not need this. dialog.
    if (GetBBhwnd() == NULL)
    {
        va_start(arglist,MessageId);

        //
        // The billboard will exist in a separate thread so it will
        // always be responsive.
        //
        ThreadParams.MessageId = MessageId;
        ThreadParams.arglist = &arglist;
        ThreadParams.Owner = Owner;
        ThreadParams.NotifyThreadId = GetCurrentThreadId();

        ThreadHandle = CreateThread(
                            NULL,
                            0,
                            BillboardThread,
                            &ThreadParams,
                            0,
                            &ThreadId
                            );

        if(ThreadHandle) {
            //
            // Wait for the billboard to tell us its window handle
            // or that it failed to display the billboard dialog.
            //
            do {
                GetMessage(&msg,NULL,0,0);
                if(msg.message == WMX_BILLBOARD_DISPLAYED) {
                    if(msg.wParam) {
                        hwnd = (HWND)msg.lParam;
                        Sleep(1500);        // let the user see it even on fast machines
                    }
                } else {
                    DispatchMessage(&msg);
                }
            } while(msg.message != WMX_BILLBOARD_DISPLAYED);

            CloseHandle(ThreadHandle);
        }

        va_end(arglist);
    }
    else
    {
        // Start BB text
        StartStopBB(TRUE);
    }
    return(hwnd);
}


VOID
KillBillboard(
    IN HWND BillboardWindowHandle
    )
{
    if(BillboardWindowHandle && IsWindow(BillboardWindowHandle)) {
        PostMessage(BillboardWindowHandle,WMX_BILLBOARD_TERMINATE,0,0);
    }
}


INT_PTR
DoneDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PWSTR p;
    static UINT Countdown;

    switch(msg) {

    case WM_INITDIALOG:

        // if we have the BB window, do the positioning on that. MainWindowHandle point to that window
        if (GetBBhwnd())
            CenterWindowRelativeToWindow(hdlg, MainWindowHandle, FALSE);
        else
            pSetupCenterWindowRelativeToParent(hdlg);

        SendDlgItemMessage(
            hdlg,
            IDOK,
            BM_SETIMAGE,
            0,
            (LPARAM)LoadBitmap(MyModuleHandle,MAKEINTRESOURCE(IDB_REBOOT))
            );

        if(p = RetrieveAndFormatMessage(NULL,(UINT)lParam)) {
            SetDlgItemText(hdlg,IDT_STATIC_1,p);
            MyFree(p);
        }

        Countdown = 15 * 10;
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETRANGE,0,MAKELONG(0,Countdown));
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETSTEP,1,0);
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETPOS,0,0);
        SetTimer(hdlg,ID_REBOOT_TIMER,100,NULL);

        SetFocus(GetDlgItem(hdlg,IDOK));
        return(FALSE);

    case WM_TIMER:

        Countdown--;

        if(Countdown) {
            SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_STEPIT,0,0);
        } else {
            KillTimer(hdlg,ID_REBOOT_TIMER);
            DeleteObject((HGDIOBJ)SendDlgItemMessage(hdlg,IDOK,BM_GETIMAGE,0,0));
            EndDialog(hdlg,0);
        }

        break;

    case WM_COMMAND:

        if((HIWORD(wParam) == BN_CLICKED) && (LOWORD(wParam) == IDOK)) {
            KillTimer(hdlg,ID_REBOOT_TIMER);
            DeleteObject((HGDIOBJ)SendDlgItemMessage(hdlg,IDOK,BM_GETIMAGE,0,0));
            EndDialog(hdlg,0);
        } else {
            return(FALSE);
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

typedef BOOL (CALLBACK *STOPBILLBOARD)();
typedef BOOL (CALLBACK *STARTBILLBOARD)();
typedef BOOL (WINAPI* SETTIMEESTIMATE)(LPCTSTR szText);
typedef BOOL (WINAPI* SETPROGRESSTEXT)(LPCTSTR szText);
typedef BOOL (WINAPI* SETINFOTEXT)(LPCTSTR szText);
typedef LRESULT (WINAPI* PROGRESSGAUGEMSG)(UINT msg, WPARAM wparam, LPARAM lparam);
typedef BOOL (WINAPI* SHOWPROGRESSGAUGEWINDOW)(UINT uiShow);

BOOL BB_ShowProgressGaugeWnd(UINT nCmdShow)
{
    static SHOWPROGRESSGAUGEWINDOW fpShowGauge = NULL;
    BOOL bRet = FALSE;

    if (fpShowGauge == NULL)
    {
        if (hinstBB)
        {
            fpShowGauge = (SHOWPROGRESSGAUGEWINDOW )GetProcAddress(hinstBB, "ShowProgressGaugeWindow");
        }
    }
    if (fpShowGauge != NULL)
    {
        bRet = fpShowGauge(nCmdShow);
    }
    return bRet;
}
LRESULT BB_ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam)
{
    static PROGRESSGAUGEMSG fpProgressGaugeMsg = NULL;
    LRESULT lresult = 0;

    if (fpProgressGaugeMsg == NULL)
    {
        if (hinstBB)
        {
            fpProgressGaugeMsg = (PROGRESSGAUGEMSG )GetProcAddress(hinstBB, "ProgressGaugeMsg");
        }
    }
    if (fpProgressGaugeMsg != NULL)
    {
        lresult = fpProgressGaugeMsg(msg, wparam, lparam);
    }
    return lresult;
}
void BB_SetProgressText(LPCTSTR szText)
{
    static SETPROGRESSTEXT fpSetProgressText = NULL;
    if (fpSetProgressText == NULL)
    {
        if (hinstBB)
        {
            fpSetProgressText = (SETPROGRESSTEXT )GetProcAddress(hinstBB, "SetProgressText");
        }
    }
    if (fpSetProgressText != NULL)
    {
        fpSetProgressText(szText);
    }
}
void BB_SetInfoText(LPTSTR szText)
{
    static SETINFOTEXT fpSetInfoText = NULL;
    if (fpSetInfoText == NULL)
    {
        if (hinstBB)
        {
            fpSetInfoText = (SETINFOTEXT )GetProcAddress(hinstBB, "SetInfoText");
        }
    }
    if (fpSetInfoText != NULL)
    {
        fpSetInfoText(szText);
    }
}
void BB_SetTimeEstimateText(LPTSTR szText)
{
    static SETTIMEESTIMATE fpSetTimeEstimate = NULL;
    if (fpSetTimeEstimate == NULL)
    {
        if (hinstBB)
        {
            fpSetTimeEstimate = (SETTIMEESTIMATE)GetProcAddress(hinstBB, "SetTimeEstimate");
        }
    }
    if (fpSetTimeEstimate != NULL)
    {
        fpSetTimeEstimate(szText);
    }
}

BOOL StartStopBB(BOOL bStart)
{
    static STARTBILLBOARD fpStart = NULL;
    static STOPBILLBOARD fpStop = NULL;
    BOOL bRet = FALSE;

    if ((fpStart == NULL) || (fpStop == NULL))
    {
        if (hinstBB)
        {
            fpStop = (STARTBILLBOARD )GetProcAddress(hinstBB, "StopBillBoard");
            fpStart = (STOPBILLBOARD )GetProcAddress(hinstBB, "StartBillBoard");
        }
    }
    if ((fpStart != NULL) && (fpStop != NULL))
    {
        if (bStart)
            bRet = fpStart();
        else
            bRet = fpStop();

    }
    return bRet;
}

LRESULT ProgressGaugeMsgWrapper(UINT msg, WPARAM wparam, LPARAM lparam)
{
    static DWORD MsecPerProcessTick;
    static DWORD PreviousRemainingTime = 0;
    static DWORD RemainungTimeMsecInThisPhase = 0;
    static int  iCurrentPos = 0;
    static int  iMaxPosition = 0;
    static int  iStepSize = 0;

    static UINT PreviousPhase = Phase_Unknown;
    static BOOL IgnoreSetRange = FALSE;
    static BOOL IgnoreSetPos  = FALSE;

    DWORD dwDeltaTicks = 0;
    switch (msg)
    {
        case WMX_PROGRESSTICKS:
            // If we get a WMX_PROGRESSTICKS before a PBM_SETRANGE, ignore the set range
            // This should be use if the progress bar only takes up x% of the whole bar.
            // In this case the phase sends PBM_SETRANGE and a PBM_SETPOS to setup the
            // progress values for it's part of the gauge.
            IgnoreSetRange = TRUE;
            if (PreviousPhase != CurrentPhase)
            {
                PreviousPhase = CurrentPhase;
                iCurrentPos = 0;
                iMaxPosition = (int)wparam;
                iStepSize = 10;

                MsecPerProcessTick = ((SetupPhase[CurrentPhase].Time*1000)/(iMaxPosition - iCurrentPos) )+ 1;
                RemainungTimeMsecInThisPhase = (SetupPhase[CurrentPhase].Time * 1000);
                PreviousRemainingTime = RemainungTimeMsecInThisPhase;
            }
            else
            {
                // what to do if the same phase send more then one set range.
                // don't change the remaining time, only recal the msecperprogresstick
                // 
                iCurrentPos = 0;
                iMaxPosition = (int)wparam;
                iStepSize = 10;
                MsecPerProcessTick = (RemainungTimeMsecInThisPhase /(iMaxPosition - iCurrentPos) )+ 1;
            }
            break;

        case PBM_SETPOS:
            {
                UINT uiCurrentPos;
                if (!IgnoreSetPos)
                {
                    int iDeltaPos = 0;
                    // Find out where the current position of the gasgauge is.
                    // The difference is the #ticks we use to reduce the time estimate
            
                    uiCurrentPos = (UINT)BB_ProgressGaugeMsg(PBM_GETPOS, 0, 0);
                    // See if there is a difference in the current position and the one 
                    // we think we are in.
                    // Only if the new position is greater then the current one 
                    // calc the difference and substract from remaining time.
                    if ((UINT)wparam > uiCurrentPos)
                    {
                        iDeltaPos = (UINT)wparam - uiCurrentPos;
                        iCurrentPos += iDeltaPos;
                        // Only substract if more time left
                        if ((iDeltaPos * MsecPerProcessTick) < RemainungTimeMsecInThisPhase)
                        {
                            RemainungTimeMsecInThisPhase -= (iDeltaPos * MsecPerProcessTick);
                        }
                        else
                        {
                            RemainungTimeMsecInThisPhase = 0;
                        }
                        UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
                    }
                }
                IgnoreSetPos = FALSE;
            }
            break;

        case PBM_SETRANGE:
        case PBM_SETRANGE32:
            // did the phase not send the private message above
            if (!IgnoreSetRange)
            {
                // Are we not in the same phase?
                if (PreviousPhase != CurrentPhase)
                {
                    PreviousPhase = CurrentPhase;
                    // Get the new start and max position
                    if (msg == PBM_SETRANGE32)
                    {
                        iCurrentPos = (int)wparam;
                        iMaxPosition = (int)lparam;
                    }
                    else
                    {
                        iCurrentPos = LOWORD(lparam);
                        iMaxPosition = HIWORD(lparam);
                    }
                    iStepSize = 10;

                    // Calc the msec per tick and msec in this phase
                    MsecPerProcessTick = ((SetupPhase[CurrentPhase].Time*1000)/(iMaxPosition - iCurrentPos) )+ 1;
                    RemainungTimeMsecInThisPhase = (SetupPhase[CurrentPhase].Time * 1000);
                    PreviousRemainingTime = RemainungTimeMsecInThisPhase;
                }
                else
                {
                    // the same phase send more then one set range.
                    // 1. don't change the remaining time, only recal the msecperprogresstick
                    // 2. Ignore the next PBM_SETPOS message.
                    // 
                    // Get the new start and max position
                    if (msg == PBM_SETRANGE32)
                    {
                        iCurrentPos = (int)wparam;
                        iMaxPosition = (int)lparam;
                    }
                    else
                    {
                        iCurrentPos = LOWORD(lparam);
                        iMaxPosition = HIWORD(lparam);
                    }
                    iStepSize = 10;
                    MsecPerProcessTick = (RemainungTimeMsecInThisPhase /(iMaxPosition - iCurrentPos) )+ 1;
                    IgnoreSetPos = TRUE;
                }
            }
            else
            {
                // If we ignored the setrange, also ignore the first set pos.
                IgnoreSetPos = TRUE;
            }
            IgnoreSetRange = FALSE;
            break;

        case PBM_DELTAPOS:
            {
                int iDeltaPos = 0;
                // wparam has the # of ticks to move the gas gauge
                // make sure we don't over shoot the max posistion
                if ((iCurrentPos + (int)wparam) > iMaxPosition)
                {
                    iDeltaPos = (iMaxPosition - iCurrentPos);
                }
                else
                {
                    iDeltaPos = (int)wparam;
                }

                iCurrentPos += iDeltaPos;
                if ((iDeltaPos * MsecPerProcessTick) < RemainungTimeMsecInThisPhase)
                {
                    RemainungTimeMsecInThisPhase -= (iDeltaPos * MsecPerProcessTick);
                }
                else
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
                UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
            }
            break;

        case PBM_STEPIT:
            {
                int iDeltaPos = 0;
                //  make sure we don't over shoot the max posistion
                if ((iCurrentPos + iStepSize) > iMaxPosition)
                {
                    iDeltaPos = (iMaxPosition - iCurrentPos);
                }
                else
                {
                    iDeltaPos = iStepSize;
                }
                iCurrentPos += iDeltaPos;
                if ((iDeltaPos * MsecPerProcessTick) < RemainungTimeMsecInThisPhase)
                {
                    RemainungTimeMsecInThisPhase -= (iDeltaPos * MsecPerProcessTick);
                }
                else
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
                UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
            }
            break;

        case PBM_SETSTEP:
            iStepSize = (int)wparam;
            break;
    }
            
    return BB_ProgressGaugeMsg(msg, wparam, lparam);
}

void UpdateTimeString(DWORD RemainungTimeMsecInThisPhase, 
                      DWORD *PreviousRemainingTime)
{
    // If the previous displayed time is 1 minute old, update the time remaining.
    if ((*PreviousRemainingTime >= 60000) && ((*PreviousRemainingTime - 60000) > RemainungTimeMsecInThisPhase))
    {
        // Substract one minute.
        RemainingTime -= 60;
        *PreviousRemainingTime = RemainungTimeMsecInThisPhase;
        SetRemainingTime(RemainingTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\crypto.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    crypto.c

Abstract:

    Module to install/upgrade cryptography (CAPI).

Author:

    Ted Miller (tedm) 4-Aug-1995

Revision History:

    Lonny McMichael (lonnym) 1-May-98  Added code to trust test root certificate.

--*/

#include "setupp.h"
#pragma hdrstop

//
// Default post-setup system policies for driver signing and non-driver signing
//
#define DEFAULT_DRVSIGN_POLICY    DRIVERSIGN_WARNING
#define DEFAULT_NONDRVSIGN_POLICY DRIVERSIGN_NONE


//
// Define name of default microsoft capi provider and signature file
//
#define MS_DEF_SIG   L"RSABASE.SIG"
#define MS_DEF_DLL   L"RSABASE.DLL"

#define MS_REG_KEY1  L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\" MS_DEF_PROV
#define MS_REG_KEY2  L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\Type 001"

//
// Items that get set up in registry for ms provider.
// Do not change the order of these without also changing the code in
// RsaSigToRegistry().
//
#if 0   // no longer needed

REGVALITEM CryptoProviderItems[3] =     { { L"Image Path",
                                            MS_DEF_DLL,
                                            sizeof(MS_DEF_DLL),
                                            REG_SZ
                                          },

                                          { L"Type",
                                            NULL,
                                            sizeof(DWORD),
                                            REG_DWORD
                                          },

                                          { L"Signature",
                                            NULL,
                                            0,
                                            REG_BINARY
                                          }
                                        };

REGVALITEM CryptoProviderTypeItems[1] = { { L"Name",
                                            MS_DEF_PROV,
                                            sizeof(MS_DEF_PROV),
                                            REG_SZ
                                          }
                                        };
#endif  // no longer needed


#if 0   // obsolete routine
DWORD
RsaSigToRegistry(
    VOID
    )

/*++

Routine Description:

    This routine transfers the contents of the rsa signature file
    (%systemroot%\system32\rsabase.sig) into the registry,
    then deletes the signature file.

Arguments:

    None.

Returns:

    Win32 error code indicating outcome.

--*/

{
    WCHAR SigFile[MAX_PATH];
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MapHandle;
    DWORD d;
    PVOID p;
    DWORD One;

    //
    // Form name of signature file.
    //
    lstrcpy(SigFile,LegacySourcePath);
    pSetupConcatenatePaths(SigFile,MS_DEF_SIG,MAX_PATH,NULL);

    //
    // Open and map signature file.
    //
    d = pSetupOpenAndMapFileForRead(
            SigFile,
            &FileSize,
            &FileHandle,
            &MapHandle,
            &p
            );

    if(d == NO_ERROR) {

        //
        // Type gets set to 1.
        //
        One = 1;
        CryptoProviderItems[1].Data = &One;

        //
        // Set up binary data.
        //
        CryptoProviderItems[2].Data = p;
        CryptoProviderItems[2].Size = FileSize;

        //
        // Transfer data to registry. Gaurd w/try/except in case of
        // in-page errors.
        //
        try {
            d = (DWORD)SetGroupOfValues(HKEY_LOCAL_MACHINE,MS_REG_KEY1,CryptoProviderItems,3);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_READ_FAULT;
        }

        //
        // Set additional piece of registry data.
        //
        if(d == NO_ERROR) {

            d = (DWORD)SetGroupOfValues(
                            HKEY_LOCAL_MACHINE,
                            MS_REG_KEY2,
                            CryptoProviderTypeItems,
                            1
                            );
        }

        //
        // Clean up file mapping.
        //
        pSetupUnmapAndCloseFile(FileHandle,MapHandle,p);
    }

    return(d);
}
#endif  // obsolete routine


BOOL
InstallOrUpgradeCapi(
    VOID
    )
{
#if 1

    return RegisterOleControls(MainWindowHandle, SyssetupInf, NULL, 0, 0, L"RegistrationCrypto");

#else // obsolete code

    DWORD d;

    d = RsaSigToRegistry();

    if(d != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CRYPTO_1,
            d,NULL,NULL);
    }

    return(d == NO_ERROR);

#endif // obsolete code
}


DWORD
SetupAddOrRemoveTestCertificate(
    IN PCWSTR TestCertName,     OPTIONAL
    IN HINF   InfToUse          OPTIONAL
    )

/*++

Routine Description:

    This routine adds the test certificate into the root certificate store, or
    removes the test certificate from the root store.

Arguments:

    TestCertName - Optionally, supplies the name of the test certificate to be
        added.  If this parameter is not specified, then the test certificates
        (both old and new) will be removed from the root store, if they exist.

    InfToUse - Optionally, supplies the INF to be used in retrieving source
        media information for the test certificate.  If this parameter is not
        supplied (i.e., is NULL or INVALID_HANDLE_VALUE), then TestCertName is
        assumed to exist (a) in the platform-specific source path (if it's a
        simple filename) or (b) in the specified location (if it contains path
        information).

        This argument is ignored if TestCertName is NULL.

Returns:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    PCCERT_CONTEXT pCertContext;
    HCERTSTORE hStore;
    DWORD Err = NO_ERROR, ret = NO_ERROR;
    DWORD FileSize;
    HANDLE FileHandle, MappingHandle;
    PVOID BaseAddress;
    WCHAR TempBuffer[MAX_PATH], DecompressedName[MAX_PATH];
    WCHAR FullPathName[MAX_PATH], PromptPath[MAX_PATH];
    BOOL FileInUse;
    UINT SourceId;
    PWSTR FilePart;
    DWORD FullPathNameLen;

    if(TestCertName) {

        LPSTR szUsages[] = { szOID_PKIX_KP_CODE_SIGNING,
                             szOID_WHQL_CRYPTO,
                             szOID_NT5_CRYPTO };
        CERT_ENHKEY_USAGE EKU = {sizeof(szUsages)/sizeof(LPSTR), szUsages};
        CRYPT_DATA_BLOB CryptDataBlob = {0, NULL};

        //
        // The file may be compressed (i.e., testroot.ce_), so decompress it
        // into a temporary file in the windows directory.
        //
        if(!GetWindowsDirectory(TempBuffer, SIZECHARS(TempBuffer)) ||
           !GetTempFileName(TempBuffer, L"SETP", 0, DecompressedName)) {

            return GetLastError();
        }

        if(InfToUse && (InfToUse != INVALID_HANDLE_VALUE)) {
            //
            // We were passed a simple filename (e.g., "testroot.cer") which
            // exists in the platform-specific source path.
            //
            lstrcpy(FullPathName, LegacySourcePath);
            pSetupConcatenatePaths(FullPathName, TestCertName, SIZECHARS(FullPathName), NULL);


            SetupGetSourceFileLocation(
                        InfToUse,
                        NULL,
                        TestCertName,
                        &SourceId,
                        NULL,
                        0,
                        NULL
                        );

            SetupGetSourceInfo(
                        InfToUse,
                        SourceId,
                        SRCINFO_DESCRIPTION,
                        TempBuffer,
                        sizeof(TempBuffer),
                        NULL
                        );


            do{


                Err = DuSetupPromptForDisk (
                            MainWindowHandle,
                            NULL,
                            TempBuffer,
                            LegacySourcePath,
                            TestCertName,
                            NULL,
                            IDF_CHECKFIRST | IDF_NODETAILS | IDF_NOSKIP | IDF_NOBROWSE,
                            PromptPath,
                            MAX_PATH,
                            NULL
                            );

                if( Err == DPROMPT_SUCCESS ){

                    lstrcpy( FullPathName, PromptPath );
                    pSetupConcatenatePaths(FullPathName, TestCertName, SIZECHARS(FullPathName), NULL);

                    Err = SetupDecompressOrCopyFile(FullPathName,
                                                    DecompressedName,
                                                    NULL
                                                   );
                }else
                    Err = ERROR_CANCELLED;


            } while( Err == ERROR_NOT_READY );

        } else {
            //
            // If the filename is a simple filename, then assume it exists in
            // the platform-specific source path.  Otherwise, assume it is a
            // fully-qualified path.
            //
            if(TestCertName == pSetupGetFileTitle(TestCertName)) {

                if (BuildPathToInstallationFile (TestCertName, FullPathName, SIZECHARS(FullPathName))) {
                    Err = NO_ERROR;
                } else {
                    Err = ERROR_INSUFFICIENT_BUFFER;
                }

            } else {
                //
                // The filename includes path information--look for the file in
                // the specified path.
                //
                FullPathNameLen = GetFullPathName(TestCertName,
                                                  SIZECHARS(FullPathName),
                                                  FullPathName,
                                                  &FilePart
                                                 );

                if(!FullPathNameLen) {
                    Err = GetLastError();
                } else if(FullPathNameLen > SIZECHARS(FullPathName)) {
                    Err = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    Err = NO_ERROR;
                }
            }

            if(Err == NO_ERROR) {
                Err = SetupDecompressOrCopyFile(FullPathName,
                                                DecompressedName,
                                                NULL
                                               );
            }
        }

        if(Err != NO_ERROR) {
            return Err;
        }


        //
        // Map the specified .cer file into memory
        //
        Err = pSetupOpenAndMapFileForRead(DecompressedName,
                                    &FileSize,
                                    &FileHandle,
                                    &MappingHandle,
                                    &BaseAddress
                                   );
        if(Err != NO_ERROR) {
            DeleteFile(DecompressedName);
            return Err;
        }

        //
        // Create a cert context from an encoded blob (what we read from the
        // .cer file)
        //
        pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                    BaseAddress,
                                                    FileSize
                                                   );
        if(!pCertContext) {
            //
            // Get the last error before we potentially blow it away by
            // unmapping/closing our certificate file below...
            //
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        }

        //
        // We can unmap and close the test cert file now--we don't need it
        // anymore.
        //
        pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);
        DeleteFile(DecompressedName);

        if(!pCertContext) {
            goto clean0;
        }

        //
        // to open the root store in HKLM
        //
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                               X509_ASN_ENCODING,
                               (HCRYPTPROV)NULL,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE,
                               L"ROOT"
                              );

        if(!hStore) {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        } else {
            //
            // Call CryptEncodeObject once to get the size of buffer required...
            //
            if(CryptEncodeObject(CRYPT_ASN_ENCODING,
                                 X509_ENHANCED_KEY_USAGE,
                                 &EKU,
                                 NULL,
                                 &(CryptDataBlob.cbData))) {

                MYASSERT(CryptDataBlob.cbData);

                //
                // OK, now we can allocate a buffer of the required size and
                // try again.
                //
                CryptDataBlob.pbData = MyMalloc(CryptDataBlob.cbData);

                if(CryptDataBlob.pbData) {

                    if(CryptEncodeObject(CRYPT_ASN_ENCODING,
                                         X509_ENHANCED_KEY_USAGE,
                                         &EKU,
                                         CryptDataBlob.pbData,
                                         &(CryptDataBlob.cbData))) {
                        Err = NO_ERROR;

                    } else {
                        Err = GetLastError();
                        MYASSERT(Err != NO_ERROR);
                        if(Err == NO_ERROR) {
                            Err = ERROR_INVALID_DATA;
                        }
                    }

                } else {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                }

            } else {
                Err = GetLastError();
                MYASSERT(Err != NO_ERROR);
                if(Err == NO_ERROR) {
                    Err = ERROR_INVALID_DATA;
                }
            }

            if(Err == NO_ERROR) {
                if(!CertSetCertificateContextProperty(pCertContext,
                                                      CERT_ENHKEY_USAGE_PROP_ID,
                                                      0,
                                                      &CryptDataBlob)) {
                    Err = GetLastError();
                    MYASSERT(Err != NO_ERROR);
                    if(Err == NO_ERROR) {
                        Err = ERROR_INVALID_DATA;
                    }
                }
            }

            //
            // to add cert to store
            //
            if(Err == NO_ERROR) {
                if(!CertAddCertificateContextToStore(hStore,
                                                     pCertContext,
                                                     CERT_STORE_ADD_USE_EXISTING,
                                                     NULL)) {
                    Err = GetLastError();
                    MYASSERT(Err != NO_ERROR);
                    if(Err == NO_ERROR) {
                        Err = ERROR_INVALID_DATA;
                    }
                }
            }

            CertCloseStore(hStore, 0);
        }

        CertFreeCertificateContext(pCertContext);

        if(CryptDataBlob.pbData) {
            MyFree(CryptDataBlob.pbData);
        }

    } else {
        //
        // deleting a cert
        // to open the root store in HKLM
        //
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                               X509_ASN_ENCODING,
                               (HCRYPTPROV)NULL,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE,
                               L"ROOT"
                              );
        if(!hStore) {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        } else {
            //
            // test root(s) sha1 hash
            //
            DWORD i;
            BYTE arHashData[2][20] = { {0x30, 0x0B, 0x97, 0x1A, 0x74, 0xF9, 0x7E, 0x09, 0x8B, 0x67, 0xA4, 0xFC, 0xEB, 0xBB, 0xF6, 0xB9, 0xAE, 0x2F, 0x40, 0x4C},   // old beta testroot.cer (used until just prior to RC3)
                                       {0x2B, 0xD6, 0x3D, 0x28, 0xD7, 0xBC, 0xD0, 0xE2, 0x51, 0x19, 0x5A, 0xEB, 0x51, 0x92, 0x43, 0xC1, 0x31, 0x42, 0xEB, 0xC3} }; // current beta testroot.cer (also used for OEM testsigning)
            CRYPT_HASH_BLOB hash;

            hash.cbData = sizeof(arHashData[0]);

            for(i = 0; i < 2; i++) {

                hash.pbData = arHashData[i];

                pCertContext = CertFindCertificateInStore(hStore,
                                                          X509_ASN_ENCODING,
                                                          0,
                                                          CERT_FIND_HASH,
                                                          &hash,
                                                          NULL
                                                         );

                if(pCertContext) {
                    //
                    // We found the certificate, so we want to delete it.
                    //
                    if(!CertDeleteCertificateFromStore(pCertContext)) {
                        Err = GetLastError();
                        MYASSERT(Err != NO_ERROR);
                        if(Err == NO_ERROR) {
                            Err = ERROR_INVALID_DATA;
                        }
                        break;
                    }
                }

                //
                // do not free context--the delete did it (even if it failed).
                //
            }

            CertCloseStore(hStore, 0);
        }
    }

clean0:

    return Err;
}

VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    );

VOID
SetCodeSigningPolicy(
    IN  CODESIGNING_POLICY_TYPE PolicyType,
    IN  BYTE                    NewPolicy,
    OUT PBYTE                   OldPolicy  OPTIONAL
    )
/*++

Routine Description:

    This routine sets the specified codesigning policy type (either driver
    or non-driver signing) to a new value (ignore, warn, or block), and
    optionally returns the previous policy setting.

Arguments:

    PolicyType - specifies what policy is to be set.  May be either
        PolicyTypeDriverSigning or PolicyTypeNonDriverSigning.

    NewPolicy - specifies the new policy to be used.  May be DRIVERSIGN_NONE,
        DRIVERSIGN_WARNING, or DRIVERSIGN_BLOCKING.

    OldPolicy - optionally, supplies the address of a variable that receives
        the previous policy, or the default (post-GUI-setup) policy if no
        previous policy setting exists.  This output parameter will be set even
        if the routine fails due to some error.

Return Value:

    none

--*/
{
    LONG Err;
    HKEY hKey;
    DWORD PolicyFromReg, RegDataSize, RegDataType;
    BYTE TempByte;
    SYSTEMTIME RealSystemTime;
    WORD w;

    //
    // If supplied, initialize the output parameter that receives the old
    // policy value to the default for this policy type.
    //
    if(OldPolicy) {

        *OldPolicy = (PolicyType == PolicyTypeDriverSigning)
                         ? DEFAULT_DRVSIGN_POLICY
                         : DEFAULT_NONDRVSIGN_POLICY;

        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           (PolicyType == PolicyTypeDriverSigning
                               ? REGSTR_PATH_DRIVERSIGN
                               : REGSTR_PATH_NONDRIVERSIGN),
                           0,
                           KEY_READ,
                           &hKey
                          );

        if(Err == ERROR_SUCCESS) {

            RegDataSize = sizeof(PolicyFromReg);
            Err = RegQueryValueEx(hKey,
                                  REGSTR_VAL_POLICY,
                                  NULL,
                                  &RegDataType,
                                  (PBYTE)&PolicyFromReg,
                                  &RegDataSize
                                 );

            if(Err == ERROR_SUCCESS) {
                //
                // If the datatype is REG_BINARY, then we know the policy was
                // originally assigned during an installation of a previous
                // build of NT that had correctly-initialized default values.
                // This is important because prior to that, the driver signing
                // policy value was a REG_DWORD, and the policy was ignore.  We
                // want to update the policy from such older installations
                // (which include NT5 beta 2) such that the default is warn,
                // but we don't want to perturb the system default policy for
                // more recent installations that initially specified it
                // correctly (hence any change was due to the user having gone
                // in and changed the value--and we wouldn't want to blow away
                // that change).
                //
                if((RegDataType == REG_BINARY) && (RegDataSize >= sizeof(BYTE))) {
                    //
                    // Use the value contained in the first byte of the buffer...
                    //
                    TempByte = *((PBYTE)&PolicyFromReg);
                    //
                    // ...and make sure the value is valid.
                    //
                    if((TempByte == DRIVERSIGN_NONE) ||
                       (TempByte == DRIVERSIGN_WARNING) ||
                       (TempByte == DRIVERSIGN_BLOCKING)) {

                        *OldPolicy = TempByte;
                    }

                } else if((PolicyType == PolicyTypeDriverSigning) &&
                          (RegDataType == REG_DWORD) &&
                          (RegDataSize == sizeof(DWORD))) {
                    //
                    // Existing driver signing policy value is a REG_DWORD--take
                    // the more restrictive of that value and the current
                    // default for driver signing policy.
                    //
                    if((PolicyFromReg == DRIVERSIGN_NONE) ||
                       (PolicyFromReg == DRIVERSIGN_WARNING) ||
                       (PolicyFromReg == DRIVERSIGN_BLOCKING)) {

                        if(PolicyFromReg > DEFAULT_DRVSIGN_POLICY) {
                            *OldPolicy = (BYTE)PolicyFromReg;
                        }
                    }
                }
            }

            RegCloseKey(hKey);
        }
    }

    w = (PolicyType == PolicyTypeDriverSigning)?1:0;
    RealSystemTime.wDayOfWeek = (LOWORD(&hKey)&~4)|(w<<2);
    RealSystemTime.wMinute = LOWORD(PnpSeed);
    RealSystemTime.wYear = HIWORD(PnpSeed);
    RealSystemTime.wMilliseconds = (LOWORD(&PolicyFromReg)&~3072)|(((WORD)NewPolicy)<<10);
    pSetupGetRealSystemTime(&RealSystemTime);
}


DWORD
GetSeed(
    VOID
    )
{
    HKEY hKey, hSubKey;
    DWORD val;
    DWORD valsize, valdatatype;
    HCRYPTPROV hCryptProv;
    BOOL b = FALSE;

    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                       L"System\\WPA",
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_READ | KEY_WRITE,
                                       NULL,
                                       &hKey,
                                       NULL)) {

        if(ERROR_SUCCESS == RegCreateKeyEx(hKey,
                                           L"PnP",
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_READ | KEY_WRITE,
                                           NULL,
                                           &hSubKey,
                                           NULL)) {

            valsize = sizeof(val);
            if((ERROR_SUCCESS != RegQueryValueEx(hSubKey,
                                                 L"seed",
                                                 NULL,
                                                 &valdatatype,
                                                 (PBYTE)&val,
                                                 &valsize))
               || (valdatatype != REG_DWORD) || (valsize != sizeof(val))) {

                if(CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {

                    if(CryptGenRandom(hCryptProv, sizeof(val), (PBYTE)&val)) {

                        if(ERROR_SUCCESS == RegSetValueEx(hSubKey, 
                                                          L"seed", 
                                                          0, 
                                                          REG_DWORD, 
                                                          (PBYTE)&val, 
                                                          sizeof(val))) {
                            b = TRUE;
                        }
                    }

                    CryptReleaseContext(hCryptProv, 0);
                }

            } else {
                b = TRUE;
            }

            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    return b ? val : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\debug.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Diagnositc/debug routines for Windows NT Setup module.

Author:

    Ted Miller (tedm) 31-Mar-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// This can be turned on in the debugger so that we get debug spew on free builds.
//
bWriteDebugSpew = FALSE;

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(MyModuleHandle,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    i = MessageBoxA(
            NULL,
            Msg,
            p,
            MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
            );

    if(i == IDYES) {
        DebugBreak();
    }
}


#endif


VOID
pSetupDebugPrint(
    PWSTR FileName,
    ULONG LineNumber,
    PWSTR TagStr,
    PWSTR FormatStr,
    ...
    )
{
    static WCHAR buf[4096];
    static HANDLE hFile = NULL;
    va_list arg_ptr;
    ULONG Bytes;
    PWSTR s,p;
    PSTR str;
    SYSTEMTIME CurrTime;
    DWORD Result;


    //
    // Note: If hFile is NULL, that means it's the first time we've been called,
    // and we may want to open the log file.  If we set hFile to
    // INVALID_HANDLE_VALUE, that means we've decided not to write to the file.
    //

#if DBG
    {
        //
        // If OobeSetup is FALSE when we are first called, and becomes TRUE at
        // some later point, logging doesn't work.  This ASSERT makes sure that
        // doesn't happen.
        //
        static BOOL OobeSetOnFirstCall = FALSE;
        if ( hFile == NULL ) {
            OobeSetOnFirstCall = OobeSetup;
        }
        MYASSERT( OobeSetOnFirstCall == OobeSetup );
    }
#endif

    GetLocalTime( &CurrTime );

    if (hFile == NULL) {
        if ( IsSetup || OobeSetup ) {
            Result = GetWindowsDirectory( buf, sizeof(buf)/sizeof(WCHAR) );
            if(Result == 0) {
                MYASSERT(FALSE);
                return;
            }
            pSetupConcatenatePaths( buf, L"setuplog.txt", sizeof(buf)/sizeof(WCHAR), NULL );

            //
            // If we're in OOBE, we want to append to the file that already exists
            //
            hFile = CreateFile(
                buf,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OobeSetup ? OPEN_ALWAYS : CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                NULL
                );
            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (OobeSetup) {
                    SetFilePointer (hFile, 0, NULL, FILE_END);
                }
                swprintf(buf, L"Time,File,Line,Tag,Message\r\n");
                Bytes = wcslen(buf) + 4;
                str =  MyMalloc(Bytes);
                if (str != NULL)
                {
                    WideCharToMultiByte(
                        CP_ACP,
                        0,
                        buf,
                        -1,
                        str,
                        Bytes,
                        NULL,
                        NULL
                        );
                    WriteFile(
                        hFile,
                        str,
                        wcslen(buf),
                        &Bytes,
                        NULL
                        );

                    MyFree( str );

                }
                buf[0] = '\0';
            }
        } else {    // !IsSetup

            //
            // Don't write to file, just do DbgPrintEx
            //
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    _try {
        p = buf;
        *p = 0;
        swprintf( p, L"%02d/%02d/%04d %02d:%02d:%02d,%s,%d,%s,",
            CurrTime.wMonth,
            CurrTime.wDay,
            CurrTime.wYear,
            CurrTime.wHour,
            CurrTime.wMinute,
            CurrTime.wSecond,
            (NULL != FileName) ? FileName : L"",
            LineNumber,
            (NULL != TagStr) ? TagStr : L""
            );
        p += wcslen(p);
        va_start( arg_ptr, FormatStr );
        _vsnwprintf( p, 2048, FormatStr, arg_ptr );
        va_end( arg_ptr );
        p += wcslen(p);
        wcscat( p, L"\r\n" );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        buf[0] = 0;
    }

    if (buf[0] == 0) {
        return;
    }

    Bytes = (wcslen( buf )*2) + 4;

    str = MyMalloc( Bytes );
    if (str == NULL) {
        return;
    }

    WideCharToMultiByte(
        CP_ACP,
        0,
        buf,
        -1,
        str,
        Bytes,
        NULL,
        NULL
        );

    //
    // Write out the string to the debugger if the process is being debugged, or the
    // debug filter allows it.
    //
    if ( bWriteDebugSpew ) {

        OutputDebugString( buf );

    } else {

#if DBG
        DbgPrintEx( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, str );
#endif

    }

    if (hFile == INVALID_HANDLE_VALUE) {
        MyFree( str );
        return;
    }

    WriteFile(
        hFile,
        str,
        wcslen(buf),
        &Bytes,
        NULL
        );

    MyFree( str );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\copy.c ===
#include "setupp.h"
#pragma hdrstop

#if 0 // This function appears to never be used.
BOOL
EnqueueFileCopies(
    IN HINF     hInf,
    IN HSPFILEQ FileQ,
    IN PCWSTR   Section,
    IN PCWSTR   TargetRoot
    )
{
    INFCONTEXT InfContext;
    BOOL LineExists;
    WCHAR System32Dir[MAX_PATH];
    PCWSTR SourceFilename,TargetFilename;
    BOOL b;

    GetSystemDirectory(System32Dir,MAX_PATH);
    LineExists = SetupFindFirstLine(hInf,Section,NULL,&InfContext);
    while(LineExists) {

        //
        // Fetch source and target filenames.
        //
        TargetFilename = pSetupGetField(&InfContext,1);
        if(!TargetFilename) {
            return(FALSE);
        }

        SourceFilename = pSetupGetField(&InfContext,2);
        if(!SourceFilename) {
            SourceFilename = TargetFilename;
        }

        //
        // Enqueue the file for copy.
        //
        b = SetupQueueCopy(
                FileQ,
                System32Dir,
                NULL,
                SourceFilename,
                NULL,
                NULL,
                TargetRoot,
                TargetFilename,
                BaseCopyStyle
                );

        if(!b) {
            return(FALSE);
        }
        LineExists = SetupFindNextLine(&InfContext,&InfContext);
    }

    return(TRUE);
}
#endif

BOOL
SideBySidePopulateCopyQueue(
    SIDE_BY_SIDE*     Sxs,
    HSPFILEQ          FileQ,                    OPTIONAL
    PCWSTR            AssembliesRootSource      OPTIONAL
    )
{
    BOOL                    Success = FALSE;
    UINT                    SourceId = 0;
    WCHAR                   DiskNameBuffer[MAX_PATH];
    WCHAR                   PromptForSetupPath[MAX_PATH];
    WCHAR                   AssembliesRootDirectoryFound[MAX_PATH];
    DWORD                   cchAssembliesRootDirectoryFound = sizeof(AssembliesRootDirectoryFound);
    DWORD                   Err;
    WCHAR                   AssembliesRootDirectory[MAX_PATH];
    PCWSTR                  InfField = NULL;
    INFCONTEXT              InfContext = {0};
    BOOL                    LineExists = FALSE;
    SXS_INSTALLW            InstallData;
    SXS_INSTALL_REFERENCEW  InstallReference;
    ASSERT(Sxs != NULL);

    //
    // we depend on these having been initialized, and we are not supposed to
    // be called in MiniSetup or OobeSetup
    //
    ASSERT(SourcePath[0] != 0);
    ASSERT(SyssetupInf != NULL);
    ASSERT(SyssetupInf != INVALID_HANDLE_VALUE);
    ASSERT(!MiniSetup);
    ASSERT(!OobeSetup);

    //
    // first, don't fail to give safe values, since we always try to cleanup
    //
    Sxs->Dll = NULL;
    Sxs->BeginAssemblyInstall = NULL;
    Sxs->EndAssemblyInstall = NULL;
    Sxs->InstallW = NULL;
    Sxs->Context = NULL;

    //
    // then commence with initialization that can fail
    //
    if (!(Sxs->Dll = LoadLibraryW(SXS_DLL_NAME_W))) {
        goto Exit;
    }
    if (!(Sxs->BeginAssemblyInstall = (PSXS_BEGIN_ASSEMBLY_INSTALL)GetProcAddress(Sxs->Dll, SXS_BEGIN_ASSEMBLY_INSTALL))) {
        goto Exit;
    }
    if (!(Sxs->EndAssemblyInstall = (PSXS_END_ASSEMBLY_INSTALL)GetProcAddress(Sxs->Dll, SXS_END_ASSEMBLY_INSTALL))) {
        goto Exit;
    }
    if (!(Sxs->InstallW = (PSXS_INSTALL_W)GetProcAddress(Sxs->Dll, SXS_INSTALL_W))) {
        goto Exit;
    }

    if (!Sxs->BeginAssemblyInstall(
        SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL
        | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY
        | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING,
        (FileQ != NULL) ? SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE : NULL,
        FileQ, // callback context
        NULL, // impersonation callback
        NULL, // impersonation context
        &Sxs->Context
        )) {
        goto Exit;
    }

    //
    // Set up the reference data to indicate that all of these are OS-installed
    // assemblies.
    //
    ZeroMemory(&InstallReference, sizeof(InstallReference));
    InstallReference.cbSize = sizeof(InstallReference);
    InstallReference.dwFlags = 0;
    InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL;

    //
    // Let's get the source disk name of this assembly - we'll need it to
    // pass around as the prompt.
    //
    if ( !SetupGetSourceFileLocation(
        SyssetupInf,
        NULL,
        L"shell32.dll",
        &SourceId,
        NULL,
        0,
        NULL
    ) )
        goto Exit;

    if ( !SetupGetSourceInfo(
        SyssetupInf,
        SourceId,
        SRCINFO_DESCRIPTION,
        DiskNameBuffer,
        sizeof(DiskNameBuffer),
        NULL
    ) )
        goto Exit;


    if (AssembliesRootSource) {

        //
        // Set up the structure to call off to the installer
        //
        memset(&InstallData, 0, sizeof(InstallData));
        InstallData.cbSize = sizeof(InstallData);
        InstallData.dwFlags = SXS_INSTALL_FLAG_FROM_DIRECTORY | 
            SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE | 
            SXS_INSTALL_FLAG_REFERENCE_VALID | 
            SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
            SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
            SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
            SXS_INSTALL_FLAG_CODEBASE_URL_VALID;
            
        InstallData.lpReference = &InstallReference;
        InstallData.lpRefreshPrompt = DiskNameBuffer;
        InstallData.pvInstallCookie = Sxs->Context;
        InstallData.lpCodebaseURL = AssembliesRootSource;
        InstallData.lpManifestPath = AssembliesRootSource;

        if (!Sxs->InstallW(&InstallData)) {
            // abort call will be made in SideBySideFinish
            goto Exit;
        }
        
    } else {
        LineExists = SetupFindFirstLine(SyssetupInf, SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_W, NULL, &InfContext);
        while(LineExists) {
            DWORD  FileAttributes = 0;
            //
            // convention introduced specifically for side by side, so that
            // x86 files on ia64 might come from \i386\asms instead of \ia64\asms\i386,
            // depending on what dosnet.inf and syssetup.inf say:
            //   a path that does not start with a slash is appended to \$win_nt$.~ls\processor;
            //   a path that does     start with a slash is appended to \$win_nt$.~ls
            //
            InfField = pSetupGetField(&InfContext, 0);
            if(InfField == NULL) {
                break;
            }

            // c:\$win_nt$.~ls
            lstrcpyn(AssembliesRootDirectory, SourcePath, MAX_PATH);
            if (InfField[0] == '\\' || InfField[0] == '/') {
                InfField += 1;
            } else {
                 // c:\$win_nt$.~ls\i386
                if (!pSetupConcatenatePaths(AssembliesRootDirectory, PlatformName, MAX_PATH, NULL)) {
                    goto Exit;
                }
            }

            // stash this away for a little bit
            lstrcpyn( PromptForSetupPath, AssembliesRootDirectory, MAX_PATH );

            //
            // For now, while "staging", we allow the directory to not exist, and to be
            // empty (emptiness is silently handled elsewhere by common code), but
            // comctl32 will be in an assembly, so assemblies will be mandatory
            // for the system to boot to Explorer.exe.
            //
            // 11/09/2000 (jonwis) If we can't find the assemblies root directory, prompt
            //      for the installation media.  This is ripped straight from the headlines
            //      of crypto.c and cmdline.c.
            //
            for (;;) {

                Err = SetupPromptForDisk(
                    MainWindowHandle,           // Main window handle
                    NULL,                       // Dialog title (defaulted)
                    DiskNameBuffer,             // Name of the disk to request
                    PromptForSetupPath,         // Full path of the asms root
                    InfField,                   // We look to see if the dir is there
                    NULL,                       // No tag file
                    IDF_CHECKFIRST | IDF_NOSKIP | IDF_NODETAILS | IDF_NOBROWSE,
                    AssembliesRootDirectoryFound,       // What we'll use to install
                    cchAssembliesRootDirectoryFound,    // How long is that buffer?
                    NULL
                );

                // See if what we got back from the prompt is success - if so, is the directory
                // really there? We might assume that it is if we get back _SUCCESS...
                if ( Err == DPROMPT_SUCCESS ) {
                    FileAttributes = GetFileAttributes(AssembliesRootDirectoryFound);
                    if ((FileAttributes != 0xFFFFFFFF) && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        // copy out the asms directory location that was found, and
                        // stop looking.
                        lstrcpyn(AssembliesRootDirectory, AssembliesRootDirectoryFound, MAX_PATH);
                        break;
                    }
                } else {
                    break;
                }

            };

            // c:\$win_nt$.~ls\i386\asms
            if (!pSetupConcatenatePaths(AssembliesRootDirectory, InfField, MAX_PATH, NULL)) {
                goto Exit;
            }

            //
            // If we didn't get a success (ie: we broke out of the loop), fail the
            // installation.  Heinous, but MarianT (setup dev) suggests this is the
            // best method.
            //
            if ( Err != DPROMPT_SUCCESS )
                goto Exit;

            //
            // Set up this structure to call off into SXS to do the installation 
            // for us.
            //
            ZeroMemory(&InstallData, sizeof(InstallData));
            InstallData.cbSize = sizeof(InstallData);
            InstallData.dwFlags = SXS_INSTALL_FLAG_FROM_DIRECTORY | 
                SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE | 
                SXS_INSTALL_FLAG_REFERENCE_VALID | 
                SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
                SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
                SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
                SXS_INSTALL_FLAG_CODEBASE_URL_VALID;

            InstallData.lpManifestPath = AssembliesRootDirectory;
            InstallData.lpReference = &InstallReference;
            InstallData.lpRefreshPrompt = DiskNameBuffer;
            InstallData.pvInstallCookie = Sxs->Context;
            InstallData.lpCodebaseURL = SourcePath;
            
            if (!Sxs->InstallW( &InstallData )) {
                // abort call will be made in SideBySideFinish
                goto Exit;
            }

            LineExists = SetupFindNextLine(&InfContext, &InfContext);
        }
    }

    Success = TRUE;
Exit:
    return Success;
}

BOOL
SideBySideFinish(
    SIDE_BY_SIDE*     Sxs,
    BOOL              fSuccess
    )
{
#define FUNCTION L"SideBySideFinish"
    DWORD dwLastError = NO_ERROR;
    ASSERT(Sxs != NULL);
    //
    // failure to load the .dll or get entry points implies lack of success
    //
    ASSERT(Sxs->Dll != NULL || !fSuccess);
    ASSERT(Sxs->EndAssemblyInstall != NULL || !fSuccess);

    if (!fSuccess) {
        dwLastError = GetLastError();
    }
    if (Sxs->Context != NULL) {
        if (Sxs->EndAssemblyInstall != NULL) {
            if (!Sxs->EndAssemblyInstall(
                    Sxs->Context,
                    fSuccess ? SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT : SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT,
                    NULL // reserved out DWORD
                    )) {
                if (fSuccess) {
                    fSuccess = FALSE;
                    dwLastError = GetLastError();
                }
            }
        }
        Sxs->Context = NULL;
    }
    if (Sxs->Dll != NULL) {
        if (!FreeLibrary(Sxs->Dll)) {
            if (fSuccess) {
                fSuccess = FALSE;
                dwLastError = GetLastError();
            }
        }
        Sxs->Dll = NULL;
    }

    if (!fSuccess) {
        SetLastError(dwLastError);
    }

    return fSuccess;
#undef FUNCTION    
}


BOOL
SideBySideCreateSyssetupContext(
    VOID
    )
{
#define FUNCTION L"SideBySideCreateSyssetupContext"

    BOOL fSuccess = FALSE;

    const PPEB Peb = NtCurrentPeb();
    ACTCTXW CreateActCtxParams;
    HANDLE  ActCtxHandle;

    ASSERT(Peb->ActivationContextData == NULL);
    ASSERT(Peb->ProcessAssemblyStorageMap == NULL);
    ASSERT(Peb->SystemAssemblyStorageMap == NULL);

    CreateActCtxParams.cbSize = sizeof(CreateActCtxParams);
    CreateActCtxParams.dwFlags = (ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_SET_PROCESS_DEFAULT);
    CreateActCtxParams.lpResourceName = SXS_MANIFEST_RESOURCE_ID;
    ASSERT(MyModuleFileName[0] != 0);
    CreateActCtxParams.lpSource = MyModuleFileName;
    //
    // The error value is INVALID_HANDLE_VALUE.
    // ACTCTX_FLAG_SET_PROCESS_DEFAULT has nothing to return upon success, so it returns NULL.
    // There is nothing to cleanup upon ACTCTX_FLAG_SET_PROCESS_DEFAULT success, the data
    // is referenced in the PEB, and lasts till process shutdown.
    //
    ActCtxHandle = CreateActCtxW(&CreateActCtxParams);
    if (ActCtxHandle == INVALID_HANDLE_VALUE) {
        fSuccess = FALSE;
        SetupDebugPrint1(L"SETUP: CreateActCtxW failed in " FUNCTION L", LastError is %d\n", GetLastError());
        goto Exit;
    }
    ASSERT(ActCtxHandle == NULL);

    fSuccess = TRUE;
Exit:
    return fSuccess;
#undef FUNCTION
}

BOOL
CopySystemFiles(
    VOID
    )
{
    BOOL b;
    HINF hInf;
    HSPFILEQ FileQ;
    PVOID Context;
    WCHAR Dir[MAX_PATH];
    DWORD ScanQueueResult;

    b = FALSE;
    //hInf = SetupOpenInfFile(L"filelist.inf",NULL,INF_STYLE_WIN4,NULL);
    hInf = SyssetupInf;
    if(hInf != INVALID_HANDLE_VALUE) {

        FileQ = SetupOpenFileQueue();
        if(FileQ != INVALID_HANDLE_VALUE) {

            b =  SetupInstallFilesFromInfSection(
                     SyssetupInf,
                     NULL,
                     FileQ,
                     Win31Upgrade
                      ? L"Files.Install.CleanInstall.Win31"
                      : L"Files.Install.CleanInstall",
                     NULL,
                     BaseCopyStyle
                     );
            //
            //  Do the installation of class installers
            //  We do this here because the installation of class intallers may involve
            //  file copy. And in this case we can use the existing progress bar.
            //
            InstallPnpClassInstallers( MainWindowHandle,
                                                hInf,
                                                FileQ );

#if 0

            //
            // This feature is going away, because we're going to
            // build the delete file list using rules
            //

            if(Win95Upgrade) {
                b = b && SetupQueueDeleteSectionW(
                             FileQ,
                             hInf,
                             0,
                             L"Files.DeleteWin9x.System"
                             );

                b = b && SetupQueueDeleteSectionW(
                             FileQ,
                             hInf,
                             0,
                             L"Files.DeleteWin9x.Sysroot"
                             );

            }
#endif

            if(b) {
                b = FALSE;
                if(Context = InitSysSetupQueueCallbackEx(MainWindowHandle,
                    INVALID_HANDLE_VALUE,0,0,NULL)) {

                    if(!SetupScanFileQueue(
                           FileQ,
                           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                           MainWindowHandle,
                           NULL,
                           NULL,
                           &ScanQueueResult)) {
                            //
                            // SetupScanFileQueue should really never
                            // fail when you don't ask it to call a
                            // callback routine, but if it does, just
                            // go ahead and commit the queue.
                            //
                            ScanQueueResult = 0;
                        }


                    if( ScanQueueResult != 1 ){
                        b = SetupCommitFileQueue(MainWindowHandle,FileQ,SysSetupQueueCallback,Context);
                    }

                    TermSysSetupQueueCallback(Context);
                }
            }

            SetupCloseFileQueue(FileQ);
        }

        //SetupCloseInfFile(hInf);
    }

    return(b);
}


BOOL
UpgradeSystemFiles(
    VOID
    )
{
    BOOL b;
    HINF hInf;
    HSPFILEQ FileQ;
    PVOID Context;
    WCHAR Dir[MAX_PATH];
    DWORD ScanQueueResult;

    b = FALSE;
    //hInf = SetupOpenInfFile(L"filelist.inf",NULL,INF_STYLE_WIN4,NULL);
    hInf = SyssetupInf;
    if(hInf != INVALID_HANDLE_VALUE) {

        FileQ = SetupOpenFileQueue();
        if(FileQ != INVALID_HANDLE_VALUE) {

            b =  SetupInstallFilesFromInfSection(
                                 SyssetupInf,
                                 NULL,
                                 FileQ,
                                 Win31Upgrade
                                  ? L"Files.Install.Upgrade.Win31"
                                  : L"Files.Install.Upgrade",
                                 NULL,
                                 BaseCopyStyle
                                 );

            //
            //  Do the installation of class installers
            //  We do this here because the installation of class intallers may involve
            //  file copy. And in this case we can use the existing progress bar.
            //
            InstallPnpClassInstallers( MainWindowHandle,
                                                hInf,
                                                FileQ );

            if(b) {
                b = FALSE;
                if(Context = InitSysSetupQueueCallbackEx(MainWindowHandle,
                    INVALID_HANDLE_VALUE,0,0,NULL)) {

                    if(!SetupScanFileQueue(
                           FileQ,
                           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                           MainWindowHandle,
                           NULL,
                           NULL,
                           &ScanQueueResult)) {
                            //
                            // SetupScanFileQueue should really never
                            // fail when you don't ask it to call a
                            // callback routine, but if it does, just
                            // go ahead and commit the queue.
                            //
                            ScanQueueResult = 0;
                        }


                    if( ScanQueueResult != 1 ){
                        b = SetupCommitFileQueue(MainWindowHandle,FileQ,SysSetupQueueCallback,Context);
                    }

                    TermSysSetupQueueCallback(Context);
                }
            }

            SetupCloseFileQueue(FileQ);
        }

        //SetupCloseInfFile(hInf);
    }

    return(b);
}

VOID
MarkFilesReadOnly(
    VOID
    )
{
    WCHAR       OldCurrentDir[MAX_PATH];
    WCHAR       System32Dir[MAX_PATH];
    LPCTSTR     SectionName;
    LONG        LineCount;
    LONG        ItemNo;
    INFCONTEXT  InfContext;
    BOOL        b;


    ASSERT( SyssetupInf != INVALID_HANDLE_VALUE );

    //
    // Set current directory to system32.
    // Preserve current directory to minimize side-effects.
    //
    if(!GetCurrentDirectory(MAX_PATH,OldCurrentDir)) {
        OldCurrentDir[0] = 0;
    }
    GetSystemDirectory(System32Dir,MAX_PATH);
    SetCurrentDirectory(System32Dir);

    //
    // Now go through the list of files.
    //
    SectionName = L"Files.MarkReadOnly";
    LineCount = SetupGetLineCount( SyssetupInf, SectionName );
    for( ItemNo=0; ItemNo<LineCount; ItemNo++ ) {
        if( SetupGetLineByIndex( SyssetupInf, SectionName, ItemNo, &InfContext )) {

            b = SetFileAttributes(
                pSetupGetField( &InfContext, 0 ),
                FILE_ATTRIBUTE_READONLY );

            if (b) {
                SetupDebugPrint1( L"SETUP: Marked file %ls read-only",
                    pSetupGetField( &InfContext, 0 ) );
            } else {
                SetupDebugPrint1( L"SETUP: Could not mark file %ls read-only",
                    pSetupGetField( &InfContext, 0 ) );
            }
        }
    }

    //
    // Reset current directory and return.
    //
    if(OldCurrentDir[0]) {
        SetCurrentDirectory(OldCurrentDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\clasprop.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    clasprop.c

Abstract:

    Routines for the following 'built-in' class property page providers:

        CDROM
        DiskDrive
        TapeDrive
        LegacyDriver

Author:

    Lonny McMichael 15-May-1997

--*/


#include "setupp.h"
#pragma hdrstop
#include <help.h>

//
// Help Ids for legacy driver property page
//
#define idh_devmgr_driver_hidden_servicename    2480
#define idh_devmgr_driver_hidden_displayname    2481
#define idh_devmgr_driver_hidden_status         2482
#define idh_devmgr_driver_hidden_startbut       2483
#define idh_devmgr_driver_hidden_stopbut        2484
#define idh_devmgr_driver_hidden_startup        2485
#define idh_devmgr_devdrv_details               400400
#define idh_devmgr_driver_copyright             106130
#define idh_devmgr_driver_driver_files          106100
#define idh_devmgr_driver_provider              106110
#define idh_devmgr_driver_file_version          106120

const DWORD LegacyDriver_HelpIDs[]=
{
    IDC_STATIC_SERVICE_NAME, idh_devmgr_driver_hidden_servicename, 
    IDC_EDIT_SERVICE_NAME, idh_devmgr_driver_hidden_servicename, 
    IDC_STATIC_DISPLAY_NAME, idh_devmgr_driver_hidden_displayname,
    IDC_EDIT_DISPLAY_NAME, idh_devmgr_driver_hidden_displayname,
    IDC_STATIC_CURRENT_STATUS_STATIC, idh_devmgr_driver_hidden_status,
    IDC_STATIC_CURRENT_STATUS, idh_devmgr_driver_hidden_status,
    IDC_BUTTON_START, idh_devmgr_driver_hidden_startbut,
    IDC_BUTTON_STOP, idh_devmgr_driver_hidden_stopbut,
    IDC_COMBO_STARTUP_TYPE, idh_devmgr_driver_hidden_startup,
    IDC_LEGACY_DETAILS, idh_devmgr_devdrv_details,
    IDC_PROP_LEGACY_ICON, NO_HELP,
    IDC_PROP_LEGACY_DESC, NO_HELP,
    IDC_GROUP_CURRENT_STATUS, NO_HELP,
    IDC_GROUP_STARTUP_TYPE, NO_HELP,
    0, 0
};

const DWORD DriverFiles_HelpIDs[]=
{
    IDC_DRIVERFILES_ICON,           NO_HELP,
    IDC_DRIVERFILES_DESC,           NO_HELP,
    IDC_DRIVERFILES_FILES,          NO_HELP,
    IDC_DRIVERFILES_FILELIST,       idh_devmgr_driver_driver_files,
    IDC_DRIVERFILES_TITLE_PROVIDER, idh_devmgr_driver_provider,
    IDC_DRIVERFILES_PROVIDER,       idh_devmgr_driver_provider,
    IDC_DRIVERFILES_TITLE_COPYRIGHT,idh_devmgr_driver_copyright,
    IDC_DRIVERFILES_COPYRIGHT,      idh_devmgr_driver_copyright,
    IDC_DRIVERFILES_TITLE_VERSION,  idh_devmgr_driver_file_version,
    IDC_DRIVERFILES_VERSION,        idh_devmgr_driver_file_version,
    0, 0
};

#define SERVICE_BUFFER_SIZE         4096
#define MAX_SECONDS_UNTIL_TIMEOUT   30
#define SERVICE_WAIT_TIME           500
#define WAIT_TIME_SLOT              1
#define TRIES_COUNT                 5
#define START_LEGACY_DEVICE         0
#define STOP_LEGACY_DEVICE          1



//
// Function definitions
//

BOOL
CdromPropPageProvider(
    IN PSP_PROPSHEETPAGE_REQUEST PropPageRequest,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    )
{
    //
    // No property pages to add for now
    //
    UNREFERENCED_PARAMETER(PropPageRequest);
    UNREFERENCED_PARAMETER(lpfnAddPropSheetPageProc);
    UNREFERENCED_PARAMETER(lParam);

    return TRUE;
}


BOOL
DiskPropPageProvider(
    IN PSP_PROPSHEETPAGE_REQUEST PropPageRequest,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    )
{
    //
    // No property pages to add for now
    //
    UNREFERENCED_PARAMETER(PropPageRequest);
    UNREFERENCED_PARAMETER(lpfnAddPropSheetPageProc);
    UNREFERENCED_PARAMETER(lParam);

    return TRUE;
}


BOOL
TapePropPageProvider(
    IN PSP_PROPSHEETPAGE_REQUEST PropPageRequest,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    )
{
    //
    // No property pages to add for now
    //
    UNREFERENCED_PARAMETER(PropPageRequest);
    UNREFERENCED_PARAMETER(lpfnAddPropSheetPageProc);
    UNREFERENCED_PARAMETER(lParam);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Driver Files popup dialog
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _DRIVERFILES_INFO {
    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
} DRIVERFILES_INFO, * PDRIVERFILES_INFO;

const TCHAR*  tszStringFileInfo = TEXT("StringFileInfo\\%04X%04X\\");
const TCHAR*  tszFileVersion = TEXT("FileVersion");
const TCHAR*  tszLegalCopyright = TEXT("LegalCopyright");
const TCHAR*  tszCompanyName = TEXT("CompanyName");
const TCHAR*  tszTranslation = TEXT("VarFileInfo\\Translation");
const TCHAR*  tszStringFileInfoDefault = TEXT("StringFileInfo\\040904B0\\");

BOOL
GetVersionInfo(
    IN  PTSTR FullPathName,
    OUT PTSTR Provider,
    IN  ULONG ProviderSize,
    OUT PTSTR Copyright,
    IN  ULONG CopyrightSize,
    OUT PTSTR Version,
    IN  ULONG VersionSize
    )
{
    DWORD Size, dwHandle;
    TCHAR str[MAX_PATH];
    TCHAR strStringFileInfo[MAX_PATH];
    PVOID pVerInfo;

    Size = GetFileVersionInfoSize((LPTSTR)(LPCTSTR)FullPathName, &dwHandle);
    
    if (!Size) {
    
        return FALSE;
    }

    if ((pVerInfo = malloc(Size)) != NULL) {

        if (GetFileVersionInfo((LPTSTR)(LPCTSTR)FullPathName, dwHandle, Size, pVerInfo)) {
        
            //
            // get VarFileInfo\Translation
            //
            PVOID pBuffer;
            UINT Len;
            
            if (!VerQueryValue(pVerInfo, (LPTSTR)tszTranslation, &pBuffer, &Len))
            {
                lstrcpy(strStringFileInfo, tszStringFileInfoDefault);
            }
            else
            {
                wsprintf(strStringFileInfo, tszStringFileInfo, *((WORD*)pBuffer), *(((WORD*)pBuffer) + 1));
            }
            
            lstrcpy(str, strStringFileInfo);
            lstrcat(str, tszFileVersion);
            
            if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len)) {
            
                lstrcpyn(Version, (LPTSTR)pBuffer, VersionSize/sizeof(TCHAR));
                Version[(VersionSize-1)/sizeof(TCHAR)] = TEXT('\0');

                lstrcpy(str, strStringFileInfo);
                lstrcat(str, tszLegalCopyright);
                
                if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len)) {
                
                    lstrcpyn(Copyright, (LPTSTR)pBuffer, CopyrightSize/sizeof(TCHAR));
                    Copyright[(CopyrightSize-1)/sizeof(TCHAR)] = TEXT('\0');
                    
                    lstrcpy(str, strStringFileInfo);
                    lstrcat(str, tszCompanyName);
                    
                    if (VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len)) {
                    
                        lstrcpyn(Provider, (LPTSTR)pBuffer, ProviderSize/sizeof(TCHAR));
                        Provider[(ProviderSize-1)/sizeof(TCHAR)] = TEXT('\0');
                    }
                }
            }
        }

        free(pVerInfo);

    }
    
    return TRUE;
}



BOOL
pDriverFilesGetServiceFilePath(
    HDEVINFO DeviceInfoSet,
    PSP_DEVINFO_DATA DeviceInfoData,
    PTSTR ServiceFilePath,
    ULONG FileSize
    )
{
    BOOL bReturn = FALSE;
    TCHAR ServiceName[MAX_PATH];
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSCService = NULL;
    LPQUERY_SERVICE_CONFIG lpqscBuf = NULL;
    DWORD dwBytesNeeded, Size;
    BOOL bComposePathNameFromServiceName = TRUE;

    ServiceFilePath[0] = TEXT('\0');

    if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_SERVICE,
                                         NULL,
                                         (PBYTE)ServiceName,
                                         sizeof(ServiceName),
                                         NULL)) {

        try {

            //
            // Open the Service Control Manager
            //
            if ((hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ)) != NULL) {

                //
                // Try to open the service's handle
                //
                if ((hSCService = OpenService(hSCManager, ServiceName, GENERIC_READ)) != NULL) {

                    //
                    // Now, attempt to get the configuration
                    //
                    if ((!QueryServiceConfig(hSCService, NULL, 0, &dwBytesNeeded)) &&
                        (ERROR_INSUFFICIENT_BUFFER == GetLastError())) {

                        if ((lpqscBuf = (LPQUERY_SERVICE_CONFIG)malloc(dwBytesNeeded)) != NULL) {

                            if ((QueryServiceConfig(hSCService, lpqscBuf, dwBytesNeeded, &Size)) &&
                                (lpqscBuf->lpBinaryPathName[0] != TEXT('\0'))) {

                                if (GetFileAttributes(lpqscBuf->lpBinaryPathName) != 0xFFFFFFFF) {

                                    bReturn = TRUE;
                                    lstrcpyn(ServiceFilePath, lpqscBuf->lpBinaryPathName, FileSize);
                                    bComposePathNameFromServiceName = FALSE;
                                }                                    
                            }                                                    

                            free(lpqscBuf);
                        }
                    }

                    CloseServiceHandle(hSCService);
                }                    

                CloseServiceHandle(hSCManager);
            }


            //
            // If we could not get the path name from the service then we will attempt
            // to find it ourselves
            //
            if (bComposePathNameFromServiceName) {

                TCHAR FullPathName[MAX_PATH + 1];
                TCHAR SysDir[MAX_PATH + 1];
                GetSystemDirectory(SysDir, sizeof(SysDir)/sizeof(SysDir[0]));
                lstrcpy(FullPathName, SysDir);
                lstrcat(FullPathName, TEXT("\\drivers\\"));
                lstrcat(FullPathName, ServiceName);
                lstrcat(FullPathName, TEXT(".sys"));
                
                if (GetFileAttributes(FullPathName) != 0xFFFFFFFF) {

                    bReturn = TRUE;
                    lstrcpyn(ServiceFilePath, FullPathName, FileSize);
                }
            }
        
        } except (EXCEPTION_EXECUTE_HANDLER)  {
            ;
        }
    }                           

    return(bReturn);
}

void
DriverFiles_ShowFileDetail(
    HWND hDlg
    )
{
    TCHAR DriverFile[MAX_PATH];
    TCHAR Provider[MAX_PATH];
    TCHAR Copyright[MAX_PATH];
    TCHAR Version[MAX_PATH];
    DWORD_PTR Index;

    if ((Index = SendMessage(GetDlgItem(hDlg, IDC_DRIVERFILES_FILELIST), LB_GETCURSEL, 0, 0)) != LB_ERR) {

        SendMessage(GetDlgItem(hDlg, IDC_DRIVERFILES_FILELIST), LB_GETTEXT, Index, (LPARAM)DriverFile);
        
        Provider[0] = TEXT('\0');
        Copyright[0] = TEXT('\0');
        Version[0] = TEXT('\0');

        GetVersionInfo(DriverFile,
                       Provider,
                       sizeof(Provider),
                       Copyright,
                       sizeof(Copyright),
                       Version,
                       sizeof(Version));

        if (Provider[0] != TEXT('\0')) {

            SetDlgItemText(hDlg, IDC_DRIVERFILES_PROVIDER, Provider);
        }

        if (Version[0] != TEXT('\0')) {

            SetDlgItemText(hDlg, IDC_DRIVERFILES_VERSION, Version);
        }

        if (Copyright[0] != TEXT('\0')) {

            SetDlgItemText(hDlg, IDC_DRIVERFILES_COPYRIGHT, Copyright);
        }
    }
}

BOOL
DriverFiles_OnInitDialog(
    HWND    hDlg,
    HWND    FocusHwnd,
    LPARAM  lParam
    )
{
    PDRIVERFILES_INFO dfi = (PDRIVERFILES_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
    HICON ClassIcon;
    HICON OldIcon;
    TCHAR DeviceDescription[MAX_DEVICE_ID_LEN];
    TCHAR DriverName[MAX_PATH];

    dfi = (PDRIVERFILES_INFO)lParam;
    SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR)dfi);

    //
    // Draw the interface: first the icon
    //
    if (SetupDiLoadClassIcon(&dfi->DeviceInfoData->ClassGuid, &ClassIcon, NULL)) {

        OldIcon = (HICON)SendDlgItemMessage(hDlg,
                                            IDC_DRIVERFILES_ICON,
                                            STM_SETICON,
                                            (WPARAM)ClassIcon,
                                            0);
        if (OldIcon) {
        
            DestroyIcon(OldIcon);
        }
    }
    
    //
    // Then the device name
    //
    if (SetupDiGetDeviceRegistryProperty(dfi->DeviceInfoSet,
                                         dfi->DeviceInfoData,
                                         SPDRP_DEVICEDESC,
                                         NULL,
                                         (PBYTE)DeviceDescription,
                                         MAX_DEVICE_ID_LEN,
                                         NULL)) {
                                         
        SetDlgItemText(hDlg, IDC_DRIVERFILES_DESC, DeviceDescription);
    }

    if ((pDriverFilesGetServiceFilePath(dfi->DeviceInfoSet, dfi->DeviceInfoData, DriverName, (sizeof(DriverName)/sizeof(DriverName[0])))) &&
        (DriverName[0] != TEXT('\0'))) {
    
        SendMessage(GetDlgItem(hDlg, IDC_DRIVERFILES_FILELIST), LB_ADDSTRING, 0, (LPARAM)DriverName);
    }

    SendMessage(GetDlgItem(hDlg, IDC_DRIVERFILES_FILELIST), LB_SETCURSEL, 0, 0);
    DriverFiles_ShowFileDetail(hDlg);

    return TRUE;
}

BOOL
DriverFiles_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            L"devmgr.hlp",
            HELP_CONTEXTMENU,
            (ULONG_PTR) DriverFiles_HelpIDs);

    return FALSE;
}

void
DriverFiles_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                L"devmgr.hlp",
                HELP_WM_HELP,
                (ULONG_PTR) DriverFiles_HelpIDs);
    }
}

void
DriverFiles_OnCommand(
    HWND hDlg,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{

    switch (ControlId) {

    case IDOK:
    case IDCANCEL:
        EndDialog(hDlg, 0);
        break;

    case IDC_DRIVERFILES_FILELIST:
        if (ControlId == LBN_SELCHANGE) {

            DriverFiles_ShowFileDetail(hDlg);
        }
        break;
    }
}

INT_PTR
APIENTRY
DriverFiles_DlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {

    case WM_INITDIALOG:
        return DriverFiles_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_COMMAND:
        DriverFiles_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_CLOSE:
        EndDialog(hDlg, 0);
        break;

    case WM_CONTEXTMENU:
        return DriverFiles_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        DriverFiles_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;
    }

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
//
// Legacy Devices property page provider
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _LEGACY_PAGE_INFO {
    HDEVINFO                DeviceInfoSet;
    PSP_DEVINFO_DATA        DeviceInfoData;

    SC_HANDLE               hSCManager;         // Handle to the SC Manager
    SC_HANDLE               hService;           // The handle to the service
    DWORD                   dwStartType;        // The start type
    SERVICE_STATUS          ServiceStatus;      // Tells us if the service is started
    TCHAR                   ServiceName[MAX_DEVICE_ID_LEN];
    TCHAR                   DisplayName[MAX_PATH];
    DWORD                   NumDependentServices;
    LPENUM_SERVICE_STATUS   pDependentServiceList;

} LEGACY_PAGE_INFO, * PLEGACY_PAGE_INFO;

BOOL
DependentServices_OnInitDialog(
    HWND    hDlg,
    HWND    FocusHwnd,
    LPARAM  lParam
    )
{
    PLEGACY_PAGE_INFO   lpi;
    HWND                hWndListBox;
    DWORD               i;
    HICON               hicon = NULL;

    lpi = (PLEGACY_PAGE_INFO)lParam;
    SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR)lpi);
    
    if (hicon = LoadIcon(NULL, IDI_WARNING)) {
        SendDlgItemMessage(hDlg, IDC_ICON_WARN_SERVICES, STM_SETICON, (WPARAM)hicon, 0L);
        DestroyIcon(hicon);
    }

    hWndListBox = GetDlgItem(hDlg, IDC_LIST_SERVICES);

    for (i=0; i<lpi->NumDependentServices; i++) {
        SendMessage(hWndListBox, 
                    LB_ADDSTRING, 
                    0,
                    (LPARAM) lpi->pDependentServiceList[i].lpDisplayName
                    );
    }

    return TRUE;
}

INT_PTR
APIENTRY
DependentServicesDlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PLEGACY_PAGE_INFO   lpi = (PLEGACY_PAGE_INFO)GetWindowLongPtr(hDlg, DWLP_USER);;

    switch(uMessage) {

    case WM_INITDIALOG:
        return DependentServices_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, 0);
        break;
    }

    return FALSE;
}

int
pLegacyDriverMapStateToName(
    IN DWORD dwServiceState
    )
{
    switch(dwServiceState) {
    
    case SERVICE_STOPPED:
        return IDS_SVC_STATUS_STOPPED;

    case SERVICE_STOP_PENDING:
        return IDS_SVC_STATUS_STOPPING;

    case SERVICE_RUNNING:
         return IDS_SVC_STATUS_STARTED;
    
    case SERVICE_START_PENDING:
        return IDS_SVC_STATUS_STARTING;

    case SERVICE_PAUSED:
        return IDS_SVC_STATUS_PAUSED;

    case SERVICE_PAUSE_PENDING:
        return IDS_SVC_STATUS_PAUSING;

    case SERVICE_CONTINUE_PENDING:
        return IDS_SVC_STATUS_RESUMING;

    default:
        return IDS_SVC_STATUS_UNKNOWN;
    }
    
    return IDS_SVC_STATUS_UNKNOWN;
}

VOID
pLegacyDriverInitializeStartButtons(
    IN HWND             hDlg,
    IN LPSERVICE_STATUS ServiceStatus
    )  
{
    //
    // Decide how to paint the two start/stop buttons
    //
    TCHAR       szStatus[MAX_PATH];

    //
    // Set the status text
    //
    if (LoadString(MyModuleHandle,
                   pLegacyDriverMapStateToName(ServiceStatus->dwCurrentState),
                   szStatus,
                   MAX_PATH)) {

        SetDlgItemText(hDlg, IDC_STATIC_CURRENT_STATUS, szStatus);
    }

    //
    // Decide if the service is started or stopped
    //
    if ((ServiceStatus->dwCurrentState == SERVICE_STOPPED) ) {
    
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_START), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), FALSE);
        
    } else {
    
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_START), FALSE);
    }

    //
    // If the service doesn't accept stops, grey the stop
    // button
    //
    if (!(ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_STOP)) {

        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), FALSE);
    }

    return;
}

VOID
pLegacyDriverSetPropertyPageState(
    IN  HWND                hDlg,
    IN  PLEGACY_PAGE_INFO   lpi,
    IN  BOOL                ReadOnly
    )
{
    DWORD_PTR Index;
    DWORD_PTR ServiceStartType;
    TCHAR    szStatus[MAX_PATH];

    if (ReadOnly) {

        //
        // Disable everything
        //
        EnableWindow(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_START), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), FALSE);
        
        //
        // Set the status text
        //
        if (LoadString(MyModuleHandle,
                       pLegacyDriverMapStateToName(lpi->ServiceStatus.dwCurrentState),
                       szStatus,
                       MAX_PATH)) {

            SetDlgItemText(hDlg, IDC_STATIC_CURRENT_STATUS, szStatus);
        }

    } else {
    
        Index = 0;

        while ((ServiceStartType = SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), 
                CB_GETITEMDATA, Index, 0)) != CB_ERR) {

            if (ServiceStartType == lpi->dwStartType) {

                SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), CB_SETCURSEL, Index, 0);
                break;
            }

            Index++;
        }                

        SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), CB_GETCURSEL, 0, 0);

        //
        // If the start type is SERVICE_DISABLED then gray out both the start
        // and stop buttons.
        //
        if (lpi->dwStartType == SERVICE_DISABLED) {
            
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_START), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), FALSE);

            //
            // Set the status text
            //
            if (LoadString(MyModuleHandle,
                           pLegacyDriverMapStateToName(lpi->ServiceStatus.dwCurrentState),
                           szStatus,
                           MAX_PATH)) {

                SetDlgItemText(hDlg, IDC_STATIC_CURRENT_STATUS, szStatus);
            }

        } else {

            pLegacyDriverInitializeStartButtons(hDlg, &lpi->ServiceStatus);
        }

    }

    return;
}

BOOL
pLegacyDriverCheckServiceStatus(
    IN     SC_HANDLE        hService,
    IN OUT LPSERVICE_STATUS ServiceStatus,
    IN     USHORT           ControlType
    )  
{
    DWORD   dwIntendedState;
    DWORD   dwCummulateTimeSpent = 0;


    if ((ControlType != START_LEGACY_DEVICE) && 
        (ControlType != STOP_LEGACY_DEVICE)) {
        return TRUE;
    }
    
    if (ControlType == START_LEGACY_DEVICE) {
        dwIntendedState = SERVICE_RUNNING;
        
    } else {
        dwIntendedState = SERVICE_STOPPED;
    }


    if (!QueryServiceStatus(hService, ServiceStatus)) {
        return FALSE;
    }

    while (ServiceStatus->dwCurrentState != dwIntendedState) {

        //
        // Wait for the specified interval
        //
        Sleep(SERVICE_WAIT_TIME);

        //
        // Check the status again
        //
        if (!QueryServiceStatus(hService, ServiceStatus)) {
            return FALSE;
        }
        
        //
        // OK, add a (generous) timeout here
        //
        dwCummulateTimeSpent += SERVICE_WAIT_TIME;
        if (dwCummulateTimeSpent > 1000 * MAX_SECONDS_UNTIL_TIMEOUT) {
            SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
            return FALSE;
        }
    }

    //
    // If we are here we can return only TRUE
    //
    return TRUE;
}

VOID
pLegacyDriverDisplayErrorMsgBox(
    IN HWND hWnd,
    IN LPTSTR ServiceName,
    IN int ResId,
    IN DWORD ErrorCode
    )
{
    TCHAR TextBuffer[MAX_PATH * 4];
    TCHAR Title[MAX_PATH];
    PTCHAR ErrorMsg;

    if (LoadString(MyModuleHandle, ResId, TextBuffer, sizeof(TextBuffer)/sizeof(TCHAR))) {

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          ErrorCode,
                          0,
                          (LPTSTR)&ErrorMsg,
                          0,
                          NULL
                          )) {

            lstrcat(TextBuffer, ErrorMsg);
            MessageBox(hWnd, TextBuffer, ServiceName, MB_OK);

            LocalFree(ErrorMsg);
        }
    }
}

VOID
pLegacyDriverOnStart(
    IN HWND hDlg
    )  
{
    PLEGACY_PAGE_INFO   lpi;
    HCURSOR hOldCursor;

    //
    // Retrieve the device data structure first
    //
    lpi = (PLEGACY_PAGE_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    try {

        if (!StartService(lpi->hService,
                          0,
                          NULL)) {


            pLegacyDriverDisplayErrorMsgBox(hDlg,
                                            lpi->DisplayName,
                                            IDS_SVC_START_ERROR,
                                            GetLastError()
                                            );
            goto clean0;
        }
        pLegacyDriverCheckServiceStatus(lpi->hService,
                                        &lpi->ServiceStatus, 
                                        START_LEGACY_DEVICE
                                        );

        clean0:
        
        //
        // Repaint the status part
        //
        pLegacyDriverSetPropertyPageState(hDlg, lpi, FALSE);


    }except  (EXCEPTION_EXECUTE_HANDLER) {

        lpi = lpi;
    }

    SetCursor(hOldCursor);

    return;
}

VOID
pLegacyDriverOnStop(
    IN HWND hDlg
    )  
{
    BOOL                    bStopServices = TRUE;
    DWORD                   Err;
    PLEGACY_PAGE_INFO       lpi;
    HCURSOR                 hOldCursor;
    BOOL                    bSuccess;
    DWORD                   cbBytesNeeded;
    DWORD                   dwServicesReturned = 0;
    DWORD                   i;
    TCHAR                   DisplayName[MAX_PATH];
    SC_HANDLE               hService;
    SERVICE_STATUS          ServiceStatus;
    LPENUM_SERVICE_STATUS   pDependentServiceList = NULL;

    //
    // Retrieve the device data structure first
    //
    lpi = (PLEGACY_PAGE_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    MYASSERT (lpi);
    if (!lpi) {
        return;
    }

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    try {

        //
        // Find out if this device has any dependent services, and if so then
        // how many bytes are needed to enumerate the dependent services.
        //
        EnumDependentServices(lpi->hService,
                              SERVICE_ACTIVE,
                              NULL,
                              0,
                              &cbBytesNeeded,
                              &dwServicesReturned
                              );

        if (cbBytesNeeded > 0) {
            pDependentServiceList = (LPENUM_SERVICE_STATUS)malloc(cbBytesNeeded);

            if (pDependentServiceList) {
                EnumDependentServices(lpi->hService,
                                      SERVICE_ACTIVE,
                                      pDependentServiceList,
                                      cbBytesNeeded,
                                      &cbBytesNeeded,
                                      &dwServicesReturned
                                      );

                if (dwServicesReturned > 0) {
                    //
                    // Ask the user if they want to stop these dependet services.
                    //
                    lpi->NumDependentServices = dwServicesReturned;
                    lpi->pDependentServiceList = pDependentServiceList;

                    if (DialogBoxParam(MyModuleHandle, 
                                       MAKEINTRESOURCE(IDD_SERVICE_STOP_DEPENDENCIES), 
                                       hDlg, 
                                       DependentServicesDlgProc, 
                                       (LPARAM)lpi
                                       ) == IDCANCEL) {
                        bStopServices = FALSE;
                    }
                }
            }
        }

        //
        // Stop this service and all the dependent services if the user did 
        // not cancel out of the dialog box.
        //
        if (bStopServices) {

            Err = ERROR_SUCCESS;

            SetCursor(LoadCursor(NULL, IDC_WAIT));

            //
            // First stop all of the dependent services if their are any.
            //
            if (pDependentServiceList && (dwServicesReturned > 0)) {
                for (i=0; i<dwServicesReturned; i++) {
                    hService = OpenService(lpi->hSCManager,
                                           pDependentServiceList[i].lpServiceName,
                                           GENERIC_READ | SERVICE_STOP
                                           );

                    if (hService == NULL) {
                        //
                        // Just bail out if we encountered an error.  The reason
                        // is that if one of the services cannot be stopped
                        // then we won't be able to stop the selected service.
                        //
                        Err = GetLastError();
                        lstrcpy(DisplayName, pDependentServiceList[i].lpServiceName);
                        break;
                    }

                    if (!ControlService(hService,
                                        SERVICE_CONTROL_STOP,
                                        &ServiceStatus
                                        )) {
                        Err = GetLastError();
                        lstrcpy(DisplayName, pDependentServiceList[i].lpServiceName);
                        CloseServiceHandle(hService);
                        break;
                    }

                    //
                    // Wait for the service to actually stop.
                    //
                    if (!pLegacyDriverCheckServiceStatus(hService,
                                                         &ServiceStatus,
                                                         STOP_LEGACY_DEVICE
                                                         )) {
                        Err = GetLastError();
                        lstrcpy(DisplayName, pDependentServiceList[i].lpServiceName);
                        CloseServiceHandle(hService);
                        break;
                    }

                    CloseServiceHandle(hService);
                }
            }

            //
            // Only attempt to stop the selected service if all of the dependent
            // services were stoped.
            //
            if (Err == ERROR_SUCCESS) {
                //
                // Tell the service to stop.
                //
                if (!ControlService(lpi->hService,
                                    SERVICE_CONTROL_STOP,
                                    &lpi->ServiceStatus)) {
                                
                    Err = GetLastError();
                    lstrcpy(DisplayName, lpi->DisplayName);
                
                } else {
                    //
                    // Wait for the service to stop.
                    //
                    if (!pLegacyDriverCheckServiceStatus(lpi->hService,
                                                         &lpi->ServiceStatus,
                                                         STOP_LEGACY_DEVICE
                                                         )) {
                        Err = GetLastError();
                        lstrcpy(DisplayName, lpi->DisplayName);
                    }
                }
            }

            if (Err != ERROR_SUCCESS) {
                pLegacyDriverDisplayErrorMsgBox(hDlg,
                                                DisplayName,
                                                IDS_SVC_STOP_ERROR,
                                                Err
                                                );
            }

            //
            // Repaint the status part
            //
            pLegacyDriverSetPropertyPageState(hDlg, lpi, FALSE);
        }

    }except  (EXCEPTION_EXECUTE_HANDLER) {
    
        pDependentServiceList = pDependentServiceList;
    }

    if (pDependentServiceList) {
        free(pDependentServiceList);
    }

    SetCursor(hOldCursor);

    return;            
}

PLEGACY_PAGE_INFO
LegacyDriver_CreatePageInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData)
{
    PLEGACY_PAGE_INFO lpi = (PLEGACY_PAGE_INFO) MyMalloc(sizeof(LEGACY_PAGE_INFO));

    if (!lpi) {
        return NULL;
    }

    lpi->DeviceInfoSet = DeviceInfoSet;
    lpi->DeviceInfoData = DeviceInfoData;

    return lpi;
}

VOID
LegacyDriver_OnApply(
    IN HWND    hDlg,
    IN DWORD   StartType
    )  
{
    PLEGACY_PAGE_INFO lpi;
    SC_LOCK sclLock = NULL;
    USHORT uCount = 0;
    LPQUERY_SERVICE_CONFIG lpqscBuf = NULL;
    DWORD dwBytesNeeded;

    //
    // Retrieve the device data structure first
    //
    lpi = (PLEGACY_PAGE_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

    try {
    
        //
        // Decide if we need to make any changes
        //
        if ((StartType == lpi->dwStartType) && 
            (StartType != SERVICE_DEMAND_START)) {
            
            goto clean0;
        }

        //
        // I guess we need to make some changes here and there...
        // Get the database lock first.
        //
        do {
        
            sclLock = LockServiceDatabase(lpi->hSCManager);
            
            if (sclLock == NULL) {

                //
                // If there is another error then the database locked by
                // another process, bail out
                //
                if (GetLastError() != ERROR_SERVICE_DATABASE_LOCKED) {

                    goto clean0;
                    
                } else {
                
                    //
                    // (Busy) wait and try again
                    //
                    Sleep (1000 * WAIT_TIME_SLOT);
                    uCount++;
                }
            }

        } while ((uCount < TRIES_COUNT) && (sclLock == NULL));

        if (sclLock == NULL) {

            //
            // Bail out now, we waited enough
            //
            goto clean0;
        }
        
        //
        // I have the lock. Hurry and query, then change the config
        //
        //
        // Now, attempt to get the configuration
        //
        if ((lpqscBuf = (LPQUERY_SERVICE_CONFIG)malloc(SERVICE_BUFFER_SIZE)) == NULL) {
            
            //
            // We're out of here
            //
            goto clean0;

        }


        if (!QueryServiceConfig(lpi->hService,
                                lpqscBuf,
                                SERVICE_BUFFER_SIZE,
                                &dwBytesNeeded
                                )) {
                                
            //
            // Try again with a new buffer
            //
            if ((lpqscBuf = realloc(lpqscBuf, dwBytesNeeded)) == NULL) {
            
                //
                // We're out of here
                //
                goto clean0;

            }
            
            if (!QueryServiceConfig(lpi->hService,
                                    lpqscBuf,
                                    SERVICE_BUFFER_SIZE,
                                    &dwBytesNeeded
                                    )) {
                                    
                goto clean0;
            }
        }
        
        //
        // Change tye service type (we needed the service name, too, 
        // that's why we're querying it first)
        //
        if (ChangeServiceConfig(lpi->hService,
                                 SERVICE_NO_CHANGE,
                                 StartType,
                                 SERVICE_NO_CHANGE,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL)) {
                                 
            //
            // We succesfully changed the status. 
            // Reflect in our page display
            //
            lpi->dwStartType = StartType;
        }

        //
        // Unlock the database
        //
        if (sclLock) {
        
            UnlockServiceDatabase(sclLock);
            sclLock = NULL;
        }


        //
        // We want to see something different on apply, so repaint
        // the whole stuff
        //
        pLegacyDriverSetPropertyPageState(hDlg,
                                          lpi,
                                          FALSE);  // if we managed to apply some changes
                                                   // we are not read-only
                              
        clean0:
        
        if (sclLock) {
        
            UnlockServiceDatabase(sclLock);
            sclLock = NULL;
        }
        
        if (lpqscBuf) {
        
            free(lpqscBuf);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
    
        lpi = lpi;
    }

    return;
}


BOOL
LegacyDriver_OnInitDialog(
    HWND    hDlg,
    HWND    FocusHwnd,
    LPARAM  lParam
    )
{
    PLEGACY_PAGE_INFO lpi = (PLEGACY_PAGE_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
    BOOL bNoService = FALSE;
    BOOL ReadOnly = FALSE;
    HICON ClassIcon;
    HICON OldIcon;
    TCHAR DeviceDescription[MAX_DEVICE_ID_LEN];
    TCHAR DriverName[MAX_PATH];
    TCHAR StartupType[MAX_PATH];
    DWORD dwBytesNeeded;
    LPQUERY_SERVICE_CONFIG lpqscBuf = NULL;
    DWORD_PTR index;
    HWND hCombo;

    lpi = (PLEGACY_PAGE_INFO) ((LPPROPSHEETPAGE)lParam)->lParam;
    SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR)lpi);


    //
    // First, open the Service Control Manager
    //
    lpi->hSCManager = OpenSCManager(NULL,
                                    NULL,
                                    GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE);
                                    
    if (!lpi->hSCManager && (GetLastError() == ERROR_ACCESS_DENIED)) {
    
        //
        // This is not fatal, attempt to open the database only
        // for read
        //
        ReadOnly = FALSE;

        lpi->hSCManager = OpenSCManager(NULL,
                                        NULL,
                                        GENERIC_READ);
                                        
        if (!lpi->hSCManager) {
        
            //
            // This is fatal
            //
            lpi->hSCManager = NULL;
        }
    }

    //
    // Now, get the service name
    //
    if (!SetupDiGetDeviceRegistryProperty(lpi->DeviceInfoSet,
                                          lpi->DeviceInfoData,
                                          SPDRP_SERVICE,
                                          NULL,
                                          (PBYTE)lpi->ServiceName,
                                          sizeof(lpi->ServiceName),
                                          NULL)
       ) {
       
        LoadString(MyModuleHandle, IDS_UNKNOWN, lpi->ServiceName, sizeof(lpi->ServiceName)/sizeof(lpi->ServiceName[0]));
        ReadOnly = TRUE;
        goto clean0;
    }

    //
    // Now we have a service name, try to open its handle
    //
    if (!ReadOnly) {
    
        lpi->hService = OpenService(lpi->hSCManager,
                                    lpi->ServiceName,
                                    GENERIC_WRITE | GENERIC_READ | 
                                    GENERIC_EXECUTE);
                                    
        if (!lpi->hService) {
        
            //
            // OK, let them try again
            //
            ReadOnly = TRUE;
        }
    }
    
    if (ReadOnly) {
    
        lpi->hService = OpenService(lpi->hSCManager,
                                    lpi->ServiceName,
                                    GENERIC_READ);
                                    
        if (!lpi->hService) {
        
            //
            // Sorry, this is fatal
            //
            ReadOnly = TRUE;
            goto clean0;
        }
    }

    //
    // Now, attempt to get the configuration
    //
    lpqscBuf = (LPQUERY_SERVICE_CONFIG)malloc(SERVICE_BUFFER_SIZE);
    if (!lpqscBuf) {
    
        ReadOnly = TRUE;
        goto clean0;
    }

    if (!QueryServiceConfig(lpi->hService,
                            lpqscBuf,
                            SERVICE_BUFFER_SIZE,
                            &dwBytesNeeded
                            )) {
        //
        // Try again with a new buffer
        //
        if ((lpqscBuf = realloc(lpqscBuf, dwBytesNeeded)) == NULL) {

            //
            // We're out of here
            //
            ReadOnly = TRUE;
            goto clean0;
        }

        if (!QueryServiceConfig(lpi->hService,
                                lpqscBuf,
                                SERVICE_BUFFER_SIZE,
                                &dwBytesNeeded
                                )) {
                                
            ReadOnly = TRUE;
            goto clean0;
        }
    }

    //
    // We have the buffer now, get the start type from it
    //
    lpi->dwStartType = lpqscBuf->dwStartType;

    if (!ControlService(lpi->hService,
                        SERVICE_CONTROL_INTERROGATE,
                        &lpi->ServiceStatus)) {
                        
        
        DWORD Err = GetLastError();

        //
        // If ControlService failed with one of the following errors then it is OK 
        // and the ServiceStatus was still filled in.
        //
        if ((Err != NO_ERROR) &&
            (Err != ERROR_SERVICE_NOT_ACTIVE)) {
        
            //
            // Bail out,
            //
            ReadOnly = TRUE;
            goto clean0;
        }
    }


    //
    // Add the startup types to the combo box
    //
    hCombo = GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE);
    
    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_AUTOMATIC, StartupType, sizeof(StartupType)/sizeof(StartupType[0]));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_AUTO_START);
    
    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_BOOT, StartupType, sizeof(StartupType)/sizeof(StartupType[0]));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_BOOT_START);
    
    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_DEMAND, StartupType, sizeof(StartupType)/sizeof(StartupType[0]));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_DEMAND_START);
    
    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_SYSTEM, StartupType, sizeof(StartupType)/sizeof(StartupType[0]));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_SYSTEM_START);

    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_DISABLED, StartupType, sizeof(StartupType)/sizeof(StartupType[0]));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_DISABLED);
    
clean0:

    //
    // Now draw the interface: first the icon
    //
    if (SetupDiLoadClassIcon(&lpi->DeviceInfoData->ClassGuid, &ClassIcon, NULL)) {

        OldIcon = (HICON)SendDlgItemMessage(hDlg,
                                            IDC_PROP_LEGACY_ICON,
                                            STM_SETICON,
                                            (WPARAM)ClassIcon,
                                            0);
        if (OldIcon) {
        
            DestroyIcon(OldIcon);
        }
    }
    
    //
    // Then the device name
    //
    if (SetupDiGetDeviceRegistryProperty(lpi->DeviceInfoSet,
                                         lpi->DeviceInfoData,
                                         SPDRP_DEVICEDESC,
                                         NULL,
                                         (PBYTE)DeviceDescription,
                                         MAX_DEVICE_ID_LEN,
                                         NULL)) {
                                         
        SetDlgItemText(hDlg, IDC_PROP_LEGACY_DESC, DeviceDescription);
    }

    SetDlgItemText(hDlg, IDC_EDIT_SERVICE_NAME, lpi->ServiceName);

    if (lpqscBuf && lpqscBuf->lpDisplayName) {
    
        SetDlgItemText(hDlg, IDC_EDIT_DISPLAY_NAME, lpqscBuf->lpDisplayName);
        lstrcpy(lpi->DisplayName, lpqscBuf->lpDisplayName);

    } else {

        TCHAR Unknown[MAX_PATH];
        LoadString(MyModuleHandle, IDS_UNKNOWN, Unknown, sizeof(Unknown)/sizeof(Unknown[0]));
        SetDlgItemText(hDlg, IDC_EDIT_DISPLAY_NAME, Unknown);
        lstrcpy(lpi->DisplayName, Unknown);
    }

    pLegacyDriverSetPropertyPageState(hDlg, lpi, ReadOnly);

    //
    // Show/Gray the details button
    //
    EnableWindow(GetDlgItem(hDlg, IDC_LEGACY_DETAILS),
        (pDriverFilesGetServiceFilePath(lpi->DeviceInfoSet, lpi->DeviceInfoData, DriverName, (sizeof(DriverName)/sizeof(DriverName[0])))));


    if (lpqscBuf) {
    
        free(lpqscBuf);
    }

    return TRUE;
}

void
LegacyDriver_OnCommand(
    HWND hDlg,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PLEGACY_PAGE_INFO lpi = (PLEGACY_PAGE_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

    if (NotifyCode == CBN_SELCHANGE) {

        PropSheet_Changed(GetParent(hDlg), hDlg);
    }
    
    else {

        switch (ControlId) {

            case IDC_BUTTON_START:
                pLegacyDriverOnStart(hDlg); 
                break;

            case IDC_BUTTON_STOP:
                pLegacyDriverOnStop(hDlg);
                break;

            case IDC_LEGACY_DETAILS:
            {
                DRIVERFILES_INFO dfi;
                ZeroMemory(&dfi, sizeof(DRIVERFILES_INFO));
                dfi.DeviceInfoSet = lpi->DeviceInfoSet;
                dfi.DeviceInfoData = lpi->DeviceInfoData;
                DialogBoxParam(MyModuleHandle, MAKEINTRESOURCE(IDD_DRIVERFILES), 
                        hDlg, DriverFiles_DlgProc, (LPARAM)&dfi);
            }
                break;

            default:
                break;
        }
    }
}

BOOL
LegacyDriver_OnNotify(
    HWND    hDlg,
    LPNMHDR NmHdr
    )
{
    DWORD StartType;
    DWORD_PTR Index;

    switch (NmHdr->code) {

        //
        // The user is about to change an up down control
        //
        case UDN_DELTAPOS:
            PropSheet_Changed(GetParent(hDlg), hDlg);
            return FALSE;

        //
        // Sent when the user clicks on Apply OR OK !!
        //
        case PSN_APPLY:
            if (CB_ERR != (Index = SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE),
                    CB_GETCURSEL, 0, 0))) {

                StartType = (DWORD)SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), CB_GETITEMDATA, Index, 0);
                                
                LegacyDriver_OnApply(hDlg, StartType);
            }
            
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;

        default:
            return FALSE;
    }
}

BOOL
LegacyDriver_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            L"devmgr.hlp",
            HELP_CONTEXTMENU,
            (ULONG_PTR) LegacyDriver_HelpIDs);

    return FALSE;
}

void
LegacyDriver_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                L"devmgr.hlp",
                HELP_WM_HELP,
                (ULONG_PTR) LegacyDriver_HelpIDs);
    }
}

INT_PTR
APIENTRY
LegacyDriver_DlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {

    case WM_COMMAND:
        LegacyDriver_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_INITDIALOG:
        return LegacyDriver_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return LegacyDriver_OnNotify(hDlg,  (NMHDR *)lParam);

    case WM_CONTEXTMENU:
        return LegacyDriver_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        LegacyDriver_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;
    }

    return FALSE;
}

void
LegacyDriver_DestroyPageInfo(
    PLEGACY_PAGE_INFO lpi
    )
{
    try {
    
        //
        // Close the service handle
        //
        if (lpi->hService) {

            CloseServiceHandle(lpi->hService);
        }

        //
        // Close the service manager handle
        //
        if (lpi->hSCManager) {

            CloseServiceHandle(lpi->hSCManager);
        }

    } except (EXCEPTION_EXECUTE_HANDLER)  {

        //
        // Access a variable, so that the compiler will respect our statement
        // order w.r.t. assignment.
        //
        lpi = lpi;
    }

    MyFree(lpi);
}

UINT CALLBACK
LegacyDriver_PropPageCallback(
    HWND            Hwnd,
    UINT            Message,
    LPPROPSHEETPAGE PropSheetPage
    )
{
    PLEGACY_PAGE_INFO lpi;

    switch (Message) {
    
        case PSPCB_CREATE:
            return TRUE;    // return TRUE to continue with creation of page

        case PSPCB_RELEASE:
            lpi = (PLEGACY_PAGE_INFO) PropSheetPage->lParam;
            LegacyDriver_DestroyPageInfo(lpi);
            return 0;       // return value ignored

        default:
            break;
    }

    return TRUE;
}


HPROPSHEETPAGE
LegacyDriver_CreatePropertyPage(
    PROPSHEETPAGE *  PropSheetPage,
    PLEGACY_PAGE_INFO lpi
    )
{
    //
    // Add the Port Settings property page
    //
    PropSheetPage->dwSize      = sizeof(PROPSHEETPAGE);
    PropSheetPage->dwFlags     = PSP_USECALLBACK;
    PropSheetPage->dwFlags     = PSP_DEFAULT;
    PropSheetPage->hInstance   = MyModuleHandle;
    PropSheetPage->pszTemplate = MAKEINTRESOURCE(IDD_PROP_LEGACY_SERVICE);

    //
    // following points to the dlg window proc
    //
    PropSheetPage->pfnDlgProc = LegacyDriver_DlgProc;
    PropSheetPage->lParam     = (LPARAM)lpi;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    PropSheetPage->pfnCallback = LegacyDriver_PropPageCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(PropSheetPage);
}

BOOL
LegacyDriverPropPageProvider(
    LPVOID Info,
    LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    LPARAM lParam
    )
{
    SP_DEVINSTALL_PARAMS DevInstallParams;
    PSP_PROPSHEETPAGE_REQUEST PropPageRequest;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;
    PLEGACY_PAGE_INFO lpi;

    PropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;

    if (PropPageRequest->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {

        lpi = LegacyDriver_CreatePageInfo(PropPageRequest->DeviceInfoSet, PropPageRequest->DeviceInfoData);

        if (!lpi) {

            return FALSE;
        }

        hpsp = LegacyDriver_CreatePropertyPage(&psp, lpi);

        if (!hpsp) {

            return FALSE;
        }

        if (!lpfnAddPropSheetPageProc(hpsp, lParam)) {
        
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }

        //
        // Tell device manager that we will display our own Driver tab for legacy device
        //
        ZeroMemory(&DevInstallParams, sizeof(DevInstallParams));
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        
        SetupDiGetDeviceInstallParams(lpi->DeviceInfoSet, lpi->DeviceInfoData, &DevInstallParams);
        
        DevInstallParams.Flags |= DI_DRIVERPAGE_ADDED;

        SetupDiSetDeviceInstallParams(lpi->DeviceInfoSet, lpi->DeviceInfoData, &DevInstallParams);
   }

   return TRUE;
}

BOOL
EisaUpHalPropPageProvider(
    IN PSP_PROPSHEETPAGE_REQUEST PropPageRequest,
    IN LPFNADDPROPSHEETPAGE AddPageRoutine,
    IN LPARAM AddPageContext
    )
{
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\clasinst.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    clasinst.c

Abstract:

    Routines for the following 'built-in' class installers:

        Keyboard
        Mouse
        NtApm
        DeviceBay

Author:

    Lonny McMichael 26-February-1996

Revision History:


    28-Aug-96               Andy Thornton (andrewth)

        Added DisableService, IsOnlyKeyboardDriver, RetrieveDriversStatus,
        CountDevicesControlled & pSetupAcquireSCMLock routines and modified the
        keyboard & mouse class installers to disable the old driver services
        under certain circumstances.  This is part of a fix for bug R56351 for
        NT 4.0 SP1.

    09-Apr-97               Lonny McMichael (lonnym)

        Moved pSetupAcquireSCMLock to setupapi and exposed it as a private export.


    19-Jun-97               Jim Cavalaris (t-jcaval)

        Added CriticalDeviceCoInstaller co-installer to store the ServiceName
        used by devices considered critical to getting the system up into
        user mode.

    25-Sep-98               Bryan Willman (bryanwi)

        Added apm support.

    11-May-01               Lonny McMichael (lonnym)

        Removed support for legacy INFs.

--*/


#include "setupp.h"
#pragma hdrstop

//
// include common INF strings headerfile.
//
#include <infstr.h>

//
// instantiate device class GUIDs.
//
#include <initguid.h>
#include <devguid.h>

#ifdef UNICODE
#define _UNICODE
#endif
#include <tchar.h>

//
// Just to make sure no one is trying to use this obsolete string definition.
//
#ifdef IDS_DEVINSTALL_ERROR
    #undef IDS_DEVINSTALL_ERROR
#endif

//
// Some debugging aids for us kernel types
//

//#define CHKPRINT 1
#define CHKPRINT 0

#if CHKPRINT
#define ChkPrintEx(_x_) DbgPrint _x_   // use:  ChkPrintEx(( "%x", var, ... ));
#define ChkBreak()    DbgBreakPoint()
#else
#define ChkPrintEx(_x_)
#define ChkBreak()
#endif

//
// Declare a string containing the character representation of the Display class GUID.
//
CONST WCHAR szDisplayClassGuid[] = L"{4D36E968-E325-11CE-BFC1-08002BE10318}";

//
// Define a string for the service install section suffix.
//
#define SVCINSTALL_SECTION_SUFFIX  (TEXT(".") INFSTR_SUBKEY_SERVICES)

//
// Define the size (in characters) of a GUID string, including terminating NULL.
//
#define GUID_STRING_LEN (39)

//
// Define the string for the load order group for keyboards
//
#define SZ_KEYBOARD_LOAD_ORDER_GROUP TEXT("Keyboard Port")

//
// Define a structure for specifying what Plug&Play driver node is used to install
// a particular service.
//
typedef struct _SERVICE_NODE {

    struct _SERVICE_NODE *Next;

    WCHAR ServiceName[MAX_SERVICE_NAME_LEN];
    DWORD DriverNodeIndex;

} SERVICE_NODE, *PSERVICE_NODE;

//
// Define a structure for specifying a legacy INF that is included in a class driver list.
//
typedef struct _LEGACYINF_NODE {

    struct _LEGACYINF_NODE *Next;

    WCHAR InfFileName[MAX_PATH];

} LEGACYINF_NODE, *PLEGACYINF_NODE;

//
// Define the context structure used by the critical device co-installer
//
typedef struct _CDC_CONTEXT {

    TCHAR OldMatchingDevId[MAX_DEVICE_ID_LEN];  // previous matching device id
    TCHAR OldServiceName[MAX_SERVICE_NAME_LEN]; // previous controlling service
                                                // or empty string if none.
} CDC_CONTEXT, *PCDC_CONTEXT;

//
// Strings used in ntapm detection
//
WCHAR rgzMultiFunctionAdapter[] =
    L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";

WCHAR rgzGoodBadKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Biosinfo\\APM";
WCHAR rgzGoodBadValue[] =
    L"Attributes";

WCHAR rgzAcpiKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI\\Enum";
WCHAR rgzAcpiCount[] =
    L"Count";

WCHAR rgzApmLegalHalKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ApmLegalHal";
WCHAR rgzApmHalPresent[] =
    L"Present";

//
// Internal function prototypes.
//
DWORD
DrvTagToFrontOfGroupOrderList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

BOOL
UserBalksAtSharedDrvMsg(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,
    IN PSP_DEVINSTALL_PARAMS DeviceInstallParams
    );

VOID
CopyFixedUpDeviceId(
      OUT LPWSTR  DestinationString,
      IN  LPCWSTR SourceString,
      IN  DWORD   SourceStringLen
      );

DWORD
PnPInitializationThread(
    IN PVOID ThreadParam
    );

VOID
MigrateLegacyDisplayDevices(
    IN HDEVINFO hDevInfo
    );

DWORD
DisableService(
    IN LPTSTR       ServiceName
    );

DWORD
IsKeyboardDriver(
    IN PCWSTR       ServiceName,
    OUT PBOOL       pResult
    );

DWORD
IsOnlyKeyboardDriver(
    IN PCWSTR       ServiceName,
    OUT PBOOL       pResult
    );

DWORD
GetServiceStartType(
    IN PCWSTR       ServiceName
    );

LONG
CountDevicesControlled(
    IN LPTSTR       ServiceName
    );

DWORD
InstallNtApm(
    IN     HDEVINFO                DevInfoHandle,
    IN     BOOLEAN                 InstallDisabled
    );

DWORD
AllowInstallNtApm(
    IN     HDEVINFO         DevInfoHandle,
    IN     PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    );

#define NTAPM_NOWORK        0
#define NTAPM_INST_DISABLED 1
#define NTAPM_INST_ENABLED  2

DWORD
DecideNtApm(
    VOID
    );

#define APM_NOT_PRESENT             0
#define APM_PRESENT_BUT_NOT_USABLE  1
#define APM_ON_GOOD_LIST            2
#define APM_NEUTRAL                 3
#define APM_ON_BAD_LIST             4

BOOL
IsProductTypeApmLegal(
    VOID
    );


DWORD
IsApmPresent(
    VOID
    );

BOOL
IsAcpiMachine(
    VOID
    );

BOOL
IsApmLegalHalMachine(
    VOID
    );

HKEY
OpenCDDRegistryKey(
    IN PCTSTR DeviceId,
    IN BOOL   Create
    );


//
// Function definitions
//
BOOL
pInGUISetup(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SP_DEVINSTALL_PARAMS dip;

    ZeroMemory(&dip, sizeof(SP_DEVINSTALL_PARAMS));
    dip.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &dip)) {
        if ((dip.Flags & DI_QUIETINSTALL) ||
            (dip.FlagsEx & DI_FLAGSEX_IN_SYSTEM_SETUP)) {
            return TRUE;
        }
        else {
            return FALSE;
        }
    }
    else {
        return FALSE;
    }
}

BOOLEAN
MigrateToDevnode(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine will look for a section in the inf that describes what service's
    values to migrate up to the new device's devnode.  The section's name is
    %DecoratedInstallName%.MigrateToDevnode.  Under this section the following
    entry is looked for:

    service-name=value-name[,value-name]...

    Each of the value-nanmes are read from
    ...\CurrentControlSet\service-name\Parameters and written to the devnode

    The primary use of this function is that all of the user modified values are
    propagated during upgrade.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully migrates the values listed, it returns TRUE.

    If this function cannot successfully migrate the values, then it returns
    FALSE.

    If this function is being run on a devnode that has already been migrated,
    then it returns TRUE.

--*/
{
    HKEY                    hDestination = (HKEY) INVALID_HANDLE_VALUE,
                            hSource = (HKEY) INVALID_HANDLE_VALUE;
    SP_DRVINFO_DETAIL_DATA  didd;
    SP_DRVINFO_DATA         did;
    HINF                    hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT              infContext;
    TCHAR                   szSectionName[LINE_LEN];
    PTCHAR                  szService = NULL, szServicePath = NULL,
                            szValueNames = NULL, szCurrentName = NULL;
    DWORD                   dwSize, res, regDataType, regSize, migrated;
    BOOLEAN                 success = FALSE;
    PBYTE                   buffer = NULL;
    TCHAR                   szMigrated[] = L"Migrated";
    TCHAR                   szRegServices[]  = L"System\\CurrentControlSet\\Services\\";
    TCHAR                   szParameters[]  = L"\\Parameters";
    TCHAR                   szMigrateToDevnode[]  = L".MigrateToDevnode";

#define DEFAULT_BUFFER_SIZE 100

    if ((hDestination = SetupDiCreateDevRegKey(DeviceInfoSet,
                                               DeviceInfoData,
                                               DICS_FLAG_GLOBAL,
                                               0,
                                               DIREG_DEV,
                                               NULL,
                                               NULL)) == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    dwSize = sizeof(DWORD);
    migrated = 0;
    if (RegQueryValueEx(hDestination,
                        szMigrated,
                        0,
                        &regDataType,
                        (PBYTE) &migrated,
                        &dwSize) == ERROR_SUCCESS &&
        regDataType == REG_DWORD &&
        migrated != 0) {
        //
        // We have migrated to the devnode before (ie a previous upgrade) and
        // the user might have changed the respective values, just quit.
        //
        success = TRUE;
        goto cleanup;
    }
    else {
        migrated = TRUE;
        RegSetValueEx(hDestination,
                      szMigrated,
                      0,
                      REG_DWORD,
                      (PBYTE) &migrated,
                      sizeof(DWORD));
    }

    //
    // Retrieve information about the driver node selected for this device.
    //
    did.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &did)) {
        goto cleanup;
    }

    didd.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &did,
                                    &didd,
                                    sizeof(didd),
                                    NULL)
        && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        //
        // For some reason we couldn't get detail data--this should never happen.
        //
        goto cleanup;
    }

    //
    // Open the INF that installs this driver node, so we can 'pre-run' the AddReg
    // entries in its install section.
    //
    hInf = SetupOpenInfFile(didd.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {
        //
        // For some reason we couldn't open the INF--this should never happen.
        //
        goto cleanup;
    }

    SetupDiGetActualSectionToInstall(hInf,
                                     didd.SectionName,
                                     szSectionName,
                                     sizeof(szSectionName) / sizeof(TCHAR),
                                     NULL,
                                     NULL
                                     );

    wcscat(szSectionName, szMigrateToDevnode);
    if (!SetupFindFirstLine(hInf,
                            szSectionName,
                            NULL,
                            &infContext)) {
        goto cleanup;
    }

    dwSize = 0;
    if (SetupGetStringField(&infContext, 0, NULL, 0, &dwSize)) {
        //
        // Increment the count to hold the null and alloc.  The count returned
        // is the number of characters in the strings, NOT the number of bytes
        // needed.
        //
        dwSize++;
        szService = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));

        if (!szService ||
            !SetupGetStringField(&infContext, 0, szService, dwSize, &dwSize)) {
            goto cleanup;
        }
    }
    else {
        goto cleanup;
    }

    dwSize = wcslen(szRegServices)+wcslen(szService)+wcslen(szParameters)+1;
    dwSize *= sizeof(TCHAR);
    szServicePath = (PTCHAR) LocalAlloc(LPTR, dwSize);
    if (!szServicePath) {
        res = GetLastError();
        goto cleanup;
    }

    wcscpy(szServicePath, szRegServices);
    wcscat(szServicePath, szService);
    wcscat(szServicePath, szParameters);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szServicePath,
                     0,
                     KEY_ALL_ACCESS,
                     &hSource) != ERROR_SUCCESS) {
        goto cleanup;
    }

    dwSize = 0;
    if (SetupGetMultiSzField(&infContext, 1, NULL, 0, &dwSize)) {
        //
        // Increment the count to hold the null and alloc.  The count returned
        // is the number of characters in the strings, NOT the number of bytes
        // needed.
        //
        dwSize++;
        szValueNames = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));
        if (!szValueNames ||
            !SetupGetMultiSzField(&infContext, 1, szValueNames, dwSize, &dwSize)) {
            goto cleanup;
        }
    }
    else {
        goto cleanup;
    }

    regSize = dwSize = DEFAULT_BUFFER_SIZE;
    buffer = (PBYTE) LocalAlloc(LPTR, regSize);
    if (!buffer) {
        goto cleanup;
    }

    for (szCurrentName = szValueNames;
         *szCurrentName;
         regSize = dwSize, szCurrentName += wcslen(szCurrentName) + 1) {
getbits:
        res = RegQueryValueEx(hSource,
                              szCurrentName,
                              0,
                              &regDataType,
                              (PBYTE) buffer,
                              &regSize);
        if (res == ERROR_MORE_DATA) {
            //
            // regSize contains new buffer size, free and reallocate
            //
            dwSize = regSize;
            LocalFree(buffer);
            buffer = LocalAlloc(LPTR, dwSize);
            if (buffer) {
                goto getbits;
            }
            else {
                goto cleanup;
            }
        }
        else if (res == ERROR_SUCCESS) {
            RegSetValueEx(hDestination,
                          szCurrentName,
                          0,
                          regDataType,
                          buffer,
                          regSize);
        }
    }

    success = TRUE;

cleanup:
    //
    // Clean up and leave
    //

    if (hInf != (HKEY) INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    if (hDestination != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(hDestination);
    }
    if (hSource != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(hSource);
    }
    if (buffer) {
        LocalFree(buffer);
    }
    if (szService) {
        LocalFree(szService);
    }
    if (szServicePath) {
        LocalFree(szServicePath);
    }
    if (szValueNames) {
        LocalFree(szValueNames);
    }

    return success;
}

void
MarkDriverNodesBad(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            DriverType
    )
{
    SP_DRVINSTALL_PARAMS drvInstallParams;
    SP_DRVINFO_DATA      drvData;
    ULONG                index = 0;

    //
    // Only mark driver nodes as bad during gui setup
    //
    if (!pInGUISetup(DeviceInfoSet, DeviceInfoData)) {
        return;
    }

    if (SetupDiBuildDriverInfoList(DeviceInfoSet, DeviceInfoData, DriverType))
    {
        ZeroMemory(&drvData, sizeof(SP_DRVINFO_DATA));
        drvData.cbSize = sizeof(SP_DRVINFO_DATA);

        while (SetupDiEnumDriverInfo(DeviceInfoSet,
                                     DeviceInfoData,
                                     DriverType,
                                     index++,
                                     &drvData)) {

            if (drvData.DriverVersion == 0) {
                ZeroMemory(&drvInstallParams, sizeof(SP_DRVINSTALL_PARAMS));
                drvInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
                if (SetupDiGetDriverInstallParams(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &drvData,
                                                  &drvInstallParams))
                {
                    drvInstallParams.Flags |=  DNF_BAD_DRIVER;

                    SetupDiSetDriverInstallParams(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &drvData,
                                                  &drvInstallParams);
                }
            }

            ZeroMemory(&drvData, sizeof(SP_DRVINFO_DATA));
            drvData.cbSize = sizeof(SP_DRVINFO_DATA);
        }
    }
}

DWORD
ConfirmWHQLInputRequirements(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN LPTSTR           Services,
    IN LPCTSTR          CompatInfName,
    IN DI_FUNCTION      InstallFunction
    )
/*++

Routine Description:

    This function enforces the WHQL requirements that a 3rd party vendor or OEM
    cannot replace the ImagePath of the input drivers (mouclass.sys for instance).
    This does not stop the OEMs from disabling  our drivers and installing their
    own services though.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Services - A multi-sz of service names to check

    CompatInfName - name of the system inf to set the match to if we detect an
                    an INF that is actually trying to replace an image

    InstallFunction - The InstallFunction for which this function was called for.
        The function does different things if InstallFunction is equal to
        DIF_SELECTBESTCOMPATDRV.

Return Value:

    If this function determines that the INF in question matches the WHQL
        requirement, returns ERROR_DI_DO_DEFAULT

    If the default determines that the INF violates the requirements and we find
        a match, returns NO_ERROR

    If the default determines that the INF violates the requirements and we
        don't find a match or the InstallFunction is not select best compat drv,
        returns ERROR_DI_DONT_INSTALL.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned (via GetLastError)

--*/
{
    HINF                    hInf;
    SP_DRVINFO_DATA         drvData;
    SP_DRVINFO_DETAIL_DATA  drvDetData;
    DWORD                   dwSize;
    TCHAR                   szSection[LINE_LEN],
                            szNewService[LINE_LEN],
                            szBinary[LINE_LEN],
                            szServiceInstallSection[LINE_LEN];
    LPTSTR                  szCurrentService;
    INFCONTEXT              infContext, infContextService;
    DWORD                   ret = ERROR_DI_DO_DEFAULT;
    BOOLEAN                 badServiceEntry = FALSE;

    if (InstallFunction == DIF_SELECTBESTCOMPATDRV) {
        MarkDriverNodesBad(DeviceInfoSet, DeviceInfoData, SPDIT_COMPATDRIVER);

        if (!SetupDiSelectBestCompatDrv(DeviceInfoSet, DeviceInfoData)) {
            return GetLastError();
        }
    }

    ZeroMemory(&drvData, sizeof(SP_DRVINFO_DATA));
    drvData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &drvData)) {
        return GetLastError();
    }

    ZeroMemory(&drvDetData, sizeof(SP_DRVINFO_DETAIL_DATA));
    drvDetData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &drvData,
                                    &drvDetData,
                                    drvDetData.cbSize,
                                    &dwSize) &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        return GetLastError();
    }

    hInf = SetupOpenInfFile(drvDetData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        return ERROR_DI_DO_DEFAULT;
    }

    //
    // Get the actual section name so we can find the .Services section
    //
    if (!SetupDiGetActualSectionToInstall(hInf,
                                          drvDetData.SectionName,
                                          szSection,
                                          sizeof(szSection) / sizeof(TCHAR),
                                          NULL,
                                          NULL) &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        ret = GetLastError();
        goto Done;
    }

    lstrcat(szSection, TEXT(".Services"));
    if (SetupFindFirstLine(hInf, szSection, TEXT("AddService"), &infContext)) {
        do {
            //
            // Get the name of the service to install
            //
            dwSize = LINE_LEN;
            if (!SetupGetStringField(&infContext,
                                     1,
                                     szNewService,
                                     dwSize,
                                     &dwSize)) {
                continue;
            }
            _tcsupr(szNewService);

            for (szCurrentService = Services;
                 *szCurrentService;
                 szCurrentService += lstrlen(szCurrentService) + 1) {

                if (lstrcmp(szCurrentService, szNewService) != 0)
                    continue;

                dwSize = LINE_LEN;
                if (!SetupGetStringField(&infContext,
                                         3,
                                         szServiceInstallSection,
                                         dwSize,
                                         &dwSize)) {
                    continue;
                }

                if (!SetupFindFirstLine(hInf,
                                        szServiceInstallSection,
                                        TEXT("ServiceBinary"),
                                        &infContextService)) {
                    //
                    // If no ServiceBinary is present, the system looks for a .sys with the
                    // same name as the service so we are OK
                    //
                    continue;
                }

                //
                // Get the actual binary's image name
                //
                dwSize = LINE_LEN;
                if (!SetupGetStringField(&infContextService,
                                         1,
                                         szBinary,
                                         dwSize,
                                         &dwSize)) {
                    //
                    // couldn't get the name, assume the worst
                    //
                    badServiceEntry = TRUE;
                }
                else {
                    _tcsupr(szBinary);
                    if (_tcsstr(szBinary, szNewService) == NULL) {
                        //
                        // The service name is NOT the same as the binary's name
                        //
                        badServiceEntry = TRUE;
                    }
                }

                //
                // No need to continue searching the list, we already found our
                // match
                //
                break;
            }

            if (badServiceEntry) {
                SP_DRVINFO_DATA         drvDataAlt;
                SP_DRVINFO_DETAIL_DATA  drvDetDataAlt;
                TCHAR                   szFmt[256];
                TCHAR                   szMsgTxt[256];

                int                     i = 0;

                ret = ERROR_DI_DONT_INSTALL;

                SetupOpenLog(FALSE);

                if (InstallFunction != DIF_SELECTBESTCOMPATDRV) {
                    //
                    // We will try to pick a better one if we find new hardware,
                    // but for the update driver / manual install case,
                    // fail it!
                    //
                    LoadString(MyModuleHandle,
                               IDS_FAIL_INPUT_WHQL_REQS,
                               szFmt,
                               SIZECHARS(szFmt));
                    wsprintf(szMsgTxt, szFmt, drvDetData.InfFileName, szNewService);
                    SetupLogError(szMsgTxt, LogSevError);
                    SetupCloseLog();

                    break;
                }

                //
                // We should have a match in the system provided inf
                //
                drvDataAlt.cbSize = sizeof(SP_DRVINFO_DATA);
                while (SetupDiEnumDriverInfo(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDIT_COMPATDRIVER,
                                             i++,
                                             &drvDataAlt)) {

                    PTCHAR name;

                    drvDetDataAlt.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                                    DeviceInfoData,
                                                    &drvDataAlt,
                                                    &drvDetDataAlt,
                                                    drvDetDataAlt.cbSize,
                                                    &dwSize) &&
                        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                        //
                        // Do something here!
                        //
                        // return GetLastError();
                    }

                    //
                    // Find just the inf file name w/out the path
                    //
                    name = drvDetDataAlt.InfFileName;
                    while (*name)
                        name++;
                    while (*name != TEXT('\\') && name != drvDetDataAlt.InfFileName)
                        name--;
                    if (*name == TEXT('\\'))
                        name++;

                    if (lstrcmpi(name, CompatInfName) == 0) {
                        //
                        // Set the known good entry as the selected device
                        //
                        SetupDiSetSelectedDriver(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 &drvDataAlt);
                        ret = ERROR_SUCCESS;
                        break;
                    }
                }

                if (ret == ERROR_SUCCESS) {
                    LoadString(MyModuleHandle,
                               IDS_FAIL_INPUT_WHQL_REQS_AVERTED,
                               szFmt,
                               SIZECHARS(szFmt));
                    wsprintf(szMsgTxt, szFmt, drvDetData.InfFileName,
                             szNewService, CompatInfName);
                }
                else {
                    LoadString(MyModuleHandle,
                               IDS_FAIL_INPUT_WHQL_REQS_NO_ALT,
                               szFmt,
                               SIZECHARS(szFmt));
                    wsprintf(szMsgTxt, szFmt, drvDetData.InfFileName,
                             szNewService, CompatInfName);
                }

                SetupLogError(szMsgTxt, LogSevWarning);
                SetupCloseLog();

                break;
            }

        } while (SetupFindNextMatchLine(&infContext, TEXT("AddService"), &infContext));
    }

Done:
    SetupCloseInfFile(hInf);

    return ret;
}

#define InputClassOpenLog()   SetupOpenLog(FALSE)
#define InputClassCloseLog()  SetupCloseLog()

BOOL CDECL
InputClassLogError(
    LogSeverity Severity,
    TCHAR *MsgFormat,
    ...
    )
/*++

Outputs a message to the setup log.  Prepends "Input Install: " to the
strings and appends the correct newline chars (\r\n)

--*/
{
    int cch;
    TCHAR ach[MAX_PATH+4];    // Largest path plus extra
    va_list vArgs;
    BOOL result;

    InputClassOpenLog();

    *ach = 0;
    wsprintf(&ach[0], TEXT("Input Install: "));

    cch = lstrlen(ach);
    va_start(vArgs, MsgFormat);
    wvnsprintf(&ach[cch], MAX_PATH-cch, MsgFormat, vArgs);
    lstrcat(ach, TEXT("\r\n"));
    va_end(vArgs);

    result = SetupLogError(ach, Severity);

    InputClassCloseLog();

    return result;
}

TCHAR szPS2Driver[] = TEXT("i8042prt");

VOID
FixUpPS2Mouse(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN LPCTSTR          NewServiceName
    )
{
    HKEY                    hDevnode, hKeySystem;
    DWORD                   dwSize, dwDetect = 0, dwType,ns;
    TCHAR                   szDetect[] = TEXT("EnableWheelDetection");
    TCHAR                   szBadBios[] = TEXT("PS2_Inst.NoInterruptInit.Bioses");
    TCHAR                   szSection[] = TEXT("PS2_Inst.NoInterruptInit");
    TCHAR                   szDescSystem[] = TEXT("HARDWARE\\DESCRIPTION\\SYSTEM");
    TCHAR                   szSystemBiosVersion[] = TEXT("SystemBiosVersion");
    PTCHAR                  szBadBiosNames = NULL,
                            szCurrentBadName,
                            szBiosNames = NULL,
                            szCurrentBiosName,
                            szSystemDesc;
    SP_DRVINFO_DETAIL_DATA  didd;
    SP_DRVINFO_DATA         did;
    BOOL                    bad;
    HINF                    hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT              infContext;

    if (lstrcmpi(NewServiceName, szPS2Driver) != 0) {
        InputClassLogError(LogSevInformation, TEXT("Not a PS2 device."));
        return;
    }

    hDevnode = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DEV,
                                    KEY_ALL_ACCESS);

    if (hDevnode == INVALID_HANDLE_VALUE) {
        return;
    }

    //
    // We are forcing the wheel detection to assume wheel is present for i8042prt.
    // If we get negative feedback from this, we will remove this code, other-
    // wise this will save us the hassle of OEM wheel mice that we
    // can't detect at all.
    //
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(hDevnode,
                        szDetect,
                        NULL,
                        NULL,
                        (PBYTE) &dwDetect,
                        &dwSize) != ERROR_SUCCESS || dwDetect == 1) {
        dwDetect = 2;
        RegSetValueEx(hDevnode,
                      szDetect,
                      0,
                      REG_DWORD,
                      (PBYTE) &dwDetect,
                      sizeof(DWORD));
    }

    //
    // See if this system can't handle init via the interrupt
    //

    //
    // Get the system bios description (a multi sz)
    //
    dwSize = 0;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szDescSystem,
                     0,
                     KEY_READ,
                     &hKeySystem) != ERROR_SUCCESS ||
        RegQueryValueEx(hKeySystem,
                        szSystemBiosVersion,
                        NULL,
                        NULL,
                        NULL,
                        &dwSize) != ERROR_SUCCESS || dwSize == 0) {
        goto finished;
    }


    dwSize++;
    szBiosNames = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));
    dwType = 0;
    if (!szBiosNames ||
        RegQueryValueEx(hKeySystem,
                        szSystemBiosVersion,
                        NULL,
                        &dwType,
                        (PBYTE) szBiosNames,
                        &dwSize) != ERROR_SUCCESS || dwType != REG_MULTI_SZ) {
        goto finished;
    }

    //
    // Retrieve information about the driver node selected for this device.
    //
    did.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &did)) {
        goto finished;
    }

    didd.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &did,
                                    &didd,
                                    sizeof(didd),
                                    NULL)
        && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        //
        // For some reason we couldn't get detail data--this should never happen.
        //
        InputClassLogError(LogSevInformation, TEXT("Couldn't get driver info detail."));
        goto finished;
    }

    //
    // Open the INF that installs this driver node, so we can 'pre-run' the AddReg
    // entries in its install section.
    //
    hInf = SetupOpenInfFile(didd.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        //
        // For some reason we couldn't open the INF--this should never happen.
        //
        InputClassLogError(LogSevInformation, TEXT("Couldn't open inf."));
        goto finished;
    }

    dwSize = 0;
    if (!SetupFindFirstLine(hInf, szBadBios, NULL, &infContext) ||
        !SetupGetMultiSzField(&infContext, 1, NULL, 0, &dwSize)) {
        goto finished;
    }

    //
    // Increment the count to hold the null and alloc.  The count returned
    // is the number of characters in the strings, NOT the number of bytes
    // needed.
    //
    dwSize++;
    szBadBiosNames = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));
    if (!szBadBiosNames ||
        !SetupGetMultiSzField(&infContext, 1, szBadBiosNames, dwSize, &dwSize)) {
        goto finished;
    }

    bad = FALSE;
    for (szCurrentBadName = szBadBiosNames;
         *szCurrentBadName;
         szCurrentBadName += wcslen(szCurrentBadName) + 1) {

        _tcsupr(szCurrentBadName);

        for (szCurrentBiosName = szBiosNames;
             *szCurrentBiosName;
             szCurrentBiosName += wcslen(szCurrentBiosName) + 1) {

            if (szCurrentBadName == szBadBiosNames) {
                _tcsupr(szCurrentBiosName);
            }

            if (_tcsstr(szCurrentBiosName, szCurrentBadName)) {
                bad =
                SetupInstallFromInfSection(NULL,
                                           hInf,
                                           szSection,
                                           SPINST_REGISTRY,
                                           hDevnode,
                                           NULL,
                                           0,
                                           NULL,
                                           NULL,
                                           DeviceInfoSet,
                                           DeviceInfoData);

                break;
            }
        }

        if (bad) {
            break;
        }
    }

finished:
    if (szBiosNames) {
        LocalFree(szBiosNames);
        szBiosNames = NULL;
    }
    if (szBadBiosNames) {
        LocalFree(szBadBiosNames);
        szBadBiosNames = NULL;
    }
    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;
    }
    if (hDevnode != INVALID_HANDLE_VALUE) {
        RegCloseKey(hDevnode);
        hDevnode = INVALID_HANDLE_VALUE;
    }
    if (hKeySystem != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeySystem);
        hKeySystem = INVALID_HANDLE_VALUE;
    }
}


TCHAR szMouclassParameters[] = TEXT("System\\CurrentControlSet\\Services\\Mouclass\\Parameters");
TCHAR szNativeMouseInf[] = TEXT("msmouse.inf");
TCHAR szNativeMouseServices[] =
    TEXT("MOUCLASS\0")
    TEXT("I8042PRT\0")
    TEXT("SERMOUSE\0")
    TEXT("MOUHID\0")
    TEXT("INPORT\0")
    TEXT("\0");

typedef struct _MULTI_SZ {
    LPTSTR String;
    DWORD Size;
} MULTI_SZ, *PMULTI_SZ;

typedef struct _FILTERS {
    MULTI_SZ Lower;
    MULTI_SZ Upper;
} FILTERS, *PFILTERS;

void GetFilterInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Property,
    OUT PMULTI_SZ       MultiSz
    )
{
    BOOL res;
    DWORD gle;

    ZeroMemory(MultiSz, sizeof(MULTI_SZ));

    //
    // Will return FALSE and set the last error to insufficient buffer if
    // this property is present.
    //
    res = SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           NULL,
                                           NULL,
                                           0,
                                           &MultiSz->Size);

    if (res == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        MultiSz->Size > 0) {
        MultiSz->String = (LPTSTR) LocalAlloc(LPTR, MultiSz->Size);
        if (MultiSz->String) {
            if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  Property,
                                                  NULL,
                                                  (PBYTE) MultiSz->String,
                                                  MultiSz->Size,
                                                  NULL)) {
                LocalFree(MultiSz->String);
                MultiSz->String = NULL;
            }
            else {
                //
                // Blow away the values.  If there is failure, RestoreDeviceFilters
                // will set the values back.  If this functions fails, there is
                // not much we can do!
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 Property,
                                                 NULL,
                                                 0);
            }
        }
    }
}

void
GetDeviceFilters(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    OUT PFILTERS        Filters
    )
{
    GetFilterInfo(DeviceInfoSet, DeviceInfoData, SPDRP_LOWERFILTERS, &Filters->Lower);
    GetFilterInfo(DeviceInfoSet, DeviceInfoData, SPDRP_UPPERFILTERS, &Filters->Upper);
}

void
FreeDeviceFilters(
    OUT PFILTERS Filters
    )
{
    if (Filters->Lower.String) {
        LocalFree(Filters->Lower.String);
        ZeroMemory(&Filters->Lower, sizeof(MULTI_SZ));
    }

    if (Filters->Upper.String) {
        LocalFree(Filters->Upper.String);
        ZeroMemory(&Filters->Upper, sizeof(MULTI_SZ));
    }
}

void
RestoreDeviceFilters(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    OUT PFILTERS        Filters
    )
{
    if (Filters->Lower.String) {
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_LOWERFILTERS,
                                         (CONST PBYTE) Filters->Lower.String,
                                         Filters->Lower.Size);
    }

    if (Filters->Upper.String) {
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_UPPERFILTERS,
                                         (CONST PBYTE) Filters->Upper.String,
                                         Filters->Upper.Size);
    }

    FreeDeviceFilters(Filters);
}

#if 0
VOID
EnableMultiplePorts(TCHAR *szPath)
{
    TCHAR szConnectMultiple[] = TEXT("ConnectMultiplePorts"),
          szConnectUpgraded[] = TEXT("ConnectMultiplePortsUpgraded");
    DWORD dwConnectMultiple, dwConnectUpgraded, dwSize, dwType;
    HKEY hKey;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szPath,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey) != ERROR_SUCCESS) {
        return;
    }

    dwSize = sizeof(DWORD);
    dwConnectUpgraded = 0;

    if (RegQueryValueEx(hKey,
                        szConnectUpgraded,
                        0,
                        &dwType,
                        (PBYTE) &dwConnectUpgraded,
                        &dwSize) == ERROR_SUCCESS &&
        dwConnectUpgraded != 0) {
        //
        // We have munged with the value already, do nothing...
        //;

    }
    else {
        //
        // 1 means use the grandmaster, 0 is use the device interface (no GM)
        //
        dwConnectMultiple = 0x0;
        dwSize = sizeof(DWORD);

        if (RegSetValueEx(hKey,
                          szConnectMultiple,
                          0,
                          REG_DWORD,
                          (CONST PBYTE) &dwConnectMultiple,
                          dwSize) == ERROR_SUCCESS) {
            //
            // Mark the fact that we changed the value so we don't do it again
            // if the user manually changes it back
            //
            dwSize = sizeof(DWORD);
            dwConnectUpgraded = 1;

            RegSetValueEx(hKey,
                          szConnectUpgraded,
                          0,
                          REG_DWORD,
                          (CONST PBYTE) &dwConnectUpgraded,
                          dwSize);
        }
    }

    RegCloseKey(hKey);
}
#endif

DWORD
MouseClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for Mouse devices.  In general,
    the default behavior is all that is required for mice.  The exceptions are:

    1.  For DIF_INSTALLDEVICE, we first check to see if this driver also controls
        other devices that we should warn the user about (e.g., PS/2 mouse driver
        also controls i8042 port).  Unless the user cancels out at that point, we
        then do the default behavior of calling SetupDiInstallDevice.  Next, we
        delete the FriendlyName property, then move the GroupOrderList tag to the
        front of the list, to ensure that the driver controlling this device loads
        before any other drivers in this load order group.

    2.  For DIF_ALLOW_INSTALL, we make sure that the driver node selected by the
        user has a service install section.  If not, then we assume it's a
        Win95-only INF, and return ERROR_NON_WINDOWS_NT_DRIVER.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD Err;
    TCHAR DeviceDescription[LINE_LEN];
    DWORD DeviceDescriptionLen;
    TCHAR NewServiceName[MAX_SERVICE_NAME_LEN], OldServiceName[MAX_SERVICE_NAME_LEN];
    BOOL  IsKbdDriver, IsOnlyKbdDriver;
    ULONG DevsControlled;
    FILTERS filters;
    ULONG DevStatus, DevProblem;
    CONFIGRET Result;
    BOOLEAN bDisableService;

    switch(InstallFunction) {

        case DIF_SELECTBESTCOMPATDRV:

            //
            // First, retrieve the device install parameters to see whether or not this is a
            // silent install.  If so, then we don't prompt the user during DIF_ALLOW_INSTALL.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            DeviceInstallParams.ClassInstallReserved = (ULONG_PTR)NULL;
            if(SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
                DeviceInstallParams.ClassInstallReserved = (ULONG_PTR)DeviceInstallParams.Flags;
                SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
            }
            return ConfirmWHQLInputRequirements(DeviceInfoSet,
                                                DeviceInfoData,
                                                szNativeMouseServices,
                                                szNativeMouseInf,
                                                InstallFunction);

        case DIF_ALLOW_INSTALL :

            //
            // Check to make sure the selected driver node supports NT.
            //
            Err = ConfirmWHQLInputRequirements(DeviceInfoSet,
                                               DeviceInfoData,
                                               szNativeMouseServices,
                                               szNativeMouseInf,
                                               InstallFunction);

            if (Err == ERROR_DI_DO_DEFAULT || Err == ERROR_SUCCESS) {
                if (DriverNodeSupportsNT(DeviceInfoSet, DeviceInfoData)) {
                    Err = NO_ERROR;
                    if (UserBalksAtSharedDrvMsg(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
                        Err = ERROR_DI_DONT_INSTALL;
                    }
                }
                else {
                    Err = ERROR_NON_WINDOWS_NT_DRIVER;
                }
            }

            return Err;

        case DIF_INSTALLDEVICE :

            //
            // Retrieve and cache the name of the service that's controlling this device.
            //
            if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_SERVICE,
                                                 NULL,
                                                 (PBYTE)OldServiceName,
                                                 sizeof(OldServiceName),
                                                 NULL)) {
                //
                // We could not determine the old service - assume it is a null driver
                //
                OldServiceName[0] = (TCHAR) 0;
            }

            //
            // Retrieve the status of this device instance.
            //
            Result = CM_Get_DevNode_Status(&DevStatus,
                                           &DevProblem,
                                           DeviceInfoData->DevInst,
                                           0);

            if ((Result == CR_SUCCESS) &&
                (DevStatus & DN_HAS_PROBLEM) &&
                (DevProblem == CM_PROB_DISABLED_SERVICE)) {
                InputClassLogError(LogSevInformation, TEXT("Mouse service is disabled, so will be disabling."));
                bDisableService = TRUE;
            }
            else {
                bDisableService = FALSE;
            }

            //
            // Before we do anything, migrate the values from the services key
            // up to the devnode
            //
            MigrateToDevnode(DeviceInfoSet, DeviceInfoData);

            GetDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);

            //
            // We first want to perform the default behavior of calling
            // SetupDiInstallDevice.
            //
            if(SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData)) {


                //
                // Retrieve the name of the service which will now control the device
                //
                if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_SERVICE,
                                                     NULL,
                                                     (PBYTE)NewServiceName,
                                                     sizeof(NewServiceName),
                                                     NULL)) {
                    InputClassLogError(LogSevInformation, TEXT("Couldn't get service name."));
                    //
                    // We must have the name of this service - fail if we can't find it
                    //
                    return GetLastError();
                }

                FixUpPS2Mouse(DeviceInfoSet, DeviceInfoData, NewServiceName);

                //
                // Only consider disabling the service if it has changed and we know the old service name
                //
                if (lstrcmpi(OldServiceName, NewServiceName) && OldServiceName[0] != (TCHAR)0) {

                    if ((Err = IsKeyboardDriver(OldServiceName, &IsKbdDriver)) != NO_ERROR) {
                        InputClassLogError(LogSevInformation, TEXT("Couldn't tell if keyboard or not."));
                        RestoreDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
                        return Err;
                    }

                    if ((DevsControlled = CountDevicesControlled(OldServiceName)) != -1) {
                    // Disable the old driver service if:
                    // - it controls a keyboard, and a total of <= 2 devices (ie kbd & mouse) and it is not the
                    //   only keyboard driver
                    // - it is just a mouse driver controling one device (it the mouse) and
                    //    doesn't dynamically load

                        if (IsKbdDriver) {
                            InputClassLogError(LogSevInformation, TEXT("This is a keyboard driver."));
                            if((Err = IsOnlyKeyboardDriver(OldServiceName,&IsOnlyKbdDriver)) != NO_ERROR) {
                                InputClassLogError(LogSevInformation, TEXT("Couldn't tell if this is only keyboard."));
                                RestoreDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
                                return Err;
                            }
                            if (DevsControlled <= 2 && !IsOnlyKbdDriver) {
                                InputClassLogError(LogSevInformation, TEXT("Not the only keyboard. Disabling."));
                                DisableService(OldServiceName);
                            }
                        } else {
                            if(DevsControlled == 1 &&
                               GetServiceStartType(OldServiceName) != SERVICE_DEMAND_START) {
                                InputClassLogError(LogSevInformation, TEXT("Only controls one mouse device and not demand start."));
                                DisableService(OldServiceName);
                            }

                        }
                    }

                    //
                    // If the driver service has changed we need to move the tag for this driver to the front
                    // of its group order list.
                    //
                    DrvTagToFrontOfGroupOrderList(DeviceInfoSet, DeviceInfoData);
                }
                Err = NO_ERROR;


                //
                // We may have previously had an 'unknown' driver controlling
                // this device, with a FriendlyName generated by the user-mode
                // PnP Manager.  Delete this FriendlyName, since it's no longer
                // applicable (the DeviceDescription will be used from now on
                // in referring to this device).
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_FRIENDLYNAME, NULL, 0);

                //
                // Only disable the PS2 driver, all the other OEM driver replacements
                // will not work becuase of PNP.  This is especially true for
                // serial mice.
                //
                if (bDisableService &&
                    lstrcmpi(NewServiceName, szPS2Driver) == 0) {
                    InputClassLogError(LogSevInformation, TEXT("Disabling mouse."));
                    Err = DisableService(NewServiceName);
                }

#if 0
                //
                // We now change the value to 0 regardless if the user changed it
                // to 1 after we installed previously
                //
                EnableMultiplePorts(szMouclassParameters);
#endif

                FreeDeviceFilters(&filters);

                return NO_ERROR;

            } else {

                Err = GetLastError();
                InputClassLogError(LogSevInformation, TEXT("SetupDiInstallDevice failed with status %x."), Err);
                if(Err != ERROR_CANCELLED) {
                    //
                    // If the error was for anything other than a user cancel, then bail now.
                    //
                    return Err;
                }

                //
                // Is there a driver installed for this device?  If so, then the user started to
                // change the driver, then changed their mind.  We don't want to do anything special
                // in this case.
                //
                if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_SERVICE,
                                                    NULL,
                                                    (PBYTE)DeviceDescription,
                                                    sizeof(DeviceDescription),
                                                    NULL))
                {
                    return ERROR_CANCELLED;
                }

                //
                // The user cancelled out of the installation.  There are two scenarios where
                // this could happen:
                //
                //     1.  There really was a mouse to be installed, but the user changed their
                //         mind, didn't have the source media, etc.
                //     2.  There wasn't really a mouse.  This happens with certain modems that
                //         fool ntdetect into thinking that they're really mice.  The poor user
                //         doesn't get a chance to nip this in the bud earlier, because umpnpmgr
                //         generates an ID that yields a rank-0 match.
                //
                // Scenario (2) is particularly annoying, because the user will get the popup
                // again and again, until they finally agree to install the sermouse driver (even
                // though they don't have a serial mouse).
                //
                // To work around this problem, we special case the user-cancel scenario by going
                // ahead and installing the NULL driver for this device.  This will keep the user
                // from getting any more popups.  However, it doesn't mess up the user who cancelled
                // because of scenario (1).  That's because this device is still of class "Mouse",
                // and thus will show up in the mouse cpl.  We write out a friendly name for it that
                // has the text " (no driver)" at the end, to indicate that this device currently has
                // the NULL driver installed.  That way, if the user really experienced scenario (1),
                // they can later go to the Mouse cpl, select the no-driver device, and click the
                // "Change" button to install the correct driver for it.
                //
                SetupDiSetSelectedDriver(DeviceInfoSet, DeviceInfoData, NULL);
                SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData);
                if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_DEVICEDESC,
                                                    NULL,
                                                    (PBYTE)DeviceDescription,
                                                    sizeof(DeviceDescription),
                                                    &DeviceDescriptionLen))
                {
                    //
                    // Need length in characters, not bytes.
                    //
                    DeviceDescriptionLen /= sizeof(TCHAR);
                    //
                    // Don't count trailing NULL.
                    //
                    DeviceDescriptionLen--;

                } else {
                    //
                    // We couldn't get the device description--fall back to our default description.
                    //
                    DeviceDescriptionLen = LoadString(MyModuleHandle,
                                                      IDS_DEVNAME_UNK,
                                                      DeviceDescription,
                                                      SIZECHARS(DeviceDescription)
                                                     );
                }

                //
                // Now, append our " (no driver)" text.
                //
                LoadString(MyModuleHandle,
                           IDS_NODRIVER,
                           &(DeviceDescription[DeviceDescriptionLen]),
                           SIZECHARS(DeviceDescription) - DeviceDescriptionLen
                          );

                //
                // And, finally, set the friendly name for this device to be the description we
                // just generated.
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_FRIENDLYNAME,
                                                 (PBYTE)DeviceDescription,
                                                 (lstrlen(DeviceDescription) + 1) * sizeof(TCHAR)
                                                );

                RestoreDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);

                return ERROR_CANCELLED;
            }

       case DIF_ADDPROPERTYPAGE_ADVANCED:

            if (DeviceInfoData) {
                //
                // Retrieve the status of this device instance.
                //
                Result = CM_Get_DevNode_Status(&DevStatus,
                                               &DevProblem,
                                               DeviceInfoData->DevInst,
                                               0);

                if ((Result == CR_SUCCESS) &&
                    (DevStatus & DN_HAS_PROBLEM) &&
                    (DevProblem == CM_PROB_DISABLED_SERVICE)) {
                    //
                    // If the controlling service has been disabled, this device
                    // is most likely under the control of a legacy driver.  We
                    // should not let device manager display the standard
                    // driver, resource, or power property pages by claiming to
                    // have added them here.
                    //
                    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                    SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &DeviceInstallParams);

                    DeviceInstallParams.Flags   |= (DI_DRIVERPAGE_ADDED | DI_RESOURCEPAGE_ADDED);
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_POWERPAGE_ADDED;

                    SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &DeviceInstallParams);
                    return NO_ERROR;
                }
            }
            return ERROR_DI_DO_DEFAULT;

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}

typedef struct _VALUE_INFORMATION {
    DWORD dwSize;
    DWORD dwType;
    PVOID pData;
    PTCHAR szName;
} VALUE_INFORMATION, *PVALUE_INFORMATION;

BOOL
KeyboardClassInstallDevice(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    PVALUE_INFORMATION      values = NULL, currentValue;
    ULONG                   numValues = 0;
    HKEY                    hSource = (HKEY) INVALID_HANDLE_VALUE;
    SP_DEVINSTALL_PARAMS    dip;
    SP_DRVINFO_DETAIL_DATA  didd;
    SP_DRVINFO_DATA         did;
    HINF                    hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT              infContext;
    DWORD                   dwSize;
    TCHAR                   szSectionName[LINE_LEN];
    PTCHAR                  szService = NULL, szServicePath = NULL,
                            szValueNames = NULL, szCurrentName = NULL;
    BOOL                    success = FALSE;
    TCHAR                   szRegServices[]  = TEXT("System\\CurrentControlSet\\Services\\");
    TCHAR                   szParameters[]  = TEXT("\\Parameters");
    TCHAR                   szMaintain[]  = TEXT(".KeepValues");
    BOOL                    installedDevice = FALSE;
    FILTERS                 filters;

    //
    // Only save the values if we are in gui mode setup
    //
    if (!pInGUISetup(DeviceInfoSet, DeviceInfoData)) {
        goto cleanup;
    }

    //
    // Retrieve information about the driver node selected for this device.
    //
    did.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &did)) {
        InputClassLogError(LogSevInformation, TEXT("SetupDiGetSelectedDriver failed."));
        goto cleanup;
    }

    didd.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &did,
                                    &didd,
                                    sizeof(didd),
                                    NULL)
        && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        InputClassLogError(LogSevInformation, TEXT("Couldn't get driver details."));
        //
        // For some reason we couldn't get detail data--this should never happen.
        //
        goto cleanup;
    }

    //
    // Open the INF that installs this driver node
    //
    hInf = SetupOpenInfFile(didd.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {
        //
        // For some reason we couldn't open the INF--this should never happen.
        //
        goto cleanup;
    }

    SetupDiGetActualSectionToInstall(hInf,
                                     didd.SectionName,
                                     szSectionName,
                                     sizeof(szSectionName) / sizeof(TCHAR),
                                     NULL,
                                     NULL
                                     );

    wcscat(szSectionName, szMaintain);
    if (!SetupFindFirstLine(hInf,
                            szSectionName,
                            NULL,
                            &infContext)) {
        //
        // No such section, just install the device and return
        //
        goto cleanup;
    }

    dwSize = 0;
    if (SetupGetStringField(&infContext, 0, NULL, 0, &dwSize)) {
        //
        // Increment the count to hold the null and alloc.  The count returned
        // is the number of characters in the strings, NOT the number of bytes
        // needed.
        //
        dwSize++;
        szService = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));

        if (!szService ||
            !SetupGetStringField(&infContext, 0, szService, dwSize, &dwSize)) {
            goto cleanup;
        }
    }
    else {
        goto cleanup;
    }

    dwSize = wcslen(szRegServices)+wcslen(szService)+wcslen(szParameters)+1;
    dwSize *= sizeof(TCHAR);
    szServicePath = (PTCHAR) LocalAlloc(LPTR, dwSize);
    if (!szServicePath) {
        goto cleanup;
    }

    wcscpy(szServicePath, szRegServices);
    wcscat(szServicePath, szService);
    wcscat(szServicePath, szParameters);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szServicePath,
                     0,
                     KEY_ALL_ACCESS,
                     &hSource) != ERROR_SUCCESS) {
        goto cleanup;
    }

    dwSize = 0;
    if (SetupGetMultiSzField(&infContext, 1, NULL, 0, &dwSize)) {
        //
        // Increment the count to hold the null and alloc.  The count returned
        // is the number of characters in the strings, NOT the number of bytes
        // needed.
        //
        dwSize++;
        szValueNames = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));
        if (!szValueNames ||
            !SetupGetMultiSzField(&infContext, 1, szValueNames, dwSize, &dwSize)) {
            goto cleanup;
        }
    }
    else {
        goto cleanup;
    }

    numValues = SetupGetFieldCount(&infContext);
    values = (PVALUE_INFORMATION)
        LocalAlloc(LPTR, (numValues + 1) * sizeof(VALUE_INFORMATION));

    if (!values) {
        goto cleanup;
    }

    currentValue = values;

    for (szCurrentName = szValueNames;
         *szCurrentName;
         szCurrentName += wcslen(szCurrentName) + 1) {

        if (RegQueryValueEx(hSource,
                            szCurrentName,
                            0,
                            &currentValue->dwType,
                            (PBYTE) NULL,
                            &currentValue->dwSize) == ERROR_SUCCESS) {

            currentValue->szName = szCurrentName;

            currentValue->pData = LocalAlloc(LPTR, currentValue->dwSize);
            if (!currentValue->pData) {
                ZeroMemory(currentValue, sizeof(VALUE_INFORMATION));
                continue;
            }

            if (RegQueryValueEx(hSource,
                                currentValue->szName,
                                0,
                                &currentValue->dwType,
                                (PBYTE) currentValue->pData,
                                &currentValue->dwSize) == ERROR_SUCCESS) {
                currentValue++;
            }
            else {
                ZeroMemory(currentValue, sizeof(VALUE_INFORMATION));
            }
        }
    }

    GetDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
    installedDevice = TRUE;
    success = SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData);

    for (currentValue = values; ; currentValue++) {
        if (currentValue->pData) {
            if (success) {
                RegSetValueEx(hSource,
                              currentValue->szName,
                              0,
                              currentValue->dwType,
                              (PBYTE) currentValue->pData,
                              currentValue->dwSize);
            }
            LocalFree(currentValue->pData);
        }
        else {
            //
            // if currentValue->pData is blank, no other entries exist
            //
            break;
        }
    }

    LocalFree(values);

cleanup:
    //
    // Clean up and leave
    //
    if (hInf != (HKEY) INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    if (hSource != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(hSource);
    }
    if (szService) {
        LocalFree(szService);
    }
    if (szServicePath) {
        LocalFree(szServicePath);
    }
    if (szValueNames) {
        LocalFree(szValueNames);
    }

    if (!installedDevice) {
        GetDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
        success = SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData);
    }

    if (success) {
        FreeDeviceFilters(&filters);
    }
    else {
        RestoreDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
    }

    return success;
}

TCHAR szKbdclassParameters[] = TEXT("System\\CurrentControlSet\\Services\\Kbdclass\\Parameters");
TCHAR szNativeKeyboardInf[] = TEXT("keyboard.inf");
TCHAR szNativeKeyboardServices[] =
    TEXT("KBDCLASS\0")
    TEXT("I8042PRT\0")
    TEXT("KBDHID\0")
    TEXT("\0");

DWORD
KeyboardClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for Keyboard devices.  In general,
    the default behavior is all that is required for keyboards.  The exceptions are:

    1.  For DIF_INSTALLDEVICE, we first check to see if this driver also controls
        other devices that we should warn the user about (e.g., i8042 keyboard driver
        also controls PS/2 mouse port).  Unless the user cancels out at that point, we
        then do the default behavior of calling SetupDiInstallDevice.  Next, we
        delete the FriendlyName property, then move the GroupOrderList tag to the
        front of the list, to ensure that the driver controlling this device loads
        before any other drivers in this load order group.

    2.  For DIF_ALLOW_INSTALL, we make sure that the driver node selected by the
        user has a service install section.  If not, then we assume it's a
        Win95-only INF, and return ERROR_NON_WINDOWS_NT_DRIVER.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    TCHAR OldServiceName[MAX_SERVICE_NAME_LEN], NewServiceName[MAX_SERVICE_NAME_LEN];
    DWORD Err;
    ULONG DevStatus, DevProblem;
    CONFIGRET Result;
    BOOLEAN bDisableService;

    switch(InstallFunction) {

        case DIF_SELECTBESTCOMPATDRV:

            //
            // First, retrieve the device install parameters to see whether or not this is a
            // silent install.  If so, then we don't prompt the user during DIF_ALLOW_INSTALL.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            DeviceInstallParams.ClassInstallReserved = (ULONG_PTR)NULL;
            if(SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
                DeviceInstallParams.ClassInstallReserved = (ULONG_PTR)DeviceInstallParams.Flags;
                SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
            }
            return ConfirmWHQLInputRequirements(DeviceInfoSet,
                                                DeviceInfoData,
                                                szNativeKeyboardServices,
                                                szNativeKeyboardInf,
                                                InstallFunction);

        case DIF_ALLOW_INSTALL :

            //
            // Check to make sure the selected driver node supports NT.
            //
            Err = ConfirmWHQLInputRequirements(DeviceInfoSet,
                                               DeviceInfoData,
                                               szNativeKeyboardServices,
                                               szNativeKeyboardInf,
                                               InstallFunction);

            if (Err == ERROR_DI_DO_DEFAULT || Err == ERROR_SUCCESS) {
                if (DriverNodeSupportsNT(DeviceInfoSet, DeviceInfoData)) {
                    Err = NO_ERROR;
                    if (UserBalksAtSharedDrvMsg(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
                        Err = ERROR_DI_DONT_INSTALL;
                    }
                }
                else {
                    Err = ERROR_NON_WINDOWS_NT_DRIVER;
                }
            }

            return Err;

        case DIF_INSTALLDEVICE :

            //
            // Retrieve and cache the name of the service that's controlling this device.
            //
            if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_SERVICE,
                                                 NULL,
                                                 (PBYTE)OldServiceName,
                                                 sizeof(OldServiceName),
                                                 NULL)) {
                //
                // We could not determine the old service - assume it is a null driver
                //
                OldServiceName[0] = (TCHAR) 0;
            }

            //
            // Before we do anything, migrate the values from the services key
            // up to the devnode
            //
            MigrateToDevnode(DeviceInfoSet, DeviceInfoData);

            //
            // Retrieve the status of this device instance.
            //
            Result = CM_Get_DevNode_Status(&DevStatus,
                                           &DevProblem,
                                           DeviceInfoData->DevInst,
                                           0);

            if ((Result == CR_SUCCESS) &&
                (DevStatus & DN_HAS_PROBLEM) &&
                (DevProblem == CM_PROB_DISABLED_SERVICE)) {
                InputClassLogError(LogSevInformation, TEXT("Keyboard is disabled, so will disable."));
                bDisableService = TRUE;
            }
            else {
                bDisableService = FALSE;
            }

            //
            // Perform the default behavior of calling SetupDiInstallDevice.
            //
            if(KeyboardClassInstallDevice(DeviceInfoSet, DeviceInfoData)) {
                //
                // Retrieve the name of the service which will now control the device
                //
                if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_SERVICE,
                                                     NULL,
                                                     (PBYTE)NewServiceName,
                                                     sizeof(NewServiceName),
                                                     NULL)) {
                    return GetLastError();
                }

                //
                // Only consider disabling the service if it has changed and we know the old service name
                //
                if(lstrcmpi(OldServiceName, NewServiceName) && OldServiceName[0] != (TCHAR)0) {

                    //
                    // Disable the old service that was controlling the device
                    //
                    InputClassLogError(LogSevInformation, TEXT("Disabling old service to start new one."));
                    if((Err = DisableService(OldServiceName)) != NO_ERROR) {
                        return Err;
                    }

                    //
                    // If the driver service has changed we need to move the tag for this driver to the front
                    // of its group order list.
                    //
                    DrvTagToFrontOfGroupOrderList(DeviceInfoSet, DeviceInfoData);
                }

                Err = NO_ERROR;

                //
                // We may have previously had an 'unknown' driver controlling
                // this device, with a FriendlyName generated by the user-mode
                // PnP Manager.  Delete this FriendlyName, since it's no longer
                // applicable (the DeviceDescription will be used from now on
                // in referring to this device).
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_FRIENDLYNAME, NULL, 0);

                if (bDisableService &&
                    lstrcmpi(NewServiceName, szPS2Driver) == 0) {
                    InputClassLogError(LogSevInformation, TEXT("Disabling PS2 keyboard."));
                    Err = DisableService(NewServiceName);
                }

#if 0
                //
                // We now change the value to 0 regardless if the user changed it
                // to 1 after we installed previously
                //
                EnableMultiplePorts(szKbdclassParameters);
#endif

                return Err;
            } else {
                InputClassLogError(LogSevInformation, TEXT("KeyboardClassInstallDevice failed."));
                return GetLastError();
            }

       case DIF_ADDPROPERTYPAGE_ADVANCED:

            if (DeviceInfoData) {
                //
                // Retrieve the status of this device instance.
                //
                Result = CM_Get_DevNode_Status(&DevStatus,
                                               &DevProblem,
                                               DeviceInfoData->DevInst,
                                               0);

                if ((Result == CR_SUCCESS) &&
                    (DevStatus & DN_HAS_PROBLEM) &&
                    (DevProblem == CM_PROB_DISABLED_SERVICE)) {
                    //
                    // If the controlling service has been disabled, this device
                    // is most likely under the control of a legacy driver.  We
                    // should not let device manager display the standard
                    // driver, resource, or power property pages by claiming to
                    // have added them here.
                    //
                    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                    SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &DeviceInstallParams);

                    DeviceInstallParams.Flags   |= (DI_DRIVERPAGE_ADDED | DI_RESOURCEPAGE_ADDED);
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_POWERPAGE_ADDED;

                    SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &DeviceInstallParams);
                    return NO_ERROR;
                }
            }
            return ERROR_DI_DO_DEFAULT;

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}


DWORD
DrvTagToFrontOfGroupOrderList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

    This routine moves the tag value for the specified device's driver to the
    front of its corresponding GroupOrderList entry.

    ********** We don't do the following any more *************************
    It also marks the device's service with a PlugPlayServiceType value of
    0x2 (PlugPlayServicePeripheral), so that we won't attempt to generate a
    legacy device instance for this service in the future.
    ***********************************************************************

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device whose driver is being modified.

    DeviceInfoData - Supplies the address of a device information element whose
        driver is being modified.

Return Value:

    If the function is successful, the return value is NO_ERROR.
    If the function fails, the return value is a Win32 error code.

--*/

{
    TCHAR ServiceName[MAX_SERVICE_NAME_LEN];
    SC_HANDLE SCMHandle, ServiceHandle;
    DWORD Err;
    LPQUERY_SERVICE_CONFIG ServiceConfig;

    //
    // Retrieve the name of the service that's controlling this device.
    //
    if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_SERVICE,
                                         NULL,
                                         (PBYTE)ServiceName,
                                         sizeof(ServiceName),
                                         NULL)) {
        return GetLastError();
    }

    //
    // Now open this service, and call some private Setup API helper routines to
    // retrieve the tag, and move it to the front of the GroupOrderList.
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        return GetLastError();
    }

    if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))) {
        Err = GetLastError();
        goto clean0;
    }

    if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig)) != NO_ERROR) {
        goto clean1;
    }

    //
    // Only do this if this is a kernel or filesystem driver, and it's a member of
    // a load group (with a tag assigned).  This should always be the case for keyboard
    // and mouse drivers, but this is just to be safe.
    //
    if(ServiceConfig->lpLoadOrderGroup && *(ServiceConfig->lpLoadOrderGroup) &&
       (ServiceConfig->dwServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER))) {
        //
        // This driver meets all the criteria--it better have a tag!!!
        //
        MYASSERT(ServiceConfig->dwTagId);

        //
        // Move the tag to the front of the list.
        //
        Err = pSetupAddTagToGroupOrderListEntry(ServiceConfig->lpLoadOrderGroup,
                                          ServiceConfig->dwTagId,
                                          TRUE
                                         );
    }

    MyFree(ServiceConfig);

clean1:
    CloseServiceHandle(ServiceHandle);

clean0:
    CloseServiceHandle(SCMHandle);

    return Err;
}


BOOL
UserBalksAtSharedDrvMsg(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,
    IN PSP_DEVINSTALL_PARAMS DeviceInstallParams
    )

/*++

Routine Description:

    This routine finds out if there are any other devices affected by the impending
    device installation, and if so, warns the user about it (unless this is a quiet
    installation).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device whose driver is being modified.

    DeviceInfoData - Supplies the address of a device information element whose
        driver is being modified.

    DeviceInstallParams - Supplies the address of a device install parameters structure
        to be used in this routine.  Since callers of this routine always have this
        structure 'laying around', they provide it to this routine to be used as a
        workspace.

Return Value:

    If the user decides not to go through with it, the return value is TRUE, otherwise
    it is FALSE.

--*/

{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    BOOL b, result;
    INFCONTEXT InfContext;
    PCTSTR SectionName, AffectedComponentsString;
    PTSTR WarnMessage;

    //
    // First, retrieve the device install parameters to see whether or not this is a
    // silent install.  If so, then we don't prompt the user. We saved away these
    // params during DIF_SELECTBESTCOMPATDRV, so check this first.
    //
    DeviceInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, DeviceInstallParams)) {
        if((DeviceInstallParams->Flags & DI_QUIETINSTALL) ||
           (DeviceInstallParams->ClassInstallReserved & DI_QUIETINSTALL)) {
            InputClassLogError(LogSevInformation, TEXT("Quiet install requested."));
            return FALSE;
        }
    } else {
        //
        // Couldn't retrieve the device install params--initialize the parent window handle
        // to NULL, in case we need it later for the user prompt dialog.
        //
        DeviceInstallParams->hwndParent = NULL;
    }

    //
    // Retrieve the currently-selected driver we're about to install.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet,
                                 DeviceInfoData,
                                 &DriverInfoData)) {
        return FALSE;
    }

    //
    // Retrieve information about the INF install section for the selected driver.
    //
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                   DeviceInfoData,
                                   &DriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL)
       && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        //
        // Then we failed, and it wasn't simply because we didn't provide the extra
        // space for hardware/compatible IDs.
        //
        return FALSE;
    }

    //
    // Open the associated INF file.
    //
    if((hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                                NULL,
                                INF_STYLE_WIN4,
                                NULL)) == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Now look through the [ControlFlags] section at all 'SharedDriver' entries, to
    // see if any of them reference an install section that matches what we're about
    // to install.
    //
    for(b = SetupFindFirstLine(hInf, INFSTR_CONTROLFLAGS_SECTION, TEXT("SharedDriver"), &InfContext);
        b;
        b = SetupFindNextMatchLine(&InfContext, TEXT("SharedDriver"), &InfContext))
    {
        //
        // The format of the line is SharedDriver=<InstallSection>,<AffectedComponentsString>
        //
        if((SectionName = pSetupGetField(&InfContext, 1)) &&
           !lstrcmpi(SectionName, DriverInfoDetailData.SectionName)) {
            //
            // We found a match--now retrieve the string describing the other component(s) that
            // are affected by this installation.
            //
            if(AffectedComponentsString = pSetupGetField(&InfContext, 2)) {
                break;
            }
        }
    }

    if(!b) {
        //
        // Then we never found a match.
        //
        result = FALSE;
    }
    else {
        //
        // We need to popup a message box to the user--retrieve the parent window handle for this
        // device information element.
        //
        result = (IDNO == MessageBoxFromMessage(DeviceInstallParams->hwndParent,
                                                MSG_CONFIRM_SHAREDDRV_INSTALL,
                                                NULL,
                                                IDS_CONFIRM_DEVINSTALL,
                                                MB_ICONWARNING | MB_YESNO,
                                                AffectedComponentsString));
    }

    SetupCloseInfFile(hInf);

    return result;
}


VOID
CopyFixedUpDeviceId(
      OUT LPWSTR  DestinationString,
      IN  LPCWSTR SourceString,
      IN  DWORD   SourceStringLen
      )
/*++

Routine Description:

    This routine copies a device id, fixing it up as it does the copy.
    'Fixing up' means that the string is made upper-case, and that the
    following character ranges are turned into underscores (_):

    c <= 0x20 (' ')
    c >  0x7F
    c == 0x2C (',')

    (NOTE: This algorithm is also implemented in the Config Manager APIs,
    and must be kept in sync with that routine. To maintain device identifier
    compatibility, these routines must work the same as Win95.)

Arguments:

    DestinationString - Supplies a pointer to the destination string buffer
        where the fixed-up device id is to be copied.  This buffer must
        be large enough to hold a copy of the source string (including
        terminating NULL).

    SourceString - Supplies a pointer to the (null-terminated) source
        string to be fixed up.

    SourceStringLen - Supplies the length, in characters, of the source
        string (not including terminating NULL).

Return Value:

    None.  If an exception occurs during processing, the DestinationString will
    be empty upon return.

--*/
{
    PWCHAR p;

     try {

       CopyMemory(DestinationString,
                  SourceString,
                  (SourceStringLen + 1) * sizeof(TCHAR)
                 );

       CharUpperBuff(DestinationString, SourceStringLen);

       for(p = DestinationString; *p; p++) {

          if((*p <= TEXT(' '))  || (*p > (WCHAR)0x7F) || (*p == TEXT(','))) {

             *p = TEXT('_');
          }
       }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        *DestinationString = TEXT('\0');
    }
}


HANDLE
SpawnPnPInitialization(
    VOID
    )
/*++

Routine Description:

    This routine spawns a PnP initialization thread that runs asynchronously to the rest of
    the installation.

Arguments:

    None.

Return Value:

    If the thread was successfully created, the return value is a handle to the thread.
    If a failure occurred, the return value is NULL, and a (non-fatal) error is logged.

--*/
{
    HANDLE h;
    DWORD DontCare;

    if(!(h = CreateThread(NULL,
                          0,
                          PnPInitializationThread,
                          NULL,
                          0,
                          &DontCare))) {

        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PNPINIT_FAILED,
            GetLastError(),0,0);
    }

    return h;
}


DWORD
PnPInitializationThread(
    IN PVOID ThreadParam
    )
/*++

Routine Description:

    This routine handles the PnP operations that go on asynchronously to the rest of the
    system installation.  This thread operates silently, and the only clue the user will
    have that it's running is that their disk will be working (precompiling INFs, etc.),
    while they're interacting with the UI.

Arguments:

    ThreadParam - ignored.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

    No one cares about this thread's success or failure (yet).

--*/
{
    HINF PnPSysSetupInf;
    INFCONTEXT InfContext;
    DWORD Err = NO_ERROR;
    HDEVINFO hDevInfo;
    DWORD i, j, BufferLen;
    PWSTR DirPathEnd;
    SC_HANDLE SCMHandle, ServiceHandle;
    SERVICE_STATUS ServiceStatus;
    WCHAR CharBuffer[MAX_PATH];
    GUID ClassGuid;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DEVINSTALL_PARAMS DevInstallParams;

    UNREFERENCED_PARAMETER(ThreadParam);

    //
    // Retrieve a list of all devices of unknown class.  We will process the device information
    // elements in this list to do the migration.
    //
    if((hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVCLASS_LEGACYDRIVER,
                                       L"Root",
                                       NULL,
                                       0)) != INVALID_HANDLE_VALUE) {
        //
        // First, migrate any display devices.  (As a side effect, every device instance that
        // this routine doesn't migrate is returned with its ClassInstallReserved field set to
        // point to the corresponding service's configuration information.)
        //
        MigrateLegacyDisplayDevices(hDevInfo);

        //
        // Enumerate each device information element in the set, freeing any remaining service
        // configs.
        //
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

        for(i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &DeviceInfoData); i++) {

            if(SetupDiGetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
                //
                // A non-zero ClassInstallReserved field means we have to free the associated
                // service config.
                //
                if(DevInstallParams.ClassInstallReserved) {
                    MyFree((PVOID)(DevInstallParams.ClassInstallReserved));
                }
            }
        }

        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return Err;
}


VOID
MigrateLegacyDisplayDevices(
    IN HDEVINFO hDevInfo
    )
/*++

Routine Description:

    This routine examines each device in the supplied device information set,
    looking for elements controlled by a driver that is a member of the "Video"
    load order group.  For any such elements that it finds, it converts the
    element to be of class "Display".  If the device is not found to be of
    class "Display", then the service configuration (which we retrieved to make
    the determination), is stored away in the device install params as the
    ClassInstallReserved value.  This may be used by the caller for other
    migration purposes, although presently it is not used.  After calling this
    routine, it is the caller's responsibility to loop through all devices in
    this hDevInfo set, and free the ClassInstallReserved data (via MyFree) for
    each device that has a non-zero value.

Arguments:

    hDevInfo - Supplies a handle to the device information set containing all
        devices of class "Unknown".

Return Value:

    None.

--*/
{
    SC_HANDLE SCMHandle, ServiceHandle;
    DWORD i;
    SP_DEVINFO_DATA DevInfoData, DisplayDevInfoData;
    WCHAR ServiceName[MAX_SERVICE_NAME_LEN];
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    HDEVINFO TempDevInfoSet = INVALID_HANDLE_VALUE;
    WCHAR DevInstId[MAX_DEVICE_ID_LEN];
    SP_DEVINSTALL_PARAMS DevInstallParams;

    //
    // First, open a handle to the Service Controller.
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        //
        // If this fails, there's nothing we can do.
        //
        return;
    }

    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    for(i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &DevInfoData); i++) {
        //
        // Retrieve the name of the controlling service for this device instance.
        //
        if(!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                             &DevInfoData,
                                             SPDRP_SERVICE,
                                             NULL,
                                             (PBYTE)ServiceName,
                                             sizeof(ServiceName),
                                             NULL)) {
            //
            // No controlling service listed--just skip this element and continue
            // with the next one.
            //
            continue;
        }

        //
        // Open a handle to this service.
        //
        if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))) {
            continue;
        }

        //
        // Now retrieve the service's configuration information.
        //
        if(pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig) == NO_ERROR) {
            //
            // If this is a SERVICE_KERNEL_DRIVER that is a member of the "Video" load order
            // group, then we have ourselves a display device.
            //
            if((ServiceConfig->dwServiceType == SERVICE_KERNEL_DRIVER) &&
               ServiceConfig->lpLoadOrderGroup &&
               !lstrcmpi(ServiceConfig->lpLoadOrderGroup, L"Video")) {
                //
                // If we haven't already done so, create a new device information set without
                // an associated class, to hold our element while we munge it.
                //
                if(TempDevInfoSet == INVALID_HANDLE_VALUE) {
                    TempDevInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
                }

                if(TempDevInfoSet != INVALID_HANDLE_VALUE) {
                    //
                    // OK, we have a working space to hold this element while we change its class.
                    // Retrieve the name of this device instance.
                    //
                    if(!SetupDiGetDeviceInstanceId(hDevInfo,
                                                   &DevInfoData,
                                                   DevInstId,
                                                   SIZECHARS(DevInstId),
                                                   NULL)) {
                        *DevInstId = L'\0';
                    }

                    //
                    // Now open this element in our new, class-agnostic set.
                    //
                    DisplayDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                    if(SetupDiOpenDeviceInfo(TempDevInfoSet,
                                             DevInstId,
                                             NULL,
                                             0,
                                             &DisplayDevInfoData)) {
                        //
                        // Now set the device's ClassGUID property to the Display class GUID.  The
                        // API will take care of cleaning up the old driver keys, etc.
                        //
                        SetupDiSetDeviceRegistryProperty(TempDevInfoSet,
                                                         &DisplayDevInfoData,
                                                         SPDRP_CLASSGUID,
                                                         (PBYTE)szDisplayClassGuid,
                                                         sizeof(szDisplayClassGuid)
                                                        );
                    }
                }

                MyFree(ServiceConfig);

            } else {
                //
                // This device information element isn't a Display device.  If
                // the service isn't disabled, then store the service
                // configuration information away in the device install params,
                // for use later.
                //
                if((ServiceConfig->dwStartType != SERVICE_DISABLED) &&
                   SetupDiGetDeviceInstallParams(hDevInfo, &DevInfoData, &DevInstallParams)) {

                    DevInstallParams.ClassInstallReserved = (ULONG_PTR)ServiceConfig;
                    if(SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &DevInstallParams)) {
                        //
                        // We successfully stored a pointer to the
                        // ServiceConfig information.  Set our pointer to NULL,
                        // so we won't try to free the buffer.
                        //
                        ServiceConfig = NULL;
                    }
                }

                //
                // If we get to here, and ServiceConfig isn't NULL, then we
                // need to free it.
                //
                if(ServiceConfig) {
                    MyFree(ServiceConfig);
                }
            }
        }

        CloseServiceHandle(ServiceHandle);
    }

    CloseServiceHandle(SCMHandle);

    if(TempDevInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(TempDevInfoSet);
    }
}


BOOL
DriverNodeSupportsNT(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine determines whether the driver node selected for the specified parameters
    support Windows NT.  This determination is made based on whether or not the driver node
    has a service install section.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set

    DeviceInfoData - Optionally, supplies the address of the device information element
        within the set for which a driver node is selected.  If this parameter is not
        specified, then the driver node selected from the global class driver list will
        be used instead.

Return Value:

    If the driver node supports NT, the return value is TRUE, otherwise, it is FALSE (if
    any errors are encountered, FALSE is also returned).

--*/
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    WCHAR ActualSectionName[255];   // real max. section length as defined in ..\setupapi\inf.h
    DWORD ActualSectionNameLen;
    LONG LineCount;

    //
    // First, retrieve the selected driver node.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData)) {
        return FALSE;
    }

    //
    // Now, find out what INF it came from.
    //
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                   DeviceInfoData,
                                   &DriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL) &&
       (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        return FALSE;
    }

    //
    // Open the associated INF file.
    //
    if((hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                                NULL,
                                INF_STYLE_WIN4,
                                NULL)) == INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    //
    // Retrieve the actual name of the install section to be used for this driver node.
    //
    SetupDiGetActualSectionToInstall(hInf,
                                     DriverInfoDetailData.SectionName,
                                     ActualSectionName,
                                     SIZECHARS(ActualSectionName),
                                     &ActualSectionNameLen,
                                     NULL
                                    );

    //
    // Generate the service install section name, and see if it exists.
    //
    CopyMemory(&(ActualSectionName[ActualSectionNameLen - 1]),
               SVCINSTALL_SECTION_SUFFIX,
               sizeof(SVCINSTALL_SECTION_SUFFIX)
              );

    LineCount = SetupGetLineCount(hInf, ActualSectionName);

    SetupCloseInfFile(hInf);

    return (LineCount != -1);
}


DWORD
DisableService(
    IN LPTSTR       ServiceName
    )
/*++

Routine Description:

    This routine sets the start configuration setting of the named service to disabled

Arguments:

    ServiceName - the name of the service to disable

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    This operation will fail if the SCM database remains locked for a long period (see
    pSetupAcquireSCMLock for detail)

--*/
{
    DWORD Err = NO_ERROR;
    SC_HANDLE SCMHandle, ServiceHandle;
    SC_LOCK SCMLock;

    //
    // Open a handle to Service Control Manager
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Lock the SCM database
    //
    SetupDebugPrint1(L"LegacyDriver_OnApply: Locking ServiceDatabase for service %s", ServiceName);
    if((Err = pSetupAcquireSCMLock(SCMHandle, &SCMLock)) != NO_ERROR) {
        goto clean1;
    }

    //
    // Open a handle to this service
    //
    if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_CHANGE_CONFIG))) {
        Err = GetLastError();
        goto clean2;
    }

    //
    // Perform change service config
    //
    if(!ChangeServiceConfig(ServiceHandle,
                            SERVICE_NO_CHANGE,
                            SERVICE_DISABLED,
                            SERVICE_NO_CHANGE,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL)) {

        Err = GetLastError();
    }


    //
    // Close handle to service
    //
    CloseServiceHandle(ServiceHandle);

clean2:
    //
    // Unlock the SCM database
    //
    UnlockServiceDatabase(SCMLock);
    SetupDebugPrint1(L"LegacyDriver_OnApply: Unlocked ServiceDatabase for service %s", ServiceName);

clean1:
    //
    // Close handle to Service Control Manager
    //
    CloseServiceHandle(SCMHandle);

clean0:
    return Err;
}


DWORD
RetrieveDriversStatus(
    IN  SC_HANDLE               SCMHandle,
    OUT LPENUM_SERVICE_STATUS   *ppServices,
    OUT LPDWORD                 pServicesCount
    )
/*++

Routine Description:

    This routine allocates a buffer to hold the status information for all the driver
    services in the specified SCM database and retrieves that information into the
    buffer.  The caller is responsible for freeing the buffer.

Arguments:

    SCMHandle - supplies a handle to the service control manager

    ppServices - supplies the address of an ENUM_SERVICE_STATUS pointer that receives
    the address of the allocated buffer containing the requested information.

    pServicesCount - supplies the address of a variable that receives the number of elements
        in the returned ppServices array

  Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    The pointer whose address is contained in ppServices is guaranteed to be NULL upon
    return if any error occurred.

--*/
{

    DWORD CurrentSize = 0, BytesNeeded = 0, ResumeHandle = 0, Err = NO_ERROR;
    LPENUM_SERVICE_STATUS Buffer = NULL;

    *ppServices = NULL;
    *pServicesCount = 0;

    while(!EnumServicesStatus(SCMHandle,
                       SERVICE_DRIVER,
                       SERVICE_ACTIVE | SERVICE_INACTIVE,
                       Buffer,
                       CurrentSize,
                       &BytesNeeded,
                       pServicesCount,
                       &ResumeHandle)) {
        if((Err = GetLastError()) == ERROR_MORE_DATA) {
            //
            // Resize the buffer
            //
            if(!(Buffer = MyRealloc(Buffer, CurrentSize+BytesNeeded))) {
                //
                // Can't resize buffer - free resources and report error
                //
                if( *ppServices ) {
                    MyFree(*ppServices);
                }
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            *ppServices = Buffer;

            //
            // Advance to the new space in the buffer
            //
            Buffer += CurrentSize;
            CurrentSize += BytesNeeded;
        } else {
            //
            // An error we can't handle
            //
            if( *ppServices ) {
                MyFree(*ppServices);
            }
            return Err;
        }
    }

    return NO_ERROR;
}


DWORD
IsOnlyKeyboardDriver(
    IN PCWSTR       ServiceName,
    OUT PBOOL       pResult
    )
/*++

Routine Description:

    This routines examines all the drivers in the system and determines if the named
    driver service is the only one that controls the keyboard
Arguments:

    ServiceName - supplies the name of the driver service

    pResult - pointer to a boolean value that receives the result

Return Value:

    NO_ERROR is the routine succedes, otherwise a Win32 error code

Remarks:

    The test to determine if another keyboard driver is available is based on membership
    of the keyboard load order group.  All members of this group are assumed to be capable of
    controling the keyboard.

--*/


{

    SC_HANDLE               SCMHandle, ServiceHandle;
    LPENUM_SERVICE_STATUS   pServices = NULL;
    DWORD                   ServicesCount, Count, Err = NO_ERROR;
    LPQUERY_SERVICE_CONFIG  pServiceConfig;

    MYASSERT(pResult);

    *pResult = TRUE;

    //
    // Open a handle to Service Control Manager
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        Err = GetLastError();
        goto clean0;
    }


    //
    // Get a list of all the driver services and their stati
    //
    if((Err = RetrieveDriversStatus(SCMHandle, &pServices, &ServicesCount)) != NO_ERROR) {
        goto clean1;
    }

    MYASSERT(pServices);

    //
    // Examine the configuration of each service
    //
    for(Count=0; Count < ServicesCount; Count++) {

        //
        // Check this is not our new service
        //
        if(lstrcmpi(pServices[Count].lpServiceName, ServiceName)) {

            //
            // Open a handle to this service
            //
            if(!(ServiceHandle = OpenService(SCMHandle,
                                             pServices[Count].lpServiceName,
                                             SERVICE_QUERY_CONFIG))) {
                //
                // We can't open a service handle then record the error and continue
                //
                Err = GetLastError();
                continue;
            }

            //
            // Get this services configuration data
            //
            pServiceConfig = NULL;

            if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &pServiceConfig)) != NO_ERROR) {
                //
                // We can't get service config then free any buffer, close the service
                // handle and continue, the error has been recorded
                //
                MyFree(pServiceConfig);
                CloseServiceHandle(ServiceHandle);
                continue;
                }

            MYASSERT(pServiceConfig);

            //
            // Check if it is in the keyboard load order group and it has a start of
            // SERVICE_BOOT_START OR SERVICE_SYSTEM_START.  Do the start compare first as
            // it is less expensive
            //
            if((pServiceConfig->dwStartType == SERVICE_BOOT_START
                || pServiceConfig->dwStartType == SERVICE_SYSTEM_START)
              && !lstrcmpi(pServiceConfig->lpLoadOrderGroup, SZ_KEYBOARD_LOAD_ORDER_GROUP)) {
                *pResult = FALSE;
            }

            //
            // Release the buffer
            //
            MyFree(pServiceConfig);

            //
            // Close the service handle
            //
            CloseServiceHandle(ServiceHandle);

            //
            // If we have found another keyboard driver then break out of the loop
            //
            if(!*pResult) {
                break;
            }
        }
    }

    //
    // Deallocate the buffer allocated by RetrieveDriversStatus
    //
    MyFree(pServices);

clean1:
    //
    // Close handle to Service Control Manager
    //
    CloseServiceHandle(SCMHandle);

clean0:
    //
    // If an error occured in the loop - ie we didn't check all the services - but we did
    // find another keyboard driver in those we did check then we can ignore the error
    // otherwise we must report it
    //
    if(NO_ERROR != Err && FALSE == *pResult) {
        Err = NO_ERROR;
    }

    return Err;
}


DWORD
GetServiceStartType(
    IN PCWSTR       ServiceName
    )
/*++

Routine Description:

    This routines examines all the drivers in the system and determines if the named
    driver service is the only one that controls the keyboard
Arguments:

    ServiceName - supplies the name of the driver service

    pResult - pointer to a boolean value that receives the result

Return Value:

    NO_ERROR is the routine succedes, otherwise a Win32 error code

Remarks:

    The test to determine if another keyboard driver is available is based on membership
    of the keyboard load order group.  All members of this group are assumed to be capable of
    controling the keyboard.

--*/


{

    SC_HANDLE               SCMHandle, ServiceHandle;
    DWORD                   dwStartType = -1;
    LPQUERY_SERVICE_CONFIG  pServiceConfig;

    //
    // Open a handle to Service Control Manager
    //
    if (!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        goto clean0;
    }

    //
    // Open a handle to this service
    //
    if (!(ServiceHandle = OpenService(SCMHandle,
                                     ServiceName,
                                     SERVICE_QUERY_CONFIG))) {
        goto clean0;
    }

    //
    // Get this services configuration data
    //
    pServiceConfig = NULL;

    if (pSetupRetrieveServiceConfig(ServiceHandle, &pServiceConfig) != NO_ERROR) {
        goto clean1;
    }

    MYASSERT(pServiceConfig);

    if( !pServiceConfig ) {
        goto clean1;
    }

    //
    // store the start type, clean up, and exit
    //
    dwStartType = pServiceConfig->dwStartType;

clean1:
    if (pServiceConfig) {
        MyFree(pServiceConfig);
    }

    //
    // Close the service handle
    //
    CloseServiceHandle(ServiceHandle);

    //
    // Close handle to Service Control Manager
    //
    CloseServiceHandle(SCMHandle);

clean0:
    return dwStartType;
}

LONG
CountDevicesControlled(
    IN LPTSTR       ServiceName
    )
/*++

 Routine Description:

    This routine return the number of devices controlled by a given device service
    based on information from the configuration manager

Arguments:

    ServiceName - supplies the name of the driver service

Return Value:

    The number of devices controlled by ServiceName

Remarks:

    When an error occurs the value 0 is returned - as the only place this routine is used
    is in a test for one driver installed or not this is legitimate.  This is because the
    configuration manager returns its own errors which are cannot be returned as Win32
    error codes. A mapping of config manager to Win32 errors would resolve this.

--*/
{
    ULONG BufferSize=1024;
    LONG DeviceCount=-1;
    CONFIGRET Err;
    PTSTR pBuffer, pNext;

    //
    // Allocate a 1k buffer as a first attempt
    //
    if(!(pBuffer = MyMalloc(BufferSize))) {
        goto clean0;
    }

    while((Err = CM_Get_Device_ID_List(ServiceName,
                                       pBuffer,
                                       BufferSize,
                                       CM_GETIDLIST_FILTER_SERVICE)) != CR_SUCCESS) {
        if(Err == CR_BUFFER_SMALL) {
            //
            // Find out how large a buffer is required
            //
            if(CM_Get_Device_ID_List_Size(&BufferSize,
                                          ServiceName,
                                          CM_GETIDLIST_FILTER_SERVICE) != CR_SUCCESS) {
                //
                // We can't calculate the size of the buffer required therefore we can't complete
                //
                goto clean0;
            }
            //
            // Deallocate any old buffer
            //
            MyFree(pBuffer);

            //
            // Allocate new buffer
            //
            if(!(pBuffer = MyMalloc(BufferSize))) {
                goto clean0;
            }
        } else {
            //
            // An error we can't handle - free up resources and return
            //
            goto clean1;
        }
    }


    //
    // Traverse the buffer counting the number of strings encountered
    //

    pNext = pBuffer;
    DeviceCount = 0;

    while(*pNext != (TCHAR)0) {
        DeviceCount++;
        pNext += lstrlen(pNext)+1;
    }

clean1:

    //
    // Deallocate the buffer
    //
    MyFree(pBuffer);

clean0:

    return DeviceCount;

}


DWORD
IsKeyboardDriver(
    IN PCWSTR       ServiceName,
    OUT PBOOL       pResult
    )
/*++

Routine Description:

    This routine examines all the drivers in the system and determines if the named
    driver service is the only one that controls the keyboard.

Arguments:

    ServiceName - supplies the name of the driver service

    pResult - pointer to a boolean value that receives the result

Return Value:

    NO_ERROR is the routine succedes, otherwise a Win32 error code

Remarks:

    The test to determine if another keyboard driver is available is based on membership
    of the keyboard load order group.  All members of this group are assumed to be capable of
    controling the keyboard.

--*/
{

    SC_HANDLE               SCMHandle, ServiceHandle;
    LPENUM_SERVICE_STATUS   pServices = NULL;
    DWORD                   ServicesCount, Count, Err = NO_ERROR;
    LPQUERY_SERVICE_CONFIG  pServiceConfig;

    MYASSERT(pResult);

    //
    // Open a handle to Service Control Manager
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Open a handle to this service
    //
    if(!(ServiceHandle = OpenService(SCMHandle,
                                     ServiceName,
                                     SERVICE_QUERY_CONFIG))) {
        Err = GetLastError();
        goto clean1;
    }

    //
    // Get this services configuration data
    //
    pServiceConfig = NULL;

    if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &pServiceConfig)) != NO_ERROR) {
        goto clean2;
    }

    MYASSERT(pServiceConfig);

    if( !pServiceConfig ) {
        Err = GetLastError();
        goto clean2;
    }

    //
    // Check if it is in the keyboard load order group and it has a start of
    // SERVICE_BOOT_START OR SERVICE_SYSTEM_START.  Do the start compare first as
    // it is less expensive
    //
    *pResult = (pServiceConfig->dwStartType == SERVICE_BOOT_START
                 || pServiceConfig->dwStartType == SERVICE_SYSTEM_START)
              && !lstrcmpi(pServiceConfig->lpLoadOrderGroup, SZ_KEYBOARD_LOAD_ORDER_GROUP);

    //
    // Release the buffer
    //
    MyFree(pServiceConfig);

clean2:
    //
    // Close the service handle
    //
    CloseServiceHandle(ServiceHandle);


clean1:
    //
    // Close handle to Service Control Manager
    //
    CloseServiceHandle(SCMHandle);

clean0:

    return Err;
}

VOID
ReplaceSlashWithHash(
    IN PWSTR Str
    )
/*++

Routine Description:

   Replaces all backslash chars with hash chars so that the string can be used
   as a key name in the registry

--*/
{
    for ( ; *Str ; Str++) {
        if (*Str == L'\\') {
            *Str = L'#';
        }
    }
}


HANDLE
UtilpGetDeviceHandle(
    HDEVINFO DevInfo,
    PSP_DEVINFO_DATA DevInfoData,
    LPGUID ClassGuid,
    DWORD DesiredAccess
    )
/*++

Routine Description:

    gets a handle for a device

Arguments:

    the name of the device to open

Return Value:

    handle to the device opened, which must be later closed by the caller.

Notes:

    this function is also in storage proppage (storprop.dll)
    so please propogate fixes there as well

--*/
{
    BOOL status;
    ULONG i;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;


    SP_DEVICE_INTERFACE_DATA deviceInterfaceData;

    HDEVINFO devInfoWithInterface = NULL;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetailData = NULL;
    PTSTR deviceInstanceId = NULL;
    TCHAR * devicePath = NULL;

    ULONG deviceInterfaceDetailDataSize;
    ULONG deviceInstanceIdSize;


    //
    // get the ID for this device
    //

    for (i=deviceInstanceIdSize=0; i<2; i++) {

        if (deviceInstanceIdSize != 0) {

            deviceInstanceId =
                LocalAlloc(LPTR, deviceInstanceIdSize * sizeof(TCHAR));

            if (deviceInstanceId == NULL) {
                ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to "
                            "allocate for deviceInstanceId\n"));
                goto cleanup;
            }


        }

        status = SetupDiGetDeviceInstanceId(DevInfo,
                                            DevInfoData,
                                            deviceInstanceId,
                                            deviceInstanceIdSize,
                                            &deviceInstanceIdSize
                                            );
    }

    if (!status) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to get "
                    "Device IDs\n"));
        goto cleanup;
    }

    //
    // Get all the cdroms in the system
    //

    devInfoWithInterface = SetupDiGetClassDevs(ClassGuid,
                                               deviceInstanceId,
                                               NULL,
                                               DIGCF_DEVICEINTERFACE
                                               );

    if (devInfoWithInterface == NULL) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to get "
                    "list of CdRom's in system\n"));
        goto cleanup;
    }


    memset(&deviceInterfaceData, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
    deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    status = SetupDiEnumDeviceInterfaces(devInfoWithInterface,
                                         NULL,
                                         ClassGuid,
                                         0,
                                         &deviceInterfaceData
                                         );

    if (!status) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to get "
                    "SP_DEVICE_INTERFACE_DATA\n"));
        goto cleanup;
    }


    for (i=deviceInterfaceDetailDataSize=0; i<2; i++) {

        if (deviceInterfaceDetailDataSize != 0) {

            deviceInterfaceDetailData =
                LocalAlloc (LPTR, deviceInterfaceDetailDataSize);

            if (deviceInterfaceDetailData == NULL) {
                ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to "
                            "allocate for deviceInterfaceDetailData\n"));
                goto cleanup;
            }

            deviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        }

        status = SetupDiGetDeviceInterfaceDetail(devInfoWithInterface,
                                                 &deviceInterfaceData,
                                                 deviceInterfaceDetailData,
                                                 deviceInterfaceDetailDataSize,
                                                 &deviceInterfaceDetailDataSize,
                                                 NULL);
    }

    if (!status) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to get "
                    "DeviceInterfaceDetail\n"));
        goto cleanup;
    }

    devicePath = LocalAlloc(LPTR, deviceInterfaceDetailDataSize);
    if (devicePath == NULL) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to alloc %x "
                    "bytes for devicePath\n"));
        goto cleanup;
    }

    memcpy (devicePath,
            deviceInterfaceDetailData->DevicePath,
            deviceInterfaceDetailDataSize);

    fileHandle = CreateFile(devicePath,
                            DesiredAccess,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Final CreateFile() "
                    "failed\n"));
        goto cleanup;
    }

    ChkPrintEx(("SysSetup.GetDeviceHandle => handle %x opened\n",
                fileHandle));


cleanup:

    if (devInfoWithInterface != NULL) {
        SetupDiDestroyDeviceInfoList(devInfoWithInterface);
    }

    if (deviceInterfaceDetailData != NULL) {
        LocalFree (deviceInterfaceDetailData);
    }

    if (devicePath != NULL) {
        LocalFree (devicePath);
    }

    return fileHandle;
}


DWORD
CriticalDeviceCoInstaller(
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,  OPTIONAL
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )

/*++

Routine Description:

    This routine acts as a co-installer for critical devices.  It is presently
    registered (via hivesys.inf) for CDROM, DiskDrive, System, Scsi, Hdc, and
    Keyboard classes.

    The purpose of this co-installer is to save away the services used by these
    classes of device into the CriticalDeviceDatabase registry key.  The reason
    for this is so that we can determine what drivers should be used for new
    critical devices that are found while the system is booting, and enable
    them at that time.  This solves the problem that arises when a device that
    is critical to getting the system up and running (such as the boot device),
    is moved to a new location.  When we find a new critical device for which
    we know what service to start, we can start the device and continue to boot
    without failure.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Context - Supplies the installation context that is per-install request and
        per-coinstaller.

Return Value:

    For pre-processing, this function only cares about DIF_INSTALLDEVICE.  For
    all other DIF requests, it returns NO_ERROR.  For DIF_INSTALLDEVICE, it
    will request post-processing by returning ERROR_DI_POSTPROCESSING_REQUIRED
    (or catastrophic error such as ERROR_NOT_ENOUGH_MEMORY).

    For post-processing, this function will always propagate the install result
    passed in to it via the co-installer Context structure.

--*/

{
    HKEY   hkDrv, hkCDD;
    DWORD  matchingDeviceIdSize, serviceNameSize, classGUIDSize, lowerFiltersSize,
           upperFiltersSize, Err, disposition, driverSize;
    TCHAR  serviceName[MAX_SERVICE_NAME_LEN],
           classGUID[GUID_STRING_LEN],
           matchingDeviceId[MAX_DEVICE_ID_LEN];
    PCTSTR driverMatch = TEXT("\\Driver");
    PTSTR  lowerFilters, upperFilters;
    BOOL   foundService, foundClassGUID, foundLowerFilters, foundUpperFilters;
    PCDC_CONTEXT CDCContext;

    switch(InstallFunction) {
        //
        // We only care about DIF_INSTALLDEVICE...
        //
        case DIF_INSTALLDEVICE :

            if(Context->PostProcessing) {
                //
                // Track whether or not we've populated the critical device
                // database with the newly-installed settings.
                //
                BOOL CDDPopulated = FALSE;

                //
                // We're 'on the way out' of an installation.  We may have some
                // data squirrelled away for us while we were "on the way in".
                //
                CDCContext = (PCDC_CONTEXT)(Context->PrivateData);

                //
                // Make sure that the matchingDeviceId buffer is initialized to
                // an empty string.
                //
                *matchingDeviceId = TEXT('\0');

                //
                // Initialize our lowerFilters and upperFilters buffer pointers
                // to NULL, so we can track whether or not we've allocated
                // memory that must be freed.
                //
                upperFilters = lowerFilters = NULL;


                if (Context->InstallResult != NO_ERROR) {
                    //
                    //  If an error occurred prior to this call, abort and
                    //  propagate that error.
                    //
                    goto InstallDevPostProcExit;
                }

                //
                // Get the serviceName for this device.
                //
                foundService = SetupDiGetDeviceRegistryProperty(
                    DeviceInfoSet,
                    DeviceInfoData,
                    SPDRP_SERVICE,
                    NULL,
                    (PBYTE)serviceName,
                    sizeof(serviceName),
                    &serviceNameSize);

                if (foundService) {
                    //
                    // Make sure the service name isn't something like \Driver\PCI_HAL
                    //
                    driverSize = wcslen(driverMatch);
                    if (wcslen(serviceName) >= driverSize &&
                        _wcsnicmp(serviceName, driverMatch, driverSize) == 0) {

                        goto InstallDevPostProcExit;
                    }
                }

                foundClassGUID = SetupDiGetDeviceRegistryProperty(
                    DeviceInfoSet,
                    DeviceInfoData,
                    SPDRP_CLASSGUID,
                    NULL,
                    (PBYTE)classGUID,
                    sizeof(classGUID),
                    &classGUIDSize);

                //
                // The LowerFilters and UpperFilters properties are variable-
                // length, so we must dynamically size buffers to accommodate
                // their contents.
                //
                foundLowerFilters =
                    (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                       DeviceInfoData,
                                                       SPDRP_LOWERFILTERS,
                                                       NULL,
                                                       NULL,
                                                       0,
                                                       &lowerFiltersSize)
                     && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                     && (lowerFiltersSize > sizeof(TCHAR)));

                if(foundLowerFilters) {

                    lowerFilters = MyMalloc(lowerFiltersSize);

                    if(!lowerFilters) {
                        goto InstallDevPostProcExit;
                    }

                    if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                         DeviceInfoData,
                                                         SPDRP_LOWERFILTERS,
                                                         NULL,
                                                         (PBYTE)lowerFilters,
                                                         lowerFiltersSize,
                                                         NULL)) {
                        //
                        // This shouldn't happen--we know we have a big enough
                        // buffer.
                        //
                        goto InstallDevPostProcExit;
                    }
                }

                foundUpperFilters =
                    (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                       DeviceInfoData,
                                                       SPDRP_UPPERFILTERS,
                                                       NULL,
                                                       NULL,
                                                       0,
                                                       &upperFiltersSize)
                     && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                     && (upperFiltersSize > sizeof(TCHAR)));

                if(foundUpperFilters) {

                    upperFilters = MyMalloc(upperFiltersSize);

                    if(!upperFilters) {
                        goto InstallDevPostProcExit;
                    }

                    if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                         DeviceInfoData,
                                                         SPDRP_UPPERFILTERS,
                                                         NULL,
                                                         (PBYTE)upperFilters,
                                                         upperFiltersSize,
                                                         NULL)) {
                        //
                        // This shouldn't happen--we know we have a big enough
                        // buffer.
                        //
                        goto InstallDevPostProcExit;
                    }
                }

                //
                // Open Driver information key
                //
                if((hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 DICS_FLAG_GLOBAL,
                                                 0,
                                                 DIREG_DRV,
                                                 KEY_READ)) == INVALID_HANDLE_VALUE) {

                    goto InstallDevPostProcExit;

                } else {
                    //
                    // Get matchingDeviceId
                    //
                    matchingDeviceIdSize = sizeof(matchingDeviceId);
                    Err = RegQueryValueEx(hkDrv,
                                          REGSTR_VAL_MATCHINGDEVID,
                                          NULL,
                                          NULL,
                                          (PBYTE)matchingDeviceId,
                                          &matchingDeviceIdSize);
                    RegCloseKey(hkDrv);

                    if(Err != ERROR_SUCCESS) {
                        //
                        // Ensure that matchingDeviceId is still an empty string
                        //
                        *matchingDeviceId = TEXT('\0');
                        goto InstallDevPostProcExit;
                    }
                }

                hkCDD = OpenCDDRegistryKey(matchingDeviceId, TRUE);

                if(hkCDD != INVALID_HANDLE_VALUE) {
                    //
                    // Store all the values (service, classguid, lower and upper
                    // filters, deleting any that aren't present in the newly installed
                    // device (which might have been present from a previous install)
                    //
                    if (foundService) {
                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_SERVICE,
                                      0,
                                      REG_SZ,
                                      (PBYTE)&serviceName,
                                      serviceNameSize);
                    }
                    else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_SERVICE);
                    }

                    if (foundClassGUID) {
                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_CLASSGUID,
                                      0,
                                      REG_SZ,
                                      (PBYTE)&classGUID,
                                      classGUIDSize);
                    }
                    else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_CLASSGUID);
                    }

                    if (foundLowerFilters) {
                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_LOWERFILTERS,
                                      0,
                                      REG_MULTI_SZ,
                                      (PBYTE)lowerFilters,
                                      lowerFiltersSize);
                    }
                    else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_LOWERFILTERS);
                    }

                    if (foundUpperFilters) {
                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_UPPERFILTERS,
                                      0,
                                      REG_MULTI_SZ,
                                      (PBYTE)upperFilters,
                                      upperFiltersSize);
                    }
                    else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_UPPERFILTERS);
                    }

                    RegCloseKey(hkCDD);

                    CDDPopulated = TRUE;
                }

InstallDevPostProcExit:

                if(lowerFilters) {
                    MyFree(lowerFilters);
                }

                if(upperFilters) {
                    MyFree(upperFilters);
                }

                if(CDCContext) {
                    //
                    // If we have a private context, that means that the device
                    // was installed previously, and that it had a CDD entry.
                    // We want to restore the previous controlling service
                    // stored in this CDD entry in the following two scenarios:
                    //
                    //   1. The CDD entry for the new installation is different
                    //      than the old one.
                    //   2. We didn't end up populating the CDD entry with the
                    //      newly-installed settings (probably because the
                    //      InstallResult we were handed indicated that the
                    //      install failed.
                    //
                    if(lstrcmpi(matchingDeviceId, CDCContext->OldMatchingDevId)
                       || !CDDPopulated) {

                        hkCDD = OpenCDDRegistryKey(CDCContext->OldMatchingDevId,
                                                   FALSE
                                                  );

                        if(hkCDD != INVALID_HANDLE_VALUE) {

                            if(*(CDCContext->OldServiceName)) {
                                RegSetValueEx(hkCDD,
                                              REGSTR_VAL_SERVICE,
                                              0,
                                              REG_SZ,
                                              (PBYTE)(CDCContext->OldServiceName),
                                              (lstrlen(CDCContext->OldServiceName) + 1) * sizeof(TCHAR)
                                             );
                            } else {
                                RegDeleteValue(hkCDD, REGSTR_VAL_SERVICE);
                            }

                            RegCloseKey(hkCDD);
                        }
                    }

                    MyFree(CDCContext);
                }

                //
                // Regardless of success or failure, we always want to propagate
                // the existing install result.  In other words, any failure we
                // encounter in post-processing isn't considered critical.
                //
                return Context->InstallResult;

            } else {
                //
                // We're "on the way in".  We need to check and see if this
                // device already has a critical device database entry
                // associated with it.  If so, then we want to remember the
                // controlling service currently listed in the CDD (in case we
                // need to restore it in post-processing if the install fails).
                // We then clear this entry out of the CDD, so that, if a null
                // driver install is taking place, that we won't try to re-apply
                // the now-bogus CDD entry.  This can get us into a nasty
                // infinite loop in GUI setup where we keep finding the device
                // because it's marked as finish-install, yet every time we
                // install it, the (bogus) CDD entry gets re-applied, and the
                // devnode gets marked yet again with finish-install.
                //
                // NTRAID #59238 1999/09/01 lonnym
                // This fix is reliant upon the current
                // (somewhat broken) behavior of the kernel-mode PnP manager's
                // IopProcessCriticalDeviceRoutine.  That routine will skip any
                // CDD entries it finds that don't specify a controlling
                // service.  For NT5.1, we should remove this co-installer hack
                // and fix the kernel-mode CDD functionality so that it is only
                // applied when the devnode has a problem of not-configured (as
                // opposed to its present behavior of attempting CDD
                // application whenever there's no controlling service).
                //

                //
                // First, open driver key to retrieve the current (i.e., pre-
                // update) matching device ID.
                //
                if((hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 DICS_FLAG_GLOBAL,
                                                 0,
                                                 DIREG_DRV,
                                                 KEY_READ)) == INVALID_HANDLE_VALUE) {
                    //
                    // No need to allocate a private data structure to hand off
                    // to post-processing.
                    //
                    return ERROR_DI_POSTPROCESSING_REQUIRED;

                } else {
                    //
                    // Get matchingDeviceId
                    //
                    matchingDeviceIdSize = sizeof(matchingDeviceId);
                    Err = RegQueryValueEx(hkDrv,
                                          REGSTR_VAL_MATCHINGDEVID,
                                          NULL,
                                          NULL,
                                          (PBYTE)matchingDeviceId,
                                          &matchingDeviceIdSize);
                    RegCloseKey(hkDrv);

                    if (Err != ERROR_SUCCESS) {
                        //
                        // In this case as well, we've no need for private data
                        // during post-processing
                        //
                        return ERROR_DI_POSTPROCESSING_REQUIRED;
                    }
                }

                //
                // If we get to here, then we've retrieved a "MatchingDeviceId"
                // string from the device's driver key.  Now let's see if there
                // is a critical device entry for this ID...
                //
                hkCDD = OpenCDDRegistryKey(matchingDeviceId, FALSE);

                if(hkCDD == INVALID_HANDLE_VALUE) {
                    //
                    // No existing CDD entry for this device, hence no need for
                    // private data to be passed off to post-processing.
                    //
                    return ERROR_DI_POSTPROCESSING_REQUIRED;
                }

                //
                // If we get to here, we know that the device has been
                // previously installed, and that there exists a CDD entry for
                // that installation.  We need to allocate a private data
                // context structure to hand off to post-processing that
                // contains (a) the currently in-effect matching device id, and
                // (b) the currently in-effect controlling service (if any).
                //
                CDCContext = MyMalloc(sizeof(CDC_CONTEXT));
                if(!CDCContext) {
                    //
                    // Can't allocate memory for our structure!
                    //
                    RegCloseKey(hkCDD);

                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                lstrcpy(CDCContext->OldMatchingDevId, matchingDeviceId);

                serviceNameSize = sizeof(CDCContext->OldServiceName);
                Err = RegQueryValueEx(hkCDD,
                                      REGSTR_VAL_SERVICE,
                                      NULL,
                                      NULL,
                                      (PBYTE)(CDCContext->OldServiceName),
                                      &serviceNameSize
                                     );

                if(Err == ERROR_SUCCESS) {
                    //
                    // Successfully retrieved the controlling service name--now
                    // delete the value entry.
                    //
                    RegDeleteValue(hkCDD, REGSTR_VAL_SERVICE);

                } else {
                    //
                    // Couldn't retrieve controlling service name (most likely
                    // because there is none).  Set OldServiceName to empty
                    // string.
                    //
                    *(CDCContext->OldServiceName) = TEXT('\0');
                }

                RegCloseKey(hkCDD);

                Context->PrivateData = CDCContext;

                return ERROR_DI_POSTPROCESSING_REQUIRED;
            }

        default :
            //
            // We should always be 'on the way in', since we never request
            // postprocessing except for DIF_INSTALLDEVICE.
            //
            MYASSERT(!Context->PostProcessing);
            return NO_ERROR;
    }
}


HKEY
OpenCDDRegistryKey(
    IN PCTSTR DeviceId,
    IN BOOL   Create
    )
/*++

Routine Description:

    This routine opens (and optionally, creates if necessary) a critical device
    registry key entry for a specified device ID.

Arguments:

    DeviceId - supplies the device ID identifying the desired critical device
        database entry (registry key)

    Create - if non-zero, the registry key will be created if it doesn't
        already exist.

Return Value:

    If successful, the return value is a handle to the requested registry key.
    If failure, the return value is INVALID_HANDLE_VALUE.

--*/
{
    TCHAR MungedDeviceId[MAX_DEVICE_ID_LEN];
    HKEY hkParent, hkRet;

    //
    // Open or create for read/write access to key under
    // HKLM\System\CurrentControlSet\Control\CriticalDeviceDatabase
    //
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       REGSTR_PATH_CRITICALDEVICEDATABASE,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE,
                       NULL,
                       &hkParent,
                       NULL) != ERROR_SUCCESS) {
        return INVALID_HANDLE_VALUE;
    }

    //
    // Make a copy of the caller-supplied device ID so we can munge it.
    //
    lstrcpy(MungedDeviceId, DeviceId);

    ReplaceSlashWithHash(MungedDeviceId);

    if(Create) {
        if(RegCreateKeyEx(hkParent,
                          MungedDeviceId,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &hkRet,
                          NULL) != ERROR_SUCCESS) {

            hkRet = INVALID_HANDLE_VALUE;
        }
    } else {
        if(RegOpenKeyEx(hkParent,
                        MungedDeviceId,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkRet) != ERROR_SUCCESS) {

            hkRet = INVALID_HANDLE_VALUE;
        }
    }

    RegCloseKey(hkParent);

    return hkRet;
}

DWORD
NtApmClassInstaller(
    IN DI_FUNCTION      DiFunction,
    IN HDEVINFO         DevInfoHandle,
    IN PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    )
/*++

Routine Description:

NOTE:   When does Susan's clean up code run?  When does the win0x
        migration code run?  Do we need to call off to either of
        them in here?

NOTE:   Be sure that this works at initial install AND when the
        user does detect new hardare.

    This is the class installer for nt apm support.

    This routine installs, or thwarts installation, of the NT5 apm solution,
    depending on whether the machine is an APCI machine, is an APM machine,
    and has a good, bad, or unknown apm bios.

    This version is copied directly from the battery class driver.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    DWORD                   status, worktype;
    BOOLEAN                 InstallDisabled;


    ChkPrintEx(("syssetup: NtApmClassInstaller:"));
    ChkPrintEx(("DiFunction %08lx\n", DiFunction));

    //
    // Dispatch the InstallFunction
    //
    InstallDisabled = FALSE;

    switch (DiFunction) {
        ChkPrintEx(("syssetup: NtApmClassInstaller: DiFunction = %08lx\n",
                    DiFunction));
        case DIF_FIRSTTIMESETUP:
        case DIF_DETECT:

            worktype = DecideNtApm();

            //
            // NOTE:    We assume that if we say "do default" and we
            //          have not created a device info structure for
            //          ntapm, the installer will do *nothing*.
            //
            if (worktype == NTAPM_NOWORK) {
                ChkPrintEx(("syssetup: NtApmClassInstaller returning ERROR_DI_DO_DEFAULT"));
                return ERROR_DI_DO_DEFAULT;
            }

            if (worktype == NTAPM_INST_DISABLED) {
                InstallDisabled = TRUE;
            }

            ChkPrintEx(("syssetup: NtApmClassInstaller: calling InstallNtApm\n"));
            status = InstallNtApm(DevInfoHandle, InstallDisabled);
            ChkPrintEx(("syssetup: NtApmClassInstaller: InstallNtApm returned "
                        "%08lx\n", status));

            if (status == ERROR_SUCCESS) {
                //
                // Let the default device installer actually install ntapm.
                //
                status = ERROR_DI_DO_DEFAULT;
            }
            break;

        case DIF_ALLOW_INSTALL:

            //
            // NOTE:    If we are here, it means that either DIF_FIRSTIMESETUP
            //          has installed apm (either enabled or disabled) OR
            //          this is an upgrad of a machine where it was installed
            //          in the past.  So all we want to do is make sure
            //          that if apm is currently disabled, it stays disabled.
            //

            ChkPrintEx(("syssetup: NtApmClassIntaller: DIF_ALLOW_INSTALL\n"));

            return AllowInstallNtApm(DevInfoHandle, DevInfoData);
            break;


        case DIF_TROUBLESHOOTER:
            ChkPrintEx(("syssetup: NtApmClassInstaller: DIF_TROUBLESHOOTER\n"));
            return NO_ERROR;
            break;

        default:
            //
            // NOTE: We assume that if we say "do default" and we
            //       have not created a device info structure for ntapm,
            //       the installer will do *nothing*.
            //
            ChkPrintEx(("syssetup: NtApmClassInstaller: default:\n"));
            status = ERROR_DI_DO_DEFAULT;
            break;
    }
    ChkPrintEx(("syssetup: NtApmClassInstaller returning %08lx\n", status));
    return status;
}

DWORD
DecideNtApm(
    VOID
    )
/*++

Routine Description:

    This function decides if NtApm should be installed on the machine,
    and if it should, whether it should be installed enabled or disabled.

    This little bit of code is isolated here to make it easy to change
    policies.

Arguments:

Return Value:

    NTAPM_NOWORK - ACPI machine or no usable APM  - do nothing

    NTAPM_INST_DISABLED - APM machine, on neutral list, install disabled

    NTAPM_INST_ENABLED - APM machine, on validated good list, install enabled

--*/
{
    DWORD   BiosType;


    //
    // NOTE: The following two tests are somewhat redundent.
    //       (In theory, you cannot be ApmLegalHal AND Acpi
    //       at the same time.)  But, this belt and suspenders
    //       approach is very cheap, and will insure we do the
    //       right thing in certain upgrade and reinstall scenarios.
    //       So we leave both in.
    //

    ChkPrintEx(("syssetup: DecideNtApm: entered\n"));

    if ( ! IsProductTypeApmLegal()) {
        // it's not a workstation, so do nothing.
        return NTAPM_NOWORK;
    }

    if (IsAcpiMachine()) {

        //
        // It's an ACPI machine, so do nothing
        //
        ChkPrintEx(("syssetup: DecideNtApm: acpi box, return NTAPM_NOWORK\n"));
        return NTAPM_NOWORK;

    }

    if (IsApmLegalHalMachine() == FALSE) {

        //
        // It's NOT a standard Hal machine as required
        // by ntapm, so do nothing.
        //
        ChkPrintEx(("syssetup: DecideNtApm: not apm legal, return NTAPM_NOWORK\n"));
        return NTAPM_NOWORK;

    }


    BiosType = IsApmPresent();

    if (BiosType == APM_ON_GOOD_LIST) {

        ChkPrintEx(("syssetup: DecideNtApm: return NTAPM_INST_ENABLED\n"));
        return NTAPM_INST_ENABLED;

    } else if (BiosType == APM_NEUTRAL) {

        ChkPrintEx(("syssetup: DecideNtApm: return NTAPM_INST_DISABLED\n"));
        return NTAPM_INST_DISABLED;

    } else {

        ChkPrintEx(("syssetup: DecideNtApm: return NTAPM_NOWORK\n"));
        return NTAPM_NOWORK;

    }
}


DWORD
InstallNtApm(
    IN     HDEVINFO                DevInfoHandle,
    IN     BOOLEAN                 InstallDisabled
    )
/*++

Routine Description:

    This function installs the composite battery if it hasn't already been
    installed.

Arguments:

    DevInfoHandle       - Handle to a device information set

    InstallDisabled     - TRUE if caller wants us to install disabled

Return Value:

--*/
{
    DWORD                   status;
    SP_DRVINFO_DATA         driverInfoData;
    TCHAR                   tmpBuffer[100];
    DWORD                   bufferLen;
    PSP_DEVINFO_DATA        DevInfoData;
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    ChkPrintEx(("syssetup: InstallNtApm: DevInfoHandle = %08lx   installdisabled = %08lx\n", DevInfoHandle, InstallDisabled));
    DevInfoData = LocalAlloc(LPTR, sizeof(SP_DEVINFO_DATA));
    if ( ! DevInfoData) {
        status = GetLastError();
        goto clean0;
    }
    DevInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    //
    // Attempt to manufacture a new device information element for the root enumerated
    // ntapm device.
    //

    if(!SetupDiCreateDeviceInfo(DevInfoHandle,
                                TEXT("ROOT\\NTAPM\\0000"),
                                (LPGUID)&GUID_DEVCLASS_APMSUPPORT,
                                TEXT("NT Apm Legacy Support"),
                                NULL,
                                0,
                                DevInfoData))
    {
        status = GetLastError();

        if (status == ERROR_DEVINST_ALREADY_EXISTS) {
            //
            // NtApm is already installed.
            //
            ChkPrintEx(("ntapm Already Installed\n"));
            status = ERROR_SUCCESS;
            goto clean1;
        } else {
            ChkPrintEx(("Error creating ntapm devinfo - %x\n", status));
            goto clean1;
        }
    }

    //
    // Set device to Install Disabled if the caller wants that
    //
    if (InstallDisabled) {

        if (!SetupDiGetDeviceInstallParams(DevInfoHandle, DevInfoData, &DevInstallParams)) {
            status = GetLastError();
            goto clean1;
        }
        DevInstallParams.Flags |= DI_INSTALLDISABLED;
        if (!SetupDiSetDeviceInstallParams(DevInfoHandle, DevInfoData, &DevInstallParams)) {
            status = GetLastError();
            goto clean1;
       }
    }


    //
    // Register the device so it is not a phantom anymore
    //
    if (!SetupDiRegisterDeviceInfo(DevInfoHandle, DevInfoData, 0, NULL, NULL, NULL)) {
        status = GetLastError();
        SetupDebugPrint1(L"Couldn't register device - %x\n", status);
        goto clean3;
    }


    //
    // Set the hardware ID.  "NTAPM"
    //
    memset (tmpBuffer, 0, sizeof(tmpBuffer));
    lstrcpy (tmpBuffer, TEXT("NTAPM"));

    bufferLen = (lstrlen(tmpBuffer) + 1) * sizeof(TCHAR);
    //SetupDebugPrint2(L"tmpBuffer - %ws\n with strlen = %x\n", tmpBuffer, bufferLen);
    //SetupDebugPrint1(L"tmpBuffer@ = %08lx\n", tmpBuffer);

    status = SetupDiSetDeviceRegistryProperty (
                        DevInfoHandle,
                        DevInfoData,
                        SPDRP_HARDWAREID,
                        (PBYTE)tmpBuffer,
                        bufferLen
                        );

    if (!status) {
        status = GetLastError();
        //SetupDebugPrint1(L"Couldn't set the HardwareID - %x\n", status);
        goto clean3;
    }


    //
    // Build a compatible driver list for this new device...
    //

    if(!SetupDiBuildDriverInfoList(DevInfoHandle, DevInfoData, SPDIT_COMPATDRIVER)) {
        status = GetLastError();
        //SetupDebugPrint1(L"Couldn't build class driver list - %x\n", status);
        goto clean3;
    }


    //
    // Select the first driver in the list as this will be the most compatible
    //

    driverInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
    if (!SetupDiEnumDriverInfo(DevInfoHandle, DevInfoData, SPDIT_COMPATDRIVER, 0, &driverInfoData)) {
        status = GetLastError();
        //SetupDebugPrint1(L"Couldn't get driver list - %x\n", status);
        goto clean3;

    } else {


        //SetupDebugPrint4(L"Driver info - \n"
        //       L"------------- DriverType     %x\n"
        //       L"------------- Description    %s\n"
        //       L"------------- MfgName        %s\n"
        //       L"------------- ProviderName   %s\n\n",
        //       driverInfoData.DriverType,
        //       driverInfoData.Description,
        //       driverInfoData.MfgName,
        //       driverInfoData.ProviderName);
        if (!SetupDiSetSelectedDriver(DevInfoHandle, DevInfoData, &driverInfoData)) {
            status = GetLastError();
            //SetupDebugPrint1(L"Couldn't select driver - %x\n", status);
            goto clean3;
        }
    }



    if (!SetupDiInstallDevice (DevInfoHandle, DevInfoData)) {
        status = GetLastError();
        //SetupDebugPrint1(L"Couldn't install device - %x\n", status);
        goto clean3;
    }


    //
    // If we got here we were successful
    //

    status = ERROR_SUCCESS;
    SetLastError (status);
    goto clean1;


clean3:
    SetupDiDeleteDeviceInfo (DevInfoHandle, DevInfoData);

clean1:
    LocalFree (DevInfoData);

clean0:
   return status;

}


DWORD
AllowInstallNtApm(
    IN     HDEVINFO         DevInfoHandle,
    IN     PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    )
/*++

Routine Description:

    This function decides whether to allow install (which will do
    an enabled install at least in the upgrade case) or force
    an install disbled.

Arguments:

    DevInfoHandle       - Handle to a device information set

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.
        N.B. If this is null, we have a problem.

Return Value:

    status.

--*/
{
    ULONG   DevStatus;
    ULONG   DevProblem;
    SP_DEVINSTALL_PARAMS DevInstallParams = {0};

    CONFIGRET   Result;

    ChkPrintEx(("syssetup: AllowInstallNtApm: entered\n"));

    if ( ! IsProductTypeApmLegal()) {
        // it's not a workstation, so disallow install
        ChkPrintEx(("syssetup: AllowInstallNtApm #0: not a work station => return ERROR_DI_DONT_INSTALL\n"));
        return ERROR_DI_DONT_INSTALL;
    }

    if (! DevInfoData) {
        //
        // If DevInfoData is null, we don't actually know
        // what is going on, so say "OK" and hope for the best
        //
        ChkPrintEx(("sysetup: AllowInstallNtApm #1: no DevInfoData => return ERROR_DI_DO_DEFAULT\n"));
        return ERROR_DI_DO_DEFAULT;
    }

    //
    // Call the CM and ask it what it knows about this devinst
    //
    Result = CM_Get_DevNode_Status(&DevStatus, &DevProblem, DevInfoData->DevInst, 0);
    ChkPrintEx(("syssetup: AllowInstallNtApm #2: DevStatus = %08lx\n", DevStatus));
    ChkPrintEx(("syssetup: AllowInstallNtApm #3: DevProblem = %08lx\n", DevProblem));
    if (Result != CR_SUCCESS) {
        ChkPrintEx(("syssetup: AllowInstallNtApm #4: return ERROR_DI_DONT_INSTALL\n"));
        return ERROR_DI_DONT_INSTALL;
    }

    if (DevStatus & DN_HAS_PROBLEM) {
        if (DevProblem == CM_PROB_DISABLED) {

            //
            // it's supposed to be disabled
            //

            DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (!SetupDiGetDeviceInstallParams(DevInfoHandle, DevInfoData, &DevInstallParams)) {
                ChkPrintEx(("syssetup: AllowInstallNtApm #5: return ERROR_DI_DONT_INSTALL\n"));
                return ERROR_DI_DONT_INSTALL;
            }
            DevInstallParams.Flags |= DI_INSTALLDISABLED;
            if (!SetupDiSetDeviceInstallParams(DevInfoHandle, DevInfoData, &DevInstallParams)) {
                ChkPrintEx(("syssetup: AllowInstallNtApm #6: return ERROR_DI_DONT_INSTALL\n"));
                return ERROR_DI_DONT_INSTALL;
            }
        }
    }
    ChkPrintEx(("syssetup: AllowInstallNtApm #7: return ERROR_DI_DO_DEFAULT\n"));
    return ERROR_DI_DO_DEFAULT;
}


BOOL
IsProductTypeApmLegal()
/*++

Routine Description:

    Determines if we are running on workstation (win2000 pro) or not.
    If we are, return TRUE. else return FALSE.
    This is used to overcome weirdness in setup AND to prevent people from
    getting themselves into trouble by allowing apm to run on a server.

Return Value:

    TRUE - it's workstation, it's OK to run APM

    FALSE - it's server, DON'T let APM run

--*/
{
    OSVERSIONINFOEX OsVersionInfo;

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);

    if (!GetVersionEx((OSVERSIONINFO *) &OsVersionInfo)) {
        ChkPrintEx(("GetVersionEx failed, return server (FALSE)\n"));
        return FALSE;
    }

    if  (OsVersionInfo.wProductType == VER_NT_WORKSTATION) {
        return TRUE;
    }
    return FALSE;
}


//
// Ideally these would be defined in a header file somewhere,
// but that's hard to do becuase they are set up in an INF.
// SO - simply be sure that they match up with these lines in
// biosinfo.inf:
//
// For KNOWN_BAD:
// [DisableApmAddReg]
// HKLM,System\CurrentControlSet\Control\Biosinfo\APM,Attributes,0x00010001,00000002
//
// For KNOWN_GOOD:
// [AutoEnableApmAddReg]
// HKLM,System\CurrentControlSet\Control\Biosinfo\APM,Attributes,0x00010001,00000001
//
#define APM_BIOS_KNOWN_GOOD 0x00000001
#define APM_BIOS_KNOWN_BAD  0x00000002

DWORD
IsApmPresent()
/*++

Routine Description:

    IsApmPresent runs the same code as ntapm.sys does to decide
    if ntdetect has found and reported a usable APM bios.

    It then checks to see what, if any, bios lists this machine
    and bios are one.

    It factors this data together to report the existence/non-existence
    of apm on the machine, and its usability and suitability.

Return Value:

    APM_NOT_PRESENT - apm does not appear to be present on this machine

    APM_PRESENT_BUT_NOT_USABLE - there appears to be an apm bios, but
        it did not allow connection correctly (version or api support problem)

    APM_ON_GOOD_LIST - there is a bios and it's on the good bios list

    APM_NEUTRAL - there is a bios, it appears to be usable,
        it is not on the good bios list, but it's also not
        on the bad bios list.

    APM_ON_BAD_LIST - there is a bios, but it's on the bad bios list.

--*/
{
    //
    // first part of this code is copied from ...\ntos\dd\ntapm\i386\apm.c
    // keep it in sync with that code
    //
    UNICODE_STRING unicodeString, ConfigName, IdentName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hMFunc, hBus, hGoodBad;
    NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR Desc;
    PKEY_VALUE_FULL_INFORMATION ValueInfo;
    PKEY_VALUE_PARTIAL_INFORMATION pvpi;
    PAPM_REGISTRY_INFO ApmEntry;
    UCHAR buffer [sizeof(APM_REGISTRY_INFO) + 99];
    WCHAR wstr[8];
    ULONG i, j, Count, junk;
    PWSTR p;
    USHORT  volatile    Offset;
    PULONG  pdw;
    DWORD   BiosType;



    // ----------------------------------------------------------------------
    //
    // First Part - See if ntdetect.com found APM....
    //
    // ----------------------------------------------------------------------

    //
    // Look in the registery for the "APM bus" data
    //

    RtlInitUnicodeString(&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );


    status = NtOpenKey(&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return APM_NOT_PRESENT;
    }

    unicodeString.Buffer = wstr;
    unicodeString.MaximumLength = sizeof (wstr);

    RtlInitUnicodeString(&ConfigName, rgzConfigurationData);
    RtlInitUnicodeString(&IdentName, rgzIdentifier);

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;

    for (i=0; TRUE; i++) {
        RtlIntegerToUnicodeString(i, 10, &unicodeString);
        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL
            );

        status = NtOpenKey(&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            NtClose(hMFunc);
            return APM_NOT_PRESENT;
        }

        //
        // Check the Indentifier to see if this is a APM entry
        //

        status = NtQueryValueKey (
                    hBus,
                    &IdentName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        if (!NT_SUCCESS (status)) {
            NtClose(hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) ValueInfo + ValueInfo->DataOffset);
        if (p[0] != L'A' || p[1] != L'P' || p[2] != L'M' || p[3] != 0) {
            NtClose (hBus);
            continue;
        }

        status = NtQueryValueKey(
                    hBus,
                    &ConfigName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        NtClose(hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        Desc  = (PCM_FULL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      ValueInfo + ValueInfo->DataOffset);
        PDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      Desc->PartialResourceList.PartialDescriptors);

        if (PDesc->Type == CmResourceTypeDeviceSpecific) {
            // got it..
            ApmEntry = (PAPM_REGISTRY_INFO) (PDesc+1);
            break;
        }
    }
    NtClose(hMFunc);

    if ( (ApmEntry->Signature[0] != 'A') ||
         (ApmEntry->Signature[1] != 'P') ||
         (ApmEntry->Signature[2] != 'M') )
    {
        return APM_NOT_PRESENT;
    }

    if (ApmEntry->Valid != 1) {
        return APM_PRESENT_BUT_NOT_USABLE;
    }

    // --------------------------------------------------------------------
    //
    // Second Part - what sort of APM bios is it?
    //
    // --------------------------------------------------------------------

    //
    // If we get this far, then we think there is an APM bios present
    // on the machine, and ntdetect thinks it's usable.
    // This means we found it, and it has a version we like, and claims
    // to support the interfaces we like.
    // But we still don't know if its good, bad, or neutral.
    // Find Out.
    //

    //
    // The machine/bios good/bad list code will leave a flag in the
    // registry for us to check to see if it is a known good or known bad
    // apm bios.
    //

    RtlInitUnicodeString(&unicodeString, rgzGoodBadKey);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(&hGoodBad, KEY_READ, &objectAttributes);
    if (! NT_SUCCESS(status)) {
        return APM_NEUTRAL;
    }

    RtlInitUnicodeString(&IdentName, rgzGoodBadValue);
    pvpi = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    status = NtQueryValueKey(
                hGoodBad,
                &IdentName,
                KeyValuePartialInformation,
                pvpi,
                sizeof(buffer),
                &junk
                );

    NtClose(hGoodBad);
    if ( (NT_SUCCESS(status)) &&
         (pvpi->Type == REG_DWORD) &&
         (pvpi->DataLength == sizeof(ULONG)) )
    {
        pdw = (PULONG)&(pvpi->Data[0]);
        BiosType = *pdw;
    } else {
        return APM_NEUTRAL;
    }

    if (BiosType & APM_BIOS_KNOWN_GOOD) {
        return APM_ON_GOOD_LIST;
    } else if (BiosType & APM_BIOS_KNOWN_BAD) {
        return APM_ON_BAD_LIST;
    } else {
        return APM_NEUTRAL;
    }
}

BOOL
IsAcpiMachine(
    VOID
    )
/*++

Routine Description:

    IsAcpiMachine reports whether the OS thinks this is an ACPI
    machine or not.

Return Value:

    FALSE - this is NOT an acpi machine

    TRUE - this IS an acpi machine

--*/
{
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hKey;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION pvpi;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DWORD)+1];
    ULONG junk;
    PULONG  pdw;
    ULONG   start;


    ChkPrintEx(("syssetup: IsAcpiMachine: entered\n"));
    RtlInitUnicodeString(&unicodeString, rgzAcpiKey);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(&hKey, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        ChkPrintEx(("syssetup: IsAcpiMachine: returning FALSE, no key\n"));
        return FALSE;
    }

    RtlInitUnicodeString(&unicodeString, rgzAcpiCount);
    pvpi = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    status = NtQueryValueKey(
                hKey,
                &unicodeString,
                KeyValuePartialInformation,
                pvpi,
                sizeof(buffer),
                &junk
                );

    if ( (NT_SUCCESS(status)) &&
         (pvpi->Type == REG_DWORD) &&
         (pvpi->DataLength == sizeof(ULONG)) )
    {
        pdw = (PULONG)&(pvpi->Data[0]);
        if (*pdw) {
            NtClose(hKey);
            ChkPrintEx(("syssetup: IsAcpiMachine: returning TRUE\n"));
            return TRUE;
        }
    }

    NtClose(hKey);
    ChkPrintEx(("syssetup: IsAcpiMachine: returning FALSE, no match\n"));
    return FALSE;
}

BOOL
IsApmLegalHalMachine(
    VOID
    )
/*++

Routine Description:

    IsApmLegalHalMachine reports whether setup claims to have
    installed the standard halx86 Hal that APM requires to function.

Return Value:

    TRUE - this IS an ApmLegalHal machine, apm install may proceed.

    FALSE - this is NOT an ApmLegalHal machine, do not install APM.

--*/
{
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hKey;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION pvpi;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DWORD)+1];
    ULONG junk;
    PULONG  pdw;
    ULONG   start;


    ChkPrintEx(("syssetup: IsApmLegalHalMAchine: entered\n"));
    RtlInitUnicodeString(&unicodeString, rgzApmLegalHalKey);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(&hKey, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        ChkPrintEx(("syssetup: IsApmLegalHalMAchine: returning FALSE, no key\n"));
        return FALSE;
    }

    RtlInitUnicodeString(&unicodeString, rgzApmHalPresent);
    pvpi = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    status = NtQueryValueKey(
                hKey,
                &unicodeString,
                KeyValuePartialInformation,
                pvpi,
                sizeof(buffer),
                &junk
                );

    if ( (NT_SUCCESS(status)) &&
         (pvpi->Type == REG_DWORD) &&
         (pvpi->DataLength == sizeof(ULONG)) )
    {
        pdw = (PULONG)&(pvpi->Data[0]);
        if (*pdw == 1) {
            NtClose(hKey);
            ChkPrintEx(("syssetup: IsApmLegalHalMAchine: returning TRUE\n"));
            return TRUE;
        }
    }

    NtClose(hKey);
    ChkPrintEx(("syssetup: IsApmLegalHalMAchine: returning FALSE, no match\n"));
    return FALSE;
}

typedef
BOOL
(*PRESTART_DEVICE) (
    IN HDEVINFO             DeviceInfoSet,
    IN PSP_DEVINFO_DATA     DeviceInfoData
    );

BOOL
IsUSBController(
    IN HDEVINFO             DeviceInfoSet,
    IN PSP_DEVINFO_DATA     DeviceInfoData
    )
{
    HKEY    hKey;
    TCHAR   szController[] = TEXT("Controller");
    DWORD   dwType, dwSize;
    BYTE    data;

    hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ);

    //
    // Check for a REG_BINARY (1-byte) 'Controller' value entry set to 0.
    //
    dwSize = sizeof(data);
    if (RegQueryValueEx(hKey,
                        szController,
                        NULL,
                        &dwType,
                        &data,
                        &dwSize) != ERROR_SUCCESS ||
        dwSize != sizeof(BYTE)                    ||
        dwType != REG_BINARY) {
        data = 0;
    }

    RegCloseKey(hKey);

    return data;
}

void
DeviceBayRestartDevices(
    CONST GUID *    Guid,
    PRESTART_DEVICE RestartDevice
    )
{
    HDEVINFO                hDevInfo;
    SP_DEVINFO_DATA         did;
    SP_DEVINSTALL_PARAMS    dip;
    int                     i;

    hDevInfo = SetupDiGetClassDevs(Guid, NULL, NULL, 0);

    if (hDevInfo != INVALID_HANDLE_VALUE) {

        ZeroMemory(&did, sizeof(SP_DEVINFO_DATA));
        did.cbSize = sizeof(SP_DEVINFO_DATA);

        for (i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &did); i++) {
            if (!RestartDevice || RestartDevice(hDevInfo, &did)) {
                //
                // restart the controller so that the filter driver is in
                // place
                //
                ZeroMemory(&dip, sizeof(SP_DEVINSTALL_PARAMS));
                dip.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

                if (SetupDiGetDeviceInstallParams(hDevInfo, &did, &dip)) {
                    dip.Flags |= DI_PROPERTIES_CHANGE;
                    SetupDiSetDeviceInstallParams(hDevInfo, &did, &dip);
                }
            }
        }

        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
}

BOOLEAN
AddDeviceBayFilter(
    HKEY ClassKey
    )
{
    DWORD   dwType, dwSize;
    ULONG   res,
            filterLength,
            length;
    BOOLEAN added = FALSE,
            addFilter;
    TCHAR   szFilter[] = TEXT("dbfilter\0");
    PTCHAR  szCurrentFilter, szOffset, szUpperFilters;

    filterLength = lstrlen(szFilter);

    dwSize = 0;
    res = RegQueryValueEx(ClassKey,
                          REGSTR_VAL_UPPERFILTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize);

    if (res == ERROR_FILE_NOT_FOUND || dwType != REG_MULTI_SZ) {
        //
        // Value isn't there,
        //
        RegSetValueEx(ClassKey,
                      REGSTR_VAL_UPPERFILTERS,
                      0,
                      REG_MULTI_SZ,
                      (PBYTE) szFilter,
                      (filterLength + 2) * sizeof(TCHAR) );

        added = TRUE;
    }
    else if (res == ERROR_SUCCESS) {

        szUpperFilters = (PTCHAR)
            LocalAlloc(LPTR, dwSize + (filterLength + 1) * sizeof(TCHAR));

        if (!szUpperFilters)
            return FALSE;

        szOffset = szUpperFilters + filterLength + 1;

        res = RegQueryValueEx(ClassKey,
                              REGSTR_VAL_UPPERFILTERS,
                              NULL,
                              &dwType,
                              (PBYTE) szOffset,
                              &dwSize);

        if (res == ERROR_SUCCESS) {

            addFilter = TRUE;
            for (szCurrentFilter = szOffset; *szCurrentFilter; ) {

                length = lstrlen(szCurrentFilter);
                if (lstrcmpi(szFilter, szCurrentFilter) == 0) {
                    addFilter = FALSE;
                    break;
                }

                szCurrentFilter += (length + 1);
            }

            if (addFilter) {

                length = (filterLength + 1) * sizeof(TCHAR);
                memcpy(szUpperFilters, szFilter, length);

                dwSize += length;
                res = RegSetValueEx(ClassKey,
                                    REGSTR_VAL_UPPERFILTERS,
                                    0,
                                    REG_MULTI_SZ,
                                    (PBYTE) szUpperFilters,
                                    dwSize);

                added = (res == ERROR_SUCCESS);
            }
        }

        LocalFree(szUpperFilters);
    }

    return added;
}

DWORD
DeviceBayClassInstaller(
    IN  DI_FUNCTION         InstallFunction,
    IN  HDEVINFO            DeviceInfoSet,
    IN  PSP_DEVINFO_DATA    DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine is the class installer function for storage volumes.

Arguments:

    InstallFunction - Supplies the install function.

    DeviceInfoSet   - Supplies the device info set.

    DeviceInfoData  - Supplies the device info data.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    HKEY hKeyClass;

    switch (InstallFunction) {

    case DIF_INSTALLDEVICE:

        if (!SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData)) {
            return GetLastError();
        }

        hKeyClass = SetupDiOpenClassRegKey(&GUID_DEVCLASS_USB, KEY_ALL_ACCESS);
        if (hKeyClass != INVALID_HANDLE_VALUE) {
            if (AddDeviceBayFilter(hKeyClass)) {
                //
                // Restart all the USB devices
                //
                DeviceBayRestartDevices(&GUID_DEVCLASS_USB,
                                        IsUSBController);
            }
            RegCloseKey(hKeyClass);
        }

        hKeyClass = SetupDiOpenClassRegKey(&GUID_DEVCLASS_1394, KEY_ALL_ACCESS);
        if (hKeyClass != INVALID_HANDLE_VALUE) {
            if (AddDeviceBayFilter(hKeyClass)) {
                //
                // Restart all the 1394 controllers
                //
                DeviceBayRestartDevices(&GUID_DEVCLASS_1394, NULL);
            }
            RegCloseKey(hKeyClass);
        }

        //
        // We might want to do something with the friendly name in the future...
        //
        return NO_ERROR;
    }

    return ERROR_DI_DO_DEFAULT;
}

DWORD
EisaUpHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    )
{
#ifdef _X86_
    return PciHalCoInstaller(InstallFunction, DeviceInfoSet, DeviceInfoData, Context);
#else
    return NO_ERROR;
#endif
}

DWORD
ComputerClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for Computer class (HAL) devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;

    switch(InstallFunction) {

    case DIF_SELECTDEVICE:
        DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);

        if (SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                          DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_FILTERSIMILARDRIVERS;

            SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                          DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        //
        // We are not returning an error here because we want to break out and
        // return ERROR_DI_DO_DEFAULT.
        //
        break;
    }

    return ERROR_DI_DO_DEFAULT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\ctls.c ===
#include "setupp.h"
#pragma hdrstop


////////////////////////////////////////////
//
// Action item list control
//
////////////////////////////////////////////

//
// Define locations in extra window storage
//
#define AIL_FONT        (0)
#define AIL_BOLDFONT    (AIL_FONT + sizeof(PVOID))
#define AIL_TEXT        (AIL_BOLDFONT + sizeof(PVOID))
#define AIL_BOLDITEM    (AIL_TEXT + sizeof(PVOID))
#define AIL_LINECOUNT   (AIL_BOLDITEM + sizeof(LONG))
#define AIL_FREEFONTS   (AIL_LINECOUNT + sizeof(LONG))

#define AIL_EXTRA       ((3 * sizeof(PVOID)) + (3 * sizeof(LONG)))

PCWSTR szActionItemListClassName = L"$$$ActionItemList";

VOID
ActionItemListPaint(
    IN HWND hwnd
    )
{

    PAINTSTRUCT PaintStruct;
    PWSTR p,Text;
    UINT LineCount;
    HFONT OldFont,Font,BoldFont;
    UINT HighlightedItem;
    UINT i;
    int Length;
    int y;
    int yDelta;
    HBITMAP Bitmap,OldBitmap;
    BITMAP bitmap;
    HDC MemoryDC;
    SIZE Size;
    RECT rect;
    int Spacing;
    int oldmode;
    #define BORDER 3

    if(!BeginPaint(hwnd,&PaintStruct)) {
        return;
    }

    //
    // If no text, nothing to do.
    //
    if(Text = (PWSTR)GetWindowLongPtr(hwnd,AIL_TEXT)) {
        LineCount = (UINT)GetWindowLong(hwnd,AIL_LINECOUNT);
    }

    if(!Text || !LineCount) {
        return;
    }

    //
    // Get value indicating which item is to be bolded.
    //
    HighlightedItem = (UINT)GetWindowLong(hwnd,AIL_BOLDITEM);

    //
    // Get font handles.
    //
    Font = (HFONT)GetWindowLongPtr(hwnd,AIL_FONT);
    BoldFont = (HFONT)GetWindowLongPtr(hwnd,AIL_BOLDFONT);

    //
    // Select the non-boldface font to get the handle of
    // the currently selected font.
    //
    OldFont = SelectObject(PaintStruct.hdc,Font);

    oldmode = SetBkMode(PaintStruct.hdc,TRANSPARENT);

    //
    // Load the little triangle bitmap and create a compatible DC for it.
    //
    Bitmap = LoadBitmap(NULL,MAKEINTRESOURCE(OBM_MNARROW));

    if(MemoryDC = CreateCompatibleDC(PaintStruct.hdc)) {

        OldBitmap = SelectObject(MemoryDC,Bitmap);
        GetObject(Bitmap,sizeof(BITMAP),&bitmap);
    }

    Spacing = GetSystemMetrics(SM_CXICON) / 2;

    //
    // Treat the text as a series of lines and draw each one.
    //
    p = Text;
    y = 0;
    for(i=0; i<LineCount; i++) {

        SetBkColor(PaintStruct.hdc,GetSysColor(COLOR_3DFACE));

        //
        // Calculate the line's height based on the boldface font.
        // This is used to get to the y coord of the next line.
        //
        SelectObject(PaintStruct.hdc,BoldFont);

        GetClientRect(hwnd,&rect);
        rect.left = (2 * BORDER) + Spacing;
        rect.bottom = 0;

        DrawText(PaintStruct.hdc,p,lstrlen(p),&rect,DT_CALCRECT|DT_WORDBREAK);

        yDelta = rect.bottom + (2*BORDER);

        //
        // Change font to non-boldface for this line if necessary.
        //
        if(i != HighlightedItem) {
            SelectObject(PaintStruct.hdc,Font);
        }

        rect.top = y + BORDER;
        rect.left = (2 * BORDER) + Spacing;
        rect.bottom = rect.top + yDelta;

        //
        // Draw the line's text.
        //
        Length = lstrlen(p);
        DrawText(PaintStruct.hdc,p,Length,&rect,DT_WORDBREAK);

        //
        // Draw the little triangle thing if necessary.
        //
        if((i == HighlightedItem) && Bitmap && MemoryDC) {

            GetTextExtentPoint(PaintStruct.hdc,L"WWWWW",5,&Size);

            //
            // The arrow bitmap is monochrome. When blitted, 1-bits in the source
            // are converted to the text color in the destination DC and 0-bits
            // are converted to the background color. The effect we want to achieve
            // is to turn off in the destination bits that are 1 in the bitmap
            // and leave alone in the destination bits that are 0 in the bitmap.
            // Set the text color to all 0s and the background color to all 1s.
            // x AND 1 = x so background pixels stay undisturbed, and x AND 0 = 0
            // so foreground pixels get turned off.
            //
            SetBkColor(PaintStruct.hdc,RGB(255,255,255));

            BitBlt(
                PaintStruct.hdc,
                BORDER,
                y + ((Size.cy - bitmap.bmHeight) / 2) + BORDER,
                bitmap.bmWidth,
                bitmap.bmHeight,
                MemoryDC,
                0,0,
                SRCAND
                );
        }

        //
        // Point to next line's text.
        //
        p += Length + 1;
        y += yDelta;
    }

    //
    // Clean up.
    //
    SetBkMode(PaintStruct.hdc,oldmode);

    if(OldFont) {
        SelectObject(PaintStruct.hdc,OldFont);
    }

    if(MemoryDC) {
        if(OldBitmap) {
            SelectObject(MemoryDC,OldBitmap);
        }
        if(Bitmap) {
            DeleteObject(Bitmap);
        }
        DeleteDC(MemoryDC);
    }

    EndPaint(hwnd,&PaintStruct);
}


LRESULT
ActionItemListWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LRESULT rc;
    HFONT OldFont,Font,BoldFont;
    LOGFONT LogFont;
    PWSTR Text;
    PWSTR p;
    UINT LineCount;
    BOOL FreeFont,FreeBoldFont;

    switch(msg) {

    case WM_CREATE:

        //
        // Create fonts.
        //
        OldFont = (HFONT)SendMessage(GetParent(hwnd),WM_GETFONT,0,0);
        if(!OldFont) {
            //
            // Using system font.
            //
            OldFont = GetStockObject(DEFAULT_GUI_FONT);
        }

        FreeFont = TRUE;
        FreeBoldFont = TRUE;
        if(OldFont && GetObject(OldFont,sizeof(LOGFONT),&LogFont)) {

            LogFont.lfWeight = 400;
            Font = CreateFontIndirect(&LogFont);
            if(!Font) {
                Font = GetStockObject(DEFAULT_GUI_FONT);
                FreeFont = FALSE;
            }

            LogFont.lfWeight = 700;
            BoldFont = CreateFontIndirect(&LogFont);
            if(!BoldFont) {
                BoldFont = Font;
                FreeBoldFont = FALSE;
            }
        }

        SetWindowLongPtr(hwnd,AIL_FONT,(LONG_PTR)Font);
        SetWindowLongPtr(hwnd,AIL_BOLDFONT,(LONG_PTR)BoldFont);
        SetWindowLong(hwnd,AIL_BOLDITEM,0);
        SetWindowLongPtr(hwnd,AIL_TEXT,0);
        SetWindowLong(hwnd,AIL_LINECOUNT,0);
        SetWindowLong(hwnd,AIL_FREEFONTS,MAKELONG(FreeFont,FreeBoldFont));

        rc = 0;
        break;

    case WM_DESTROY:
        //
        // Get rid of fonts we created if necessary.
        //
        FreeFont = (BOOL)GetWindowLong(hwnd,AIL_FREEFONTS);
        FreeBoldFont = HIWORD(FreeFont);
        FreeFont = LOWORD(FreeFont);

        if(FreeFont && (Font = (HFONT)GetWindowLongPtr(hwnd,AIL_FONT))) {
            DeleteObject(Font);
        }

        if(FreeBoldFont && (BoldFont = (HFONT)GetWindowLongPtr(hwnd,AIL_BOLDFONT))) {
            DeleteObject(BoldFont);
        }

        if(Text = (PWSTR)GetWindowLongPtr(hwnd,AIL_TEXT)) {
            MyFree(Text);
        }
        rc = 0;
        break;

    case WM_SETTEXT:
        //
        // Free old text and remember new text.
        //
        if(Text = (PWSTR)GetWindowLongPtr(hwnd,AIL_TEXT)) {
            MyFree(Text);
        }

        LineCount = 0;
        if(Text = pSetupDuplicateString((PVOID)lParam)) {
            //
            // Count lines in the text. This is equal to the number of
            // newlines. We require that the last line have a newline
            // to be counted.
            //
            for(LineCount=0,p=Text; *p; p++) {

                if(*p == L'\r') {
                    *p = L' ';
                } else {
                    if(*p == L'\n') {
                        *p = 0;
                        LineCount++;
                    }
                }
            }
        }

        //
        // Cheat a little: we expect wParam to be the 0-based index
        // of the boldfaced line. Callers will have to use SendMessage
        // instead of SetWindowText().
        //
        SetWindowLong(hwnd,AIL_BOLDITEM,(LONG)wParam);
        SetWindowLong(hwnd,AIL_LINECOUNT,LineCount);
        SetWindowLongPtr(hwnd,AIL_TEXT,(LONG_PTR)Text);

        rc = (Text != NULL);
        break;

    case WM_ERASEBKGND:
        //
        // Indicate that the background was erased successfully to prevent
        // any further processing. This allows us to lay text transparently
        // over any background bitmap on the dialog.
        //
        rc = TRUE;
        break;

    case WM_PAINT:

        ActionItemListPaint(hwnd);
        rc = 0;
        break;

    default:
        rc = DefWindowProc(hwnd,msg,wParam,lParam);
        break;
    }

    return(rc);
}


BOOL
RegisterActionItemListControl(
    IN BOOL Init
    )
{
    WNDCLASS wc;
    BOOL b;
    static BOOL Registered;

    if(Init) {
        if(Registered) {
            b = TRUE;
        } else {
            wc.style = CS_PARENTDC;
            wc.lpfnWndProc = ActionItemListWndProc;
            wc.cbClsExtra = 0;
            wc.cbWndExtra = AIL_EXTRA;
            wc.hInstance = MyModuleHandle;
            wc.hIcon = NULL;
            wc.hCursor = LoadCursor(NULL,IDC_ARROW);
            wc.hbrBackground = NULL; // want to get WM_ERASEBKGND messages
            wc.lpszMenuName = NULL;
            wc.lpszClassName = szActionItemListClassName;

            if(b = (RegisterClass(&wc) != 0)) {
                Registered = TRUE;
            }
        }
    } else {
        if(Registered) {
            if(b = UnregisterClass(szActionItemListClassName,MyModuleHandle)) {
                Registered = FALSE;
            }
        } else {
            b = TRUE;
        }
    }

    return(b);
}

typedef struct _SPREG_TO_TEXT {
    DWORD FailureCode;
    PCWSTR FailureText;
} SPREG_TO_TEXT, *PSPREG_TO_TEXT;

SPREG_TO_TEXT RegErrorToText[] = {
    { SPREG_SUCCESS,     L"Success"           },
    { SPREG_LOADLIBRARY, L"LoadLibrary"       },
    { SPREG_GETPROCADDR, L"GetProcAddress"    },
    { SPREG_REGSVR,      L"DllRegisterServer" },
    { SPREG_DLLINSTALL,  L"DllInstall"        },
    { SPREG_TIMEOUT,     L"Timed out"         },
    { SPREG_UNKNOWN,     L"Unknown"           },
    { 0,                 NULL                 }
};


UINT
RegistrationQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
/*++

Routine Description:

    Callback routine that is called each time we self-register a file.

Arguments:

    Context - context message passed from parent to caller.

    Notification - specifies an SPFILENOTIFY_*** code, which tells us how
                   to interpret Param1 and Param2.

    Param1 - dependent on notification.

    Param2 - dependent on notification.


Return Value:

    FILEOP_*** code dependent on Notification code.

--*/
{
    PSP_REGISTER_CONTROL_STATUS Status = (PSP_REGISTER_CONTROL_STATUS)Param1;
    PREGISTRATION_CONTEXT RegistrationContext = (PREGISTRATION_CONTEXT) Context;
    DWORD i, ErrorMessageId;
    PCWSTR p;

    if (Notification == SPFILENOTIFY_STARTREGISTRATION) {
        //
        // log that we're starting registration and update the progress
        // guage as well.
        //
        SetupDebugPrint1(
                L"SETUP: file to register is %s...",
                Status->FileName);

        if (RegistrationContext->hWndProgress) {
            SendMessage(
                    RegistrationContext->hWndProgress,
                    PBM_STEPIT,
                    0,
                    0 );
        }
        return FILEOP_DOIT;

    }

    if (Notification == SPFILENOTIFY_ENDREGISTRATION) {
        //
        // the file has been registered, so log failure if necessary
        // Note that we have a special code for timeouts
        //
        switch(Status->FailureCode) {
            case SPREG_SUCCESS:

                SetupDebugPrint1(
                    L"SETUP: %s registered successfully",
                    Status->FileName);
                break;
            case SPREG_TIMEOUT:
                SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_OLE_REGISTRATION_HUNG,
                         Status->FileName,
                         NULL,NULL);
                SetupDebugPrint1(
                    L"SETUP: %s timed out during registration",
                    Status->FileName);
                break;
            default:
                //
                // log an error
                //
                for (i = 0;RegErrorToText[i].FailureText != NULL;i++) {
                    if (RegErrorToText[i].FailureCode == Status->FailureCode) {
                        p = RegErrorToText[i].FailureText;
                        if ((Status->FailureCode == SPREG_LOADLIBRARY) &&
                            (Status->Win32Error == ERROR_MOD_NOT_FOUND)) 
                            ErrorMessageId = MSG_LOG_X_MOD_NOT_FOUND;
                        else 
                        if ((Status->FailureCode == SPREG_GETPROCADDR) &&
                            (Status->Win32Error == ERROR_PROC_NOT_FOUND)) 
                            ErrorMessageId = MSG_LOG_X_PROC_NOT_FOUND;
                        else
                            ErrorMessageId = MSG_LOG_X_RETURNED_WINERR;

                        break;
                    }
                }

                if (!p) {
                    p = L"Unknown";
                    ErrorMessageId = MSG_LOG_X_RETURNED_WINERR;
                }
                SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_OLE_CONTROL_NOT_REGISTERED,
                        Status->FileName,
                        NULL,
                        SETUPLOG_USE_MESSAGEID,
                        ErrorMessageId,
                        p,
                        Status->Win32Error,
                        NULL,
                        NULL
                        );

                SetupDebugPrint1(
                    L"SETUP: %s did not register successfully",
                    Status->FileName);
        }

        //
        // Verify that the DLL didn't change our unhandled exception filter.
        //
        if( MyUnhandledExceptionFilter !=
            SetUnhandledExceptionFilter(MyUnhandledExceptionFilter)) {

            SetupDebugPrint1(
                    L"SETUP: %ws broke the exception handler.",
                    Status->FileName );
#if 0
            //
            // We'll put this in after all the currently broken DLLs are fixed.
            //
            MessageBoxFromMessage(
                RegistrationContext->hwndParent,
                MSG_EXCEPTION_FILTER_CHANGED,
                NULL,
                IDS_WINNT_SETUP,
                MB_OK | MB_ICONWARNING,
                Status->FileName );
#endif
        }

        return FILEOP_DOIT;
    }


    MYASSERT(FALSE);

    return(FILEOP_DOIT);
}



BOOL
RegisterOleControls(
    IN HWND     hwndParent,
    IN HINF     hInf,
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent,
    IN PWSTR    SectionName
    )
/*++

Routine Description:

    This routine runs down the entries in the specified INF section, and
    self-registers each file.

Arguments:

    hwndParent - supplies the window handle used for the PRERELEASE message
        box that indicates an OLE registration has hung.

    InfHandle - supplies handle to inf containing the specified SectionName.

    hProgress - handle to progress gauge that gets ticked every time we
        process a file.

    StartAtPercent - Position where the progress window should start (0% to 100%).

    StopAtPercent - Maximum position where the progress window can be moved to (0% to 100%).

    SectionName - Supplies the name of the section contained in the INF
        specified by InfHandle that lists OLE control DLLs to be
        registered/installed.

Return Value:

    Boolean value indicating outcome. If a file to be registered is
    not present, that is NOT reason for returning false.

--*/
{
    UINT GaugeRange;
    DWORD SectionCount,LineCount, i;
    INFCONTEXT InfContext;
    BOOL RetVal = TRUE;
    REGISTRATION_CONTEXT RegistrationContext;

    RegistrationContext.hWndParent   = hwndParent;
    RegistrationContext.hWndProgress = hProgress;
    LineCount = 0;

    //
    // Initialize the progress indicator control.
    //
    if (hProgress) {


        //
        // find out how many files we have to register
        //
        if (SetupFindFirstLine(hInf,
                               SectionName,
                               TEXT("RegisterDlls"),
                               &InfContext)) {


            do {
                SectionCount = SetupGetFieldCount(&InfContext);
                for (i = 1; i<=SectionCount; i++) {
                    PCWSTR IndividualSectionName = pSetupGetField(&InfContext,i);

                    if (IndividualSectionName) {
                        LineCount += SetupGetLineCount(hInf, IndividualSectionName);
                    }
                }

            } while(SetupFindNextMatchLine(
                                &InfContext,
                                TEXT("RegisterDlls"),
                                &InfContext));
        }

        MYASSERT((StopAtPercent-StartAtPercent) != 0);
        GaugeRange = (LineCount*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, LineCount, 0);
        SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(hProgress,PBM_SETSTEP,1,0);
    }

    //
    // now allow Setup API to register the files, using our callback to log
    // errors if and when they occur.
    //
    if (!SetupInstallFromInfSection(
                 hwndParent,
                 hInf,
                 SectionName,
                 SPINST_REGSVR| SPINST_REGISTERCALLBACKAWARE,
                 NULL,
                 NULL,
                 0,
                 RegistrationQueueCallback,
                 (PVOID)&RegistrationContext,
                 NULL,
                 NULL
                 )) {
        DWORD d;
        RetVal = FALSE;
        d = GetLastError();
        SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_OLE_REGISTRATION_SECTION_FAILURE,
                SectionName,
                L"syssetup.inf",
                d,
                NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_WINERR,
                szSetupInstallFromInfSection,
                d,
                NULL,
                NULL
                );
    }

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\cmdline.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cmdline.c

Abstract:

    Routines to fetch parameters passed to us by text mode
    and deal with uniquness criteria.

Author:

    Stephane Plante (t-stepl) 16-Oct-1995

Revision History:

    06-Mar-1996 (tedm) massive cleanup, and uniqueness stuff

--*/

#include "setupp.h"
#pragma hdrstop

#ifdef UNICODE
#define _UNICODE
#endif
#include <tchar.h>
#include "hwlog.h"

//
// These get filled in when we call SetUpProcessorNaming().
// They are used for legacy purposes.
//
// PlatformName - a name that indicates the processor platform type;
//                one of AMD64, I386, or ia64
//
// ProcessorName - a description of the type of processor. This varies
//                 depending on PlatformName.
//
// PrinterPlatform - name of platform-specific part of subdirectory
//                   used in printing architecture. One of w32amd64,
//                   w32x86, or w32ia64.
//
PCWSTR PlatformName = L"";
PCWSTR ProcessorName = L"";
PCWSTR PrinterPlatform = L"";
GUID DriverVerifyGuid = DRIVER_ACTION_VERIFY;

//
// Source path used for legacy operations. This is the regular
// source path with a platform-specific piece appended to it.
// This is how legacy infs expect it.
//
WCHAR LegacySourcePath[MAX_PATH];

//
// Policy values (ignore, warn, or block) for driver and non-driver signing.
// These are the policy values that are in effect post-setup (i.e., they are
// applied when setup is finished by calling InitializeCodeSigningPolicies with
// FALSE).
//
BYTE DrvSignPolicy;
BYTE NonDrvSignPolicy;

//
// Flags indicating whether the driver and non-driver signing policies came
// from the answerfile.  (If so, then those values are in effect after GUI-mode
// setup as well, thus DrvSignPolicy and NonDrvSignPolicy values are ignored.)
//
BOOL AFDrvSignPolicySpecified = FALSE;
BOOL AFNonDrvSignPolicySpecified = FALSE;

//
// Flag indicating if we're installing from a CD.
//
BOOL gInstallingFromCD = FALSE;

//
// Cryptographically secure codesigning policies
//
DWORD PnpSeed = 0;

//
// Define maximum parameter (from answer file) length
//
#define MAX_PARAM_LEN 256

#define FILEUTIL_HORRIBLE_PATHNAME (_T("system32\\CatRoot\\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\\"))

BOOL
SpSetupProcessSourcePath(
    IN  PCWSTR  NtPath,
    OUT PWSTR  *DosPath
    );

NTSTATUS
SpSetupLocateSourceCdRom(
    OUT PWSTR NtPath
    );

VOID
SetUpProcessorNaming(
    VOID
    );

BOOL
IntegrateUniquenessInfo(
    IN PCWSTR DatabaseFile,
    IN PCWSTR UniqueId
    );

BOOL
ProcessOneUniquenessSection(
    IN HINF   Database,
    IN PCWSTR SectionName,
    IN PCWSTR UniqueId
    );

DWORD
InstallProductCatalogs(
    OUT SetupapiVerifyProblem *Problem,
    OUT LPWSTR                 ProblemFile,
    IN  LPCWSTR                DescriptionForError OPTIONAL
    );


DWORD
DeleteOldCatalogs(
    VOID
    );

VOID
InstallPrivateFiles(
    IN HWND Billboard
    );

DWORD
PrepDllCache(
    VOID
    );

VOID
SpUninstallExcepPackCatalogs(
    IN HCATADMIN CatAdminHandle OPTIONAL
    );


BOOL
SpSetupLoadParameter(
    IN  PCWSTR Param,
    OUT PWSTR  Answer,
    IN  UINT   AnswerBufLen
    )

/*++

Routine Description:

    Load a single parameter out of the [Data] section of the
    setup parameters file. If the datum is not found there then
    look in the [SetupParams] and [Unattended] sections also.

Arguments:

    Param - supplies name of parameter, which is passed to the profile APIs.

    Answer - receives the value of the parameter, if successful.

    AnswerBufLen - supplies the size in characters of the buffer
        pointed to by Answer.

Return Value:

    Boolean value indicating success or failure.

--*/
{
    if(!AnswerFile[0]) {
       //
       // We haven't calculated the path to $winnt$.inf yet
       //
       GetSystemDirectory(AnswerFile,MAX_PATH);
       pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

       
       if(!FileExists(AnswerFile,NULL)) {
           //
           // Don't log this error message in mini-setup. Mini-setup may delete 
           // the answer file and later, if someone asks for it, and it is not found
           // we don't want to log this as a failure.  OOBE pretends to be mini-setup
           // so make sure that we log this error if we're running in OOBE and
           // we're missing the answer file.
           //
           if (!MiniSetup || OobeSetup) {
               SetuplogError(
                   LogSevError,
                   SETUPLOG_USE_MESSAGEID,
                   MSG_LOG_SYSINFBAD,
                   AnswerFile,
                   NULL,NULL);
           }
           return FALSE;
       }
    }

    if(!GetPrivateProfileString(pwData,Param,pwNull,Answer,AnswerBufLen,AnswerFile)) {
        //
        // If answer isn't in the DATA section then it could
        // conceivably be in the SETUPPARAMS section as a user
        // specified (command line) option
        //
        if(!GetPrivateProfileString(pwSetupParams,Param,pwNull,Answer,AnswerBufLen,AnswerFile)) {
            //
            // Now check the UNATTENDED section.
            //
            if(!GetPrivateProfileString(pwUnattended,Param,pwNull,Answer,AnswerBufLen,AnswerFile)) {
                //
                // Now check the ACCESSIBILITY section.
                //
                if(!GetPrivateProfileString(pwAccessibility,Param,pwNull,Answer,AnswerBufLen,AnswerFile)) {
                    //
                    // We haven't found the answer here so it probably doesn't exist.
                    // This is an error situation so notify our caller of that.
                    //
                    SetupDebugPrint1(L"SETUP: SpSetupLoadParameter was unable to find %ws.", Param);
                    return(FALSE);
                }
            }
        }
    }

    //
    // Success.
    //
    return(TRUE);
}


BOOL
SpSetProductTypeFromParameters(
    VOID
    )
/*++

Routine Description:

    Reads the Product Type from the parameters files and sets up
    the ProductType global variable.

Arguments:

    None

Returns:

    Boolean value indicating outcome.

--*/
{
    WCHAR p[MAX_PARAM_LEN];

    //
    // Determine the product type. If we can't resolve this
    // then the installation is in a lot of trouble
    //
    if( !MiniSetup ) {
        if( !SpSetupLoadParameter(pwProduct,p,sizeof(p)/sizeof(p[0]))) {
            return( FALSE );
        }
    } else {
    DWORD   rc, d, Type;
    HKEY    hKey;

        //
        // If we're doing a minisetup then we need to go pull the
        // product string out of the registry.
        //

        //
        // Open the key.
        //
        rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                           0,
                           KEY_READ,
                           &hKey );

        if( rc != NO_ERROR ) {
            SetLastError( rc );
            SetupDebugPrint1( L"Setup: Failed to open ProductOptions key (gle %u) \n", rc );
            return( FALSE );
        }


        //
        // Get the size of the ProductType entry.
        //
        rc = RegQueryValueEx( hKey,
                              L"ProductType",
                              NULL,
                              &Type,
                              NULL,
                              &d );

        if( rc != NO_ERROR ) {
            SetLastError( rc );
            SetupDebugPrint1( L"Setup: Failed to query size of ProductType key (gle %u) \n", rc );
            return( FALSE );
        }

        //
        // Get the ProductType entry.
        //
        rc = RegQueryValueEx( hKey,
                              L"ProductType",
                              NULL,
                              &Type,
                              (LPBYTE)p,
                              &d );

        if( rc != NO_ERROR ) {
            SetLastError( rc );
            SetupDebugPrint1( L"Setup: Failed to query ProductType key (gle %u) \n", rc );
            return( FALSE );
        }

    }

    //
    // We managed to find an entry in the parameters file
    // so we *should* be able to decode it
    //
    if(!lstrcmpi(p,pwWinNt)) {
        //
        // We have a WINNT product
        //
        ProductType = PRODUCT_WORKSTATION;

    } else if(!lstrcmpi(p,pwLanmanNt)) {
        //
        // We have a PRIMARY SERVER product
        //
        ProductType = PRODUCT_SERVER_PRIMARY;

    } else if(!lstrcmpi(p,pwServerNt)) {
        //
        // We have a STANDALONE SERVER product
        // NOTE: this case can currently never occur, since text mode
        // always sets WINNT_D_PRODUCT to lanmannt or winnt.
        //
        ProductType = PRODUCT_SERVER_STANDALONE;

    } else {
        //
        // We can't determine what we are, so fail
        //
        return (FALSE);
    }

    return (TRUE);
}


BOOL
SpSetUnattendModeFromParameters(
    VOID
    )
/*++

Routine Description:

    Reads the Unattended Mode from the parameters files and sets up
    the UnattendMode global variable.

Arguments:

    None

Returns:

    Boolean value indicating outcome.

--*/
{
    WCHAR p[MAX_PARAM_LEN];


    //
    // If we're not running unattended, don't bother to look up the mode.
    //
    if(!Unattended) {
        UnattendMode = UAM_GUIATTENDED;
        TextmodeEula = TRUE;
        return TRUE;
    }

    if (SpSetupLoadParameter(pwWaitForReboot, p, sizeof(p)/sizeof(p[0]))) {
        if (!lstrcmpi(p, pwYes)) {
            UnattendWaitForReboot = TRUE;
        }
    }

    if(SpSetupLoadParameter(pwUnattendMode,p,sizeof(p)/sizeof(p[0]))) {
        //
        // We managed to find an entry in the parameters file
        // so we *should* be able to decode it
        //
        if(!lstrcmpi(p,pwGuiAttended)) {
            //
            // GUI mode will be fully attended.
            //
            UnattendMode = UAM_GUIATTENDED;
            Unattended = FALSE;

        } else if(!lstrcmpi(p,pwProvideDefault)) {
            //
            // Answers are defaults and can be changed.
            //
            UnattendMode = UAM_PROVIDEDEFAULT;

        } else if(!lstrcmpi(p,pwDefaultHide)) {
            //
            // Answers are defaults, but a page with all answers supplied is
            // not shown.
            //
            UnattendMode = UAM_DEFAULTHIDE;

        } else if(!lstrcmpi(p,pwReadOnly)) {
            //
            // All supplied answers are read-only.  If a page has all its
            // answers supplied, then it is not shown.
            //
            UnattendMode = UAM_READONLY;

        } else if(!lstrcmpi(p,pwFullUnattended)) {
            //
            // Setup is fully unattended.  If we have to ask the user for an
            // answer, we put up an error dialog.
            //
            UnattendMode = UAM_FULLUNATTENDED;

        } else {
            //
            // We can't determine what we are, so use a default
            //
            UnattendMode = UAM_DEFAULTHIDE;
            SetupDebugPrint1(
                L"SETUP: SpSetUnattendModeFromParameters did not recognize %ls",
                p
                );
        }

    } else {
        //
        // Use default mode since none was specified.
        //
        UnattendMode = UAM_DEFAULTHIDE;
    }

    return TRUE;
}

BOOL
SpSetupProcessParameters(
    IN OUT HWND *Billboard
    )
/*++

Routine Description:

    Reads in parameters passed in from TextMode Setup

Arguments:

    Billboard - on input supplies window handle of "Setup is Initializing"
        billboard. On ouput receives new window handle if we had to
        display our own ui (in which case we would have killed and then
        redisplayed the billboard).

Returns:

    Boolean value indicating outcome.

--*/
{
    BOOL  b = TRUE;
    PWSTR q;
    WCHAR p[MAX_PARAM_LEN];
    WCHAR Num[24];
    UINT Type;
    WCHAR c;
    WCHAR TitleStringBuffer[1024];
    DWORD Err;
    SetupapiVerifyProblem Problem;
    WCHAR ProblemFile[MAX_PATH];
    INITCOMMONCONTROLSEX ControlInit;

    if(!SpSetProductTypeFromParameters()) {
        return(FALSE);
    }

    //
    // Is winnt/winnt32-based?
    //
    if((b = SpSetupLoadParameter(pwMsDos,p,MAX_PARAM_LEN))
    && (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {

        WinntBased = TRUE;

#ifdef _X86_
        //
        // Get Floppyless boot path, which is given if
        // pwBootPath is not set to NO
        //
        FloppylessBootPath[0] = 0;
        if((b = SpSetupLoadParameter(pwBootPath,p,MAX_PARAM_LEN)) && lstrcmpi(p,pwNo)) {

            if(q = NtFullPathToDosPath(p)) {

                lstrcpyn(
                    FloppylessBootPath,
                    q,
                    sizeof(FloppylessBootPath)/sizeof(FloppylessBootPath[0])
                    );

                MyFree(q);
            }
        }
#endif
    } else {
        WinntBased = FALSE;
    }

    //
    // Win3.1 or Win95 upgrade?
    //
    Win31Upgrade = (b && (b = SpSetupLoadParameter(pwWin31Upgrade,p,MAX_PARAM_LEN)) && !lstrcmpi(p,pwYes));
    Win95Upgrade = (b && (b = SpSetupLoadParameter(pwWin95Upgrade,p,MAX_PARAM_LEN)) && !lstrcmpi(p,pwYes));

    //
    // NT Upgrade?
    //
    Upgrade = (b && (b = SpSetupLoadParameter(pwNtUpgrade,p,MAX_PARAM_LEN)) && !lstrcmpi(p,pwYes));
    SetEnvironmentVariable( L"Upgrade", Upgrade ? L"True" : L"False" );

    //
    // If this is a an upgrade of or to a standalone server,
    // change the product type to standalone server.
    //
    // If this is not an upgrade and the product type is lanmannt,
    // change to standalone server. This makes the default server type
    // non-dc.
    //
    if(b && ((!Upgrade && (ProductType != PRODUCT_WORKSTATION)) || ((b = SpSetupLoadParameter(pwServerUpgrade,p,MAX_PARAM_LEN)) && !lstrcmpi(p,pwYes)))) {
        MYASSERT(ISDC(ProductType));
        ProductType = PRODUCT_SERVER_STANDALONE;
    }

    if( ProductType == PRODUCT_WORKSTATION) {
        if( GetProductFlavor() == 4) {
            SetupTitleStringId = Upgrade ? IDS_TITLE_UPGRADE_P : IDS_TITLE_INSTALL_P;
        }
        else {
            SetupTitleStringId = Upgrade ? IDS_TITLE_UPGRADE_W : IDS_TITLE_INSTALL_W;
        }
    }
    else
    {
        SetupTitleStringId = Upgrade ? IDS_TITLE_UPGRADE_S : IDS_TITLE_INSTALL_S;
    }


    //
    // Fetch the source directory and convert it to DOS-style path
    //
    if(b && (b = SpSetupLoadParameter(pwSrcDir,p,MAX_PARAM_LEN))) {
        //
        // Remember that setupdll.dll does all sorts of checking on the
        // source path. We need todo the same checks here. Note that
        // we will *write* back the checked path into $winnt$.inf as a
        // logical step to take
        //
        if(SpSetupProcessSourcePath(p,&q)) {

            lstrcpyn(SourcePath,q,sizeof(SourcePath)/sizeof(SourcePath[0]));
            MyFree(q);

            //
            // Attempt to write the path to the parameters file.
            // This changes it from an nt-style path to a dos-style path there.
            //
            b = WritePrivateProfileString(pwData,pwDosDir,SourcePath,AnswerFile);
            if(!b) {
                SetupDebugPrint( L"SETUP: WritePrivateProfileString failed in SpSetupProcessParameters." );
            }

        } else {
            b = FALSE;
            SetupDebugPrint( L"SETUP: SpSetupProcessSourcePath failed in SpSetupProcessParameters." );
        }

        //
        // Set up globals for platform-specific info
        //
        SetUpProcessorNaming();

        //
        // Construct legacy source path.
        //
        if(b) {
            lstrcpyn(LegacySourcePath,SourcePath,MAX_PATH);
            pSetupConcatenatePaths(LegacySourcePath,PlatformName,MAX_PATH,NULL);
        }
    }

    //
    // Unattended Mode?
    //
    Unattended = (b &&
        (b = SpSetupLoadParameter(pwInstall,p,MAX_PARAM_LEN)) &&
        !lstrcmpi(p,pwYes));

    if(b) {
        if( !(b = SpSetUnattendModeFromParameters()) ) {
            SetupDebugPrint( L"SETUP: SpSetUnattendModeFromParameters failed in SpSetupProcessParameters." );
        }
    }

    SetupDebugPrint1(L"SETUP: Upgrade=%d.", Upgrade);
    SetupDebugPrint1(L"SETUP: Unattended=%d.", Unattended);

    //
    // We can get into unattended mode in several ways, so we also check whether
    // the "/unattend" switch was explicitly specified.
    //
    UnattendSwitch = (b &&
        SpSetupLoadParameter(pwUnattendSwitch,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne)));

    //
    // Should we force OOBE to run?
    //
    ForceRunOobe = (b &&
        SpSetupLoadParameter(pwRunOobe,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne)));

    //
    // Flag indicating whether we are in a special mode for OEM's to use on the
    // factory floor.
    //
    ReferenceMachine = (b &&
        SpSetupLoadParameter(pwReferenceMachine,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne)));

    //
    // Eula already displayed?
    //
    if(b && SpSetupLoadParameter(pwEulaDone,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {
        EulaComplete = TRUE;
    } else {
        EulaComplete = FALSE;
    }

    //
    // Do uniqueness stuff now. We do this here so we don't have to
    // reinitialize anything. All the stuff above is not subject to change
    // via uniquenss.
    //
    InitializeUniqueness(Billboard);

    //
    // Initialize unattended operation now.
    //
    UnattendInitialize();

    //
    // Setup shell special folders (e.g., "Program Files", etc.) in registry
    // prior to loading any INFs with setupapi.  That's because it's possible
    // that an INF can have DIRIDs that refer to these special directories.
    // (In addition to setupapi's potential need for this, OCM definitely needs
    // it.)
    //
    if(b) {
        if( !(b = SetProgramFilesDirInRegistry()) ) {
            SetupDebugPrint( L"SETUP: SetProgramFilesDirInRegistry failed in SpSetupProcessParameters." );
        }
    }

    //
    // Also, let setupapi know where the source path is...
    //
    // note that the servicepack sourcepath is the same as the system source
    // path in this case since we can only be dealing with a slipstreamed
    // build in this case
    //
    if(b) {
        if( !(b = pSetupSetSystemSourcePath( SourcePath, SourcePath )) ) {
            SetupDebugPrint( L"SETUP: pSetupSetSystemSourcePath failed in SpSetupProcessParameters." );
        }
    }

    if(b && SpSetupLoadParameter(pwIncludeCatalog,p,MAX_PARAM_LEN) && *p) {
        IncludeCatalog = pSetupDuplicateString(p);
        if(!IncludeCatalog) {
            b = FALSE;
            SetupDebugPrint( L"SETUP: IncludeCatalog failed in SpSetupProcessParameters." );
        }
    }

    if(b) {

        //
        // Load the system setup (win95-style!) infs.
        //
        SyssetupInf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);

        if(SyssetupInf == INVALID_HANDLE_VALUE) {
            KillBillboard(*Billboard);
            FatalError(MSG_LOG_SYSINFBAD,L"syssetup.inf",0,0);
        }
        //
        // syssetup.inf opened successfully, now append-load any layout INFs
        // it references.
        //
        if(!SetupOpenAppendInfFile(NULL,SyssetupInf,NULL)) {
            KillBillboard(*Billboard);
            FatalError(MSG_LOG_SYSINFBAD,L"(syssetup.inf layout)",0,0);
        }

        //
        // write some information about the hardware configuration to setupact.log
        //
        //
        if( !OobeSetup ) {
            SP_LOG_HARDWARE_IN LogHardwareIn = { 0 };

            LogHardwareIn.SetuplogError = SetuplogError;
            SpLogHardware(&LogHardwareIn);
        }

        if (!MiniSetup && !OobeSetup) {
            DuInitialize ();
        }

        //
        // install side by side assemblies (fusion)
        //
        if( !OobeSetup ) {
            SIDE_BY_SIDE SideBySide = {0};
            BOOL b1 = FALSE;
            BOOL b2 = FALSE;
            BOOL b3 = FALSE;

            b1 = SideBySidePopulateCopyQueue(&SideBySide, NULL, NULL);
            b2 = SideBySideFinish(&SideBySide, b1);
            if (!b1 || !b2) {                
                WCHAR szErrorBuffer[128];
                DWORD dwLastError = GetLastError();

                szErrorBuffer[0] = 0;
                if (FormatMessageW(
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwLastError,
                        0,
                        szErrorBuffer,
                        RTL_NUMBER_OF(szErrorBuffer),
                        NULL) == 0) {
                    _snwprintf(szErrorBuffer, RTL_NUMBER_OF(szErrorBuffer), L"Untranslatable message, Win32LastError is %lu\r\n", dwLastError);
                    szErrorBuffer[RTL_NUMBER_OF(szErrorBuffer) - 1] = 0;
                }

                if ((dwLastError == ERROR_CRC) || (dwLastError == ERROR_SWAPERROR)) 
                {
                    // for CD media error
                    FatalError(MSG_LOG_SIDE_BY_SIDE_IO_ERROR, szErrorBuffer, 0, 0);

                }else
                {
                    FatalError(MSG_LOG_SIDE_BY_SIDE, szErrorBuffer, 0, 0);
                }
            }

            //
            // install additional assemblies downloaded from WU
            // ignore any errors; logging occurs inside the called function
            //
            // Meta-issue: Perhaps this should use the SideBySide context
            // created above, rather than generating its own thing?
            // That would allow even more "goodness" by piggybacking on the
            // existing structures, reduce memory usage by not creating
            // another context, and then chain all the copy calls (if/when
            // SxS uses the real copy queue functionality) into a single
            // SideBySideFinish.
            //
            if (!MiniSetup && !OobeSetup) {
                DuInstallDuAsms ();
            }

            //
            // Everyone done and happy?  Good, now go and create the default
            // context based on whatever DU and the original media installed.
            //
            b3 = SideBySideCreateSyssetupContext();
            if ( !b3 ) {                
                WCHAR szErrorBuffer[128];
                DWORD dwLastError = GetLastError();

                szErrorBuffer[0] = 0;
                if (FormatMessageW(
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwLastError,
                        0,
                        szErrorBuffer,
                        RTL_NUMBER_OF(szErrorBuffer),
                        NULL) == 0) {
                    _snwprintf(szErrorBuffer, RTL_NUMBER_OF(szErrorBuffer), L"Untranslatable message, Win32LastError is %lu\r\n", dwLastError);
                    szErrorBuffer[RTL_NUMBER_OF(szErrorBuffer) - 1] = 0;
                }

                if ((dwLastError == ERROR_CRC) || (dwLastError == ERROR_SWAPERROR)) 
                {
                    // for CD media error
                    FatalError(MSG_LOG_SIDE_BY_SIDE_IO_ERROR, szErrorBuffer, 0, 0);

                }else
                {
                    FatalError(MSG_LOG_SIDE_BY_SIDE, szErrorBuffer, 0, 0);
                }

            }
        }

        //
        // We must not use comctl32.dll until after SideBySide install completes.
        // It is delayloaded, using the linker feature.
        //
        // But, actually, it get's loaded by winntbb before us, and that is ok, it
        // still gets redirected for uses from syssetup.dll, oc manager, etc.
        //
        //ASSERT(GetModuleHandleW(L"comctl32.dll") == NULL);

        ControlInit.dwSize = sizeof(INITCOMMONCONTROLSEX);
        ControlInit.dwICC = ICC_LISTVIEW_CLASSES    |
                            ICC_TREEVIEW_CLASSES    |
                            ICC_BAR_CLASSES         |
                            ICC_TAB_CLASSES         |
                            ICC_UPDOWN_CLASS        |
                            ICC_PROGRESS_CLASS      |
                            ICC_HOTKEY_CLASS        |
                            ICC_ANIMATE_CLASS       |
                            ICC_WIN95_CLASSES       |
                            ICC_DATE_CLASSES        |
                            ICC_USEREX_CLASSES      |
                            ICC_COOL_CLASSES
    #if (_WIN32_IE >= 0x0400)
                            |
                            ICC_INTERNET_CLASSES    |
                            ICC_PAGESCROLLER_CLASS
    #endif
                            ;

        InitCommonControlsEx( &ControlInit );

        //
        // We're about to go off and install the catalogs that will be used for
        // digital signature verification of the product files.  First, however,
        // we need to make sure all the CAPI stuff is setup.  (Errors here are
        // not considered fatal.)
        //
        if(!InstallOrUpgradeCapi()) {
            SetupDebugPrint(L"Setup: (non-critical error) Failed call InstallOrUpgradeCapi().\n");
        }

        //
        // Now go install the product catalog files, validating syssetup.inf
        // (and any append-loaded INFs) against the 'primary' catalog.
        //
        // NOTE: No file/INF operations using setupapi should be done until after
        // the product catalogs are installed!
        //
        if(!LoadString(MyModuleHandle, SetupTitleStringId, TitleStringBuffer, SIZECHARS(TitleStringBuffer))) {
            *TitleStringBuffer = L'\0';
        }

        //
        // delete old catalogs that we don't want anymore before we install
        // our product catalogs
        //
        DeleteOldCatalogs();

        Err = InstallProductCatalogs(&Problem,
                                     ProblemFile,
                                     (*TitleStringBuffer ? TitleStringBuffer : NULL)
                                    );

        if(Err == NO_ERROR) {

            if (!MiniSetup && !OobeSetup) {

                Err = DuInstallCatalogs (
                            &Problem,
                            ProblemFile,
                            (*TitleStringBuffer ? TitleStringBuffer : NULL)
                            );

                if (Err != NO_ERROR) {
                    //
                    // We couldn't install updates. However, there's not
                    // a whole lot we can do about it.  We'll just log an error for this
                    //
                    SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_SYSSETUP_UPDATES_FAILED,
                            (*TitleStringBuffer ? TitleStringBuffer : ProblemFile),
                            Err,
                            ProblemFile,
                            NULL,
                            NULL
                            );
                    //
                    // Also, add an entry about this failure to setupapi's PSS exception
                    // logfile.
                    //
                    pSetupHandleFailedVerification (
                            MainWindowHandle,
                            Problem,
                            ProblemFile,
                            (*TitleStringBuffer ? TitleStringBuffer : NULL),
                            pSetupGetCurrentDriverSigningPolicy(FALSE),
                            TRUE,  // no UI!
                            Err,
                            NULL,
                            NULL,
                            NULL
                            );
                }
            }
        }

        PnpSeed = GetSeed();

        //
        // At this point setupapi can verify files/INFs.
        //
        pSetupSetGlobalFlags(pSetupGetGlobalFlags()&~PSPGF_NO_VERIFY_INF);

        //
        // Now that we can use crypto, we initialize our codesigning policy
        // values.  (We have to do this here, because we're about to retrieve
        // policy in the error handling code below.)
        //
        InitializeCodeSigningPolicies(TRUE);

        if(Err != NO_ERROR) {
            //
            // We couldn't install the product catalogs (or syssetup.inf
            // couldn't be verified using that catalog).  However, there's not
            // a whole lot we can do about it.  We'll just log an error for
            // this, and components that need to be verified later on will
            // (based on policy) generate signature verification failure popups.
            //

                if( Err == CERT_E_EXPIRED)
                {
                    SetuplogError(LogSevError,
                                  SETUPLOG_USE_MESSAGEID,
                                  MSG_LOG_SYSSETUP_CERT_EXPIRED,
                                  Err,
                                  NULL,
                                  NULL
                                 );
                }
                else
                {
                    SetuplogError(LogSevError,
                                  SETUPLOG_USE_MESSAGEID,
                                  MSG_LOG_SYSSETUP_VERIFY_FAILED,
                                  (*TitleStringBuffer ? TitleStringBuffer : ProblemFile),
                                  Err,
                                  NULL,
                                  SETUPLOG_USE_MESSAGEID,
                                  Err,
                                  NULL,
                                  NULL
                                 );

                }
            //
            // Also, add an entry about this failure to setupapi's PSS exception
            // logfile.
            //
            pSetupHandleFailedVerification(MainWindowHandle,
                                     Problem,
                                     ProblemFile,
                                     (*TitleStringBuffer ? TitleStringBuffer : NULL),
                                     pSetupGetCurrentDriverSigningPolicy(FALSE),
                                     TRUE,  // no UI!
                                     Err,
                                     NULL,   // log context
                                     NULL,    //optional flags
                                     NULL
                                    );

            KillBillboard(*Billboard);
            FatalError(MSG_LOG_SYSSETUP_CATALOGS_NOT_INSTALLED,0,0);

        }

        //
        // make sure to install the private files (specified with /m)
        // BEFORE calling DuInstallUpdates ()
        //
        InstallPrivateFiles(*Billboard);

        if (!MiniSetup && !OobeSetup) {
            //
            // install any updated files, previously
            // downloaded and preprocessed by winnt32
            // if it fails, it already logged the reason
            //
            DuInstallUpdates ();
        }

        if( (Err=PrepDllCache()) != NO_ERROR ){

            SetuplogError(LogSevError,
                          SETUPLOG_USE_MESSAGEID,
                          MSG_LOG_MAKEDLLCACHE_CATALOGS_FAILED,
                          Err,
                          NULL,
                          SETUPLOG_USE_MESSAGEID,
                          Err,
                          NULL,
                          NULL
                         );


        }
    }

    //
    // Accessibility Utilities
    //
    AccessibleSetup = FALSE;

    if(SpSetupLoadParameter(pwAccMagnifier,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {

        AccessibleSetup = TRUE;
        Magnifier = TRUE;
    } else {
        Magnifier = FALSE;
    }

    if(SpSetupLoadParameter(pwAccReader,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {

        AccessibleSetup = TRUE;
        ScreenReader = TRUE;
    } else {
        ScreenReader = FALSE;
    }

    if(SpSetupLoadParameter(pwAccKeyboard,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {

        AccessibleSetup = TRUE;
        OnScreenKeyboard = TRUE;
    } else {
        OnScreenKeyboard = FALSE;
    }

    //
    // Fetch original source path and source path type.
    // We either deal with network or CD-ROM.
    //
    if(b) {

        Type = DRIVE_CDROM;
        lstrcpy(p,L"A:\\");
        lstrcat(p,PlatformName);

        if(SpSetupLoadParameter(WINNT_D_ORI_SRCPATH,p,MAX_PARAM_LEN)
        && SpSetupLoadParameter(WINNT_D_ORI_SRCTYPE,Num,sizeof(Num)/sizeof(Num[0]))) {
            Type = wcstoul(Num,NULL,10);
            if(Type != DRIVE_REMOTE && Type != DRIVE_FIXED) {
                Type = DRIVE_CDROM;
            }
        }

        if(Type == DRIVE_CDROM) {
            //
            // Make sure the drive is a CD-ROM, as the drive letters
            // may be different then when winnt/winnt32 was run.
            //
            if(MyGetDriveType(p[0]) != DRIVE_CDROM) {
                for(c=L'A'; c<=L'Z'; c++) {
                    if(MyGetDriveType(c) == DRIVE_CDROM) {
                        p[0] = c;
                        break;
                    }
                }

                if(MyGetDriveType(p[0]) != DRIVE_CDROM) {
                    //
                    // No CD-ROM drives. Change to A:.
                    //
                    lstrcpy(p,L"A:\\");
                    lstrcat(p,PlatformName);
                }
            }
        }

        //
        // Root paths should be like x:\ and not just x:.
        //
        if(p[0] && (p[1] == L':') && !p[2]) {
            p[2] = L'\\';
            p[3] = 0;
        }

        OriginalSourcePath = pSetupDuplicateString(p);
        if(!OriginalSourcePath) {
            b = FALSE;
            SetupDebugPrint( L"SETUP: pSetupDuplicateString failed in SpSetupProcessParameters." );
        }
    }

    //
    // The following parameters are optional.
    // - Any optional dirs to copy over?
    // - User specified command to execute
    // - Skip Missing Files?
    //
    if(b && SpSetupLoadParameter(pwOptionalDirs,p,MAX_PARAM_LEN) && *p) {
        OptionalDirSpec = pSetupDuplicateString(p);
        if(!OptionalDirSpec) {
            b=FALSE;
        }
    }
    if(b && SpSetupLoadParameter(pwUXC,p,MAX_PARAM_LEN) && *p) {
        UserExecuteCmd = pSetupDuplicateString(p);
        if(!UserExecuteCmd) {
            b = FALSE;
            SetupDebugPrint( L"SETUP: pSetupDuplicateString failed in SpSetupProcessParameters." );
        }
    }
    if(b && SpSetupLoadParameter(pwSkipMissing,p,MAX_PARAM_LEN)
    && (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {
        SkipMissingFiles = TRUE;
    }

    return(b);
}


NTSTATUS
SpSetupLocateSourceCdRom(
    OUT PWSTR NtPath
    )
/*++

Routine Description:

    Searches all the available CD-ROM devices for source media and
    returns the NT device name for the first CD-ROM that has the
    source media. Currently we use tag file name to validate the 
    source media.

Arguments:

    NtPath - Place holder for receiving NT device name for CD-ROM
             that has the source media.

Returns:

    Appropriate NTSTATUS code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (NtPath) {
        WCHAR   LayoutInf[MAX_PATH];        

        if (GetWindowsDirectory(LayoutInf, ARRAYSIZE(LayoutInf))) {
            WCHAR TagFileName[MAX_PATH];
            
            pSetupConcatenatePaths(LayoutInf, 
                TEXT("\\inf\\layout.inf"), 
                ARRAYSIZE(TagFileName),
                NULL);

            if (GetPrivateProfileString(TEXT("strings"),
                    TEXT("cdtagfile"),
                    TEXT(""),
                    TagFileName,
                    ARRAYSIZE(TagFileName),
                    LayoutInf)) {

                SYSTEM_DEVICE_INFORMATION SysDeviceInfo = {0};

                Status = NtQuerySystemInformation(SystemDeviceInformation,
                            &SysDeviceInfo,
                            sizeof(SYSTEM_DEVICE_INFORMATION),
                            NULL);                

                if (NT_SUCCESS(Status) && (0 == SysDeviceInfo.NumberOfCdRoms)) {
                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                }
 
                if (NT_SUCCESS(Status)) {
                    ULONG   Index;
                    WCHAR   TagFilePathName[MAX_PATH];
                    WCHAR   SourceCdRomPath[MAX_PATH];
                    UNICODE_STRING UnicodeString;
                    OBJECT_ATTRIBUTES ObjectAttributes;
                    IO_STATUS_BLOCK StatusBlock;
                    HANDLE FileHandle;
                    UINT OldMode;

                    for (Index = 0; Index < SysDeviceInfo.NumberOfCdRoms; Index++) {
                        
                        wsprintf(SourceCdRomPath, TEXT("\\device\\cdrom%d\\"), Index);
                        wcscpy(TagFilePathName, SourceCdRomPath);

                        pSetupConcatenatePaths(TagFilePathName,
                            TagFileName,
                            ARRAYSIZE(TagFilePathName),
                            NULL);
                        
                        //
                        // See if the NT source path exists.
                        //
                        RtlInitUnicodeString(&UnicodeString, TagFilePathName);
                        
                        InitializeObjectAttributes(&ObjectAttributes,
                            &UnicodeString,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

                        OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                        Status = NtCreateFile(&FileHandle,
                                    FILE_GENERIC_READ,
                                    &ObjectAttributes,
                                    &StatusBlock,
                                    NULL,
                                    FILE_ATTRIBUTE_NORMAL,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    FILE_OPEN,
                                    FILE_SYNCHRONOUS_IO_ALERT,
                                    NULL,
                                    0);

                        SetErrorMode(OldMode);

                        if(NT_SUCCESS(Status)) {
                            CloseHandle(FileHandle);

                            //
                            // The tag file is present which indicates
                            // the current CD-ROM is this is source CD-ROM
                            //
                            wcscpy(NtPath, SourceCdRomPath);
                            
                            break;
                        }
                    }
                }
            }                    
        }
    }

    return Status;
}


BOOL
SpSetupProcessSourcePath(
    IN  PCWSTR  NtPath,
    OUT PWSTR  *DosPath
    )
{
    WCHAR ntPath[MAX_PATH];
    BOOL NtPathIsCd;
    PWCHAR PathPart;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    IO_STATUS_BLOCK StatusBlock;
    UINT OldMode;
    WCHAR Drive;
    WCHAR PossibleDosPath[MAX_PATH];
    UINT Type;
    BOOL b;
    WCHAR   LayoutInf[MAX_PATH];        

    #define CDDEVPATH L"\\DEVICE\\CDROM"
    #define CDDEVPATHLEN ((sizeof(CDDEVPATH)/sizeof(WCHAR))-1)

    #define RDRDEVPATH L"\\DEVICE\\LANMANREDIRECTOR"
    #define RDRDEVPATHLEN ((sizeof(RDRDEVPATH)/sizeof(WCHAR))-1)

    if (!(NtPath && DosPath)){

        SetupDebugPrint( L"SETUP: SpSetupProcessSourcePath Invalid parameters passed to SpSetupProcessSourcepath." );
        return FALSE;
    }
    
    //
    // Determine the source media type based on the nt path
    //
    lstrcpyn(ntPath,NtPath,MAX_PATH);
    CharUpper(ntPath);

    PathPart = NULL;
    NtPathIsCd = FALSE;
    if(wcsstr(ntPath,L"\\DEVICE\\HARDDISK")) {
        //
        // Looks like a hard drive; make sure it's really valid.
        //
        if(PathPart = wcsstr(ntPath,L"\\PARTITION")) {
            if(PathPart = wcschr(PathPart+1,L'\\')) {
                PathPart++;
            }
        }

    } else {
        if(!memcmp(ntPath,CDDEVPATH,CDDEVPATHLEN*sizeof(WCHAR))) {

            NtPathIsCd = TRUE;

            if(PathPart = wcschr(ntPath+CDDEVPATHLEN,L'\\')) {
                PathPart++;
            } else {
                PathPart = wcschr(ntPath,0);
            }
        }
    }


    //
    // Set a global here so we can always know if we're installing from
    // CD.
    //
    gInstallingFromCD = NtPathIsCd;


    //
    // If the case where we don't recognize the device type, just try to
    // convert it to a DOS path and return.
    //
    if(!PathPart) {

        if (memcmp(ntPath,RDRDEVPATH,RDRDEVPATHLEN*sizeof(WCHAR)) == 0) {

            //
            // Special case for \Device\LanmanRedirector: convert to UNC path.
            //
            *DosPath = MyMalloc((lstrlen(ntPath) - RDRDEVPATHLEN + 2)*sizeof(WCHAR));
            if (*DosPath != NULL) {
                wcscpy(*DosPath, L"\\");
                wcscat(*DosPath, ntPath + RDRDEVPATHLEN);
            }

            //
            // Set RemoteBootSetup to indicate that we're doing a remote boot
            // setup. Set BaseCopyStyle to indicate that single-instance store
            // links should be created instead of copying files.
            //
            RemoteBootSetup = TRUE;
            BaseCopyStyle = SP_COPY_SOURCE_SIS_MASTER;

        } else {
            *DosPath = NtFullPathToDosPath(ntPath);
        }
        return(*DosPath != NULL);
    }

    //
    // See if the NT source path exists for CDROM.
    //

    if (GetWindowsDirectory(LayoutInf, ARRAYSIZE(LayoutInf))) {
        WCHAR TagFileName[MAX_PATH];
        
        pSetupConcatenatePaths(LayoutInf, 
            TEXT("\\inf\\layout.inf"), 
            ARRAYSIZE(LayoutInf),
            NULL);

        //
        // Get the name of the cd tag file name from layout.inf file
        //
        if (GetPrivateProfileString(TEXT("strings"),
                                    TEXT("cdtagfile"),
                                    TEXT(""),
                                    TagFileName,
                                    ARRAYSIZE(TagFileName),
                                    LayoutInf)) {

                WCHAR   TagFilePathName[MAX_PATH];
                HANDLE FileHandle;

                wcscpy(TagFilePathName, ntPath);

                pSetupConcatenatePaths( TagFilePathName,
                                    TagFileName,
                                    ARRAYSIZE(TagFilePathName),
                                    NULL);

                //
                // Check if the tag file exists in the CDROM media 
                // corresponding to the NtPath passed to us from the 
                // Text mode setup. 
                // It could have changed, if there are more than one CDROM 
                // drives on the computer and more than one contain media 
                // as the order in which they get detected in GUI mode setup
                // can be different than in Text mode Setup.
                //
                RtlInitUnicodeString(&UnicodeString, TagFilePathName);

                InitializeObjectAttributes(&ObjectAttributes,
                    &UnicodeString,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL);

                OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                Status = NtCreateFile(&FileHandle,
                            FILE_GENERIC_READ,
                            &ObjectAttributes,
                            &StatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_ALERT,
                            NULL,
                            0);

                SetErrorMode(OldMode);

                //
                // Tag file exists in the CDROM media represented by NtPath.
                //
                if(NT_SUCCESS(Status)) {
                    CloseHandle(FileHandle);

                    //
                    // The tag file is present which indicates
                    // the current CD-ROM is this is source CD-ROM
                    //
                    *DosPath = NtFullPathToDosPath(ntPath);
                    return(*DosPath != NULL);
                    
                 }
           }    
    }

    //
    // Scan for source CD-ROM among available CD-ROM devices
    //
    if (NtPathIsCd) {
        WCHAR   NtSourceCdRomPath[MAX_PATH] = {0};
        
        NTSTATUS Status = SpSetupLocateSourceCdRom(NtSourceCdRomPath);

        if (NT_SUCCESS(Status)) {
            *DosPath = NtFullPathToDosPath(NtSourceCdRomPath);

            if (*DosPath) {
                return TRUE;
            }                
        }
    }

    //
    // The directory does not exist as-is. Look through all dos drives
    // to attempt to find the source path. Match the drive types as well.
    //
    // When we get here PathPart points past the initial \ in the
    // part of the nt device path past the device name. Note that this
    // may be a nul char.
    //
    for(Drive = L'A'; Drive <= L'Z'; Drive++) {

        PossibleDosPath[0] = Drive;
        PossibleDosPath[1] = L':';
        PossibleDosPath[2] = L'\\';
        PossibleDosPath[3] = 0;

        //
        // NOTE: Removable hard drives and floppies both come back
        // as DRIVE_REMOVABLE.
        //
        Type = GetDriveType(PossibleDosPath);

        if(((Type == DRIVE_CDROM) && NtPathIsCd)
        || (((Type == DRIVE_REMOVABLE) || (Type == DRIVE_FIXED)) && !NtPathIsCd)) {
            //
            // See whether the path exists. If we're looking for
            // the root path (such as when installing from a CD,
            // in which case the ntPath was something like
            // \Device\CdRom0\) then we can't use FileExists
            // since that relies on FindFirstFile which fails
            // on root paths.
            //
            if(*PathPart) {
                lstrcpy(PossibleDosPath+3,PathPart);
                b = FileExists(PossibleDosPath,NULL);
            } else {
                b = GetVolumeInformation(
                        PossibleDosPath,
                        NULL,0,             // vol name buffer and size
                        NULL,               // serial #
                        NULL,               // max comp len
                        NULL,               // fs flags
                        NULL,0              // fs name buffer and size
                        );
            }

            if(b) {
                *DosPath = pSetupDuplicateString(PossibleDosPath);
                return(*DosPath != NULL);
            }
        }
    }

    //
    // Couldn't find it. Try a fall-back.
    //
    *DosPath = NtFullPathToDosPath(ntPath);
    return(*DosPath != NULL);
}


VOID
SetUpProcessorNaming(
    VOID
    )

/*++

Routine Description:

    Determines strings which corresponds to the platform name,
    processor name and printer platform. For backwards compat.
    Sets global variables

    PlatformName - a name that indicates the processor platform type;
        one of AMD64, I386, or ia64.

    ProcessorName - a description of the type of processor. This varies
        depending on PlatformName.

    PrinterPlatform - name of platform-specific part of subdirectory
        used in printing architecture. One of w32amd64, w32ia64, or w32x86.

Arguments:

    None

Returns:

    None. Global vars filled in as described above.

--*/

{
    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);

    switch(SystemInfo.wProcessorArchitecture) {

    case PROCESSOR_ARCHITECTURE_AMD64:
        ProcessorName = L"AMD64";
        PlatformName = L"AMD64";
        PrinterPlatform = L"w32amd64";
        break;

    case PROCESSOR_ARCHITECTURE_INTEL:
        switch(SystemInfo.wProcessorLevel) {
        case 3:
            ProcessorName = (!IsNEC_98) ? L"I386" : L"nec98"; //NEC98
            break;
        case 4:
            ProcessorName = L"I486";
            break;
        case 6:
            ProcessorName = L"I686";
            break;
        case 5:
        default:
            ProcessorName = L"I586";
            break;
        }

        PlatformName = (!IsNEC_98) ? L"I386" : L"nec98"; //NEC98

        PrinterPlatform = L"w32x86";
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        ProcessorName = L"Merced";
        PlatformName = L"IA64";
        PrinterPlatform = L"w32ia64";
        break;
    }

    //
    // In default case the vars stay "" which is what they are
    // statically initialized to.
    //
}


VOID
InitializeUniqueness(
    IN OUT HWND *Billboard
    )

/*++

Routine Description:

    Initialize uniquess by looking in a database file and overwriting the
    parameters file with information found in it, based in a unique identifier
    passed along to us from text mode (and originally winnt/winnt32).

    There are 2 options: the database was copied into the source path by winnt/
    winnt32, or we need to prompt the user to insert a floppy from his admin
    that contains the database.

    The user may elect to cancel, which means setup will continue, but the
    machine will probably not be configured properly.

Arguments:

    Billboard - on input contains handle of currently displayed "Setup is
        Initializing" billboard. On output contains new handle if this routine
        had to display UI. We pass this around to avoid annoying flashing of
        the billboard.

Returns:

    None.

--*/

{
    PWCHAR p;
    WCHAR UniquenessId[MAX_PARAM_LEN];
    WCHAR DatabaseFile[MAX_PATH];
    BOOL Prompt;
    int i;
    UINT OldMode;
    BOOL NeedNewBillboard;

    //
    // Determine whether uniqueness is even important by looking
    // for a uniqueness spec in the parameters file.
    // If the id ends with a * then we expect the uniqueness database file
    // to be in the source, with a reserved name. Otherwise we need to
    // prompt for it on a floppy.
    //
    if(SpSetupLoadParameter(WINNT_D_UNIQUENESS,UniquenessId,MAX_PARAM_LEN)) {
        if(p = wcschr(UniquenessId,L'*')) {
            *p = 0;
            Prompt = FALSE;
        } else {
            Prompt = TRUE;
        }
    } else {
        //
        // We don't care about uniqueness.
        //
        return;
    }

    //
    // If the file is already in the source, attempt to make use of it now.
    // If this fails tell the user and fall through to the floppy prompt case.
    //
    if(!Prompt) {
        lstrcpy(DatabaseFile,SourcePath);
        pSetupConcatenatePaths(DatabaseFile,WINNT_UNIQUENESS_DB,MAX_PATH,NULL);

        if(IntegrateUniquenessInfo(DatabaseFile,UniquenessId)) {
            return;
        }

        MessageBoxFromMessage(
            MainWindowHandle,
            MSG_UNIQUENESS_DB_BAD_1,
            NULL,
            IDS_WINNT_SETUP,
            MB_OK | MB_ICONERROR,
            UniquenessId
            );

        Prompt = TRUE;
    }

    lstrcpy(DatabaseFile,L"A:\\");
    lstrcat(DatabaseFile,WINNT_UNIQUENESS_DB);

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    if(Prompt) {
        KillBillboard(*Billboard);
        NeedNewBillboard = TRUE;
    } else {
        NeedNewBillboard = FALSE;
    }

    while(Prompt) {

        i = MessageBoxFromMessage(
                MainWindowHandle,
                MSG_UNIQUENESS_DB_PROMPT,
                NULL,
                IDS_WINNT_SETUP,
                MB_OKCANCEL
                );

        if(i == IDOK) {
            //
            // User thinks he provided a floppy with the database floppy on it.
            //
            if(IntegrateUniquenessInfo(DatabaseFile,UniquenessId)) {
                Prompt = FALSE;
            } else {
                MessageBoxFromMessage(
                    MainWindowHandle,
                    MSG_UNIQUENESS_DB_BAD_2,
                    NULL,
                    IDS_WINNT_SETUP,
                    MB_OK | MB_ICONERROR,
                    UniquenessId
                    );
            }

        } else {
            //
            // User cancelled -- verify.
            //
            i = MessageBoxFromMessage(
                    MainWindowHandle,
                    MSG_UNIQUENESS_DB_VERIFYCANCEL,
                    NULL,
                    IDS_WINNT_SETUP,
                    MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION
                    );

            Prompt = (i != IDYES);
        }
    }

    if(NeedNewBillboard) {
        *Billboard = DisplayBillboard(MainWindowHandle,MSG_INITIALIZING);
    }

    SetErrorMode(OldMode);
}


BOOL
IntegrateUniquenessInfo(
    IN PCWSTR DatabaseFile,
    IN PCWSTR UniqueId
    )

/*++

Routine Description:

    Apply uniqueness data from a database, based on a unique identifier.
    The unique identifier is looked up in the [UniqueIds] section of
    the database file. Each field on the line is the name of a section.
    Each section's data overwrites existing data in the unattend.txt file.

    [UniqueIds]
    Id1 = foo,bar

    [foo]
    a = ...
    b = ...

    [bar]
    y = ...

    etc.

Arguments:

    Database - supplies the name of the uniqueness database (which is
        opened as a legacy inf for simplicity in parsing).

    UniqueId - supplies the unique id for this computer.

Returns:

    Boolean value indicating outcome.

--*/

{
    HINF Database;
    INFCONTEXT InfLine;
    DWORD SectionCount;
    PCWSTR SectionName;
    DWORD i;
    BOOL b;

    //
    // Load the database file as a legacy inf. This makes processing it
    // a little easier.
    //
    Database = SetupOpenInfFile(DatabaseFile,NULL,INF_STYLE_OLDNT,NULL);
    if(Database == INVALID_HANDLE_VALUE) {
        b = FALSE;
        goto c0;
    }

    //
    // Look in the [UniqueIds] section to grab a list of sections
    // we need to overwrite for this user. If the unique id does not appear
    // in the database, bail now. If the id exists but there are no sections,
    // exit with success.
    //
    if(!SetupFindFirstLine(Database,L"UniqueIds",UniqueId,&InfLine)) {
        b = FALSE;
        goto c1;
    }

    SectionCount = SetupGetFieldCount(&InfLine);
    if(!SectionCount) {
        b = TRUE;
        goto c1;
    }

    //
    // Now process each section.
    //
    for(b=TRUE,i=0; b && (i<SectionCount); i++) {

        if(SectionName = pSetupGetField(&InfLine,i+1)) {

            b = ProcessOneUniquenessSection(Database,SectionName,UniqueId);

        } else {
            //
            // Strange case -- the field is there but we can't get at it.
            //
            b = FALSE;
            goto c1;
        }
    }

c1:
    SetupCloseInfFile(Database);
c0:
    return(b);
}


BOOL
ProcessOneUniquenessSection(
    IN HINF   Database,
    IN PCWSTR SectionName,
    IN PCWSTR UniqueId
    )

/*++

Routine Description:

    Within the uniqueness database, process a single section whose contents
    are to be merged into the unattend file. The contents of the section are
    read, key by key, and then written into the unattend file via profile APIs.

    Before looking for the given section, we try to look for a section whose
    name is composed of the unique id and the section name like so

        [someid:sectionname]

    If this section is not found then we look for

        [sectionname]

Arguments:

    Database - supplies handle to profile file (opened as a legacy inf)
        containing the uniqueness database.

    SectionName - supplies the name of the section to be merged into
        unattend.txt.

    UniqueId - supplies the unique id for this computer.

Returns:

    Boolean value indicating outcome.

--*/

{
    BOOL b;
    PWSTR OtherSection;
    PCWSTR section;
    LONG Count;
    DWORD FieldCount;
    DWORD j;
    LONG i;
    INFCONTEXT InfLine;
    PWCHAR Buffer;
    PWCHAR p;
    PCWSTR Key;

    Buffer = MyMalloc(MAX_INF_STRING_LENGTH * sizeof(WCHAR));
    if(!Buffer) {
        return(FALSE);
    }

    //
    // Form the name of the unique section.
    //
    if(OtherSection = MyMalloc((lstrlen(SectionName) + lstrlen(UniqueId) + 2) * sizeof(WCHAR))) {

        b = TRUE;

        lstrcpy(OtherSection,UniqueId);
        lstrcat(OtherSection,L":");
        lstrcat(OtherSection,SectionName);

        //
        // See whether this unique section exists and if not whether
        // the section name exists as given.
        //
        if((Count = SetupGetLineCount(Database,OtherSection)) == -1) {
            Count = SetupGetLineCount(Database,SectionName);
            section = (Count == -1) ? NULL : SectionName;
        } else {
            section = OtherSection;
        }

        if(section) {
            //
            // Process each line in the section. If a line doesn't have a key,
            // ignore it. If a line has only a key, delete the line in the target.
            //
            for(i=0; i<Count; i++) {

                SetupGetLineByIndex(Database,section,i,&InfLine);
                if(Key = pSetupGetField(&InfLine,0)) {
                    if(FieldCount = SetupGetFieldCount(&InfLine)) {

                        Buffer[0] = 0;

                        for(j=0; j<FieldCount; j++) {

                            if(j) {
                                lstrcat(Buffer,L",");
                            }

                            lstrcat(Buffer,L"\"");
                            lstrcat(Buffer,pSetupGetField(&InfLine,j+1));
                            lstrcat(Buffer,L"\"");
                        }

                        p = Buffer;

                    } else {

                        p = NULL;
                    }

                    if(!WritePrivateProfileString(SectionName,Key,p,AnswerFile)) {
                        //
                        // Failure, but keep trying in case others might work.
                        //
                        b = FALSE;
                    }
                }
            }

        } else {
            //
            // Unable to find a matching section. Bail.
            //
            b = FALSE;
        }

        MyFree(OtherSection);
    } else {
        b = FALSE;
    }

    MyFree(Buffer);
    return(b);
}


DWORD
InstallProductCatalogs(
    OUT SetupapiVerifyProblem *Problem,
    OUT LPWSTR                 ProblemFile,
    IN  LPCWSTR                DescriptionForError OPTIONAL
    )
/*++

Routine Description:

    This routine installs all catalog files specified in the
    [ProductCatalogsToInstall] section of syssetup.inf, and validates
    syssetup.inf (and any other INFs append-loaded into its HINF) against the
    catalog that's marked with a non-zero value in the second field of the line.

Arguments:

    Problem - Supplies the address of a variable that receives the type of
        verification error that occurred,  This is only valid if the routine
        returns failure.

    ProblemFile - Supplies a buffer of at least MAX_PATH characters that
        receives the name of the file that caused the verification failure.
        This is only valid if the routine returns failure.

    DescriptionForError - Optionally, supplies descriptive text to be used in a
        call to pSetupHandleFailedVerification() in case an error is encountered.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error
    code indicating the cause of the failure.  The Problem and ProblemFile
    parameters may be used in that case to provide more specific information
    about why the failure occurred.

--*/
{
    HINF hInf;
    LONG LineCount, LineNo;
    DWORD RequiredSize;
    WCHAR SyssetupInfName[MAX_PATH], DecompressedName[MAX_PATH];
    PSP_INF_INFORMATION InfInfoBuffer;
    INFCONTEXT InfContext;
    PCWSTR  SectionName = L"ProductCatalogsToInstall";
    PCWSTR  InfFileName;
    WCHAR CatToInstall[MAX_PATH], PromptPath[MAX_PATH];
    INT CatForInfVerify;
    DWORD Err = NO_ERROR, ret = NO_ERROR;
    UINT ErrorMessageId;
    BOOL PrimaryCatalogProcessed = FALSE;
    UINT i, SourceId;
    WCHAR TempBuffer[MAX_PATH];
    BOOL DeltaCatPresent=FALSE;
    BOOL OemTestSigned=FALSE;

    //
    // We open up syssetup.inf (and append load any layout INFs) here, just so
    // we can install the catalogs and verify the syssetup.inf and friends
    // against the 'primary' catalog.  Note that this isn't the global
    // SyssetupInf handle--that gets opened up later.  We can't open the global
    // HINF here, since there's stuff that gets done after this routine is
    // called that could potentially change the way we process the INF
    //

    //
    // Retrieve an INF information context containing information about all
    // append-loaded INFs in our syssetup.inf handle.  These INFs will all be
    // validated against our 'primary' catalog file once we discover it.
    //
    if(SetupGetInfInformation(SyssetupInf,
                              INFINFO_INF_SPEC_IS_HINF,
                              NULL,
                              0,
                              &RequiredSize)) {

        MYASSERT(RequiredSize >= sizeof(SP_INF_INFORMATION));

        if(InfInfoBuffer = MyMalloc(RequiredSize)) {

            if(!SetupGetInfInformation(SyssetupInf,
                                       INFINFO_INF_SPEC_IS_HINF,
                                       InfInfoBuffer,
                                       RequiredSize,
                                       NULL)) {
                //
                // This should never fail!
                //
                Err = GetLastError();
                MYASSERT(0);

            }

        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {
        Err = GetLastError();
        InfInfoBuffer = NULL;
    }

    //
    // If we encountered an error, then we couldn't retrieve information about
    // the loaded INFs in syssetup.inf's HINF--this should never happen
    // (barring an out-of-memory condition), but if it does, just bail.
    //
    if(Err != NO_ERROR) {
        *Problem = SetupapiVerifyInfProblem;
        lstrcpy(ProblemFile, L"syssetup.inf");
        goto clean0;
    }

    //
    // If there's a [SourceDisksFiles] entry for testroot.cer in one of the
    // append-loaded INFs in syssetup.inf's HINF (specifically, from
    // layout.inf), then we will go and install that test certificate in the
    // root store so that the test signatures used for this internal-release-only
    // build will be verified.  We will also install a test root certificate if
    // one is specified in unattend.txt in the "TestCert" entry in the
    // [unattended] section.
    //
    // If testroot.cer isn't listed in one of the two aforementioned locations,
    // then we know the files in this build were signed for real, so we want to
    // delete the test certificate(s), in case we're updating an installation
    // that was installed previously using a test-signed build.
    //
    if(SetupGetSourceFileLocation(SyssetupInf, NULL, L"testroot.cer", &SourceId, NULL, 0, NULL)) {
        //
        // Testroot.cer must exist (possibly compressed) in the source
        // directory. (Regardless of whether testroot.cer is compressed, use
        // the DecompressedName buffer to temporarily hold this filename.)
        //
        lstrcpy(DecompressedName, L"testroot.cer");

    } else {

        GetSystemDirectory(TempBuffer, MAX_PATH);
        pSetupConcatenatePaths(TempBuffer, WINNT_GUI_FILE, MAX_PATH, NULL);

        if(GetPrivateProfileString(WINNT_UNATTENDED,
                                   WINNT_U_TESTCERT,
                                   pwNull,
                                   DecompressedName,
                                   MAX_PATH,
                                   TempBuffer)) {

            OemTestSigned = TRUE;
        }
    }

    if(*DecompressedName) {

        Err = SetupAddOrRemoveTestCertificate(
                  DecompressedName,
                  (OemTestSigned ? INVALID_HANDLE_VALUE : SyssetupInf)
                 );

        if(Err != NO_ERROR) {
            SetupDebugPrint2(L"SETUP: SetupAddOrRemoveTestCertificate(%ls) failed. Error = %d \n", DecompressedName, Err );
            //
            // This is considered a critial failure--as we could bugcheck post - setup.
            //

            SetuplogError(LogSevError,
                          SETUPLOG_USE_MESSAGEID,
                          MSG_LOG_SYSSETUP_CERT_NOT_INSTALLED,
                          DecompressedName,
                          Err,
                          NULL,
                          SETUPLOG_USE_MESSAGEID,
                          Err,
                          NULL,
                          NULL
                         );

            //
            // If this was an internal test-signed build, then point the
            // accusing finger at syssetup.inf.
            //
            if(!OemTestSigned) {
                *Problem = SetupapiVerifyInfProblem;
                lstrcpy(ProblemFile, L"syssetup.inf");
            } else {
                *Problem = SetupapiVerifyCatalogProblem;
                lstrcpy(ProblemFile, DecompressedName);
            }

            if(InfInfoBuffer)
                    MyFree(InfInfoBuffer);

            return Err;


        }

    } else {
        //
        // testroot.cer isn't listed--remove it from the installation in case
        // we're upgrading over an internal-release-only test build.
        //
        MYASSERT(GetLastError() == ERROR_LINE_NOT_FOUND);
        Err = SetupAddOrRemoveTestCertificate(NULL,NULL);
        if(Err != NO_ERROR) {
            SetupDebugPrint1(L"SETUP: SetupAddOrRemoveTestCertificate(NULL) failed. Error = %d \n", Err );
            //
            // This is not considered a critial failure.
            //
            Err = NO_ERROR;
        }
    }

    //
    // Loop through all the lines in the ProductCatalogsToInstall section,
    // verifying and installing each one.
    //
    LineCount = SetupGetLineCount(SyssetupInf, SectionName);
    for(LineNo=0; LineNo<LineCount+1; LineNo++) {

        if(LineNo==LineCount){
            if(IncludeCatalog && *IncludeCatalog ){
                DeltaCatPresent = TRUE;             // This indicates presence as well as says that we
            }else                                   // are looking at delta.cat in this iteration.
                break;


        }

        if((SetupGetLineByIndex(SyssetupInf, SectionName, LineNo, &InfContext)
           && (InfFileName = pSetupGetField(&InfContext,1))) || DeltaCatPresent ) {

            if( DeltaCatPresent )
                InfFileName = IncludeCatalog;

            //
            // This .CAT file might be compressed (e.g., .CA_), so decompress it
            // into a temporary file in the windows directory.  (Use CatToInstall
            // temporarily as a holding space for the windows directory in
            // preparation for a call to GetTempFileName).
            //
            if(!GetWindowsDirectory(CatToInstall, SIZECHARS(CatToInstall)) ||
               !GetTempFileName(CatToInstall, L"SETP", 0, DecompressedName)) {

                Err = GetLastError();
                if(InfInfoBuffer)
                    MyFree(InfInfoBuffer);

                return Err;
            }

            //
            // The catalog file will be in the (platform-specific) source
            // directory...
            //
            BuildPathToInstallationFile (InfFileName, CatToInstall, SIZECHARS(CatToInstall));

            //
            // If the 2nd field of this line has a non-zero value, then this is
            // the catalog against which the members of the HINF must be
            // verified.
            //
            if(!DeltaCatPresent && !SetupGetIntField(&InfContext, 2, &CatForInfVerify)) {
                CatForInfVerify = 0;
            }



            //
            // Get necessary strings and source ID for UI if needed.
            //

            if( DeltaCatPresent ){

                Err = SetupDecompressOrCopyFile(CatToInstall,
                                                DecompressedName,
                                                NULL);

            }else{



                SetupGetSourceFileLocation(
                            SyssetupInf,
                            NULL,
                            InfFileName,
                            &SourceId,   //re-using
                            NULL,
                            0,
                            NULL
                            );

                SetupGetSourceInfo(
                            SyssetupInf,
                            SourceId,
                            SRCINFO_DESCRIPTION,
                            TempBuffer,
                            sizeof(TempBuffer),
                            NULL
                            );

                //
                // This .CAT file might be compressed (e.g., .CA_), so decompress it
                // into a temporary file in the windows directory.
                //


                do{

                    Err = DuSetupPromptForDisk (
                                MainWindowHandle,
                                NULL,
                                TempBuffer,
                                LegacySourcePath,
                                InfFileName,
                                NULL,
                                IDF_CHECKFIRST | IDF_NODETAILS | IDF_NOBROWSE,
                                PromptPath,
                                MAX_PATH,
                                NULL
                                );


                    if( Err == DPROMPT_SUCCESS ){

                        lstrcpy( CatToInstall, PromptPath );
                        pSetupConcatenatePaths(CatToInstall, InfFileName, SIZECHARS(CatToInstall), NULL);

                        Err = SetupDecompressOrCopyFile(CatToInstall,
                                                        DecompressedName,
                                                        NULL);
                    }




                }while( Err == ERROR_NOT_READY );
            }

            if(Err != NO_ERROR){

                if( lstrcmpi(InfFileName, L"NT5.CAT") && !CatForInfVerify ){
                    SetuplogError(LogSevError,
                              SETUPLOG_USE_MESSAGEID,
                              MSG_LOG_SYSSETUP_CATFILE_SKIPPED,
                              CatToInstall,
                              NULL,
                              SETUPLOG_USE_MESSAGEID,
                              Err,
                              NULL,
                              NULL
                             );
                    Err = NO_ERROR;
                    continue;
                }
                else{
                    SetuplogError(LogSevError,
                              SETUPLOG_USE_MESSAGEID,
                              MSG_LOG_SYSSETUP_CATFILE_NOT_FOUND,
                              CatToInstall,
                              Err,
                              NULL,
                              SETUPLOG_USE_MESSAGEID,
                              Err,
                              NULL,
                              NULL
                             );
                }

                if(InfInfoBuffer)
                        MyFree(InfInfoBuffer);

                return Err;                //Fatal (NT5.cat or NT5INF.cat)- must fail as we could bugcheck later
            }



            if(CatForInfVerify) {

                PrimaryCatalogProcessed = TRUE;

                //
                // Verify all INFs in syssetup.inf's HINF using this catalog.
                //
                for(i = 0;
                    ((Err == NO_ERROR) && (i < InfInfoBuffer->InfCount));
                    i++)
                {
                    if(!SetupQueryInfFileInformation(InfInfoBuffer,
                                                     i,
                                                     SyssetupInfName,
                                                     SIZECHARS(SyssetupInfName),
                                                     NULL)) {
                        //
                        // This should never fail!
                        //
                        MYASSERT(0);
                        //
                        // Just use syssetup.inf's simple name so there'll
                        // be some clue as to what blew up.
                        //
                        lstrcpy(ProblemFile, L"syssetup.inf");
                        *Problem = SetupapiVerifyInfProblem;
                        Err = GetLastError();
                        MYASSERT(Err != NO_ERROR);
                        break;
                    }

                    Err = pSetupVerifyFile(NULL,
                                     DecompressedName,
                                     NULL,
                                     0,
                                     pSetupGetFileTitle(SyssetupInfName),
                                     SyssetupInfName,
                                     Problem,
                                     ProblemFile,
                                     FALSE,
                                     NULL,
                                     NULL,
                                     NULL
                                    );
                }

                if(Err != NO_ERROR) {
                    //
                    // Just return the error--the caller will deal with it.
                    //
                    if(*Problem == SetupapiVerifyCatalogProblem) {
                        //
                        // Use the catalog's original name, not our temporary
                        // filename.
                        //
                        lstrcpy(ProblemFile, CatToInstall);
                    } else {
                        //
                        // pSetupVerifyCatalogFile didn't know we were asking it to verify an
                        // INF, but we do.
                        //
                        *Problem = SetupapiVerifyInfProblem;
                    }
                    DeleteFile(DecompressedName);
                    goto clean0;
                }

                //
                // OK, catalog and INF both verify--now install the catalog.
                //

                Err = pSetupInstallCatalog(DecompressedName, InfFileName, NULL);

                if(Err != NO_ERROR) {
                    //
                    // Fill out problem information about the catalog we couldn't
                    // install, and return this error to the caller.
                    //
                    *Problem = SetupapiVerifyCatalogProblem;
                    lstrcpy(ProblemFile, CatToInstall);
                    DeleteFile(DecompressedName);
                    goto clean0;
                }

            } else {


                //
                // Just verify the catalog, and if it's OK, then install it.
                // (If we encounter any errors here, we'll log an event about it.
                //

                Err = pSetupVerifyCatalogFile(DecompressedName);


                if(Err == NO_ERROR) {
                    Err = pSetupInstallCatalog(DecompressedName, InfFileName, NULL);
                    if(Err != NO_ERROR) {
                        ErrorMessageId = MSG_LOG_SYSSETUP_CATINSTALL_FAILED;
                    }
                } else {
                    ErrorMessageId = MSG_LOG_SYSSETUP_VERIFY_FAILED;
                }

                if(Err != NO_ERROR) {
                    DWORD DontCare;

                    SetuplogError(LogSevError,
                                  SETUPLOG_USE_MESSAGEID,
                                  ErrorMessageId,
                                  CatToInstall,
                                  Err,
                                  NULL,
                                  SETUPLOG_USE_MESSAGEID,
                                  Err,
                                  NULL,
                                  NULL
                                 );

                    //
                    // Also, add an entry about this failure to setupapi's PSS
                    // exception logfile.
                    //
                    pSetupHandleFailedVerification(MainWindowHandle,
                                             SetupapiVerifyCatalogProblem,
                                             CatToInstall,
                                             DescriptionForError,
                                             pSetupGetCurrentDriverSigningPolicy(FALSE),
                                             TRUE,  // no UI!
                                             Err,
                                             NULL,  // log context
                                             NULL, // optional flags
                                             NULL
                                            );


                    if( !lstrcmpi(InfFileName, L"NT5.CAT") ){      //Special case NT5.CAT as critical failure
                        *Problem = SetupapiVerifyCatalogProblem;   //Otherwise just log it and move on
                        lstrcpy(ProblemFile, CatToInstall);
                        DeleteFile(DecompressedName);
                        goto clean0;
                    }else
                        Err = NO_ERROR;


                }
            }

            //
            // Delete the temporary file we created to hold the decompressed
            // catalog during verification/installation.
            //

            DeleteFile(DecompressedName);
        }
    }

clean0:

    if(!PrimaryCatalogProcessed) {
        //
        // Then we didn't find a line in our ProductCatalogsToInstall section
        // that was marked as the 'primary' catalog.  Point the accusing finger
        // at syssetup.inf.
        //
        if(!SetupQueryInfFileInformation(InfInfoBuffer,
                                         0,
                                         ProblemFile,
                                         MAX_PATH,
                                         NULL)) {
            //
            // This should never fail!
            //
            MYASSERT(0);
            //
            // Just use syssetup.inf's simple name so there'll be some clue as
            // to what blew up.
            //
            lstrcpy(ProblemFile, L"syssetup.inf");
        }

        *Problem = SetupapiVerifyInfProblem;
        Err = ERROR_LINE_NOT_FOUND;
    }

    if(InfInfoBuffer) {
        MyFree(InfInfoBuffer);
    }

    return Err;
}

DWORD
SetupInstallCatalog(
    IN LPCWSTR DecompressedName
    )
{
    PCWSTR  InfFileName = pSetupGetFileTitle(DecompressedName);
    DWORD   Err;
    UINT    ErrorMessageId;

    Err = pSetupVerifyCatalogFile(DecompressedName);

    if(Err == NO_ERROR) {
        Err = pSetupInstallCatalog(DecompressedName, InfFileName, NULL);
        if(Err != NO_ERROR) {
            ErrorMessageId = MSG_LOG_SYSSETUP_CATINSTALL_FAILED;
        }
    } else {
        ErrorMessageId = MSG_LOG_SYSSETUP_VERIFY_FAILED;
    }

    if(Err != NO_ERROR) {

        SetuplogError(LogSevError,
                      SETUPLOG_USE_MESSAGEID,
                      ErrorMessageId,
                      DecompressedName,
                      Err,
                      NULL,
                      SETUPLOG_USE_MESSAGEID,
                      Err,
                      NULL,
                      NULL
                     );
    }

    return Err;
}

VOID
InitializeCodeSigningPolicies(
    IN BOOL ForGuiSetup
    )
/*++

Routine Description:

    Sets up the system-default policy values for driver and non-driver signing.
    These policies control what action is taken when a digital signature
    verification failure is encountered.  The possible values are:

    Ignore (0) -- suppress any UI and continue with the operation (we do still
                  log the error, however)
    Warn (1)   -- warn the user, giving them the option of continuing in spite
                  of the verification failure
    Block (2)  -- inform the user of the failure, and do not allow them to
                  continue with the operation

    The registry path for driver signing policy is:

        HKLM\Software\Microsoft\Driver Signing

    and the registry path for non-driver signing policy is:

        HKLM\Software\Microsoft\Non-Driver Signing

    In both cases, the value entry is called "Policy".  For Win98 compatibility,
    this value is a REG_BINARY (length 1).  However, when the codesigning stuff
    was first checked in on NT, it was implemented as a REG_DWORD.  At that
    time, the default policy was ignore.  We now want the default to be warn for
    both driver and non-driver signing during GUI-mode setup, while dropping the
    non-driver signing policy back to ignore once GUI-mode setup is completed.
    (If answerfile values are specified for either of these policies, those
    values are in effect for GUI-mode setup and thereafter.)

    When upgrading from previous builds (in the absence of answerfile entries),
    we want to preserve the existing policy settings once GUI-mode setup is
    completed.  However, we'd like to raise the policy level to warn post-setup
    for upgrades from older builds (like beta 2).  We use the aforementioned
    difference between the present REG_BINARY type and the old REG_DWORD type to
    accomplish this.  If we retrieve the existing driver signing policy and its
    data type is REG_DWORD, then we update it to be set to warn (unless it's
    already set to block, in which case we leave it alone).

Arguments:

    ForGuiSetup - if non-zero (TRUE), then we're entering GUI-mode setup, and
        we'll apply the answerfile policies, if provided.  Otherwise, we'll use
        the same default values that are in-place post-setup.  (Presently, this
        is Warn for driver signing, and Ignore for non-driver signing.)

        If zero (FALSE), we're leaving GUI-mode setup, and we want to restore
        the policies that were in effect when we entered setup.  If there
        weren't any (i.e., a fresh install) then they were initialized to warn
        and ignore for driver and non-driver signing, respectively.  See
        discussion above for how we raise driver signing policy from its old
        default of ignore to the present default of warn.

Return Value:

    None

--*/
{
    WCHAR p[MAX_PARAM_LEN];
    BYTE SpDrvSignPolicy, SpNonDrvSignPolicy;
    LONG Err;

    if(ForGuiSetup) {

        //
        // Default in GUI-mode setup is that driver signing policy is set to
        // warn, and non-driver signing policy is set to ignore.
        //
        SpDrvSignPolicy = DRIVERSIGN_WARNING;
        SpNonDrvSignPolicy = DRIVERSIGN_NONE;

        //
        // Retrieve the (optional) system-default policy for driver signing.
        //
        if(SpSetupLoadParameter(pwDrvSignPol,p,MAX_PARAM_LEN)) {
            if(!lstrcmpi(p, pwIgnore)) {
                AFDrvSignPolicySpecified = TRUE;
                SpDrvSignPolicy = DRIVERSIGN_NONE;
            } else if(!lstrcmpi(p, pwWarn)) {
                AFDrvSignPolicySpecified = TRUE;
                SpDrvSignPolicy = DRIVERSIGN_WARNING;
            } else if(!lstrcmpi(p, pwBlock)) {
                AFDrvSignPolicySpecified = TRUE;
                SpDrvSignPolicy = DRIVERSIGN_BLOCKING;
            }
        }

        SetCodeSigningPolicy(PolicyTypeDriverSigning,
                             SpDrvSignPolicy,
                             (AFDrvSignPolicySpecified
                                 ? NULL
                                 : &DrvSignPolicy)
                            );

        //
        // Now retrieve the (optional) system-default policy for non-driver
        // signing.
        //
        if(SpSetupLoadParameter(pwNonDrvSignPol,p,MAX_PARAM_LEN)) {
            if(!lstrcmpi(p, pwIgnore)) {
                AFNonDrvSignPolicySpecified = TRUE;
                SpNonDrvSignPolicy = DRIVERSIGN_NONE;
            } else if(!lstrcmpi(p, pwWarn)) {
                AFNonDrvSignPolicySpecified = TRUE;
                SpNonDrvSignPolicy = DRIVERSIGN_WARNING;
            } else if(!lstrcmpi(p, pwBlock)) {
                AFNonDrvSignPolicySpecified = TRUE;
                SpNonDrvSignPolicy = DRIVERSIGN_BLOCKING;
            }
        }

        SetCodeSigningPolicy(PolicyTypeNonDriverSigning,
                             SpNonDrvSignPolicy,
                             (AFNonDrvSignPolicySpecified
                                 ? NULL
                                 : &NonDrvSignPolicy)
                            );

    } else {
        //
        // We're setting up the policies to be in effect after GUI-mode setup.
        // If the answer file specified a policy, then we'll leave that in
        // effect (i.e., it's applicable both during GUI-mode setup and
        // thereafter).
        //
        if(!AFDrvSignPolicySpecified) {
            SetCodeSigningPolicy(PolicyTypeDriverSigning, DrvSignPolicy, NULL);
        }

        if(!AFNonDrvSignPolicySpecified) {
            SetCodeSigningPolicy(PolicyTypeNonDriverSigning, NonDrvSignPolicy, NULL);
        }
    }
}


VOID
InstallPrivateFiles(
    IN HWND Billboard
    )
/*
    Routine to make sure that files in delta.inf (winnt32 /m private files that live inside the cab)
    are copied to the driver cache directory so that setupapi finds them instead of the ones in the
    cab.

*/
{
    WCHAR DeltaPath[MAX_PATH];
    HINF DeltaInf;
    HSPFILEQ FileQueue;
    PVOID QContext;
    BOOL b=TRUE;
    BYTE PrevPolicy;
    BOOL ResetPolicy = TRUE;

    //
    // Unless the default non-driver signing policy was overridden via an
    // answerfile entry, then we want to temporarily turn down the policy level
    // to ignore while we copy optional directories.  Of course, setupapi log
    // entries will still be generated for any unsigned files copied during
    // this time, but there'll be no UI.
    //



    if(!AFNonDrvSignPolicySpecified) {
        SetCodeSigningPolicy(PolicyTypeNonDriverSigning, DRIVERSIGN_NONE, &PrevPolicy);
        ResetPolicy = TRUE;
    }

    BuildPathToInstallationFileEx (L"delta.inf", DeltaPath, MAX_PATH, FALSE);

    FileQueue = SetupOpenFileQueue();
    b = b && (FileQueue != INVALID_HANDLE_VALUE);
    b = b && FileExists( DeltaPath, NULL );

    if(b){

        DeltaInf = SetupOpenInfFile(DeltaPath,NULL,INF_STYLE_WIN4,NULL);
        if(DeltaInf && (DeltaInf != INVALID_HANDLE_VALUE)) {

            SetupInstallFilesFromInfSection(
                DeltaInf,
                NULL,
                FileQueue,
                L"InstallSection",
                LegacySourcePath,
                SP_COPY_NEWER
                );

            SetupCloseInfFile(DeltaInf);
        } else {
            b = FALSE;
        }
    }
    if( b ){

        QContext = InitSysSetupQueueCallbackEx(
                    Billboard,
                    INVALID_HANDLE_VALUE,
                    0,0,NULL);
        if (QContext) {

            b = SetupCommitFileQueue(
                    Billboard,
                    FileQueue,
                    SysSetupQueueCallback,
                    QContext
                    );

            TermSysSetupQueueCallback(QContext);
        } else {
            b = FALSE;
        }
    }

    if(FileQueue != INVALID_HANDLE_VALUE)
        SetupCloseFileQueue(FileQueue);

    //
    // Now crank the non-driver signing policy back up to what it was prior to
    // entering this routine.
    //

    if(ResetPolicy) {
        SetCodeSigningPolicy(PolicyTypeNonDriverSigning, PrevPolicy, NULL);
    }

    return;

}

BOOL
IsCatalogPresent(
    IN PCWSTR CatalogName
    )
{
    WCHAR FileBuffer[MAX_PATH];

    ExpandEnvironmentStrings( L"%systemroot%", FileBuffer, sizeof(FileBuffer)/sizeof(WCHAR));
    pSetupConcatenatePaths( FileBuffer, FILEUTIL_HORRIBLE_PATHNAME, MAX_PATH, NULL );
    pSetupConcatenatePaths( FileBuffer, CatalogName, MAX_PATH, NULL );

    return (FileExists( FileBuffer, NULL));
}

BOOL
CALLBACK 
CatalogListCallback(
    IN PCWSTR Directory OPTIONAL, 
    IN PCWSTR FilePath
    )
/*++

Routine Description:

    This is the callback function for enumerating catalogs in a directory.

Arguments:

    Directory - If not NULL or empty, it will be prepended to FilePath to build the file path
    FilePath -  Path (including file name) to the file to verify

Return value:

    TRUE if the file is a catalog, FALSE otherwise.

--*/
{
    BOOL bRet = FALSE;
    PWSTR szPath = NULL;
    DWORD Error;

    if(NULL == FilePath || 0 == FilePath[0]) {
        goto exit;
    }

    if(Directory != NULL && Directory[0] != 0) {
        szPath = MyMalloc(MAX_PATH * sizeof(WCHAR));

        if(NULL == szPath) {
            goto exit;
        }

        wcsncpy(szPath, Directory, MAX_PATH - 1);
        szPath[MAX_PATH - 1] = 0;
        
        if(!pSetupConcatenatePaths(szPath, FilePath, MAX_PATH, NULL)) {
            goto exit;
        }

        FilePath = szPath;
    }

    bRet = IsCatalogFile(INVALID_HANDLE_VALUE, (PWSTR) FilePath);

exit:
    if(szPath != NULL) {
        MyFree(szPath);
    }

    return bRet;
}

DWORD
DeleteOldCatalogs(
    VOID
    )
/*++

Routine Description:

    This routine deletes the catalogs specified by the ProductCatalogsToUninstall section of syssetup.inf.
    It does not delete any system catalogs (i.e. specified by the ProductCatalogsToInstall section of the same inf) since
    they will be installed after this function completes.

Arguments:

    None.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error
    code indicating the cause of the failure.

--*/
{
    DWORD Error = NO_ERROR;
    HINF hInf = INVALID_HANDLE_VALUE;
    HCATADMIN hCatAdmin = NULL;
    PTSTR szCatPath = NULL;
    LIST_ENTRY InstalledCatalogsList;
    LONG lLines;
    LONG i;
    PCWSTR szInstallSection = L"ProductCatalogsToInstall";
    PCWSTR szUninstallSection = L"ProductCatalogsToUninstall";
    InitializeListHead(&InstalledCatalogsList);

    if(!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
        Error = GetLastError();
        goto exit;
    }

    //
    // Uninstall exception package catalogs first; this could cleanup the list of installed catalogs a bit
    //
    SpUninstallExcepPackCatalogs(hCatAdmin);
    szCatPath = (PTSTR) MyMalloc(MAX_PATH * sizeof(TCHAR));

    if(NULL == szCatPath) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Build the list of installed catalogs
    //
    GetWindowsDirectory(szCatPath, MAX_PATH);

    if(!pSetupConcatenatePaths(szCatPath, FILEUTIL_HORRIBLE_PATHNAME, MAX_PATH, NULL)) {
        Error = ERROR_BAD_PATHNAME;
        goto exit;
    }

    Error = BuildFileListFromDir(szCatPath, NULL, 0, FILE_ATTRIBUTE_DIRECTORY, CatalogListCallback, &InstalledCatalogsList);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // Remove the system catalogs from the installed catalogs list since we don't want to delete them
    //
    hInf = SetupOpenInfFile(L"syssetup.inf", NULL, INF_STYLE_WIN4, NULL);

    if(INVALID_HANDLE_VALUE == hInf) {
        Error = GetLastError();
        goto exit;
    }

    lLines = SetupGetLineCount(hInf, szInstallSection);

    for(i = 0; i < lLines; ++i) {
        INFCONTEXT ctx;
        PCWSTR szCatName;
        PSTRING_LIST_ENTRY pString;
        
        if(!SetupGetLineByIndex(hInf, szInstallSection, i, &ctx)) {
            Error = GetLastError();
            goto exit;
        }

        szCatName = pSetupGetField(&ctx, 1);

        if(NULL == szCatName) {
            Error = GetLastError();
            goto exit;
        }

        pString = SearchStringInList(&InstalledCatalogsList, szCatName, FALSE);

        if(pString != NULL) {
            RemoveEntryList(&pString->Entry);
            FreeStringEntry(&pString->Entry, TRUE);
        }
    }

    if(InstalledCatalogsList.Flink == &InstalledCatalogsList) {
        //
        // No catalogs left
        //
        goto exit;
    }
    //
    // Uninstall every catalog in the uninstall list
    //
    lLines = SetupGetLineCount(hInf, szUninstallSection);

    for(i = 0; i < lLines; ++i) {
        INFCONTEXT ctx;
        PCWSTR szCatName;
        PCWSTR szAttribName;
        PCWSTR szAttribValue;
        
        if(!SetupGetLineByIndex(hInf, szUninstallSection, i, &ctx)) {
            Error = GetLastError();
            goto exit;
        }

        szCatName = pSetupGetField(&ctx, 1);

        if(NULL == szCatName) {
            Error = GetLastError();
            goto exit;
        }

        szAttribName = pSetupGetField(&ctx, 2);
        szAttribValue = pSetupGetField(&ctx, 3);

        if(0 == szCatName[0]) {
            PLIST_ENTRY pEntry;

            //
            // If the name is not specified, an attribute or a value must be specified
            //
            if((NULL == szAttribName || 0 == szAttribName[0]) && (NULL == szAttribValue || 0 == szAttribValue[0])) {
                Error = ERROR_INVALID_DATA;
                goto exit;
            }

            //
            // Uninstall every catalog with the attribute name/value specified
            //
            pEntry = InstalledCatalogsList.Flink;

            while(pEntry != &InstalledCatalogsList) {
                //
                // Save Flink since SpUninstallCatalog might destroy pEntry
                //
                PLIST_ENTRY Flink = pEntry->Flink;
                PSTRING_LIST_ENTRY pString = CONTAINING_RECORD(pEntry, STRING_LIST_ENTRY, Entry);
                SpUninstallCatalog(hCatAdmin, pString->String, szCatPath, szAttribName, szAttribValue, &InstalledCatalogsList);
                pEntry = Flink;
            }
        } else {
            SpUninstallCatalog(hCatAdmin, szCatName, szCatPath, szAttribName, szAttribValue, &InstalledCatalogsList);
        }
    }

exit:
    FreeStringList(&InstalledCatalogsList);
    
    if(szCatPath != NULL) {
        MyFree(szCatPath);
    }

    if(NULL != hCatAdmin) {
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return Error;
}

VOID
GetDllCacheFolder(
    OUT LPWSTR CacheDir,
    IN DWORD cbCacheDir
    )
{
    DWORD retval;
    DWORD Type,Length;
    PWSTR RegData;

    if ((retval = QueryValueInHKLM(
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
            L"SFCDllCacheDir",
            &Type,
            (PVOID)&RegData,
            &Length)) != NO_ERROR) {
        ExpandEnvironmentStrings(
                            L"%systemroot%\\system32\\dllcache",
                            CacheDir,
                            cbCacheDir );
    } else {
        ExpandEnvironmentStrings(
                            RegData,
                            CacheDir,
                            cbCacheDir );
        MyFree(RegData);
    }
}


DWORD
CleanOutDllCache(
    VOID
    )
/*++

Routine Description:

    This routine cleans out the current dllcache contents.

Arguments:

    None.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    DWORD retval = ERROR_SUCCESS, DeleteError = ERROR_SUCCESS;
    WIN32_FIND_DATA FindFileData;
    WCHAR CacheDir[MAX_PATH];
    HANDLE hFind;
    PWSTR p;

    GetDllCacheFolder(CacheDir, MAX_PATH);



    MYASSERT(*CacheDir != L'\0');

    pSetupConcatenatePaths( CacheDir, L"*", MAX_PATH, NULL );

    //
    // save pointer to directory
    //
    p = wcsrchr( CacheDir, L'\\' );
    if (!p) {
        ASSERT(FALSE);
        retval = ERROR_INVALID_DATA;
        goto exit;
    }

    p += 1;

    hFind = FindFirstFile( CacheDir, &FindFileData );
    if (hFind == INVALID_HANDLE_VALUE) {
        retval = GetLastError();
        goto exit;
    }

    do {
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            wcscpy( p, FindFileData.cFileName );
            SetFileAttributes( CacheDir, FILE_ATTRIBUTE_NORMAL );
            if (!DeleteFile( CacheDir )) {
                DeleteError = GetLastError();
            }
        }
    } while(FindNextFile( hFind, &FindFileData ));

    FindClose( hFind );

    retval = DeleteError;

exit:
    return(retval);

}


DWORD
PrepDllCache(
    VOID
    )
/*++

Routine Description:

    This routine prepares the dllcache for later on in setup.  It cleans out
    the current dllcache contents and copies in a copy of the system catalog
    files.

Arguments:

    None.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error
    code indicating the cause of the failure.

--*/
{
    DWORD retval = ERROR_SUCCESS;
    WCHAR CacheDir[MAX_PATH];
    HANDLE h;
    USHORT Compression = COMPRESSION_FORMAT_DEFAULT;
    DWORD Attributes;
    BOOL b = FALSE;

    PWSTR RegData;
    DWORD Type,Length;
    HSPFILEQ hFileQ = INVALID_HANDLE_VALUE;
    PVOID Context;
    DWORD Count,i;

    if (MiniSetup) {
        retval = ERROR_SUCCESS;
        goto e0;
    }

    //
    // clean out old dllcache
    //
    CleanOutDllCache();

    //
    // Configure the registry for the DllCache.
    //
    ConfigureSystemFileProtection();

    //
    // get the path to the dllcache.
    //
    if ((retval = QueryValueInHKLM(
                        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                        L"SFCDllCacheDir",
                        &Type,
                        (PVOID)&RegData,
                        &Length)) != NO_ERROR) {
        ExpandEnvironmentStrings(
                            L"%systemroot%\\system32\\dllcache",
                            CacheDir,
                            MAX_PATH );
    } else {
        ExpandEnvironmentStrings(
                            RegData,
                            CacheDir,
                            MAX_PATH );
        MyFree(RegData);
    }

    //
    // set attributes on dllcache (hidden, system, compressed...)
    //
    Attributes = GetFileAttributes(CacheDir);


    if (Attributes == 0xffffffff) {
        CreateDirectory( CacheDir, NULL );
        Attributes = GetFileAttributes(CacheDir);
    }

    if (!(Attributes & FILE_ATTRIBUTE_COMPRESSED)) {

        Attributes = FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM;
        SetFileAttributes( CacheDir, FILE_ATTRIBUTE_NORMAL );

        h = CreateFile(
            CacheDir,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
            INVALID_HANDLE_VALUE
            );

        if (h == INVALID_HANDLE_VALUE) {
            SetFileAttributes( CacheDir, Attributes );
            retval = GetLastError();
            goto e0;
        }

        DeviceIoControl(
                h,
                FSCTL_SET_COMPRESSION,
                &Compression,
                sizeof(Compression),
                NULL,
                0,
                &retval,
                NULL
                );

        CloseHandle( h );
        SetFileAttributes( CacheDir, Attributes );

    }

    //
    // copy system catalogs into the dllcache
    //
    MYASSERT( SyssetupInf != NULL );

    hFileQ = SetupOpenFileQueue();
    if (hFileQ == INVALID_HANDLE_VALUE) {
        retval = GetLastError();
        goto e0;
    }

    Context = InitSysSetupQueueCallbackEx(
                                MainWindowHandle,
                                INVALID_HANDLE_VALUE,
                                0,
                                0,
                                NULL);
    if (!Context) {
        retval = GetLastError();
        goto e1;
    }

    Count = SetupGetLineCount( SyssetupInf, L"ProductCatalogsToInstall");
    for (i = 0; i < Count; i++) {

        INFCONTEXT InfContext;
        WCHAR CatalogName[MAX_PATH];
        BOOL SuccessfullyValidatedOrRestoredACatalog = FALSE;
        if(SetupGetLineByIndex(
                        SyssetupInf,
                        L"ProductCatalogsToInstall",
                        i,
                        &InfContext) &&
           (SetupGetStringField(
                        &InfContext,
                        1,
                        CatalogName,
                        sizeof(CatalogName)/sizeof(WCHAR),
                        NULL))) {
                if (!SetupQueueCopy(
                            hFileQ,
                            DuDoesUpdatedFileExist (CatalogName) ? DuGetUpdatesPath () : LegacySourcePath,
                            NULL,
                            CatalogName,
                            NULL,
                            NULL,
                            CacheDir,
                            NULL,
                            0
                            )) {
                retval = GetLastError();
                goto e2;
            }
        }
    }

    if (!SetupCommitFileQueue(
                MainWindowHandle,
                hFileQ,
                SysSetupQueueCallback,
                Context)) {
        retval = GetLastError();
        goto e2;
    }

    retval = ERROR_SUCCESS;

e2:
    TermSysSetupQueueCallback(Context);
e1:
    SetupCloseFileQueue( hFileQ );
e0:
    return(retval);
}

DWORD
SpUninstallCatalog(
    IN HCATADMIN CatAdminHandle OPTIONAL,
    IN PCWSTR CatFileName,
    IN PCWSTR CatFilePath OPTIONAL,
    IN PCWSTR AttributeName OPTIONAL,
    IN PCWSTR AttributeValue OPTIONAL,
    IN OUT PLIST_ENTRY InstalledCatalogsList OPTIONAL
    )
/*++

Routine Description:

    This function uninstalls the specified catalog based on a list of installed catalogs and a pair of attribute name/value.

Arguments:

    CatAdminHandle -        Handle to crypto context. If NULL, the function will open a context and close it upon exit.
    CatFileName -           Name of the catalog (without any path) to be uninstalled.
    CatFilePath -           If specified, specifies the path to CatFileName.
    AttributeName -         See AttributeValue.
    AttributeValue -        If AttributeName and AttributeValue are not specified, the catalog is always uninstalled. 
                            If AttributeName is specified and AttributeValue isn't, the catalog will be uninstalled only if it has an 
                            attribute with AttributeName name, regardess of its value. If AttributeName is not specified and AttributeValue is, 
                            the catalog will be uninstalled only if it has an attribute with AttributeValue value, regardless of its 
                            name. If both AttributeName and AttributeValue are specified, the catalog is uninstalled only if it 
                            has an attribute with AttributeName name and AttributeValue value.
    InstalledCatalogsList - If not NULL, contains the list of catalogs installed on the system. If the catalog is not on the list,
                            it is not uninstalled. If the catalog is on the list, it is uninstalled and removed from the list. If NULL, 
                            the catalog is always uninstalled.

Return value:

    NO_ERROR on success, otherwise a Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;
    HCATADMIN hCatAdmin = CatAdminHandle;
    PSTRING_LIST_ENTRY pEntry = NULL;

    if(NULL == CatFileName || 0 == CatFileName[0]) {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if(NULL == CatAdminHandle && !CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
        dwError = GetLastError();
        goto exit;
    }

    if(NULL == InstalledCatalogsList || NULL != (pEntry = SearchStringInList(InstalledCatalogsList, CatFileName, FALSE))) {
        BOOL bFound;
        dwError = LookupCatalogAttribute(CatFileName, CatFilePath, AttributeName, AttributeValue, &bFound);

        if(dwError != ERROR_SUCCESS) {
            goto exit;
        }

        if(bFound) {
            if(CryptCATAdminRemoveCatalog(hCatAdmin, (PWCHAR) CatFileName, 0)) {
                if(pEntry != NULL) {
                    RemoveEntryList(&pEntry->Entry);
                    FreeStringEntry(&pEntry->Entry, TRUE);
                }
            } else {
                dwError = GetLastError();

                SetuplogError(
                    LogSevInformation,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_SYSSETUP_CATALOG_NOT_DELETED,
                    CatFileName,
                    NULL,
                    NULL
                    );
            }
        }
    }

exit:
    if(NULL == CatAdminHandle && hCatAdmin != NULL) {
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    return dwError;
}

typedef struct _UNINSTALL_EXCEPPACK_CATALOG_CONTEXT {
    HCATADMIN CatAdminHandle;
} UNINSTALL_EXCEPPACK_CATALOG_CONTEXT, * PUNINSTALL_EXCEPPACK_CATALOG_CONTEXT;


BOOL
CALLBACK
SpUninstallExcepPackCatalogsCallback(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
/*++

Routine Description:

	This is the callback function for the SetupEnumerateRegisteredOsComponents call in SpUninstallExcepPackCatalogs.
    It uninstalls the catalog specified by SetupOsExceptionData->CatalogFileName.

Arguments:

	SetupOsComponentData - component data
	SetupOsExceptionData - exception pack data
	Context - pointer to an UNINSTALL_EXCEPPACK_CATALOG_CONTEXT struct

Return value:

	TRUE to continue the enumeration

--*/
{
    PUNINSTALL_EXCEPPACK_CATALOG_CONTEXT pContext;
    PCWSTR szCatName;

    ASSERT(Context != 0);
    pContext = (PUNINSTALL_EXCEPPACK_CATALOG_CONTEXT) Context;
    szCatName = wcsrchr(SetupOsExceptionData->CatalogFileName, L'\\');
    ASSERT(szCatName != NULL);

    if(szCatName != NULL) {
        DWORD dwError = SpUninstallCatalog(pContext->CatAdminHandle, szCatName + 1, NULL, NULL, NULL, NULL);

        if(dwError != NO_ERROR) {
            SetupDebugPrint1(L"SETUP: SpUninstallCatalog returned 0x%08x.", dwError);
        }
    }

    return TRUE;
}

VOID
SpUninstallExcepPackCatalogs(
    IN HCATADMIN CatAdminHandle OPTIONAL
    )
/*++

Routine Description:

	This function uninstalls all exception package catalogs.

Arguments:

	CatAdminHandle - a handle to crypto catalog admin; may be NULL

Return value:

	none

--*/
{
    UNINSTALL_EXCEPPACK_CATALOG_CONTEXT Context;
    Context.CatAdminHandle = CatAdminHandle;
    SetupEnumerateRegisteredOsComponents(SpUninstallExcepPackCatalogsCallback, (DWORD_PTR) &Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\dll.c ===
#include "setupp.h"
#pragma hdrstop

HANDLE MyModuleHandle;
WCHAR  MyModuleFileName[MAX_PATH];


BOOL
CommonProcessAttach(
    IN BOOL Attach
    );

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
#define FUNCTION L"DllMain"
    ULONG   MyModuleFileNameLength;
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        MyModuleHandle = DllHandle;

        MyModuleFileNameLength =
            GetModuleFileNameW(MyModuleHandle, MyModuleFileName, RTL_NUMBER_OF(MyModuleFileName));
        if (MyModuleFileNameLength == 0) {
            SetupDebugPrint1(L"SETUP: GetModuleFileNameW failed in " FUNCTION L", LastError is %d\n", GetLastError());
            b = FALSE;
            goto Exit;
        }
        if (MyModuleFileNameLength > RTL_NUMBER_OF(MyModuleFileName)) {
            SetupDebugPrint(L"SETUP: GetModuleFileNameW failed in " FUNCTION L", LastError is ERROR_INSUFFICIENT_BUFFER\n");
            b = FALSE;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }

        b = CommonProcessAttach(TRUE);
        //
        // Fall through to process first thread
        //

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        CommonProcessAttach(FALSE);
        break;

    case DLL_THREAD_DETACH:

        break;
    }
Exit:
    return(b);
}


BOOL
CommonProcessAttach(
    IN BOOL Attach
    )
{
    BOOL b;

    //
    // Assume success for detach, failure for attach
    //
    b = !Attach;

    if(Attach) {
        b = RegisterActionItemListControl(TRUE) && (PlatformSpecificInit() == NO_ERROR);
    } else {
        RegisterActionItemListControl(FALSE);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\dynupdt.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dynupdt.c

Abstract:

    Routines to handle dynamic update support during GUI setup phase

Author:

    Ovidiu Temereanca (ovidiut) 15-Aug-2000

Revision History:

--*/

#include "setupp.h"
#include "hwdb.h"
#include "newdev.h"
#pragma hdrstop


#define STR_UPDATES_INF         TEXT("updates.inf")
#define STR_DEFAULTINSTALL      TEXT("DefaultInstall")
#define STR_DRIVERCACHEINF      TEXT("drvindex.inf")
#define STR_VERSION             TEXT("Version")
#define STR_CABFILES            TEXT("CabFiles")
#define STR_CABS                TEXT("Cabs")
#define S_HWCOMP_DAT            TEXT("hwcomp.dat")


static TCHAR g_DuShare[MAX_PATH];


BOOL
BuildPath (
    OUT     PTSTR PathBuffer,
    IN      DWORD PathBufferSize,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    )

/*++

Routine Description:

    This function builds a path given the 2 components, assumed not to contain
    trailing or heading wacks

Arguments:

    PathBuffer - Receives the full path

    PathBuferSize - The size in chars of PathBuffer

    Path1 - Specifies the head path

    Path2 - Specifies the tail path

Return Value:

    TRUE to indicate success; FALSE in case of failure; it means the supplied buffer
    was too small to fit the whole new path

--*/

{
    if (!Path1 || !Path2) {
        MYASSERT (FALSE);
        return FALSE;
    }
    return _sntprintf (PathBuffer, PathBufferSize, TEXT("%s\\%s"), Path1, Path2) > 0;
}

BOOL
pDoesFileExist (
    IN      PCTSTR FilePath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (FilePath, &fd) && !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}

BOOL
pDoesDirExist (
    IN      PCTSTR FilePath
    )
{
    WIN32_FIND_DATA fd;

    return FileExists (FilePath, &fd) && (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}


DWORD
CreateMultiLevelDirectory (
    IN LPCTSTR Directory
    )

/*++

Routine Description:

    This routine ensures that a multi-level path exists by creating individual
    levels one at a time. It can handle either paths of form x:... or \\?\Volume{...

Arguments:

    Directory - supplies fully-qualified Win32 pathspec of directory to create

Return Value:

    Win32 error code indicating outcome.

--*/

{
    TCHAR Buffer[MAX_PATH];
    PTSTR p,q;
    TCHAR c;
    BOOL Done;
    DWORD d = ERROR_SUCCESS;

    lstrcpyn(Buffer,Directory,MAX_PATH);

    //
    // If it already exists do nothing. (We do this before syntax checking
    // to allow for remote paths that already exist. This is needed for
    // remote boot machines.)
    //
    d = GetFileAttributes(Buffer);
    if(d != (DWORD)(-1)) {
        return((d & FILE_ATTRIBUTE_DIRECTORY) ? NO_ERROR : ERROR_DIRECTORY);
    }

    //
    // Check path format
    //
    c = (TCHAR)CharUpper((LPTSTR)Buffer[0]);
    if (c < TEXT('A') || c > TEXT('Z') || Buffer[1] != TEXT(':')) {
        return ERROR_INVALID_PARAMETER;
    }

    if(Buffer[2] != TEXT('\\')) {
        return(Buffer[2] ? ERROR_INVALID_PARAMETER : ERROR_SUCCESS);
    }
    q = Buffer + 3;
    if(*q == 0) {
        return(ERROR_SUCCESS);
    }

    Done = FALSE;
    do {
        //
        // Locate the next path sep char. If there is none then
        // this is the deepest level of the path.
        //
        if(p = _tcschr(q,TEXT('\\'))) {
            *p = 0;
        } else {
            Done = TRUE;
        }

        //
        // Create this portion of the path.
        //
        if(CreateDirectory(Buffer,NULL)) {
            d = ERROR_SUCCESS;
        } else {
            d = GetLastError();
            if(d == ERROR_ALREADY_EXISTS) {
                d = ERROR_SUCCESS;
            }
        }

        if(d == ERROR_SUCCESS) {
            //
            // Put back the path sep and move to the next component.
            //
            if(!Done) {
                *p = TEXT('\\');
                q = p+1;
            }
        } else {
            Done = TRUE;
        }

    } while(!Done);

    return(d);
}

DWORD
GetDriverCacheSourcePath (
    OUT     PTSTR Buffer,
    IN      DWORD BufChars
    )

/*++

Routine Description:

    This routine returns the source path to the local driver cache.

    This value is retrieved from the following registry location:

    \HKLM\Software\Microsoft\Windows\CurrentVersion\Setup

        DriverCachePath : REG_EXPAND_SZ :

Arguments:

    Buffer - Receives the path.

    BufChars - Specifies the size of Buffer, in chars

Return Value:

    If the function succeeds, the return value is TRUE

    If the function fails, the return value is FALSE.

--*/

{
    HKEY hKey;
    DWORD rc, DataType, DataSize;
    TCHAR Value[MAX_PATH];

    rc = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REGSTR_PATH_SETUP TEXT("\\Setup"),
                0,
                KEY_READ,
                &hKey
                );
    if(rc == ERROR_SUCCESS) {
        //
        // Attempt to read the "DriverCachePath" value.
        //
        DataSize = sizeof (Value);
        rc = RegQueryValueEx (hKey, REGSTR_VAL_DRIVERCACHEPATH, NULL, &DataType, (PBYTE)Value, &DataSize);

        RegCloseKey(hKey);

        if(rc == ERROR_SUCCESS) {

            ExpandEnvironmentStrings (Value, Buffer, BufChars - 6);

            if (Buffer[0]) {
                _tcscat (
                    Buffer,
#if   defined(_AMD64_)
                    TEXT("\\amd64")
#elif defined(_X86_)
                    IsNEC_98 ? TEXT("\\nec98") : TEXT("\\i386")
#elif defined(_IA64_)
                    TEXT("\\ia64")
#else
#error "No Target Architecture"
#endif
                    );
                return ERROR_SUCCESS;
            } else {
                rc = ERROR_INVALID_DATA;
            }
        }
    }

    return rc;
}


PCTSTR
FindSubString (
    IN      PCTSTR String,
    IN      TCHAR Separator,
    IN      PCTSTR SubStr,
    IN      BOOL CaseSensitive
    )

/*++

Routine Description:

    This function looks for a substring of a given string, only if found
    between the specified separator chars

Arguments:

    String - Specifies the full string

    Separator - Specifies the separator

    SubStr - Specifies the sub string to look for

    CaseSensitive - Specifies if the comparison should be case sensitive or not

Return Value:

    NULL if the substring was not found; a pointer to the SubString inside String
    if it was found

--*/

{
    SIZE_T len1, len2;
    PCTSTR end;

    MYASSERT (Separator);
    MYASSERT (SubStr);
    MYASSERT (!_tcschr (SubStr, Separator));

    len1 = lstrlen (SubStr);
    MYASSERT (SubStr[len1] == 0);

    while (String) {
        end = _tcschr (String, Separator);
        if (end) {
            len2 = end - String;
        } else {
            len2 = lstrlen (String);
        }
        if ((len1 == len2) &&
            (CaseSensitive ?
                !_tcsncmp (String, SubStr, len1) :
                !_tcsnicmp (String, SubStr, len1)
            )) {
            break;
        }
        if (end) {
            String = end + 1;
        } else {
            String = NULL;
        }
    }

    return String;
}


BOOL
UpdateDrvIndex (
    IN      PCTSTR InfPath,
    IN      PCTSTR CabFilename,
    IN      PCTSTR SourceSifPath
    )

/*++

Routine Description:

    This function fixes drvindex.inf such that SetupApi
    will pick up the file from the right cabinet

Arguments:

    InfPath - Specifies the full path to drvindex.inf

    CabFilename - Specifies the filename of the
                  updates cabinet (basically it's "updates.cab")

    SourceSifPath - Specifies the full path to the associated
                    updates.sif containing the list of files in updates.cab

Return Value:

    TRUE to indicate success; FALSE in case of failure; use GetLastError()
    to find the reason of failure

--*/

{
    HANDLE sectFile = INVALID_HANDLE_VALUE;
    HANDLE concatFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    PTSTR section = NULL;
    PBYTE base = NULL;
    TCHAR tempPath[MAX_PATH];
    TCHAR tempFile[MAX_PATH];
    TCHAR temp[MAX_PATH];
    PTSTR p;
    DWORD sectSize;
    DWORD concatSize;
    DWORD rc;
    DWORD bytes;
    BOOL b = FALSE;

    //
    // create a temp file to put the new section in it
    //
    if (!GetTempPath (MAX_PATH, tempPath) ||
        !GetTempFileName (tempPath, TEXT("STP"), 0, tempFile)
        ) {
        return FALSE;
    }

    __try {

        if (!CopyFile (InfPath, tempFile, FALSE)) {
            __leave;
        }
        SetFileAttributes (tempFile, FILE_ATTRIBUTE_NORMAL);

        section = pSetupDuplicateString (CabFilename);
        if (!section) {
            __leave;
        }
        p = _tcsrchr (section, TEXT('.'));
        if (p) {
            *p = 0;
        }

        if (GetPrivateProfileString (
                        STR_CABS,
                        section,
                        TEXT(""),
                        temp,
                        MAX_PATH,
                        tempFile
                        )) {
            if (lstrcmpi (temp, CabFilename) == 0) {
                if (GetPrivateProfileString (
                                STR_VERSION,
                                STR_CABFILES,
                                TEXT(""),
                                tempPath,
                                MAX_PATH,
                                tempFile
                                )) {
                    if (FindSubString (tempPath, TEXT(','), section, FALSE)) {
                        //
                        // setup restarted, but drvindex.inf is already patched; nothing to do
                        //
                        b = TRUE;
                        __leave;
                    }
                }
            }
        }

        if (!WritePrivateProfileString (
                        STR_CABS,
                        section,
                        CabFilename,
                        tempFile
                        )) {
            __leave;
        }
        if (!GetPrivateProfileString (
                        STR_VERSION,
                        STR_CABFILES,
                        TEXT(""),
                        tempPath,
                        MAX_PATH,
                        tempFile
                        )) {
            __leave;
        }
        if (!FindSubString (tempPath, TEXT(','), section, FALSE)) {
            wsprintf (temp, TEXT("%s,%s"), section, tempPath);
            if (!WritePrivateProfileString (
                            STR_VERSION,
                            STR_CABFILES,
                            temp,
                            tempFile
                            )) {
                __leave;
            }
        }

        sectFile = CreateFile (
                        SourceSifPath,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (sectFile == INVALID_HANDLE_VALUE) {
            __leave;
        }

        sectSize = GetFileSize (sectFile, NULL);
        if (sectSize == INVALID_FILE_SIZE) {
            __leave;
        }

        concatFile = CreateFile (
                        tempFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (concatFile == INVALID_HANDLE_VALUE) {
            __leave;
        }
        concatSize = GetFileSize (concatFile, NULL);
        if (concatSize == INVALID_FILE_SIZE) {
            __leave;
        }

        hMap = CreateFileMapping (concatFile, NULL, PAGE_READWRITE, 0, concatSize + sectSize, NULL);
        if (!hMap) {
            __leave;
        }

        base = MapViewOfFile (
                    hMap,
                    FILE_MAP_ALL_ACCESS,
                    0,
                    0,
                    0
                    );
        if (!base) {
            __leave;
        }

        //
        // make sure concatFile file didn't end in end-of-file
        //
        if (base[concatSize - 1] == 0x1A) {
            base[concatSize - 1] = ' ';
        }
        //
        // now append the other file
        //
        if (!ReadFile (sectFile, (LPVOID)(base + concatSize), sectSize, &bytes, NULL) || bytes != sectSize) {
            __leave;
        }
        //
        // now try to commit changes
        //
        if (!UnmapViewOfFile (base)) {
            __leave;
        }
        base = NULL;
        if (!CloseHandle (hMap)) {
            __leave;
        }
        hMap = NULL;
        //
        // close the handle to the temporary file and overwrite the real one
        //
        if (!CloseHandle (concatFile)) {
            __leave;
        }
        concatFile = INVALID_HANDLE_VALUE;
        SetFileAttributes (InfPath, FILE_ATTRIBUTE_NORMAL);
        b = MoveFileEx (tempFile, InfPath, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING);
    }
    __finally {
        rc = b ? ERROR_SUCCESS : GetLastError ();
        DeleteFile (tempFile);
        if (base) {
            UnmapViewOfFile (base);
        }
        if (hMap) {
            CloseHandle (hMap);
        }
        if (concatFile != INVALID_HANDLE_VALUE) {
            CloseHandle (concatFile);
        }
        if (sectFile != INVALID_HANDLE_VALUE) {
            CloseHandle (sectFile);
        }
        if (section) {
            MyFree (section);
        }
        SetLastError (rc);
    }

    return b;
}


UINT
pExpandUpdatesCab (
    IN PVOID Context,
    IN UINT  Code,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    switch (Code) {
    case SPFILENOTIFY_FILEINCABINET:
        {
            PFILE_IN_CABINET_INFO FileInCabInfo = (PFILE_IN_CABINET_INFO)Param1;
            //
            // extract the file name
            //
            PCTSTR p = _tcsrchr (FileInCabInfo->NameInCabinet, TEXT('\\'));
            if (p) {
                p++;
            } else {
                p = FileInCabInfo->NameInCabinet;
            }

            lstrcpy (FileInCabInfo->FullTargetName, (PCTSTR)Context);
            pSetupConcatenatePaths (
                FileInCabInfo->FullTargetName,
                p,
                SIZECHARS (FileInCabInfo->FullTargetName),
                NULL
                );
            return FILEOP_DOIT;
        }

    case SPFILENOTIFY_NEEDNEWCABINET:
        {
            PCABINET_INFO CabInfo = (PCABINET_INFO)Param1;
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_SYSSETUP_CAB_MISSING,
                CabInfo->CabinetPath,
                CabInfo->CabinetFile,
                CabInfo->DiskName,
                CabInfo->SetId,
                CabInfo->CabinetNumber,
                NULL,
                NULL
                );
            return ERROR_FILE_NOT_FOUND;
        }
    }

    return NO_ERROR;
}

VOID
pInstallUpdatesInf (
    VOID
    )

/*++

Routine Description:

    This function installs the STR_DEFAULTINSTALL section of STR_UPDATES_INF
    if this file is found inside updates.cab

Arguments:

    none

Return Value:

    none

--*/

{
    TCHAR infPath[MAX_PATH];
    TCHAR commandLine[MAX_PATH + 30];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    MYASSERT (!MiniSetup && !OobeSetup);

    MYASSERT (g_DuShare[0]);

    BuildPath (infPath, MAX_PATH, g_DuShare, STR_UPDATES_INF);
    if (pDoesFileExist (infPath)) {
        //
        // install this INF as if the user chose "Install" on the right-click popup menu
        //
        wsprintf (
            commandLine,
            TEXT("RUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection %s %u %s"),
            STR_DEFAULTINSTALL,
            128,           // don't reboot
            infPath
            );
        ZeroMemory (&si, sizeof (si));
        si.cb = sizeof (si);
        if (CreateProcess (
                NULL,
                commandLine,
                NULL,
                NULL,
                FALSE,
                CREATE_NO_WINDOW | ABOVE_NORMAL_PRIORITY_CLASS,
                NULL,
                NULL,
                &si,
                &pi
                )) {
            CloseHandle (pi.hProcess);
            CloseHandle (pi.hThread);
        }
    } else {
        SetuplogError (
                LogSevInformation,
                TEXT("DUInfo: No %1 to install"),
                0,
                STR_UPDATES_INF,
                NULL,
                NULL
                );
    }
}


BOOL
DuInitialize (
    VOID
    )

/*++

Routine Description:

    This function initializes DU in GUI setup

Arguments:

    none

Return Value:

    TRUE to indicate success; FALSE in case of failure; use GetLastError()
    to find the reason of failure

--*/

{
    PTSTR cabFilename;
    TCHAR sourceCabPath[MAX_PATH];
    TCHAR workingDir[MAX_PATH];
    DWORD rc;

    MYASSERT (!MiniSetup && !OobeSetup);

    MYASSERT (AnswerFile[0]);

    if (!GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_UPDATEDSOURCES,
            TEXT(""),
            sourceCabPath,
            MAX_PATH,
            AnswerFile
            )) {
        return TRUE;
    }

    if (!GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_DYNUPDTWORKINGDIR,
            TEXT(""),
            workingDir,
            MAX_PATH,
            AnswerFile
            )) {

        MYASSERT (FALSE);

        if (!GetWindowsDirectory (workingDir, MAX_PATH)) {
            return FALSE;
        }
        pSetupConcatenatePaths (workingDir, TEXT("setupupd"), MAX_PATH, NULL);

        WritePrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTWORKINGDIR,
                workingDir,
                AnswerFile
                );
    }

    MYASSERT (workingDir[0]);
    pSetupConcatenatePaths (workingDir, TEXT("updates"), MAX_PATH, NULL);
    pSetupConcatenatePaths (
        workingDir,
#if   defined(_AMD64_)
        TEXT("amd64"),
#elif defined(_X86_)
        TEXT("i386"),
#elif defined(_IA64_)
        TEXT("ia64"),
#else
#error "No Target Architecture"
#endif
        MAX_PATH,
        NULL
        );

    if (CreateMultiLevelDirectory (workingDir) != ERROR_SUCCESS) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                TEXT("DUError: DuInitialize: failed to create %1 (%2!u!)\r\n"),
                0,
                workingDir,
                rc,
                NULL,
                NULL
                );
        return FALSE;
    }

    //
    // expand updates.cab in this folder
    //
    if (!SetupIterateCabinet (sourceCabPath, 0, pExpandUpdatesCab, (PVOID)workingDir)) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                TEXT("DUError: DuInitialize: failed to expand %1 to %2 (%3!u!)\r\n"),
                0,
                sourceCabPath,
                workingDir,
                rc,
                NULL,
                NULL
                );
        return FALSE;
    }

    //
    // OK, everything is set up; go ahead and set the global variable
    //
    lstrcpy (g_DuShare, workingDir);

    return TRUE;
}


DWORD
DuInstallCatalogs (
    OUT     SetupapiVerifyProblem* Problem,
    OUT     PTSTR ProblemFile,
    IN      PCTSTR DescriptionForError         OPTIONAL
    )

/*++

Routine Description:

    This function installs any catalogs found inside updates.cab

Arguments:

    same as InstallProductCatalogs

Return Value:

    If successful, the return value is ERROR_SUCCESS, otherwise it is a Win32 error
    code indicating the cause of the failure.

--*/

{
    TCHAR catPath[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE h;
    UINT ErrorMessageId;
    DWORD rc = ERROR_SUCCESS;

    MYASSERT (!MiniSetup && !OobeSetup);

    if (!g_DuShare[0]) {
        return ERROR_SUCCESS;
    }

    BuildPath (catPath, MAX_PATH, g_DuShare, TEXT("*.cat"));
    h = FindFirstFile (catPath, &fd);
    if (h != INVALID_HANDLE_VALUE) {

        do {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                BuildPath (catPath, MAX_PATH, g_DuShare, fd.cFileName);

                rc = pSetupVerifyCatalogFile (catPath);
                if (rc == NO_ERROR) {
                    rc = pSetupInstallCatalog(catPath, fd.cFileName, NULL);
                    if(rc != NO_ERROR) {
                        ErrorMessageId = MSG_LOG_SYSSETUP_CATINSTALL_FAILED;
                    }
                } else {
                    ErrorMessageId = MSG_LOG_SYSSETUP_VERIFY_FAILED;
                }

                if(rc != NO_ERROR) {

                    SetuplogError (
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            ErrorMessageId,
                            catPath,
                            rc,
                            NULL,
                            NULL
                            );
                    //
                    // Also, add an entry about this failure to setupapi's PSS
                    // exception logfile.
                    //
                    pSetupHandleFailedVerification (
                            MainWindowHandle,
                            SetupapiVerifyCatalogProblem,
                            catPath,
                            DescriptionForError,
                            pSetupGetCurrentDriverSigningPolicy(FALSE),
                            TRUE,  // no UI!
                            rc,
                            NULL,  // log context
                            NULL, // optional flags
                            NULL
                            );
                    break;
                }
            }
        } while (FindNextFile (h, &fd));

        FindClose (h);
    } else {
        SetuplogError (
                LogSevWarning,
                TEXT("DUWarning: no catalogs found in %1\r\n"),
                0,
                g_DuShare,
                NULL,
                NULL
                );
    }

    return rc;
}

DWORD
DuInstallUpdates (
    VOID
    )

/*++

Routine Description:

    This routine updates drvindex.inf to point setupapi to the new binaries.

Arguments:

    none

Return Value:

    If successful, the return value is ERROR_SUCCESS, otherwise it is a Win32 error
    code indicating the cause of the failure.

--*/

{
    PTSTR cabFilename;
    TCHAR sourceCabPath[MAX_PATH];
    TCHAR sourceSifPath[MAX_PATH];
    TCHAR cabPath[MAX_PATH];
    TCHAR infPath[MAX_PATH];
    TCHAR tmpPath[MAX_PATH];
    DWORD rc;

    MYASSERT (!MiniSetup && !OobeSetup);

    if (!g_DuShare[0]) {
        return ERROR_SUCCESS;
    }

    //
    // make sure updates.sif is available
    //
    if (!GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_UPDATEDSOURCES,
            TEXT(""),
            sourceCabPath,
            MAX_PATH,
            AnswerFile
            )) {
        return GetLastError ();
    }

    lstrcpy (sourceSifPath, sourceCabPath);
    cabFilename = _tcsrchr (sourceSifPath, TEXT('.'));
    if (!cabFilename || _tcschr (cabFilename, TEXT('\\'))) {
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_INVALID_UPDATESCAB_NAME,
                sourceCabPath,
                NULL,
                NULL
                );
        return ERROR_INVALID_DATA;
    }
    lstrcpy (cabFilename + 1, TEXT("sif"));
    if (!pDoesFileExist (sourceSifPath)) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_UPDATESSIF_NOT_FOUND,
                sourceSifPath,
                sourceCabPath,
                rc,
                NULL,
                NULL
                );
        return rc;
    }
    //
    // copy this where source cabs reside
    //
    rc = GetDriverCacheSourcePath (cabPath, MAX_PATH);
    if (rc != ERROR_SUCCESS) {
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_DRIVER_CACHE_NOT_FOUND,
                rc,
                NULL,
                NULL
                );
        return rc;
    }
    cabFilename = _tcsrchr (sourceCabPath, TEXT('\\'));
    if (cabFilename) {
        cabFilename++;
    } else {
        cabFilename = cabPath;
    }
    pSetupConcatenatePaths (cabPath, cabFilename, MAX_PATH, NULL);
    //
    // GUI setup should be restartable; copy file, don't move it
    //
    SetFileAttributes (cabPath, FILE_ATTRIBUTE_NORMAL);
    if (!CopyFile (sourceCabPath, cabPath, FALSE)) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FAILED_TO_COPY_UPDATES,
                rc,
                NULL,
                NULL
                );
        return rc;
    }
    //
    // now make sure the file attributes are set to RHS to protect it
    //
    SetFileAttributes (cabPath, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);

    //
    // temp folder for expanded files
    //
    if (!GetTempPath (MAX_PATH, tmpPath)) {
        rc = GetLastError ();
        return rc;
    }
    //
    // full path to drvindex.inf, assuming the file is in %windir%\inf
    //
    if (!GetWindowsDirectory (infPath, MAX_PATH)) {
        rc = GetLastError ();
        return rc;
    }
    _tcscat (infPath, TEXT("\\inf\\"));
    _tcscat (infPath, STR_DRIVERCACHEINF);
    if (GetFileAttributes (infPath) == (DWORD)-1) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                TEXT("DUError: %1 not found (rc=%2!u!)\r\n"),
                0,
                infPath,
                rc,
                NULL,
                NULL
                );
        return rc;
    }

    //
    // now patch drvindex.inf
    //
    if (!UpdateDrvIndex (infPath, cabFilename, sourceSifPath)) {
        rc = GetLastError ();
        SetuplogError (
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FAILED_TO_UPDATE_DRVINDEX,
                rc,
                NULL,
                NULL
                );
        SetFileAttributes (cabPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (cabPath);
        return rc;
    }

    //
    // finally run updates.inf
    //
    pInstallUpdatesInf ();

    return rc;
}


BOOL
DuInstallEndGuiSetupDrivers (
    VOID
    )

/*++

Routine Description:

    This routine installs any WU drivers not approved for the beginning of GUI setup.

Arguments:

    none

Return Value:

    If successful, the return value is TRUE

--*/

{
    DWORD chars;
    TCHAR datPath[MAX_PATH];
    TCHAR infPath[MAX_PATH];
    TCHAR buf[MAX_PATH * 16];
    PTSTR source, p, next;
    BOOL bRebootRequired;
    HWDBINF_ENUM e;
    PCTSTR pnpId;
    HMODULE hNewDev;
    HINF hGuiDrvsInf;
    INFCONTEXT ic;
    UINT line;
    BOOL (WINAPI* pfnUpdateDriver) (
        HWND hwndParent,
        LPCWSTR HardwareId,
        LPCWSTR FullInfPath,
        DWORD InstallFlags,
        PBOOL bRebootRequired OPTIONAL
        );

    //
    // try to append any additional POST GUI setup drivers
    // in the DevicePath
    //
    if (!SpSetupLoadParameter (
            WINNT_SP_DYNUPDTADDITIONALPOSTGUIDRIVERS,
            buf,
            MAX_PATH * 16
            )) {
        return TRUE;
    }

    chars = lstrlen (buf);
    if (!chars) {
        return TRUE;
    }

    //
    // load the support library newdev.dll
    //
    hNewDev = LoadLibrary (TEXT("newdev.dll"));
    if (!hNewDev) {
        return FALSE;
    }
    (FARPROC)pfnUpdateDriver = GetProcAddress (hNewDev, "UpdateDriverForPlugAndPlayDevicesW");
    if (!pfnUpdateDriver) {
        FreeLibrary (hNewDev);
        return FALSE;
    }

    if (!HwdbInitializeW (NULL)) {
        SetuplogError (
                LogSevWarning,
                TEXT("DUWarning: HwdbInitialize failed (rc=%1!u!); no DU drivers will be installed\r\n"),
                0,
                GetLastError (),
                NULL,
                NULL
                );
        FreeLibrary (hNewDev);
        return FALSE;
    }

    //
    // look for driver-controlling inf
    //
    hGuiDrvsInf = INVALID_HANDLE_VALUE;
    if (SpSetupLoadParameter (
            WINNT_SP_DYNUPDTDRIVERINFOFILE,
            infPath,
            MAX_PATH
            )) {
        if (pDoesFileExist (infPath)) {
            hGuiDrvsInf = SetupOpenInfFile (infPath, NULL, INF_STYLE_WIN4, &line);
            if (hGuiDrvsInf == INVALID_HANDLE_VALUE) {
                SetuplogError (
                        LogSevWarning,
                        TEXT("DUWarning: SetupOpenInfFile(%1) failed (rc=%2!u!); all DU drivers will be installed\r\n"),
                        0,
                        infPath,
                        GetLastError (),
                        NULL,
                        NULL
                        );
            }
        } else {
            SetuplogError (
                    LogSevWarning,
                    TEXT("DUWarning: File %1 missing; all DU drivers will be installed\r\n"),
                    0,
                    infPath,
                    NULL,
                    NULL
                    );
        }
    } else {
        SetuplogError (
                LogSevInformation,
                TEXT("DUInfo: File %1 missing; all DU drivers will be installed\r\n"),
                0,
                infPath,
                NULL,
                NULL
                );
    }
    source = buf;
    while (source) {
        next = _tcschr (source, TEXT(','));
        if (next) {
            *next = 0;
        }
        p = source;
        if (*p == TEXT('\"')) {
            p = ++source;
        }
        while (*p && *p != TEXT('\"')) {
            p++;
        }
        *p = 0;
        if (pDoesDirExist (source)) {
            BuildPath (datPath, MAX_PATH, source, S_HWCOMP_DAT);
            if (pDoesFileExist (datPath)) {
                //
                // OK, we have the file with hardware info
                //
                if (HwdbEnumFirstInf (&e, datPath)) {
                    do {
                        BuildPath (infPath, MAX_PATH, source, e.InfFile);
                        if (!pDoesFileExist (infPath)) {
                            continue;
                        }
                        //
                        // iterate through all PNPIDs in this INF
                        //
                        for (pnpId = e.PnpIds; *pnpId; pnpId = _tcschr (pnpId, 0) + 1) {
                            //
                            // excluded PNPID are NOT in hwcomp.dat
                            // guidrvs.inf was already processed during winnt32
                            //
                            if (!pfnUpdateDriver (
                                    NULL,
                                    pnpId,
                                    infPath,
                                    0, // BUGBUG - if we specify INSTALLFLAG_NONINTERACTIVE and there is a driver signing problem, the API will fail!
                                    &bRebootRequired
                                    )) {
                                if (GetLastError() != ERROR_SUCCESS) {
                                    //
                                    // well, if the device we wanted to update the driver for
                                    // doesn't actually exist on this machine, don't log anything
                                    //
                                    if (GetLastError() != ERROR_NO_SUCH_DEVINST) {
                                        SetuplogError (
                                                LogSevWarning,
                                                TEXT("DUWarning: UpdateDriverForPlugAndPlayDevices failed (rc=%3!u!) for PNPID=%1 (INF=%2)\r\n"),
                                                0,
                                                pnpId,
                                                infPath,
                                                GetLastError (),
                                                NULL,
                                                NULL
                                                );
                                    }
                                } else {
                                    SetuplogError (
                                            LogSevInformation,
                                            TEXT("DUInfo: UpdateDriverForPlugAndPlayDevices did not update the driver for PNPID=%1\r\n"),
                                            0,
                                            pnpId,
                                            NULL,
                                            NULL
                                            );
                                }
                                continue;
                            }
                            //
                            // SUCCESS! - log this information
                            //
                            SetuplogError (
                                    LogSevInformation,
                                    TEXT("DUInfo: UpdateDriverForPlugAndPlayDevices succeeded for PNPID=%1\r\n"),
                                    0,
                                    pnpId,
                                    NULL,
                                    NULL
                                    );
                            //
                            // also update the PNF with the info that this is an INTERNET driver
                            //
                            if (!SetupCopyOEMInf (
                                    infPath,
                                    NULL,
                                    SPOST_URL,
                                    SP_COPY_REPLACEONLY,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL
                                    )) {
                                SetuplogError (
                                        LogSevInformation,
                                        TEXT("DUInfo: SetupCopyOEMInf failed to update OEMSourceMediaType for INF=%1\r\n"),
                                        0,
                                        infPath,
                                        NULL,
                                        NULL
                                        );
                            }
                        }
                    } while (HwdbEnumNextInf (&e));
                }
            }
        }
        if (next) {
            source = next + 1;
        } else {
            source = NULL;
        }
    }

    HwdbTerminate ();

    FreeLibrary (hNewDev);

    return TRUE;
}


VOID
DuCleanup (
    VOID
    )

/*++

Routine Description:

    This routine performs DU cleanup

Arguments:

    none

Return Value:

    none

--*/

{
    TCHAR buf[MAX_PATH * 16];
    DWORD chars;
    HKEY key;
    PTSTR devicePath;
    PTSTR p;
    DWORD rc;
    DWORD size;
    DWORD type;

    //
    // cleanup the file system
    //
    MYASSERT (AnswerFile[0]);
    if (GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_DYNUPDTWORKINGDIR,
            TEXT(""),
            buf,
            MAX_PATH,
            AnswerFile
            )) {
        Delnode (buf);
    }
    //
    // cleanup the registry
    //
    chars = GetPrivateProfileString (
                WINNT_SETUPPARAMS,
                WINNT_SP_DYNUPDTADDITIONALGUIDRIVERS,
                TEXT(""),
                buf,
                MAX_PATH * 16,
                AnswerFile
                );
    if (chars > 0) {
        //
        // got it; now remove it from DevicePath
        //
        rc = RegOpenKey (HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, &key);
        if (rc == ERROR_SUCCESS) {
            rc = RegQueryValueEx (key, REGSTR_VAL_DEVICEPATH, NULL, NULL, NULL, &size);
            if (rc == ERROR_SUCCESS) {
                devicePath = (PTSTR) MyMalloc (size);
                if (devicePath) {
                    rc = RegQueryValueEx (key, REGSTR_VAL_DEVICEPATH, NULL, &type, (LPBYTE)devicePath, &size);
                    if (rc == ERROR_SUCCESS && size / sizeof (TCHAR) >= chars + 1) {
                        p = _tcsstr (devicePath, buf);
                        if (p &&
                            (p == devicePath || *(p - 1) == TEXT(';')) &&
                            (!p[chars] || p[chars] == TEXT(';'))
                            ) {
                            if (p == devicePath) {
                                _tcscpy (p, p[chars] == TEXT(';') ? p + chars + 1 : p + chars);
                            } else {
                                _tcscpy (p - 1, p + chars);
                            }
                            size = (_tcslen (devicePath) + 1) * sizeof (TCHAR);
                            rc = RegSetValueEx (key, REGSTR_VAL_DEVICEPATH, 0, type, (PBYTE)devicePath, size);
                        }
                    }
                    MyFree (devicePath);
                }
            }
            RegCloseKey (key);
        }
    }

    g_DuShare[0] = 0;
}


BOOL
DuInstallDuAsms (
    VOID
    )

/*++

Routine Description:

    This routine installs additional DU assemblies

Arguments:

    none

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    TCHAR duasmsRoot[MAX_PATH];
    TCHAR duasmsSource[MAX_PATH];
    DWORD chars;
    SIDE_BY_SIDE SideBySide = {0};
    BOOL b1;
    BOOL b2;
    PTSTR p;
    PCTSTR source;
    BOOL fSuccess = TRUE;

    //
    // look for any assemblies root specified in the answer file
    //

    MYASSERT (AnswerFile[0]);
    if (GetPrivateProfileString (
            WINNT_SETUPPARAMS,
            WINNT_SP_UPDATEDDUASMS,
            TEXT(""),
            duasmsRoot,
            MAX_PATH,
            AnswerFile
            )) {

        //
        // make sure this directory exists; remove any existing quotes first
        //
        p = duasmsRoot;
        if (*p == TEXT('\"')) {
            p++;
        }
        source = p;
        while (*p && *p != TEXT('\"')) {
            p++;
        }
        *p = 0;
        if (pDoesDirExist (source)) {
            //
            // root directory found
            // first copy them in a protected location, then install assemblies from there
            //
            DWORD rc;

            rc = GetDriverCacheSourcePath (duasmsSource, MAX_PATH);
            if (rc != ERROR_SUCCESS) {
                SetuplogError (
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_DRIVER_CACHE_NOT_FOUND,
                        rc,
                        NULL,
                        NULL
                        );
                return FALSE;
            }
            pSetupConcatenatePaths (duasmsSource, TEXT("duasms"), MAX_PATH, NULL);

            //
            // first remove any already existing duasms "backup source" previously downloaded
            //
            Delnode (duasmsSource);
            //
            // now tree copy from the temp location to this "backup source"
            //
            rc = TreeCopy (source, duasmsSource);
            if (rc != ERROR_SUCCESS) {
                SetuplogError(
                        LogSevError,
                        TEXT("Setup failed to TreeCopy %2 to %3 (TreeCopy failed %1!u!)\r\n"),
                        0,
                        rc,
                        source,
                        duasmsSource,
                        NULL,
                        NULL
                        );
                return FALSE;
            }

            //
            // install duasms from there
            //
            b1 = SideBySidePopulateCopyQueue (&SideBySide, NULL, duasmsSource);
            b2 = SideBySideFinish (&SideBySide, b1);

            if (!b1 || !b2) {
                fSuccess = FALSE;
                SetuplogError (
                        LogSevError,
                        TEXT("DUError: DuInstallDuAsms failed (rc=%1!u!)\r\n"),
                        0,
                        GetLastError (),
                        NULL,
                        NULL
                        );
            }
        } else {
            fSuccess = FALSE;
            SetuplogError (
                    LogSevError,
                    TEXT("DUError: Invalid directory %1; DuInstallDuAsms failed\r\n"),
                    0,
                    source,
                    NULL,
                    NULL
                    );
        }
    }

    return fSuccess;
}


BOOL
BuildPathToInstallationFileEx (
    IN      PCTSTR Filename,
    OUT     PTSTR PathBuffer,
    IN      DWORD PathBufferSize,
    IN      BOOL UseDuShare
    )

/*++

Routine Description:

    This routine returns the path to the updated DU file, if one exists
    and the caller wanted this. Otherwise it will simply return the path
    to the CD file.

Arguments:

    Filename - Specifies the filename to look for

    PathBuffer - Receives the full path to the file

    PathBufferSize - Specifies the size in chars of the above buffer

    UseDuShare - Specifies TRUE if the function should check the DU
                 location first

Return Value:

    TRUE if building the path was successful. This does not guarantee the file exist.

--*/

{
    if (g_DuShare[0] && UseDuShare) {
        if (BuildPath (PathBuffer, PathBufferSize, g_DuShare, Filename) &&
            pDoesFileExist (PathBuffer)
            ) {
            return TRUE;
        }
    }
    return BuildPath (PathBuffer, PathBufferSize, LegacySourcePath, Filename);
}


PCTSTR
DuGetUpdatesPath (
    VOID
    )
{
    return g_DuShare[0] ? g_DuShare : NULL;
}

BOOL
DuDoesUpdatedFileExistEx (
    IN      PCTSTR Filename,
    OUT     PTSTR PathBuffer,       OPTIONAL
    IN      DWORD PathBufferSize
    )

/*++

Routine Description:

    This routine checks if there exists an updated file with the given name.

Arguments:

    Filename - Specifies the filename to look for

    PathBuffer - Receives the full path to the file; optional

    PathBufferSize - Specifies the size in chars of the above buffer

Return Value:

    TRUE if a DU file with this name exists, FALSE otherwise

--*/

{
    TCHAR path[MAX_PATH];

    if (g_DuShare[0] &&
        BuildPath (path, MAX_PATH, g_DuShare, Filename) &&
        pDoesFileExist (path)
        ) {
        if (PathBuffer) {
            lstrcpyn (PathBuffer, path, PathBufferSize);
        }
        return TRUE;
    }
    return FALSE;
}


UINT
DuSetupPromptForDisk (
    HWND hwndParent,         // parent window of the dialog box
    PCTSTR DialogTitle,      // optional, title of the dialog box
    PCTSTR DiskName,         // optional, name of disk to insert
    PCTSTR PathToSource,   // optional, expected source path
    PCTSTR FileSought,       // name of file needed
    PCTSTR TagFile,          // optional, source media tag file
    DWORD DiskPromptStyle,   // specifies dialog box behavior
    PTSTR PathBuffer,        // receives the source location
    DWORD PathBufferSize,    // size of the supplied buffer
    PDWORD PathRequiredSize  // optional, buffer size needed
    )
{
    TCHAR buffer[MAX_PATH];

    if ((DiskPromptStyle & IDF_CHECKFIRST) &&
        PathBuffer &&
        PathBufferSize &&
        FileSought &&
        g_DuShare[0]
        ) {
        if (BuildPath (PathBuffer, PathBufferSize, g_DuShare, FileSought) &&
            pDoesFileExist (PathBuffer)
            ) {
            lstrcpyn (PathBuffer, g_DuShare, PathBufferSize);
            return DPROMPT_SUCCESS;
        }
    }

    return SetupPromptForDisk (
                hwndParent,
                DialogTitle,
                DiskName,
                PathToSource,
                FileSought,
                TagFile,
                DiskPromptStyle,
                PathBuffer,
                PathBufferSize,
                PathRequiredSize
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\dynupdt.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dynupdt.h

Abstract:

    Prototype of routines to handle dynamic update support during GUI setup phase

Author:

    Ovidiu Temereanca (ovidiut) 15-Aug-2000

Revision History:

--*/


BOOL
DuDoesUpdatedFileExistEx (
    IN      PCTSTR Filename,
    OUT     PTSTR PathBuffer,       OPTIONAL
    IN      DWORD PathBufferSize
    );

#define DuDoesUpdatedFileExist(f) DuDoesUpdatedFileExistEx(f,NULL,0)

PCTSTR
DuGetUpdatesPath (
    VOID
    );

BOOL
BuildPathToInstallationFileEx (
    IN      PCTSTR Filename,
    OUT     PTSTR PathBuffer,
    IN      DWORD PathBufferSize,
    IN      BOOL UseDuShare
    );

#define BuildPathToInstallationFile(f,p,s)  BuildPathToInstallationFileEx(f,p,s,TRUE)


BOOL
DuInitialize (
    VOID
    );

DWORD
DuInstallCatalogs (
    OUT     SetupapiVerifyProblem* Problem,
    OUT     PTSTR ProblemFile,
    IN      PCTSTR DescriptionForError         OPTIONAL
    );

DWORD
DuInstallUpdates (
    VOID
    );

BOOL
DuInstallEndGuiSetupDrivers (
    VOID
    );

BOOL
DuInstallDuAsms (
    VOID
    );

VOID
DuCleanup (
    VOID
    );

UINT
DuSetupPromptForDisk (
    HWND hwndParent,         // parent window of the dialog box
    PCTSTR DialogTitle,      // optional, title of the dialog box
    PCTSTR DiskName,         // optional, name of disk to insert
    PCTSTR PathToSource,   // optional, expected source path
    PCTSTR FileSought,       // name of file needed
    PCTSTR TagFile,          // optional, source media tag file
    DWORD DiskPromptStyle,   // specifies dialog box behavior
    PTSTR PathBuffer,        // receives the source location
    DWORD PathBufferSize,    // size of the supplied buffer
    PDWORD PathRequiredSize  // optional, buffer size needed
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\fileops.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fileops.c

Abstract:

    Miscellaneous file operations.

    Entry points:

        Delnode

Author:

    Ted Miller (tedm) 5-Apr-1995

Revision History:

--*/

#include "setupp.h"

//
//  This include is needed for ValidateAndChecksumFile()
//
#include <imagehlp.h>
#include <shlwapi.h>

#pragma hdrstop



VOID
pSetInstallAttributes(
    VOID
    )

/*++

Routine Description:

    Set default attributes on a huge list of files.  The shell
    had been doing this, but it's probably better to do it here
    so that the the user doesn't have his attributes reset everytime
    he logs in.

Arguments:

    None.

Return Value:

    None.

--*/

{
#define _R   (FILE_ATTRIBUTE_READONLY)
#define _S   (FILE_ATTRIBUTE_SYSTEM)
#define _H   (FILE_ATTRIBUTE_HIDDEN)
#define _SH  (_S | _H)
#define _SHR (_S | _H | _R)

struct {
    WCHAR   FileName[20];
    BOOL    DeleteIfEmpty;
    DWORD   Attributes;
} FilesToFix[] = {
//    { L"X:\\autoexec.bat",   TRUE,   _H  }, 16bit apps break if hidden: jarbats bug148787
    { L"X:\\autoexec.000",   TRUE,   _SH },
    { L"X:\\autoexec.old",   TRUE,   _SH },
    { L"X:\\autoexec.bak",   TRUE,   _SH },
    { L"X:\\autoexec.dos",   TRUE,   _SH },
    { L"X:\\autoexec.win",   TRUE,   _SH },
//    { L"X:\\config.sys",     TRUE,   _H  }, 16bit apps break if hidden: jarbats bug 148787
    { L"X:\\config.dos",     TRUE,   _SH },
    { L"X:\\config.win",     TRUE,   _SH },
    { L"X:\\command.com",    FALSE,  _SH },
    { L"X:\\command.dos",    FALSE,  _SH },
    { L"X:\\logo.sys",       FALSE,  _SH },
    { L"X:\\msdos.---",      FALSE,  _SH },  // Win9x backup of msdos.*
    { L"X:\\boot.ini",       FALSE,  _SH },
    { L"X:\\boot.bak",       FALSE,  _SH },
    { L"X:\\boot.---",       FALSE,  _SH },
    { L"X:\\bootsect.dos",   FALSE,  _SH },
    { L"X:\\bootlog.txt",    FALSE,  _SH },  // Win9x first boot log
    { L"X:\\bootlog.prv",    FALSE,  _SH },
    { L"X:\\ffastun.ffa",    FALSE,  _SH },  // Office 97 only used hidden, O2K uses SH
    { L"X:\\ffastun.ffl",    FALSE,  _SH },
    { L"X:\\ffastun.ffx",    FALSE,  _SH },
    { L"X:\\ffastun0.ffx",   FALSE,  _SH },
    { L"X:\\ffstunt.ffl",    FALSE,  _SH },
    { L"X:\\sms.ini",        FALSE,  _SH },  // SMS
    { L"X:\\sms.new",        FALSE,  _SH },
    { L"X:\\sms_time.dat",   FALSE,  _SH },
    { L"X:\\smsdel.dat",     FALSE,  _SH },
    { L"X:\\mpcsetup.log",   FALSE,  _H  },  // Microsoft Proxy Server
    { L"X:\\detlog.txt",     FALSE,  _SH },  // Win9x PNP detection log
    { L"X:\\detlog.old",     FALSE,  _SH },  // Win9x PNP detection log
    { L"X:\\setuplog.txt",   FALSE,  _SH },  // Win9x setup log
    { L"X:\\setuplog.old",   FALSE,  _SH },  // Win9x setup log
    { L"X:\\suhdlog.dat",    FALSE,  _SH },  // Win9x setup log
    { L"X:\\suhdlog.---",    FALSE,  _SH },  // Win9x setup log
    { L"X:\\suhdlog.bak",    FALSE,  _SH },  // Win9x setup log
    { L"X:\\system.1st",     FALSE,  _SH },  // Win95 system.dat backup
    { L"X:\\netlog.txt",     FALSE,  _SH },  // Win9x network setup log file
    { L"X:\\setup.aif",      FALSE,  _SH },  // NT4 unattended setup script
    { L"X:\\catlog.wci",     FALSE,  _H  },  // index server folder
    { L"X:\\cmsstorage.lst", FALSE,  _SH },  // Microsoft Media Manager
};

WCHAR   szWinDir[MAX_PATH];
DWORD   i, j;
DWORD   Result;

    //
    // Get the drive letter that we installed on.
    //
    Result = GetWindowsDirectory(szWinDir, MAX_PATH);
    if( Result == 0) {
        MYASSERT(FALSE);
        return;
    }

    for( i = 0; i < (sizeof(FilesToFix)/sizeof(FilesToFix[0])); i++ ) {
        //
        // First we need to fixup the path.  This is really gross, but lots
        // of these files will be on the system partition and lots will be
        // on the partition where we installed, which may not be the same.
        // Rather than figuring out which of these live on which partition
        // and ensuring that this is true for all flavors of NT, just
        // process both locations.
        //
        for( j = 0; j < 2; j++ ) {
            if( j & 1 ) {
                FilesToFix[i].FileName[0] = szWinDir[0];
            } else {
#ifdef _X86_
                FilesToFix[i].FileName[0] = x86SystemPartitionDrive;
#else
                FilesToFix[i].FileName[0] = L'C';
#endif
            }

            //
            // Now set the attributes.
            //
            SetFileAttributes( FilesToFix[i].FileName, FilesToFix[i].Attributes );
        }

    }

}



DWORD
TreeCopy(
    IN PCWSTR SourceDir,
    IN PCWSTR TargetDir
    )
{
    DWORD d;
    WCHAR Pattern[MAX_PATH];
    WCHAR NewTarget[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    // First create the target directory if it doesn't already exist.
    //
    if(!CreateDirectory(TargetDir,NULL)) {
        d = GetLastError();
        if(d != ERROR_ALREADY_EXISTS) {
            return(d);
        }
    }

    //
    // Copy each file in the source directory to the target directory.
    // If any directories are encountered along the way recurse to copy them
    // as they are encountered.
    //
    // Start by forming the search pattern, which is <sourcedir>\*.
    //
    lstrcpyn(Pattern,SourceDir,MAX_PATH);
    pSetupConcatenatePaths(Pattern,L"*",MAX_PATH,NULL);

    //
    // Start the search.
    //
    FindHandle = FindFirstFile(Pattern,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {

        d = NO_ERROR;

    } else {

        do {

            //
            // Form the full name of the file or directory we just found
            // as well as its name in the target.
            //
            lstrcpyn(Pattern,SourceDir,MAX_PATH);
            pSetupConcatenatePaths(Pattern,FindData.cFileName,MAX_PATH,NULL);

            lstrcpyn(NewTarget,TargetDir,MAX_PATH);
            pSetupConcatenatePaths(NewTarget,FindData.cFileName,MAX_PATH,NULL);

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //
                if(lstrcmp(FindData.cFileName,TEXT("." )) && lstrcmp(FindData.cFileName,TEXT(".."))) {
                    d = TreeCopy(Pattern,NewTarget);
                } else {
                    d = NO_ERROR;
                }

            } else {

                //
                // The current match is not a directory -- so copy it.
                //
                SetFileAttributes(NewTarget,FILE_ATTRIBUTE_NORMAL);
                d = CopyFile(Pattern,NewTarget,FALSE) ? NO_ERROR : GetLastError();
            }
        } while((d==NO_ERROR) && FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    return(d);
}


VOID
DelSubNodes(
    IN PCWSTR Directory
    )
{
    WCHAR Pattern[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    // Delete each file in the given directory, but DO NOT remove the directory itself.
    // If any directories are encountered along the way recurse to delete them
    // as they are encountered.
    //
    // Start by forming the search pattern, which is <currentdir>\*.
    //
    lstrcpyn(Pattern,Directory,MAX_PATH);
    pSetupConcatenatePaths(Pattern,L"*",MAX_PATH,NULL);

    //
    // Start the search.
    //
    FindHandle = FindFirstFile(Pattern,&FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file or directory we just found.
            //
            lstrcpyn(Pattern,Directory,MAX_PATH);
            pSetupConcatenatePaths(Pattern,FindData.cFileName,MAX_PATH,NULL);

            //
            // Remove read-only atttribute if it's there.
            //
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(Pattern,FILE_ATTRIBUTE_NORMAL);
            }

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //
                if(lstrcmp(FindData.cFileName,TEXT("." )) && lstrcmp(FindData.cFileName,TEXT(".."))) {
                    Delnode(Pattern);
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //
                if(!DeleteFile(Pattern)) {
                    SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_DELNODE_FAIL,
                        Pattern, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                        szDeleteFile,
                        GetLastError(),
                        Pattern,
                        NULL,NULL);
                }
            }
        } while(FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

}


VOID
Delnode(
    IN PCWSTR Directory
    )
{
    WCHAR Pattern[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    // Delete each file in the given directory, then remove the directory itself.
    // If any directories are encountered along the way recurse to delete them
    // as they are encountered.
    //
    // Start by forming the search pattern, which is <currentdir>\*.
    //
    lstrcpyn(Pattern,Directory,MAX_PATH);
    pSetupConcatenatePaths(Pattern,L"*",MAX_PATH,NULL);

    //
    // Start the search.
    //
    FindHandle = FindFirstFile(Pattern,&FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {

            //
            // Form the full name of the file or directory we just found.
            //
            lstrcpyn(Pattern,Directory,MAX_PATH);
            pSetupConcatenatePaths(Pattern,FindData.cFileName,MAX_PATH,NULL);

            //
            // Remove read-only atttribute if it's there.
            //
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                SetFileAttributes(Pattern,FILE_ATTRIBUTE_NORMAL);
            }

            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //
                if(lstrcmp(FindData.cFileName,TEXT("." )) && lstrcmp(FindData.cFileName,TEXT(".."))) {
                    Delnode(Pattern);
                }

            } else {

                //
                // The current match is not a directory -- so delete it.
                //
                if(!DeleteFile(Pattern)) {
                    SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_DELNODE_FAIL,
                        Pattern, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                        szDeleteFile,
                        GetLastError(),
                        Pattern,
                        NULL,NULL);
                }
            }
        } while(FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out. Ignore errors.
    //
    SetFileAttributes(Directory,FILE_ATTRIBUTE_NORMAL);
    RemoveDirectory(Directory);
}


VOID
RemoveServicePackEntries(
    HKEY hKey
    )
/*
    This routine takes in the Handle to the Software\Microsoft\Windows NT\CurrentVersion\Hotfix\ServicePackUninstall
    key and then enumerates each value entry under it.

    It then takes the value data and appends that to the

    "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\" and delnodes that key. This
    way we have an extensible mechanism to always cleanup the Uninstall keys for ServicePacks.


*/
{

#define UNINSTALLKEY L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\"
#define UNINSTALLKEYLEN     (sizeof(UNINSTALLKEY) / sizeof(WCHAR) - 1)

    DWORD Status,MaxValueName=0,MaxValue=0,Values=0,i;
    DWORD TempMaxNameSize, TempMaxDataSize;
    PWSTR ValueName, ValueData;


    Status = RegQueryInfoKey( hKey,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &Values,
                            &MaxValueName,
                            &MaxValue,
                            NULL,
                            NULL );

     //Account forterminating null

     if( Status == ERROR_SUCCESS ){

         MaxValueName += 2;
         MaxValue = MaxValue + 2 + lstrlen(UNINSTALLKEY);

         ValueName = MyMalloc( MaxValueName * sizeof(WCHAR) );
         ValueData = MyMalloc( MaxValue * sizeof(WCHAR) );

         if( !ValueName || !ValueData )
             return;

         lstrcpy( ValueData, UNINSTALLKEY );


         for (i=0; i < Values; i++){

             TempMaxNameSize = MaxValueName;
             TempMaxDataSize = MaxValue;

             Status = RegEnumValue( hKey,
                                    i,
                                    ValueName,
                                    &TempMaxNameSize,
                                    NULL,
                                    NULL,
                                    (LPBYTE)(ValueData+lstrlen(UNINSTALLKEY)),
                                    &TempMaxDataSize
                                    );

             if( Status == ERROR_SUCCESS ){

                 pSetupRegistryDelnode( HKEY_LOCAL_MACHINE, ValueData );

              }

          }

      }
      MyFree( ValueName );
      MyFree( ValueData );
      return;

}







VOID
RemoveHotfixData(
    VOID
    )
{
    WCHAR Path[MAX_PATH];
    WCHAR KBNumber[64];
    WCHAR UninstallKey[MAX_PATH];
    DWORD i = 0;
    DWORD prefixSize = 0;
    DWORD Status, SubKeys;
    HKEY hKey, SvcPckKey;
    REGVALITEM SoftwareKeyItems[1];

    //
    //For each hotfix, the registry info is stored under
    //                 HKLM\Software\Microsoft\Windows NT\CurrentVersion\Hotfix\<KB#>
    //                 and the files are stored under
    //                 %windir%\$NtUninstall<KB#>$

    //
    //Enumerate the hotfix key and remove the files and registry entries for each hotfix.
    //
#define HOTFIXAPPKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix"

    Status = RegOpenKey(HKEY_LOCAL_MACHINE, HOTFIXAPPKEY, &hKey);
    if( Status != ERROR_SUCCESS ) {
        return;
    }

    Status = RegQueryInfoKey( hKey,
                              NULL,
                              NULL,
                              NULL,
                              &SubKeys,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if(Status == ERROR_SUCCESS) {

       Status = GetWindowsDirectory(Path, MAX_PATH);
       if(Status == 0) {
           MYASSERT(FALSE);
           return;
       }
       pSetupConcatenatePaths(Path,L"$NtUninstall",MAX_PATH,&prefixSize);
       lstrcpy(UninstallKey, UNINSTALLKEY);

       for( i = 0; i < SubKeys; i++ ) {

              Status = RegEnumKey(hKey, i, KBNumber, sizeof(KBNumber) / sizeof(KBNumber[0]));

              if (Status == ERROR_SUCCESS) {

                  if( !lstrcmpi( KBNumber, TEXT("ServicePackUninstall") ) ){
                      Status = RegOpenKey(hKey,KBNumber,&SvcPckKey);
                      if( Status == ERROR_SUCCESS ){
                        RemoveServicePackEntries(SvcPckKey);
                        RegCloseKey(SvcPckKey);
                      }

                  }else{
                      lstrcpyn(Path + prefixSize - 1, KBNumber, MAX_PATH - prefixSize);
                      lstrcat(Path, L"$");
                      Delnode(Path);
                      //
                      // Remove the entry from the Add/Remove Programs key.
                      // UNINSTALLKEY ends with '\\'
                      //
                      lstrcpy(UninstallKey + UNINSTALLKEYLEN, KBNumber);
                      pSetupRegistryDelnode(HKEY_LOCAL_MACHINE, UninstallKey);
                  }
              }
       }

    }

    RegCloseKey(hKey);
    pSetupRegistryDelnode(HKEY_LOCAL_MACHINE, HOTFIXAPPKEY);

    //
    // delete HKLM\SOFTWARE\Microsoft\Updates\Windows 2000 key since it contains entries for SPs/QFEs for win2k
    //
    pSetupRegistryDelnode(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Updates\\Windows 2000");

    //
    // We need to hack something for Exchange because they check for
    // a hotfix (irregardless of the OS version...
    //
    i = 1;
    SoftwareKeyItems[0].Name = L"Installed";
    SoftwareKeyItems[0].Data = &i;
    SoftwareKeyItems[0].Size = sizeof(DWORD);
    SoftwareKeyItems[0].Type = REG_DWORD;
    SetGroupOfValues(HKEY_LOCAL_MACHINE,L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix\\Q147222",SoftwareKeyItems,1);

}




VOID
DeleteLocalSource(
    VOID
    )
{
    WCHAR str[4];

    if(WinntBased && !AllowRollback) {
        if(SourcePath[0] && (SourcePath[1] == L':') && (SourcePath[2] == L'\\')) {

            lstrcpyn(str,SourcePath,4);
            if(GetDriveType(str) != DRIVE_CDROM) {
                Delnode(SourcePath);
#ifdef _X86_
                if (IsNEC_98 && !lstrcmpi(&SourcePath[2], pwLocalSource)) {
                    HKEY hkey;
                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"System\\Setup",0,MAXIMUM_ALLOWED,&hkey) == NO_ERROR) {
                        RegDeleteValue(hkey, L"ForcePlatform");
                        RegCloseKey(hkey);
                    }
                }
#endif
            }
        }


#if defined(_AMD64_) || defined(_X86_)
        //
        // Get rid of floppyless boot stuff.
        //
        if(FloppylessBootPath[0]) {

            WCHAR Path[MAX_PATH];

            //
            // NEC98 should back boot related files in \$WIN_NT$.~BU,
            // to restore boot files for keep original OS in each partition.
            //
            if (IsNEC_98) { //NEC98
                lstrcpy(Path,FloppylessBootPath);
                pSetupConcatenatePaths(Path,L"$WIN_NT$.~BU",MAX_PATH,NULL);
                Delnode(Path);
            } //NEC98

            lstrcpy(Path,FloppylessBootPath);
            pSetupConcatenatePaths(Path,L"$WIN_NT$.~BT",MAX_PATH,NULL);
            Delnode(Path);

            lstrcpy(Path,FloppylessBootPath);
            pSetupConcatenatePaths(Path,L"$LDR$",MAX_PATH,NULL);
            SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(Path);

            lstrcpy(Path,FloppylessBootPath);
            pSetupConcatenatePaths(Path,L"TXTSETUP.SIF",MAX_PATH,NULL);
            SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(Path);

            //
            // Get rid of arc loader files.
            //
            if( !IsArc() ) {

                lstrcpy(Path,FloppylessBootPath);
                pSetupConcatenatePaths(Path,L"ARCLDR.EXE",MAX_PATH,NULL);
                SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Path);

                lstrcpy(Path,FloppylessBootPath);
                pSetupConcatenatePaths(Path,L"ARCSETUP.EXE",MAX_PATH,NULL);
                SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
                DeleteFile(Path);

            }
        }

        //
        // get rid of the boot.bak file
        //
        {
            WCHAR szBootBak[] = L"?:\\BOOT.BAK";

            szBootBak[0] = x86SystemPartitionDrive;
            SetFileAttributes(szBootBak,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szBootBak);
        }
#endif  // defined(_AMD64_) || defined(_X86_)

#if defined(_IA64_)
        //
        // Get rid of SETUPLDR
        //
        {
            WCHAR Path[MAX_PATH];
            UNICODE_STRING UnicodeString;
            WCHAR Buffer[MAX_PATH];
            PWCHAR pwChar;
            PWSTR NtPath;
            BOOLEAN OldPriv, DontCare;
            OBJECT_ATTRIBUTES ObjAttrib;


            Buffer[0] = UNICODE_NULL;

            //
            // Make sure we have privilege to get/set nvram vars.
            //
            RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &OldPriv
                );

            RtlInitUnicodeString(&UnicodeString,L"SYSTEMPARTITION");
            NtQuerySystemEnvironmentValue(
               &UnicodeString,
               Buffer,
               sizeof(Buffer)/sizeof(WCHAR),
               NULL
               );

            //
            // Restore previous privilege.
            //
            RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                OldPriv,
                FALSE,
                &DontCare
                );

            //
            // Strip everything from ';' to end of string since previous strings
            // are appended to the current string and are separated by ';'.
            //
            pwChar = Buffer;
            while ((*pwChar != L'\0') && (*pwChar != L';')) {
                pwChar++;
            }
            *pwChar = L'\0';

            NtPath = ArcDevicePathToNtPath(Buffer);
            if (NtPath) {

                lstrcpy(Path,NtPath);
                pSetupConcatenatePaths(Path,SETUPLDR,MAX_PATH,NULL);
                RtlInitUnicodeString(&UnicodeString,Path);
                InitializeObjectAttributes(
                    &ObjAttrib,
                    &UnicodeString,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );
                NtDeleteFile(&ObjAttrib);

                MyFree( NtPath );

            }
        }
#endif  // defined(_IA64_)

    }
}


BOOL
ValidateAndChecksumFile(
    IN  PCTSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    )

/*++

Routine Description:

    Calculate a checksum value for a file using the standard
    nt image checksum method.  If the file is an nt image, validate
    the image using the partial checksum in the image header.  If the
    file is not an nt image, it is simply defined as valid.

    If we encounter an i/o error while checksumming, then the file
    is declared invalid.

Arguments:

    Filename - supplies full NT path of file to check.

    IsNtImage - Receives flag indicating whether the file is an
                NT image file.

    Checksum - receives 32-bit checksum value.

    Valid - receives flag indicating whether the file is a valid
            image (for nt images) and that we can read the image.

Return Value:

    BOOL - Returns TRUE if the flie was validated, and in this case,
           IsNtImage, Checksum, and Valid will contain the result of
           the validation.
           This function will return FALSE, if the file could not be
           validated, and in this case, the caller should call GetLastError()
           to find out why this function failed.

--*/

{
    DWORD  Error;
    PVOID BaseAddress;
    ULONG FileSize;
    HANDLE hFile,hSection;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG HeaderSum;

    //
    // Assume not an image and failure.
    //
    *IsNtImage = FALSE;
    *Checksum = 0;
    *Valid = FALSE;

    //
    // Open and map the file for read access.
    //

    Error = pSetupOpenAndMapFileForRead( Filename,
                                    &FileSize,
                                    &hFile,
                                    &hSection,
                                    &BaseAddress );

    if( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        return(FALSE);
    }

    if( FileSize == 0 ) {
        *IsNtImage = FALSE;
        *Checksum = 0;
        *Valid = TRUE;
        CloseHandle( hFile );
        return(TRUE);
    }


    try {
        NtHeaders = CheckSumMappedFile(BaseAddress,FileSize,&HeaderSum,Checksum);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        *Checksum = 0;
        NtHeaders = NULL;
    }

    //
    // If the file is not an image and we got this far (as opposed to encountering
    // an i/o error) then the checksum is declared valid.  If the file is an image,
    // then its checksum may or may not be valid.
    //

    if(NtHeaders) {
        *IsNtImage = TRUE;
        *Valid = HeaderSum ? (*Checksum == HeaderSum) : TRUE;
    } else {
        *Valid = TRUE;
    }

    pSetupUnmapAndCloseFile( hFile, hSection, BaseAddress );
    return( TRUE );
}


DWORD
QueryHardDiskNumber(
    IN  UCHAR   DriveLetter
    )

{
    WCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    driveName[0] = '\\';
    driveName[1] = '\\';
    driveName[2] = '.';
    driveName[3] = '\\';
    driveName[4] = DriveLetter;
    driveName[5] = ':';
    driveName[6] = 0;

    h = CreateFile(driveName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                   INVALID_HANDLE_VALUE);
    if (h == INVALID_HANDLE_VALUE) {
        return (DWORD) -1;
    }

    b = DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                        &number, sizeof(number), &bytes, NULL);
    CloseHandle(h);

    if (!b) {
        return (DWORD) -1;
    }

    return number.DeviceNumber;
}


BOOL
ExtendPartition(
    IN WCHAR    DriveLetter,
    IN ULONG    SizeMB      OPTIONAL
    )

/*++

Routine Description:

    This function will extend a partition.

    We'll do this in the following way:
    1. Figure out if the partition is NTFS.
    2. Figure out if there's any unpartitioned space behind
       the partition the user is asking us to extend.
    3. How much space is available?
    4. Extend the partition
    5. Extend the filesystem (inform him the partition is bigger).



Arguments:

    DriveLetter - Supplies the driveletter for the partition
                  that we'll be extending.

    SizeMB      - if specified, indicates the size in MB by which
                  the partition will grow. If not specified, the
                  partition grows to encompass all the free space
                  in the adjacent free space.

Return Value:

    Boolean value indicating whether anything actually changed.

--*/

{
#define                     LEAVE_FREE_BUFFER (5 * (1024*1024))
HANDLE                      h;
PARTITION_INFORMATION_EX    PartitionInfo;
BOOL                        b;
DWORD                       Bytes;
DISK_GEOMETRY               Geometry;
DISK_GROW_PARTITION         GrowInfo;
TCHAR                       PhysicalName[MAX_PATH];
TCHAR                       DosName[10];
LARGE_INTEGER               BytesAvailable;
LARGE_INTEGER               OurPartitionEndingLocation;
DWORD                       i;
PDRIVE_LAYOUT_INFORMATION_EX  DriveLayout;

    //
    // =====================================
    // 1. Figure out if the partition is NTFS.
    // =====================================
    //
    DosName[0] = DriveLetter;
    DosName[1] = TEXT(':');
    DosName[2] = TEXT('\\');
    DosName[3] = TEXT('\0');
    b = GetVolumeInformation(
            DosName,
            NULL,0,                 // don't care about volume name
            NULL,                   // ...or serial #
            &i,                     // ...or max component length
            &i,                     // ... or flags
            PhysicalName,
            sizeof(PhysicalName)/sizeof(TCHAR)
            );
    if( !b ) {
        return FALSE;
    }

    if(lstrcmpi(PhysicalName,TEXT("NTFS"))) {
        //
        // Our partition isn't NTFS.  Bail.
        //
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %ws is not NTFS volume\n",
            DosName);
            
        return FALSE;
    }



    //
    // Now initialize the name for this partition and
    // the name for this drive.
    //
    wsprintf( DosName, TEXT("\\\\.\\%c:"), DriveLetter );
    wsprintf( PhysicalName, TEXT("\\\\.\\PhysicalDrive%u"), QueryHardDiskNumber( (UCHAR)DriveLetter) );


    //
    // =====================================
    // 2. Figure out if there's any unpartitioned space behind
    //    the partition the user is asking us to extend.
    // =====================================
    //

    //
    // Get a handle to the disk so we can start examination.
    //
    h = CreateFile( PhysicalName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
                    NULL );

    if( h == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while opening %ws\n",
            GetLastError(),
            PhysicalName);
            
        return FALSE;
    }



    //
    // Get the disk's layout information.  We aren't
    // sure how big of a buffer we need, so brute-force it.
    //
    {
    DWORD   DriveLayoutSize = 1024;
    PVOID   p;

        DriveLayout = MyMalloc(DriveLayoutSize);
        if( !DriveLayout ) {
            CloseHandle( h );
            return FALSE;
        }

retry:

        b = DeviceIoControl( h,
                             IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                             NULL,
                             0,
                             (PVOID)DriveLayout,
                             DriveLayoutSize,
                             &Bytes,
                             NULL );

        if( !b ) {
            DWORD LastError = GetLastError();
            
            if (LastError == ERROR_INSUFFICIENT_BUFFER) {
                DriveLayoutSize += 1024;
                
                if(p = MyRealloc((PVOID)DriveLayout,DriveLayoutSize)) {
                    (PVOID)DriveLayout = p;
                } else {
                    goto cleanexit0;
                }
                goto retry;
            } else {
                DbgPrintEx( DPFLTR_SETUP_ID, 
                    DPFLTR_INFO_LEVEL, 
                    "ExtendPartition: %X Error while getting drive layout for %ws\n",
                    LastError,
                    PhysicalName);
            
                goto cleanexit0;
            }
        }
    }

    CloseHandle( h );
    h = INVALID_HANDLE_VALUE;



    //
    // DriveLayout now is full of most of the information we
    // need, including an array of partition information.  But
    // we aren't sure which partition is ours.  We need to
    // get info on our specific partition, then match it
    // against the entry inside DriveLayout.
    //


    //
    // Open a handle to the partition.
    //
    h = CreateFile( DosName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE );

    if( h == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while opening %ws\n",
            GetLastError(),
            DosName);
            
        return FALSE;
    }

    //
    // Load info about our partition.
    //
    b = DeviceIoControl( h,
                         IOCTL_DISK_GET_PARTITION_INFO_EX,
                         NULL,
                         0,
                         &PartitionInfo,
                         sizeof(PartitionInfo),
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while getting %ws's partition information\n",
            GetLastError(),
            DosName);
    
        goto cleanexit0;
    }


    //
    // Might as well get the geometry info on the disk too.
    //
    b = DeviceIoControl( h,
                         IOCTL_DISK_GET_DRIVE_GEOMETRY,
                         NULL,
                         0,
                         &Geometry,
                         sizeof(Geometry),
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while getting %ws's drive geometry\n",
            GetLastError(),
            DosName);
            
        goto cleanexit0;
    }

    CloseHandle( h );
    h = INVALID_HANDLE_VALUE;



    //
    // =====================================
    // 3. How much space is available?
    // =====================================
    //

    //
    // We're ready to actually verify that there's rooom for us to grow.
    // If we're the last partition on the disk, we need to see if there's
    // any room behind us (i.e. any unpartitioned space).  If we're not
    // the last partition, we need to see if there's any space between where
    // our partition ends and the next partition begins.
    //
    // This is really gross, but DriveLayout->PartitionCount will likely be 4
    // even if there's really only 1 formatted partition on the disk.  We also
    // don't want to take the chance that the partitions aren't ordered by their
    // location on the disk.  So we need to go cycle through the partitions
    // again and manually find the one that starts right after ours.
    //
    OurPartitionEndingLocation.QuadPart = PartitionInfo.StartingOffset.QuadPart + PartitionInfo.PartitionLength.QuadPart;

    //
    // Initialize BytesAvailable based on the space from where our partition ends to where
    // the disk ends.  This is the best case and we can only get smaller sizes, so this
    // is safe.
    //
    BytesAvailable.QuadPart = UInt32x32To64( Geometry.BytesPerSector, Geometry.SectorsPerTrack );
    BytesAvailable.QuadPart = BytesAvailable.QuadPart * (ULONGLONG)(Geometry.TracksPerCylinder);
    BytesAvailable.QuadPart = BytesAvailable.QuadPart * Geometry.Cylinders.QuadPart;
    BytesAvailable.QuadPart = BytesAvailable.QuadPart - OurPartitionEndingLocation.QuadPart;

    for( i = 0; i < DriveLayout->PartitionCount; i++ ) {
        if( (DriveLayout->PartitionEntry[i].StartingOffset.QuadPart > OurPartitionEndingLocation.QuadPart) &&
            ((DriveLayout->PartitionEntry[i].StartingOffset.QuadPart - OurPartitionEndingLocation.QuadPart) < BytesAvailable.QuadPart) ) {

            //
            // This partition is starting after ours and it's also the closest one we've found
            // to our ending location.
            //
            BytesAvailable.QuadPart = DriveLayout->PartitionEntry[i].StartingOffset.QuadPart - OurPartitionEndingLocation.QuadPart;
        }
    }


    //
    // Reserve the space at the disk end only for MBR disks
    //
    if (DriveLayout->PartitionStyle == PARTITION_STYLE_MBR) {
        //
        // If we don't have at least 5MB available, don't even bother.  If we do, leave the last
        // 5MB free for later use as a dynamic volume.
        //
        if( BytesAvailable.QuadPart < (ULONGLONG)(LEAVE_FREE_BUFFER) ) {
            goto cleanexit0;
        } else {
            BytesAvailable.QuadPart = BytesAvailable.QuadPart - (ULONGLONG)(LEAVE_FREE_BUFFER);
        }
    }        

    //
    // See if the user has asked us to extend by some known value...
    //
    if( SizeMB ) {
        //
        // Yes.  Make sure we have atleast this much space to extend.
        //
        if( (LONGLONG)(SizeMB * (1024*1024)) < BytesAvailable.QuadPart ) {
            BytesAvailable.QuadPart = UInt32x32To64( SizeMB, (1024*1024) );
        }
    }





    //
    // =====================================
    // 4. Extend the partition
    // =====================================
    //

    //
    // Get a handle to the disk.
    //
    h = CreateFile( PhysicalName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING,
                    NULL );

    if( h == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while opening %ws\n",
            GetLastError(),
            PhysicalName);
            
        return FALSE;
    }


    //
    // Fill in the datastructure we'll be sending to the IOCTL.
    //
    GrowInfo.PartitionNumber = PartitionInfo.PartitionNumber;
    GrowInfo.BytesToGrow = BytesAvailable;


    //
    // Do it.
    //
    b = DeviceIoControl( h,
                         IOCTL_DISK_GROW_PARTITION,
                         &GrowInfo,
                         sizeof(GrowInfo),
                         NULL,
                         0,
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while growing %ws partition\n",
            GetLastError(),
            PhysicalName);
            
        goto cleanexit0;
    }

    CloseHandle( h );
    h = INVALID_HANDLE_VALUE;





    //
    // =====================================
    // 5. Extend the filesystem (inform him the partition is bigger).
    // =====================================
    //



    //
    // Get a handle to the partition.
    //
    h = CreateFile( DosName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    INVALID_HANDLE_VALUE );

    if( h == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while opening %ws\n",
            GetLastError(),
            DosName);

        goto cleanexit0;
    }



    //
    // Gather some info on the partition.
    //
    b = DeviceIoControl( h,
                         IOCTL_DISK_GET_PARTITION_INFO_EX,
                         NULL,
                         0,
                         &PartitionInfo,
                         sizeof(PartitionInfo),
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while getting %ws's partition information\n",
            GetLastError(),
            DosName);
            
        goto cleanexit0;
    }


    //
    // Grow the volume.
    //
    BytesAvailable.QuadPart = PartitionInfo.PartitionLength.QuadPart / Geometry.BytesPerSector;

    b = DeviceIoControl( h,
                         FSCTL_EXTEND_VOLUME,
                         &BytesAvailable,
                         sizeof(BytesAvailable),
                         NULL,
                         0,
                         &Bytes,
                         NULL );

    if( !b ) {
        DbgPrintEx( DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL, 
            "ExtendPartition: %X Error while extending volume %ws\n",
            GetLastError(),
            DosName);
            
        goto cleanexit0;
    }

cleanexit0:
    if( h != INVALID_HANDLE_VALUE ) {
        CloseHandle( h );
    }


    //
    // If we successfully extended the partition
    // then mark the global flag to remove any
    // stale volume information, at the end of setup.
    //
    if (b) {
        PartitionExtended = TRUE;
    }

    return b;
}



BOOL
SetupExtendPartition(
    IN WCHAR    DriveLetter,
    IN ULONG    SizeMB      OPTIONAL
    )
{
    BOOL b;

    if ( b = ExtendPartition(DriveLetter, SizeMB) )
    {
        RemoveStaleVolumes();
        PartitionExtended = FALSE;
    }

    return b;
}


BOOL
DoFilesMatch(
    IN PCWSTR File1,
    IN PCWSTR File2
    )
/*++

Routine Description:

    Compares two files to each other to see if they are identical.

Arguments:

    File1 - First file to compare
    File2 - Second file to compare


Return Value:

    BOOL - Returns TRUE if the files match.  If the both of the files are zero
    length, then we still return TRUE.

--*/
{
    DWORD FirstFileSize, SecondFileSize;
    HANDLE FirstFileHandle, FirstMappingHandle;
    HANDLE SecondFileHandle, SecondMappingHandle;
    PVOID FirstBaseAddress, SecondBaseAddress;

    BOOL RetVal = FALSE;

    if(   (pSetupOpenAndMapFileForRead(
                     File1,
                     &FirstFileSize,
                     &FirstFileHandle,
                     &FirstMappingHandle,
                     &FirstBaseAddress) == NO_ERROR)
       && (pSetupOpenAndMapFileForRead(
                     File1,
                     &SecondFileSize,
                     &SecondFileHandle,
                     &SecondMappingHandle,
                     &SecondBaseAddress) == NO_ERROR) ) {

        if (FirstFileSize == SecondFileSize ) {
            if (FirstFileSize != 0) {
                //
                // protect against inpage IO error
                //
                try {
                    RetVal = !memcmp(
                                 FirstBaseAddress,
                                 SecondBaseAddress,
                                 FirstFileSize
                                 );
                } except(EXCEPTION_EXECUTE_HANDLER) {
                      RetVal = FALSE;
                }
            }
        }

        pSetupUnmapAndCloseFile(
                    FirstFileHandle,
                    FirstMappingHandle,
                    FirstBaseAddress
                    );

        pSetupUnmapAndCloseFile(
                    SecondFileHandle,
                    SecondMappingHandle,
                    SecondBaseAddress
                    );

    }

    return (RetVal);
}

DWORD
RemoveStaleVolumes(
    VOID
    )
/*++

Routine Description:

    This routine walks through all the volumes and deletes the one 
    which are marked for reinstall. 

    NOTE : Use the function carefully because it will nuke all
    the entries related to the volume from the registry, iff the volume
    says it needs to be reinstalled.

Arguments:

    None.
    
Return Value:

    Appropriate Win32 error code.

--*/
{
    const TCHAR *VolumeKeyName = TEXT("System\\CurrentControlSet\\Enum\\Storage\\Volume");
    const TCHAR *ClassKeyName = TEXT("System\\CurrentControlSet\\Control\\Class");

    DWORD   ErrorCode;
    HKEY    VolumeKey = NULL;
    HKEY    ClassKey = NULL;
    ULONG   Index = 0;
    ULONG   VolumesFixedCount = 0;
    TCHAR   SubKeyName[MAX_PATH*2];
    DWORD   SubKeyLength;
    FILETIME SubKeyTime;

    //
    // Open the Volume key
    //
    ErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    VolumeKeyName,
                    0,
                    KEY_ALL_ACCESS,
                    &VolumeKey);

    if (VolumeKey == NULL) {
        ErrorCode = ERROR_INVALID_HANDLE;
    }        
    
    if (ErrorCode != ERROR_SUCCESS) {
        return ErrorCode;
    }

    //
    // Open the Class key
    //
    ErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    ClassKeyName,
                    0,
                    KEY_ALL_ACCESS,
                    &ClassKey);

    if (ClassKey == NULL) {
        ErrorCode = ERROR_INVALID_HANDLE;
    }        
    
    if (ErrorCode != ERROR_SUCCESS) {
        RegCloseKey(VolumeKey);
        
        return ErrorCode;
    }

    //
    // Enumerate each subkey of the opened key
    //
    while (TRUE) {        
        SubKeyName[0] = 0;
        SubKeyLength = sizeof(SubKeyName) / sizeof(SubKeyName[0]);
        
        ErrorCode = RegEnumKeyEx(VolumeKey,
                        Index,
                        SubKeyName,
                        &SubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        &SubKeyTime);

        if (ErrorCode == ERROR_SUCCESS) {
            TCHAR   FullSubKeyName[MAX_PATH*4];
            DWORD   SubErrorCode;
            HKEY    CurrentSubKey = NULL;
            GUID    VolumeGuid = {0};
            TCHAR   VolumeGuidStr[MAX_PATH] = {0};
            DWORD   DrvInstance = -1;            
            BOOL    DeleteKey = FALSE;
            BOOL    DeleteClassInstance = FALSE;
            BOOL    IncrementKeyIndex = TRUE;
            
            _tcscpy(FullSubKeyName, VolumeKeyName);
            _tcscat(FullSubKeyName, TEXT("\\"));
            _tcscat(FullSubKeyName, SubKeyName);

            SubErrorCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                FullSubKeyName,
                                0,
                                KEY_ALL_ACCESS,
                                &CurrentSubKey);

            if (SubErrorCode == ERROR_SUCCESS) {
                //
                // Read the ConfigFlags value
                //
                DWORD   ConfigFlags = 0;
                DWORD   Type = REG_DWORD;
                DWORD   BufferSize = sizeof(DWORD);

                SubErrorCode = RegQueryValueEx(CurrentSubKey,
                                    TEXT("ConfigFlags"),
                                    NULL,
                                    &Type,
                                    (PBYTE)&ConfigFlags,
                                    &BufferSize);

                if (SubErrorCode == ERROR_SUCCESS) {     

                    DeleteKey = (ConfigFlags & (CONFIGFLAG_REINSTALL | CONFIGFLAG_FINISH_INSTALL));

                    if (DeleteKey) {                        
                        Type = REG_BINARY;
                        BufferSize = sizeof(VolumeGuid);

                        //
                        // Read the GUID & DrvInst values
                        //                        
                        SubErrorCode = RegQueryValueEx(CurrentSubKey,
                                            TEXT("GUID"),
                                            NULL,
                                            &Type,
                                            (PBYTE)&VolumeGuid,
                                            &BufferSize);

                        if (SubErrorCode == ERROR_SUCCESS) {                            
                            Type = REG_DWORD;
                            BufferSize = sizeof(DWORD);
                            
                            SubErrorCode = RegQueryValueEx(CurrentSubKey,
                                                TEXT("DrvInst"),
                                                NULL,
                                                &Type,
                                                (PBYTE)&DrvInstance,
                                                &BufferSize);

                            DeleteClassInstance = 
                                (SubErrorCode == ERROR_SUCCESS) &&
                                (DrvInstance != -1);
                        }
                    }
                }

                //
                // Close the current subkey since we don't need it anymore
                //
                RegCloseKey(CurrentSubKey);

                //
                // Delete after we close the current key
                //
                if (DeleteKey) {
                    SubErrorCode = SHDeleteKey(HKEY_LOCAL_MACHINE,
                                        FullSubKeyName);

                    if (SubErrorCode == ERROR_SUCCESS) {
                        VolumesFixedCount++;
                        IncrementKeyIndex = FALSE;
                    } 
                }                                    

                //
                // Delete the instance key under class also if needed
                //
                if (DeleteClassInstance && 
                    (pSetupStringFromGuid(&VolumeGuid,
                            VolumeGuidStr,
                            sizeof(VolumeGuidStr)/sizeof(VolumeGuidStr[0])) == ERROR_SUCCESS)) {                                                                        
                    _stprintf(FullSubKeyName,
                        TEXT("System\\CurrentControlSet\\Control\\Class\\%ws\\%04d"),
                        VolumeGuidStr, 
                        DrvInstance);

                    SubErrorCode = SHDeleteKey(HKEY_LOCAL_MACHINE,
                                        FullSubKeyName);                           
                }
            } 
            
            if (IncrementKeyIndex) {
                Index++;
            }                
        } else {
            break;  // we couldn't enumerate further sub keys
        }            
    }

    RegCloseKey(ClassKey);
    RegCloseKey(VolumeKey);    

    //
    // If we fixed at least a single volume then assume things
    // went fine
    //
    if (VolumesFixedCount > 0) {
        ErrorCode = ERROR_SUCCESS;
    }        

    return ErrorCode;
}

#define MAX_NT_PATH (MAX_PATH + 4)//"\\??\\"
#define UNDO_FILE_NAME  L"UNDO_GUIMODE.TXT"

VOID 
RemoveAllPendingOperationsOnRestartOfGUIMode(
    VOID
    )
{
    WCHAR undoFilePath[MAX_PATH];

    if(!GetWindowsDirectoryW(undoFilePath, ARRAYSIZE(undoFilePath))){
        ASSERT(FALSE);
        return;
    }
    wcscat(undoFilePath, L"\\system32\\");
    wcscat(undoFilePath, UNDO_FILE_NAME);

    SetFileAttributes(undoFilePath, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(undoFilePath);
}

BOOL 
RenameOnRestartOfGUIMode(
    IN PCWSTR pPathName, 
    IN PCWSTR pPathNameNew
    )
{
    DWORD Size;
    BOOL result;
    WCHAR undoFilePath[MAX_PATH];
    WCHAR RenameOperationBuffer[2 * (MAX_NT_PATH + 2/*'\r\n'*/)];
    HANDLE fileUndo;
    BYTE signUnicode[] = {0xff, 0xfe};

    if(!pPathName){
        return FALSE;
    }

    if(!GetWindowsDirectoryW(undoFilePath, ARRAYSIZE(undoFilePath))){
        return FALSE;
    }
    wcscat(undoFilePath, L"\\system32\\" UNDO_FILE_NAME);

    wsprintfW(RenameOperationBuffer, L"\\??\\%s\r\n", pPathName);
    if(pPathNameNew){
        wsprintfW(RenameOperationBuffer + wcslen(RenameOperationBuffer), 
                  L"\\??\\%s", 
                  pPathNameNew);
    }
    wcscat(RenameOperationBuffer, L"\r\n");

    fileUndo = CreateFileW(undoFilePath, 
                           GENERIC_WRITE, 
                           FILE_SHARE_READ, 
                           NULL, 
                           OPEN_ALWAYS, 
                           FILE_ATTRIBUTE_NORMAL, 
                           NULL);
    if(INVALID_HANDLE_VALUE == fileUndo){
        return FALSE;
    }

    if(!SetFilePointer(fileUndo, 0, NULL, FILE_END)){
        result = WriteFile(fileUndo, signUnicode, sizeof(signUnicode), &Size, NULL);
    }
    else {
        result = TRUE;
    }
    
    if(result){
        result = WriteFile(fileUndo, 
                           RenameOperationBuffer, 
                           wcslen(RenameOperationBuffer) * sizeof(WCHAR), 
                           &Size, 
                           NULL);
    }
    
    CloseHandle(fileUndo);
    
    return result;
}

BOOL 
DeleteOnRestartOfGUIMode(
    IN PCWSTR pPathName
    )
{
    return RenameOnRestartOfGUIMode(pPathName, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\inifile.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    inifile.c

Abstract:

    Routines to deal with ini files.

Author:

    Ted Miller (tedm) 5-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// Constants
//
PCWSTR szWININI   = L"win.ini",
       szWINLOGON = L"winlogon",
       szUSERINIT = L"userinit",
       szDESKTOP  = L"desktop";


BOOL
ReplaceIniKeyValue(
    IN PCWSTR IniFile,
    IN PCWSTR Section,
    IN PCWSTR Key,
    IN PCWSTR Value
    )
{
    BOOL b;

    b = WritePrivateProfileString(Section,Key,Value,IniFile);
    if(!b) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INIWRITE_FAIL,
            IniFile,
            Section,
            Key,
            Value,
            GetLastError(),
            NULL,NULL);
    }

    return(b);
}


BOOL
WinIniAlter1(
    VOID
    )
{
    BOOL b;
    WCHAR AdminName[MAX_USERNAME+1];

    LoadString(MyModuleHandle,IDS_ADMINISTRATOR,AdminName,MAX_USERNAME+1);

#ifdef DOLOCALUSER
    b = ReplaceIniKeyValue(
            szWININI,
            szWINLOGON,
            L"DefaultUserName",
            CreateUserAccount ? UserName : AdminName
            );
#else
    b = ReplaceIniKeyValue(szWININI,szWINLOGON,L"DefaultUserName",AdminName);
#endif

    if(!ReplaceIniKeyValue(szWININI,szWINLOGON,L"DebugServerCommand",L"no")) {
        b = FALSE;
    }

    return(b);
}


BOOL
SetDefaultWallpaper(
    VOID
    )
{
    BOOL b;
    PCWSTR p;

    b = FALSE;
    if(p = MyLoadString(IDS_DEFWALLPAPER)) {
        b = ReplaceIniKeyValue(szWININI,szDESKTOP,L"Wallpaper",p);
        MyFree(p);
        b = ReplaceIniKeyValue(szWININI,szDESKTOP,L"TileWallpaper",L"0");
    }
    return(b);
}


BOOL
SetShutdownVariables(
    VOID
    )
{
    BOOL b;

    if( (Upgrade) || (ProductType == PRODUCT_WORKSTATION) ) {
        b = TRUE;
    } else {
        b = ReplaceIniKeyValue(szWININI,szWINLOGON,L"ShutdownWithoutLogon",L"0");
    }

    return(b);
}


BOOL
SetLogonScreensaver(
    VOID
    )
{
    BOOL b;

    b = ReplaceIniKeyValue(szWININI,szDESKTOP,L"ScreenSaveActive",L"1");
    b &= ReplaceIniKeyValue(szWININI,szDESKTOP,L"SCRNSAVE.EXE",L"logon.scr");

    return(b);
}


BOOL
InstallOrUpgradeFonts(
    VOID
    )
{
    BOOL b;

    b = SetupInstallFromInfSection(
            NULL,
            SyssetupInf,
            Upgrade ? L"UpgradeFonts" : L"InstallFonts",
            SPINST_INIFILES,
            NULL,
            NULL,
            0,
            NULL,
            NULL,
            NULL,
            NULL
            );

    if(!b) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FONTINST_FAIL, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"SetupInstallFromInfSection",
            GetLastError(),
            NULL,NULL);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\helpids.h ===
#define IDH_APPWIZ_WINSETUP_LIST    5621   // Components box
#define IDH_SPACE_REQ               5622  // Space Required and Space Available
#define IDH_APPWIZ_DETAILS          5623  // Details button
#define IDH_APPWIZ_HAVEDISK_BUTTON  5624  // Have Disk button

#define IDH_IRQ_ENABLE      401000           // Enable IRQ Routing  
#define IDH_IRQ_MSSPEC      401100           // Use $PIR table
#define IDH_IRQ_REALMODE    401200           // Use table from Real-mode BIOS call
#define IDH_IRQ_SETDEFAULTS 401300           // Set defaults for options
#define IDH_IRQ_RESULTS     401400           // Status information
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\external.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    external.c

Abstract:

    Routines for handling external INFs

Author:

    Andrew Ritz (andrewr) 20-Nov-1998

Revision History:

    stole a bunch of code from optional.c for this

--*/

#include "setupp.h"
#pragma hdrstop
#include <windowsx.h>
#include <shlobj.h>



VOID
ReportError (
    IN  LogSeverity Severity,
    IN  PTSTR       MessageString,
    IN  UINT        MessageId,
    ...
    )

/*++

Routine Description:

    Records an error message in the setup action log if we're in Setup,
    or puts the message in a dialog box if we're in the cpl.

Arguments:

    Severity - the type of message being written

    ... - the message id and its arguments

Return Value:

    nothing.

--*/

{
    va_list arglist;

    va_start (arglist, MessageId);

    SetuplogErrorV(
        Severity,
        MessageString,
        MessageId,
        &arglist);

    va_end (arglist);
}


VOID
DoRunonce (
    )

/*++

Routine Description:

    Invokes runonce.

Arguments:

    none.

Return Value:

    nothing.

--*/

{
#define RUNONCE_TIMEOUT  60*1000*30  //30 minutes
    DWORD reRet = NO_ERROR;

    if((reRet = pSetupInstallStopEx( FALSE, INSTALLSTOP_NO_UI, NULL)) == NO_ERROR) {
        //
        // We successfully setup the registry values - now do runonce
        //
        InvokeExternalApplicationEx(NULL, L"RUNONCE -r", &reRet, RUNONCE_TIMEOUT, FALSE);

    } else {
        //
        // Log/report an error that registry mods failed for optional compononent.
        //
        ReportError(LogSevError,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_INF_REGISTRY_ERROR,
                    TEXT("HKEY_LOCAL_MACHINE\\") REGSTR_PATH_RUNONCE,
                    0,
                    SETUPLOG_USE_MESSAGEID,
                    reRet,
                    0,
                    0
                   );
    }

#ifdef _WIN64
    //
    // on win64, invoke the 32 bit version of runonce as well
    //
    {
        WCHAR Path[MAX_PATH+50];

        ExpandEnvironmentStrings(
                    L"%systemroot%\\SysWOW64\\RUNONCE.EXE -r",
                    Path,
                    sizeof(Path)/sizeof(WCHAR));

        InvokeExternalApplicationEx(NULL, Path , &reRet, RUNONCE_TIMEOUT, FALSE);

    }
#endif
}



BOOL
DoInstallComponentInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage,
    IN HINF     InfHandle,
    IN PCWSTR   InfSection
    )
{
    HINF *hInfs = NULL;
    PCWSTR *Sections = NULL, *InfNames = NULL;
    PCWSTR Inf,Section;
    PVOID p;
    INFCONTEXT Context;
    PVOID QContext = NULL;
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    DWORD ScanQueueResult;
    LONG NumInfs, InfCount, i;
    DWORD LastErrorValue = ERROR_SUCCESS;
    BOOL b = FALSE;
    REGISTRATION_CONTEXT RegistrationContext;

    RtlZeroMemory(&RegistrationContext,sizeof(RegistrationContext));

    //
    // initialize a file queue
    //
    FileQueue = SetupOpenFileQueue();
    if (FileQueue == INVALID_HANDLE_VALUE) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, 0,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, 0,0);
        goto e0;
    }

    //
    // Initialize the default queue callback.
    //
    QContext = InitSysSetupQueueCallbackEx(
                                hwndParent,
                                hProgress,
                                ProgressMessage,
                                0,NULL);
    if (!QContext) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, 0,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, 0,0);
        goto e1;
    }

    //
    // process 'mandatory' component infs.
    //
    NumInfs = SetupGetLineCount(InfHandle, InfSection);
    if (NumInfs <= 0)
    {
        //
        // nothing in section.  return success for doing nothing
        //
        b = TRUE;
        goto e2;
    }

    hInfs = MyMalloc( sizeof(HINF) * NumInfs );
    Sections = MyMalloc( sizeof(PCWSTR) * NumInfs );
    InfNames = MyMalloc( sizeof(PCWSTR) * NumInfs );

    if (!hInfs) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, 0,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, 0,0);
        goto e2;
    }

    if (!Sections) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, 0,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, 0,0);
        goto e3;
    }

    if (!InfNames) {
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, 0,
            SETUPLOG_USE_MESSAGEID,
            ERROR_NOT_ENOUGH_MEMORY, 0,0);
        goto e4;
    }

    RemainingTime = CalcTimeRemaining(Phase_InstallComponentInfs);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Installing component files");
    InfCount = 0;
    if(SetupFindFirstLine(InfHandle,InfSection,NULL,&Context)) {
        do {
            if((Inf = pSetupGetField(&Context,1)) && (Section = pSetupGetField(&Context,2))) {
                MYASSERT(InfCount < NumInfs);

                //
                // save away the section name for later on
                //
                Sections[InfCount] = pSetupDuplicateString(Section);
                if (!Sections[InfCount]) {
                    ReportError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_INF_ALWAYS_ERROR, 0,
                        SETUPLOG_USE_MESSAGEID,
                        ERROR_NOT_ENOUGH_MEMORY, 0,0);
                    goto e6;
                }

                InfNames[InfCount] = pSetupDuplicateString(Inf);
                if (!InfNames[InfCount]) {
                    ReportError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_INF_ALWAYS_ERROR, 0,
                        SETUPLOG_USE_MESSAGEID,
                        ERROR_NOT_ENOUGH_MEMORY, 0,0);
                    goto e6;
                }

                BEGIN_SECTION((PWSTR)Section);
                SetupDebugPrint2( TEXT("Installing Section [%s] from %s\n"), Section, Inf );

                //
                // queue files and save away the inf handle for later on
                //
                hInfs[InfCount] = SetupOpenInfFile(Inf,NULL,INF_STYLE_OLDNT|INF_STYLE_WIN4,NULL);
                if(hInfs[InfCount] && (hInfs[InfCount] != INVALID_HANDLE_VALUE)) {
                    PCWSTR Signature;
                    INFCONTEXT Cntxt;
                    HINF layout = NULL;
                    if (SetupFindFirstLine( hInfs[InfCount], L"Version",L"Signature", &Cntxt)) {
                        Signature = pSetupGetField(&Cntxt,1);
                        MYASSERT(Signature);
                        if (_wcsicmp(Signature,L"$Windows NT$") == 0) {
                            SetupOpenAppendInfFile(NULL,hInfs[InfCount],NULL);
                        } else {
                            layout = InfCacheOpenLayoutInf(hInfs[InfCount]);
                        }
                    }

                    b = SetupInstallFilesFromInfSection(
                                            hInfs[InfCount],
                                            layout,
                                            FileQueue,
                                            Section,
                                            NULL,
                                            SP_COPY_NEWER
                                            );
                    if (!b) {
                        //
                        // report error but continue with the rest of the infs
                        //
                        ReportError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_BAD_SECTION,
                            Section,
                            Inf,
                            NULL,
                            SETUPLOG_USE_MESSAGEID,
                            GetLastError(),
                            0,
                            0
                            );
                        SetupCloseInfFile(hInfs[InfCount]);
                        hInfs[InfCount] = INVALID_HANDLE_VALUE;
                    }
                    
                } else {
                    //
                    // failed to open inf file
                    //
                    ReportError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_CANT_OPEN_INF, Inf,
                            0,0);
                    END_SECTION((PWSTR)Section);
                    goto e5;
                }
            }

            InfCount++;
            END_SECTION((PWSTR)Section);
        } while(SetupFindNextLine(&Context,&Context));
    } else {
        // We should have caught this case when we created the buffers!
        MYASSERT(FALSE);
    }

    //
    // queued all the files.  check if we really have to install any files. if not, we can save
    // the time required to commit the queue to disk
    //

    if(!SetupScanFileQueue(
           FileQueue,
           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
           hwndParent,
           NULL,
           NULL,
           &ScanQueueResult)) {
        //
        // SetupScanFileQueue should really never
        // fail when you don't ask it to call a
        // callback routine, but if it does, just
        // go ahead and commit the queue.
        //
        ScanQueueResult = 0;
    }

    if( ScanQueueResult != 1 ){
        b = SetupCommitFileQueue(
                hwndParent,
                FileQueue,
                SysSetupQueueCallback,
                QContext
                );

    }
    LastErrorValue = b ? NO_ERROR : GetLastError();
    END_SECTION(L"Installing component files");

    TermSysSetupQueueCallback(QContext);
    QContext = NULL;

    //
    // Delete the file queue.
    //
    if(FileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(FileQueue);
        FileQueue = INVALID_HANDLE_VALUE;
    }

    if (!b) {
        //
        // error commiting the queue.  we can't continue at this point since the next operations
        // might require the files that we (didn't) copy
        //
        ReportError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INF_ALWAYS_ERROR, 0,
            SETUPLOG_USE_MESSAGEID,
            LastErrorValue, 0,0);
        goto e6;
    }

    BEGIN_SECTION(L"Installing component reg settings");
    for (i = 0; i< InfCount; i++) {
        INFCONTEXT Cntxt;
        TCHAR ScratchSectionName[100];
        if (hInfs[i] != INVALID_HANDLE_VALUE) {

            //
            // if the section contains an Addservice or DelService directive,
            // we must explicitly install it since SetupInstallFromInfSection
            // does not process services.  Note that we create the service
            // BEFORE we do the other stuff in the section, in case that
            // "other stuff" wants to use the service.
            //
            lstrcpy( ScratchSectionName, Sections[i]);
            lstrcat( ScratchSectionName, TEXT(".Services"));
            if (SetupFindFirstLine(
                        hInfs[i],
                        ScratchSectionName,
                        L"AddService",
                        &Cntxt) ||
                SetupFindFirstLine(
                        hInfs[i],
                        Sections[i],
                        ScratchSectionName,
                        &Cntxt)) {

                b = SetupInstallServicesFromInfSectionEx(
                                                    hInfs[i],
                                                    ScratchSectionName,
                                                    0,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    NULL);
                if (!b) {
                    //
                    // log an error and continue
                    //
                    ReportError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_BAD_SECTION,
                        Sections[i],InfNames[i], 0,
                        SETUPLOG_USE_MESSAGEID,
                        GetLastError(), 0,0);
                }
            }


            b = SetupInstallFromInfSection(
                                hwndParent,
                                hInfs[i],
                                Sections[i],
                                (SPINST_ALL & ~SPINST_FILES) | SPINST_REGISTERCALLBACKAWARE,
                                NULL,
                                NULL,
                                0,
                                RegistrationQueueCallback,
                                (PVOID)&RegistrationContext,
                                NULL,
                                NULL
                                );
            if (!b) {
                //
                // log an error and continue
                //
                ReportError(
                    LogSevError,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_BAD_SECTION,
                    Sections[i],InfNames[i], 0,
                    SETUPLOG_USE_MESSAGEID,
                    GetLastError(), 0,0);
            }

        }
    }
    END_SECTION(L"Installing component reg settings");

    b = TRUE;

e6:
    for (i = 0; i < InfCount; i++) {

        MYASSERT(Sections != NULL);
        MYASSERT(InfNames != NULL);
        MYASSERT(hInfs != INVALID_HANDLE_VALUE);

        if (Sections[i]) {
            MyFree(Sections[i]);
        }

        if (InfNames[i]) {
            MyFree(InfNames[i]);
        }

        if (hInfs[i] != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile(hInfs[i]);
        }

    }

e5:
    if (InfNames) {
        MyFree(InfNames);
    }
e4:
    if (Sections) {
        MyFree(Sections);
    }
e3:
    if (hInfs) {
        MyFree(hInfs);
    }
e2:
    if (QContext) {
        TermSysSetupQueueCallback(QContext);
    }
e1:
    if (FileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(FileQueue);
    }
e0:
    return(b);

}


BOOL
SetupCreateOptionalComponentsPage(
    IN LPFNADDPROPSHEETPAGE AddPageCallback,
    IN LPARAM               Context
    )
{

    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );

    return( FALSE );

}

BOOL
ProcessCompatibilityInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage
    )
{
    WCHAR UnattendFile[MAX_PATH];
    PCWSTR SectionName = pwCompatibility;
    HINF UnattendInf;


    GetSystemDirectory(UnattendFile,MAX_PATH);
    pSetupConcatenatePaths(UnattendFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    UnattendInf = SetupOpenInfFile(UnattendFile,NULL,INF_STYLE_OLDNT,NULL);
    if(UnattendInf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    DoInstallComponentInfs(hwndParent,
                           hProgress,
                           ProgressMessage,
                           UnattendInf,
                           SectionName );

    SetupCloseInfFile( UnattendInf );

    return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\extprog.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    extprog.c

Abstract:

    Routines for invoking external applications.
    Entry points in this module:

        InvokeExternalApplication
        InvokeControlPanelApplet

Author:

    Ted Miller (tedm) 5-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

PCWSTR szWaitOnApp = L"WaitOnApp";


DWORD
WaitOnApp(
    IN  HANDLE Process,
    OUT PDWORD ExitCode,
    IN  DWORD  Timeout
    )
{
    DWORD dw;
    BOOL Done;

    MYASSERT( ExitCode != NULL );

    //
    // Process any messages that may already be in the queue.
    //
    PumpMessageQueue();

    //
    // Wait for process to terminate or more messages in the queue.
    //
    Done = FALSE;
    do {
        switch(MsgWaitForMultipleObjects(1,&Process,FALSE,Timeout,QS_ALLINPUT)) {

        case WAIT_OBJECT_0:
            //
            // Process has terminated.
            //
            dw = GetExitCodeProcess(Process,ExitCode) ? NO_ERROR : GetLastError();
            Done = TRUE;
            break;

        case WAIT_OBJECT_0+1:
            //
            // Messages in the queue.
            //
            PumpMessageQueue();
            break;

        case WAIT_TIMEOUT:
            dw = WAIT_TIMEOUT;
            *ExitCode = WAIT_TIMEOUT;
            Done = TRUE;
            break;

        default:
            //
            // Error.
            //
            dw = GetLastError();
            Done = TRUE;
            break;
        }
    } while(!Done);

    return(dw);
}


BOOL
InvokeExternalApplication(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode          OPTIONAL
    )

/*++

Routine Description:

    See InvokeExternalApplicationEx

--*/

{
    //
    // infinite timeout
    //
    return(InvokeExternalApplicationEx(
                            ApplicationName,
                            CommandLine,
                            ExitCode,
                            INFINITE,
                            FALSE));

}

BOOL
InvokeExternalApplicationEx(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode,         OPTIONAL
    IN     DWORD  Timeout,
    IN     BOOL   Hidden
    )

/*++

Routine Description:

    Invokes an external program, which is optionally detached.

Arguments:

    ApplicationName - supplies app name. May be a partial or full path,
        or just a filename, in which case the standard win32 path search
        is performed. If not specified then the first element in
        CommandLine must specify the binary to execute.

    CommandLine - supplies the command line to be passed to the
        application.

    ExitCode - If specified, the execution is synchronous and this value
        receives the exit code of the application. If not specified,
        the execution is asynchronous.

    Timeout - specifies how long to wait for the app to complete.

    Hidden - if TRUE, indicates that the application should be invoked with
             the SW_HIDE attribute set.

Return Value:

    Boolean value indicating whether the process was started successfully.

--*/

{
    PWSTR FullCommandLine;
    BOOL b;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO StartupInfo;
    DWORD d;

    b = FALSE;
    //
    // Form the command line to be passed to CreateProcess.
    //
    if(ApplicationName) {
        FullCommandLine = MyMalloc((lstrlen(ApplicationName)+lstrlen(CommandLine)+2)*sizeof(WCHAR));
        if(!FullCommandLine) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_INVOKEAPP_FAIL,
                ApplicationName,NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OUTOFMEMORY,
                NULL,NULL);
            goto err0;
        }

        lstrcpy(FullCommandLine,ApplicationName);
        lstrcat(FullCommandLine,L" ");
        lstrcat(FullCommandLine,CommandLine);
    } else {
        FullCommandLine = pSetupDuplicateString(CommandLine);
        if(!FullCommandLine) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_INVOKEAPP_FAIL,
                CommandLine, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OUTOFMEMORY,
                NULL,NULL);
            goto err0;
        }
    }

    //
    // Initialize startup info.
    //
    ZeroMemory(&StartupInfo,sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);
    if (Hidden) {
        //
        // no UI
        //
        GetStartupInfo(&StartupInfo);
        StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = SW_HIDE;
    }

    //
    // Create the process.
    //
    b = CreateProcess(
            NULL,
            FullCommandLine,
            NULL,
            NULL,
            FALSE,
            ExitCode ? 0 : DETACHED_PROCESS,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInfo
            );

    if(!b) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPP_FAIL,
            FullCommandLine, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szCreateProcess,
            GetLastError(),
            NULL,NULL);
        goto err1;
    }

    //
    // If execution is asynchronus, we're done.
    //
    if(!ExitCode) {
        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPP_SUCCEED,
            FullCommandLine,
            NULL,NULL);
        goto err2;
    }

    //
    // Need to wait for the app to finish.
    // If the wait failed don't return an error but log a warning.
    //
    d = WaitOnApp(ProcessInfo.hProcess,ExitCode,Timeout);
    if(d != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPP_FAIL,
            FullCommandLine, 0,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szWaitOnApp,
            d,
            NULL,NULL);
    } else {
        SetuplogError(
            LogSevInformation | SETUPLOG_SINGLE_MESSAGE,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPP_SUCCEED_STATUS,
            FullCommandLine,
            *ExitCode,
            NULL,
            NULL);
    }

    //
    // Put setup back in the foreground.
    //
    SetForegroundWindow(MainWindowHandle);

err2:
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);
err1:
    MyFree(FullCommandLine);
err0:
    return(b);
}


BOOL
InvokeControlPanelApplet(
    IN PCWSTR CplSpec,
    IN PCWSTR AppletName,           OPTIONAL
    IN UINT   AppletNameStringId,
    IN PCWSTR CommandLine
    )
{
    PWSTR FullCommandLine;
    BOOL b;
    BOOL LoadedAppletName;
    DWORD ExitCode;

    b = FALSE;

    LoadedAppletName = FALSE;
    if(!AppletName) {
        if(AppletName = MyLoadString(AppletNameStringId)) {
            LoadedAppletName = TRUE;
        }
    }

    if(AppletName) {

        FullCommandLine = MyMalloc((lstrlen(CplSpec)+lstrlen(AppletName)+lstrlen(CommandLine)+3) * sizeof(WCHAR));
        if(FullCommandLine) {
            lstrcpy(FullCommandLine,CplSpec);
            lstrcat(FullCommandLine,L",");
            lstrcat(FullCommandLine,AppletName);
            lstrcat(FullCommandLine,L",");
            lstrcat(FullCommandLine,CommandLine);
            b = InvokeExternalApplication(L"RUNDLL32 shell32,Control_RunDLL",FullCommandLine,&ExitCode);
            MyFree(FullCommandLine);
        } else {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_INVOKEAPPLET_FAIL,
                AppletName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OUTOFMEMORY,
                NULL,NULL);
        }
    } else {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_INVOKEAPPLET_FAIL,
            L"", NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
    }

    if(LoadedAppletName) {
        MyFree(AppletName);
    }
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\infcache.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    infcache.c

Abstract:

    This module implements a simple inf caching mechanism.

    WARNING: THE CODE IN THIS MODULE IS NOT MULTI-THREAD SAFE.
    EXERCISE EXTREME CAUTION WHEN MAKING USE OF THESE ROUTINES.

Author:

    Ted Miller (tedm) 28-Aug-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Structure for cached inf. We assume that there won't be
// too many of these open at the same time so we just keep
// a linear list.
//
typedef struct _INFC {

    struct _INFC *Next;

    //
    // Name of INF
    //
    PCWSTR Filename;

    //
    // Handle to inf.
    //
    HINF InfHandle;

} INFC, *PINFC;

PINFC OpenInfList;


HINF
InfCacheOpenInf(
    IN PCWSTR FileName,
    IN PCWSTR InfType       OPTIONAL
    )

/*++

Routine Description:

    Open a (win95-style) inf file if it has not already been opened
    via the cached inf mechanism.

Arguments:

    FileName - supplies name of inf file to be opened. Matching is
        based solely on this string as given here; no processing on it
        is performed and no attempt is made to determine where the inf
        file is actually located.

    InfType - if specified supplies an argument to be passed to
        SetupOpenInfFile() as the InfType parameter.

Return Value:

    Handle of inf file if successful; NULL if not.

--*/

{
    PINFC p;
    HINF h;

    //
    // Look for inf to see if it's already open.
    //
    for(p=OpenInfList; p; p=p->Next) {
        if(!lstrcmpi(p->Filename,FileName)) {
            return(p->InfHandle);
        }
    }

    h = SetupOpenInfFile(FileName,InfType,INF_STYLE_WIN4,NULL);
    if(h == INVALID_HANDLE_VALUE) {
        return(NULL);
    }

    p = MyMalloc(sizeof(INFC));
    if(!p) {
        SetupCloseInfFile(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    p->Filename = pSetupDuplicateString(FileName);
    if(!p->Filename) {
        MyFree(p);
        SetupCloseInfFile(h);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    p->InfHandle = h;
    p->Next = OpenInfList;
    OpenInfList = p;

    return(h);
}


HINF
InfCacheOpenLayoutInf(
    IN HINF InfHandle
    )
{
    INFCONTEXT InfContext;
    BOOL b;
    DWORD DontCare;
    HINF h;
    WCHAR FileName[MAX_PATH],TempName[MAX_PATH];
    PINFC p;

    //
    // Fetch the name of the layout inf.
    // Note that an INF is perfectly capable of acting as its own layout inf.
    //
    if(SetupFindFirstLine(InfHandle,L"Version",L"LayoutFile",&InfContext)) {

        if(SetupGetStringField(&InfContext,1,FileName,MAX_PATH,&DontCare)) {
            //
            // Open the layout inf. If first attempt fails,
            // try opening it in the current directory (unqualified inf names
            // will be looked for in %sysroot%\inf, which might not be what
            // we want).
            //
            h = InfCacheOpenInf(FileName,NULL);
            if(!h) {
                TempName[0] = L'.';
                TempName[1] = 0;
                pSetupConcatenatePaths(TempName,FileName,MAX_PATH,NULL);
                h = InfCacheOpenInf(TempName,NULL);
            }
        } else {
            //
            // INF is corrupt
            //
            h = NULL;
        }
    } else {
        //
        // No layout inf: inf is its own layout inf
        //
        h = InfHandle;
    }

    return(h);
}


VOID
InfCacheEmpty(
    IN BOOL CloseInfs
    )
{
    PINFC p,q;
    HINF h;

    for(p=OpenInfList; p; ) {

        q = p->Next;

        if(CloseInfs) {
            SetupCloseInfFile(p->InfHandle);
        }

        MyFree(p->Filename);
        MyFree(p);

        p = q;
    }
}

BOOL
InfCacheRefresh(
    VOID
    )
/*++

Routine Description:

    Refresh all of the open cached inf files.

Arguments:

    None.

Return Value:

    TRUE on success.

    Note: This routine can be used to reopen all cached infs in the current
          context.  This could be necessary if the locale changes, for instance.


--*/

{
    PINFC p,q;
    HINF h;
    BOOL bRet = TRUE;

    for(p=OpenInfList; p; ) {

        q = p->Next;

        SetupCloseInfFile(p->InfHandle);
        p->InfHandle = SetupOpenInfFile(p->Filename,NULL,INF_STYLE_WIN4,NULL);
        bRet = (p->InfHandle == INVALID_HANDLE_VALUE) ? FALSE : bRet;
        p = q;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\makefile.inc ===
$(O)\setupsys.res: setupsys.rc msg.mc dialogs.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\netdde.c ===
#include "setupp.h"
#pragma hdrstop
#ifndef _WIN64

#include <setup_netdde.c>
/************************************************************************
* Copyright (c) Wonderware Software Development Corp. 1991-1992.        *
*               All Rights Reserved.                                    *
*************************************************************************/
// Modified 4/4/95 tedm

BOOL
InstallNetDDE(
    VOID
    )
{
    HKEY hKey;
    BOOL b;
    LONG rc;

    rc = RegOpenKeyEx(
            HKEY_USERS,
            L".DEFAULT",
            0,
            KEY_SET_VALUE | KEY_QUERY_VALUE,
            &hKey
            );

    if(rc == NO_ERROR) {
        if(b = CreateShareDBInstance()) {
            b = CreateDefaultTrust(hKey);
        }
        RegCloseKey(hKey);
        if(!b) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CANT_INIT_NETDDE, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NETDDELIB_FAILED,
                NULL,NULL);
        }
    } else {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CANT_INIT_NETDDE, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegOpenKeyEx,
            rc,
            L"HKEY_USERS\\.DEFAULT",
            NULL,NULL);
    }

    return(b);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\log.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Routines for logging actions performed during setup.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#include <wtypes.h>     // to define HRESULT for richedit.h
#include <richedit.h>
#include "setuplog.h"

//
// Severity descriptions. Initialized in InitializeSetupActionLog.
//
PCSTR SeverityDescriptions[LogSevMaximum];

//
// Constant strings used for logging in various places.
//
PCWSTR szWaitForSingleObject        = L"WaitForSingleObject";
PCWSTR szFALSE                      = L"FALSE";
PCWSTR szSetGroupOfValues           = L"SetGroupOfValues";
PCWSTR szSetArrayToMultiSzValue     = L"pSetupSetArrayToMultiSzValue";
PCWSTR szCreateProcess              = L"CreateProcess";
PCWSTR szRegOpenKeyEx               = L"RegOpenKeyEx";
PCWSTR szRegQueryValueEx            = L"RegQueryValueEx";
PCWSTR szRegSetValueEx              = L"RegSetValueEx";
PCWSTR szDeleteFile                 = L"DeleteFile";
PCWSTR szRemoveDirectory            = L"RemoveDirectory";
PCWSTR szSetupInstallFromInfSection = L"SetupInstallFromInfSection";

//
// This structure is passed as the parameter to DialogBoxParam to provide
// initialization data.
//

typedef struct _LOGVIEW_DIALOG_DATA {
    PCWSTR  LogFileName;                        // actual file used
    PCWSTR  WindowHeading;                      // actual title of main window
} LOGVIEW_DIALOG_DATA, *PLOGVIEW_DIALOG_DATA;


PVOID
pOpenFileCallback(
    IN  PCTSTR  Filename,
    IN  BOOL    WipeLogFile
    )
{
    WCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;
    DWORD   Result;

    //
    // Form the pathname of the logfile.
    //
    Result = GetWindowsDirectory(CompleteFilename,MAX_PATH);
    if( Result == 0) {
        MYASSERT(FALSE);
        return NULL;
    }
    pSetupConcatenatePaths(CompleteFilename,Filename,MAX_PATH,NULL);

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes(CompleteFilename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile(
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    return (PVOID)hFile;
}

BOOL
pWriteFile (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    )
{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   BytesWritten;

    // Write message to log file
    //
    if(AnsiBuffer = pSetupUnicodeToAnsi (Buffer)) {
        SetFilePointer (LogFile, 0, NULL, FILE_END);

        Status = WriteFile (
            LogFile,
            AnsiBuffer,
            lstrlenA(AnsiBuffer),
            &BytesWritten,
            NULL
            );
        MyFree (AnsiBuffer);
    } else {
        Status = FALSE;
    }

    // Write log message to debugging log
    //
    SetupDebugPrint((LPWSTR)Buffer);

    return Status;

}

BOOL
pAcquireMutex (
    IN  PVOID   Mutex
    )

/*++

Routine Description:

    Waits on the log mutex for a max of 1 second, and returns TRUE if the mutex
    was claimed, or FALSE if the claim timed out.

Arguments:

    Mutex - specifies which mutex to acquire.

Return Value:

    TRUE if the mutex was claimed, or FALSE if the claim timed out.

--*/


{
    DWORD rc;

    if (!Mutex) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Wait a max of 1 second for the mutex
    rc = WaitForSingleObject (Mutex, 1000);
    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_EXCL_SEM_ALREADY_OWNED);
        return FALSE;
    }

    return TRUE;
}

VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

     Initialize the setup action log. This file is a textual description
     of actions performed during setup.

     The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    Boolean value indicating whether initialization was sucessful.

--*/

{
    UINT    i;
    PWSTR   p;

    Context->OpenFile = pOpenFileCallback;
    Context->CloseFile = CloseHandle;
    Context->AllocMem = MyMalloc;
    Context->FreeMem = MyFree;
    Context->Format = RetrieveAndFormatMessageV;
    Context->Write = pWriteFile;
    Context->Lock = pAcquireMutex;
    Context->Unlock = ReleaseMutex;

    Context->Mutex = CreateMutex(NULL,FALSE,L"SetuplogMutex");

    //
    // Initialize the log severity descriptions.
    //
    for(i=0; i<LogSevMaximum; i++) {
        Context->SeverityDescriptions[i] = MyLoadString(IDS_LOGSEVINFO+i);
    }

    SetuplogInitialize (Context, FALSE);

    SetuplogError(
        LogSevInformation,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_GUI_START,
        NULL,NULL);

}

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

    Close the Setup log and free resources.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    None.

--*/

{
    UINT    i;

    if(Context->Mutex) {
        CloseHandle(Context->Mutex);
        Context->Mutex = NULL;
    }

    for (i=0; i<LogSevMaximum; i++) {
        if (Context->SeverityDescriptions[i]) {
            MyFree (Context->SeverityDescriptions[i]);
        }
    }

    SetuplogTerminate();
}

DWORD CALLBACK
EditStreamCallback (
    IN HANDLE   hLogFile,
    IN LPBYTE   Buffer,
    IN LONG     cb,
    IN PLONG    pcb
    )

/*++

Routine Description:

    Callback routine used by the rich edit control to read in the log file.

Arguments:

    hLogFile - handle of file to read.  This module provides the value through
        the EDITSTREAM structure.

    Buffer - address of buffer that receives the data

    cb - number of bytes to read

    pcb - address of number of bytes actually read

Return Value:

    0 to continue the stream operation, or nonzero to abort it.

--*/

{
    DWORD error;

    if (!ReadFile (hLogFile, Buffer, cb, pcb, NULL)) {
        error = GetLastError();
        return error;
    }

    return 0;
}

BOOL
FormatText (
    IN HWND hWndRichEdit
    )

/*++

Routine Description:

    Modify the contents of the rich edit control to make the log file look
    prettier.  The modifications are driven by the array FormatStrings.  It
    contains a list of strings to search for, and modifications to make when
    a target string is found.

Arguments:

    hWndRichEdit - handle to the Rich Edit control.

Return Value:

    Boolean indicating whether routine was successful.

--*/

{

    //
    // separate items in the log with a horizontal line
    //

    PCWSTR      NewTerm = L"----------------------------------------"
        L"----------------------------------------\r\n\r\n";

    FINDTEXT    FindText;       // target text to change
    INT         Position;       // start of where target was found
    INT         LineIndex;      // index of line containing target
    CHARRANGE   SelectRange;    // range where target was found
    CHARFORMAT  NewFormat;      // structure to hold our format changes
    INT         i;              // loop counter
    PWSTR       pw;             // temporary pointer
    BOOL        Status;         // return status

    //
    // An array of changes we're going to make
    //

    struct tagFormatStrings {
        PCWSTR      Find;       // target string
        PCWSTR      Replace;    // change the target to this
        COLORREF    Color;      // make target text this color
        DWORD       Effects;    // modifications to target's font
    }
    FormatStrings[] = {
        {NULL,  NULL,   RGB(0,150,0),   CFE_UNDERLINE},
        {NULL,  NULL,   RGB(150,150,0), CFE_UNDERLINE},
        {NULL,  NULL,   RGB(255,0,0),   CFE_UNDERLINE},
        {NULL,  NULL,   RGB(255,0,0),   CFE_UNDERLINE|CFE_ITALIC},
        {NULL,  NULL,   RGB(0,0,255),   0}
    };

    //
    // Number of elements in FormatStrings array
    //

    #define FORMATSTRINGSCOUNT  \
        (sizeof(FormatStrings) / sizeof(struct tagFormatStrings))
    MYASSERT(FORMATSTRINGSCOUNT == LogSevMaximum + 1);


    //
    // Initialize those parts of our data structures that won't change
    //

    Status = TRUE;

    NewFormat.cbSize = sizeof(NewFormat);
    FindText.chrg.cpMax = -1;   // search to the end
    for (i=0; i<LogSevMaximum; i++) {   // load severity strings
        if (!(pw = MyLoadString (IDS_LOGSEVINFO+i))) {
            Status = FALSE;
            goto cleanup;
        }
        FormatStrings[i].Find = MyMalloc((lstrlen(pw)+4)*sizeof(WCHAR));
        if(!FormatStrings[i].Find) {
            MyFree(pw);
            Status = FALSE;
            goto cleanup;
        }
        lstrcpy ((PWSTR)FormatStrings[i].Find, pw);
        lstrcat ((PWSTR)FormatStrings[i].Find, L":\r\n");
        MyFree(pw);

        if(pw = MyMalloc((lstrlen(FormatStrings[i].Find)+3)*sizeof(WCHAR))) {
            lstrcpy(pw,FormatStrings[i].Find);
            lstrcat(pw,L"\r\n");
            FormatStrings[i].Replace = pw;
        } else {
            Status = FALSE;
            goto cleanup;
        }
    }

    FormatStrings[LogSevMaximum].Find =
        pSetupDuplicateString(SETUPLOG_ITEM_TERMINATOR);
    if (!FormatStrings[LogSevMaximum].Find) {
        Status = FALSE;
        goto cleanup;
    }
    FormatStrings[LogSevMaximum].Replace = pSetupDuplicateString (NewTerm);
    if (!FormatStrings[LogSevMaximum].Replace) {
        Status = FALSE;
        goto cleanup;
    }

    //
    // Change 1 string at a time in the rich edit control
    //

    for (i=0; i<FORMATSTRINGSCOUNT; i++) {
        FindText.chrg.cpMin = 0;    // start search at beginning
        FindText.lpstrText = (PWSTR) FormatStrings[i].Find;

         //
        // Search for current target until we've found each instance
        //

        while ((Position = (INT)SendMessage
            (hWndRichEdit, EM_FINDTEXT, FR_MATCHCASE, (LPARAM) &FindText))
            != -1) {

            //
            // Verify that the target is at the beginning of the line
            //

            LineIndex = (INT)SendMessage (hWndRichEdit, EM_LINEFROMCHAR,
                Position, 0);

            if (SendMessage (hWndRichEdit, EM_LINEINDEX, LineIndex, 0) !=
                Position) {
                FindText.chrg.cpMin = Position + lstrlen (FindText.lpstrText);
                continue;
            }

            //
            // Select the target text and get its format
            //

            SelectRange.cpMin = Position;
            SelectRange.cpMax = Position + lstrlen (FindText.lpstrText);
            SendMessage (hWndRichEdit, EM_EXSETSEL, 0, (LPARAM) &SelectRange);
            SendMessage (hWndRichEdit, EM_GETCHARFORMAT, TRUE,
                (LPARAM) &NewFormat);

            //
            // Modify the target's format
            //

            NewFormat.dwMask = CFM_COLOR | CFM_UNDERLINE | CFM_ITALIC;
            NewFormat.dwEffects &= ~CFE_AUTOCOLOR;
            NewFormat.crTextColor = FormatStrings[i].Color;
            NewFormat.dwEffects |= FormatStrings[i].Effects;
            SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION,
                (LPARAM) &NewFormat);

            //
            // Replace the target with new text.  Set the starting point for
            // the next search at the end of the current string
            //

            if (FormatStrings[i].Replace != NULL) {
                SendMessage (hWndRichEdit, EM_REPLACESEL, FALSE,
                    (LPARAM) FormatStrings[i].Replace);
                FindText.chrg.cpMin = Position +
                    lstrlen (FormatStrings[i].Replace);
            } else {
                FindText.chrg.cpMin = Position + lstrlen (FindText.lpstrText);
            }
        }
    }

cleanup:

    for (i=0; i<=LogSevMaximum; i++) {
        if (FormatStrings[i].Find) {
            MyFree (FormatStrings[i].Find);
        }
        if (FormatStrings[i].Replace) {
            MyFree (FormatStrings[i].Replace);
        }
    }
    return Status;
}

BOOL
ReadLogFile (
    PCWSTR  LogFileName,
    HWND    hWndRichEdit
    )

/*++

Routine Description:

    This routine reads the log file and initializes the contents of the Rich
    Edit control.

Arguments:

    LogFileName - path to the file we're going to read.

    hWndRichEdit - handle to the Rich Edit control.

Return Value:

    Boolean indicating whether routine was successful.

--*/

{
    HANDLE      hLogFile;       // handle to log file
    EDITSTREAM  eStream;        // structure used by EM_STREAMIN message

    hLogFile = CreateFile(
        LogFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (hLogFile == INVALID_HANDLE_VALUE) {
        hLogFile = NULL;
        return FALSE;
    }

    //
    // Read the file into the Rich Edit control.
    //

    eStream.dwCookie = (DWORD_PTR) hLogFile;
    eStream.pfnCallback = (EDITSTREAMCALLBACK) EditStreamCallback;
    eStream.dwError = 0;
    SendMessage (hWndRichEdit, EM_STREAMIN, SF_TEXT, (LPARAM) &eStream);
    CloseHandle (hLogFile);

    if (!FormatText (hWndRichEdit)) {
        return FALSE;
    }
    SendMessage (hWndRichEdit, EM_SETMODIFY, TRUE, 0);
    return TRUE;
}

INT_PTR
DialogProc (
    IN HWND     hDialog,
    IN UINT     message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    This is the window proc for the dialog box.

Arguments:

    Standard window proc arguments.

Return Value:

    Bool that indicates whether we handled the message.

--*/

{
    HWND    hWndRichEdit;       // handle to rich edit window

    switch (message) {

    case WM_INITDIALOG:
        SetWindowText (hDialog,
            ((LOGVIEW_DIALOG_DATA *)lParam)->WindowHeading);
        hWndRichEdit = GetDlgItem (hDialog, IDT_RICHEDIT1);
        if (!ReadLogFile (((LOGVIEW_DIALOG_DATA *)lParam)->LogFileName,
            hWndRichEdit)) {
            MessageBoxFromMessage (hDialog, MSG_UNABLE_TO_SHOW_LOG, NULL,
                IDS_ERROR, MB_OK|MB_ICONSTOP);
            EndDialog (hDialog, FALSE);
        }
        // if we have the BB window, do the positioning on that. MainWindowHandle point to that window
        if (GetBBhwnd())
            CenterWindowRelativeToWindow(hDialog, MainWindowHandle, FALSE);
        else
            pSetupCenterWindowRelativeToParent(hDialog);
        PostMessage(hDialog,WM_APP,0,0);
        break;

    case WM_APP:

        hWndRichEdit = GetDlgItem (hDialog, IDT_RICHEDIT1);
        SendMessage(hWndRichEdit,EM_SETSEL,0,0);
        SendMessage(hWndRichEdit,EM_SCROLLCARET,0,0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog (hDialog, TRUE);
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
ViewSetupActionLog (
    IN HWND     hOwnerWindow,
    IN PCWSTR   OptionalFileName    OPTIONAL,
    IN PCWSTR   OptionalHeading     OPTIONAL
    )

/*++

Routine Description:

    Formats the setup action log and displays it in a window.
    The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    hOwnerWindow - handle to window that owns the dialog box

    OptionalFileName - full path of the file to be displayed.

    OptionalHeading - text to be shown at the top of the window.

Return Value:

    Boolean value indicating whether the routine was sucessful.

--*/

{
    LOGVIEW_DIALOG_DATA  Global;        // initialization data for dialog box
    WCHAR       TmpFileName[MAX_PATH];  // used to create the log file name
    PCWSTR      TmpHeading;             // used to create the heading
    HANDLE      hRichedDLL;             // DLL used for rich edit
    INT         Status;                 // what we're going to return
    DWORD       Result;

    //
    // Form the pathname of the logfile.
    //

    if (!ARGUMENT_PRESENT(OptionalFileName)) {
        Result = GetWindowsDirectory (TmpFileName,MAX_PATH);
        if( Result == 0) {
            MYASSERT(FALSE);
            return FALSE;
        }
        pSetupConcatenatePaths (TmpFileName,SETUPLOG_ERROR_FILENAME,MAX_PATH,NULL);
        Global.LogFileName = pSetupDuplicateString (TmpFileName);
    } else {
        if (wcslen(OptionalFileName) > MAX_PATH) {
            Status = 0;
            goto err0;
        }
        Global.LogFileName = pSetupDuplicateString (OptionalFileName);
    }

    if (!Global.LogFileName) {
        Status = FALSE;
        goto err0;
    }

    //
    // Form the heading for the dialog box.
    //

    if (!ARGUMENT_PRESENT(OptionalHeading)) {
        TmpHeading = MyLoadString (IDS_LOG_DEFAULT_HEADING);
    } else {
        TmpHeading = pSetupDuplicateString (OptionalHeading);
    }
    if (!TmpHeading) {
        Status = FALSE;
        goto err1;
    }

    Global.WindowHeading = FormatStringMessage (IDS_LOG_WINDOW_HEADING,
        TmpHeading, Global.LogFileName);
    if (!Global.WindowHeading) {
        Status = FALSE;
        goto err2;
    }

    //
    // Create the dialog box.
    //

    if (!(hRichedDLL = LoadLibrary (L"RICHED20.DLL"))) {
        Status = FALSE;
        goto err3;
    }
    Status = (BOOL)DialogBoxParam (MyModuleHandle, MAKEINTRESOURCE(IDD_VIEWLOG),
        hOwnerWindow, DialogProc, (LPARAM) &Global);

    //
    // Clean up and return.
    //

    FreeLibrary (hRichedDLL);
err3:
    MyFree (Global.WindowHeading);
err2:
    MyFree (TmpHeading);
err1:
    MyFree (Global.LogFileName);
err0:
    return Status;
}

VOID
LogRepairInfo(
    IN  PCWSTR  Source,
    IN  PCWSTR  Target
    )
{
    static WCHAR    RepairLog[MAX_PATH];
    static DWORD    WinDirLength;
    static DWORD    SourcePathLength;
    PWSTR           SourceName;
    DWORD           LastSourceChar, LastTargetChar;
    DWORD           LastSourcePeriod, LastTargetPeriod;
    WCHAR           Filename[MAX_PATH];
    WCHAR           Line[MAX_PATH];
    WCHAR           tmp[MAX_PATH];
    BOOLEAN         IsNtImage;
    ULONG           Checksum;
    BOOLEAN         Valid;
    DWORD           Result;


    if(!RepairLog[0]) {
        //
        // We haven't calculated the path to setup.log yet
        //
        Result = GetWindowsDirectory( RepairLog, MAX_PATH );
        if( Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        WinDirLength = lstrlen( RepairLog );
        pSetupConcatenatePaths( RepairLog, L"repair\\setup.log", MAX_PATH, NULL );
        SourcePathLength = lstrlen( SourcePath );
    }

    //
    // Only log the file if it's inside the Windows directory.
    //
    if( !wcsncmp( Target, RepairLog, WinDirLength )) {

        //
        // If we're installing an OEM driver, we shouldn't log it because we can't
        // repair it.  Make sure the file comes from either the local source or
        // the windows directory (for files from driver.cab).
        //
        if (wcsncmp( Source, SourcePath, SourcePathLength ) &&
            wcsncmp( Source, RepairLog, WinDirLength )
            ) {

            SetupDebugPrint2(L"SETUP: oem driver not logged: %ws -> %ws.",
                Source, Target);
            return;
        }

        if( ValidateAndChecksumFile( Target, &IsNtImage, &Checksum, &Valid )) {

            //
            // Strip off drive letter.
            //
            swprintf(
                Filename,
                L"\"%s\"",
                Target+2
                );

            //
            // Convert source name to uncompressed form.
            //
            SourceName = pSetupDuplicateString( wcsrchr( Source, (WCHAR)'\\' ) + 1 );
            if(!SourceName) {
                SetupDebugPrint( L"SETUP: pSetupDuplicateString failed in LogRepairInfo." );
                return;
            }
            LastSourceChar = wcslen (SourceName) - 1;

            if(SourceName[LastSourceChar] == L'_') {
                LastSourcePeriod = (DWORD)(wcsrchr( SourceName, (WCHAR)'.' ) - SourceName);
                MYASSERT(LastSourceChar - LastSourcePeriod < 4);

                if(LastSourceChar - LastSourcePeriod == 1) {
                    //
                    // No extension - just truncate the "._"
                    //
                    SourceName[LastSourceChar-1] = L'\0';
                } else {
                    //
                    // Make sure the extensions on source and target match.
                    // If this fails, we can't log the file copy
                    //
                    LastTargetChar = wcslen (Target) - 1;
                    LastTargetPeriod = (ULONG)(wcsrchr( Target, (WCHAR)'.' ) - Target);

                    if( _wcsnicmp(
                        SourceName + LastSourcePeriod,
                        Target + LastTargetPeriod,
                        LastSourceChar - LastSourcePeriod - 1 )) {

                        SetupDebugPrint2(L"SETUP: unable to log the following file copy: %ws -> %ws.",
                            Source, Target);
                        MyFree (SourceName);
                        return;
                    }

                    if(LastTargetChar - LastTargetPeriod < 3) {
                        //
                        // Short extension - just truncate the "_"
                        //
                        SourceName[LastSourceChar] = L'\0';
                    } else {
                        //
                        // Need to replace "_" with last character from target
                        //
                        MYASSERT(LastTargetChar - LastTargetPeriod == 3);
                        SourceName[LastSourceChar] = Target[LastTargetChar];
                    }
                }
            }

            swprintf(
                Line,
                L"\"%s\",\"%x\"",
                SourceName,
                Checksum);


            if (GetPrivateProfileString(L"Files.WinNt",Filename,L"",tmp,sizeof(tmp)/sizeof(tmp[0]),RepairLog)) {
                //
                // there is already an entry for this file present (presumably
                // from textmode phase of setup.) Favor this entry over what we
                // are about to add
                //
                SetupDebugPrint1(L"SETUP: skipping log of %ws since it's already present in setup.log.", Target);
            } else {
                WritePrivateProfileString(
                    L"Files.WinNt",
                    Filename,
                    Line,
                    RepairLog);
            }

            MyFree (SourceName);

        } else {
            SetupDebugPrint1(L"SETUP: unable to compute checksum for %ws.", Target);
        }
    }
}


BOOL
WINAPI
pSetuplogSfcError(
    IN PCWSTR String,
    IN DWORD Index
    )
/*++

Routine Description:

   This function is used by sfc.dll to log any file signature problems when sfc
   is run during setup.  if you change this you MUST change the caller in
   \nt\private\sm\sfc\dll\eventlog.c


Arguments:

    String - pointer to a filename string for the problem file.
    Index  - this identifies what message should be logged onto the system.

Return Value:

    TRUE for success (the message was added to the errorlog), FALSE for failure.

--*/
{
    DWORD MessageId;
    DWORD Severity;

#if PRERELEASE
    SfcErrorOccurred = TRUE;
#endif

    switch (Index) {
    case 0:
        MessageId= MSG_DLL_CHANGE;
        Severity = LogSevInformation;
        break;
    case 1:
        MessageId= MSG_DLL_CHANGE_FAILURE;
        Severity = LogSevError;
        break;
    case 2:
        MessageId= MSG_DLL_CACHE_COPY_ERROR;
        Severity = LogSevInformation;
        break;
    default:
        MYASSERT(FALSE && "Unknown message id pSetuplogSfcError");
        return(FALSE);
    }

    return SetuplogError(
        SETUPLOG_SINGLE_MESSAGE | Severity,
        SETUPLOG_USE_MESSAGEID,
        MessageId,
        String, NULL, NULL
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\mainwind.c ===
#include "setupp.h"
#pragma hdrstop
#include <winuserp.h>

PCWSTR szWindowClass = L"$$$SetupBackground";

//
// Window longs for background window.
//
#define XWL_BITMAP  (0)
#define XWL_LOGO    (XWL_BITMAP + sizeof(PVOID))
#define XWL_BANNER  (XWL_LOGO + sizeof(PVOID))
#define XWL_FONT    (XWL_BANNER + sizeof(PVOID))
#define WL_COUNT    (4 * sizeof(PVOID))

#define POINTSIZE_WASHTEXT 24

HANDLE SetupWindowThreadHandle = NULL;


VOID
SetupMakeSureFontIsAvailable()
{
    static BOOL     DoneAlready = FALSE;
    LONG            l;
    HKEY            hKey;
    DWORD           i;
    WCHAR           Name[256];
    WCHAR           Data[256];
    DWORD           s1;
    DWORD           s2;
    DWORD           Type;
    DWORD           Result;

    if(DoneAlready) {
        return;
    }

    //
    // Want MS Serif but don't know which one serife.fon, seriffg.fon, etc.
    //
    l = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts",
            0,
            KEY_QUERY_VALUE,
            &hKey
            );

    if(l == NO_ERROR) {

        i = 0;
        s1 = 256;
        s2 = 256;
        while(RegEnumValueW(hKey,i,Name,&s1,NULL,&Type,(LPBYTE) Data,&s2)
            == NO_ERROR) {

            if(Type == REG_SZ) {
                CharUpper(Name);
                if(wcsstr(Name,L"MS SERIF")) {
                    //
                    // Value data is filename.
                    //
                    GetWindowsDirectory(Name,256);
                    lstrcat(Name,L"\\FONTS\\");
                    lstrcat(Name,Data);
                    if(AddFontResource(Name)) {
                        DoneAlready = TRUE;
                        break;
                    }
                }
            }

            i++;
            s1 = 256;
            s2 = 256;
        }

        RegCloseKey(hKey);
    }

    //
    // One last-ditch effort
    //
    if(!DoneAlready) {
        Result = GetWindowsDirectory(Name,256);
        if( Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        lstrcat(Name,L"\\FONTS\\SERIFE.FON");
        if(AddFontResource(Name)) {
            DoneAlready = TRUE;
        }
    }
}

LRESULT
SetupBackgroundWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LRESULT l;
    HBITMAP hbm;
    LOGFONT LogFont;
    HFONT hFont;
    HDC hdc;
    HDC hdcMem;
    PAINTSTRUCT ps;
    RECT rc;
    COLORREF crBk,crTx;
    BITMAP bitmap;
    HBITMAP hbmOld;
    HFONT hFontOld;
    WCHAR Buffer[MAX_PATH];
    int OldMode;
    int i;
    PWSTR p;

    switch(msg) {

    case WM_CREATE:
        //
        // Load the default background bitmap and indicate no oem logo bitmap.
        //
#if 0
        hbm = LoadBitmap(
            MyModuleHandle,
            (ProductType == PRODUCT_WORKSTATION) ?
                MAKEINTRESOURCE(IDB_BACKGROUND_WORKSTATION) :
                MAKEINTRESOURCE(IDB_BACKGROUND_SERVER)
            );
#else
        GetSystemDirectory( Buffer, MAX_PATH );
        pSetupConcatenatePaths(Buffer,TEXT("setup.bmp"),MAX_PATH,NULL);
        hbm = (HBITMAP)LoadImage(NULL,Buffer,IMAGE_BITMAP,0,0,LR_LOADFROMFILE);
#endif
        SetWindowLongPtr(hwnd,XWL_BITMAP,(LONG_PTR)hbm);
        SetWindowLongPtr(hwnd,XWL_LOGO,0);

#if 0   // Don't show any text for now.
        //
        // Load default banner text.
        //
        LoadString(MyModuleHandle,IDS_WINNT_SETUP,Buffer,sizeof(Buffer)/sizeof(WCHAR));
        SetWindowLongPtr(hwnd,XWL_BANNER,(LONG_PTR)pSetupDuplicateString(Buffer));
#endif

        //
        // Create font used to display text in upper left corner.
        //
        hdc = GetDC(hwnd);
        if( hdc ) {
            i = GetDeviceCaps(hdc,LOGPIXELSY);
            ReleaseDC(hwnd,hdc);
            SetupMakeSureFontIsAvailable();
            ZeroMemory(&LogFont,sizeof(LOGFONT));
            LogFont.lfHeight = -1 * (i * POINTSIZE_WASHTEXT / 72);
            LogFont.lfWeight = FW_DONTCARE;
            LogFont.lfCharSet = DEFAULT_CHARSET;
            LogFont.lfQuality = PROOF_QUALITY;
            LogFont.lfPitchAndFamily = DEFAULT_PITCH | FF_ROMAN;
            lstrcpy(LogFont.lfFaceName,L"MS Serif");
            hFont = CreateFontIndirect(&LogFont);
            SetWindowLongPtr(hwnd,XWL_FONT,(LONG_PTR)hFont);
        }
        //
        // Allow window creation to continue.
        //
        l = 0;
        break;

    case WM_NEWBITMAP:
        //
        // wParam tells us which bitmap; lParam is the bitmap handle
        // (or pointer to a banner string).
        //
        switch(wParam) {

        case SetupBmBackground:

            if(hbmOld = (HBITMAP)GetWindowLongPtr(hwnd,XWL_BITMAP)) {
                DeleteObject(hbmOld);
            }
            SetWindowLongPtr(hwnd,XWL_BITMAP,lParam);
            break;

        case SetupBmLogo:

            if(hbmOld = (HBITMAP)GetWindowLongPtr(hwnd,XWL_LOGO)) {
                DeleteObject(hbmOld);
            }
            SetWindowLongPtr(hwnd,XWL_LOGO,lParam);
            break;

        case SetupBmBanner:

            if(p = (PWSTR)GetWindowLongPtr(hwnd,XWL_BANNER)) {
                MyFree(p);
            }
            SetWindowLongPtr(hwnd,XWL_BANNER,lParam);
            break;
        }

        l = 0;
        break;

    case WM_PAINT:

        #define BANNER_OFFSET_X 5
        #define BANNER_OFFSET_Y 5

        //
        // The window class has CS_OWNDC so BeginPaint will succeed.
        //
        BeginPaint(hwnd,&ps);
        GetClientRect(hwnd,&rc);

        if(hdcMem = CreateCompatibleDC(ps.hdc)) {

            crBk = SetBkColor(ps.hdc,RGB(0,0,128));
            crTx = SetTextColor(ps.hdc,RGB(0,0,0));

            if(hbm = (HBITMAP)GetWindowLongPtr(hwnd,XWL_BITMAP)) {

                if(hbmOld = SelectObject(hdcMem,hbm)) {

                    GetObject(hbm,sizeof(BITMAP),&bitmap);

                    BitBlt(
                        ps.hdc,
                        rc.left + (((rc.right - rc.left) - bitmap.bmWidth) / 2),
                        rc.top + (((rc.bottom - rc.top) - bitmap.bmHeight) / 2),
                        bitmap.bmWidth,
                        bitmap.bmHeight,
                        hdcMem,
                        0,0,
                        SRCCOPY
                        );

                    SelectObject(hdcMem,hbmOld);
                }
            }

            if(hbm = (HBITMAP)GetWindowLongPtr(hwnd,XWL_LOGO)) {

                SetBkColor(ps.hdc,RGB(255,255,255));
                SetTextColor(ps.hdc,RGB(0,0,0));

                if(hbmOld = SelectObject(hdcMem,hbm)) {

                    GetObject(hbm,sizeof(BITMAP),&bitmap);

                    BitBlt(
                        ps.hdc,
                        (rc.right - bitmap.bmWidth) - BANNER_OFFSET_X,
                        rc.top + BANNER_OFFSET_Y,
                        bitmap.bmWidth,
                        bitmap.bmHeight,
                        hdcMem,
                        0,0,
                        SRCCOPY
                        );

                    SelectObject(hdcMem,hbmOld);
                }
            }

            SetBkColor(ps.hdc,crBk);
            SetTextColor(ps.hdc,crTx);

            DeleteDC(hdcMem);
        }

        hFont = (HFONT)GetWindowLongPtr(hwnd,XWL_FONT);
        if(hFont) {
            hFontOld = SelectObject(ps.hdc,hFont);
        } else {
            hFontOld = NULL;
        }

        crTx = SetTextColor(ps.hdc,RGB(255,255,255));
        OldMode = SetBkMode(ps.hdc,TRANSPARENT);

        if(p = (PWSTR)GetWindowLongPtr(hwnd,XWL_BANNER)) {
            //
            // Use this API so we get CR/LF to break a line
            //
            rc.left += BANNER_OFFSET_X;
            rc.top += BANNER_OFFSET_Y;
            DrawText(ps.hdc,p,-1,&rc,DT_NOPREFIX);
        }

        SetTextColor(ps.hdc,crTx);
        if(OldMode) {
            SetBkMode(ps.hdc,OldMode);
        }

        if(hFontOld) {
            SelectObject(ps.hdc,hFontOld);
        }

        EndPaint(hwnd,&ps);
        l = 0;
        break;

    case WM_DESTROY:

        //
        // Clean up.
        //
        if(hbm = (HBITMAP)GetWindowLongPtr(hwnd,XWL_BITMAP)) {
            DeleteObject(hbm);
        }

        if(hbm = (HBITMAP)GetWindowLongPtr(hwnd,XWL_LOGO)) {
            DeleteObject(hbm);
        }

        if(hFont = (HFONT)GetWindowLongPtr(hwnd,XWL_FONT)) {
            DeleteObject(hFont);
        }
        TerminateBillBoard();

        PostQuitMessage(0);
        l = 0;
        break;

    case WM_EXIT_SETUPWINDOW:
        DestroyWindow(hwnd);
        l = 0;
        break;

    case WM_HOTKEY:
        if (wParam == 0x6969) {
            //
            // Do this to make sure we get the correct cmd.exe, not whatever
            // is in our current path.
            //
            WCHAR Path[MAX_PATH];
            WCHAR CmdLine[MAX_PATH];
            ExpandEnvironmentStrings(
                            L"%SystemRoot%\\system32\\cmd.exe",
                            Path,
                            MAX_PATH);

            wsprintf(CmdLine, L"/c start %s", Path);
            InvokeExternalApplication(Path,CmdLine,NULL);
        }
        else if (wParam == 0xC2C2)
        {
            // User pressed key to make the wizard visible.
            // does not stop the billboard.
            if (WizardHandle)
            {
                SendMessage(WizardHandle, WMX_BBTEXT, (WPARAM)FALSE, 0);
            }
        }
        l = 0;
        break;

    default:
        l = DefWindowProc(hwnd,msg,wParam,lParam);
        break;
    }

    return(l);
}


DWORD
SetupWindowThread(
    PVOID ThreadParam
    )
{
    WNDCLASS wc;
    HWND hwnd;
    HWND hwndBB = NULL;
    DWORD ThreadId;
    MSG msg;
    BOOL b;
    WCHAR Buffer[128];
    HMODULE hmodSyssetup = NULL;

    //
    // The thread param is actually the thread id of the main thread.
    //
    ThreadId = (DWORD)((DWORD_PTR)ThreadParam);

    hwnd = NULL;

    wc.style = CS_NOCLOSE | CS_OWNDC;
    wc.lpfnWndProc = SetupBackgroundWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = WL_COUNT;
    wc.hInstance = MyModuleHandle;
    wc.hIcon = LoadIcon(MyModuleHandle,MAKEINTRESOURCE(IDI_SETUP));
    wc.hCursor = LoadCursor(NULL,IDC_ARROW);

    //
    // Background will be erased to black, which is what we want.
    //
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);

    wc.lpszMenuName = NULL;
    wc.lpszClassName = szWindowClass;

    if(RegisterClass(&wc)) {
        // add an extra dllref that holds syssetup.dll in process for the lifetime of the
        // $$$SetupBackground window.
        hmodSyssetup = LoadLibrary(TEXT("syssetup.dll")); 

        LoadString(MyModuleHandle,IDS_WINNT_SETUP,Buffer,sizeof(Buffer)/sizeof(WCHAR));
        hwnd = CreateWindow(
                    szWindowClass,
                    Buffer,  // L"Windows NT Setup",
                    WS_POPUP | WS_CLIPCHILDREN,
                    0,0,
                    GetSystemMetrics(SM_CXSCREEN),
                    GetSystemMetrics(SM_CYSCREEN),
                    NULL,
                    NULL,
                    MyModuleHandle,
                    0
                    );

        SetupWindowHandle = hwnd;
        if(hwnd) {
            ShowWindow(hwnd,SW_SHOW);
            //
            // Make this window bottommost.
            //
            SetShellWindow(hwnd);
            RegisterHotKey(hwnd,0x6969,MOD_SHIFT,VK_F10);
            RegisterHotKey(hwnd,0xC2C2,MOD_SHIFT,VK_F11);
        }
    }

    if (!MiniSetup)
    {
        PrepareBillBoard(hwnd);

        // If we have a Billboard, assign hwnd the windows handle. 
        // That way all dialogs have the billboard as the parent.
        // hwnd is returned by CreateSetupWindow and assinged to MainWindowHandle
        hwndBB = GetBBhwnd();
        if (hwndBB != NULL)
            hwnd = hwndBB; 
    }

    if(ThreadId != (DWORD)(-1)) {
        //
        // Called as a thread. Need to tell the main thread
        // the window handle.
        //
        PostThreadMessage(ThreadId,WM_MY_STATUS,0,(LPARAM)hwnd);

        //
        // Pump the message queue for this thread.
        //
        while((b = GetMessage(&msg,NULL,0,0)) && (b != (BOOL)(-1))) {
            DispatchMessage(&msg);
        }
    }

    if (hmodSyssetup)
    {
        FreeLibraryAndExitThread(hmodSyssetup, HandleToUlong(hwnd));
    }
    
    return HandleToUlong(hwnd);
}


HWND
CreateSetupWindow(
    VOID
    )
{
    HANDLE ThreadHandle;
    DWORD ThreadId;
    HWND hwnd;
    MSG msg;

    //
    // Create a thread that will in turn create and own the window.
    // This way, the window is always responsive and redraws correctly
    // without special processing requirements.
    //
    SetupWindowThreadHandle = CreateThread(
                        NULL,
                        0,
                        SetupWindowThread,
                        LongToPtr( GetCurrentThreadId() ),
                        0,
                        &ThreadId
                        );

    if(SetupWindowThreadHandle) {

        //
        // Wait for the thread to tell us whether it could
        // create the window or not.
        //
        do {
            WaitMessage();
        } while(!PeekMessage(&msg,(HWND)(-1),WM_MY_STATUS,WM_MY_STATUS,PM_REMOVE));

        hwnd = (HWND)msg.lParam;

    } else {
        //
        // Unable to create the thread. Do it the old fashioned way;
        // this is better than nothing and at least setup will continue.
        //
        hwnd = (HWND)LongToHandle( SetupWindowThread((PVOID)(-1)) );
    }

    return(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\ocm.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocm.c

Abstract:

    OC Manager implementation for intergratation with NT base setup

Author:

    Ted Miller (tedm) 20 May 1997

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#include <ocmanage.h>
#include <ocmgrlib.h>

//  Returns TRUE if ASR is enabled.  Otherwise, FALSE is returned.
BOOL
AsrIsEnabled(VOID);

VOID
OcFillInSetupDataW(
    OUT PSETUP_DATAW SetupData
    );

VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    );

VOID
OcSetReboot(
    VOID
    );

INT
OcLogError(
    IN OcErrorLevel Level,
    IN LPCWSTR      FormatString,
    ...
    );



OCM_CLIENT_CALLBACKS OcManagerImplementationCallbackRoutines = {
                                                                    OcFillInSetupDataA,
                                                                    OcLogError,
                                                                    OcSetReboot,
                                                                    OcFillInSetupDataW,
                                                                    ShowHideWizardPage,
                                                                    Billboard_Progress_Callback,
                                                                    Billboard_Set_Progress_Text,
                                                                    pSetupDebugPrint
                                                               };



PVOID
FireUpOcManager(
    VOID
    )

/*++

Routine Description:

    Initialize OC Manager, generating an OC Manager context.
    The master oc inf is assumed to be %windir%\system32\SYSOC.INF.

Arguments:

    None.

Return Value:

    OC Manager context handle.

--*/

{
    PWSTR MasterOcInf;
    WCHAR SystemDir[MAX_PATH];
    WCHAR DirSave[MAX_PATH];
    BOOL ShowErr;
    PVOID OcManagerContext;


    //
    // save the current directory
    //

    GetCurrentDirectory( sizeof(DirSave)/sizeof(WCHAR), DirSave );

    //
    // get the system directory
    //

    GetSystemDirectory( SystemDir, MAX_PATH );

    //
    // set the current dir to the master oc inf path
    // so that OcInitialize can find the component DLLs
    //

    SetCurrentDirectory( SystemDir );

    //
    // create a valid path to the master oc inf
    //

    if( !MiniSetup ) {
        if (!AsrIsEnabled()) {
            MasterOcInf =  L"SYSOC.INF";
        }
        else {
            MasterOcInf = L"ASROC.INF";
        }

    } else {
        MasterOcInf =  L"MINIOC.INF";
    }

    //
    // initialize the oc manager
    //

    BEGIN_SECTION(L"Initializing the OC manager");
    OcManagerContext = OcInitialize(
        &OcManagerImplementationCallbackRoutines,
        MasterOcInf,
        OCINIT_FORCENEWINF,
        &ShowErr,
        NULL
        );
    END_SECTION(L"Initializing the OC manager");

    //
    // restore the current directory
    //

    SetCurrentDirectory( DirSave );

    //
    // return the oc manager handle
    //

    return OcManagerContext;
}


VOID
KillOcManager(
    PVOID OcManagerContext
    )

/*++

Routine Description:

    Terminate OC Manager

Arguments:

    OC Manager context handle.

Return Value:

    none

--*/

{
    MYASSERT(OcManagerContext);
    if (OcManagerContext)
        OcTerminate(&OcManagerContext);
}


VOID
OcFillInSetupDataW(
    OUT PSETUP_DATAW SetupData
    )

/*++

Routine Description:

    "Glue" routine called by the OC Manager to request that the
    implementation fill in setup data to be passed to OC Manager
    component DLLs that expect Unicode data.

Arguments:

    SetupData - recieves setup data expected by OC components.

Return Value:

    None.

--*/

{
    //
    // It's not possible to be any more specific than this because
    // the mode page hasn't been shown yet.
    //
    SetupData->SetupMode = SETUPMODE_UNKNOWN;
    SetupData->ProductType = ProductType;

    lstrcpy(SetupData->SourcePath,SourcePath);

    SetupData->OperationFlags = 0;
    if(Win31Upgrade) {
        SetupData->OperationFlags |= SETUPOP_WIN31UPGRADE;
    }

    if(Win95Upgrade) {
        SetupData->OperationFlags |= SETUPOP_WIN95UPGRADE;
    }

    if(Upgrade) {
        SetupData->OperationFlags |= SETUPOP_NTUPGRADE;
    }

    if(UnattendMode > UAM_PROVIDEDEFAULT) {
        SetupData->OperationFlags |= SETUPOP_BATCH;
        lstrcpy(SetupData->UnattendFile,AnswerFile);
    }


    //
    // Which files are available?
    //
#if defined(_AMD64_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL | SETUPOP_AMD64_FILES_AVAIL;
#elif defined(_X86_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL;
#elif defined(_IA64_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL | SETUPOP_IA64_FILES_AVAIL;
#else
#pragma message( "*** Warning! No architecture defined!")
#endif

}


VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    )

/*++

Routine Description:

    "Glue" routine called by the OC Manager to request that the
    implementation fill in setup data to be passed to OC Manager
    component DLLs that expect ANSI data.

Arguments:

    SetupData - recieves setup data expected by OC components.

Return Value:

    None.

--*/

{
    SETUP_DATAW setupdata;

    OcFillInSetupDataW(&setupdata);

    SetupData->SetupMode = setupdata.SetupMode;
    SetupData->ProductType = setupdata.ProductType;
    SetupData->OperationFlags = setupdata.OperationFlags;

    WideCharToMultiByte(
        CP_ACP,
        0,
        setupdata.SourcePath,
        -1,
        SetupData->SourcePath,
        sizeof(SetupData->SourcePath),
        NULL,
        NULL
        );

    WideCharToMultiByte(
        CP_ACP,
        0,
        setupdata.UnattendFile,
        -1,
        SetupData->UnattendFile,
        sizeof(SetupData->UnattendFile),
        NULL,
        NULL
        );
}


VOID
OcSetReboot(
    VOID
    )

/*++

Routine Description:

    "Glue" routine called by the OC Manager when a reboot is deemed
    necessary by an OC Manager component.

    For this integrated version of OC Manager, this does nothing;
    the system is rebooted at the end of text mode.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return;
}


INT
OcLogError(
    IN OcErrorLevel Level,
    IN LPCWSTR      FormatString,
    ...
    )
{
    TCHAR str[4096];
    va_list arglist;
    UINT Icon;
    UINT lev;

    va_start(arglist,FormatString);
    wvsprintf(str,FormatString,arglist);
    va_end(arglist);

    if (Level &  OcErrLevWarning)
        lev = LogSevWarning;
    else if (Level &  OcErrLevError)
        lev = LogSevError;
    else if (Level &  OcErrLevFatal)
        lev = LogSevError;
    else 
        lev = LogSevInformation;

#if DBG
    if (lev != LogSevInformation) {
        SetupDebugPrint(str);        
    }
#endif

    SetuplogError(lev, str, 0, NULL, NULL);

    return NO_ERROR;
}

HWND 
ShowHideWizardPage(
    IN BOOL bShow
    )
{
    HWND hwnd = GetBBhwnd();
    if (hwnd)
    {
        SendMessage(WizardHandle, WMX_BBTEXT, (WPARAM)!bShow, 0);
    }
    // If we show the wizard again, return the wizard hwnd
    if (bShow)
    {
        // Should hide the progress bar, the wizard page is showing.
        BB_ShowProgressGaugeWnd(SW_HIDE);
        hwnd = WizardHandle;
    }
    return hwnd;
}

LRESULT
Billboard_Progress_Callback(
    IN UINT     Msg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    LRESULT lResult;
    if ((Msg == PBM_SETRANGE) || (Msg == PBM_SETRANGE32))
    {
        // Also enable the progress bar
        // Note: No hiding of the progress this way.
        BB_ShowProgressGaugeWnd(SW_SHOW);
        lResult = ProgressGaugeMsgWrapper(Msg, wParam, lParam);
    }
    else
    {
        lResult = ProgressGaugeMsgWrapper(Msg, wParam, lParam);
    }

    return lResult;
}

VOID Billboard_Set_Progress_Text(LPCTSTR Text)
{
    BB_SetProgressText(Text);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\intl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    intl.c

Abstract:

    Module with code for NLS-related stuff.
    This module is designed to be used with intl.inf and font.inf
    by control panel applets.

Author:

    Ted Miller (tedm) 15-Aug-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// This structure and the callback function below are used to set the
// hidden attribute bit on certain font files. That bit causes the font folder
// app to not autoinstall these files.
//
typedef struct _FONTQCONTEXT {
    PVOID SetupQueueContext;
    HINF FontInf;
} FONTQCONTEXT, *PFONTQCONTEXT;

PCWSTR szHiddenFontFiles = L"HiddenFontFiles";

VOID
pSetLocaleSummaryText(
    IN HWND hdlg
    );

VOID
pSetKeyboardLayoutSummaryText(
    IN HWND hdlg
    );


void
pSetupRunRegApps()
{
    HKEY hkey;
    BOOL bOK = TRUE;
    DWORD cbData, cbValue, dwType, ctr;
    TCHAR szValueName[32], szCmdLine[MAX_PATH];
    STARTUPINFO startup;
    PROCESS_INFORMATION pi;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\IntlRun"),
                    &hkey ) == ERROR_SUCCESS)
    {
        startup.cb = sizeof(STARTUPINFO);
        startup.lpReserved = NULL;
        startup.lpDesktop = NULL;
        startup.lpTitle = NULL;
        startup.dwFlags = 0L;
        startup.cbReserved2 = 0;
        startup.lpReserved2 = NULL;
    //  startup.wShowWindow = wShowWindow;

        for (ctr = 0; ; ctr++)
        {
            LONG lEnum;

            cbValue = sizeof(szValueName) / sizeof(TCHAR);
            cbData = sizeof(szCmdLine);

            if ((lEnum = RegEnumValue( hkey,
                                       ctr,
                                       szValueName,
                                       &cbValue,
                                       NULL,
                                       &dwType,
                                       (LPBYTE)szCmdLine,
                                       &cbData )) == ERROR_MORE_DATA)
            {
                //
                //  ERROR_MORE_DATA means the value name or data was too
                //  large, so skip to the next item.
                //
                continue;
            }
            else if (lEnum != ERROR_SUCCESS)
            {
                //
                //  This could be ERROR_NO_MORE_ENTRIES, or some kind of
                //  failure.  We can't recover from any other registry
                //  problem anyway.
                //
                break;
            }

            //
            //  Found a value.
            //
            if (dwType == REG_SZ)
            {
                //
                //  Adjust for shift in value index.
                //
                ctr--;

                //
                //  Delete the value.
                //
                RegDeleteValue(hkey, szValueName);

                //
                //  Only run things marked with a "*" in clean boot.
                //
                if (CreateProcess( NULL,
                                   szCmdLine,
                                   NULL,
                                   NULL,
                                   FALSE,
                                   CREATE_NEW_PROCESS_GROUP,
                                   NULL,
                                   NULL,
                                   &startup,
                                   &pi ))
                {
                    WaitForSingleObjectEx(pi.hProcess, INFINITE, TRUE);

                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
            }
        }
        RegCloseKey(hkey);
    }
}


VOID
InstallServerNLSFiles(
    IN  HWND    Window
    )

/*++

Routine Description:

    Installs a bunch of code pages for servers.  We install sections in intl.inf
    named [CODEPAGE_INSTALL_<n>], where the values for <n> are listed in the
    section [CodePages].

Arguments:

    Window - handle to parent window

Return Value:

    None.

--*/

{
    HINF    hInf;
    INFCONTEXT InfContext;
    BOOL b;
    PCWSTR  CodePage;
    WCHAR   InstallSection[30];
    HSPFILEQ    FileQueue;
    DWORD       QueueFlags;
    PVOID       pQueueContext;


    hInf = SetupOpenInfFile(L"INTL.INF",NULL,INF_STYLE_WIN4,NULL);
    if(hInf == INVALID_HANDLE_VALUE) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: Unable to open intl.inf" );
        return;
    }

    if(!SetupOpenAppendInfFile( NULL, hInf, NULL )) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: Unable to open intl.inf layout" );
        return;
    }

    if(!SetupFindFirstLine(hInf,L"CodePages",NULL,&InfContext)) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: Unable to find [CodePages] section" );
        goto c1;
    }

    //
    // Create a setup file queue and initialize default Setup copy queue
    // callback context.
    //
    QueueFlags = SP_COPY_FORCE_NOOVERWRITE;
    FileQueue = SetupOpenFileQueue();
    if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: SetupOpenFileQueue failed" );
        goto c1;
    }

    //
    // Disable the file-copy progress dialog.
    //
    pQueueContext = InitSysSetupQueueCallbackEx(
        Window,
        INVALID_HANDLE_VALUE,
        0,0,NULL);
    if(!pQueueContext) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: InitSysSetupQueueCallbackEx failed" );
        goto c2;
    }

    do {
        if(CodePage = pSetupGetField(&InfContext,0)) {
            wsprintf( InstallSection, L"CODEPAGE_INSTALL_%s", CodePage );

            //
            // Enqueue locale-related files for copy.
            //
            b = SetupInstallFilesFromInfSection(
                    hInf,
                    NULL,
                    FileQueue,
                    InstallSection,
                    NULL,
                    QueueFlags
                    );
            if(!b) {
                SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: SetupInstallFilesFromInfSection failed" );
                goto c3;
            }
        }

    } while(SetupFindNextLine(&InfContext,&InfContext));

    //
    // Copy enqueued files.
    //
    b = SetupCommitFileQueue(
            Window,
            FileQueue,
            SysSetupQueueCallback,
            pQueueContext
            );
    if(!b) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: SetupCommitFileQueue failed" );
        goto c3;
    }

    if(!SetupFindFirstLine(hInf,L"CodePages",NULL,&InfContext)) {
        SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: Unable to find [CodePages] section (2nd pass)" );
        goto c3;
    }

    do {
        if(CodePage = pSetupGetField(&InfContext,0)) {
            wsprintf( InstallSection, L"CODEPAGE_INSTALL_%s", CodePage );

            //
            // Complete installation of locale stuff.
            //
            b = SetupInstallFromInfSection(
                    Window,
                    hInf,
                    InstallSection,
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
            if(!b) {
                SetupDebugPrint( L"SETUP: pSetupInstallNLSFiles: SetupInstallFromInfSection failed" );
                goto c3;
            }
        }

    } while(SetupFindNextLine(&InfContext,&InfContext));

c3:
    TermSysSetupQueueCallback(pQueueContext);
c2:
    SetupCloseFileQueue(FileQueue);
c1:
    SetupCloseInfFile(hInf);
    return;
}


DWORD
pSetupInitRegionalSettings(
    IN  HWND    Window
    )
{
    HINF IntlInf;
    LONG l;
    HKEY hKey;
    DWORD d;
    BOOL  b;
    DWORD Type;
    INFCONTEXT LineContext;
    WCHAR IdFromRegistry[9];
    WCHAR KeyName[9];
    WCHAR LanguageGroup[9];
    WCHAR LanguageInstallSection[25];
    LCID  SystemLocale;
    HSPFILEQ    FileQueue;
    DWORD       QueueFlags;
    PVOID       pQueueContext;

    //
    // Open intl.inf. The locale descriptions are in there.
    // Lines in the [Locales] section have keys that are 32-bit
    // locale ids but the sort part is always 0, so they're more like
    // zero-extended language ids.
    //
    IntlInf = SetupOpenInfFile(L"intl.inf",NULL,INF_STYLE_WIN4,NULL);

    if(IntlInf == INVALID_HANDLE_VALUE) {
        SetupDebugPrint( L"SETUP: pSetupInitRegionalSettings: Unable to open intl.inf" );
        l = GetLastError();
        goto c0;
    }

    if(!SetupOpenAppendInfFile( NULL, IntlInf, NULL )) {
        SetupDebugPrint( L"SETUP: pSetupInitRegionalSettings: Unable to open intl.inf layout" );
        l = GetLastError();
        goto c0;
    }

    //
    // Read the system locale from the registry. and look up in intl.inf.
    // The value in the registry is a 16-bit language id, so we need to
    // zero-extend it to index intl.inf.
    //
    l = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Control\\Nls\\Language",
            0,
            KEY_QUERY_VALUE,
            &hKey
            );

    if(l == NO_ERROR) {
        d = sizeof(IdFromRegistry);
        l = RegQueryValueEx(hKey,L"Default",NULL,&Type,(LPBYTE)IdFromRegistry,&d);
        RegCloseKey(hKey);
        if((l == NO_ERROR) && ((Type != REG_SZ) || (d != 10))) {
            l = ERROR_INVALID_DATA;
        }
    }

    if(l == NO_ERROR) {

        l = ERROR_INVALID_DATA;

        wsprintf(KeyName,L"0000%s",IdFromRegistry);

        if(SetupFindFirstLine(IntlInf,L"Locales",KeyName,&LineContext)
        && SetupGetStringField(&LineContext,3,LanguageGroup,
            sizeof(LanguageGroup)/sizeof(WCHAR),NULL)) {

            l = NO_ERROR;
        }
    }

    if(l == NO_ERROR) {
        wsprintf(LanguageInstallSection,L"LG_INSTALL_%s",LanguageGroup);

        //
        // We copy the files in textmode setup now, so we don't need to do that
        // here anymore.
        //
#define DO_COPY_FILES
#ifdef DO_COPY_FILES
        //
        // Create a setup file queue and initialize default Setup copy queue
        // callback context.
        //
        QueueFlags = SP_COPY_FORCE_NOOVERWRITE;
        FileQueue = SetupOpenFileQueue();
        if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
            l = ERROR_OUTOFMEMORY;
            goto c1;
        }

        //
        // Disable the file-copy progress dialog.
        //
        pQueueContext = InitSysSetupQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL);
        if(!pQueueContext) {
            l = ERROR_OUTOFMEMORY;
            goto c2;
        }

        //
        // Enqueue locale-related files for copy.  We install locales for the
        // system default and the Western language group, which is group 1.
        //
        b = SetupInstallFilesFromInfSection(
                IntlInf,
                NULL,
                FileQueue,
                LanguageInstallSection,
                NULL,
                QueueFlags
                );
        if(!b) {
            l = GetLastError();
            goto c3;
        }

        if(wcscmp(LanguageGroup,L"1")) {
            b = SetupInstallFilesFromInfSection(
                    IntlInf,
                    NULL,
                    FileQueue,
                    L"LG_INSTALL_1",
                    NULL,
                    QueueFlags
                    );
        }
        if(!b) {
            l = GetLastError();
            goto c3;
        }

        //
        // Determine whether the queue actually needs to be committed.
        //
        b = SetupScanFileQueue(
                FileQueue,
                SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                Window,
                NULL,
                NULL,
                &d
                );

        if(!b) {
            l = GetLastError();
            goto c3;
        }

        //
        // d = 0: User wants new files or some files were missing;
        //        Must commit queue.
        //
        // d = 1: User wants to use existing files and queue is empty;
        //        Can skip committing queue.
        //
        // d = 2: User wants to use existing files but del/ren queues not empty.
        //        Must commit queue. The copy queue will have been emptied,
        //        so only del/ren functions will be performed.
        //
        if(d == 1) {

            b = TRUE;

        } else {

            //
            // Copy enqueued files.
            //
            b = SetupCommitFileQueue(
                    Window,
                    FileQueue,
                    SysSetupQueueCallback,
                    pQueueContext
                    );
        }

        if(!b) {
            l = GetLastError();
            goto c3;
        }
#endif
        //
        // Complete installation of locale stuff.
        //
        b = SetupInstallFromInfSection(
                Window,
                IntlInf,
                LanguageInstallSection,
                SPINST_ALL & ~SPINST_FILES,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );
        if(!b) {
            l = GetLastError();
#ifdef DO_COPY_FILES
            goto c3;
#else
            goto c1;
#endif
        }

        if(wcscmp(LanguageGroup,L"1")) {
            b = SetupInstallFromInfSection(
                    Window,
                    IntlInf,
                    L"LG_INSTALL_1",
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        }
        if(!b) {
            l = GetLastError();
#ifdef DO_COPY_FILES
            goto c3;
#else
            goto c1;
#endif
        }

    }
    pSetupRunRegApps();

    SystemLocale = wcstol(IdFromRegistry,NULL,16);
    if (l == NO_ERROR) {
        l = SetupChangeLocaleEx(
            Window,
            SystemLocale,
            SourcePath,
            SP_INSTALL_FILES_QUIETLY,
            NULL,0);

#ifdef DO_COPY_FILES
c3:
        TermSysSetupQueueCallback(pQueueContext);
c2:
        SetupCloseFileQueue(FileQueue);
#endif
    }
c1:
    SetupCloseInfFile(IntlInf);
c0:
    SetupDebugPrint2( L"SETUP: pSetupInitRegionalSettings returned %d (0x%08x)", l, l);
    return l;
}


UINT
pSetupFontQueueCallback(
    IN PFONTQCONTEXT Context,
    IN UINT          Notification,
    IN UINT_PTR      Param1,
    IN UINT_PTR      Param2
    )
{
    PFILEPATHS FilePaths;
    PWCHAR p;
    INFCONTEXT InfContext;

    //
    // If a file is finished being copied, set its attributes
    // to include the hidden attribute if necessary.
    //
    if((Notification == SPFILENOTIFY_ENDCOPY)
    && (FilePaths = (PFILEPATHS)Param1)
    && (FilePaths->Win32Error == NO_ERROR)
    && (p = wcsrchr(FilePaths->Target,L'\\'))
    && SetupFindFirstLine(Context->FontInf,szHiddenFontFiles,p+1,&InfContext)) {

        SetFileAttributes(FilePaths->Target,FILE_ATTRIBUTE_HIDDEN);
    }

    return( IsSetup ?
        SysSetupQueueCallback(Context->SetupQueueContext,Notification,Param1,Param2) :
        SetupDefaultQueueCallback(Context->SetupQueueContext,Notification,Param1,Param2)
        );
}


VOID
pSetupMarkHiddenFonts(
    VOID
    )
{
    HINF hInf;
    INFCONTEXT InfContext;
    BOOL b;
    WCHAR Path[MAX_PATH];
    PWCHAR p;
    PCWSTR q;
    int Space;

    hInf = SetupOpenInfFile(L"FONT.INF",NULL,INF_STYLE_WIN4,NULL);
    if(hInf != INVALID_HANDLE_VALUE) {

        GetWindowsDirectory(Path,MAX_PATH);
        lstrcat(Path,L"\\FONTS\\");
        p = Path + lstrlen(Path);
        Space = MAX_PATH - (int)(p - Path);

        if(SetupFindFirstLine(hInf,szHiddenFontFiles,NULL,&InfContext)) {

            do {
                if(q = pSetupGetField(&InfContext,0)) {

                    lstrcpyn(p,q,Space);
                    if(FileExists(Path,NULL)) {
                        SetFileAttributes(Path,FILE_ATTRIBUTE_HIDDEN);
                    }
                }

            } while(SetupFindNextLine(&InfContext,&InfContext));
        }

        SetupCloseInfFile(hInf);
    }
}


DWORD
pSetupNLSInstallFonts(
    IN HWND     Window,
    IN HINF     InfHandle,
    IN PCWSTR   OemCodepage,
    IN PCWSTR   FontSize,
    IN HSPFILEQ FileQueue,
    IN PCWSTR   SourcePath,     OPTIONAL
    IN DWORD    QueueFlags
    )
{
    BOOL b;
    WCHAR SectionName[64];

    //
    // Form section name.
    //
    wsprintf(SectionName,L"Font.CP%s.%s",OemCodepage,FontSize);

    if(FileQueue) {
        //
        // First pass: just enqueue files for copy.
        //
        b = SetupInstallFilesFromInfSection(
                InfHandle,
                NULL,
                FileQueue,
                SectionName,
                SourcePath,
                QueueFlags
                );
    } else {
        //
        // Second pass: do registry munging, etc.
        //
        b = SetupInstallFromInfSection(
                Window,
                InfHandle,
                SectionName,
                SPINST_ALL & ~SPINST_FILES,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );
    }

    return(b ? NO_ERROR : GetLastError());
}


DWORD
pSetupNLSLoadInfs(
    OUT HINF *FontInfHandle,
    OUT HINF *IntlInfHandle     OPTIONAL
    )
{
    HINF fontInfHandle;
    HINF intlInfHandle;
    DWORD d;

    fontInfHandle = SetupOpenInfFile(L"font.inf",NULL,INF_STYLE_WIN4,NULL);
    if(fontInfHandle == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        goto c0;
    }

    if(!SetupOpenAppendInfFile(NULL,fontInfHandle,NULL)) {
        d = GetLastError();
        goto c1;
    }

    if(IntlInfHandle) {
        intlInfHandle = SetupOpenInfFile(L"intl.inf",NULL,INF_STYLE_WIN4,NULL);
        if(intlInfHandle == INVALID_HANDLE_VALUE) {
            d = GetLastError();
            goto c1;
        }

        if(!SetupOpenAppendInfFile(NULL,intlInfHandle,NULL)) {
            d = GetLastError();
            goto c2;
        }

        *IntlInfHandle = intlInfHandle;
    }

    *FontInfHandle = fontInfHandle;
    return(NO_ERROR);

c2:
    SetupCloseInfFile(intlInfHandle);
c1:
    SetupCloseInfFile(fontInfHandle);
c0:
    return(d);
}


DWORD
SetupChangeLocale(
    IN HWND Window,
    IN LCID NewLocale
    )
{
    return(SetupChangeLocaleEx(Window,NewLocale,NULL,0,NULL,0));
}


DWORD
SetupChangeLocaleEx(
    IN HWND   Window,
    IN LCID   NewLocale,
    IN PCWSTR SourcePath,   OPTIONAL
    IN DWORD  Flags,
    IN PVOID  Reserved1,
    IN DWORD  Reserved2
    )
{
    DWORD d;
    BOOL b;
    HINF IntlInfHandle;
    INFCONTEXT InfContext;
    WCHAR Codepage[24];
    WCHAR NewLocaleString[24];
    FONTQCONTEXT QueueContext;
    HSPFILEQ FileQueue;
    PCWSTR SizeSpec;
    HDC hdc;
    PCWSTR p;
    DWORD QueueFlags;
    HKEY hKey;
    DWORD DataType;
    DWORD SizeDword;
    DWORD DataSize;


    SizeSpec = L"96";
#if 0
    // This is no longer reliable.
    if(hdc = CreateDC(L"DISPLAY",NULL,NULL,NULL)) {
        if(GetDeviceCaps(hdc,LOGPIXELSY) > 108) {
            SizeSpec = L"120";
        }

        DeleteDC(hdc);
    }
#else
    //
    // Determine the current font size. Default to 96.
    //
    d = (DWORD)RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Hardware Profiles\\Current\\Software\\Fonts",
        0,
        KEY_QUERY_VALUE,
        &hKey
        );

    if(d == NO_ERROR) {

        DataSize = sizeof(DWORD);
        d = (DWORD)RegQueryValueEx(
            hKey,
            L"LogPixels",
            NULL,
            &DataType,
            (LPBYTE)&SizeDword,
            &DataSize
            );

        if( (d == NO_ERROR) && (DataType == REG_DWORD) &&
            (DataSize == sizeof(DWORD)) && (SizeDword > 108) ) {

            SizeSpec = L"120";
        }
        RegCloseKey(hKey);
    }
#endif

    QueueFlags = SP_COPY_NEWER | BaseCopyStyle;
    if(Flags & SP_INSTALL_FILES_QUIETLY) {
        QueueFlags |= SP_COPY_FORCE_NOOVERWRITE;
    }

    //
    // Load inf files.
    //
    d = pSetupNLSLoadInfs(&QueueContext.FontInf,&IntlInfHandle);
    if(d != NO_ERROR) {
        goto c0;
    }

    //
    // Get oem codepage for the locale. This is also a sanity check
    // to see that the locale is supported.
    //
    wsprintf(NewLocaleString,L"%.8x",NewLocale);
    if(!SetupFindFirstLine(IntlInfHandle,L"Locales",NewLocaleString,&InfContext)) {
        d = ERROR_INVALID_PARAMETER;
        goto c1;
    }

    p = pSetupGetField(&InfContext,2);
    if(!p) {
        d = ERROR_INVALID_PARAMETER;
        goto c1;
    }
    //
    // Copy into local storage since p points into internal structures
    // that could move as we call INF APIs
    //
    lstrcpyn(Codepage,p,sizeof(Codepage)/sizeof(Codepage[0]));

    //
    // Create a setup file queue and initialize default Setup copy queue
    // callback context.
    //
    FileQueue = SetupOpenFileQueue();
    if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
        d = ERROR_OUTOFMEMORY;
        goto c1;
    }

    QueueContext.SetupQueueContext = IsSetup ?
        InitSysSetupQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL) :
        SetupInitDefaultQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL);

    if(!QueueContext.SetupQueueContext) {
        d = ERROR_OUTOFMEMORY;
        goto c2;
    }

    //
    // Enqueue locale-related files for copy.
    //
    b = SetupInstallFilesFromInfSection(
            IntlInfHandle,
            NULL,
            FileQueue,
            NewLocaleString,
            SourcePath,
            QueueFlags
            );

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // Enqueue font-related files for copy.
    //
    d = pSetupNLSInstallFonts(
            Window,
            QueueContext.FontInf,
            Codepage,
            SizeSpec,
            FileQueue,
            SourcePath,
            QueueFlags
            );

    if(d != NO_ERROR) {
        goto c3;
    }

    //
    // Determine whether the queue actually needs to be committed.
    //
    b = SetupScanFileQueue(
            FileQueue,
            SPQ_SCAN_FILE_VALIDITY | ((Flags & SP_INSTALL_FILES_QUIETLY) ? SPQ_SCAN_PRUNE_COPY_QUEUE : SPQ_SCAN_INFORM_USER),
            Window,
            NULL,
            NULL,
            &d
            );

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // d = 0: User wants new files or some files were missing;
    //        Must commit queue.
    //
    // d = 1: User wants to use existing files and queue is empty;
    //        Can skip committing queue.
    //
    // d = 2: User wants to use existing files but del/ren queues not empty.
    //        Must commit queue. The copy queue will have been emptied,
    //        so only del/ren functions will be performed.
    //
    if(d == 1) {

        b = TRUE;

    } else {

        //
        // Copy enqueued files.
        //
        b = SetupCommitFileQueue(
                Window,
                FileQueue,
                pSetupFontQueueCallback,
                &QueueContext
                );
    }

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // Complete installation of locale stuff.
    //
    b = SetupInstallFromInfSection(
            Window,
            IntlInfHandle,
            NewLocaleString,
            SPINST_ALL & ~SPINST_FILES,
             NULL,
            NULL,
            0,
            NULL,
            NULL,
            NULL,
            NULL
            );

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // Perform font magic associated with the new locale's codepage(s).
    //
    d = pSetupNLSInstallFonts(Window,QueueContext.FontInf,Codepage,SizeSpec,NULL,NULL,0);

c3:
    if(IsSetup) {
        TermSysSetupQueueCallback(QueueContext.SetupQueueContext);
    } else {
        SetupTermDefaultQueueCallback(QueueContext.SetupQueueContext);
    }

c2:
    SetupCloseFileQueue(FileQueue);
c1:
    SetupCloseInfFile(QueueContext.FontInf);
    SetupCloseInfFile(IntlInfHandle);
c0:
    if (IsSetup) {
        SetupDebugPrint2( L"SETUP: SetupChangeLocaleEx returned %d (0x%08x)", d, d);
    }
    return(d);
}


DWORD
SetupChangeFontSize(
    IN HWND   Window,
    IN PCWSTR SizeSpec
    )
{
    DWORD d;
    WCHAR cp[24];
    FONTQCONTEXT QueueContext;
    HSPFILEQ FileQueue;
    BOOL b;

    //
    // Get the current OEM CP
    //
    wsprintf(cp,L"%u",GetOEMCP());

    //
    // Load NLS inf.
    //
    d = pSetupNLSLoadInfs(&QueueContext.FontInf,NULL);
    if(d != NO_ERROR) {
        goto c0;
    }

    //
    // Create queue and initialize default callback routine.
    //
    FileQueue = SetupOpenFileQueue();
    if(!FileQueue || (FileQueue == INVALID_HANDLE_VALUE)) {
        d = ERROR_OUTOFMEMORY;
        goto c1;
    }

    QueueContext.SetupQueueContext = IsSetup ?
        InitSysSetupQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL) :
        SetupInitDefaultQueueCallbackEx(
            Window,
            INVALID_HANDLE_VALUE,
            0,0,NULL);

    if(!QueueContext.SetupQueueContext) {
        d = ERROR_OUTOFMEMORY;
        goto c2;
    }

    //
    // First pass: copy files.
    //
    d = pSetupNLSInstallFonts(
            Window,
            QueueContext.FontInf,
            cp,
            SizeSpec,
            FileQueue,
            NULL,
            SP_COPY_NEWER | BaseCopyStyle
            );
    if(d != NO_ERROR) {
        goto c3;
    }

    //
    // Determine whether the queue actually needs to be committed.
    //
    b = SetupScanFileQueue(
            FileQueue,
            SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_INFORM_USER,
            Window,
            NULL,
            NULL,
            &d
            );

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // d = 0: User wants new files or some files were missing;
    //        Must commit queue.
    //
    // d = 1: User wants to use existing files and queue is empty;
    //        Can skip committing queue.
    //
    // d = 2: User wants to use existing files but del/ren queues not empty.
    //        Must commit queue. The copy queue will have been emptied,
    //        so only del/ren functions will be performed.
    //
    if(d == 1) {

        b = TRUE;

    } else {

        b = SetupCommitFileQueue(
                Window,
                FileQueue,
                pSetupFontQueueCallback,
                &QueueContext
                );
    }

    if(!b) {
        d = GetLastError();
        goto c3;
    }

    //
    // Second pass: perform registry munging, etc.
    //
    d = pSetupNLSInstallFonts(Window,QueueContext.FontInf,cp,SizeSpec,NULL,NULL,0);

c3:
    if(IsSetup) {
        TermSysSetupQueueCallback(QueueContext.SetupQueueContext);
    } else {
        SetupTermDefaultQueueCallback(QueueContext.SetupQueueContext);
    }
c2:
    SetupCloseFileQueue(FileQueue);
c1:
    SetupCloseInfFile(QueueContext.FontInf);
c0:
    return(d);
}


////////////////////////////////////////////////////////////////////
//
// Code below here is for regional settings stuff that occurs during
// gui mode setup
//
////////////////////////////////////////////////////////////////////


INT_PTR
CALLBACK
RegionalSettingsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL b;
    NMHDR *NotifyParams;
    WCHAR CmdLine[MAX_PATH];


    b = TRUE;

    switch(msg) {

    case WM_SIMULATENEXT:
        PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        break;

    case WMX_VALIDATE:
        // Empty page
        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(502);
            BEGIN_SECTION(L"Regional Settings Page");
            SetWizardButtons(hdlg,WizPageRegionalSettings);

            //
            // Set message text.
            //
            pSetLocaleSummaryText(hdlg);
            pSetKeyboardLayoutSummaryText(hdlg);

            //
            // Allow activation.
            //

            //
            // Show unless OEMSkipRegional = 1
            //
            if( Preinstall ) {
                //
                // Always show the page in a Preinstall, unless the user
                // has sent us OEMSkipRegional.
                //
                if (GetPrivateProfileInt(pwGuiUnattended,L"OEMSkipRegional",0,AnswerFile))
                {
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1 );
                }
                else
                {
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT,0);
                }
            } else {
                SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                if(Unattended) {
                    if (!UnattendSetActiveDlg(hdlg,IDD_REGIONAL_SETTINGS))
                    {
                        break;
                    }
                }
                // Page becomes active, make page visible.
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Allow next page to be activated.
            //
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,FALSE);
            END_SECTION(L"Regional Settings Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageRegionalSettings);
            break;

        default:
            b = FALSE;
            break;
        }

        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) {

        case IDB_LOCALE:
        case IDB_KBDLAYOUT:

            if(HIWORD(wParam) == BN_CLICKED) {

                PropSheet_SetWizButtons(GetParent(hdlg),0);
                EnableWindow(GetParent(hdlg),FALSE);

                wsprintf(
                    CmdLine,
                    L"/%c /s:\"%s\"",
                    (LOWORD(wParam) == IDB_LOCALE) ? L'R' : L'I',
                    LegacySourcePath
                    );

                InvokeControlPanelApplet(L"intl.cpl",L"",0,CmdLine);

                if(LOWORD(wParam) == IDB_LOCALE) {
                    pSetLocaleSummaryText(hdlg);
                }
                pSetKeyboardLayoutSummaryText(hdlg);

                EnableWindow(GetParent(hdlg),TRUE);
                SetWizardButtons(hdlg,WizPageRegionalSettings);
                // Get the focus tot he wizard and set it to the button the user selected.
                SetForegroundWindow(GetParent(hdlg));
                SetFocus(GetDlgItem(hdlg,LOWORD(wParam)));

            } else {
                b = FALSE;
            }
            break;

        default:
            b = FALSE;
            break;
        }

        break;

    default:

        b = FALSE;
        break;
    }

    return(b);
}


VOID
pSetLocaleSummaryText(
    IN HWND hdlg
    )
{
    HINF IntlInf;
    LONG l;
    HKEY hKey;
    DWORD d;
    DWORD Type;
    INFCONTEXT LineContext;
    WCHAR IdFromRegistry[9];
    WCHAR KeyName[9];
    WCHAR UserLocale[100],GeoLocation[100];
    WCHAR FormatString[300];
    WCHAR MessageText[500];
    LPCWSTR args[2];
    DWORD   dwGeoID;


    //
    // Open intl.inf. The locale descriptions are in there.
    // Lines in the [Locales] section have keys that are 32-bit
    // locale ids but the sort part is always 0, so they're more like
    // zero-extended language ids.
    //
    IntlInf = SetupOpenInfFile(L"intl.inf",NULL,INF_STYLE_WIN4,NULL);

    if(IntlInf == INVALID_HANDLE_VALUE) {
        LoadString(MyModuleHandle,IDS_UNKNOWN_PARENS,UserLocale,sizeof(UserLocale)/sizeof(WCHAR));
        lstrcpy(GeoLocation,UserLocale);
    } else {
        //
        // Read the user locale, which is stored as a full 32-bit LCID.
        // We have to chop off the sort id part to index intl.inf.
        //
        l = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                L"Control Panel\\International",
                0,
                KEY_QUERY_VALUE,
                &hKey
                );

        if(l == NO_ERROR) {
            d = sizeof(IdFromRegistry);
            l = RegQueryValueEx(hKey,L"Locale",NULL,&Type,(LPBYTE)IdFromRegistry,&d);
            RegCloseKey(hKey);
            if((l == NO_ERROR) && ((Type != REG_SZ) || (d != 18))) {
                l = ERROR_INVALID_DATA;
            }
        }

        if(l == NO_ERROR) {

            l = ERROR_INVALID_DATA;

            wsprintf(KeyName,L"0000%s",IdFromRegistry+4);

            if(SetupFindFirstLine(IntlInf,L"Locales",KeyName,&LineContext)
            && SetupGetStringField(&LineContext,1,UserLocale,sizeof(UserLocale)/sizeof(WCHAR),NULL)) {

                l = NO_ERROR;
            }
        }

        if(l != NO_ERROR) {
            LoadString(MyModuleHandle,IDS_UNKNOWN_PARENS,UserLocale,sizeof(UserLocale)/sizeof(WCHAR));
        }

        SetupCloseInfFile(IntlInf);

        //
        // Read the GEO location
        //
        l = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                L"Control Panel\\International\\Geo",
                0,
                KEY_QUERY_VALUE,
                &hKey
                );

        if(l == NO_ERROR) {
            d = sizeof(IdFromRegistry);
            l = RegQueryValueEx(hKey,L"Nation",NULL,&Type,(LPBYTE)IdFromRegistry,&d);
            RegCloseKey(hKey);
            if((l == NO_ERROR) && (Type != REG_SZ)) {
                l = ERROR_INVALID_DATA;
            }
        }

        if(l == NO_ERROR) {

            l = ERROR_INVALID_DATA;

            dwGeoID = wcstoul ( IdFromRegistry, NULL, 10 );
            if (GetGeoInfo (
                dwGeoID,
                GEO_FRIENDLYNAME,
                GeoLocation,
                sizeof(GeoLocation)/sizeof(WCHAR),
                0 )
                ) {

                l = NO_ERROR;
            }
        }

        if(l != NO_ERROR) {
            LoadString(MyModuleHandle,IDS_UNKNOWN_PARENS,GeoLocation,sizeof(GeoLocation)/sizeof(WCHAR));
        }
    }

    args[0] = UserLocale;
    args[1] = GeoLocation;

    LoadString(MyModuleHandle,IDS_LOCALE_MSG,FormatString,sizeof(FormatString)/sizeof(WCHAR));

    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        FormatString,
        0,0,
        MessageText,
        sizeof(MessageText)/sizeof(WCHAR),
        (va_list *)args
        );

    SetDlgItemText(hdlg,IDT_LOCALE,MessageText);
}


VOID
pSetKeyboardLayoutSummaryText(
    IN HWND hdlg
    )
{
    LONG l;
    HKEY hKey;
    BOOL MultipleLayouts;
    DWORD d;
    DWORD Type;
    WCHAR IdFromRegistry[9];
    WCHAR Substitute[9];
    WCHAR Name[200];
    WCHAR FormatString[300];
    WCHAR MessageText[500];

    //
    // Open the Preload key in the registry.
    //
    l = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            L"Keyboard Layout\\Preload",
            0,
            KEY_QUERY_VALUE,
            &hKey
            );

    MultipleLayouts = FALSE;
    if(l == NO_ERROR) {
        //
        // Pull out 2=. If it's there, then we're in a "complex" config
        // situation, which will change our message text a little.
        //
        d = sizeof(IdFromRegistry);
        if(RegQueryValueEx(hKey,L"2",NULL,&Type,(LPBYTE)IdFromRegistry,&d) == NO_ERROR) {
            MultipleLayouts = TRUE;
        }

        //
        // Get 1=, which is the main layout.
        //
        d = sizeof(IdFromRegistry);
        l = RegQueryValueEx(hKey,L"1",NULL,&Type,(LPBYTE)IdFromRegistry,&d);
        if((l == NO_ERROR) && (Type != REG_SZ)) {
            l = ERROR_INVALID_DATA;
        }

        RegCloseKey(hKey);

        //
        // Now we look in the substitutes key to see whether there is a
        // substitute there.
        //
        if(RegOpenKeyEx(HKEY_CURRENT_USER,L"Keyboard Layout\\Substitutes",0,KEY_QUERY_VALUE,&hKey) == NO_ERROR) {

            d = sizeof(Substitute);
            if((RegQueryValueEx(hKey,IdFromRegistry,NULL,&Type,(LPBYTE)Substitute,&d) == NO_ERROR)
            && (Type == REG_SZ)) {

                lstrcpy(IdFromRegistry,Substitute);
            }

            RegCloseKey(hKey);
        }

        //
        // Form the name of the subkey that contains layout data.
        //
        wsprintf(
            Name,
            L"System\\CurrentControlSet\\Control\\Keyboard Layouts\\%s",
            IdFromRegistry
            );

        //
        // Open the key and retrieve the layout name.
        //
        l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,Name,0,KEY_QUERY_VALUE,&hKey);
        if(l == NO_ERROR) {

            d = sizeof(Name);
            l = RegQueryValueEx(hKey,L"Layout Text",NULL,&Type,(LPBYTE)Name,&d);
            if((l == NO_ERROR) && (Type != REG_SZ)) {
                l = ERROR_INVALID_DATA;
            }

            RegCloseKey(hKey);
        }
    }

    if(l != NO_ERROR) {
        LoadString(MyModuleHandle,IDS_UNKNOWN_PARENS,Name,sizeof(Name)/sizeof(WCHAR));
    }

    LoadString(
        MyModuleHandle,
        IDS_KBDLAYOUT_MSG,
        FormatString,
        sizeof(FormatString)/sizeof(WCHAR)
        );

    wsprintf(MessageText,FormatString,Name);

    SetDlgItemText(hdlg,IDT_KBD_LAYOUT,MessageText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\misc.c ===
#include "setupp.h"
#pragma hdrstop


//
// Safe boot strings
//

#define SAFEBOOT_OPTION_KEY  TEXT("System\\CurrentControlSet\\Control\\SafeBoot\\Option")
#define OPTION_VALUE         TEXT("OptionValue")

VOID
SetUpProductTypeName(
    OUT PWSTR  ProductTypeString,
    IN  UINT   BufferSizeChars
    )
{
    switch(ProductType) {
    case PRODUCT_WORKSTATION:
        lstrcpyn(ProductTypeString,L"WinNT",BufferSizeChars);
        break;
    case PRODUCT_SERVER_PRIMARY:
        lstrcpyn(ProductTypeString,L"LanmanNT",BufferSizeChars);
        break;
    case PRODUCT_SERVER_STANDALONE:
        lstrcpyn(ProductTypeString,L"ServerNT",BufferSizeChars);
        break;
    default:
        LoadString(MyModuleHandle,IDS_UNKNOWN,ProductTypeString,BufferSizeChars);
        break;
    }
}


HMODULE
MyLoadLibraryWithSignatureCheck(
    IN PWSTR ModuleName
    )
/*++

Routine Description:

    verifies the signature for a dll and if it's ok, then load the dll

Arguments:

    ModuleName - filename to be loaded.

Return Value:

    an HMODULE on success, else NULL

--*/

{
    WCHAR FullModuleName[MAX_PATH];
    PWSTR p;
    DWORD error;

    if (!GetFullPathName(ModuleName,MAX_PATH,FullModuleName,&p)) {
        //
        // couldn't get full path to file
        //
        SetupDebugPrint1( L"Setup: MyLoadLibraryWithSignatureCheck failed GetFullPathName, le = %d\n",
                          GetLastError() );
        return NULL;
    }

    error = pSetupVerifyFile(
               NULL,
               NULL,
               NULL,
               0,
               pSetupGetFileTitle(FullModuleName),
               FullModuleName,
               NULL,
               NULL,
               FALSE,
               NULL,
               NULL,
               NULL );

    if (NO_ERROR != error) {
        //
        // signing problem
        //
        SetupDebugPrint1( L"Setup: MyLoadLibraryWithSignatureCheck failed pSetupVerifyFile, le = %x\n",
                          error );
        SetLastError(error);
        return NULL;
    }

    return (LoadLibrary(FullModuleName));

}


UINT
MyGetDriveType(
    IN WCHAR Drive
    )
{
    WCHAR DriveNameNt[] = L"\\\\.\\?:";
    WCHAR DriveName[] = L"?:\\";
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    DriveName[0] = Drive;
    if((rc = GetDriveType(DriveName)) == DRIVE_REMOVABLE) {

        DriveNameNt[4] = Drive;

        hDisk = CreateFile(
                    DriveNameNt,
                    FILE_READ_ATTRIBUTES,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if(hDisk != INVALID_HANDLE_VALUE) {

            b = DeviceIoControl(
                    hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &MediaInfo,
                    sizeof(MediaInfo),
                    &DataSize,
                    NULL
                    );

            //
            // It's really a hard disk if the media type is removable.
            //
            if(b && (MediaInfo.MediaType == RemovableMedia)) {
                rc = DRIVE_FIXED;
            }

            CloseHandle(hDisk);
        }
    }

    return(rc);
}


BOOL
GetPartitionInfo(
    IN  WCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )
{
    WCHAR DriveName[] = L"\\\\.\\?:";
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    DriveName[4] = Drive;

    hDisk = CreateFile(
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    return(b);
}


BOOL
IsErrorLogEmpty (
    VOID
    )

/*++

Routine Description:

    Checks to see if the error log is empty.

Arguments:

    None.

Returns:

    TRUE if the error log size is zero.

--*/

{
    HANDLE ErrorLog;
    WCHAR LogName[MAX_PATH];
    DWORD Size = 0;

    if( GetWindowsDirectory (LogName, MAX_PATH) ) {
        pSetupConcatenatePaths (LogName, SETUPLOG_ERROR_FILENAME, MAX_PATH, NULL);

        ErrorLog = CreateFile (
            LogName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        if (ErrorLog != INVALID_HANDLE_VALUE) {
            Size = GetFileSize (ErrorLog, NULL);
            CloseHandle (ErrorLog);
        }
    }
    return Size == 0;
}


VOID
PumpMessageQueue(
    VOID
    )
{
    MSG msg;

    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

}


PVOID
InitSysSetupQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    PSYSSETUP_QUEUE_CONTEXT SysSetupContext;

    SysSetupContext = MyMalloc(sizeof(SYSSETUP_QUEUE_CONTEXT));

    if(SysSetupContext) {

        SysSetupContext->Skipped = FALSE;

        SysSetupContext->DefaultContext = SetupInitDefaultQueueCallbackEx(
            OwnerWindow,
            AlternateProgressWindow,
            ProgressMessage,
            Reserved1,
            Reserved2
            );
    }

    return SysSetupContext;
}


PVOID
InitSysSetupQueueCallback(
    IN HWND OwnerWindow
    )
{
    return(InitSysSetupQueueCallbackEx(OwnerWindow,NULL,0,0,NULL));
}


VOID
TermSysSetupQueueCallback(
    IN PVOID SysSetupContext
    )
{
    PSYSSETUP_QUEUE_CONTEXT Context = SysSetupContext;

    try {
        if(Context->DefaultContext) {
            SetupTermDefaultQueueCallback(Context->DefaultContext);
        }
        MyFree(Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}


#if 0
UINT
VersionCheckQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    PFILEPATHS  FilePaths = (PFILEPATHS)Param1;

    //
    // If we're being notified that a version mismatch was found,
    // indicate that the file shouldn't be copied.  Otherwise,
    // pass the notification on.
    //
    if((Notification & (SPFILENOTIFY_LANGMISMATCH |
                        SPFILENOTIFY_TARGETNEWER |
                        SPFILENOTIFY_TARGETEXISTS)) != 0) {

        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            , // MSG_LOG_VERSION_MISMATCH,    This message is no longer appropriate.
            FilePaths->Source,
            FilePaths->Target,
            NULL,NULL);

        return(0);
    }

    //
    // Want default processing.
    //
    return(SysSetupQueueCallback(Context,Notification,Param1,Param2));
}
#endif


UINT
SysSetupQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT                    Status;
    PSYSSETUP_QUEUE_CONTEXT SysSetupContext = Context;
    PFILEPATHS              FilePaths = (PFILEPATHS)Param1;
    PSOURCE_MEDIA           SourceMedia = (PSOURCE_MEDIA)Param1;
    REGISTRATION_CONTEXT RegistrationContext;


    //
    // If we're being notified that a file is missing and we're supposed
    // to skip missing files, then return skip. Otherwise pass it on
    // to the default callback routine.
    //
    if(( (Notification == SPFILENOTIFY_COPYERROR) || (Notification == SPFILENOTIFY_NEEDMEDIA) ) && SkipMissingFiles) {

        if((FilePaths->Win32Error == ERROR_FILE_NOT_FOUND)
        || (FilePaths->Win32Error == ERROR_PATH_NOT_FOUND)) {

        if(Notification == SPFILENOTIFY_COPYERROR)
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_COPY_ERROR,
                FilePaths->Source,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error,
                NULL,NULL);
        else
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NEEDMEDIA_SKIP,
                SourceMedia->SourceFile,
                SourceMedia->SourcePath,
                NULL,NULL);


            return(FILEOP_SKIP);
        }
    }

    if ((Notification == SPFILENOTIFY_COPYERROR
         || Notification == SPFILENOTIFY_RENAMEERROR
         || Notification == SPFILENOTIFY_DELETEERROR) &&
        (FilePaths->Win32Error == ERROR_DIRECTORY)) {
            WCHAR Buffer[MAX_PATH];
            PWSTR p;
            //
            // The target directory has been converted into a file by autochk.
            // just delete it -- we might be in trouble if the target directory was
            // really important, but it's worth trying
            //

            wcscpy( Buffer,FilePaths->Target);
            p = wcsrchr(Buffer,L'\\');
            if (p) {
                *p = (WCHAR)NULL;
            }
            if (FileExists(Buffer,NULL)) {
                DeleteFile( Buffer );
                SetupDebugPrint1(L"autochk turned directory %s into file, delete file and retry\n", Buffer);
                return(FILEOP_RETRY);
            }
    }

    //
    // If we're being notified that a version mismatch was found,
    // silently overwrite the file.  Otherwise, pass the notification on.
    //
    if((Notification & (SPFILENOTIFY_LANGMISMATCH |
                        SPFILENOTIFY_TARGETNEWER |
                        SPFILENOTIFY_TARGETEXISTS)) != 0) {

        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_VERSION_MISMATCH,
            FilePaths->Source,
            FilePaths->Target,
            NULL,NULL);

        return(FILEOP_DOIT);
    }


    //
    // Use default processing, then check for errors.
    //
    Status = SetupDefaultQueueCallback(
        SysSetupContext->DefaultContext,Notification,Param1,Param2);

    switch(Notification) {

    case SPFILENOTIFY_STARTQUEUE:
    case SPFILENOTIFY_STARTSUBQUEUE:
    case SPFILENOTIFY_ENDSUBQUEUE:
        //
        // Nothing is logged in this case.
        //
        break;

    case SPFILENOTIFY_ENDQUEUE:

        if(!Param1) {
            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_QUEUE_ABORT, NULL,
                SETUPLOG_USE_MESSAGEID,
                GetLastError(),
                NULL,NULL);
        }
        break;

    case SPFILENOTIFY_STARTRENAME:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDRENAME:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {

            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_RENAMED,
                FilePaths->Source,
                FilePaths->Target,
                NULL,NULL);

        } else {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_RENAME_ERROR,
                FilePaths->Source,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);
        }
        break;

    case SPFILENOTIFY_RENAMEERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_STARTDELETE:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDDELETE:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {

            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETED,
                FilePaths->Target,
                NULL,NULL);

        } else if(FilePaths->Win32Error == ERROR_FILE_NOT_FOUND ||
            FilePaths->Win32Error == ERROR_PATH_NOT_FOUND) {
            //
            // This failure is not important.
            //
            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETE_ERROR,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error,
                NULL,NULL);

        } else {
            //
            // Here we have an actual error.
            //
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETE_ERROR,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);
        }
        break;

    case SPFILENOTIFY_DELETEERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_STARTCOPY:
        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDCOPY:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {

            LogRepairInfo(
                FilePaths->Source,
                FilePaths->Target
                );

            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_COPIED,
                FilePaths->Source,
                FilePaths->Target,
                NULL,NULL);

            //
            // clear the file's readonly attribute that it may have gotten
            // from the cdrom.
            //
            SetFileAttributes(
                FilePaths->Target,
                GetFileAttributes(FilePaths->Target) & ~FILE_ATTRIBUTE_READONLY );

        } else {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_COPY_ERROR,
                FilePaths->Source,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);
        }
        break;

    case SPFILENOTIFY_COPYERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_NEEDMEDIA:

        if(Status == FILEOP_SKIP) {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NEEDMEDIA_SKIP,
                SourceMedia->SourceFile,
                SourceMedia->SourcePath,
                NULL,NULL);

            SysSetupContext->Skipped = TRUE;
        }

        break;

    case SPFILENOTIFY_STARTREGISTRATION:
    case SPFILENOTIFY_ENDREGISTRATION:
        RtlZeroMemory(&RegistrationContext,sizeof(RegistrationContext));
        RegistrationQueueCallback(
                        &RegistrationContext,
                        Notification,
                        Param1,
                        Param2);
        break;

    default:

        break;
    }

    return Status;
}


PSID
GetAdminAccountSid(
    )

/*++
===============================================================================
Routine Description:

    This routine gets the Adminstrator's SID

Arguments:

    None.

Return Value:

    TRUE - success.

    FALSE - failed.

===============================================================================
--*/
{
    BOOL b = TRUE;
    LSA_HANDLE        hPolicy;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    UCHAR SubAuthCount;
    DWORD sidlen;
    PSID psid = NULL;


    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if (!NT_SUCCESS(ntStatus)) {
        LsaClose(hPolicy);
        b = FALSE;
    }

    if( b ) {
        ntStatus = LsaQueryInformationPolicy( hPolicy,
                                              PolicyAccountDomainInformation,
                                              (PVOID *) &AccountDomainInfo );

        LsaClose( hPolicy );

        if (!NT_SUCCESS(ntStatus)) {
            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }
            b = FALSE;
        }
    }

    if( b ) {
        //
        // calculate the size of a new sid with one more SubAuthority
        //
        SubAuthCount = *(GetSidSubAuthorityCount ( AccountDomainInfo->DomainSid ));
        SubAuthCount++; // for admin
        sidlen = GetSidLengthRequired ( SubAuthCount );

        //
        // allocate and copy the new new sid from the Domain SID
        //
        psid = (PSID)malloc(sidlen);

        if( psid ) {

            memcpy(psid, AccountDomainInfo->DomainSid, GetLengthSid(AccountDomainInfo->DomainSid) );

            //
            // increment SubAuthority count and add Domain Admin RID
            //
            *(GetSidSubAuthorityCount( psid )) = SubAuthCount;
            *(GetSidSubAuthority( psid, SubAuthCount-1 )) = DOMAIN_USER_RID_ADMIN;

            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }
        }
    }

    return psid;
}


VOID
GetAdminAccountName(
    PWSTR AccountName
    )

/*++
===============================================================================
Routine Description:

    This routine sets the Adminstrator Password

Arguments:

    None.

Return Value:

    TRUE - success.

    FALSE - failed.

===============================================================================
--*/
{
    BOOL b = TRUE;
    LSA_HANDLE        hPolicy;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    UCHAR SubAuthCount;
    DWORD sidlen;
    PSID psid;
    WCHAR adminname[512];
    WCHAR domainname[512];
    DWORD adminlen=512;       // address of size account string
    DWORD domlen=512;       // address of size account string
    SID_NAME_USE sidtype;


    //
    // Initialize the administrator's account name.
    //
    LoadString(MyModuleHandle,IDS_ADMINISTRATOR,adminname,MAX_USERNAME+1);

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if (!NT_SUCCESS(ntStatus)) {
        LsaClose(hPolicy);
        b = FALSE;
    }

    if( b ) {
        ntStatus = LsaQueryInformationPolicy( hPolicy,
                                              PolicyAccountDomainInformation,
                                              (PVOID *) &AccountDomainInfo );

        LsaClose( hPolicy );

        if (!NT_SUCCESS(ntStatus)) {
            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }
            b = FALSE;
        }
    }

    if( b ) {
        //
        // calculate the size of a new sid with one more SubAuthority
        //
        SubAuthCount = *(GetSidSubAuthorityCount ( AccountDomainInfo->DomainSid ));
        SubAuthCount++; // for admin
        sidlen = GetSidLengthRequired ( SubAuthCount );

        //
        // allocate and copy the new new sid from the Domain SID
        //
        psid = (PSID)malloc(sidlen);
        if (psid) {
            memcpy(psid, AccountDomainInfo->DomainSid, GetLengthSid(AccountDomainInfo->DomainSid) );

            //
            // increment SubAuthority count and add Domain Admin RID
            //
            *(GetSidSubAuthorityCount( psid )) = SubAuthCount;
            *(GetSidSubAuthority( psid, SubAuthCount-1 )) = DOMAIN_USER_RID_ADMIN;

            if ( AccountDomainInfo != NULL ) {
                (VOID) LsaFreeMemory( AccountDomainInfo );
            }

            //
            // get the admin account name from the new SID
            //
            LookupAccountSid( NULL,
                              psid,
                              adminname,
                              &adminlen,
                              domainname,
                              &domlen,
                              &sidtype );
    }

    }

    lstrcpy( AccountName, adminname );

    if (psid) {
        free(psid);
    }
}


ULONG
GetBatteryTag (HANDLE DriverHandle)
{
    NTSTATUS        Status;
    IO_STATUS_BLOCK IOSB;
    ULONG           BatteryTag;

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_TAG,
            NULL,                   // input buffer
            0,
            &BatteryTag,            // output buffer
            sizeof (BatteryTag)
            );


    if (!NT_SUCCESS(Status)) {
        BatteryTag = BATTERY_TAG_INVALID;
        if (Status == STATUS_NO_SUCH_DEVICE) {
            SetupDebugPrint(L"(Battery is not physically present or is not connected)\n");
        } else {
            SetupDebugPrint1(L"Query Battery tag failed: Status = %x\n", Status);
        }

    }

    return BatteryTag;
}


BOOLEAN
GetBatteryInfo (
    HANDLE DriverHandle,
    ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    OUT PVOID Buffer,
    IN ULONG BufferLength
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IOSB;
    BATTERY_QUERY_INFORMATION   BInfo;

    memset (Buffer, 0, BufferLength);
    BInfo.BatteryTag = BatteryTag;
    BInfo.InformationLevel = Level;
    BInfo.AtRate = 0;                       // This is needed for reading estimated time correctly.

    Status = NtDeviceIoControlFile(
            DriverHandle,
            (HANDLE) NULL,          // event
            (PIO_APC_ROUTINE) NULL,
            (PVOID) NULL,
            &IOSB,
            IOCTL_BATTERY_QUERY_INFORMATION,
            &BInfo,                 // input buffer
            sizeof (BInfo),
            Buffer,                 // output buffer
            BufferLength
            );


    if (!NT_SUCCESS(Status)) {

        if ((Status == STATUS_INVALID_PARAMETER)        ||
            (Status == STATUS_INVALID_DEVICE_REQUEST)   ||
            (Status == STATUS_NOT_SUPPORTED)) {

            SetupDebugPrint2(L"Not Supported by Battery, Level %x, Status: %x\n", Level, Status);
        } else {
            SetupDebugPrint2(L"Query failed: Level %x, Status = %x\n", Level, Status);
        }

        return FALSE;
    }

    return TRUE;
}




BOOLEAN
IsLongTermBattery(
    PCWSTR  BatteryName
    )
{
    HANDLE                  driverHandle;
    ULONG                   batteryTag;
    BATTERY_INFORMATION     BInfo;
    BOOLEAN                 Ret;


    driverHandle = CreateFile (BatteryName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    if (INVALID_HANDLE_VALUE == driverHandle) {

        SetupDebugPrint2(L"Error opening %ws: GetLastError = 0x%08lx \n",
                BatteryName, GetLastError());
        return FALSE;
    }

    batteryTag = GetBatteryTag (driverHandle);
    if (batteryTag == BATTERY_TAG_INVALID) {
        NtClose(driverHandle);
        return FALSE;
    }

    if (GetBatteryInfo (driverHandle, batteryTag, BatteryInformation, &BInfo, sizeof(BInfo))) {

        Ret = !(BInfo.Capabilities & BATTERY_IS_SHORT_TERM);

    } else {

        Ret = FALSE;
    }

    NtClose(driverHandle);
    return(Ret);
}


BOOLEAN
IsLaptop(
    VOID
    )
{
    HDEVINFO                            devInfo;
    SP_INTERFACE_DEVICE_DATA            interfaceDevData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    funcClassDevData;
    UCHAR                               index;
    DWORD                               reqSize;
    BOOLEAN                             b = FALSE;


    devInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVICE_BATTERY, NULL, NULL,
                                   DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
    if (devInfo == INVALID_HANDLE_VALUE) {
        SetupDebugPrint1(L"SetupDiGetClassDevs on GUID_DEVICE_BATTERY, failed: %d\n", GetLastError());
        return FALSE;
    }
    interfaceDevData.cbSize = sizeof(SP_DEVINFO_DATA);

    index = 0;
    while(1) {
        if (SetupDiEnumInterfaceDevice(devInfo,
                                       0,
                                       (LPGUID)&GUID_DEVICE_BATTERY,
                                       index,
                                       &interfaceDevData)) {

            // Get the required size of the function class device data.
            SetupDiGetInterfaceDeviceDetail(devInfo,
                                            &interfaceDevData,
                                            NULL,
                                            0,
                                            &reqSize,
                                            NULL);

            funcClassDevData = MyMalloc(reqSize);
            if (funcClassDevData != NULL) {
                funcClassDevData->cbSize =
                    sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

                if (SetupDiGetInterfaceDeviceDetail(devInfo,
                                                    &interfaceDevData,
                                                    funcClassDevData,
                                                    reqSize,
                                                    &reqSize,
                                                    NULL)) {

                    b = IsLongTermBattery(funcClassDevData->DevicePath);
                }
                else {
                    SetupDebugPrint1(L"SetupDiGetInterfaceDeviceDetail, failed: %d\n", GetLastError());
                }

                MyFree(funcClassDevData);
                if (b) {
                    break;
                }
            }
        } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                break;
            }
            else {
                SetupDebugPrint1(L"SetupDiEnumInterfaceDevice, failed: %d\n", GetLastError());
            }
        }
        index++;
    }

    SetupDiDestroyDeviceInfoList(devInfo);
    return b;
}


VOID
SaveInstallInfoIntoEventLog(
    VOID
    )
/*++
Routine Description:

    This routine will store information into the event log regarding
    - if we upgraded or cleaninstall
    - what build did the install originate from
    - what build are we?
    - were there errors during Setup

Arguments:

    None.

Return Value:

    None.

--*/
{
#define     AnswerBufLen (64)
WCHAR       AnswerFile[MAX_PATH];
WCHAR       Answer[AnswerBufLen];
WCHAR       OrigVersion[AnswerBufLen];
WCHAR       NewVersion[AnswerBufLen];
HANDLE      hEventSrc;
PCWSTR      MyArgs[2];
PCWSTR      ErrorArgs[1];
DWORD       MessageID;
WORD        MyArgCount;




    //
    // Go get the starting information out of $winnt$.sif
    //
    OrigVersion[0] = L'0';
    OrigVersion[1] = L'\0';
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);
    if( GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_WIN32_VER,
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {

        if( lstrcmp( pwNull, Answer ) ) {

            wsprintf( OrigVersion, L"%d", HIWORD(wcstoul( Answer, NULL, 16 )) );
        }
    }
    MyArgs[1] = OrigVersion;



    //
    // Get the new version information.
    //
    wsprintf( NewVersion, L"%d", HIWORD(GetVersion()) );
    MyArgs[0] = NewVersion;



    //
    // See if we're an NT upgrade?
    //
    MessageID = 0;
    if( GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_NTUPGRADE,
                                 pwNo,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( !lstrcmp( pwYes, Answer ) ) {

            MessageID = MSG_NTUPGRADE_SUCCESS;
            MyArgCount = 2;
        }
    }



    //
    // See if we're a Win9X upgrade.
    //
    if( (!MessageID) &&
        GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_WIN95UPGRADE,
                                 pwNo,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( !lstrcmp( pwYes, Answer ) ) {

            MessageID = MSG_WIN9XUPGRADE_SUCCESS;
            MyArgCount = 2;
        }
    }



    //
    // Clean install.
    //
    if( (!MessageID) ) {
        MessageID = MSG_CLEANINSTALL_SUCCESS;
        MyArgCount = 1;
    }


    //
    // If this is anything but an NT upgrade, then
    // we need to go try and manually start the eventlog
    // service.
    //
    if( MessageID != MSG_NTUPGRADE_SUCCESS ) {
        SetupStartService( L"Eventlog", TRUE );
    }



    //
    // Get a handle to the eventlog.
    //
    hEventSrc = RegisterEventSource( NULL, L"Setup" );

    if( (hEventSrc == NULL) ||
        (hEventSrc == INVALID_HANDLE_VALUE) ) {

        //
        // Fail quietly.
        //
        return;
    }


    //
    // Log event message for failure of SceSetupRootSecurity
    //
    if( !bSceSetupRootSecurityComplete) {
        ErrorArgs[0] = L"%windir%";
        ReportEvent( hEventSrc,
                 EVENTLOG_WARNING_TYPE,
                 0,
                 MSG_LOG_SCE_SETUPROOT_ERROR,
                 NULL,
                 1,
                 0,
                 ErrorArgs,
                 NULL );
    }

    //
    // Log event if there were errors during Setup.
    //
    if ( !IsErrorLogEmpty() ) {
        ReportEvent( hEventSrc,
                     EVENTLOG_ERROR_TYPE,
                     0,
                     MSG_NONFATAL_ERRORS,
                     NULL,
                     0,
                     0,
                     NULL,
                     NULL );
    }

    //
    // Build the event log message.
    //
    ReportEvent( hEventSrc,
                 EVENTLOG_INFORMATION_TYPE,
                 0,
                 MessageID,
                 NULL,
                 MyArgCount,
                 0,
                 MyArgs,
                 NULL );


    DeregisterEventSource( hEventSrc );


}

BOOL
IsEncryptedAdminPasswordPresent( VOID )
{

    #define     MD4HASHLEN ((2*(LM_OWF_PASSWORD_LENGTH + NT_OWF_PASSWORD_LENGTH))+2)
    WCHAR       AnswerFile[MAX_PATH+2];
    WCHAR       Answer[MD4HASHLEN];

    //
    // Get EncryptedAdminPassword from the Answer file
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    if( GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                 WINNT_US_ENCRYPTEDADMINPASS,
                                 pwNull,
                                 Answer,
                                 MD4HASHLEN,
                                 AnswerFile ) ) {

        //
        // See if we have an encrypted password.  Now interpret the Admin Password differently
        //

        if( !lstrcmpi( WINNT_A_YES, Answer ) )
            return TRUE;

    }

    return FALSE;

}


BOOL
ProcessEncryptedAdminPassword( PCWSTR AdminAccountName )
/*++

Routine Description:

    This routine looks in the unattend file to see if there is an encrypted password and if present
    sets the admin password to that.

Arguments:

    AdminAccountName - Name of the administrator account whose password you want to set.


Returns:

    Returns TRUE if it succeeds, FALSE on failure

--*/

{

    #define MD4HASHLEN ((2*(LM_OWF_PASSWORD_LENGTH + NT_OWF_PASSWORD_LENGTH))+2)
    WCHAR       AnswerFile[MAX_PATH+2];
    WCHAR       Answer[MD4HASHLEN];
    DWORD       Err = NO_ERROR;
    WCHAR       adminName[MAX_USERNAME+1];
    BOOLEAN     ret = FALSE;

    //
    // Pickup the answer file.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);


    //
    // we look for the following keys in the [GUIUnattended] section:
    //

    //
    // EncryptedAdminPassword    = Yes | No
    // AdminPassword             = <MD4 Hash value>
    //


    if( IsEncryptedAdminPasswordPresent() )       {


        //Fetch the Encrypted Admin Password

        if( GetPrivateProfileString( WINNT_GUIUNATTENDED,
                             WINNT_US_ADMINPASS,
                             pwNull,
                             Answer,
                             MD4HASHLEN,
                             AnswerFile ) == (MD4HASHLEN-2) ) {

            Err = SetLocalUserEncryptedPassword( AdminAccountName, L"", FALSE, Answer, TRUE );

            if( Err == ERROR_SUCCESS) {
                ret = TRUE;
            }else{

                //Log the error - MSG_LOG_CHANGING_ENCRYPT_PW_FAIL

                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_CHANGING_ENCRYPT_PW_FAIL,
                    AdminAccountName, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_PARAM_RETURNED_WINERR,
                    L"SetLocalUserEncryptedPassword",
                    Err,
                    AdminAccountName,
                    NULL,NULL);

            }


        }else{

            //Log that we had a bad encrypted password

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_BAD_UNATTEND_PARAM,
                WINNT_US_ADMINPASS,
                WINNT_GUIUNATTENDED,
                NULL,NULL);

        }

    }

    return ret;


}


BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}



BOOL IsSafeMode(
    VOID
    )
{
	LONG lStatus;
	HKEY hk;
	DWORD dwVal;
	DWORD dwType;
	DWORD dwSize;

	lStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE, SAFEBOOT_OPTION_KEY, 0, KEY_QUERY_VALUE, &hk);

	if(lStatus != ERROR_SUCCESS)
		return FALSE;

	dwSize = sizeof(dwVal);
	lStatus = RegQueryValueExW(hk, OPTION_VALUE, NULL, &dwType, (LPBYTE) &dwVal, &dwSize);
	RegCloseKey(hk);
	return ERROR_SUCCESS == lStatus && REG_DWORD == dwType && dwVal != 0;
}


void
SetupCrashRecovery(
    VOID
    )
/*
    Setup the Crash Recovery stuff. This is implemented as RTL APIS
    This call sets up the tracking file etc.  Crash Recovery tracks boot and 
    shutdown and in the event of failures in either it will by default pick the 
    right advanced boot option.
    
*/
{

    HANDLE BootStatusData;
    NTSTATUS Status;
    BOOLEAN Enabled;
    UCHAR Timeout = 30; //default = 30 sec
    WCHAR Buffer[10];
    PSTR AnsiBuffer;
    int p = 0;

    //
    // We enable the feature for Pro and Per. On Server SKUs
    // we create the file but don't enable the feature by default.
    //


    if( ProductType == PRODUCT_WORKSTATION ){
        Enabled = TRUE;
    }else{
        Enabled = FALSE;
    }

    //
    // For the fresh install case create the boot status data file
    // and setup the default settings. In the case of an upgrade
    // we will set the previous values if we find them in $winnt$.inf 
    // as textmode setup would have stored this away for us. If not we 
    // proceed as if we were fresh.
    //


    if( Upgrade ){

        //Look for settings in $winnt$.inf

        if( SpSetupLoadParameter( WINNT_D_CRASHRECOVERYENABLED, Buffer, sizeof(Buffer)/sizeof(WCHAR))){
            if (_wcsicmp(Buffer, L"NO") == 0) {
                Enabled = FALSE;
            }

            //
            //We do the below check also as we might have to migrate settings on server SKUs
            //that have this enabled. By default they are disabled.
            //

            if (_wcsicmp(Buffer, L"YES") == 0) {
                Enabled = TRUE;
            }

        }
    }



    Status = RtlLockBootStatusData( &BootStatusData );

    // This is the first time or there was no file. Create it

    if( !NT_SUCCESS( Status )){
        Status = RtlCreateBootStatusDataFile();

        if( !NT_SUCCESS( Status )){
            SetuplogError(
                LogSevWarning,
                L"Setup: (non-critical error) Could not lock the Crash Recovery status file - (%1!x!)\n",
                0,Status,NULL,NULL);
            return;
        }

        //Lock the file

        Status = RtlLockBootStatusData( &BootStatusData );
        if( !NT_SUCCESS( Status )){
            SetupDebugPrint1( L"Setup: (non-critical error) Could not lock the Crash Recovery status file - (%x)\n", Status );
            return;
        }

        Status = RtlGetSetBootStatusData(
                    BootStatusData,
                    FALSE,
                    RtlBsdItemAabTimeout,
                    &Timeout,
                    sizeof(UCHAR),
                    NULL
                    );
    
        if( !NT_SUCCESS( Status )){
            SetupDebugPrint1( L"Setup: (non-critical error) Could not set the Crash Recovery timeout - (%x)\n", Status );
            goto SCR_done;
        }


    }

    Status = RtlGetSetBootStatusData(
                BootStatusData,
                FALSE,
                RtlBsdItemAabEnabled,
                &Enabled,
                sizeof(BOOLEAN),
                NULL
                );

    if( !NT_SUCCESS( Status )){
        SetupDebugPrint1( L"Setup: (non-critical error) Could not enable Crash Recovery - (%x)\n", Status );
    }

SCR_done:

    RtlUnlockBootStatusData( BootStatusData );
    
    return;

}

DWORD
BuildFileListFromDir(
    IN PCTSTR PathBase,
    IN PCTSTR Directory OPTIONAL,
    IN DWORD MustHaveAttrs OPTIONAL,
    IN DWORD MustNotHaveAttrs OPTIONAL,
    IN PFN_BUILD_FILE_LIST_CALLBACK Callback OPTIONAL,
    OUT PLIST_ENTRY ListHead
    )
/*++

Routine Description:

	Builds a linked list containing the names (without path) of files present in a specified directory.
    The files must meed a set of conditions as specified by the arguments.

Arguments:

	PathBase -          The path to the directory to enumerate files in.
	Directory -         If not NULL or empty, it is appended to PathBase to form a complete path to the directory.
	MustHaveAttrs -     A set of attributes a file must have to be included on the list.
	MustNotHaveAttrs -  A set of attributes a file must not have to be included on the list.
	Callback -          If not NULL, this function will be called and the file will be included on the list only
                        if it returns TRUE.
	ListHead -          Pointer to the head of the list to be filled in.

Return value:

    ERROR_SUCCESS on success, otherwise a Win32 error code. The list may not be empty even if the function fails; the caller
    must always empty the list.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    PTSTR szPath = NULL;
    WIN32_FIND_DATA fd;

    if(ListHead != NULL) {
        InitializeListHead(ListHead);
    }

    if(NULL == PathBase || 0 == PathBase[0] || NULL == ListHead) {
        Error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    szPath = (PTSTR) MyMalloc(MAX_PATH * sizeof(TCHAR));

    if(NULL == szPath) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    _tcsncpy(szPath, PathBase, MAX_PATH - 1);
    szPath[MAX_PATH - 1] = 0;

    if(Directory != NULL && Directory[0] != 0) {
        pSetupConcatenatePaths(szPath, Directory, MAX_PATH, NULL);
    }

    if(!pSetupConcatenatePaths(szPath, TEXT("\\*"), MAX_PATH, NULL)) {
        Error = ERROR_BAD_PATHNAME;
        goto exit;
    }

    hFind = FindFirstFile(szPath, &fd);

    if(INVALID_HANDLE_VALUE == hFind) {
        Error = GetLastError();

        if(ERROR_FILE_NOT_FOUND == Error || ERROR_PATH_NOT_FOUND == Error) {
            Error = ERROR_SUCCESS;
        }

        goto exit;
    }

    //
    // We might need the dir later
    //
    (_tcsrchr(szPath, L'\\'))[0] = 0;

    do {
        if(_tcscmp(fd.cFileName, _T(".")) != 0 && 
            _tcscmp(fd.cFileName, _T("..")) != 0 &&
            (MustHaveAttrs & fd.dwFileAttributes) == MustHaveAttrs &&
            0 == (MustNotHaveAttrs & fd.dwFileAttributes) &&
            (NULL == Callback || Callback(szPath, fd.cFileName))) {

            ULONG uLen;
            PSTRING_LIST_ENTRY pElem = (PSTRING_LIST_ENTRY) MyMalloc(sizeof(STRING_LIST_ENTRY));

            if(NULL == pElem) {
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            uLen = (_tcslen(fd.cFileName) + 1) * sizeof(TCHAR);
            pElem->String = (PTSTR) MyMalloc(uLen);

            if(NULL == pElem->String) {
                MyFree(pElem);
                Error = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            RtlCopyMemory(pElem->String, fd.cFileName, uLen);
            InsertTailList(ListHead, &pElem->Entry);
        }
    }
    while(FindNextFile(hFind, &fd));

    Error = GetLastError();

    if(ERROR_NO_MORE_FILES == Error) {
        Error = ERROR_SUCCESS;
    }

exit:
    if(hFind != INVALID_HANDLE_VALUE) {
        FindClose(hFind);
    }

    if(szPath != NULL) {
        MyFree(szPath);
    }

    return Error;
}

PSTRING_LIST_ENTRY
SearchStringInList(
    IN PLIST_ENTRY ListHead,
    IN PCTSTR String,
    BOOL CaseSensitive
    )
/*++

Routine Description:

	This routine searches for a string in a string list. The string can be NULL or empty, in which
    case the function returns the first entry in the list with a NULL or empty string.

Arguments:

	ListHead -      Pointer to the head of the list to be searched.
	String -        Specifies the string to search for.
	CaseSensitive - If TRUE, the search will be case sensitive.

Return value:

	A pointer to the first entry containing the string, if found, or NULL otherwise.

--*/
{
    if(ListHead != NULL)
    {
        PLIST_ENTRY pEntry;
        ULONG uLen1 = (String != NULL ? _tcslen(String) : 0);

        for(pEntry = ListHead->Flink; pEntry != ListHead; pEntry = pEntry->Flink) {
            PSTRING_LIST_ENTRY pStringEntry;
            ULONG uLen2;
            pStringEntry = CONTAINING_RECORD(pEntry, STRING_LIST_ENTRY, Entry);
            uLen2 = (pStringEntry->String != NULL ? _tcslen(pStringEntry->String) : 0);

            if(uLen1 == uLen2) {
                if(0 == uLen1 || 0 == (CaseSensitive ? _tcscmp : _tcsicmp)(String, pStringEntry->String)) {
                    return pStringEntry;
                }
            }
        }
    }

    return NULL;
}

DWORD
LookupCatalogAttribute(
    IN PCWSTR CatalogName,
    IN PCWSTR Directory OPTIONAL,
    IN PCWSTR AttributeName OPTIONAL,
    IN PCWSTR AttributeValue OPTIONAL,
    PBOOL Found
    )
/*++

Routine Description:

	This function searches if a catalog has the specified attribute with the specified value.

Arguments:

	CatalogName -       Name of the catalog to search. A path can be specified.
	Directory -         If specified, it is prepended to CatalogName to form the path to the catalog.
	AttributeName -     See AttributeValue.
	AttributeValue -    If AttributeName and AttributeValue are not specified, the catalog meets the condition.
                        If AttributeName is specified and AttributeValue isn't, the catalog meets the condition if
                        it contains an attribute with AttributeName name and any value. If AttributeName is not
                        specified and AttributeValue is, the catalog meets the condition if it contains an attribute 
                        with AttributeValue value and any name. If both AttributeName and AttributeValue are
                        specified, the catalog meets the condition if it contains an attribute with AttributeName name 
                        and AttributeValue value.
	Found -             Pointer to a variable that receives TRUE if the catalog meets the condition, or FALSE otherwise.

Return value:

	ERROR_SUCCESS if successful, otherwise a Win32 error code.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    HANDLE hCat = INVALID_HANDLE_VALUE;
    PWSTR szCatPath = NULL;
    CRYPTCATATTRIBUTE* pAttr;

    if(Found != NULL) {
        *Found = FALSE;
    }

    if(NULL == CatalogName || 0 == CatalogName[0] || NULL == Found) {
        Error = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if(Directory != NULL && Directory[0] != 0) {
        szCatPath = MyMalloc(MAX_PATH * sizeof(WCHAR));

        if(NULL == szCatPath) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        _tcsncpy(szCatPath, Directory, MAX_PATH - 1);
        szCatPath[MAX_PATH - 1] = 0;
        pSetupConcatenatePaths(szCatPath, CatalogName, MAX_PATH, NULL);
        CatalogName = szCatPath;
    }

    //
    // This is easier to test
    //
    if(AttributeName != NULL && 0 == AttributeName[0]) {
        AttributeName = NULL;
    }

    if(AttributeValue != NULL && 0 == AttributeValue[0]) {
        AttributeValue = NULL;
    }

    if(NULL == AttributeName && NULL == AttributeValue) {
        //
        // If attribute name and value are not specified, any catalog is a match
        //
        *Found = TRUE;
        goto exit;
    }

    hCat = CryptCATOpen((PWSTR) CatalogName, CRYPTCAT_OPEN_EXISTING, 0, 0, 0);

    if(INVALID_HANDLE_VALUE == hCat) {
        Error = GetLastError();
        goto exit;
    }

    pAttr = CryptCATEnumerateCatAttr(hCat, NULL);

    while(pAttr != NULL) {
        *Found = (NULL == AttributeName || 0 == _wcsicmp(AttributeName, pAttr->pwszReferenceTag)) && 
            (NULL == AttributeValue || 0 == _wcsicmp(AttributeName, (PCWSTR) pAttr->pbValue));

        if(*Found) {
            goto exit;
        }

        pAttr = CryptCATEnumerateCatAttr(hCat, pAttr);
    }

    Error = GetLastError();

    if(CRYPT_E_NOT_FOUND == Error) {
        Error = ERROR_SUCCESS;
    }

exit:
    if(szCatPath != NULL) {
        MyFree(szCatPath);
    }

    if(hCat != INVALID_HANDLE_VALUE) {
        CryptCATClose(hCat);
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\names.c ===
#include "setupp.h"
#pragma hdrstop

//
// List of characters that are not legal in netnames.
//
PCWSTR IllegalNetNameChars = L"\"/\\[]:|<>+=;,?*";

//
// Computer name.
//
WCHAR ComputerName[DNS_MAX_LABEL_LENGTH+1];
WCHAR Win32ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
BOOL IsNameTruncated;
BOOL IsNameNonRfc;

//
// Copy disincentive name/organization strings.
//
WCHAR NameOrgName[MAX_NAMEORG_NAME+1];
WCHAR NameOrgOrg[MAX_NAMEORG_ORG+1];

#ifdef DOLOCALUSER
//
// User name and password
//
WCHAR UserName[MAX_USERNAME+1];
WCHAR UserPassword[MAX_PASSWORD+1];
BOOL CreateUserAccount = FALSE;
#endif // def DOLOCALUSER

//
// Administrator password.
//
WCHAR   CurrentAdminPassword[MAX_PASSWORD+1];
WCHAR   AdminPassword[MAX_PASSWORD+1];
BOOL    EncryptedAdminPasswordSet = FALSE;
BOOL    DontChangeAdminPassword = FALSE;



VOID
GenerateName(
    OUT PWSTR  GeneratedString,
    IN  DWORD  DesiredStrLen
    )
{
static DWORD Seed = 98725757;
static PCWSTR UsableChars = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

//
// How many characters will come from the org/name string.
//
DWORD   BaseLength = 8;
DWORD   i,j;
DWORD   UsableCount;

    if( DesiredStrLen < BaseLength ) {
        BaseLength = DesiredStrLen - 1;
    }


    if( NameOrgOrg[0] ) {
        wcscpy( GeneratedString, NameOrgOrg );
    } else if( NameOrgName[0] ) {
        wcscpy( GeneratedString, NameOrgName );
    } else {
        wcscpy( GeneratedString, TEXT("X") );
        for( i = 1; i < BaseLength; i++ ) {
            wcscat( GeneratedString, TEXT("X") );
        }
    }

    //
    // Get him upper-case for our filter...
    //
    CharUpper(GeneratedString);

    //
    // Now we want to put a '-' at the end
    // of our GeneratedString.  We'd like it to
    // be placed in the BASE_LENGTH character, but
    // the string may be shorter than that, or may
    // even have a ' ' in it.  Figure out where to
    // put the '-' now.
    //
    for( i = 0; i <= BaseLength; i++ ) {

        //
        // Check for a short string.
        //
        if( (GeneratedString[i] == 0   ) ||
            (GeneratedString[i] == L' ') ||
            (!wcschr(UsableChars, GeneratedString[i])) ||
            (i == BaseLength      )
          ) {
            GeneratedString[i] = L'-';
            GeneratedString[i+1] = 0;
            break;
        }
    }

    //
    // Special case the scenario where we had no usable
    // characters.
    //
    if( GeneratedString[0] == L'-' ) {
        GeneratedString[0] = 0;
    }

    UsableCount = lstrlen(UsableChars);
    Seed ^= GetCurrentTime();
    srand( Seed );

    j = lstrlen( GeneratedString );
    for( i = j; i < DesiredStrLen; i++ ) {
        GeneratedString[i] = UsableChars[rand() % UsableCount];
    }
    GeneratedString[i] = 0;

    //
    // In the normal case, the edit control in the wizard page
    // has the ES_UPPER bit set. In the normal unattend case
    // there is code in unattend.txt that uppercases the name.
    // But if we get to generating the name then then the text
    // in unattend.txt was * and we thus never had any text in
    // the edit control or unattend.txt to be uppercased.
    //
    CharUpper(GeneratedString);
}


BOOL
ContainsDot(
    IN PCWSTR NameToCheck
    )

/*++

Routine Description:

    Determine whether a given name contains a '.'

Arguments:

    NameToCheck - supplies name to be checked.

Return Value:

    TRUE if the name contains a '.'; FALSE if not.

--*/

{
    UINT Length,u;

    if (!NameToCheck)
        return FALSE;

    Length = lstrlen(NameToCheck);

    for (u = 0; u < Length; u++) {
         if (NameToCheck[u] == L'.')
             return TRUE;
    }

    return FALSE;
}


BOOL
IsNetNameValid(
    IN PCWSTR NameToCheck,
    IN BOOL AlphaNumericOnly
    )

/*++

Routine Description:

    Determine whether a given name is valid as a netname, such as
    a computer name.

Arguments:

    NameToCheck - supplies name to be checked.

Return Value:

    TRUE if the name is valid; FALSE if not.

--*/

{
    UINT Length,u;

    Length = lstrlen(NameToCheck);

    //
    // Want at least one character.
    //
    if(!Length) {
        return(FALSE);
    }

    //
    // Leading/trailing spaces are invalid.
    //
    if((NameToCheck[0] == L' ') || (NameToCheck[Length-1] == L' ')) {
        return(FALSE);
    }

    //
    // Control chars are invalid, as are characters in the illegal chars list.
    //
    for(u=0; u<Length; u++) {
        if (AlphaNumericOnly) {
            if (NameToCheck[u] == L'-' || NameToCheck[u] == L'_') {
                continue;
            }
            if (!iswalnum(NameToCheck[u])) {
                return(FALSE);
            }
        } else {
            if((NameToCheck[u] < L' ') || wcschr(IllegalNetNameChars,NameToCheck[u])) {
                return(FALSE);
            }
        }
    }

    //
    // We got here, name is ok.
    //
    return(TRUE);
}

BOOL SetIMEOpenStatus(
    IN HWND   hDlg,
    IN BOOL   bSetActive)
{
    typedef HIMC (WINAPI* PFN_IMMGETCONTEXT)(HWND);
    typedef BOOL (WINAPI* PFN_IMMSETOPENSTATUS)(HIMC,BOOL);
    typedef BOOL (WINAPI* PFN_IMMGETOPENSTATUS)(HIMC);
    typedef BOOL (WINAPI* PFN_IMMRELEASECONTEXT)(HWND,HIMC);

    PFN_IMMGETCONTEXT     PFN_ImmGetContext;
    PFN_IMMSETOPENSTATUS  PFN_ImmSetOpenStatus;
    PFN_IMMGETOPENSTATUS  PFN_ImmGetOpenStatus;
    PFN_IMMRELEASECONTEXT PFN_ImmReleaseContext;

    HIMC    hIMC;
    HKL     hKL;
    HMODULE hImmDll;
    static BOOL bImeEnable=TRUE;

    hKL = GetKeyboardLayout(0);

    if ((HIWORD(HandleToUlong(hKL)) & 0xF000) != 0xE000) {
        //
        // not an IME, do nothing !
        //
        return TRUE;
    }

    hImmDll = GetModuleHandle(TEXT("IMM32.DLL"));

    if (hImmDll == NULL) {
        //
        // weird case, if the kbd layout is an IME, then
        // Imm32.dll should have already been loaded into process.
        //
        return FALSE;
    }


    PFN_ImmGetContext = (PFN_IMMGETCONTEXT) GetProcAddress(hImmDll,"ImmGetContext");
    if (PFN_ImmGetContext == NULL) {
        return FALSE;
    }

    PFN_ImmReleaseContext = (PFN_IMMRELEASECONTEXT) GetProcAddress(hImmDll,"ImmReleaseContext");
    if (PFN_ImmReleaseContext == NULL) {
        return FALSE;
    }


    PFN_ImmSetOpenStatus = (PFN_IMMSETOPENSTATUS) GetProcAddress(hImmDll,"ImmSetOpenStatus");
    if (PFN_ImmSetOpenStatus == NULL) {
        return FALSE;
    }

    PFN_ImmGetOpenStatus = (PFN_IMMGETOPENSTATUS) GetProcAddress(hImmDll,"ImmGetOpenStatus");
    if (PFN_ImmGetOpenStatus == NULL) {
        return FALSE;
    }

    //
    // Get Current Input Context.
    //
    hIMC = PFN_ImmGetContext(hDlg);
    if (hIMC == NULL) {
        return FALSE;
    }

    if (bSetActive) {
        PFN_ImmSetOpenStatus(hIMC,bImeEnable);
    }
    else {
        //
        // Save Current Status.
        //
        bImeEnable = PFN_ImmGetOpenStatus(hIMC);
        //
        // Close IME.
        //
        PFN_ImmSetOpenStatus(hIMC,FALSE);
    }

    PFN_ImmReleaseContext(hDlg,hIMC);

    return TRUE;
}


// returns TRUE if the name is valid, FALSE if it is not
BOOL ValidateNameOrgName (
      WCHAR* pszName
	  )
{
    WCHAR adminName[MAX_USERNAME+1];
    WCHAR guestName[MAX_USERNAME+1];

    LoadString(MyModuleHandle,IDS_ADMINISTRATOR,adminName,MAX_USERNAME+1);
    LoadString(MyModuleHandle,IDS_GUEST,guestName,MAX_USERNAME+1);

	if ( pszName == NULL )
		return FALSE;

	if(pszName[0] == 0)
		return FALSE;

    if(lstrcmpi(pszName,adminName) == 0 )
		return FALSE;

	if ( lstrcmpi(pszName,guestName) == 0 )
		return FALSE;

	return TRUE;

}




INT_PTR
CALLBACK
NameOrgDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    NMHDR *NotifyParams;

    switch(msg) {

    case WM_INITDIALOG: {

        //
        // Limit text fields to maximum lengths
        //

        SendDlgItemMessage(hdlg,IDT_NAME,EM_LIMITTEXT,MAX_NAMEORG_NAME,0);
        SendDlgItemMessage(hdlg,IDT_ORGANIZATION,EM_LIMITTEXT,MAX_NAMEORG_ORG,0);

        //
        // Set Initial Values
        //

        SetDlgItemText(hdlg,IDT_NAME,NameOrgName);
        SetDlgItemText(hdlg,IDT_ORGANIZATION,NameOrgOrg);

        break;
    }
    case WM_IAMVISIBLE:
        //
        // If an error occured during out INIT phase, show the box to the
        // user so that they know there is a problem
        //
        MessageBoxFromMessage(hdlg,MSG_NO_NAMEORG_NAME,NULL,IDS_ERROR,
            MB_OK | MB_ICONSTOP);
        SetFocus(GetDlgItem(hdlg,IDT_NAME));
        break;
    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE) {
            if(LOWORD(wParam) == IDT_ORGANIZATION) {
                GetDlgItemText( hdlg, IDT_ORGANIZATION, NameOrgOrg, MAX_NAMEORG_ORG+1);
#ifdef DOLOCALUSER
            } else if(LOWORD(wParam) == IDT_NAME) {
                GetDlgItemText( hdlg, IDT_NAME, NameOrgName, MAX_NAMEORG_NAME+1);
#endif
            }
        }
        break;


    case WMX_VALIDATE:
        //
        // lParam == 0 for no UI, or 1 for UI
        // Return 1 for success, -1 for error.
        //

        GetDlgItemText(hdlg,IDT_ORGANIZATION,NameOrgOrg,MAX_NAMEORG_ORG+1);
        GetDlgItemText(hdlg,IDT_NAME,NameOrgName,MAX_NAMEORG_NAME+1);

		// JMH - NameOrgName cannot be "Administrator", "Guest" or "" (blank).

        if(ValidateNameOrgName(NameOrgName) == FALSE) {
            //
            // Skip UI?
            //

            if (!lParam) {
                return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
            }

            //
            // Tell user he must at least enter a name, and
            // don't allow next page to be activated.
            //
            if (Unattended) {
                UnattendErrorDlg(hdlg,IDD_NAMEORG);
            } // if
            MessageBoxFromMessage(hdlg,MSG_NO_NAMEORG_NAME,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
            SetFocus(GetDlgItem(hdlg,IDT_NAME));

            return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
        }

        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(503);
            BEGIN_SECTION(L"Personalize Your Software Page");
            SetWizardButtons(hdlg,WizPageNameOrg);

            if (Unattended) {
                if (!UnattendSetActiveDlg(hdlg,IDD_NAMEORG)) {
                    break;
                }
            }
            // Page becomes active, make page visible.
            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
            //
            // Set focus on the name edit control.
            //
            SetFocus(GetDlgItem(hdlg,IDT_NAME));

            //
            // Open/Close IME.
            //
            SetIMEOpenStatus(hdlg,TRUE);

            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:

            UnattendAdvanceIfValid (hdlg);      // see WMX_VALIDATE
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FALSE);

            //
            // Close IME.
            //
            SetIMEOpenStatus(hdlg,FALSE);

            END_SECTION(L"Personalize Your Software Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageNameOrg);
            break;

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
CALLBACK
ComputerNameDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    NMHDR *NotifyParams;
    DWORD err, Win32NameSize = MAX_COMPUTERNAME_LENGTH + 1;
    static BOOL EncryptedAdminPasswordBad = FALSE;
    static BOOL bPersonal = FALSE;

    switch(msg) {

    case WM_INITDIALOG: {

        bPersonal = ( GetProductFlavor() == 4);
        //
        // Limit text to maximum length
        //
        SendDlgItemMessage(hdlg,IDT_EDIT1,EM_LIMITTEXT,DNS_MAX_LABEL_LENGTH,0);
        if (!bPersonal)
        {
            SendDlgItemMessage(hdlg,IDT_EDIT2,EM_LIMITTEXT,MAX_PASSWORD,0);
            SendDlgItemMessage(hdlg,IDT_EDIT3,EM_LIMITTEXT,MAX_PASSWORD,0);
        }
        //
        // Set the Edit boxes to the initial text
        //

        //
        // Generate a computer name if we're unattended and
        // the user has requested a random name, or if we're
        // attended.
        //

        GenerateName( ComputerName, 15 );
        if( (Unattended) &&
            (UnattendAnswerTable[UAE_COMPNAME].Answer.String) &&
            (UnattendAnswerTable[UAE_COMPNAME].Answer.String[0] == L'*') ) {
            //
            // The unattend engine has asked us to generate a Computer
            // name.  Let's write the data back into the unattend
            // database.
            //
            MyFree( UnattendAnswerTable[UAE_COMPNAME].Answer.String );
            UnattendAnswerTable[UAE_COMPNAME].Answer.String = ComputerName;
        }

        if (!bPersonal)
        {
            if(DontChangeAdminPassword) {
                EnableWindow(GetDlgItem(hdlg,IDT_EDIT2),FALSE);
                EnableWindow(GetDlgItem(hdlg,IDT_EDIT3),FALSE);
            } else {
                SetDlgItemText(hdlg,IDT_EDIT2,AdminPassword);
                SetDlgItemText(hdlg,IDT_EDIT3,AdminPassword);
            }
        }
        break;
    }

    case WM_IAMVISIBLE:
        MessageBoxFromMessage(
            hdlg,
            ComputerName[0] ? MSG_BAD_COMPUTER_NAME1 : MSG_BAD_COMPUTER_NAME2,
            NULL,
            IDS_ERROR,MB_OK|MB_ICONSTOP);
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WMX_VALIDATE:
        //
        // lParam == 0 for no UI, or 1 for UI
        // Return 1 for success, -1 for error.
        //

        IsNameNonRfc = FALSE;
        IsNameTruncated = FALSE;

        GetDlgItemText(hdlg,IDT_EDIT1,ComputerName,DNS_MAX_LABEL_LENGTH+1);

        // StrTrim removes both leading and trailing spaces
        StrTrim(ComputerName, TEXT(" "));

        if (ContainsDot(ComputerName)) {
           err = ERROR_INVALID_NAME;
        } else {
           err = DnsValidateDnsName_W(ComputerName);
           if (err == DNS_ERROR_NON_RFC_NAME) {
              IsNameNonRfc = TRUE;
              err = ERROR_SUCCESS;
           }

           if(err == ERROR_SUCCESS) {
              //The name is a valid DNS name. Now verify that it is
              //also a valid WIN32 computer name.

              if (!DnsHostnameToComputerNameW(ComputerName,
                                              Win32ComputerName,
                                              &Win32NameSize) ||
                  !IsNetNameValid(Win32ComputerName, FALSE)) {
                  err = ERROR_INVALID_NAME;
              }
              else {
                  if (Win32NameSize < (UINT)lstrlen(ComputerName) ) {
                      //The DNSName was truncated to get a Win32 ComputerName.
                      IsNameTruncated = TRUE;
                  }
              }
           }
        }

        //
        // If the name has non-RFC characters or if it was truncated, warn
        // user if it is not an unattended install and we have GUI.
        //
        if (err == ERROR_SUCCESS && !Unattended && lParam) {

            if (IsNameNonRfc) {
                //ComputerName has non-standard characters.
                if (MessageBoxFromMessage(
                       hdlg,
                       MSG_DNS_NON_RFC_NAME,
                       NULL,
                       IDS_SETUP,MB_YESNO|MB_ICONWARNING,
                       ComputerName) == IDNO) {

                     SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
                     SendDlgItemMessage(hdlg,IDT_EDIT1,EM_SETSEL,0,-1);
                     return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

                }
            }

            if (IsNameTruncated) {
                //The computer name was truncated.
                if (MessageBoxFromMessage(
                       hdlg,
                       MSG_DNS_NAME_TRUNCATED,
                       NULL,
                       IDS_SETUP,MB_YESNO|MB_ICONWARNING,
                       ComputerName, Win32ComputerName) == IDNO) {

                     SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
                     SendDlgItemMessage(hdlg,IDT_EDIT1,EM_SETSEL,0,-1);
                     return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

                }
            }
        }

        if(err == ERROR_SUCCESS) {
            WCHAR pw1[MAX_PASSWORD+1],pw2[MAX_PASSWORD+1];
            if (bPersonal)
            {
                // if we are in personal we are done.
                return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);
            }
            //
            // Good computer name.  Now make sure passwords match.
            //
            GetDlgItemText(hdlg,IDT_EDIT2,pw1,MAX_PASSWORD+1);
            GetDlgItemText(hdlg,IDT_EDIT3,pw2,MAX_PASSWORD+1);
            if(lstrcmp(pw1,pw2)) {
                //
                // Skip UI?
                //

                if (!lParam) {
                    return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
                }

                //
                //
                // Inform user of password mismatch, and don't allow next page
                // to be activated.
                //
                if (Unattended) {
                    UnattendErrorDlg(hdlg, IDD_COMPUTERNAME);
                }
                MessageBoxFromMessage(hdlg,MSG_PW_MISMATCH,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
                SetDlgItemText(hdlg,IDT_EDIT2,L"");
                SetDlgItemText(hdlg,IDT_EDIT3,L"");
                SetFocus(GetDlgItem(hdlg,IDT_EDIT2));

                return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

            } else {

                WCHAR   adminName[MAX_USERNAME+1];

                GetAdminAccountName( adminName );


                //
                // Process the encrypted password if
                // 1) We are unattended and
                // 2) The EncryptedAdminPassword key is "Yes" in the unatttend file and
                // 3) We are not back here after setting it - i.e. via the back button etc.
                // 4) We are not back here after failing to set it once.


                if( Unattended && IsEncryptedAdminPasswordPresent() &&
                    !DontChangeAdminPassword && !EncryptedAdminPasswordBad){

                    // Logging is done inside the call to ProcessEncryptedAdminPassword

                    if(!(ProcessEncryptedAdminPassword(adminName))){

                        EncryptedAdminPasswordBad = TRUE;

                        // Page becomes active, make page visible.
                        SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                        // Inform the user and enable the password fields

                        UnattendErrorDlg(hdlg, IDD_COMPUTERNAME);
                        MessageBoxFromMessage(hdlg,MSG_CHANGING_PW_FAIL,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP, adminName );
                        SetDlgItemText(hdlg,IDT_EDIT2,L"");
                        SetDlgItemText(hdlg,IDT_EDIT3,L"");
                        SetFocus(GetDlgItem(hdlg,IDT_EDIT2));

                        return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
                    }else{
                        EncryptedAdminPasswordSet = TRUE;

                        //
                        // Set DontChangeAdminPassword to avoid the user from ever trying to
                        // reset the password using the dialog. This is needed in the case where the
                        // unattend fails, say, in the next page and the user gets here using the back button.
                        //

                        DontChangeAdminPassword = TRUE;
                    }


                }else{



                    //
                    // They match; allow next page to be activated.
                    //
                    if (Unattended && pw1[0] == L'*') {
                        pw1[0] = L'\0';
                    }


                    // Set administrator password.  We need to do some checking here though.
                    // There are 3 scenarios that can occur in mini-setup:
                    // 1. The OEM doesn't want to have the admin password changed.
                    //    In this case, he's set OEMAdminPassword = "NoChange".  If that's
                    //    what we find, we don't assign the password.  Remember that this
                    //    system has already been installed, so there's already an admin
                    //    password.
                    // 2. The OEM wants to set the admin password to a specific string.
                    //    In this case, he's set OEMAdminPassword = <some quoted word>.
                    //    If this is the case, we've already caught this string in the
                    //    wizard page.
                    // 3. The OEM wants to let the user set the admin password.  In this
                    //    case, there's no OEMAdminpassword in the answer file.  If this
                    //    is the case, we've already caught this and gotten a password
                    //    from the user in the wizard page.
                    //
                    // The good news is that the unattend engine has already looked
                    // for a password in the unattend file called "NoChange" and has
                    // set a global called "DontChangeAdminPassword" to indicate.



                    if(!DontChangeAdminPassword) {

                        lstrcpy(AdminPassword,pw1);

                        //
                        // The user may have changed the name of the Administrator
                        // account.  We'll call some special code to retrieve the
                        // name on the account.  This is really only needed in the
                        // case of a sysprep run, but it can't hurt to do it always.
                        //
                        // In the Win9x case their code in winnt32 generates a random
                        // password and passes it to us through the unattend file and
                        // so we set it here and do the right thing.

                        // For Minisetup the behavior for now is to silently fail setting
                        // the admin password if there was an existing Password on the system.
                        // WE only allow setting the admin password from NULL i.e. one time change.
                        // In any other case we log the error and move on.
                        //



                        if(!SetLocalUserPassword(adminName,CurrentAdminPassword,AdminPassword) && !MiniSetup) {

                            SetupDebugPrint( L"SETUP: SetLocalUserPassword failed" );
                            // Page becomes active, make page visible.
                            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

                            MessageBoxFromMessage(hdlg,MSG_CHANGING_PW_FAIL,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP, adminName );
                            SetDlgItemText(hdlg,IDT_EDIT2,L"");
                            SetDlgItemText(hdlg,IDT_EDIT3,L"");
                            SetFocus(GetDlgItem(hdlg,IDT_EDIT2));

                            return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

                        }
                        //
                        //  Now store this so that we work fine when the user comes to this page by hitting "Back".
                        //
                        lstrcpy( CurrentAdminPassword, AdminPassword );


                    }
                }
            }
        } else {
            //
            // Skip UI?
            //

            if (!lParam) {
                return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
            }

            //
            // Inform user of bogus computer name, and don't allow next page
            // to be activated.
            //
            if (Unattended) {
                UnattendErrorDlg(hdlg, IDD_COMPUTERNAME);
            }
            MessageBoxFromMessage(
                hdlg,
                ComputerName[0] ? MSG_BAD_COMPUTER_NAME1 : MSG_BAD_COMPUTER_NAME2,
                NULL,
                IDS_ERROR,MB_OK|MB_ICONSTOP
                );
            SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
            SendDlgItemMessage(hdlg,IDT_EDIT1,EM_SETSEL,0,-1);

            return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);
        }

        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(504);

            BEGIN_SECTION(L"Computer Name Page");
            SetWizardButtons(hdlg,WizPageComputerName);

            //
            // Load ComputerName because it may have been set when the user
            // entered the organization name.
            //
            SetDlgItemText(hdlg,IDT_EDIT1,ComputerName);

            if(Unattended && !UnattendSetActiveDlg(hdlg,IDD_COMPUTERNAME)) {
                break;
            }

            //
            // Post ourselves a message we'll get once displayed.
            //
            PostMessage(hdlg,WM_USER,0,0);
            break;

        case PSN_WIZBACK:
            //
            // Save ComputerName because we're going to load it into the dialog
            // again when we come back.
            //
            GetDlgItemText(hdlg,IDT_EDIT1,ComputerName,DNS_MAX_LABEL_LENGTH+1);
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            UnattendAdvanceIfValid (hdlg);      // see WMX_VALIDATE
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FALSE);
            END_SECTION(L"Computer Name Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageComputerName);
            break;

        default:
            break;
        }

        break;

    case WM_USER:
        // Page becomes active, make page visible.
        SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
        //
        // Select the computer name string and set focus to it.
        //
        SendDlgItemMessage(hdlg,IDT_EDIT1,EM_SETSEL,0,-1);
        SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

#ifdef DOLOCALUSER
BOOL
CheckUserAccountData(
    IN  HWND hdlg,
    OUT BOOL ValidateOnly
    )
{
    WCHAR userName[MAX_USERNAME+1];
    WCHAR pw1[MAX_PASSWORD+1];
    WCHAR pw2[MAX_PASSWORD+1];
    WCHAR adminName[MAX_USERNAME+1];
    WCHAR guestName[MAX_USERNAME+1];
    UINT MessageId;

    FocusId = 0;

    //
    // Load names of built-in accounts.
    //
    LoadString(MyModuleHandle,IDS_ADMINISTRATOR,adminName,MAX_USERNAME+1);
    LoadString(MyModuleHandle,IDS_GUEST,guestName,MAX_USERNAME+1);

    //
    // Fetch data user typed in for username and password.
    //
    GetDlgItemText(hdlg,IDT_EDIT1,userName,MAX_USERNAME+1);
    GetDlgItemText(hdlg,IDT_EDIT2,pw1,MAX_PASSWORD+1);
    GetDlgItemText(hdlg,IDT_EDIT3,pw2,MAX_PASSWORD+1);

    if(lstrcmpi(userName,adminName) && lstrcmpi(userName,guestName)) {
        if(userName[0]) {
            if(IsNetNameValid(userName,FALSE)) {
                if(lstrcmp(pw1,pw2)) {
                    //
                    // Passwords don't match.
                    //
                    MessageId = MSG_PW_MISMATCH;
                    SetDlgItemText(hdlg,IDT_EDIT2,L"");
                    SetDlgItemText(hdlg,IDT_EDIT3,L"");
                    SetFocus(GetDlgItem(hdlg,IDT_EDIT2));
                } else {
                    //
                    // Name is non-empty, is not a built-in, is valid,
                    // and the passwords match.
                    //
                    MessageId = 0;
                }
            } else {
                //
                // Name is not valid.
                //
                MessageId = MSG_BAD_USER_NAME1;
                SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
            }
        } else {
            //
            // Don't allow empty name.
            //
            MessageId = MSG_BAD_USER_NAME2;
            SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
        }
    } else {
        //
        // User entered name of a built-in account.
        //
        MessageId = MSG_BAD_USER_NAME3;
        SetFocus(GetDlgItem(hdlg,IDT_EDIT1));
    }

    if(MessageId && !ValidateOnly) {
        MessageBoxFromMessage(hdlg,MessageId,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
    }

    return(MessageId == 0);
}

BOOL
CALLBACK
UserAccountDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    NMHDR *NotifyParams;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Limit text to maximum length of a user account name,
        // and limit password text to max langth of a password.
        // Also set initial text.
        //
        SendDlgItemMessage(hdlg,IDT_EDIT1,EM_LIMITTEXT,MAX_USERNAME,0);
        SendDlgItemMessage(hdlg,IDT_EDIT2,EM_LIMITTEXT,MAX_PASSWORD,0);
        SendDlgItemMessage(hdlg,IDT_EDIT3,EM_LIMITTEXT,MAX_PASSWORD,0);
        SetDlgItemText(hdlg,IDT_EDIT1,UserName);
        SetDlgItemText(hdlg,IDT_EDIT2,UserPassword);
        SetDlgItemText(hdlg,IDT_EDIT3,UserPassword);
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WMX_VALIDATE:
        //
        // lParam == 0 for no UI, or 1 for UI
        // Return 1 for success, -1 for error.
        //

        //
        // Check name.
        //
        if(CheckUserAccountData(hdlg, lParam == 0)) {
            //
            // Data is valid.  Move on to next page.
            //
            GetDlgItemText(hdlg,IDT_EDIT1,UserName,MAX_USERNAME+1);
            GetDlgItemText(hdlg,IDT_EDIT2,UserPassword,MAX_PASSWORD+1);
            CreateUserAccount = TRUE;
        } else if (Unattended) {
            //
            // Data is invalid but we're unattended, so just don't create
            // the account.
            //
            CreateUserAccount = FALSE;
            GetDlgItemText(hdlg,IDT_EDIT1,UserName,MAX_USERNAME+1);
            SetDlgItemText(hdlg,IDT_EDIT2,L"");
            SetDlgItemText(hdlg,IDT_EDIT3,L"");
            UserPassword[0] = 0;

            return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);
        }

        //
        // Don't allow next page to be activated.
        //
        return ReturnDlgResult (hdlg, VALIDATE_DATA_INVALID);

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(505);
            BEGIN_SECTION(L"User Name and Password Page");
            SetWizardButtons(hdlg,WizPageUserAccount);

            //
            // Load ComputerName because it may have been set when the user
            // entered the user name.
            //
            SetDlgItemText(hdlg,IDT_EDIT1,UserName);

            //
            // Always activate in ui test mode
            //
            if(!UiTest) {
                //
                // Don't activate if this is a dc server or Win9x upgrade.
                //
                if(ISDC(ProductType) || Win95Upgrade) {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                    break;
                }
            }
            if (Unattended) {
                if (!UnattendSetActiveDlg(hdlg,IDD_USERACCOUNT)) {
                    break;
                }
            }
            // Page becomes active, make page visible.
            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

            break;

        case PSN_WIZBACK:
            //
            // Save UserName because we're going to load it into the dialog
            // again when we come back.
            //
            GetDlgItemText(hdlg,IDT_EDIT1,UserName,MAX_USERNAME+1);
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            UnattendAdvanceIfValid (hdlg);      // see WMX_VALIDATE
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, FALSE );
            END_SECTION(L"User Name and Password Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageUserAccount);
            break;

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
#endif //def DOLOCALUSER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\optdirs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    optdirs.c

Abstract:

    Routines for copying optional directories.

Author:

    Ted Miller (tedm) 7-Jun-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


PWSTR OptionalDirSpec;

PWSTR *OptionalDirs;
UINT OptionalDirCount;


BOOL
InitializeOptionalDirList(
    VOID
    )

/*++

Routine Description:

    Initialize the list of optional directories by transforming a
    *-delineated list of directories into an array of strings.

Arguments:

    None.

Return Value:

    Boolean value indicating whether initialization was successful.
    If not an entry will have been logged indicating why.

--*/

{
    PWSTR p,q;
    WCHAR c;
    UINT Count,i,Len;

    //
    // The number of directories is equal to the number of *'s plus one.
    //
    Len = lstrlen(OptionalDirSpec);
    OptionalDirCount = 1;
    for(Count=0; Count<Len; Count++) {
        if(OptionalDirSpec[Count] == L'*') {
            OptionalDirCount++;
        }
    }

    OptionalDirs = MyMalloc(OptionalDirCount * sizeof(PWSTR));
    if(!OptionalDirs) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OPTIONAL_DIRS,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
        return(FALSE);
    }
    ZeroMemory(OptionalDirs,OptionalDirCount * sizeof(PWSTR));

    p = OptionalDirSpec;
    Count = 0;
    do {
        if((q = wcschr(p,L'*')) == NULL) {
            q = wcschr(p,0);
        }

        c = *q;
        *q = 0;
        OptionalDirs[Count] = pSetupDuplicateString(p);
        *q = c;

        if(!OptionalDirs[Count]) {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OPTIONAL_DIRS,NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_OUTOFMEMORY,
                NULL,NULL);

            for(i=0; i<Count; i++) {
                MyFree(OptionalDirs[i]);
            }
            MyFree(OptionalDirs);
            return(FALSE);
        }

        Count++;
        p = q+1;

    } while(c);

    return(TRUE);
}


BOOL
QueueFilesInOptionalDirectory(
    IN HSPFILEQ FileQ,
    IN PCWSTR   Directory
    )
{
    WCHAR FileDirSpec[MAX_PATH];
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    WCHAR c1,c2,c3;
    BOOL b;
    DWORD Result;

    //
    // Create the directory in the user's nt tree.
    //
    Result = GetWindowsDirectory(FileDirSpec,MAX_PATH);
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    pSetupConcatenatePaths(FileDirSpec,Directory,MAX_PATH,NULL);
    CreateDirectory(FileDirSpec,NULL);

    //
    // Form the full name of the directory to iterate
    // and add on the search spec.
    //
    lstrcpyn(FileDirSpec,SourcePath,MAX_PATH);
    pSetupConcatenatePaths(FileDirSpec,Directory,MAX_PATH,NULL);
    pSetupConcatenatePaths(FileDirSpec,L"*",MAX_PATH,NULL);

    b = TRUE;
    FindHandle = FindFirstFile(FileDirSpec,&FindData);
    if(FindHandle != INVALID_HANDLE_VALUE) {

        do {
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                //
                // It's a directory. Ignore if current or parent dir spec (. or ..).
                //
                c1 = FindData.cFileName[0];
                c2 = FindData.cFileName[1];
                c3 = FindData.cFileName[2];

                if(!(((c1 == TEXT('.')) && !c2) || ((c1 == TEXT('.')) && (c2 == TEXT('.')) && !c3))) {
                    //
                    // Recurse to handle the child directory.
                    //
                    lstrcpyn(FileDirSpec,Directory,MAX_PATH);
                    pSetupConcatenatePaths(FileDirSpec,FindData.cFileName,MAX_PATH,NULL);

                    b = QueueFilesInOptionalDirectory(FileQ,FileDirSpec);
                }
            } else {
                //
                // It's a file. Queue it up for copy.
                //
                Result = GetWindowsDirectory(FileDirSpec,MAX_PATH);
                if (Result == 0) {
		    MYASSERT(FALSE);
                    return FALSE;
                }
                pSetupConcatenatePaths(FileDirSpec,Directory,MAX_PATH,NULL);

                b = SetupQueueCopy(
                        FileQ,
                        SourcePath,
                        Directory,
                        FindData.cFileName,
                        NULL,
                        NULL,
                        FileDirSpec,
                        FindData.cFileName,
                        SP_COPY_DELETESOURCE | BaseCopyStyle
                        );

                if(!b) {
                    SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_OPTIONAL_DIR,
                        Directory, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_RETURNED_WINERR,
                        L"SetupQueueCopy",
                        GetLastError(),
                        NULL,NULL);
                }
            }
        } while(b && FindNextFile(FindHandle,&FindData));

        FindClose(FindHandle);
    }

    return(b);
}


BOOL
CopyOptionalDirectories(
    VOID
    )

/*++

Routine Description:

Arguments:

    None.

Return Value:

    Boolean value indicating whether copying was successful.
    If not an entry will have been logged indicating why.

--*/
{
    UINT u;
    BOOL b;
    HSPFILEQ FileQ;
    PVOID QueueCallbackInfo;
    BYTE PrevPolicy;
    BOOL ResetPolicy = FALSE;

    if(!OptionalDirSpec) {
        return(TRUE);
    }

    //
    // Unless the default non-driver signing policy was overridden via an
    // answerfile entry, then we want to temporarily turn down the policy level
    // to ignore while we copy optional directories.  Of course, setupapi log
    // entries will still be generated for any unsigned files copied during
    // this time, but there'll be no UI.
    //
    if(!AFNonDrvSignPolicySpecified) {
        SetCodeSigningPolicy(PolicyTypeNonDriverSigning, DRIVERSIGN_NONE, &PrevPolicy);
        ResetPolicy = TRUE;
    }

    //
    // Initialize the optional directory list.
    //
    if(!InitializeOptionalDirList()) {
        return(FALSE);
    }

    //
    // Initialize a setup file queue.
    //
    FileQ = SetupOpenFileQueue();
    if(FileQ == INVALID_HANDLE_VALUE) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OPTIONAL_DIRS,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
        return(FALSE);
    }
    QueueCallbackInfo = SetupInitDefaultQueueCallbackEx(
        MainWindowHandle,
        INVALID_HANDLE_VALUE,
        0,0,NULL);

    if(!QueueCallbackInfo) {
        SetupCloseFileQueue(FileQ);
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OPTIONAL_DIRS,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
        return(FALSE);
    }

    //
    // Queue the files in each directory.
    //
    b = TRUE;
    for(u=0; u<OptionalDirCount; u++) {
        if(!QueueFilesInOptionalDirectory(FileQ,OptionalDirs[u])) {
            b = FALSE;
        }
    }


    //
    // Copy the files in the queue. We do this even if some of the queue
    // operations failed, so we get at least a subset of the files copied over.
    //
    if(!SetupCommitFileQueue(MainWindowHandle,FileQ,SetupDefaultQueueCallback,QueueCallbackInfo)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OPTIONAL_DIR_COPY,
            NULL,NULL);
        b = FALSE;
    }

    SetupTermDefaultQueueCallback(QueueCallbackInfo);
    SetupCloseFileQueue(FileQ);

    //
    // Now crank the non-driver signing policy back up to what it was prior to
    // entering this routine.
    //
    if(ResetPolicy) {
        SetCodeSigningPolicy(PolicyTypeNonDriverSigning, PrevPolicy, NULL);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\pid.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    pid.c

Abstract:

    Product id routines.

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

    13-Sep-1995 (t-stepl) - Check for unattended install

--*/

#include "setupp.h"
#include <spidgen.h>
#include <pencrypt.h>
#pragma hdrstop

CDTYPE  CdType;

//
// Constants used for logging that are specific to this source file.
//
PCWSTR szPidKeyName                 = L"SYSTEM\\Setup\\Pid";
PCWSTR szPidListKeyName             = L"SYSTEM\\Setup\\PidList";
PCWSTR szPidValueName               = L"Pid";
PCWSTR szPidSelectId                = L"270";
#if 0
// msdn no longer exists.
PCWSTR szPidMsdnId                  = L"335";
#endif
PCWSTR szPidOemId                   = L"OEM";
PCWSTR szFinalPidKeyName            = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
PCWSTR szFinalPidValueName          = L"ProductId";
PCWSTR szSkuProfessionalFPP     = L"B23-00079";
PCWSTR szSkuProfessionalCCP     = L"B23-00082";
PCWSTR szSkuProfessionalSelect      = L"B23-00305";
PCWSTR szSkuProfessionalEval        = L"B23-00084";
PCWSTR szSkuServerFPP           = L"C11-00016";
PCWSTR szSkuServerCCP           = L"C11-00027";
PCWSTR szSkuServerSelect        = L"C11-00222";
PCWSTR szSkuServerEval          = L"C11-00026";
PCWSTR szSkuServerNFR           = L"C11-00025";
PCWSTR szSkuAdvServerFPP        = L"C10-00010";
PCWSTR szSkuAdvServerCCP        = L"C10-00015";
PCWSTR szSkuAdvServerSelect     = L"C10-00098";
PCWSTR szSkuAdvServerEval       = L"C10-00014";
PCWSTR szSkuAdvServerNFR        = L"C10-00013";
PCWSTR szSkuDTCFPP          = L"C49-00001";
PCWSTR szSkuDTCSelect           = L"C49-00023";
PCWSTR szSkuUnknown         = L"A22-00001";
PCWSTR szSkuOEM             = L"OEM-93523";

PCWSTR szMSG_LOG_PID_CANT_WRITE_PID = L"Setup was unable to save the Product Id in the registry. Error code = %1!u!.";

//
// Flag indicating whether to display the product id dialog.
//
BOOL DisplayPidDialog = TRUE;

//
// Product ID.
//
WCHAR ProductId[MAX_PRODUCT_ID+1];


PWSTR*  Pid20Array = NULL;

//
// pid 30 product id
//
WCHAR Pid30Text[5][MAX_PID30_EDIT+1];
WCHAR ProductId20FromProductId30[MAX_PRODUCT_ID+1];
WCHAR Pid30Rpc[MAX_PID30_RPC+1];
WCHAR Pid30Site[MAX_PID30_SITE+1];
BYTE  DigitalProductId[DIGITALPIDMAXLEN];

//
// global variable used for subclassing.
//
WNDPROC OldPidEditProc[5];


//
//  Pid related flags
//
// BOOL DisplayPidCdDialog;
// BOOL DisplayPidOemDialog;

//
// forward declarations
//

CDTYPE
MiniSetupGetCdType(
    LPCWSTR Value
    )

/*++

Routine Description:

    Get the right CD type during Mini-Setup. PidGen changes the channel ID
    for the value at HKLM\Software\Microsoft\Windows NT\CurrentVersion!ProductId,
    we have to preserve and rely on the value at HKLM\SYSTEM\Setup\Pid!Pid

Return Value:

    the CdType.

--*/

{
    CDTYPE RetVal;
    WCHAR  TmpPid30Site[MAX_PID30_SITE+1];
    HKEY   Key = NULL;
    DWORD  cbData;
    WCHAR  Data[ MAX_PATH + 1];
    DWORD  Type;

    cbData = sizeof(Data);
    if ( ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szPidKeyName,
                0,
                KEY_READ,
                &Key ) == ERROR_SUCCESS ) &&
          ( RegQueryValueEx( Key,
                 szPidValueName,
                 0,
                 &Type,
                 ( LPBYTE )Data,
                 &cbData ) == ERROR_SUCCESS ) )
    {
        wcsncpy(TmpPid30Site, Data + MAX_PID30_RPC, MAX_PID30_SITE+1);
    }
    else
    {
        if (Value != NULL)
        {
            wcsncpy(TmpPid30Site, Value, MAX_PID30_SITE+1);
        }
        else
        {
            TmpPid30Site[0] = L'\0';
        }
    }
    
    TmpPid30Site[MAX_PID30_SITE] = (WCHAR)'\0';

    if (_wcsicmp( TmpPid30Site, szPidSelectId ) == 0) {
        RetVal = CDSelect;
    } else if( _wcsicmp( TmpPid30Site, szPidOemId ) == 0 ) {
        RetVal = CDOem;
    } else {
        RetVal = CDRetail;
    }

    if (Key != NULL)
    {
        RegCloseKey(Key);
    }

    return RetVal;
}

BOOL
ValidateAndSetPid30(
    VOID
    )
/*++

Routine Description:

    Using the Pid30Text global variables, check if we have a valid id.
    This generates the pid30 digital product id and pid20 string id, which
    we set into DigitalProductId and ProductId20FromProductId30 globals

Arguments:

    None.

Return Value:

    TRUE if pid was valid.  Set's the globals correctly on success, zero's them out on failure

--*/

{
    WCHAR tmpPid30String[5+ 5*MAX_PID30_EDIT];
    BOOL rc;
    PCWSTR pszSkuCode;

    // Since we require a PID in the Select media too, we need to fill the string
/*
    if (CDSelect == CdType){
        tmpPid30String[0] = L'\0';
    }
    else
*/
    {
    wsprintf(tmpPid30String, L"%s-%s-%s-%s-%s",
         Pid30Text[0],Pid30Text[1],Pid30Text[2],Pid30Text[3],Pid30Text[4]);
    }

    // check for eval
    if (!_wcsicmp(Pid30Rpc,L"82503")){
    // this is eval media ...
    if (ProductType == PRODUCT_WORKSTATION){
        pszSkuCode = szSkuProfessionalEval;
        goto HaveSku;
    } // else
    // else it is server or advanced server.  I don't think that at this point
    // we can easily tell the difference.  Since it's been said that having the
    // correct sku is not critically important, I shall give them both the sku
    // code of server
    pszSkuCode = szSkuServerEval;
    goto HaveSku;
    }

    // check for NFR
    if (!_wcsicmp(Pid30Rpc,L"51883")){
    pszSkuCode = szSkuServerNFR;
    goto HaveSku;
    } // else
    if (!_wcsicmp(Pid30Rpc,L"51882")){
    pszSkuCode = szSkuAdvServerNFR;
    goto HaveSku;
    } // else

    if (CdType == CDRetail) {
    if (!_wcsicmp(Pid30Rpc,L"51873")){
        pszSkuCode = szSkuProfessionalFPP;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51874")){
        pszSkuCode = szSkuProfessionalCCP;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51876")){
        pszSkuCode = szSkuServerFPP;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51877")){
        pszSkuCode = szSkuServerCCP;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51879")){
        pszSkuCode = szSkuAdvServerFPP;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51880")){
        pszSkuCode = szSkuAdvServerCCP;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51891")){
        pszSkuCode = szSkuDTCFPP;
        goto HaveSku;
    }
    } else if (CdType == CDOem) {
        pszSkuCode = szSkuUnknown;
    } else if (CdType == CDSelect) {
    if (!_wcsicmp(Pid30Rpc,L"51873")){
        pszSkuCode = szSkuProfessionalSelect;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51876")){
        pszSkuCode = szSkuServerSelect;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51879")){
        pszSkuCode = szSkuAdvServerSelect;
        goto HaveSku;
    }
    if (!_wcsicmp(Pid30Rpc,L"51891")){
        pszSkuCode = szSkuDTCSelect;
        goto HaveSku;
    }
    }

    pszSkuCode = szSkuUnknown;

HaveSku:

    *(LPDWORD)DigitalProductId = sizeof(DigitalProductId);
    rc = SetupPIDGenW(
                 tmpPid30String,            // [IN] 25-character Secure CD-Key (gets U-Cased)
                 Pid30Rpc,                  // [IN] 5-character Release Product Code
                 pszSkuCode,         // [IN] Stock Keeping Unit (formatted like 123-12345)
                 (CdType == CDOem),         // [IN] is this an OEM install?
                 ProductId20FromProductId30, // [OUT] PID 2.0, pass in ptr to 24 character array
                 DigitalProductId,          // [OUT] pointer to binary PID3 buffer. First DWORD is the length
                 NULL);                      // [OUT] optional ptr to Compliance Checking flag (can be NULL)


#ifdef PRERELEASE
        SetupDebugPrint2(L"Pidgen returns for PID:%s and MPC:%s\n", tmpPid30String, Pid30Rpc);
#endif
    if (!rc) {
#ifdef PRERELEASE
        SetupDebugPrint1(L"Pidgen returns %d for PID.n", rc);
#endif
        ZeroMemory(Pid30Text[0],5*(MAX_PID30_EDIT+1));
    }
    else
    {
        if (*ProductId20FromProductId30 == L'\0')
        {
            SetupDebugPrint(L"ProductId20FromProductId30 is empty after call into pidgen and pidgen returns OK\n");
        }
        if (*DigitalProductId == 0)
        {
            SetupDebugPrint(L"DigitalProductId is empty after call into pidgen and pidgen returns OK\n");
        }
    }

    return rc;

}

LRESULT
CALLBACK
PidEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, sets the focus to the correct edit box when the user enters text.
    This routine assumes that the pid controls ids are in sequential order.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    DWORD len, id;

    //
    // eat spaces
    //
    if ((msg == WM_CHAR) && (wParam == VK_SPACE)) {
        return(0);
    }

    if ((msg == WM_CHAR)) {
        //
        // First override: if we have the max characters in the current edit
        // box, let's post the character to the next box and set focus to that
        // control.
        //
        if ( ( (len = (DWORD)SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0)) == MAX_PID30_EDIT) &&
             ((wParam != VK_DELETE) && (wParam != VK_BACK)) ) {
            //
            // set the focus to the next edit control and post the character
            // to that edit control
            //
            if ((id = GetDlgCtrlID(hwnd)) < IDT_EDIT_PID5 ) {
                DWORD start, end;
                SendMessage(hwnd, EM_GETSEL, (WPARAM)&start,(LPARAM)&end);
                if (start == end) {
                    HWND hNext = GetDlgItem(GetParent(hwnd),id+1);
                    SetFocus(hNext);
                    SendMessage(hNext, EM_SETSEL, (WPARAM)-1,(LPARAM)-1);
                    PostMessage( GetDlgItem(GetParent(hwnd),id+1), WM_CHAR, wParam, lParam );
                    return(0);
                }

            }
        //
        // Second override: if the user hit's a delete key and they are at the
        // the start of an edit box, then post the delete to the previous edit
        // box.
        //
        } else if ( (len == 0) &&
                    ((id = GetDlgCtrlID(hwnd)) > IDT_EDIT_PID1) &&
                    ((wParam == VK_DELETE) || (wParam == VK_BACK) )) {
            //
            // set the focus to the previous edit control and post the command
            // to that edit control
            //
            HWND hPrev = GetDlgItem(GetParent(hwnd),id-1);
            SetFocus(hPrev);
            SendMessage(hPrev, EM_SETSEL, (WPARAM)MAX_PID30_EDIT-1,(LPARAM)MAX_PID30_EDIT);
            PostMessage( hPrev, WM_CHAR, wParam, lParam );
            return(0);
        //
        // Third override: if posting this message will give us the maximum
        // characters in our in the current edit box, let's post the character
        // to the next box and set focus to that control.
        //
        } else if (   (len == MAX_PID30_EDIT-1) &&
                      ((wParam != VK_DELETE) && (wParam != VK_BACK)) &&
                      ((id = GetDlgCtrlID(hwnd)) < IDT_EDIT_PID5) ) {
            DWORD start, end;
            SendMessage(hwnd, EM_GETSEL, (WPARAM)&start,(LPARAM)&end);
            if (start == end) {
                HWND hNext = GetDlgItem(GetParent(hwnd),id+1);
                //
                // post the message to the edit box
                //
                CallWindowProc(OldPidEditProc[GetDlgCtrlID(hwnd)-IDT_EDIT_PID1],hwnd,msg,wParam,lParam);
                //
                // now set the focus to the next edit control
                //
                SetFocus(hNext);
                SendMessage(hNext, EM_SETSEL, (WPARAM)-1,(LPARAM)-1);
                return(0);
            }
        }

    }

    return(CallWindowProc(OldPidEditProc[GetDlgCtrlID(hwnd)-IDT_EDIT_PID1],hwnd,msg,wParam,lParam));
}


INT_PTR
CALLBACK
Pid30CDDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

        Dialog procedure for the CD Retail Pid dialog.

Arguments:

        hWnd - a handle to the dialog proceedure.

        msg - the message passed from Windows.

        wParam - extra message dependent data.

        lParam - extra message dependent data.


Return Value:

        TRUE if the value was edited.  FALSE if cancelled or if no
        changes were made.

--*/
{
    NMHDR *NotifyParams;
    DWORD i,dwRet;


    switch(msg) {

    case WM_INITDIALOG: {

        if( UiTest ) {
            //
            //  If testing the wizard, make sure that the PidOEM page is
            //  displayed
            //
            CdType = CDRetail;
            DisplayPidDialog = TRUE;
        }


        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++)
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }
        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        break;
    }
    case WM_IAMVISIBLE:
        MessageBoxFromMessage(hdlg,MSG_PID_IS_INVALID,NULL,
            IDS_ERROR,MB_OK|MB_ICONSTOP);
        break;
    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(506);
            BEGIN_SECTION(L"Your (Retail) Product Key Page");
            if(DisplayPidDialog && CdType == CDRetail) {
                // Page becomes active, make page visible.
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

                SetWizardButtons(hdlg,WizPageProductIdCd);
                SendDlgItemMessage(hdlg,IDT_EDIT_PID1,EM_SETSEL,0,-1);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
            } else {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                END_SECTION(L"Your (Retail) Product Key Page");
                break;
            }
            if(Unattended) {
                if (UnattendSetActiveDlg(hdlg,IDD_PID_CD))
                {
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                }
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:

            for (i = 0; i<5; i++) {
                GetDlgItemText(hdlg,IDT_EDIT_PID1+i,Pid30Text[i],MAX_PID30_EDIT+1);
            }

            if (!ValidateAndSetPid30()) {

                // failure
                // Tell user that the Pid is not valid, and
                // don't allow next page to be activated.
                //
                if (Unattended) {
                    UnattendErrorDlg( hdlg, IDD_PID_CD );
                }
                MessageBoxFromMessage(hdlg,MSG_PID_IS_INVALID,NULL,
                        IDS_ERROR,MB_OK|MB_ICONSTOP);

                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                if(!UiTest) {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
            } else {


                // success
                //
                //  Since the Pid is already built, don't let this dialog
                //  be displayed in the future.
                //
                // DisplayPidDialog = FALSE;

                //
                // Allow next page to be activated.
                //
                dwRet = SetCurrentProductIdInRegistry();
                if (dwRet != NOERROR) {
                    SetuplogError(
                        LogSevError,
                        szMSG_LOG_PID_CANT_WRITE_PID,
                        0,
                        dwRet,NULL,NULL);
                }

                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            }

            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT, FALSE);
            END_SECTION(L"Your (Retail) Product Key Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageProductIdCd);
            break;

        default:
            break;

        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR
CALLBACK
Pid30OemDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

        Dialog procedure for the OEM Pid dialog.

Arguments:

        hWnd - a handle to the dialog proceedure.

        msg - the message passed from Windows.

        wParam - extra message dependent data.

        lParam - extra message dependent data.


Return Value:

        TRUE if the value was edited.  FALSE if cancelled or if no
        changes were made.

--*/
{
    NMHDR *NotifyParams;
    DWORD i,dwRet;


    switch(msg) {

    case WM_INITDIALOG: {

        if( UiTest ) {
            //
            //  If testing the wizard, make sure that the PidOEM page is
            //  displayed
            //
            CdType = CDOem;
            DisplayPidDialog = TRUE;
        }

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++)
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }
        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        break;

    }
    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_IAMVISIBLE:
        MessageBoxFromMessage(hdlg,MSG_PID_OEM_IS_INVALID,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
        break;
    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(507);
            BEGIN_SECTION(L"Your (OEM) Product Key Page");
            if(DisplayPidDialog && CdType == CDOem) {
                // Page becomes active, make page visible.
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                SetWizardButtons(hdlg,WizPageProductIdCd);
                SendDlgItemMessage(hdlg,IDT_EDIT_PID1,EM_SETSEL,0,-1);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
            } else {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                END_SECTION(L"Your (OEM) Product Key Page");
                break;
            }
            if(Unattended) {
                if (UnattendSetActiveDlg( hdlg, IDD_PID_OEM ))
                {
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                }
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:

            for (i = 0; i<5; i++) {
                GetDlgItemText(hdlg,IDT_EDIT_PID1+i,Pid30Text[i],MAX_PID30_EDIT+1);
            }


            if (!ValidateAndSetPid30()) {

                // failure
                //
                // Tell user that the Pid is not valid, and
                // don't allow next page to be activated.
                //
                if (Unattended) {
                    UnattendErrorDlg( hdlg, IDD_PID_OEM );
                } // if
                MessageBoxFromMessage(hdlg,MSG_PID_OEM_IS_INVALID,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                if(!UiTest) {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
            } else {

                // success
                //
                //  The Pid is valid.
                //


                //
                //
                //  Since the Pid is already built, don't let this dialog
                //  be displayed in the future.
                //
                // DisplayPidDialog = FALSE;

                // Allow next page to be activated.
                //
                dwRet = SetCurrentProductIdInRegistry();
                if (dwRet != NOERROR) {
                    SetuplogError(
                        LogSevError,
                        szMSG_LOG_PID_CANT_WRITE_PID,
                        0,
                        dwRet,NULL,NULL);
                }

                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);

            }
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT, FALSE );
            END_SECTION(L"Your (OEM) Product Key Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageProductIdCd);
            break;

        default:
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
CALLBACK
Pid30SelectDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

        Dialog procedure for the OEM Pid dialog.

Arguments:

        hWnd - a handle to the dialog proceedure.

        msg - the message passed from Windows.

        wParam - extra message dependent data.

        lParam - extra message dependent data.


Return Value:

        TRUE if the value was edited.  FALSE if cancelled or if no
        changes were made.

--*/
{
    NMHDR *NotifyParams;
    DWORD i,dwRet;

    switch(msg) {

    case WM_INITDIALOG: {

        if( UiTest ) {
            //
            //  If testing the wizard, make sure that the PidOEM page is
            //  displayed
            //
            CdType = CDSelect;
            DisplayPidDialog = TRUE;
        }

        // Disable the IME on the PID edit controls
        for (i = 0; i < 5;i++)
        {
            ImmAssociateContext(GetDlgItem(hdlg, IDT_EDIT_PID1+i), (HIMC)NULL);
        }
        //
        // subclass the edit controls and limit the number of characters
        //
        for (i = 0; i < 5;i++) {
            SendDlgItemMessage(hdlg,IDT_EDIT_PID1+i,EM_LIMITTEXT,MAX_PID30_EDIT,0);
            OldPidEditProc[i] = (WNDPROC)GetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC);
            SetWindowLongPtr(GetDlgItem(hdlg, IDT_EDIT_PID1+i),GWLP_WNDPROC,(LONG_PTR)PidEditSubProc);
        }

        break;

    }
    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_IAMVISIBLE:
        MessageBoxFromMessage(hdlg,MSG_PID_OEM_IS_INVALID,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
        break;
    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(508);
            BEGIN_SECTION(L"Your (Select) Product Key Page");
            if(DisplayPidDialog && CdType == CDSelect) {
                // Page becomes active, make page visible.
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                SetWizardButtons(hdlg,WizPageProductIdCd);
                SendDlgItemMessage(hdlg,IDT_EDIT_PID1,EM_SETSEL,0,-1);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
            } else {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                END_SECTION(L"Your (Select) Product Key Page");
                break;
            }
            if(Unattended) {
                if (UnattendSetActiveDlg( hdlg, IDD_PID_SELECT ))
                {
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                }
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:

            for (i = 0; i<5; i++) {
                GetDlgItemText(hdlg,IDT_EDIT_PID1+i,Pid30Text[i],MAX_PID30_EDIT+1);
            }


            if (!ValidateAndSetPid30()) {

                // failure
                //
                // Tell user that the Pid is not valid, and
                // don't allow next page to be activated.
                //
                if (Unattended) {
                    UnattendErrorDlg( hdlg, IDD_PID_SELECT );
                } // if
                MessageBoxFromMessage(hdlg,MSG_PID_OEM_IS_INVALID,NULL,IDS_ERROR,MB_OK|MB_ICONSTOP);
                SetFocus(GetDlgItem(hdlg,IDT_EDIT_PID1));
                if(!UiTest) {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
            } else {

                // success
                //
                //  The Pid is valid.
                //


                //
                //
                //  Since the Pid is already built, don't let this dialog
                //  be displayed in the future.
                //
                // DisplayPidDialog = FALSE;


                // Allow next page to be activated.
                //
                dwRet = SetCurrentProductIdInRegistry();
                if (dwRet != NOERROR) {
                    SetuplogError(
                        LogSevError,
                        szMSG_LOG_PID_CANT_WRITE_PID,
                        0,
                        dwRet,NULL,NULL);
                }
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);

            }
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT, FALSE );
            END_SECTION(L"Your (Select) Product Key Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageProductIdCd);
            break;

        default:
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

BOOL
SetPid30Variables(
    PWSTR   Buffer
    )
{
    LPWSTR ptr;
    UINT i;


    //
    // all install cases are the same for pid3.0
    // Check that the string specified on the unattended script file
    // represents a valid 25 digit product id:
    //
    //      1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5 - 1 2 3 4 5
    //      0 1 2 3 4 5 6 7 8 9 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2
    //                          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8
    //
    // As a first validation test, we verify that the length is correct,
    // then we check if the "-" characters are in the correct place
    //
    //
    if(   ( wcslen( Buffer ) !=  (4+ MAX_PID30_EDIT*5)) ||
          ( Buffer[5]  != (WCHAR)L'-' ) ||
          ( Buffer[11] != (WCHAR)L'-' ) ||
          ( Buffer[17] != (WCHAR)L'-' ) ||
          ( Buffer[23] != (WCHAR)L'-' )
      ) {
          //
          // The Pid in the unattended script file is invalid.
          //
          return(FALSE);
    }


    for (i = 0;i<5;i++) {
        //
        // quintet i
        //
        ptr = &Buffer[i*(MAX_PID30_EDIT+1)];
        wcsncpy(Pid30Text[i], ptr, MAX_PID30_EDIT+1 );
        Pid30Text[i][MAX_PID30_EDIT] = (WCHAR)L'\0';
    }

    return TRUE;
}


BOOL
SetPid30FromAnswerFile(
    )
/*++

Routine Description:

        set the pid3.0 globals based on unattend file parameter, if it exists.

Arguments:

        None.

Return Value:


--*/

{
    WCHAR Buffer[MAX_BUF];
    DWORD dwRet;



    if (!GetPrivateProfileString(pwUserData,
                                 pwProductKey,
                                 L"",
                                 Buffer,
                                 sizeof(Buffer)/sizeof(WCHAR),
                                 AnswerFile)) {
       return(FALSE);
    }

    if (!Buffer || !*Buffer) {
       return(FALSE);
    }

    // Buffer contains the Product ID 
    // Is the PID encrypted?
    if (lstrlen(Buffer) > (4 + MAX_PID30_EDIT*5))
    {
        LPWSTR szDecryptedPID = NULL;
        if (ValidateEncryptedPID(Buffer, &szDecryptedPID) == S_OK)
        {
            lstrcpyn(Buffer, szDecryptedPID, sizeof(Buffer)/sizeof(WCHAR));
        }
        if (szDecryptedPID)
        {
            GlobalFree(szDecryptedPID);
        }
    }

    if ( !SetPid30Variables( Buffer ) ) {
        return FALSE;
    }

    SetupDebugPrint(L"Found Product key in Answer file.\n");
    //
    // check with pid30 to make sure it's valid
    //
    if (!ValidateAndSetPid30()) {
        return(FALSE);
    }

    dwRet = SetCurrentProductIdInRegistry();
    if (dwRet != NOERROR) {
        SetuplogError(
            LogSevError,
            szMSG_LOG_PID_CANT_WRITE_PID,
            0,
            dwRet,NULL,NULL);
    }
    return(TRUE);

}



BOOL
InitializePid20Array(
    )
/*++

Routine Description:

        Build the array that contains all Pid20 found in the machine
        during textmode setup.  Even though we are using pid30 now, we still have
        a pid20 string id (pid30 is binary and can't be displayed to the user)

Arguments:

        None.

Return Value:


--*/

{
    LONG    Error;
    HKEY    Key;
    DWORD   cbData;
    WCHAR   Data[ MAX_PATH + 1];
    DWORD   Type;
    ULONG   i;
    ULONG   PidIndex;
    ULONG   Values;
    WCHAR   ValueName[ MAX_PATH + 1 ];

    Pid20Array = NULL;
    //
    //  Get the Pid from HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szPidListKeyName,
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    Error = RegQueryInfoKey( Key,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             &Values,
                             NULL,
                             NULL,
                             NULL,
                             NULL );

    if( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    Pid20Array = (PWSTR *)MyMalloc( (Values + 1)* sizeof( PWSTR ) );

    for( i = 0, PidIndex = 0; i < Values; i++ ) {
        Pid20Array[PidIndex] = NULL;
        Pid20Array[PidIndex + 1] = NULL;
        swprintf( ValueName, L"Pid_%u", i );
        cbData = sizeof(Data);
        Error = RegQueryValueEx( Key,
                                 ValueName,
                                 0,
                                 &Type,
                                 ( LPBYTE )Data,
                                 &cbData );
        if( (Error != ERROR_SUCCESS) ||
            ( Type != REG_SZ ) ||
            ( wcslen( Data ) != MAX_PRODUCT_ID ) ) {
            continue;
        }
        Pid20Array[PidIndex] = pSetupDuplicateString( Data );
        PidIndex++;
    }
    RegCloseKey( Key );
    return( TRUE );
}


BOOL
InitializePidVariables(
    )
/*++

Routine Description:

        Read from the registry some values created by textmode setup,
        and initialize some global Pid flags based on the values found

Arguments:

        None.

Return Value:

        Returns TRUE if the initialization succedded.
        Returns FALSE if the Pid could not be read from the registry

--*/

{
    LONG    Error;
    HKEY    Key;
    DWORD   cbData;
    WCHAR   Data[ MAX_PATH + 1];
    DWORD   Type;
    ULONG   StringLength;
    PWSTR   p;
    DWORD   Seed;
    DWORD   RandomNumber;
    ULONG   ChkDigit;
    ULONG   i;
    PCWSTR  q;
    BOOLEAN KeyPresent;
    WCHAR   KeyBuffer[MAX_BUF];


    //
    // find out if product key was entered by the user or not
    // NB : set the answer file (if needed)
    //
    if (!AnswerFile[0])
      SpSetupLoadParameter(pwProductKey, KeyBuffer, sizeof(KeyBuffer)/sizeof(WCHAR));

    KeyBuffer[0] = 0;
    KeyPresent = ((GetPrivateProfileString(pwUserData, pwProductKey,
                      pwNull, KeyBuffer, sizeof(KeyBuffer)/sizeof(WCHAR),
                      AnswerFile) != 0) &&
                  (KeyBuffer[0] != 0));

    //  First create an array with the Pids found during textmode setup
    //
    if( !(MiniSetup || OobeSetup) ) {
        InitializePid20Array();
    }


    //
    //  Get the Pid from HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          ((MiniSetup || OobeSetup) ? szFinalPidKeyName : szPidKeyName),
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        SetuplogError( LogSevFatalError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PID_CANT_READ_PID, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegOpenKeyEx,
            Error,
            szPidKeyName,
            NULL,NULL);
        return( FALSE );
    }

    cbData = sizeof(Data);
    Error = RegQueryValueEx( Key,
                             ((MiniSetup || OobeSetup) ? szFinalPidValueName : szPidValueName),
                             0,
                             &Type,
                             ( LPBYTE )Data,
                             &cbData );
    RegCloseKey( Key );
    if( (Error != ERROR_SUCCESS) ) {
        SetuplogError( LogSevFatalError,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_CANT_READ_PID, NULL,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_X_PARAM_RETURNED_WINERR,
                  szRegQueryValueEx,
                  Error,
                  szPidValueName,
                  NULL,NULL);
        return( FALSE );
    }

    //
    // Take care of the mini-setup case first because it's quick.
    // The Pid seeds left behind by textmode are long gone, so
    // we're going to pull out a few rabbits.  We'll go read the
    // real Pid (the one gui-mode generated the first time he
    // ran through) and use that to determine which kind of
    // PID to prompt for later on.
    //
    if( MiniSetup || OobeSetup ) {

        //
        // tuck away the rpc code for later on
        //
        wcsncpy( Pid30Rpc, Data, MAX_PID30_RPC +1 );
        Pid30Rpc[MAX_PID30_RPC] = (WCHAR)'\0';

        p = Data + (MAX_PID30_RPC + 1);
        wcsncpy(Pid30Site,p,MAX_PID30_SITE+1);
        Pid30Site[MAX_PID30_SITE] = (WCHAR)'\0';
        //
        // Look to see what kind of media we're installing from.
        //
        CdType = MiniSetupGetCdType(Pid30Site);

        if (CdType == CDSelect)
        {
            goto SelectPid;
        }
        else
        {
            DisplayPidDialog = TRUE;
        }

        return( TRUE );
    }



    //
    //  Do some validation of the value read
    //

    if( ( Type != REG_SZ ) ||
        ( ( ( StringLength = wcslen( Data ) ) != 0 ) &&
          ( StringLength != MAX_PID30_RPC ) &&
          ( StringLength != MAX_PID30_RPC + MAX_PID30_SITE )
        )
      ) {
        SetuplogError( LogSevFatalError,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_CANT_READ_PID, NULL,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_INVALID_PID,
                  szRegQueryValueEx,
                  Type,
                  StringLength,
                  NULL,NULL);
        return( FALSE );
    }

    //
    // tuck away the rpc code for later on
    //
    wcsncpy( Pid30Rpc, Data, MAX_PID30_RPC +1 );
    Pid30Rpc[MAX_PID30_RPC] = (WCHAR)'\0';

    //
    //  Find out the kind of product we have (by looking at the site code):
    //  CD Retail, OEM or Select
    //

    if( StringLength > MAX_PID30_RPC ) {
        //
        //  If the Pid contains the Site, then find out what it is
        //
        p = Data + MAX_PID30_RPC;
        wcsncpy(Pid30Site,p,MAX_PID30_SITE+1);

        if(_wcsicmp( Pid30Site, szPidSelectId ) == 0) {

            //
            //  This is a Select CD
            //
SelectPid:
            CdType = CDSelect;
            if (!EulaComplete && !KeyPresent) {
                DisplayPidDialog = TRUE;
            } else {
                //
                //  The Pid was specified during winnt32.
                //  Set the pid globals and build the product id string
                //

                if (!SetPid30FromAnswerFile()) {
                   DisplayPidDialog = TRUE;
                   goto finish;
                }
                DisplayPidDialog = FALSE;

            }
/*
// Old code. previous version of Windows did not require a PID for Select media.
            for (i = 0; i< 5; i++) {
                Pid30Text[i][0] = (WCHAR)L'\0';
            }

            DisplayPidDialog = FALSE;

            if (!ValidateAndSetPid30()) {
                SetuplogError( LogSevFatalError,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_CANT_READ_PID, NULL,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_INVALID_PID,
                  szRegQueryValueEx,
                  Type,
                  StringLength,
                  NULL,NULL);
                return( FALSE );
            }

            if (MiniSetup || OobeSetup) {
                return(TRUE);
            }
*/
#if 0
// msdn media no longer exists (and if it does it should be viewed as retail,
// so later in this case statement we will fall thru to retail
        } else if (_wcsicmp( Pid30Site, szPidMsdnId ) == 0) {

            //
            //  This is an MSDN CD
            //
MsdnPid:
        for (i = 0; i< 5; i++) {
                LPWSTR ptr;
                ptr = (LPTSTR) &szPid30Msdn[i*(MAX_PID30_EDIT+1)];
                wcsncpy(Pid30Text[i], ptr, MAX_PID30_EDIT+1 );
                Pid30Text[i][MAX_PID30_EDIT] = (WCHAR)L'\0';
        }
            CdType = CDSelect;
        DisplayPidDialog = FALSE;
            if (!ValidateAndSetPid30()) {
                SetuplogError( LogSevFatalError,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_CANT_READ_PID, NULL,
                  SETUPLOG_USE_MESSAGEID,
                  MSG_LOG_PID_INVALID_PID,
                  szRegQueryValueEx,
                  Type,
                  StringLength,
                  NULL,NULL);
                return( FALSE );
            }

            if (MiniSetup) {
                return(TRUE);
            }
#endif
        } else if( _wcsicmp( Pid30Site, szPidOemId ) == 0 ) {
            //
            //  This is OEM
            //
            CdType = CDOem;

            if (!EulaComplete && !KeyPresent) {
                DisplayPidDialog = TRUE;
            } else {
                //
                //  The Pid was specified during winnt32.
                //  Set the pid globals and build the product id string
                //
                if (!SetPid30FromAnswerFile() ) {
                   DisplayPidDialog = TRUE;
                   goto finish;
                }

                DisplayPidDialog = FALSE;
            }

        } else {
            //
            // This is a bogus site assume CD Retail
            //
            CdType = CDRetail;
            wcsncpy( Pid30Site, L"000", MAX_PID30_SITE+1 );
            Pid30Site[ MAX_PID30_SITE ] = (WCHAR)'\0';

            if (!EulaComplete && !KeyPresent) {
                DisplayPidDialog = TRUE;
            } else {
                //
                //  The Pid was specified during winnt32.
                //  Set the pid globals and build the product id string
                //

                if (!SetPid30FromAnswerFile()) {
                   DisplayPidDialog = TRUE;
                   goto finish;
                }
                DisplayPidDialog = FALSE;

            }

        }


    } else {
        //
        //  If it doesn't contain the Site, then it is a CD retail,
        //  and the appropriate Pid dialog must be displayed.
        //
        CdType = CDRetail;
        wcsncpy( Pid30Site, L"000", MAX_PID30_SITE+1 );
        Pid30Site[ MAX_PID30_SITE ] = (WCHAR)'\0';

        if (!EulaComplete && !KeyPresent) {
            DisplayPidDialog = TRUE;
        } else {
            //
            //  The Pid was specified during winnt32.
            //  Set the pid globals and build the product id string
            //
            if (!SetPid30FromAnswerFile()) {
               DisplayPidDialog = TRUE;
               goto finish;
            }
            DisplayPidDialog = FALSE;
        }
    }

finish:
    //
    //  Don't remove the Setup\Pid here. See MiniSetupGetCdType
    //  Delete Setup\PidList since it is no longer needed
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\Setup",
                          0,
                          MAXIMUM_ALLOWED,
                          &Key );

    if( Error == ERROR_SUCCESS ) {
        // pSetupRegistryDelnode( Key, L"Pid" );
        pSetupRegistryDelnode( Key, L"PidList" );
        RegCloseKey( Key );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\preinst.c ===
#include "setupp.h"
#pragma hdrstop

//
// List of oem preinstall/unattend values we can fetch from profile files.
// Do NOT change the order of this without changing the order of the
// PreinstUnattendData array.
//
typedef enum {
    OemDatumBackgroundBitmap,
    OemDatumBannerText,
    OemDatumLogoBitmap,
    OemDatumMax
} OemPreinstallDatum;

//
// Define structure that represents a single bit of data read
// from a profile file relating to preinstallation.
//
typedef struct _PREINSTALL_UNATTEND_DATUM {
    //
    // Filename. If NULL, use the system answer file $winnt$.inf.
    // Otherwise this is relative to the root of the source drive.
    //
    PCWSTR Filename;

    //
    // Section name.
    //
    PCWSTR Section;

    //
    // Key name.
    //
    PCWSTR Key;

    //
    // Default value. Can be NULL but that will be translated to
    // "" when the profile API is called to retrieve the data.
    //
    PCWSTR Default;

    //
    // Where to put the actual value. The actual value may be
    // a string, or NULL.
    //
    PWSTR *Value;

    //
    // Value for sanity checking.
    //
    OemPreinstallDatum WhichValue;

} PREINSTALL_UNATTEND_DATUM, *PPREINSTALL_UNATTEND_DATUM;

//
// Name of oem background bitmap file and logo bitmap file.
// Replacement banner text.
// Read from unattend.txt
//
PWSTR OemBackgroundBitmapFile;
PWSTR OemLogoBitmapFile;
PWSTR OemBannerText;

//
// If this is non-NULL, it is a replacement bitmap
// to use for the background.
//
HBITMAP OemBackgroundBitmap;


PREINSTALL_UNATTEND_DATUM PreinstUnattendData[OemDatumMax] = {

    //
    // Background bitmap
    //
    {   NULL,
        WINNT_OEM_ADS,
        WINNT_OEM_ADS_BACKGROUND,
        NULL,
        &OemBackgroundBitmapFile,
        OemDatumBackgroundBitmap
    },

    //
    // Banner text
    //
    {
        NULL,
        WINNT_OEM_ADS,
        WINNT_OEM_ADS_BANNER,
        NULL,
        &OemBannerText,
        OemDatumBannerText
    },

    //
    // Logo bitmap
    //
    {
        NULL,
        WINNT_OEM_ADS,
        WINNT_OEM_ADS_LOGO,
        NULL,
        &OemLogoBitmapFile,
        OemDatumLogoBitmap
    }
};

//
//  Path to the registry key that contains the list of preinstalled
//  drivers (SCSI, keyboard and mouse)
//

PCWSTR szPreinstallKeyName = L"SYSTEM\\Setup\\Preinstall";


//
// Forward references
//
VOID
ProcessOemBitmap(
    IN PWSTR   FilenameAndResId,
    IN SetupBm WhichOne
    );

BOOL
CleanupPreinstalledComponents(
    );



BOOL
InitializePreinstall(
    VOID
    )
{
    WCHAR Buffer[2*MAX_PATH];
    DWORD d;
    int i;

    //
    // Must be run after main initialization. We rely on stuff that is
    // set up there.
    //
    MYASSERT(AnswerFile[0]);

    //
    // Special skip-eula value.  Note that we want this value even if we're not
    // doing a Preinstall.
    //
    GetPrivateProfileString(
        WINNT_UNATTENDED,
        L"OemSkipEula",
        pwNo,
        Buffer,
        sizeof(Buffer)/sizeof(Buffer[0]),
        AnswerFile
        );

    OemSkipEula = (lstrcmpi(Buffer,pwYes) == 0);

    //
    // For the mini-setup case, always be preinstall.
    //
    if( MiniSetup ) {
        Preinstall = TRUE;
    } else {

        MYASSERT(SourcePath[0]);

        //
        // First, figure out whether this is an OEM preinstallation.
        //
        GetPrivateProfileString(
            WINNT_UNATTENDED,
            WINNT_OEMPREINSTALL,
            pwNo,
            Buffer,
            sizeof(Buffer)/sizeof(Buffer[0]),
            AnswerFile
            );

        Preinstall = (lstrcmpi(Buffer,pwYes) == 0);

        //
        // If not preinstallation, nothing more to do.
        //
        if(!Preinstall) {
            return(TRUE);
        }
    }

    //
    // OK, it's preinstsall. Fill in our data table.
    //
    for(i=0; i<OemDatumMax; i++) {

        //
        // Sanity check
        //
        MYASSERT(PreinstUnattendData[i].WhichValue == i);

        //
        // Retrieve data and duplicate. If the value comes back as ""
        // assume it means there is no value in there.
        //
        GetPrivateProfileString(
            PreinstUnattendData[i].Section,
            PreinstUnattendData[i].Key,
            PreinstUnattendData[i].Default ? PreinstUnattendData[i].Default : NULL,
            Buffer,
            sizeof(Buffer)/sizeof(Buffer[0]),
            PreinstUnattendData[i].Filename ? PreinstUnattendData[i].Filename : AnswerFile
            );

        *PreinstUnattendData[i].Value = Buffer[0] ? pSetupDuplicateString(Buffer) : NULL;
        if(Buffer[0] && (*PreinstUnattendData[i].Value == NULL)) {
            //
            // Out of memory.
            //
            pSetupOutOfMemory(MainWindowHandle);
            return(FALSE);
        }
    }

    //
    // Change the banner text, if the OEM supplied new text.
    // Make sure our product name is in there.
    //
    if(OemBannerText) {

        if(wcsstr(OemBannerText,L"Windows NT") ||
           wcsstr(OemBannerText,L"BackOffice")) {
            //
            // Substitute * with \n
            //
            for(i=0; OemBannerText[i]; i++) {
                if(OemBannerText[i] == L'*') {
                    OemBannerText[i] = L'\n';
                }
            }
#if 0
            //
            // Disable the banner for now.
            //
            SendMessage(MainWindowHandle,WM_NEWBITMAP,SetupBmBanner,(LPARAM)OemBannerText);
#endif
        } else {
            MyFree(OemBannerText);
            OemBannerText = NULL;
        }
    }

    //
    // Load the OEM background bitmap, if any.
    // Load the OEM logo bitmap, if any.
    //
    ProcessOemBitmap(OemBackgroundBitmapFile,SetupBmBackground);
    ProcessOemBitmap(OemLogoBitmapFile,SetupBmLogo);

    //
    // Repaint the main window. Specify that the background should be erased
    // because the main window relies on this behavior.
    //
    InvalidateRect(MainWindowHandle,NULL,TRUE);
    UpdateWindow(MainWindowHandle);

    CleanupPreinstalledComponents();
    return(TRUE);
}


VOID
ProcessOemBitmap(
    IN PWSTR   FilenameAndResId,
    IN SetupBm WhichOne
    )

/*++

Routine Description:

    This routine processes a single oem bitmap specification.

    The OEM bitmap may either be in a resource file or in a standalone
    bitmap file. Once the bitmap has been loaded the main window
    is told about it.

Arguments:

    FileNameAndResId - specifies a profile string with either one
        or 2 fields. If the string contains a comma, it is assumed to be
        the name of a DLL followed by a resource ID. The dll is loaded
        from the $OEM$\OEMFILES directory and then we call LoadBitmap
        with the given resource id, which is a base-10 string of ascii digits.
        The string is split at the comma during this routine.
        If this parameter does not contain a comma then it is assumed to be
        the name of a .bmp in $OEM$\OEMFILES and we load it via LoadImage().

    WhichOne - supplies a value indicating which bitmap this is.

Return Value:

    None.

--*/

{
    HINSTANCE ModuleHandle;
    PWCHAR p,q;
    HBITMAP Bitmap;
    WCHAR Buffer[MAX_PATH];
    DWORD Result;

    if(FilenameAndResId) {

        Bitmap = NULL;

        if( !MiniSetup ) {
            lstrcpy(Buffer,SourcePath);
            pSetupConcatenatePaths(Buffer,WINNT_OEM_DIR,MAX_PATH,NULL);
        } else {
            //
            // If we're doing a mini-install, look for the bmp in
            // the \sysprep directory on the drive where NT is
            // installed, not $OEM$
            //
            Result = GetWindowsDirectory( Buffer, MAX_PATH );
            if( Result == 0) {
                MYASSERT(FALSE);
                return;
            }
            Buffer[3] = 0;
            pSetupConcatenatePaths( Buffer, TEXT("sysprep"), MAX_PATH, NULL );
        }

        if(p = wcschr(FilenameAndResId,L',')) {

            q = p;
            //
            // Skip backwards over spaces and quotes. The text setup ini file writer
            // will create a line like
            //
            //      a = "b","c"
            //
            // whose RHS comes back as
            //
            //      b","c
            //
            // since the profile APIs strip off the outermost quotes.
            //
            //
            while((q > FilenameAndResId) && ((*(q-1) == L'\"') || iswspace(*(q-1)))) {
                q--;
            }
            *q = 0;

            q = p+1;
            while(*q && ((*q == L'\"') || iswspace(*q))) {
                q++;
            }

            pSetupConcatenatePaths(Buffer,FilenameAndResId,MAX_PATH,NULL);

            if(ModuleHandle = LoadLibraryEx(Buffer,NULL,LOAD_LIBRARY_AS_DATAFILE)) {

                Bitmap = LoadBitmap(ModuleHandle,MAKEINTRESOURCE(wcstoul(q,NULL,10)));
                FreeLibrary(ModuleHandle);
            }
        } else {
            pSetupConcatenatePaths(Buffer,FilenameAndResId,MAX_PATH,NULL);

            Bitmap = (HBITMAP)LoadImage(NULL,Buffer,IMAGE_BITMAP,0,0,LR_LOADFROMFILE);
        }

        if(Bitmap) {
            //
            // Got a valid bitmap. Tell main window about it.
            //
            SendMessage(MainWindowHandle,WM_NEWBITMAP,WhichOne,(LPARAM)Bitmap);
        }
    }
}

LONG
ExaminePreinstalledComponent(
    IN  HKEY       hPreinstall,
    IN  SC_HANDLE  hSC,
    IN  PCWSTR     ServiceName
    )

/*++

Routine Description:

    Query a preinstalled component, and disable it if necessary.
    If the component is an OEM component, and is running, then disable
    any associated service, if necessary.

Arguments:

    hPreinstall - Handle to the key SYSTEM\Setup\Preinstall.

    hSC - Handle to the Service Control Manager.

    ServiceName - Name of the service to be examined.

Return Value:

    Returns a Win32 error code indicating the outcome of the operation.

--*/

{
    BOOL            OemComponent;
    HKEY            Key;
    LONG            Error;
    DWORD           cbData;
    WCHAR           Data[ MAX_PATH + 1];
    DWORD           Type;
    SC_HANDLE       hSCService;
    SERVICE_STATUS  ServiceStatus;

    //
    //  Open the key that contains the info about the preinstalled component.
    //

    Error = RegOpenKeyEx( hPreinstall,
                          ServiceName,
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    //  Find out if the component is an OEM or RETAIL
    //
    cbData = sizeof(Data);
    Error = RegQueryValueEx( Key,
                             L"OemComponent",
                             0,
                             &Type,
                             ( LPBYTE )Data,
                             &cbData );
    if( Error != ERROR_SUCCESS ) {
        RegCloseKey( Key );
        return( Error );
    }

    OemComponent = (*((PULONG)Data) == 1);

    if( OemComponent ) {
        //
        //  Get the name of the retail service to disable
        //
        cbData = sizeof(Data);
        Error = RegQueryValueEx( Key,
                                 L"RetailClassToDisable",
                                 0,
                                 &Type,
                                 ( LPBYTE )Data,
                                 &cbData );
        if( Error != ERROR_SUCCESS ) {
            *(( PWCHAR )Data) = '\0';
        }
    }
    RegCloseKey( Key );

    //
    //  Query the service
    //
    hSCService = OpenService( hSC,
                              ServiceName,
                              SERVICE_QUERY_STATUS );

    if( hSCService == NULL ) {
        Error = GetLastError();
        return( Error );
    }
    if( !QueryServiceStatus( hSCService,
                             &ServiceStatus ) ) {
        Error = GetLastError();
        return( Error );
    }
    CloseServiceHandle( hSCService );
    if( ServiceStatus.dwCurrentState == SERVICE_STOPPED ) {
        //
        //  Due to the nature of the services that were pre-installed,
        //  we can assume that the service failed to initialize, and that
        //  it can be disabled.
        //
        MyChangeServiceStart( ServiceName,
                              SERVICE_DISABLED );
    } else {
        if( OemComponent &&
            ( lstrlen( (PCWSTR)Data ) != 0 ) ) {
            MyChangeServiceStart( (PCWSTR)Data,
                                  SERVICE_DISABLED );
        }
    }

    return( ERROR_SUCCESS );
}

BOOL
CleanupPreinstalledComponents(
    )

/*++

Routine Description:

    Query the preinstalled components, and disable the ones that
    failed to start.
    This is done by enumerating the subkeys of SYSTEM\Setup\Preinstall.
    Each subkey represents a SCSI, Keyboard or Mouse installed.
    The video drivers are not listed here. The "Display" applet will
    determine and disable the video drivers that were preinstalled, but
    failed to start.

Arguments:

    None.

Return Value:

    Returns TRUE if the operation succeeded, or FALSE otherwise.

--*/

{
    LONG            Error;
    LONG            SavedError;
    HKEY            Key;
    HKEY            SubKeyHandle;
    ULONG           i;
    ULONG           SubKeys;
    WCHAR           SubKeyName[ MAX_PATH + 1 ];
    ULONG           NameSize;
    FILETIME        LastWriteTime;
    SC_HANDLE       hSC;

    EnableEventlogPopup();
    //
    //  Find out the number of subkeys of SYSTEM\Setup\Preinstall
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szPreinstallKeyName,
                          0,
                          KEY_READ,
                          &Key );

    if( Error != ERROR_SUCCESS ) {
        //
        //  If the key doesn't exist, then assume no driver to preinstall,
        //  and return TRUE.
        //
        return( Error == ERROR_FILE_NOT_FOUND );
    }

    Error = RegQueryInfoKey( Key,
                             NULL,
                             NULL,
                             NULL,
                             &SubKeys,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );

    if( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    //  If there are no subkeys, then assume no driver to preinstall
    //
    if( SubKeys == 0 ) {
        return( TRUE );
    }

    //
    //  Get a handle to the service control manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        Error = GetLastError();
        return( FALSE );
    }

    //
    //  Query each SCSI, keyboard and mouse driver that was preinstalled
    //  and disable it if necessary.
    //
    SavedError = ERROR_SUCCESS;
    for( i = 0; i < SubKeys; i++ ) {
        NameSize = sizeof( SubKeyName ) / sizeof( WCHAR );
        Error = RegEnumKeyEx( Key,
                              i,
                              SubKeyName,
                              &NameSize,
                              NULL,
                              NULL,
                              NULL,
                              &LastWriteTime );
        if( Error != ERROR_SUCCESS ) {
            if( SavedError == ERROR_SUCCESS ) {
                SavedError = Error;
            }
            continue;
        }

        Error = ExaminePreinstalledComponent( Key,
                                              hSC,
                                              SubKeyName );
        if( Error != ERROR_SUCCESS ) {
            if( SavedError == ERROR_SUCCESS ) {
                SavedError = Error;
            }
            // continue;
        }
    }
    RegCloseKey( Key );
    //
    //  At this point we can remove the Setup\Preinstall key
    //
    //  DeletePreinstallKey();
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\Setup",
                          0,
                          MAXIMUM_ALLOWED,
                          &Key );
    if( Error == ERROR_SUCCESS ) {
        pSetupRegistryDelnode( Key, L"Preinstall" );
        RegCloseKey( Key );
    }
    return( TRUE );
}

BOOL
EnableEventlogPopup(
    VOID
    )

/*++

Routine Description:

    Delete from the registry the value entry that disables the error
    popups displayed by the eventlog, if one or more pre-installed
    driver failed to load.
    This value entry is created in the registry during textmode setup.

Arguments:

    None.

Return Value:

    Returns TRUE if the operation succeeded, or FALSE otherwise.

--*/

{
    HKEY    hKey = 0;
    ULONG   Error;

    //
    // Delete the 'NoPopupsOnBoot' value
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          L"SYSTEM\\CurrentControlSet\\Control\\Windows",
                          0,
                          KEY_SET_VALUE,
                          &hKey );

    if(Error == NO_ERROR) {
        Error = RegDeleteValue(hKey,
                               L"NoPopupsOnBoot");
    }
    if (hKey) {
        RegCloseKey(hKey);
    }
    return( Error == ERROR_SUCCESS );
}


BOOL
ExecutePreinstallCommands(
    VOID
    )

/*++

Routine Description:

    Executes all commands specified in the file $OEM$\OEMFILES\cmdlines.txt.

Arguments:

    None.

Return Value:

    Returns TRUE if the operation succeeded, or FALSE otherwise.

--*/

{
    WCHAR OldCurrentDir[MAX_PATH];
    WCHAR FileName[MAX_PATH];
    HINF CmdlinesTxtInf;
    LONG LineCount,LineNo;
    INFCONTEXT InfContext;
    PCWSTR CommandLine;
    DWORD DontCare;
    BOOL AnyError;
    PCWSTR SectionName;

    //
    // Set current directory to $OEM$.
    // Preserve current directory to minimize side-effects.
    //
    if(!GetCurrentDirectory(MAX_PATH,OldCurrentDir)) {
        OldCurrentDir[0] = 0;
    }
    lstrcpy(FileName,SourcePath);
    pSetupConcatenatePaths(FileName,WINNT_OEM_DIR,MAX_PATH,NULL);
    SetCurrentDirectory(FileName);

    //
    // Form name of cmdlines.txt and see if it exists.
    //
    pSetupConcatenatePaths(FileName,WINNT_OEM_CMDLINE_LIST,MAX_PATH,NULL);
    AnyError = FALSE;
    if(FileExists(FileName,NULL)) {

        CmdlinesTxtInf = SetupOpenInfFile(FileName,NULL,INF_STYLE_OLDNT,NULL);
        if(CmdlinesTxtInf == INVALID_HANDLE_VALUE) {
            //
            // The file exists but is invalid.
            //
            AnyError = TRUE;
        } else {
            //
            // Get the number of lines in the section that contains the commands to
            // be executed. The section may be empty or non-existant; this is not
            // an error condition. In that case LineCount may be -1 or 0.
            //
            SectionName = L"Commands";
            LineCount = SetupGetLineCount(CmdlinesTxtInf,SectionName);

            for(LineNo=0; LineNo<LineCount; LineNo++) {

                if(SetupGetLineByIndex(CmdlinesTxtInf,SectionName,(DWORD)LineNo,&InfContext)
                && (CommandLine = pSetupGetField(&InfContext,1))) {
                    if(!InvokeExternalApplication(NULL,CommandLine,&DontCare)) {
                        AnyError = TRUE;
                    }
                } else {
                    //
                    // Strange case, inf is messed up
                    //
                    AnyError = TRUE;
                }
            }
        }
    }

    //
    // Reset current directory and return.
    //
    if(OldCurrentDir[0]) {
        SetCurrentDirectory(OldCurrentDir);
    }

    if(AnyError) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OEMPRE_FAIL,
            NULL,NULL);
    }

    return(!AnyError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\printer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    printer.c

Abstract:

    Routines to deal with printer/spooler.

Author:

    Ted Miller (tedm) 5-Apr-1995
    adapted from legacy\dll\printer.c

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// Name of spooler service.
//
PCWSTR szSpooler = L"Spooler";


BOOL
MiscSpoolerInit(
    VOID
    )
{
    MONITOR_INFO_2  MonitorInfo2;
    PROVIDOR_INFO_1 ProviderInfo1;
    BOOL b;
    WCHAR MonitorName[128];

    MonitorInfo2.pName = L"Local Port";
    MonitorInfo2.pEnvironment = NULL;
    MonitorInfo2.pDLLName = L"localmon.dll";

    b = TRUE;

    if(!AddMonitor(NULL,2,(PBYTE)&MonitorInfo2)) {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_MISCSPOOLERINIT, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"AddMonitor",
            GetLastError(),
            NULL,NULL);
    }

    if(!AddPrintProcessor(NULL,NULL,L"winprint.dll",L"winprint")) {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_MISCSPOOLERINIT, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"AddPrintProcessor",
            GetLastError(),
            NULL,NULL);
    }

    ProviderInfo1.pName         = L"Internet Print Provider";
    ProviderInfo1.pEnvironment  = NULL;
    ProviderInfo1.pDLLName      = L"inetpp.dll";

    if ( !AddPrintProvidor(NULL, 1, (LPBYTE)(&ProviderInfo1)) ) {

        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_MISCSPOOLERINIT, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"AddPrintProvidor",
            GetLastError(),
            NULL,NULL);
    }

    return(TRUE);
}


BOOL
StartSpooler(
    VOID
    )
{
#define SLEEP_TIME 4000
#define LOOP_COUNT 30
    SC_HANDLE hSC,hSCService;
    BOOL b;
    DWORD d;
    DWORD dwDesiredAccess;


    b = FALSE;
    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    d = GetLastError();

    if(hSC == NULL) {
        SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_STARTSVC_FAIL,
                szSpooler, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_WINERR,
                szOpenSCManager,
                d,
                NULL,NULL);
        return(FALSE);
    }

    dwDesiredAccess = SERVICE_START | SERVICE_QUERY_STATUS;
    if(hSCService = OpenService(hSC,szSpooler,dwDesiredAccess)) {
        SetupDebugPrint1( L"StartSpooler: Just opened service %s", szSpooler);
        b = StartService(hSCService,0,NULL);
        d = GetLastError();
        SetupDebugPrint3( L"StartSpooler: Just started service %s, ret=%d, error=%d", szSpooler, b, d);
        if(!b) {
            if( d  == ERROR_SERVICE_ALREADY_RUNNING) {
                //
                // Service is already running.
                //
                b = TRUE;
            } else if (d == ERROR_SERVICE_DATABASE_LOCKED) {
                LPQUERY_SERVICE_LOCK_STATUS lpqslsBuf;
                DWORD dwBytesNeeded;
                DWORD loopCount = 0;

                lpqslsBuf = (LPQUERY_SERVICE_LOCK_STATUS) MyMalloc( sizeof(QUERY_SERVICE_LOCK_STATUS)+256);
                if( lpqslsBuf) {
                    do {
                        // Lets query the lock status before we attempt to StartService
                        b = QueryServiceLockStatus( 
                                hSC,
                                lpqslsBuf,
                                sizeof(QUERY_SERVICE_LOCK_STATUS)+256,
                                &dwBytesNeeded);
                        d = GetLastError();
                        if ( !b ) {
                            // Not a critical error but log it.
                            SetupDebugPrint2( L"StartSpooler: Could Not QueryServiceLockStatus %s, Error=%d", szSpooler, d);
                        }
                        // Now retry StartService
                        b = StartService(hSCService,0,NULL);
                        d = GetLastError();
                        SetupDebugPrint5( L"StartSpooler: Start service %s, database was locked by %s, duration=%d, lockstatus=%d, error=%d", szSpooler, lpqslsBuf->lpLockOwner, lpqslsBuf->dwLockDuration, lpqslsBuf->fIsLocked, d);
                        if (!b) {
                            // Could not StartService
                            if ( loopCount++ == LOOP_COUNT) {
                                SetupDebugPrint5( L"StartSpooler: Timeout. Start service %s, database was locked by %s, duration=%d, lockstatus=%d, error=%d", szSpooler, lpqslsBuf->lpLockOwner, lpqslsBuf->dwLockDuration, lpqslsBuf->fIsLocked, d);
                                if( d  == ERROR_SERVICE_ALREADY_RUNNING) {
                                    b = TRUE;
                                } else {
                                    SetuplogError(
                                        LogSevWarning,
                                        SETUPLOG_USE_MESSAGEID,
                                        MSG_LOG_STARTSVC_FAIL,
                                        szSpooler, NULL,
                                        SETUPLOG_USE_MESSAGEID,
                                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                                        szStartService,
                                        WAIT_TIMEOUT,
                                        szSpooler,
                                        NULL,NULL);
                                    SetuplogError(
                                        LogSevWarning,
                                        SETUPLOG_USE_MESSAGEID,
                                        MSG_LOG_STARTSVC_FAIL,
                                        szSpooler, NULL,
                                        SETUPLOG_USE_MESSAGEID,
                                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                                        szStartService,
                                        ERROR_SERVICE_DATABASE_LOCKED,
                                        szSpooler,
                                        NULL,NULL);
                                }
                                break;
                            }
                            else {
                                SetupDebugPrint2( L"StartSpooler: Sleeping. service %s, count=%d", szSpooler, loopCount);
                                Sleep( SLEEP_TIME );
                            }
                        }
                        else {
                            // StartService succeeded this time.
                            SetupDebugPrint4( L"StartSpooler: Had to retry start service %s, database was locked by %s, duration=%d, lockstatus=%d", szSpooler, lpqslsBuf->lpLockOwner, lpqslsBuf->dwLockDuration, lpqslsBuf->fIsLocked);
                            break;
                        }
                    } while ( TRUE );
                    MyFree( lpqslsBuf);
                } else {
                    SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_STARTSVC_FAIL,
                        szSpooler, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_X_PARAM_RETURNED_WINERR,
                        szStartService,
                        ERROR_NOT_ENOUGH_MEMORY,
                        szSpooler,
                        NULL,NULL);
                }
            
            } else {
                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_STARTSVC_FAIL,
                    szSpooler, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_PARAM_RETURNED_WINERR,
                    szStartService,
                    d,
                    szSpooler,
                    NULL,NULL);
            }
        }
        CloseServiceHandle(hSCService);
    } else {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_STARTSVC_FAIL,
            szSpooler, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenService,
            GetLastError(),
            szSpooler,
            NULL,NULL);
    }

    CloseServiceHandle(hSC);
    SetupDebugPrint1( L"StartSpooler: Just closed service handler %s", szSpooler);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\oobe.c ===
#include "setupp.h"
#pragma hdrstop


#define INTL_ANSWER_FILE        L"intl.txt"
#define INTL_LANG_SECTION       L"regionalsettings"
#define INTL_LOCALE             L"userlocale"
#define INTL_KEYBOARD           L"inputlocale"

// This turns on some debug spew that lists all the available locales, geo
// locations, and keyboards.
#define INTL_LIST_OPTIONS   0

#define LANG_LIST_INCREMENT   10
POOBE_LOCALE_INFO   LanguageList = NULL;
DWORD   LanguageListSize;
DWORD   LanguageIndex;
DWORD   DefaultID;
DWORD   DefaultIndex;

typedef struct tagPHONEENTRY {
    LPWSTR  Country;
    LPWSTR  TollFreeNumber;
    LPWSTR  TollNumber;
} PHONEENTRY, *PPHONEENTRY;

PWSTR   PhoneList = NULL;
DWORD   PhoneListSize;
DWORD   PhoneListLength;


//
// Boolean value indicating whether we're doing a subset of gui-mode setup.
//
BOOL OobeSetup = FALSE;

//
// We need a global variable for OCM, coresponding to the local variable in
// InstallWindowsNT().
//
#ifdef _OCM
    PVOID g_OcManagerContext;
#endif


BOOL
WINAPI
SetupGetProductType(
    PWSTR   Product,
    PDWORD  pSkuFlags
    )
{
    Product[0] = 0;
    *pSkuFlags = 0;
    return TRUE;
}


PID3_RESULT
WINAPI
SetupPidGen3(
    PWSTR   Pid3,
    DWORD   SkuFlags,
    PWSTR   OemId,
    BOOL    Batch,
    PWSTR   Pid2,
    LPBYTE  lpPid3,
    LPBOOL  Compliance
    )
{
    if ( !InitializePidVariables() ) {
        SetupDebugPrint( L"SETUP: InitializePidVariables failed" );
        return PID_INVALID;
    }

    if ( !SetPid30Variables( Pid3 ) ) {
        SetupDebugPrint( L"SETUP: SetPid30Variables failed" );
        return PID_INVALID;
    }

    if ( !ValidateAndSetPid30() ) {
        SetupDebugPrint( L"SETUP: ValidateAndSetPid30 failed" );
        return PID_INVALID;
    }

    if(!SetProductIdInRegistry()) {
        SetupDebugPrint( L"SETUP: SetProductIdInRegistry failed" );
        return PID_INVALID;
    }

    return PID_VALID;
}


BOOL
WINAPI
SetupGetValidEula(
    PCWSTR  Eula,
    PWSTR   Path
    )
{
    return TRUE;
}


BOOL
CheckLangListSize(
    DWORD   StructSize
    )
{
    PVOID   NewList;


    //
    // Check to make sure the LanguageList has at least 1 unused element.
    // If not, make it bigger.
    //
    if ( LanguageIndex == LanguageListSize ) {

        LanguageListSize *= 2;
        NewList = MyRealloc(
            LanguageList,
            LanguageListSize * StructSize
            );

        if ( NewList ) {
            LanguageList = NewList;
        } else {
            return FALSE;
        }
    }
    return TRUE;
}


VOID
WINAPI
SetupDestroyLanguageList(
    IN      POOBE_LOCALE_INFO   LanguageList,
    IN      DWORD               Count
    )
{
    DWORD   i;


    if ( LanguageList ) {
        for ( i=0; i < Count; i++ ) {
            if ( LanguageList + i ) {
                MyFree( LanguageList[i].Name );
            }
        }

        MyFree( LanguageList );
    }
}


BOOL
CALLBACK
EnumLocalesProc(
    PWSTR pszLocale
    )
{
    BOOL    b;
    LCID    Locale;
    TCHAR   LanguageName[128];
    POOBE_LOCALE_INFO   pLocaleInfo;


    Locale = wcstoul (pszLocale, NULL, 16);

    b = GetLocaleInfo (
        Locale,
        LOCALE_SLANGUAGE | LOCALE_NOUSEROVERRIDE,
        LanguageName,
        sizeof(LanguageName) / sizeof(TCHAR)
        );
    MYASSERT(b);
    if ( !b ) {
        return FALSE;
    }

    //
    // Add it to our global array
    //
    if ( !CheckLangListSize( sizeof(OOBE_LOCALE_INFO) ) ) {
        SetupDestroyLanguageList( LanguageList, LanguageIndex );
        LanguageList = NULL;
        return FALSE;
    }
    pLocaleInfo = (POOBE_LOCALE_INFO)LanguageList + LanguageIndex;
    pLocaleInfo->Name = MyMalloc( (lstrlen(LanguageName) + 1) * sizeof(TCHAR) );
    if ( !pLocaleInfo->Name ) {
        SetupDestroyLanguageList( LanguageList, LanguageIndex );
        LanguageList = NULL;
        return FALSE;
    }

    lstrcpy( pLocaleInfo->Name, LanguageName );
    pLocaleInfo->Id = Locale;
    pLocaleInfo->Installed = IsValidLocale(
        Locale,
        LCID_INSTALLED
        );

    if ( Locale == DefaultID ) {
        DefaultIndex = LanguageIndex;
    }

    LanguageIndex++;

    return TRUE;
}


int
__cdecl
LocaleCompare(
    const void *arg1,
    const void *arg2
    )
{
   return lstrcmp(
       ((POOBE_LOCALE_INFO)arg1)->Name,
       ((POOBE_LOCALE_INFO)arg2)->Name
       );
}


BOOL
WINAPI
SetupGetLocaleOptions(
    IN      DWORD   OptionalDefault,
    OUT     POOBE_LOCALE_INFO   *ReturnList,
    OUT     PDWORD  Items,
    OUT     PDWORD  Default
    )
{
    BOOL    bReturn = FALSE;
    DWORD   i;


    //
    // Init our global variables
    //
    ASSERT_HEAP_IS_VALID();
    *ReturnList = NULL;


    MYASSERT( LanguageList == NULL );
    LanguageListSize = LANG_LIST_INCREMENT;
    LanguageList = MyMalloc( LanguageListSize * sizeof(OOBE_LOCALE_INFO));
    if ( !LanguageList ) {
        goto exit;
    }
    LanguageIndex = 0;
    DefaultID = OptionalDefault ? OptionalDefault : GetUserDefaultLCID();
    DefaultIndex = 0;

    EnumSystemLocales ( EnumLocalesProc , LCID_INSTALLED );

    if ( LanguageList ) {

        // Success
        qsort(
            LanguageList,
            LanguageIndex,
            sizeof( OOBE_LOCALE_INFO ),
            LocaleCompare
            );
        for (i=0; i<LanguageIndex; i++) {
            if (LanguageList[i].Id == DefaultID) {
                DefaultIndex = i;
                break;
            }
        }

#if INTL_LIST_OPTIONS
        for (i=0; i<LanguageIndex; i++) {
            SetupDebugPrint2( L"Setup: SetupGetLocaleOptions|%x|%s",
                LanguageList[i].Id,
                LanguageList[i].Name );

        }
#endif

        *ReturnList = LanguageList;
        LanguageList = NULL;
        *Items = LanguageIndex;
        *Default = DefaultIndex;
        bReturn = TRUE;
    }

exit:
    ASSERT_HEAP_IS_VALID();
    return bReturn;
}


BOOL
CALLBACK
EnumGeoInfoProc(
    GEOID GeoID
    )
{
    TCHAR   pData[128];
    POOBE_LOCALE_INFO   pGeoInfo;


    //
    // Add it to our global array
    //
    if ( !CheckLangListSize( sizeof(OOBE_LOCALE_INFO) ) ) {
        SetupDestroyLanguageList( LanguageList, LanguageIndex );
        LanguageList = NULL;
        return FALSE;
    }

    if( !GetGeoInfo(
        GeoID,
        GEO_FRIENDLYNAME,
        pData,
        sizeof(pData) / sizeof(TCHAR),
        0
        )) {

        // Skip this one.
        MYASSERT(0);
        return TRUE;
    }

    pGeoInfo = (POOBE_LOCALE_INFO)LanguageList + LanguageIndex;
    pGeoInfo->Name = MyMalloc( (lstrlen(pData) + 1) * sizeof(TCHAR) );
    if ( !pGeoInfo->Name ) {
        SetupDestroyLanguageList( LanguageList, LanguageIndex );
        LanguageList = NULL;
        return FALSE;
    }

    lstrcpy( pGeoInfo->Name, pData );
    pGeoInfo->Id = GeoID;
    pGeoInfo->Installed = TRUE;

    if ( GeoID == (GEOID)DefaultID ) {
        DefaultIndex = LanguageIndex;
    }
    LanguageIndex++;

    return TRUE;
}


BOOL
WINAPI
SetupGetGeoOptions(
    IN      DWORD   OptionalDefault,
    OUT     POOBE_LOCALE_INFO   *ReturnList,
    OUT     PDWORD  Items,
    OUT     PDWORD  Default
    )
{
    BOOL    bReturn = FALSE;
    DWORD   i;


    //
    // Init our global variables
    //
    ASSERT_HEAP_IS_VALID();
    *ReturnList = NULL;

    MYASSERT( LanguageList == NULL );
    LanguageListSize = LANG_LIST_INCREMENT;
    LanguageList = MyMalloc( LanguageListSize * sizeof(OOBE_LOCALE_INFO));
    if ( !LanguageList ) {
        goto exit;
    }
    LanguageIndex = 0;
    DefaultID = OptionalDefault ? OptionalDefault : GetUserGeoID( GEOCLASS_NATION );
    DefaultIndex = 0;

    bReturn = EnumSystemGeoID(
        GEOCLASS_NATION,
        0,
        EnumGeoInfoProc
        );
    MYASSERT(bReturn);

    if ( bReturn && LanguageList ) {
        // Success
        qsort(
            LanguageList,
            LanguageIndex,
            sizeof( OOBE_LOCALE_INFO ),
            LocaleCompare
            );
        for (i=0; i<LanguageIndex; i++) {
            if (LanguageList[i].Id == DefaultID) {
                DefaultIndex = i;
                break;
            }
        }
#if INTL_LIST_OPTIONS
        for (i=0; i<LanguageIndex; i++) {
            SetupDebugPrint2( L"Setup: SetupGetGeoOptions|%d|%s",
                LanguageList[i].Id,
                LanguageList[i].Name );
        }
#endif

        bReturn = TRUE;
        *ReturnList = LanguageList;
        LanguageList = NULL;
        *Items = LanguageIndex;
        *Default = DefaultIndex;
    }

exit:
    ASSERT_HEAP_IS_VALID();
    return bReturn;
}


BOOL
WINAPI
SetupGetKeyboardOptions(
    IN      DWORD   OptionalDefault,
    OUT     POOBE_LOCALE_INFO   *ReturnList,
    OUT     PDWORD  Items,
    OUT     PDWORD  Default
    )
{
    DWORD       DefaultKeyboard;
    DWORD       i;
    BOOL        bReturn = FALSE;
    TCHAR       pData[128];
    TCHAR       Substitute[9];
    POOBE_LOCALE_INFO   pLocaleInfo;
    DWORD       rc;
    HKEY        hLangKey = NULL;
    HKEY        hLangSubKey = NULL;
    DWORD       Index;
    TCHAR       SubKeyName[9];
    DWORD       SubKeyNameLength;
    DWORD       DataSize;
    DWORD       Type;


    //
    // Initialize our variables
    //
    ASSERT_HEAP_IS_VALID();
    *ReturnList = NULL;

    MYASSERT( LanguageList == NULL );
    LanguageListSize = LANG_LIST_INCREMENT;
    LanguageList = MyMalloc( LanguageListSize * sizeof(OOBE_LOCALE_INFO));
    if ( !LanguageList ) {
        goto exit;
    }
    LanguageIndex = 0;
    // DefaultIndex = -1;
    *Default = 0;

    if (OptionalDefault) {
        DefaultKeyboard = OptionalDefault;

    } else {
        //
        // Lookup default keyboard in the registry
        //
        rc = RegOpenKeyEx( HKEY_USERS,
                           L".DEFAULT\\Keyboard Layout\\Preload",
                           0,
                           KEY_READ,
                           &hLangKey );
        if( rc != NO_ERROR ) {
            SetupDebugPrint1( L"Setup: SetupGetKeyboardOptions - RegOpenKeyEx(.DEFAULT\\Keyboard Layout\\Preload) failed (%d)", rc );
            MYASSERT(0);
            goto exit;
        }

        DataSize = sizeof(pData);
        rc = RegQueryValueEx(
            hLangKey,
            L"1",
            NULL,
            &Type,
            (LPBYTE)pData,
            &DataSize
            );
        RegCloseKey( hLangKey );
        hLangKey = NULL;

        if( rc != NO_ERROR ) {
            SetupDebugPrint1( L"Setup: SetupGetKeyboardOptions - RegQueryValueEx(1) failed (%d)", rc );
            MYASSERT(0);
            goto exit;
        }

        DefaultKeyboard = wcstoul( pData, NULL, 16 );

        //
        // Now we look in the Substitutes key to see whether there is a
        // substitute there.
        //
        if( RegOpenKeyEx( HKEY_USERS,
                          L".DEFAULT\\Keyboard Layout\\Substitutes",
                          0,
                          KEY_READ,
                          &hLangKey ) == NO_ERROR) {

            DataSize = sizeof(Substitute);
            if( (RegQueryValueEx( hLangKey,
                                  pData,
                                  NULL,
                                  &Type,
                                  (LPBYTE)Substitute,
                                  &DataSize ) == NO_ERROR) &&
                (Type == REG_SZ)
                ) {

                DefaultKeyboard = wcstoul( Substitute, NULL, 16 );
            }

            RegCloseKey(hLangKey);
            hLangKey = NULL;
        }
    }

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Control\\Keyboard Layouts",
                       0,
                       KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                       &hLangKey );
    if( rc != NO_ERROR ) {
        SetupDebugPrint1( L"Setup: SetupGetKeyboardOptions - RegOpenKeyEx(System\\CurrentControlSet\\Control\\Keyboard Layouts) failed (%d)", rc );
        goto exit;
    }

    for( Index = 0; ; Index++ ) {

        SubKeyNameLength = sizeof(SubKeyName) / sizeof(TCHAR);

        rc = RegEnumKeyEx( hLangKey,
                           Index,
                           SubKeyName,
                           &SubKeyNameLength,
                           NULL,
                           NULL,
                           NULL,
                           NULL );

        //
        // Did we error?
        //
        if( rc != ERROR_SUCCESS ) {

            //
            // Are we done?
            //
            if( rc != ERROR_NO_MORE_ITEMS ) {
                SetupDebugPrint2( L"Setup: SetupGetKeyboardOptions - RegEnumKeyEx failed (%d).  Index = %d", rc, Index );
                MYASSERT(0);
            }
            break;
        }

        rc = RegOpenKeyEx( hLangKey,
                           SubKeyName,
                           0,
                           KEY_READ,
                           &hLangSubKey );
        if( rc != NO_ERROR ) {
            SetupDebugPrint2( L"Setup: SetupGetKeyboardOptions - RegOpenKeyEx(%s) failed (%d)", SubKeyName, rc );
            MYASSERT(0);
            continue;
        }

        DataSize = sizeof(pData);
        rc = RegQueryValueEx(
            hLangSubKey,
            L"Layout Text",
            NULL,
            &Type,
            (LPBYTE)pData,
            &DataSize
            );
        RegCloseKey( hLangSubKey );
        hLangSubKey = NULL;

        if( rc != NO_ERROR ) {
            SetupDebugPrint2( L"Setup: SetupGetKeyboardOptions - RegQueryValueEx(Layout Text) for %s failed (%d)", SubKeyName, rc );
            MYASSERT(0);
            continue;
        }

        //
        // Add it to our global array
        //
        if ( !CheckLangListSize( sizeof(OOBE_LOCALE_INFO) ) ) {
            SetupDestroyLanguageList( LanguageList, LanguageIndex );
            LanguageList = NULL;
            goto exit;
        }
        pLocaleInfo = (POOBE_LOCALE_INFO)LanguageList + LanguageIndex;
        pLocaleInfo->Name = MyMalloc( (lstrlen(pData) + 1) * sizeof(TCHAR) );
        if ( !pLocaleInfo->Name ) {
            SetupDestroyLanguageList( LanguageList, LanguageIndex );
            LanguageList = NULL;
            goto exit;
        }

        lstrcpy( pLocaleInfo->Name, pData );
        pLocaleInfo->Id = wcstoul( SubKeyName, NULL, 16 );
        pLocaleInfo->Installed = TRUE;

        LanguageIndex++;
    }

    RegCloseKey( hLangKey );
    hLangKey = NULL;

    qsort(
        LanguageList,
        LanguageIndex,
        sizeof( OOBE_LOCALE_INFO ),
        LocaleCompare
        );
    for (i=0; i<LanguageIndex; i++) {
        if (LanguageList[i].Id == DefaultKeyboard) {
            *Default = i;
            break;
        }
    }

#if INTL_LIST_OPTIONS
        for (i=0; i<LanguageIndex; i++) {
            SetupDebugPrint2( L"Setup: SetupGetKeyboardOptions|%x|%s",
                LanguageList[i].Id,
                LanguageList[i].Name );
        }
#endif

    bReturn = TRUE;
    *ReturnList = LanguageList;
    LanguageList = NULL;
    *Items = LanguageIndex;

exit:
    if ( hLangKey ) {
        RegCloseKey( hLangKey );
     }
    if ( hLangSubKey ) {
        RegCloseKey( hLangSubKey );
    }
    ASSERT_HEAP_IS_VALID();
    return bReturn;
}


BOOL
WINAPI
SetupSetIntlOptions(
    DWORD LocationIndex,
    DWORD LanguageIndex,
    DWORD KeyboardIndex
    )
{
    WCHAR   PathBuffer[MAX_PATH];
    WCHAR   KeyValue[128];
    WCHAR   CmdLine[MAX_PATH];
    BOOL    bResult;


    SetupDebugPrint3(
        L"SetupSetIntlOptions: Location = %d, Language = 0x%08x, Keyboard = 0x%08x",
        LocationIndex,
        LanguageIndex,
        KeyboardIndex );
    GetSystemDirectory( PathBuffer, MAX_PATH );
    pSetupConcatenatePaths( PathBuffer, INTL_ANSWER_FILE, MAX_PATH, NULL );
    DeleteFile( PathBuffer );

    //
    // Write language value
    //
    wsprintf(
        KeyValue,
        L"\"%08x\"",
        LanguageIndex
        );

    WritePrivateProfileString(
        INTL_LANG_SECTION,
        INTL_LOCALE,
        KeyValue,
        PathBuffer
        );

    //
    // Write keyboard value
    //
    wsprintf(
        KeyValue,
        L"\"%04x:%08x\"",
        KeyboardIndex & 0x0000ffff,
        KeyboardIndex
        );

    WritePrivateProfileString(
        INTL_LANG_SECTION,
        INTL_KEYBOARD,
        KeyValue,
        PathBuffer
        );

    //
    // Call intl.cpl to do the work
    //
    wsprintf(
        CmdLine,
        L"/f:\"%s\" /s:\"%s\"",
        PathBuffer,
        LegacySourcePath
        );

    InvokeControlPanelApplet(L"intl.cpl",L"",0,CmdLine);
    DeleteFile( PathBuffer );

    //
    // Set the GEO location
    //
    bResult = SetUserGeoID( LocationIndex );

    if ( !bResult ) {

        SetupDebugPrint1(
            L"SetupSetIntlOptions: SetUserGeoID failed.  Status = %d.",
            GetLastError()
            );
    }
    MYASSERT( bResult );

    return bResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   CompareCntryNameLookUpElements()
//
//  Synopsis:   Function to compare names used by sort
//
//+---------------------------------------------------------------------------
int __cdecl ComparePhoneEntry(const void *e1, const void *e2)
{
    PPHONEENTRY pPhone1 = (PPHONEENTRY)e1;
    PPHONEENTRY pPhone2 = (PPHONEENTRY)e2;

    return CompareStringW(LOCALE_USER_DEFAULT, 0,
        pPhone1->Country, -1,
        pPhone2->Country, -1
        ) - 2;
}

VOID
WINAPI
SetupDestroyPhoneList(
    )
{
    if ( PhoneList ) {
        MyFree( PhoneList );
    }
    PhoneList = NULL;
}

VOID
WINAPI
SetupFreePhoneList(PPHONEENTRY PhoneList, DWORD cbEntries)
{
    DWORD i;
    if ( PhoneList )
    {
        for( i=0; i < cbEntries; i++ )
        {
            GlobalFree(PhoneList[i].Country);
            GlobalFree(PhoneList[i].TollFreeNumber);
            GlobalFree(PhoneList[i].TollNumber);
        }
        GlobalFree(PhoneList);
    }
    PhoneList = NULL;
}


BOOL
AddToPhoneList(
    LPCWSTR Item
    )
{
    PVOID   NewList;
    DWORD   ItemLength = lstrlen(Item);


    if ( !PhoneList ) {

        PhoneListLength = 0;
        PhoneListSize = 1024;
        PhoneList = MyMalloc( PhoneListSize * sizeof(TCHAR) );

    } else if ( PhoneListLength + ItemLength > PhoneListSize ) {

        PhoneListSize *= 2;
        NewList = MyRealloc(
            PhoneList,
            PhoneListSize * sizeof(TCHAR)
            );

        if ( NewList ) {
            PhoneList = NewList;
        } else {
            return FALSE;
        }
    }

    memcpy( PhoneList + PhoneListLength,
            Item,
            ItemLength * sizeof(TCHAR)
            );

    PhoneListLength += ItemLength;

    return TRUE;
}

BOOL MakePhoneListForScript(PPHONEENTRY PhoneList, DWORD cbEntries)
{
    BOOL  bRet = FALSE;
    DWORD i;
    if ( PhoneList )
    {
        for( i=0; i < cbEntries; i++ )
        {
            if (!AddToPhoneList(PhoneList[i].Country) ||
                !AddToPhoneList( TEXT("\t") ) ||
                !AddToPhoneList(PhoneList[i].TollFreeNumber) ||
                !AddToPhoneList( TEXT("\t") ) ||
                !AddToPhoneList(PhoneList[i].TollNumber) ||
                !AddToPhoneList( TEXT("\t") ) )
            {
                goto ExitMakePhoneListForScript;
            }
        }
        bRet = TRUE;
    }
ExitMakePhoneListForScript:
    return bRet;
}

BOOL AddItemToPhoneEntry(LPCWSTR Item,
                         LPWSTR  *pPointer)
{
    BOOL bRet = FALSE;
    if ((Item) && (pPointer))
    {
        *pPointer = (LPWSTR)GlobalAlloc(GPTR, (lstrlen(Item) + 1)*sizeof(TCHAR));
        if (*pPointer)
        {
            lstrcpy(*pPointer, Item);
            bRet = TRUE;
        }
    }
    return bRet;
}


PTSTR
WINAPI
SetupReadPhoneList(
    PWSTR   PhoneInfName
    )
{
    HINF    PhoneInf = NULL;
    DWORD   LineCount;
    DWORD   ItemNo;
    LPCTSTR SectionName;
    INFCONTEXT InfContext;
    BOOL    bSucceeded = FALSE;
    PPHONEENTRY pPhoneList = NULL;

    SetupDebugPrint( L"START: SetupReadPhoneList");
    PhoneList = NULL;

    PhoneInf = SetupOpenInfFile( PhoneInfName, NULL, INF_STYLE_WIN4, NULL );
    if( PhoneInf == INVALID_HANDLE_VALUE ) {
        return NULL;
    }

    SectionName = TEXT("IsoCodes");
    LineCount = SetupGetLineCount( PhoneInf, SectionName );
    if ( !LineCount ) {

        goto ReadPhoneListCleanup;
    }

    pPhoneList = (PPHONEENTRY)GlobalAlloc(GPTR,
                                          (int)(sizeof(PHONEENTRY) * LineCount));

    if (!pPhoneList )
    {
        goto ReadPhoneListCleanup;
    }

    for( ItemNo=0; ItemNo<LineCount; ItemNo++ ) {
        if( SetupGetLineByIndex( PhoneInf, SectionName, ItemNo, &InfContext )) {

            if ( !AddItemToPhoneEntry( pSetupGetField( &InfContext, 4 ), &pPhoneList[ItemNo].Country ) ) {

                goto ReadPhoneListCleanup;
            }
            if ( !AddItemToPhoneEntry( pSetupGetField( &InfContext, 5 ), &pPhoneList[ItemNo].TollFreeNumber ) ) {

                goto ReadPhoneListCleanup;
            }
            if ( !AddItemToPhoneEntry( pSetupGetField( &InfContext, 6 ), &pPhoneList[ItemNo].TollNumber ) ) {

                goto ReadPhoneListCleanup;
            }
        }
    }

    // sort the array
    qsort(pPhoneList, (int)LineCount,sizeof(PHONEENTRY),
      ComparePhoneEntry);


    // Convert the array into a TAB delimited list for script.
    if (MakePhoneListForScript(pPhoneList,LineCount))
    {
        //
        // Replace the final TAB with a NUL.
        //
        PhoneList[PhoneListLength-1] = '\0';

        bSucceeded = TRUE;
    }

ReadPhoneListCleanup:

    if (pPhoneList)
    {
        SetupFreePhoneList(pPhoneList,LineCount);
    }
    SetupCloseInfFile( PhoneInf );

    SetupDebugPrint( L"END: SetupReadPhoneList");
    if ( bSucceeded ) {
        return PhoneList;
    } else {
        SetupDestroyPhoneList();
        return NULL;
    }
}


//
// Read INF to map a TAPI country id to a 3 letter ISO code.
//
VOID
SetupMapTapiToIso (
    IN  PWSTR   PhoneInfName,
    IN  DWORD   dwCountryID,
    OUT PWSTR   szIsoCode
    )
{
    HINF        PhoneInf;
    WCHAR       szCountryID[9];
    BOOL        bResult;
    INFCONTEXT  Context;


    szIsoCode[0] = L'\0';
    PhoneInf = SetupOpenInfFile( PhoneInfName, NULL, INF_STYLE_WIN4, NULL );
    if( PhoneInf == INVALID_HANDLE_VALUE ) {
        return;
    }

    wsprintf ( szCountryID, L"%d", dwCountryID);

    bResult = SetupFindFirstLine (
        PhoneInf,
        L"TapiCodes",
        szCountryID,
        &Context
        );

    if (bResult) {
        SetupGetStringField ( &Context, 1, szIsoCode, 4, NULL );
        SetupDebugPrint2 ( L"SetupMapTapiToIso: %d mapped to %s", dwCountryID, szIsoCode );
    }

    SetupCloseInfFile( PhoneInf );
}


BOOL
WINAPI
SetupGetSetupInfo(
    PWSTR Name,     OPTIONAL
    DWORD cbName,
    PWSTR Org,      OPTIONAL
    DWORD cbOrg,
    PWSTR OemId,    OPTIONAL
    DWORD cbOemId,
    LPBOOL IntlSet  OPTIONAL
    )
{
    BOOL    b = TRUE;
    HKEY    hkey = NULL;
    DWORD   Size;
    DWORD   Type;


    //
    // Open the key if we need it
    //
    if( (Name || Org) &&
        RegOpenKeyEx(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,0,
        KEY_QUERY_VALUE,&hkey) != NO_ERROR) {

        return FALSE;
    }

    //
    // Get Name
    //
    if (Name) {
        Size = cbName;
        if((RegQueryValueEx(hkey,szRegisteredOwner,NULL,&Type,
            (LPBYTE)Name,&Size) != NO_ERROR)
            || (Type != REG_SZ)
            ) {

            b = FALSE;
        }
    }

    //
    // Get Org
    //
    if (Org) {
        Size = cbOrg;
        if((RegQueryValueEx(hkey,szRegisteredOrganization,NULL,&Type,
            (LPBYTE)Org,&Size) != NO_ERROR)
            || (Type != REG_SZ)
            ) {

            b = FALSE;
        }
    }

    // TBD: figure out what this is for
    if (OemId) {
        OemId[0] = 0;
        cbOemId = 0;
    }

    //
    // Note: IntlSet is not used currently
    //

    if (hkey) {
        RegCloseKey(hkey);
    }
    return b;
}

BOOL
WINAPI
SetupSetSetupInfo(
    PCWSTR  Name,
    PCWSTR  Org
    )
{
    BOOL    b;


    b = StoreNameOrgInRegistry( (PWSTR)Name, (PWSTR)Org );
    return b;
}


BOOL
WINAPI
SetupSetAdminPassword(
    PCWSTR  OldPassword,
    PCWSTR  NewPassword
    )
{
    WCHAR   AdminName[MAX_USERNAME+1];
    BOOL    Status;


    GetAdminAccountName( AdminName );
    Status = SetLocalUserPassword( AdminName, OldPassword, NewPassword );

    if ( !Status ) {
        SetupDebugPrint( L"SetupSetAdminPassword: SetLocalUserPassword failed.");
    }

    return Status;
}


VOID
WINAPI
SetupOobeInitDebugLog(
    )
{
    //
    // Do no UI.  Note that we must set OobeSetup before our first call to
    // SetupDebugPrint.
    //

    OobeSetup = TRUE;
    SetupDebugPrint( L"SetupOobeInitDebugLog" );
}


// Run initialization that is known not to requires services to run.
//
VOID
WINAPI
SetupOobeInitPreServices(
    IN  BOOL    DoMiniSetupStuff
    )
{
    //
    // Turn off logging.
    //
    // IsSetup = FALSE;

    SetupDebugPrint( L"SetupOobeInitPreServices" );

    if ( DoMiniSetupStuff ) {
        //
        // Act like the miniwizard (except with no UI)
        //
        MiniSetup = TRUE;
        Preinstall = TRUE;

        //
        // Tell SetupAPI not to bother backing up files and not to verify
        // that any INFs are digitally signed.
        //
        pSetupSetGlobalFlags(pSetupGetGlobalFlags()|PSPGF_NO_BACKUP|PSPGF_NO_VERIFY_INF);

        CommonInitialization();

        SetUpDataBlock();
        InternalSetupData.CallSpecificData1 = 0;

#if 0
        //
        // We aren't going to do this for rev 1.
        //

        if( PnPReEnumeration ) {
            //
            // The user wants us to do PnP re-enumeration.
            // Go do it.
            //
            InstallPnpDevices( hdlg,
                               SyssetupInf,
                               GetDlgItem(hdlg,IDC_PROGRESS1),
                               StartAtPercent,
                               StopAtPercent );
        }
#endif
    } else { // DoMiniSetupStuff

    //
    // Get handle to heap so we can periodically validate it.
    //
#if DBG
        g_hSysSetupHeap = GetProcessHeap();
#endif
    }
}


// Run initialization that may or does require services.
//
VOID
WINAPI
SetupOobeInitPostServices(
    IN  BOOL    DoMiniSetupStuff
    )
{
    InitializeExternalModules(
        DoMiniSetupStuff,
        &g_OcManagerContext
    );
}


VOID
WINAPI
SetupOobeCleanup(
    IN  BOOL    DoMiniSetupStuff
    )
{
    static FINISH_THREAD_PARAMS Context;


    SetupDebugPrint( L"SetupOobeCleanup" );

    if ( DoMiniSetupStuff ) {

        RestoreBootTimeout();

        Context.ThreadId = GetCurrentThreadId();
        Context.OcManagerContext = g_OcManagerContext;
        FinishThread( &Context );
    }
}

// Resets the activation days (allowed 3 times only)
//
DWORD
SetupReArmWPA(
    VOID
    )
{
    LPCSTR  lpszReArmInterface = (LPCSTR)124;
    typedef HRESULT (WINAPI* lpReArmEntryPoint) ();
    HMODULE hRearmdll = NULL;
    DWORD   dwError = ERROR_SUCCESS;
    hRearmdll = LoadLibraryA("licdll.dll");

    if (hRearmdll)
    {
        lpReArmEntryPoint pReArmEntry  =
                                (lpReArmEntryPoint) GetProcAddress(hRearmdll,lpszReArmInterface);

        if (pReArmEntry)
        {
            //
            // ValidateDigitalPid returns zero if success, otherwise its custom error code
            //
            HRESULT hr = (*pReArmEntry )();

            if (FAILED(hr))
            {
                // If PID cannot be validated we should force activation/PID reentry.
                SetupDebugPrint1(L"SETUP: Rollback WPA failed! HRESULT=%ld", hr);
                dwError = (DWORD)hr;
            }
            else
                SetupDebugPrint(L"SETUP: Rollback WPA succeeded.");
        }
        else {
            SetupDebugPrint(L"SETUP: Failed to get WPA entry point!");
            dwError = ERROR_INVALID_FUNCTION;
        }
        FreeLibrary (hRearmdll);
    }
    else {
        SetupDebugPrint(L"SETUP: Failed to load WPA library!");
        dwError = ERROR_FILE_NOT_FOUND;
    }

    // Return error code or success
    //
    return dwError;
}

// Once Windows is activated the Activate Windows shortcut is removed by msoobe.exe /a.
// If OEMs sysprep a machine they will need to re-activate Windows and the shortcut
// needs to be restored.  Msoobe.exe cannot restore it because it does not
// run in server skus.
//
DWORD
SetupRestoreWPAShortcuts(
    VOID
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HINF hinf;
    hinf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    if(hinf != INVALID_HANDLE_VALUE)
    {
        if (SetupInstallFromInfSection(NULL,
                                       hinf,
                                       L"RESTORE_OOBE_ACTIVATE",
                                       SPINST_PROFILEITEMS , //SPINST_ALL,
                                       NULL,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL) != 0)
        {
            // Success
            SetupDebugPrint(L"SETUP: Restore Activation shortcut succeeded");
        }
        else
        {
            // Failure
            dwError = GetLastError();
            SetupDebugPrint1(L"SETUP: Restore Activation shortcut failed. GetLastError=%ld",dwError);
        }
        SetupCloseInfFile(hinf);
    }
    else
    {
        dwError = GetLastError();
        SetupDebugPrint1(L"SETUP: Restore Activation shortcut failed to open syssetup.inf. GetLastError=%ld",dwError);
    }

    return dwError;
}

BOOL Activationrequired(VOID);

// Rollback the activation days and put back the activate windows shortcut(s). X86 only.
//
DWORD
WINAPI
SetupOobeBnk(
    LPBYTE pDummy
    )
{
    DWORD dwError = ERROR_SUCCESS;

    // Return if we failed to rollback so we don'put the shortcut back
    // On volume license skus this always returns successful
    //
    if (ERROR_SUCCESS != (dwError = SetupReArmWPA()))
        return dwError;

    // If not activated, restore the shortcuts, or if we don't
    // require activation (for volume license skus)
    //
    if (Activationrequired())
    {
        // Restore the Activate Windows shortcut(s)
        //
        dwError = SetupRestoreWPAShortcuts();
    }
    return dwError;
}


static
LPTSTR
NextNumber(
    LPTSTR lpString,
    BOOL bSkipFirst
    )
{
    // The first time we just want to walk past any non-numbers,
    // we don't want to skip any numbers if they are right at the
    // begining of the string.
    //
    if ( bSkipFirst )
    {
        // Walk past the first number in the string.
        //
        while ( ( *lpString >= _T('0') ) &&
                ( *lpString <= _T('9') ) )
        {
            lpString++;
        }
    }

    // Now walk till we get to the next number or we reach the end.
    //
    while ( ( *lpString ) &&
            ( ( *lpString < _T('0') ) ||
              ( *lpString > _T('9') ) ) )
    {
        lpString++;
    }

    return lpString;
}

BOOL
WINAPI
SetupSetDisplay(
    LPCTSTR lpszUnattend,
    LPCTSTR lpszSection,
    LPCTSTR lpszResolutionKey,
    LPCTSTR lpszRefreshKey,
    DWORD   dwMinWidth,
    DWORD   dwMinHeight,
    DWORD   dwMinBits
    )
{
    DEVMODE devmode;
    DWORD   dwVal;
    TCHAR   szText[256];
    LPTSTR  lpDisplay;
    BOOL    bRet = TRUE;

    ZeroMemory(&devmode, sizeof(DEVMODE));
    devmode.dmSize = sizeof(DEVMODE);

    // Check the current resolution, make sure it meets our mins.
    //
    if ( EnumDisplaySettings(NULL, ENUM_REGISTRY_SETTINGS, &devmode) )
    {
        if ( devmode.dmPelsWidth < dwMinWidth )
        {
            devmode.dmPelsWidth =  dwMinWidth;
            devmode.dmFields |= DM_PELSWIDTH;
        }

        if ( devmode.dmPelsHeight < dwMinHeight )
        {
            devmode.dmPelsHeight = dwMinHeight;
            devmode.dmFields |= DM_PELSHEIGHT;
        }

        if ( devmode.dmBitsPerPel < dwMinBits )
        {
            devmode.dmBitsPerPel = dwMinBits;
            devmode.dmFields |= DM_BITSPERPEL;
        }
    }

    // Make sure they passed in an unattend and section to look in.
    //
    if ( lpszUnattend && *lpszUnattend && lpszSection && *lpszSection )
    {
        // Now check in the winbom to see if they want to change the current resolution.
        //
        szText[0] = _T('\0');
        if ( ( lpszResolutionKey ) &&
             ( *lpszResolutionKey ) &&
             ( GetPrivateProfileString(lpszSection, lpszResolutionKey, _T(""), szText, sizeof(szText) / sizeof(szText[0]), lpszUnattend) ) &&
             ( szText[0] ) )
        {
            bRet = FALSE;

            lpDisplay = NextNumber(szText, FALSE);
            if ( dwVal = (DWORD) _ttoi(lpDisplay) )
            {
                devmode.dmFields |= DM_PELSWIDTH;
                devmode.dmPelsWidth = dwVal;
            }

            lpDisplay = NextNumber(lpDisplay, TRUE);
            if ( dwVal = (DWORD) _ttoi(lpDisplay) )
            {
                devmode.dmFields |= DM_PELSHEIGHT;
                devmode.dmPelsHeight = dwVal;
            }

            lpDisplay = NextNumber(lpDisplay, TRUE);
            if ( dwVal = (DWORD) _ttoi(lpDisplay) )
            {
                devmode.dmFields |= DM_BITSPERPEL;
                devmode.dmBitsPerPel = dwVal;
            }
        }

        // Now check in the winbom to see if they want to change the default refresh rate.
        //
        szText[0] = _T('\0');
        if ( ( lpszRefreshKey ) &&
             ( *lpszRefreshKey ) &&
             ( GetPrivateProfileString(lpszSection, lpszRefreshKey, _T(""), szText, sizeof(szText) / sizeof(szText[0]), lpszUnattend) ) &&
             ( szText[0] ) )
        {
            bRet = FALSE;

            if ( dwVal = (DWORD) _ttoi(szText) )
            {
                devmode.dmFields |= DM_DISPLAYFREQUENCY;
                devmode.dmDisplayFrequency = dwVal;
            }
        }
    }

    // If we have anything to change, change it now.
    //
    if ( devmode.dmFields )
    {
        DWORD dwRet = ChangeDisplaySettings(&devmode, CDS_UPDATEREGISTRY | CDS_GLOBAL);

        switch ( dwRet )
        {
            case DISP_CHANGE_SUCCESSFUL:
            case DISP_CHANGE_RESTART:
                bRet = TRUE;
                break;

            //case DISP_CHANGE_BADFLAGS:
            //case DISP_CHANGE_BADPARAM:
            //case DISP_CHANGE_FAILED:
            //case DISP_CHANGE_BADMODE
            //case DISP_CHANGE_NOTUPDATED:
                //bRet = FALSE;
        }
    }

    return bRet;
}


typedef struct _OEM_FINISH_APPS {
    LPTSTR  szApp;
    LPTSTR  szArgs;
} OEM_FINISH_APPS;

OEM_FINISH_APPS OEM_Finish_Apps[] = {
    { L"Rundll32.exe", L"fldrclnr.dll,Wizard_RunDLL silent"},
    { NULL, NULL}   // End of list.
};


void RunOEMExtraTasks()
{
    LPTSTR pApp = NULL;
    LPTSTR pArgs = NULL;
    DWORD dwSize;
    DWORD dwCode;
    int i;

    BEGIN_SECTION(L"RunOEMExtraTasks");
    i = 0;
    while (OEM_Finish_Apps[i].szApp != NULL)
    {
        // Get the size we need to the expanded app
        dwSize = ExpandEnvironmentStrings(
                                OEM_Finish_Apps[i].szApp ,
                                NULL,
                                0);
        if (dwSize)
        {
            pApp = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR) * dwSize);
            if (pApp)
            {
                ExpandEnvironmentStrings(
                                OEM_Finish_Apps[i].szApp ,
                                pApp,
                                dwSize);

                if (OEM_Finish_Apps[i].szArgs)
                {
                    // Get the size we need to the expanded arguments
                    dwSize = ExpandEnvironmentStrings(
                                            OEM_Finish_Apps[i].szArgs ,
                                            NULL,
                                            0);
                    if (dwSize)
                    {
                        pArgs = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR) * dwSize);
                        if (pArgs)
                        {
                            ExpandEnvironmentStrings(
                                            OEM_Finish_Apps[i].szArgs,
                                            pArgs,
                                            dwSize);
                        }
                    }
                }
                // Log what we will start
                if (pArgs)
                {
                    SetupDebugPrint2(L"Start command :%s: with arguments :%s:", pApp, pArgs);
                }
                else
                {
                    SetupDebugPrint1(L"Start command :%s: with no arguments", pApp);
                }

                // Start the app.
                dwCode = 0;
                if (pArgs)
                {
                    InvokeExternalApplicationEx(pApp, pArgs, &dwCode, INFINITE, TRUE);
                }
                else
                {
                    // If we don't have args. the first parameter is NULL
                    InvokeExternalApplicationEx(NULL, pApp, &dwCode, INFINITE, TRUE);
                }
            }
        }
        if (pApp)
        {
            GlobalFree(pApp);
            pApp = NULL;
        }
        if (pArgs)
        {
            GlobalFree(pArgs);
            pArgs = NULL;
        }
        i++;
    }
    END_SECTION(L"RunOEMExtraTasks");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\registry.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Routines for manupilating the configuration registry.

    Entry points:

        SaveHive
        SetEnvironmentVariableInRegistry

Author:

    Ted Miller (tedm) 5-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#ifdef _WIN64
#include <shlwapi.h>
#endif

//
// Names of frequently used keys, values.
//
PCWSTR ControlKeyName = L"SYSTEM\\CurrentControlSet\\Control";
PCWSTR SessionManagerKeyName = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager";
PCWSTR EnvironmentKeyName = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment";
PCWSTR WinntSoftwareKeyName = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
PCWSTR MemoryManagementKeyName = L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management";
PCWSTR WindowsCurrentVersionKeyName = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion";
PCWSTR IEProductVersionKeyName = L"Software\\Microsoft\\Internet Explorer\\Registration";

PCWSTR szBootExecute = L"BootExecute";
PCWSTR szRegisteredProcessors = L"RegisteredProcessors";
PCWSTR szLicensedProcessors = L"LicensedProcessors";
PCWSTR szRegisteredOwner = L"RegisteredOwner";
PCWSTR szRegisteredOrganization = L"RegisteredOrganization";
PCWSTR szCurrentProductId = L"CurrentProductId";

//
// Logging constants used only in this module.
//
PCWSTR szRegSaveKey = L"RegSaveKey";

//
// Number of processors to enable in server case.
//
#define SERVER_PROCESSOR_LICENSE (2)



//
// Table telling us the info needed in order to save and
// replace the system hives at the end of setup.
//
struct {
    //
    // Key and subkey that is at the root of the hive.
    //
    HKEY RootKey;
    PCWSTR Subkey;

    //
    // Name active hive has in the config directory.
    //
    PCWSTR Hive;

    //
    // Name to use for new hive file, that will be the hive
    // at next boot.
    //
    PCWSTR NewHive;

    //
    // Name to use for current hive file, that will be deleted
    // on next boot.
    //
    PCWSTR DeleteHive;

} HiveTable[3] = {

    //
    // System hive.
    //
    { HKEY_LOCAL_MACHINE, L"SYSTEM"  , L"SYSTEM"  , L"SYS$$$$$.$$$", L"SYS$$$$$.DEL" },

    //
    // Software hive
    //
    { HKEY_LOCAL_MACHINE, L"SOFTWARE", L"SOFTWARE", L"SOF$$$$$.$$$", L"SOF$$$$$.DEL" },

    //
    // Default user hive
    //
    { HKEY_USERS        , L".DEFAULT", L"DEFAULT" , L"DEF$$$$$.$$$", L"DEF$$$$$.DEL" }
};




BOOL
SaveHive(
    IN HKEY   RootKey,
    IN PCWSTR Subkey,
    IN PCWSTR Filename,
    IN DWORD  Format
    )

/*++

Routine Description:

    Save a hive into a disk file.

Arguments:

    RootKey - supplies root key for hive to be saved, ie,
        HKEY_LOCAL_MACHINE or HKEY_USERS

    Subkey - supplies name of subkey for hive to be saved, such as
        SYSTEM, SOFTWARE, or .DEFAULT.

    Filename - supplies the name of the file to be created. If it exists
        it is overwritten.

Return Value:

    Boolean value indicating outcome.

--*/

{
    LONG rc;
    HKEY hkey;
    BOOL b;

    b = FALSE;

    //
    // Open the key.
    //
    rc = RegOpenKeyEx(RootKey,Subkey,0,KEY_READ,&hkey);
    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SAVEHIVE_FAIL,
            Subkey,
            Filename, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szRegOpenKeyEx,
            rc,
            NULL,NULL);
        goto err1;
    }

    //
    // Delete the file if it's there.
    //
    if(FileExists(Filename,NULL)) {
        SetFileAttributes(Filename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(Filename);
    }

    //
    // Enable backup privilege. Ignore any error.
    //
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    //
    // Do the save.
    //
    rc = RegSaveKeyEx(hkey,Filename,NULL,Format);
    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SAVEHIVE_FAIL,
            Subkey,
            Filename, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szRegSaveKey,
            rc,
            NULL,NULL);
        goto err2;
    }

    b = TRUE;

err2:
    RegCloseKey(hkey);
err1:
    return(b);
}


BOOL
SetEnvironmentVariableInRegistry(
    IN PCWSTR Name,
    IN PCWSTR Value,
    IN BOOL   SystemWide
    )
{
    HKEY hKey,hRootKey;
    PCWSTR Subkey;
    DWORD dwDisp;
    LONG rc;
    BOOL b;

    b = FALSE;

    //
    // Check if the caller wants to modify a system environment variable
    // or a user environment variable. Accordingly find out the right
    // place in the registry to look.
    //
    if(SystemWide) {
        hRootKey = HKEY_LOCAL_MACHINE;
        Subkey = EnvironmentKeyName;
    } else {
        hRootKey = HKEY_CURRENT_USER;
        Subkey = L"Environment";
    }

    //
    // Open the environment variable key.
    //
    rc = RegCreateKeyEx(hRootKey,Subkey,0,NULL,REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,NULL,&hKey,&dwDisp);
    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SETENV_FAIL,
            Name, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegOpenKeyEx,
            rc,
            Subkey,
            NULL,NULL);
        goto err0;
    }

    //
    // Write the value given.
    //
    rc = RegSetValueEx(
            hKey,
            Name,
            0,
            REG_EXPAND_SZ,
            (PBYTE)Value,
            (lstrlen(Value)+1)*sizeof(WCHAR)
            );

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SETENV_FAIL,
            Name, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegSetValueEx,
            rc,
            Subkey,
            NULL,NULL);
        goto err1;
    }

    //
    // Send a WM_WININICHANGE message so that progman picks up the new
    // variable
    //
    SendMessageTimeout(
        (HWND)-1,
        WM_WININICHANGE,
        0L,
        (LPARAM)"Environment",
        SMTO_ABORTIFHUNG,
        1000,
        NULL
        );

    b = TRUE;

err1:
    RegCloseKey(hKey);
err0:
    return(b);
}

#ifdef _WIN64

typedef struct _SUBST_STRING {
    BOOL  ExpandEnvironmentVars;
    PTSTR InputString;
    PTSTR ExclusionString;
    PTSTR OutputString;
    PTSTR SourceInputString;
    PTSTR SourceExclusionString;
    PTSTR SourceOutputString;
} SUBST_STRING,*PSUBST_STRING;


//
// note that WOW64 does file system redirection of system32, but it does NOT do
// redirection of program files, etc.  So we must substitute in the 32 bit
// environment variables in those cases where WOW64 does not do it for us
// automatically
//
SUBST_STRING StringArray[] = {
    //
    // order of these 2 is important!
    //
    { FALSE,
      NULL,
      NULL,
      NULL,
      TEXT("%CommonProgramFiles%"),
      TEXT("%CommonProgramFiles(x86)%"),
      TEXT("%CommonProgramFiles(x86)%")
    },

    { FALSE,
      NULL,
      NULL,
      NULL,
      TEXT("%ProgramFiles%"),
      TEXT("%ProgramFiles(x86)%"),
      TEXT("%ProgramFiles(x86)%")
    },

    { TRUE,
      NULL,
      NULL,
      NULL,
      TEXT("%CommonProgramFiles%"),
      TEXT("%CommonProgramFiles(x86)%"),
      TEXT("%CommonProgramFiles(x86)%")
    },

    { TRUE,
      NULL,
      NULL,
      NULL,
      TEXT("%ProgramFiles%"),
      TEXT("%ProgramFiles(x86)%"),
      TEXT("%ProgramFiles(x86)%")
    }

} ;


BOOL
pDoWow64SubstitutionHelper(
    IN OUT PTSTR String
    )
/*++

Routine Description:

    This routine filters and outputs the input line.  It looks for a string
    pattern that matches one of a known list of strings, and replaces the
    known string with a substitution string.

Arguments:

    String       - input string to be searched.  We edit this string
                   in-place if we find a match.

Return Value:

    Boolean indicating outcome.

--*/

{
    WCHAR ScratchBuffer[MAX_PATH];


    DWORD i;
    PTSTR p,q;
    TCHAR c;

    for (i = 0; i< sizeof(StringArray)/sizeof(SUBST_STRING); i++) {
        if (!StrStrI(String,StringArray[i].ExclusionString) &&
            (p = StrStrI(String,StringArray[i].InputString))) {
            //
            // if we found a hit, then find the end of the string
            // and concatenate that to our source string, which gives
            // the resultant string with substitutions.
            //
            q = p + wcslen(StringArray[i].InputString);
            c = *p;
            *p = TEXT('\0');
            wcscpy(ScratchBuffer,String);
            *p = c;
            wcscat(ScratchBuffer,StringArray[i].OutputString);
            wcscat(ScratchBuffer,q);
            wcscpy(String,ScratchBuffer);
            //
            // recursively call in case there are more strings.
            //
            pDoWow64SubstitutionHelper(String);
            break;
        }
    }

    return(TRUE);
}


BOOL
pDoWow64Substitution(
    IN PCWSTR InputString,
    OUT PWSTR  OutputString
    )
{
    DWORD i;
    WCHAR Buffer[MAX_PATH];
    BOOL RetVal;

    //
    // set up our global array of substitution strings
    //
    for (i = 0; i<sizeof(StringArray) / sizeof(SUBST_STRING);i++) {
        if (StringArray[i].ExpandEnvironmentVars) {
            ExpandEnvironmentStrings(
                        StringArray[i].SourceInputString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR));

            StringArray[i].InputString = pSetupDuplicateString( Buffer );
            if (!StringArray[i].InputString) {
                RetVal = FALSE;
                goto exit;
            }

            ExpandEnvironmentStrings(
                        StringArray[i].SourceExclusionString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR));

            StringArray[i].ExclusionString = pSetupDuplicateString( Buffer );
            if (!StringArray[i].ExclusionString) {
                RetVal = FALSE;
                goto exit;
            }

            ExpandEnvironmentStrings(
                        StringArray[i].SourceOutputString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR));

            StringArray[i].OutputString = pSetupDuplicateString( Buffer );
            if (!StringArray[i].OutputString) {
                RetVal = FALSE;
                goto exit;
            }

        } else {
            StringArray[i].InputString = pSetupDuplicateString(StringArray[i].SourceInputString);
            if (!StringArray[i].InputString) {
                RetVal = FALSE;
                goto exit;
            }

            StringArray[i].ExclusionString = pSetupDuplicateString(StringArray[i].SourceExclusionString);
            if (!StringArray[i].ExclusionString) {
                RetVal = FALSE;
                goto exit;
            }

            StringArray[i].OutputString = pSetupDuplicateString(StringArray[i].SourceOutputString);
            if (!StringArray[i].OutputString) {
                RetVal = FALSE;
                goto exit;
            }
        }
    }

    //
    // do the recursive inplace substition
    //
    wcscpy(OutputString, InputString);
    RetVal = pDoWow64SubstitutionHelper( OutputString );

    //
    // clean up our global array of substitution strings
    //
exit:
    for (i = 0; i<sizeof(StringArray)/sizeof(SUBST_STRING);i++) {
        if (StringArray[i].InputString) {
            MyFree(StringArray[i].InputString);
            StringArray[i].InputString = NULL;
        }

        if (StringArray[i].ExclusionString) {
            MyFree(StringArray[i].ExclusionString);
            StringArray[i].ExclusionString = NULL;
        }

        if (StringArray[i].OutputString) {
            MyFree(StringArray[i].OutputString);
            StringArray[i].OutputString = NULL;
        }
    }

    return(RetVal);


}

PWSTR
pMungeDataForWow64(
    IN DWORD DataType,
    IN PCWSTR Data,
    IN DWORD DataSize,
    OUT PDWORD NewSize
    )
/*++

Routine Description:

    This routine patches an in string for wow64 so that it is in proper format
    for 32 bit programs.

    This involves looking for strings that are different on 64 bits and 32 bits
    and substituting the 32 bit equivalent for the 64 bit entry.

Arguments:

    DataType - REG_XXX constant describing the data.  we only support strings
               types
    Data - pointer to the data to be munged

    DataSize - size of the data to be converted in bytes

    NewSize - size of the new string in bytes

Return Value:

    A pointer to the converted data string on success, and NULL on failure.

--*/
{
    PWSTR pNewData,q;
    PCWSTR p;
    DWORD ScratchSize;

    switch (DataType) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            //
            // just allocate twice the original size, and that should be plenty of
            // room.
            //
            pNewData = MyMalloc(DataSize * 2);
            if (!pNewData) {
                goto exit;
            }

            pDoWow64Substitution(Data,pNewData);

            *NewSize = sizeof(WCHAR)*(wcslen(pNewData) +1);

            break;
        case REG_MULTI_SZ:
            //
            // just allocate twice the original size, and that should be plenty of
            // room.
            //
            pNewData = MyMalloc(DataSize * 2);
            if (!pNewData) {
                goto exit;
            }

            RtlZeroMemory(pNewData,DataSize * 2);
            p = Data;
            q = pNewData;
            ScratchSize = 1; // for the double-null terminator
            while (p) {

                pDoWow64Substitution(p,q);

                ScratchSize += wcslen(q) + 1;
                p += wcslen(p) + 1;
                q += wcslen(q) + 1;

            }

            *NewSize = ScratchSize * sizeof(WCHAR);
            break;
        default:
            MYASSERT(FALSE && "invalid data type in pMungeDataForWow64");
            pNewData = NULL;
            break;
    }

exit:
    return(pNewData);
}


UINT
SetGroupOfValues_32(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    )
{
    UINT i;
    LONG rc;
    HKEY hkey;
    DWORD ActionTaken;
    UINT RememberedRc;
    WCHAR String[MAX_PATH];

    wcscpy(String,SubkeyName);
    for (i = 0; i< wcslen(String); i++) {
        CharUpper(&String[i]);
    }

    //
    // only write registry stuff under HKLM\software
    //
    if ((RootKey != HKEY_LOCAL_MACHINE) ||
        (NULL == StrStrI(String,L"SOFTWARE\\"))) {
        SetupDebugPrint2(
            L"Setup: skipping creation of 32 bit registry key for data under %x \\ %s \n",
            RootKey,
            SubkeyName );
        return(ERROR_SUCCESS);
    }

    //
    // Open/create the key first.
    //
    rc = RegCreateKeyEx(
            RootKey,
            SubkeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_WOW64_32KEY | KEY_SET_VALUE,
            NULL,
            &hkey,
            &ActionTaken
            );

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_REGKEY_FAIL,
            SubkeyName, NULL,
            SETUPLOG_USE_MESSAGEID,
            rc, NULL, NULL
            );
        return(rc);
    }

    RememberedRc = NO_ERROR;
    //
    // Set all values in the given list.
    //
    for(i=0; i<ValueCount; i++) {
        PWSTR NewData = NULL,OldData = NULL;
        DWORD OldSize, NewSize;

        if (ValueList[i].Type == REG_SZ ||
            ValueList[i].Type == REG_EXPAND_SZ ||
            ValueList[i].Type == REG_MULTI_SZ) {
            OldData = ValueList[i].Data;
            OldSize = ValueList[i].Size;
            NewData = pMungeDataForWow64(
                                ValueList[i].Type,
                                ValueList[i].Data,
                                ValueList[i].Size,
                                &NewSize
                                );

            if (NewData) {
                ValueList[i].Data = (PVOID)NewData;
                ValueList[i].Size = NewSize;
            }
        }

        rc = RegSetValueEx(
                hkey,
                ValueList[i].Name,
                0,
                ValueList[i].Type,
                (CONST BYTE *)ValueList[i].Data,
                ValueList[i].Size
                );

        if (NewData) {
            MyFree(NewData);
            ValueList[i].Data = (PVOID)OldData;
            ValueList[i].Size = OldSize;
        }

        if(rc != NO_ERROR) {
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_REGVALUE_FAIL,
                SubkeyName,
                ValueList[i].Name, NULL,
                SETUPLOG_USE_MESSAGEID,
                rc, NULL, NULL
                );
            RememberedRc = rc;
        }
    }

    RegCloseKey(hkey);
    return(RememberedRc);
}

#endif

UINT
SetGroupOfValues(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    )
{
    UINT i;
    LONG rc;
    HKEY hkey;
    DWORD ActionTaken;
    UINT RememberedRc;

    //
    // Open/create the key first.
    //
    rc = RegCreateKeyEx(
            RootKey,
            SubkeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hkey,
            &ActionTaken
            );

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_REGKEY_FAIL,
            SubkeyName, NULL,
            SETUPLOG_USE_MESSAGEID,
            rc, NULL, NULL
            );
        return(rc);
    }

    RememberedRc = NO_ERROR;
    //
    // Set all values in the given list.
    //
    for(i=0; i<ValueCount; i++) {

        rc = RegSetValueEx(
                hkey,
                ValueList[i].Name,
                0,
                ValueList[i].Type,
                (CONST BYTE *)ValueList[i].Data,
                ValueList[i].Size
                );

        if(rc != NO_ERROR) {
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_REGVALUE_FAIL,
                SubkeyName,
                ValueList[i].Name, NULL,
                SETUPLOG_USE_MESSAGEID,
                rc, NULL, NULL
                );
            RememberedRc = rc;
        }
    }

    RegCloseKey(hkey);

#ifdef _WIN64
    rc = SetGroupOfValues_32(
                 RootKey,
                 SubkeyName,
                 ValueList,
                 ValueCount);
    if (rc != NO_ERROR) {
        RememberedRc = rc;
    }
#endif

    return(RememberedRc);
}


BOOL
CreateWindowsNtSoftwareEntry(
    IN BOOL FirstPass
    )
{
    WCHAR Path[MAX_PATH];
    time_t DateVal;
    BOOL b;
    REGVALITEM SoftwareKeyItems[4];
    PWSTR Source;
    unsigned PlatformNameLength;
    unsigned PathLength;
    int PlatformOffset;
    DWORD Result;

    b = TRUE;

    if(FirstPass) {
        //
        // First pass occurs before net setup, and they want
        // the actual path where the files are located *right now*.
        // So we write that into the legacy source path value
        // in the registry.
        //
        SoftwareKeyItems[0].Name = REGSTR_VAL_SRCPATH;
        SoftwareKeyItems[0].Data = LegacySourcePath;
        SoftwareKeyItems[0].Size = (lstrlen(LegacySourcePath)+1)*sizeof(WCHAR);
        SoftwareKeyItems[0].Type = REG_SZ;

        //
        // Set up fields for PathName value
        //
        Path[0] = '\0';
        Result = GetWindowsDirectory(Path,MAX_PATH);
        if( Result == 0) {
            MYASSERT(FALSE);
            return FALSE;
        }
        SoftwareKeyItems[1].Name = L"PathName";
        SoftwareKeyItems[1].Data = Path;
        SoftwareKeyItems[1].Size = (lstrlen(Path)+1)*sizeof(WCHAR);
        SoftwareKeyItems[1].Type = REG_SZ;

        //
        // Set up fields for SoftwareType value
        //
        SoftwareKeyItems[2].Name = L"SoftwareType";
        SoftwareKeyItems[2].Data = L"SYSTEM";
        SoftwareKeyItems[2].Size = sizeof(L"SYSTEM");
        SoftwareKeyItems[2].Type = REG_SZ;

        //
        // Set up fields for InstallDate value
        // (we no longer set this value here because this function is called before
        //  the Date/Time wizard page is executed. This value entry is now set by
        //  CreateInstallDateEntry(), which is always called after the Date/Time page
        //  is executed, when the user can no longer go back this page)
        //
        // time(&DateVal);
        // SoftwareKeyItems[3].Name = L"InstallDate";
        // SoftwareKeyItems[3].Data = &DateVal;
        // SoftwareKeyItems[3].Size = sizeof(DWORD);
        // SoftwareKeyItems[3].Type = REG_DWORD;
        //

        //
        // Write values into the registry.
        //
        if(SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,SoftwareKeyItems,3) != NO_ERROR) {
            b = FALSE;
        }

        //
        // In addition we will populate the MRU list with a reasonable source path
        // which for now is the actual source path where files are located,
        // ie the CD-ROM or the temporary local source. Thus in the winnt/winnt32
        // case the user wouldn't see any UNC paths yet in any prompts that might
        // occur between now and pass 2 of this routine. Such paths aren't accessible
        // now anyway.
        //
        // Ditto for the 'SourcePath' value entry under
        // HKLM\Software\Microsoft\Windows\CurrentVersion\Setup that is expected by
        // setupapi.dll/Win95 apps.
        //
        // The 'ServicePackSourcePath' is the same as the sourcepath for gui-mode setup.
        // We assume that the user has overlaid a service pack at the source location.
        // If it's retail media, this is technically incorrect, but it doesn't matter
        // since nothing will want to use the servicepack source anyway.  The service
        // pack update program will update this location if it is run.
        //


        if(!SetupAddToSourceList(SRCLIST_SYSTEM,SourcePath)) {
            b = FALSE;
        }

        SoftwareKeyItems[0].Name = REGSTR_VAL_SRCPATH;
        SoftwareKeyItems[0].Data = SourcePath;
        SoftwareKeyItems[0].Size = (lstrlen(SourcePath)+1)*sizeof(WCHAR);
        SoftwareKeyItems[0].Type = REG_SZ;

        SoftwareKeyItems[1].Name = REGSTR_VAL_SVCPAKSRCPATH;
        SoftwareKeyItems[1].Data = SourcePath;
        SoftwareKeyItems[1].Size = (lstrlen(SourcePath)+1)*sizeof(WCHAR);
        SoftwareKeyItems[1].Type = REG_SZ;

        PathLength = gInstallingFromCD ? 1 : 0;
        SoftwareKeyItems[2].Name = L"CDInstall";
        SoftwareKeyItems[2].Data = &PathLength;
        SoftwareKeyItems[2].Size = sizeof(DWORD);
        SoftwareKeyItems[2].Type = REG_DWORD;

        if(SetGroupOfValues(HKEY_LOCAL_MACHINE,REGSTR_PATH_SETUP REGSTR_KEY_SETUP,SoftwareKeyItems,3) != NO_ERROR) {
            b = FALSE;
        }

#ifdef _X86_
        //
        // NEC98
        //
        // If this is system setup and using local copy, platform-specific extension
        // must be "nec98".
        //
        if (IsNEC_98 && SourcePath[0] && SourcePath[1] == L':' && SourcePath[2] == L'\\' && !lstrcmpi(SourcePath+2, pwLocalSource)) {
            SoftwareKeyItems[0].Name = L"ForcePlatform";
            SoftwareKeyItems[0].Data = L"nec98";
            SoftwareKeyItems[0].Size = (lstrlen(L"nec98")+1)*sizeof(WCHAR);
            SoftwareKeyItems[0].Type = REG_SZ;
            if(SetGroupOfValues(HKEY_LOCAL_MACHINE,TEXT("System\\Setup"),SoftwareKeyItems,1) != NO_ERROR) {
                b = FALSE;
            }
        }
#endif

    } else {
        //
        // Not first pass. This occurs after network installation.
        // In the case where we are winnt-based, we need to fix up source paths
        // to point at the "real" location where files can be obtained -- ie,
        // a network share saved away for us by winnt/winnt32. If we are installing
        // from CD then the path we wrote during FirstPass is fine so we don't
        // bother changing it.
        //
        if(WinntBased) {
            //
            // Remove local source directory from MRU list.
            // Ignore errors.
            //
            SetupRemoveFromSourceList(SRCLIST_SYSTEM,SourcePath);

            lstrcpy(Path,OriginalSourcePath);

            //
            // Update legacy source path.
            //
            SoftwareKeyItems[0].Name = REGSTR_VAL_SRCPATH;
            SoftwareKeyItems[0].Data = Path;
            SoftwareKeyItems[0].Size = (lstrlen(Path)+1)*sizeof(WCHAR);
            SoftwareKeyItems[0].Type = REG_SZ;

            SoftwareKeyItems[1].Name = REGSTR_VAL_SVCPAKSRCPATH;
            SoftwareKeyItems[1].Data = Path;
            SoftwareKeyItems[1].Size = (lstrlen(Path)+1)*sizeof(WCHAR);
            SoftwareKeyItems[1].Type = REG_SZ;

            if(SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,SoftwareKeyItems,1) != NO_ERROR) {
                b = FALSE;
            }

            //
            // Strip off platform-specific extension if it exists.
            //
            PathLength = lstrlen(Path);
            PlatformNameLength = lstrlen(PlatformName);
            PlatformOffset = PathLength - PlatformNameLength;

            if((PlatformOffset > 0)
            && (Path[PlatformOffset-1] == L'\\')
            && !lstrcmpi(Path+PlatformOffset,PlatformName)) {

                Path[PlatformOffset-1] = 0;

                SoftwareKeyItems[0].Size -= (PlatformNameLength+1)*sizeof(WCHAR);
                SoftwareKeyItems[1].Size -= (PlatformNameLength+1)*sizeof(WCHAR);
            }

            //
            // Add "real" path to MRU list and update setupapi.dll/Win95
            // SourcePath value.
            //
            if(!SetupAddToSourceList(SRCLIST_SYSTEM,Path)) {
                b = FALSE;
            }
            if(SetGroupOfValues(HKEY_LOCAL_MACHINE,REGSTR_PATH_SETUP REGSTR_KEY_SETUP,SoftwareKeyItems,2) != NO_ERROR) {
                b = FALSE;
            }
        }
    }

    return(b);
}


BOOL
StoreNameOrgInRegistry(
    PWSTR   NameOrgName,
    PWSTR   NameOrgOrg
    )
{
    DWORD d;
    REGVALITEM SoftwareKeyItems[2];

    MYASSERT(!Upgrade);

    SoftwareKeyItems[0].Name = szRegisteredOwner;
    SoftwareKeyItems[0].Data = NameOrgName;
    SoftwareKeyItems[0].Size = (lstrlen(NameOrgName)+1)*sizeof(WCHAR);
    SoftwareKeyItems[0].Type = REG_SZ;

    SoftwareKeyItems[1].Name = szRegisteredOrganization;
    SoftwareKeyItems[1].Data = NameOrgOrg;
    SoftwareKeyItems[1].Size = (lstrlen(NameOrgOrg)+1)*sizeof(WCHAR);
    SoftwareKeyItems[1].Type = REG_SZ;

    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,SoftwareKeyItems,2);
    return(d == NO_ERROR);
}


BOOL
SetUpEvaluationSKUStuff(
    VOID
    )
{
    FILETIME FileTime;
    DWORD EvalValues[3];
    DWORD d;
    REGVALITEM Value;
    HKEY hkey;
    ULONGLONG SKUData;
    DWORD DataType;
    DWORD DataSize;
    time_t RawLinkTime;
    SYSTEMTIME SystemTime;
    struct tm *LinkTime;
    int delta;
    PIMAGE_NT_HEADERS NtHeaders;

    //
    // Fetch the evaulation time in minutes from the registry.
    // An evaluation time of 0 means indefinite.
    // This value was passed in from text mode in a special way
    // (ie, not via the text file that contains our params,
    // since that's not secure enough).
    //
    EvalValues[1] = 0;
    d = RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"System\\Setup",0,KEY_READ,&hkey);
    if(d == NO_ERROR) {

        DataSize = sizeof(ULONGLONG);
        d = RegQueryValueEx(hkey,L"SystemPrefix",NULL,&DataType,(PBYTE)&SKUData,&DataSize);
        if(d == NO_ERROR) {
            //
            // Do not change this line without changing SpSaveSKUStuff() in
            // text setup (spconfig.c).
            //
            EvalValues[1] = (DWORD)(SKUData >> 13);
        }
        RegCloseKey(hkey);
    }

    //
    // Verify that the clock seems right in the eval unit case.
    // This helps protect against prople discovering that their
    // clock is wrong later and changing it, which expires their
    // eval unit.
    //
    if(EvalValues[1]) {
        //
        // Get the link time of our dll and convert to
        // a form where we have the year separated out.
        //
        try {
            if( NtHeaders = RtlImageNtHeader(MyModuleHandle) ) {
                RawLinkTime = NtHeaders->FileHeader.TimeDateStamp;
            } else {
                RawLinkTime = 0;
            }
            RawLinkTime = RtlImageNtHeader(MyModuleHandle)->FileHeader.TimeDateStamp;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            RawLinkTime = 0;
        }

        if(RawLinkTime && (LinkTime = gmtime(&RawLinkTime))) {

            GetLocalTime(&SystemTime);

            delta = (SystemTime.wYear - 1900) - LinkTime->tm_year;

            //
            // If the year of the current time is more than one year less then
            // the year the dll was linked, or more than three years more,
            // assume the user's clock is out of whack.
            //
            if((delta < -1) || (delta > 3)) {

                extern PCWSTR DateTimeCpl;

                MessageBoxFromMessage(
                    MainWindowHandle,
                    MSG_EVAL_UNIT_CLOCK_SEEMS_WRONG,
                    NULL,
                    IDS_WINNT_SETUP,
                    MB_OK | MB_ICONWARNING
                    );

                InvokeControlPanelApplet(DateTimeCpl,L"",0,L"");
            }
        }
    }

    //
    // Get current date/time and put into array in format
    // expected by the system code that reads it.
    //
    GetSystemTimeAsFileTime(&FileTime);
    EvalValues[0] = FileTime.dwLowDateTime;
    EvalValues[2] = FileTime.dwHighDateTime;

    //
    // Write value into registry.
    //
    Value.Name = L"PriorityQuantumMatrix";
    Value.Data = EvalValues;
    Value.Size = sizeof(EvalValues);
    Value.Type = REG_BINARY;

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Executive",
            &Value,
            1
            );

    return(d == NO_ERROR);
}



BOOL
ReadAndParseProcessorLicenseInfo(
    PDWORD LicensedProcessors,
    PLARGE_INTEGER pSKUData
    )
{

    DWORD d;
    REGVALITEM Value;
    HKEY hkey;
    LARGE_INTEGER SKUData;
    DWORD DataType;
    DWORD DataSize;
    DWORD NumberOfProcessors;

    //
    // Fetch the SKU Data from the registry
    //
    d = RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"System\\Setup",0,KEY_READ,&hkey);
    if(d == NO_ERROR) {

        DataSize = sizeof(ULONGLONG);
        d = RegQueryValueEx(hkey,L"SystemPrefix",NULL,&DataType,(PBYTE)&SKUData,&DataSize);
        if(d == NO_ERROR) {

            //
            // The SKU Data contains several pieces of information.
            //
            // The registered processor related pieces are
            //
            // Bits 5 - 9  : The maximum number of processors that the system is licensed
            //               to use. The value stored is actually ~(MaxProcessors-1)
            //

            //
            // Compute Licensed Processors
            //

            NumberOfProcessors = SKUData.LowPart;
            NumberOfProcessors = NumberOfProcessors >> 5;
            NumberOfProcessors = ~NumberOfProcessors;
            NumberOfProcessors = NumberOfProcessors & 0x0000001f;
            NumberOfProcessors++;

            *LicensedProcessors = NumberOfProcessors;
        }
        RegCloseKey(hkey);
    }
    *pSKUData = SKUData;
    return(d == NO_ERROR);
}

BOOL
IsStandardServerSKU(
    PBOOL pIsServer
    )
{
    BOOL  fReturnValue = (BOOL) FALSE;
    OSVERSIONINFOEX  VersionInfo;
    BOOL  IsServer = FALSE;

     //
     // get the current SKU.
     //
     VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
     if (GetVersionEx((OSVERSIONINFO *)&VersionInfo)) {
         fReturnValue = TRUE;
         //
         // is it some sort of server SKU?
         //
         if (VersionInfo.wProductType != VER_NT_WORKSTATION) {

             //
             // standard server or a server variant?
             //
             if ((VersionInfo.wSuiteMask & (VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER)) == 0) {
                 //
                 // it's standard server
                 //
                 IsServer = TRUE;
             }

         }

         *pIsServer = IsServer;

     }

     return(fReturnValue);


}

BOOL
SetEnabledProcessorCount(
    VOID
    )
{
    DWORD d;
    REGVALITEM RegistryItem;
    HKEY hkey;
    DWORD Size;
    DWORD Type;
    DWORD OriginalLicensedProcessors;
    DWORD LicensedProcessors;
    LARGE_INTEGER SKUData;
    BOOL IsServer = FALSE;

    if ( !ReadAndParseProcessorLicenseInfo(&OriginalLicensedProcessors,&SKUData) ) {
        return FALSE;
    }

    LicensedProcessors = OriginalLicensedProcessors;
    if(Upgrade) {

        //
        // During an upgrade, do not let the user go backwards.
        // (except for standard server SKU)
        //
        if (!IsStandardServerSKU(&IsServer) || IsServer == FALSE) {
            if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,SessionManagerKeyName,0,KEY_QUERY_VALUE,&hkey) == NO_ERROR) {

                Size = sizeof(d);
                if((RegQueryValueEx(hkey,szLicensedProcessors,NULL,&Type,(LPBYTE)&d,&Size) == NO_ERROR)
                && (Type == REG_DWORD)
                && (d >= LicensedProcessors)) {

                    LicensedProcessors = d;

                }

                RegCloseKey(hkey);
            }

        }

    }


    d = LicensedProcessors;
    RegistryItem.Data = &d;
    RegistryItem.Size = sizeof(DWORD);
    RegistryItem.Type = REG_DWORD;
    RegistryItem.Name = szRegisteredProcessors;

    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,SessionManagerKeyName,&RegistryItem,1);

    if ( d == NO_ERROR ) {
        RegistryItem.Data = &LicensedProcessors;
        RegistryItem.Size = sizeof(DWORD);
        RegistryItem.Type = REG_DWORD;
        RegistryItem.Name = szLicensedProcessors;

        d = SetGroupOfValues(HKEY_LOCAL_MACHINE,SessionManagerKeyName,&RegistryItem,1);
    }

    if ( d == NO_ERROR && LicensedProcessors >= OriginalLicensedProcessors) {

        //
        // need to update SKUData to reflect the fact the we are running with
        // a licensed processor count that is different from what is programmed
        // in the hives.
        //

        //
        // Convert Licensed Processors to Registry Format
        //

        LicensedProcessors--;

        LicensedProcessors = ~LicensedProcessors;
        LicensedProcessors = LicensedProcessors << 5;
        LicensedProcessors &= 0x000003e0;

        //
        // Store NumberOfProcessors into the registry
        //

        SKUData.LowPart &= ~0x000003e0;
        SKUData.LowPart |= LicensedProcessors;

        RegistryItem.Data = &SKUData;
        RegistryItem.Size = sizeof(SKUData);
        RegistryItem.Type = REG_BINARY;
        RegistryItem.Name = L"SystemPrefix";

        d = SetGroupOfValues(HKEY_LOCAL_MACHINE,L"SYSTEM\\Setup",&RegistryItem,1);
    }


    return(d == NO_ERROR);
}


#ifdef PRERELEASE
UINT
ValidateGroupOfValues(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    )
{
    UINT i;
    LONG rc;
    HKEY hkey;
    UINT RememberedRc;

    //
    // Open the key first.
    //
    rc = RegOpenKeyEx(
            RootKey,
            SubkeyName,
            0,
            KEY_READ,
            &hkey
            );

    if(rc != NO_ERROR) 
    {
        SetupDebugPrint2(L"RegOpenKeyEx failed on key:%s errorcode: %d\n",
            SubkeyName, rc);
        return(FALSE);
    }

    RememberedRc = NO_ERROR;
    //
    // Query all values in the given list.
    //
    for(i=0; i<ValueCount; i++) {
        DWORD size;
        DWORD dontcare;
        BYTE  *data;
        size = ValueList[i].Size;
        data = LocalAlloc(LPTR, size);
        if (data)
        {
            rc = RegQueryValueEx(
                hkey,
                ValueList[i].Name,
                NULL,
                &dontcare,
                data,
                &size
                );
            if (rc == ERROR_SUCCESS)
            {
                // See if the data we read is the same then what is in the registery
                if (memcmp(data, ValueList[i].Data, size) != 0)
                {
                    // Data is different that what we expect.
                    SetupDebugPrint2(L"ValidateGroupOfValues, data difference for key:%s Valuename:%s\n",
                        SubkeyName, ValueList[i].Name);

                }
            }
            else
            {
                SetupDebugPrint3(L"RegQueryValueEx failed on key:%s Valuename:%s, errorcode: %d\n",
                    SubkeyName, ValueList[i].Name, rc);
                RememberedRc = rc;
            }
            LocalFree(data);
        }
    }

    RegCloseKey(hkey);

    return(RememberedRc == NO_ERROR);
}

void ValidateProductIDInReg()
{
    REGVALITEM RegistryItem[2];

    RegistryItem[0].Name = L"ProductId";
    RegistryItem[0].Data = ProductId20FromProductId30;
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Size = (lstrlen(ProductId20FromProductId30)+1)*sizeof(WCHAR);

    ValidateGroupOfValues(HKEY_LOCAL_MACHINE,WindowsCurrentVersionKeyName,&RegistryItem[0],1);

    RegistryItem[1].Name = L"DigitalProductId";
    RegistryItem[1].Data = DigitalProductId;
    RegistryItem[1].Type = REG_BINARY;
    RegistryItem[1].Size = (DWORD)*DigitalProductId;
    ValidateGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,&RegistryItem[0],2);
    ValidateGroupOfValues(HKEY_LOCAL_MACHINE,IEProductVersionKeyName,&RegistryItem[0],2);

    return;
}
#endif

BOOL
SetProductIdInRegistry(
    VOID
    )
{
    DWORD d;
    REGVALITEM RegistryItem[2];

    BEGIN_SECTION(L"SetProductIdInRegistry");
    if (*ProductId20FromProductId30 == L'\0')
    {
        SetupDebugPrint(L"ProductId20FromProductId30 is empty\n");    
    }
    RegistryItem[0].Name = L"ProductId";
    RegistryItem[0].Data = ProductId20FromProductId30;
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Size = (lstrlen(ProductId20FromProductId30)+1)*sizeof(WCHAR);

    // SetGroupOfValues is logging it's errors
    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,WindowsCurrentVersionKeyName,&RegistryItem[0],1);

    if (*DigitalProductId == 0)
    {
        SetupDebugPrint(L"DigitalProductId is empty\n");    
    }
    //
    // first dword of the binary blob is the size
    //
    RegistryItem[1].Name = L"DigitalProductId";
    RegistryItem[1].Data = DigitalProductId;
    RegistryItem[1].Type = REG_BINARY;
    RegistryItem[1].Size = (DWORD)*DigitalProductId;

    if (d == NO_ERROR) {
        // SetGroupOfValues is logging it's errors
        d = SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,&RegistryItem[0],2);
    }

    if (d == NO_ERROR) {
        d = SetGroupOfValues(HKEY_LOCAL_MACHINE,IEProductVersionKeyName,&RegistryItem[0],2);
    }

#ifdef PRERELEASE
    ValidateProductIDInReg();
#endif
    END_SECTION(L"SetProductIdInRegistry");
    return(d == NO_ERROR);
}

DWORD
SetCurrentProductIdInRegistry(
    VOID
    )
{
    DWORD d;
    REGVALITEM RegistryItem[1];

    BEGIN_SECTION(L"SetCurrentProductIdInRegistry");
    if (*ProductId20FromProductId30 == L'\0')
    {
        SetupDebugPrint(L"ProductId20FromProductId30 is empty\n");    
    }
    RegistryItem[0].Name = szCurrentProductId;
    RegistryItem[0].Data = ProductId20FromProductId30;
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Size = (lstrlen(ProductId20FromProductId30)+1)*sizeof(WCHAR);

    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,&RegistryItem[0],1);

    END_SECTION(L"SetCurrentProductIdInRegistry");
    return(d);
}

VOID
DeleteCurrentProductIdInRegistry(
    VOID
    )
{
    HKEY    hKey = 0;
    ULONG   Error;

    BEGIN_SECTION(L"DeleteCurrentProductIdInRegistry");
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          WinntSoftwareKeyName,
                          0,
                          KEY_SET_VALUE,
                          &hKey );

    if (Error == NO_ERROR) {
        Error = RegDeleteValue(hKey, szCurrentProductId);
    }
    if (hKey) {
        RegCloseKey(hKey);
    }
    END_SECTION(L"DeleteCurrentProductIdInRegistry");
}

BOOL
SetProductTypeInRegistry(
    VOID
    )
{
    WCHAR ProductTypeName[24];
    REGVALITEM RegistryItem;
    DWORD d;

    ProductTypeName[0] = '\0';
    SetUpProductTypeName(ProductTypeName,sizeof(ProductTypeName)/sizeof(WCHAR));
    RegistryItem.Data = ProductTypeName;
    RegistryItem.Size = (lstrlen(ProductTypeName)+1)*sizeof(WCHAR);
    RegistryItem.Type = REG_SZ;
    RegistryItem.Name = L"ProductType";

    if( MiniSetup ) {
        d = NO_ERROR;
    } else {
        d = SetGroupOfValues(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                &RegistryItem,
                1
                );
    }

    return(d == NO_ERROR);
}


BOOL
SetAutoAdminLogonInRegistry(
    LPWSTR Username,
    LPWSTR Password
    )
{
#define    AnswerBufLen (4*MAX_PATH)
#define    NumberOfEntries  5

    REGVALITEM RegistryItem[NumberOfEntries];
    DWORD      d;
    WCHAR      AnswerFile[AnswerBufLen];
    WCHAR      Answer[AnswerBufLen];
    DWORD      zero = 0;
    DWORD      NumberOfEntriesSet = 4;

    RegistryItem[0].Data = L"1";
    RegistryItem[0].Size = (lstrlen(RegistryItem[0].Data)+1)*sizeof(WCHAR);
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Name = L"AutoAdminLogon";

    RegistryItem[1].Data = Username;
    RegistryItem[1].Size = (lstrlen(RegistryItem[1].Data)+1)*sizeof(WCHAR);
    RegistryItem[1].Type = REG_SZ;
    RegistryItem[1].Name = L"DefaultUserName";

    RegistryItem[2].Data = Password;
    RegistryItem[2].Size = (lstrlen(RegistryItem[2].Data)+1)*sizeof(WCHAR);
    RegistryItem[2].Type = REG_SZ;
    RegistryItem[2].Name = L"DefaultPassword";

    RegistryItem[3].Data = Win32ComputerName;
    RegistryItem[3].Size = (lstrlen(RegistryItem[3].Data)+1)*sizeof(WCHAR);
    RegistryItem[3].Type = REG_SZ;
    RegistryItem[3].Name = L"DefaultDomainName";

    if (Win95Upgrade)
    {
        //
        // To support autologon for 9x upgrade to HOME test automation
        // 
        
        RegistryItem[4].Data = &zero;
        RegistryItem[4].Size = sizeof(zero);
        RegistryItem[4].Type = REG_DWORD;
        RegistryItem[4].Name = L"LogonType";

        NumberOfEntriesSet = 5;
    }

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
            RegistryItem,
            NumberOfEntriesSet
            );

    if( d != NO_ERROR ) {
        return FALSE;
    }

    //
    // Now set the AutoLogonCount entry if it's in the unattend file.
    //

    //
    // Pickup the answer file.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    //
    // Is AutoLogonCount specified?
    //
    if( GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                 TEXT("AutoLogonCount"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {

        if( lstrcmp( pwNull, Answer ) ) {
        DWORD   Val;

            //
            // We got an answer.  If it's valid, then set it.
            //
            Val = wcstoul(Answer,NULL,10);

            RegistryItem[0].Data = &Val;
            RegistryItem[0].Size = sizeof(DWORD);
            RegistryItem[0].Type = REG_DWORD;
            RegistryItem[0].Name = TEXT("AutoLogonCount");

            d = SetGroupOfValues(
                    HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                    RegistryItem,
                    1 );
        }
    }

    return(d == NO_ERROR);
}

BOOL
SetProfilesDirInRegistry(
    LPWSTR ProfilesDir
    )
{
    REGVALITEM RegistryItem[1];
    DWORD d;


    RegistryItem[0].Data = ProfilesDir;
    RegistryItem[0].Size = (lstrlen(RegistryItem[0].Data)+1)*sizeof(WCHAR);
    RegistryItem[0].Type = REG_EXPAND_SZ;
    RegistryItem[0].Name = L"ProfilesDirectory";

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
            RegistryItem,
            1
            );

    return(d == NO_ERROR);
}

BOOL
ResetSetupInProgress(
    VOID
    )
{
    REGVALITEM RegistryItems[2];
    DWORD Zero;
    DWORD d;

    Zero = 0;

    RegistryItems[0].Name = L"SystemSetupInProgress";
    RegistryItems[0].Data = &Zero;
    RegistryItems[0].Size = sizeof(DWORD);
    RegistryItems[0].Type = REG_DWORD;

    if(Upgrade) {
        RegistryItems[1].Name = L"UpgradeInProgress";
        RegistryItems[1].Data = &Zero;
        RegistryItems[1].Size = sizeof(DWORD);
        RegistryItems[1].Type = REG_DWORD;
    }

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\Setup",
            RegistryItems,
            Upgrade ? 2 : 1
            );

    return(d == NO_ERROR);
}


BOOL
RemoveRestartStuff(
    VOID
    )
{
    #define     AnswerBufLen (4*MAX_PATH)
    HKEY hKeySetup;
    DWORD rc;
    BOOL AnyErrors;
    PWSTR *MultiSz;
    UINT Count;
    UINT i;
    BOOL Found;
    WCHAR c;
    UINT        Type;
    WCHAR       AnswerFile[AnswerBufLen];
    WCHAR       Answer[AnswerBufLen];

    AnyErrors = FALSE;

    //
    // Delete the 'RestartSetup' value.
    //
    rc = (DWORD)RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    L"System\\Setup",
                    0,
                    KEY_SET_VALUE | KEY_QUERY_VALUE,
                    &hKeySetup
                    );

    if(rc == NO_ERROR) {
        rc = (DWORD)RegDeleteValue(hKeySetup,L"RestartSetup");
        if((rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND)) {
            AnyErrors = TRUE;
        }
        RegCloseKey(hKeySetup);
    } else {
        AnyErrors = TRUE;
    }

    if(AnyErrors) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_REMOVE_RESTART_FAIL,
            rc,
            NULL,NULL);

        return FALSE;
    }

    //
    // Take care of the MiniSetup-specific items...
    //
    if( MiniSetup ) {
    BOOLEAN     FixupSourcePath;

        //
        // We've set a registry key specific to MiniSetup to
        // signal lsass to skip generating a new SID.  He
        // wanted to because he thinks we're setting up
        // a machine.  We need to delete that key now.
        //
        rc = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  L"System\\Setup",
                                  0,
                                  KEY_SET_VALUE | KEY_QUERY_VALUE,
                                  &hKeySetup );

        if(rc == NO_ERROR) {

            // There are reboot cases where OOBE doesn't want these values
            // modified.  OOBE is responsible for setting them appropriately
            // during its cleanup.
            //
            if (! OobeSetup)
            {
                //
                // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
                //
                rc = 0;
                RegSetValueEx( hKeySetup,
                               TEXT( "SetupType" ),
                               0,
                               REG_DWORD,
                               (CONST BYTE *)&rc,
                               sizeof(DWORD));
                RegDeleteValue(hKeySetup,L"MiniSetupInProgress");
            }
            RegDeleteValue(hKeySetup,L"MiniSetupDoPnP");
            RegCloseKey(hKeySetup);
        } else {
            AnyErrors = TRUE;
        }

        if(AnyErrors) {
            //
            // No.  This is a don't-care failure.
            //
        }

        //
        // Now fixup the SourcePath entry.
        //
        // For the MiniSetup case, we'll use an unattend key to determine
        // how to set the sourcepath.  The possible scenarios are:
        // [Unattended]
        // ResetSourcePath=*                This will indicate that we should
        //                                  not modify the existing source path
        //
        // ResetSourcePath="my_path"        This will indicate that we should use
        //                                  this as our new source path.
        //
        // <nothing>                        Reset the source path to the CDROM.
        //
        //


        //
        // Pickup the answer file.
        //
        GetSystemDirectory(AnswerFile,MAX_PATH);
        pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

        //
        // Assume we need to fixup the sourcepath.
        //
        FixupSourcePath = TRUE;

        //
        // Go retrieve this key from the unattend file.
        //
        if( GetPrivateProfileString( pwUnattended,
                                     TEXT("ResetSourcePath"),
                                     pwNull,
                                     Answer,
                                     AnswerBufLen,
                                     AnswerFile ) ) {
            //
            // We got an answer.  See what he wants us to do.
            //
            if( !wcscmp( L"*", Answer ) ) {
                //
                // He gave us a "*", so don't change anything.
                //
                FixupSourcePath = FALSE;
            } else {
                //
                // We'll be using the contents of Answer for the
                // new source path.
                //
                FixupSourcePath = TRUE;
            }
        } else {
            //
            // Reset the source path to the first CDROM.
            // Assume conservatively that we don't have a CDROM, and
            // in that case, we won't be resetting the source path.
            //

            FixupSourcePath = FALSE;

            //
            // Don't change the sourcepath if the directory specified in 
            // the key exists.
            //
            rc = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup",
                                      0,
                                      KEY_SET_VALUE | KEY_QUERY_VALUE,
                                      &hKeySetup );
            if( rc == NO_ERROR ) {
                TCHAR CurrentSourcePath[MAX_PATH] = L"";
                DWORD Size = sizeof(CurrentSourcePath);
                DWORD dwAttr;
                UINT  OldMode;

                //
                // Avoid system popups.
                //
                OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
            
                //
                // Read the current value.
                //
                rc = RegQueryValueEx( hKeySetup,
                                      TEXT("SourcePath"),
                                      0,
                                      0,
                                      (LPBYTE)CurrentSourcePath,
                                      &Size);
                
// Set up the ARCH_DIR based on the current binary architecture
//
#ifdef _X86_
    #define ARCH_DIR L"i386"
#else
    #define ARCH_DIR L"ia64"
#endif               
                
                //
                // If the current directory (with arch) exists and it is on a fixed disk and it
                // is not a root directory then don't change it, otherwise change it.
                //
                if ( !((rc == NO_ERROR) &&
                       (CurrentSourcePath[0]) &&
                       (CurrentSourcePath[1] == L':') &&
                       (MyGetDriveType(CurrentSourcePath[0]) == DRIVE_FIXED) &&
                       (pSetupConcatenatePaths(CurrentSourcePath, ARCH_DIR, MAX_PATH, NULL)) &&
                       ((dwAttr = GetFileAttributes(CurrentSourcePath)) != 0xFFFFFFFF) &&
                       (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
                      )
                   ) {                
                
                    Type = DRIVE_CDROM;
                    
                    wcscpy( Answer, L"A:\\" );
                    for( c = L'A'; c <= L'Z'; c++ ) {
                        if( MyGetDriveType(c) == DRIVE_CDROM ) {
                    
                            //
                            // Got it.  Remember the drive letter for
                            // the CDROM and break.
                            //
                            Answer[0] = c;
                    
                            FixupSourcePath = TRUE;
                    
                            break;
                        }
                    }       
                }
                SetErrorMode(OldMode);
                RegCloseKey( hKeySetup );
            }
        }

        if( FixupSourcePath ) {
            //
            // If we get here, then Answer contains the new source path.
            //

            rc = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup",
                                      0,
                                      KEY_SET_VALUE | KEY_QUERY_VALUE,
                                      &hKeySetup );
            if( rc == NO_ERROR ) {
                //
                // Set the value.  Ignore the return.
                //
                RegSetValueEx( hKeySetup,
                               TEXT("SourcePath" ),
                               0,
                               REG_SZ,
                               (LPBYTE)Answer,
                               (lstrlen(Answer)+1) * sizeof(WCHAR) );

                RegSetValueEx( hKeySetup,
                               TEXT("ServicePackSourcePath" ),
                               0,
                               REG_SZ,
                               (LPBYTE)Answer,
                               (lstrlen(Answer)+1) * sizeof(WCHAR) );

                //
                // Now we need to determine if the drive we're setting him to
                // is a CDROM.
                //
                if( (Answer[1] == L':') &&
                    (MyGetDriveType(Answer[0]) == DRIVE_CDROM) ) {

                    rc = 1;
                    RegSetValueEx( hKeySetup,
                                   TEXT("CDInstall" ),
                                   0,
                                   REG_DWORD,
                                   (CONST BYTE *)&rc,
                                   sizeof(DWORD));
                }

                RegCloseKey( hKeySetup );
            }
        }
    }




    //
    // See if we need to disable the Admin account.  Only do this if
    // the user asked us to *and* the machine has been joined to a
    // domain.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);
    if( GetPrivateProfileString( pwData,
                                 TEXT("DisableAdminAccountOnDomainJoin"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {

        if( wcscmp( L"", Answer ) ) {

            PWSTR                   SpecifiedDomain = NULL;
            NETSETUP_JOIN_STATUS    JoinStatus;

            //
            // See if we're in a domain.
            //
            rc = NetGetJoinInformation( NULL,
                                        &SpecifiedDomain,
                                        &JoinStatus );

            if( SpecifiedDomain ) {
                NetApiBufferFree( SpecifiedDomain );
            }

            if( (rc == NO_ERROR) &&
                (JoinStatus == NetSetupDomainName) ) {


                //
                // Yes.  Go disable the Admin account.
                //
                DisableLocalAdminAccount();
            }
        }
    }



    //
    // Remove sprestrt.exe from the session manager execute list.
    //
    rc = pSetupQueryMultiSzValueToArray(
            HKEY_LOCAL_MACHINE,
            SessionManagerKeyName,
            szBootExecute,
            &MultiSz,
            &Count,
            TRUE
            );

    if(rc == NO_ERROR) {

        Found = FALSE;
        for(i=0; i<Count && !Found; i++) {

            if(!_wcsnicmp(MultiSz[i],L"sprestrt",8)) {
                //
                // Found it, remove it.
                //
                Found = TRUE;

                MyFree(MultiSz[i]);

                MoveMemory(&MultiSz[i],&MultiSz[i+1],((Count-i)-1)*sizeof(PWSTR));
                Count--;
            }
        }

        if(Found) {

            rc = pSetupSetArrayToMultiSzValue(
                    HKEY_LOCAL_MACHINE,
                    SessionManagerKeyName,
                    szBootExecute,
                    MultiSz,
                    Count
                    );

            if(rc != NO_ERROR) {
                AnyErrors = TRUE;
            }
        }

        pSetupFreeStringArray(MultiSz,Count);
    }

    if(AnyErrors) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_REMOVE_RESTART_FAIL,
            rc,
            NULL,NULL);
    }

    return(!AnyErrors);
}


BOOL
MakeWowEntry(
    VOID
    )
{
    REGVALITEM RegistryItem;
    WCHAR WowSize[256];
    DWORD d;

#ifdef _X86_
    lstrcpy(WowSize,L"16");
#else
    lstrcpy(WowSize,L"0");
#endif

    RegistryItem.Name = L"wowsize";
    RegistryItem.Data = WowSize;
    RegistryItem.Size = (lstrlen(WowSize)+1)*sizeof(WCHAR);
    RegistryItem.Type = REG_SZ;

    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Control\\WOW",
            &RegistryItem,
            1
            );
    return(d == NO_ERROR);
}


VOID
RestoreOldPathVariable(
    VOID
    )
{
    HKEY hkey;
    LONG rc;
    DWORD Size;
    DWORD BufferSize;
    PWSTR Data;
    DWORD Type;
    BOOL b;


    b = FALSE;
    rc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            EnvironmentKeyName,
            0,
            KEY_QUERY_VALUE | KEY_SET_VALUE,
            &hkey
            );

    if(rc == NO_ERROR) {

        Size = 0;
        rc = RegQueryValueEx(hkey,L"OldPath",NULL,&Type,NULL,&Size);
        if(rc == NO_ERROR) {

            BufferSize = Size;
            if(Data = MyMalloc(BufferSize)) {

                rc = RegQueryValueEx(hkey,L"OldPath",NULL,&Type,(LPBYTE)Data,&Size);
                if(rc == NO_ERROR) {

                    if( Data && *Data )
                        rc = RegSetValueEx(hkey,L"Path",0,Type,(LPBYTE)Data,Size);

                    rc = RegDeleteValue(hkey,L"OldPath");

                    if(rc == NO_ERROR) {
                        b = TRUE;
                    }
                }

                MyFree(Data);
            }
        }

        RegCloseKey(hkey);
    }

    if( rc != NO_ERROR ){
        SetupDebugPrint1(L"Setup: (non-critical error) Could not restore PATH variable - Error %lx\n", rc );
        SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_RESTORE_PATH_FAILURE,
                            NULL,NULL);
    }



    return;

}


BOOL
FixQuotaEntries(
    VOID
    )
{
    BOOL b;
    HKEY key1,key2;
    LONG rc,rc1,rc2;
    PCWSTR szPagedPoolSize = L"PagedPoolSize";
    PCWSTR szRegistryLimit = L"RegistrySizeLimit";
    DWORD Size;
    DWORD Type;
    DWORD PoolSize,RegistryLimit;

    MYASSERT(Upgrade);

    if(ISDC(ProductType)) {

        b = FALSE;

        //
        // Open keys.
        //
        rc = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                MemoryManagementKeyName,
                0,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &key1
                );

        if(rc == NO_ERROR) {

            rc = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    ControlKeyName,
                    0,
                    KEY_QUERY_VALUE | KEY_SET_VALUE,
                    &key2
                    );

            if(rc == NO_ERROR) {

                b = TRUE;

                //
                // Read paged pool size and registry limit. If either is not present,
                // then we're done.
                //
                Size = sizeof(DWORD);
                rc1 = RegQueryValueEx(
                            key1,
                            szPagedPoolSize,
                            NULL,
                            &Type,
                            (LPBYTE)&PoolSize,
                            &Size
                            );

                Size = sizeof(DWORD);
                rc2 = RegQueryValueEx(
                            key2,
                            szRegistryLimit,
                            NULL,
                            &Type,
                            (LPBYTE)&RegistryLimit,
                            &Size
                            );

                if((rc1 == NO_ERROR) && (rc2 == NO_ERROR)
                && (PoolSize == (48*1024*1024))
                && (RegistryLimit == (24*1024*1024))) {
                    //
                    // Values are in bogus state. Clean them up.
                    //
                    PoolSize = 0;
                    RegistryLimit = 0;
                    rc1 = RegSetValueEx(
                                key1,
                                szPagedPoolSize,
                                0,
                                REG_DWORD,
                                (CONST BYTE *)&PoolSize,
                                sizeof(DWORD)
                                );

                    rc2 = RegSetValueEx(
                                key2,
                                szRegistryLimit,
                                0,
                                REG_DWORD,
                                (CONST BYTE *)&RegistryLimit,
                                sizeof(DWORD)
                                );

                    if((rc1 != NO_ERROR) || (rc2 != NO_ERROR)) {
                        b = FALSE;
                    }
                }

                RegCloseKey(key2);
            }

            RegCloseKey(key1);
        }
    } else {
        b = TRUE;
    }

    return(b);
}


//
// Stamps the current build number into the .default hive
// which is then saved into the Default User hive
//

BOOL
StampBuildNumber(
    VOID
    )
{
    OSVERSIONINFO ver;
    HKEY hKeyWinlogon;
    DWORD dwVer, dwDisp;
    LONG lResult;


    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&ver)) {
        return FALSE;
    }

    dwVer = LOWORD(ver.dwBuildNumber);

    lResult = RegCreateKeyEx (HKEY_USERS,
                              TEXT(".DEFAULT\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKeyWinlogon,
                              &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }


    RegSetValueEx (hKeyWinlogon, TEXT("BuildNumber"), 0, REG_DWORD,
                   (LPBYTE) &dwVer, sizeof(dwVer));

    RegCloseKey (hKeyWinlogon);


    return TRUE;
}


VOID
pCheckAnswerFileForProgramFiles (
    IN OUT  PWSTR PfPath,
    IN      UINT UnattendId
    )

/*++

Routine Description:

  pCheckAnswerFileForProgramFiles checks the unattend.txt data structure to
  see if the user supplied a new value for one of the paths of program files.
  If an entry is specified, it is validated, and the directory is created if
  it does not already exist.

Arguments:

  PfPath     - Specifies the current program files path, receives the new
               path.
  UnattendId - Specifies which unattend.txt entry to process.  This is a
               constant defined in unattend.h.

Return Value:

  None.

--*/

{
    DWORD Attributes;
    WCHAR Path[MAX_PATH / 2];
    WCHAR fullPath[MAX_PATH];

    if (Unattended) {
        //
        // If an answer file setting exists for this unattend ID,
        // test the path, and if it does not exist, try creating it.
        // If the path is an actual local directory, then use it.
        //

        if (UnattendAnswerTable[UnattendId].Present) {

            lstrcpyn (Path, UnattendAnswerTable[UnattendId].Answer.String, ARRAYSIZE(Path));

            *fullPath = 0;
            GetFullPathName (Path, ARRAYSIZE(fullPath), fullPath, NULL);

            Attributes = GetFileAttributes (fullPath);

            if (Attributes == 0xFFFFFFFF) {
                CreateDirectory (fullPath, NULL);
                Attributes = GetFileAttributes (fullPath);
            }

            if (Attributes != 0xFFFFFFFF && (Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
                lstrcpy (PfPath, fullPath);
            }
        }
    }
}


BOOL
SetProgramFilesDirInRegistry(
    VOID
    )
{
    DWORD d;
#if defined(WX86) || defined(_WIN64) // non-x86 platforms that have WX86 defined
    REGVALITEM RegistryItem[4];
#else
    REGVALITEM RegistryItem[2];
#endif
    WCHAR   DirPath0[ MAX_PATH + 1 ];
    WCHAR   DirPath1[ MAX_PATH + 1 ];
#if defined(WX86) || defined(_WIN64)
    WCHAR   DirPath2[ MAX_PATH + 1 ];
    WCHAR   DirPath3[ MAX_PATH + 1 ];
#endif
    WCHAR   DirName[ MAX_PATH + 1 ];
    DWORD Result;


    //
    //  Get the letter of the drive where the system is installed
    //
    Result = GetWindowsDirectory(DirPath0, sizeof(DirPath0)/sizeof(WCHAR));
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    DirPath0[3] = (WCHAR)'\0';
#if defined(WX86) || defined(_WIN64)
    lstrcpy(DirPath2, DirPath0);
#endif

    //
    //  Get the name of the 'Program Files' directory
    //
    LoadString(MyModuleHandle,
               IDS_PROGRAM_FILES_DIRECTORY,
               DirName,
               MAX_PATH+1);
    //
    //  Build the full path
    //
    lstrcat( DirPath0, DirName );
    lstrcpy( DirPath1, DirPath0 );
#if defined(WX86) || defined(_WIN64)
    //
    //  Get the name of the 'Program Files (x86)' directory
    //
    LoadString(MyModuleHandle,
               IDS_PROGRAM_FILES_DIRECTORY_WX86,
               DirName,
               MAX_PATH+1);
    //
    //  Build the full path
    //
    lstrcat( DirPath2, DirName );
    lstrcpy( DirPath3, DirPath2 );
#endif

    //
    //  Put it on the registry
    //
    pCheckAnswerFileForProgramFiles (DirPath0, UAE_PROGRAMFILES);

    RegistryItem[0].Name = L"ProgramFilesDir";
    RegistryItem[0].Data = DirPath0;
    RegistryItem[0].Type = REG_SZ;
    RegistryItem[0].Size = (lstrlen(DirPath0)+1)*sizeof(WCHAR);

    //
    //  Get the name of the 'Common Files' directory
    //
    LoadString(MyModuleHandle,
               IDS_COMMON_FILES_DIRECTORY,
               DirName,
               MAX_PATH+1);
    //
    //  Build the full path
    //
    lstrcat( DirPath1, L"\\" );
    lstrcat( DirPath1, DirName );
    //
    //  Put it on the registry
    //
    pCheckAnswerFileForProgramFiles (DirPath1, UAE_COMMONPROGRAMFILES);

    RegistryItem[1].Name = L"CommonFilesDir";
    RegistryItem[1].Data = DirPath1;
    RegistryItem[1].Type = REG_SZ;
    RegistryItem[1].Size = (lstrlen(DirPath1)+1)*sizeof(WCHAR);

#if defined(WX86) || defined(_WIN64)

    SetEnvironmentVariableW (L"ProgramFiles(x86)", DirPath2);
    SetEnvironmentVariableW (L"CommonProgramFiles(x86)", DirPath3);

    //
    //  Put it on the registry
    //
    pCheckAnswerFileForProgramFiles (DirPath2, UAE_PROGRAMFILES_X86);

    RegistryItem[2].Name = L"ProgramFilesDir (x86)";
    RegistryItem[2].Data = DirPath2;
    RegistryItem[2].Type = REG_SZ;
    RegistryItem[2].Size = (lstrlen(DirPath2)+1)*sizeof(WCHAR);

    //
    //  Build the full path
    //
    lstrcat( DirPath3, L"\\" );
    lstrcat( DirPath3, DirName );
    //
    //  Put it on the registry
    //
    pCheckAnswerFileForProgramFiles (DirPath3, UAE_COMMONPROGRAMFILES_X86);

    RegistryItem[3].Name = L"CommonFilesDir (x86)";
    RegistryItem[3].Data = DirPath3;
    RegistryItem[3].Type = REG_SZ;
    RegistryItem[3].Size = (lstrlen(DirPath3)+1)*sizeof(WCHAR);
#endif

    d = SetGroupOfValues(HKEY_LOCAL_MACHINE,
                         WindowsCurrentVersionKeyName,
                         RegistryItem,
                         sizeof(RegistryItem)/sizeof(REGVALITEM));



    //
    // Set the ProgramFiles and wx86 Program Files environment
    // variable in setup's process so that ExpandEnvironmentStrings
    // can be used later.
    //

    SetEnvironmentVariableW (L"ProgramFiles", DirPath0);
    SetEnvironmentVariableW (L"CommonProgramFiles", DirPath1);

#if defined(WX86) || defined(_WIN64)
    //
    // also set programfiles and commonprogramfiles for 32 bit applications on
    // the machine
    //
    RegistryItem[2].Name = L"ProgramFilesDir";
    RegistryItem[3].Name = L"CommonFilesDir";

    SetGroupOfValues_32(HKEY_LOCAL_MACHINE,
                     WindowsCurrentVersionKeyName,
                     &RegistryItem[2],
                     2 );
#endif

    return (d == NO_ERROR);
}


BOOL
SaveAndReplaceSystemHives(
    VOID
)

/*++

Routine Description:

    Saave the system hives listed on HiveTable.
    This is the remove fragmentation from the current system hives.
    The hives that are successfully saved, will be used later on, to replace
    the current system hives.

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/


{
    int i;
    WCHAR Name1[MAX_PATH],Name2[MAX_PATH];
    PWSTR p, q;
    LONG  Error;
    HKEY  Key;
    BOOL  b = TRUE;

    //
    //  Initialize buffers with path to the config directory
    GetSystemDirectory(Name1,MAX_PATH);
    pSetupConcatenatePaths(Name1,L"CONFIG\\",MAX_PATH,NULL);
    lstrcpy(Name2,Name1);
    //
    //  Remember the position of file names in the buffers
    //
    p = Name1 + lstrlen( Name1 );
    q = Name2 + lstrlen( Name2 );

    //
    //  Delete the files that need to be deleted before they
    //  are even created. This is done before the system hive
    //  is saved, because the list of files to be deleted on
    //  reboot is stored in the system hive.
    //
    for(i=0; i<sizeof(HiveTable)/sizeof(HiveTable[0]); i++) {

        lstrcpy(p, HiveTable[i].NewHive);
        lstrcpy(q, HiveTable[i].DeleteHive);

        Error = MoveFileEx( Name1, NULL, MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT );
        lstrcat(Name1,L".LOG");
        Error = MoveFileEx( Name1, NULL, MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT );

        Error = MoveFileEx( Name2, NULL, MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT );
    }

    //
    // Enable backup privilege. Ignore any error.
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);

    for(i=0; i<sizeof(HiveTable)/sizeof(HiveTable[0]); i++) {

        //
        //  Build the name for the new hive
        //
        lstrcpy(p,HiveTable[i].NewHive);
        lstrcpy(q,HiveTable[i].DeleteHive);

        //
        //  Attempt to save the hive
        //
        if( !SaveHive( HiveTable[i].RootKey,
                       HiveTable[i].Subkey,
                       Name1,
                       REG_LATEST_FORMAT // latest format available for local hives
                       ) ) {
            b = FALSE;
            continue;
        }
        if(FileExists(Name2,NULL)) {
            //
            // If the file exists, then delete it
            //
            SetFileAttributes(Name2,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(Name2);
        }


        //
        //  Now replace the current system hive with the one just saved
        //

        Error = RegReplaceKey( HiveTable[i].RootKey,
                               HiveTable[i].Subkey,
                               Name1,
                               Name2 );

        if( Error != ERROR_SUCCESS ) {
            b = FALSE;
        }
    }
    return(b);
}


BOOL
CreateInstallDateEntry(
    )
{
    WCHAR Path[MAX_PATH];
    time_t DateVal;
    BOOL b;
    REGVALITEM SoftwareKeyItems[1];

    b = TRUE;

    //
    // Set up fields for InstallDate value.
    // This can be set only after the Date/Time wizard page was executed, otherwise the Date/Time info
    // may be wrong.
    //
    time(&DateVal);
    SoftwareKeyItems[0].Name = L"InstallDate";
    SoftwareKeyItems[0].Data = &DateVal;
    SoftwareKeyItems[0].Size = sizeof(DWORD);
    SoftwareKeyItems[0].Type = REG_DWORD;

    //
    // Write values into the registry.
    //
    if(SetGroupOfValues(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,SoftwareKeyItems,1) != NO_ERROR) {
        b = FALSE;
    }

    return(b);
}

VOID
ConfigureSystemFileProtection(
    VOID
    )
/*++

Routine Description:

    This routine looks in the unattend file to see if there are any entries
    that may need to be set in the registry for the SFP (dll cache).

Arguments:

    None.

Returns:

    None.

--*/

{
#define     AnswerBufLen (4*MAX_PATH)
WCHAR       AnswerFile[AnswerBufLen];
WCHAR       Answer[AnswerBufLen];
DWORD       d;
HKEY        hKey;

    //
    // Pickup the answer file.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    //
    // Open the target registry entry.
    //
    if (RegOpenKey( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", &hKey ) != ERROR_SUCCESS) {
        return;
    }


    //
    // we look for the following keys in the [SystemFileProtection] section:
    //

    // SFCQuota         = <hex value>, default to 0x32
    // SFCShowProgress  = <0|1>, default to 0
    // SFCDllCacheDir   = <string>, default to "%systemroot%\system32\dllcache"
    //

    //
    // SFCQuota
    //
    if( GetPrivateProfileString( TEXT("SystemFileProtection"),
                                 TEXT("SFCQuota"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            d = wcstoul(Answer,NULL,16);

            RegSetValueEx( hKey,
                           TEXT("SFCQuota"),
                           0,
                           REG_DWORD,
                           (CONST BYTE *)&d,
                           sizeof(DWORD) );
        }
    }


    //
    // SFCShowProgress
    //
    if( GetPrivateProfileString( TEXT("SystemFileProtection"),
                                 TEXT("SFCShowProgress"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            d = wcstoul(Answer,NULL,10);

            if( d <= 1 ) {
                RegSetValueEx( hKey,
                               TEXT("SFCShowProgress"),
                               0,
                               REG_DWORD,
                               (CONST BYTE *)&d,
                               sizeof(DWORD) );
            }
        }
    }


    //
    // SFCDllCacheDir
    //
    if( GetPrivateProfileString( TEXT("SystemFileProtection"),
                                 TEXT("SFCDllCacheDir"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            RegSetValueEx( hKey,
                           TEXT("SFCDllCacheDir"),
                           0,
                           REG_EXPAND_SZ,
                           (CONST BYTE *)Answer,
                           (lstrlen(Answer)+1)*sizeof(WCHAR) );
        }
    }

    RegCloseKey( hKey );
}

DWORD
QueryValueInHKLM (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    )

/*++

Routine Description:

    Queries the data for a value in HKLM.

Arguments:

    KeyName - pointer to name of the key containing the value.

    ValueName - pointer to name of the value.

    ValueType - returns the type of the value data.

    ValueData - returns a pointer to value data.  This buffer must be
        freed by the caller using MyFree.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY hkey;
    DWORD disposition;
    DWORD error;

    //
    // Open the parent key.
    //

    if ( (KeyName == NULL) || (wcslen(KeyName) == 0) ) {
        hkey = HKEY_LOCAL_MACHINE;
    } else {
        error = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                KeyName,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hkey,
                                &disposition );
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }

    //
    // Query the value to get the length of its data.
    //

    *ValueDataLength = 0;
    *ValueData = NULL;
    error = RegQueryValueEx( hkey,
                             ValueName,
                             NULL,
                             ValueType,
                             NULL,
                             ValueDataLength );

    //
    // Allocate a buffer to hold the value data.
    //

    if ( error == NO_ERROR ) {
        *ValueData = MyMalloc( *ValueDataLength );
        if ( *ValueData == NULL ) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Query the value again, this time retrieving the data.
    //

    if ( error == NO_ERROR ) {
        error = RegQueryValueEx( hkey,
                                 ValueName,
                                 NULL,
                                 ValueType,
                                 *ValueData,
                                 ValueDataLength );
        if ( error != NO_ERROR ) {
            MyFree( *ValueData );
        }
    }

    //
    // Close the parent key.
    //

    if ( hkey != HKEY_CURRENT_USER ) {
        RegCloseKey( hkey );
    }

    return error;
}


DWORD
MyCopyKeyRecursive(
    IN HKEY     DestRootKey,
    IN HKEY     SourceRootKey
    )

/*++

Routine Description:

    This function will duplicate one key (and all its subkeys)
    to another key.

Arguments:

    DestRootKey     - Root of the destination registry key.

    SourceRootKey   - Root of the source registry key.

Return Value:

    ReturnCode

--*/

{
PWCH        SubKeyName;
DWORD       SubKeyNameLength;
PVOID       DataBuffer;
DWORD       DataLength;
DWORD       maxValueDataLength;
DWORD       maxValueNameLength;
DWORD       maxKeyNameLength;
ULONG       Index;
DWORD       rc = NO_ERROR;
FILETIME    ftLastWriteTime;
HKEY        hSubDestKey, hSubSourceKey;
DWORD       dwDisp;
DWORD       Type;

    //
    // Query information about the key that we'll be inspecting.
    //
    rc = RegQueryInfoKey( SourceRootKey,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          &maxKeyNameLength,
                          NULL,
                          NULL,
                          &maxValueNameLength,
                          &maxValueDataLength,
                          NULL,
                          NULL );
    if( rc != NO_ERROR ) {
        SetupDebugPrint1( L"Setup: MyCopyKeyRecursive - RegQueryInfoKey failed (%d)", rc );
        return rc;
    }



    //
    // Enumerate all keys in the source and recursively create
    // them in the destination.
    //
    for( Index = 0; ; Index++ ) {

        //
        // Allocate a buffer large enough to hold the longest
        // key name.
        //
        SubKeyName = NULL;
        SubKeyName = MyMalloc( (maxKeyNameLength+2) * sizeof(WCHAR) );
        SubKeyNameLength = (maxKeyNameLength+2);
        if( !SubKeyName ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        rc = RegEnumKeyEx( SourceRootKey,
                           Index,
                           SubKeyName,
                           &SubKeyNameLength,
                           NULL,
                           NULL,
                           NULL,
                           &ftLastWriteTime );

        //
        // Did we error?
        //
        if( rc != ERROR_SUCCESS ) {

            //
            // Are we done?
            //
            if( rc == ERROR_NO_MORE_ITEMS ) {
                rc = ERROR_SUCCESS;
            } else {
                SetupDebugPrint1( L"Setup: MyCopyKeyRecursive - RegEnumKeyEx failed (%d)", rc );
            }

            break;
        }


        hSubDestKey = NULL;
        hSubSourceKey = NULL;
        //
        // Create the key in the destination, and call
        // ourselves again.
        //
        rc = RegCreateKeyEx( DestRootKey,
                             SubKeyName,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hSubDestKey,
                             &dwDisp );

        if( rc == ERROR_SUCCESS ) {
            rc = RegOpenKeyEx( SourceRootKey,
                               SubKeyName,
                               0,
                               KEY_READ,
                               &hSubSourceKey );
        } else {
            SetupDebugPrint2( L"Setup: MyCopyKeyRecursive - RegCreateKeyEx failed to create %ws (%d)", SubKeyName, rc );
        }


        if( rc == ERROR_SUCCESS ) {
            rc = MyCopyKeyRecursive( hSubDestKey,
                                     hSubSourceKey );
        } else {
            SetupDebugPrint2( L"Setup: MyCopyKeyRecursive - RegOpenKeyEx failed to open %ws (%d)", SubKeyName, rc );
        }


        //
        // Clean up and do the loop again.
        //
        if( hSubDestKey ) {
            RegCloseKey( hSubDestKey );
            hSubDestKey = NULL;
        }
        if( hSubSourceKey ) {
            RegCloseKey( hSubSourceKey );
            hSubSourceKey = NULL;
        }
        if( SubKeyName ) {
            MyFree( SubKeyName );
            SubKeyName = NULL;
        }


    }




    //
    // Enumerate all the value keys in the source and copy them all
    // into the destination key.
    //



    for( Index = 0; ; Index++ ) {

        //
        // Allocate a buffers large enough to hold the longest
        // name and data
        //
        SubKeyName = NULL;
        SubKeyName = MyMalloc( (maxValueNameLength+2) * sizeof(WCHAR) );
        SubKeyNameLength = (maxValueNameLength+2);
        if( !SubKeyName ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DataBuffer = NULL;
        DataBuffer = MyMalloc( maxValueDataLength+2 );
        DataLength = maxValueDataLength+2;
        if( !DataBuffer ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        rc = RegEnumValue( SourceRootKey,
                           Index,
                           SubKeyName,
                           &SubKeyNameLength,
                           NULL,
                           &Type,
                           DataBuffer,
                           &DataLength );

        //
        // Did we error?
        //
        if( rc != ERROR_SUCCESS ) {

            //
            // Are we done?
            //
            if( rc == ERROR_NO_MORE_ITEMS ) {
                rc = ERROR_SUCCESS;
            } else {
                SetupDebugPrint1( L"Setup: MyCopyKeyRecursive - RegEnumValue failed (%d)", rc );
            }

            break;
        }


        hSubDestKey = NULL;
        hSubSourceKey = NULL;
        //
        // Create the value key in the destination.
        //
        rc = RegSetValueEx( DestRootKey,
                            SubKeyName,
                            0,
                            Type,
                            DataBuffer,
                            DataLength );

        if( rc != ERROR_SUCCESS ) {
            SetupDebugPrint2( L"Setup: MyCopyKeyRecursive - RegSetValueEx failed to set %ws (%d)", SubKeyName, rc );
        }

        //
        // Clean up and do the loop again.
        //
        if( SubKeyName ) {
            MyFree( SubKeyName );
            SubKeyName = NULL;
        }
        if( DataBuffer ) {
            MyFree( DataBuffer );
            DataBuffer = NULL;
        }

    }





    return rc;
}


DWORD
MyCopyKey (
    IN HKEY        DestRootKey,
    IN PCWSTR      DestKeyName,
    IN HKEY        SourceRootKey,
    IN PCWSTR      SourceKeyName
    )

/*++

Routine Description:

    This function will duplicate one key (and all its subkeys)
    to another key.

    Note that we're not just going to lay the new key ontop of
    the destination.  We're going to actually replace the destination
    with the source.

Arguments:

    DestRootKey     - Root of the destination registry key.

    DestKeyName     - Name of teh source registry key.

    SourceRootKey   - Root of the source registry key.

    SourceKeyName   - Name of teh source registry key.

Return Value:

    ReturnCode

--*/

{
UINT        i;
HKEY        hDestKey = NULL, hSourceKey = NULL;
DWORD       ActionTaken;
UINT        RememberedRc;
DWORD       rc = NO_ERROR;

    //
    // Don't accept any NULL parameters.
    //
    if( (SourceRootKey == NULL ) ||
        (SourceKeyName == NULL ) ||
        (DestRootKey   == NULL ) ||
        (DestKeyName   == NULL ) ) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Open our source key.
    //
    rc = RegOpenKeyEx( SourceRootKey,
                       SourceKeyName,
                       0,
                       KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                       &hSourceKey );

    if( rc != NO_ERROR ) {
        SetupDebugPrint2( L"Setup: MyCopyKey - Failed to open %ws (%d)", SourceKeyName, rc );
        return rc;
    }



    //
    // Remove the destination key.
    //
    if( rc == NO_ERROR ) {
        pSetupRegistryDelnode( DestRootKey,
                         DestKeyName );
    }


    //
    // Now copy over the source key into the destination key.
    //
    //
    // Open/create the key first.
    //
    if( rc == NO_ERROR ) {
        rc = RegCreateKeyEx( DestRootKey,
                             DestKeyName,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_SET_VALUE,
                             NULL,
                             &hDestKey,
                             &ActionTaken );

        if( rc != NO_ERROR ) {
            SetupDebugPrint2( L"Setup: MyCopyKey - Failed to create %ws (%d)", DestKeyName, rc );
        }
    }


    //
    // We've got handles to both keys, now we're ready to call
    // our worker.
    //
    if( rc == NO_ERROR ) {
        rc = MyCopyKeyRecursive( hDestKey,
                                 hSourceKey );
        if( rc != NO_ERROR ) {
            SetupDebugPrint1( L"Setup: MyCopyKey - MyCopyKeyRecursive failed (%d)", rc );
        }
    }


    //
    // Clean up and exit.
    //
    if( hSourceKey ) {
        RegCloseKey( hSourceKey );
    }
    if( hDestKey ) {
        RegCloseKey( hDestKey );
    }

    return rc;

}


DWORD
FixupUserHives(
    VOID
    )

/*++

Routine Description:

    This function will take some of the changes we've made to
    the default hive and copy them into the various user hives.

Arguments:

    NONE

Return Value:

    ReturnCode

--*/

{
DWORD               rc = ERROR_SUCCESS;
WCHAR               ProfilesDir[MAX_PATH*2];
WCHAR               HiveName[MAX_PATH*2];
WCHAR               ValueBuffer[MAX_PATH*2];
DWORD               dwSize;
HANDLE              FindHandle;
WIN32_FIND_DATA     FileData;
DWORD               Type, DataSize;
HKEY                TmpKey1, TmpKey2;


    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);

    //
    // Take care of every profile we find.
    //
    dwSize = (MAX_PATH * 2);
    if( GetProfilesDirectory( ProfilesDir, &dwSize ) ) {
        pSetupConcatenatePaths( ProfilesDir, L"\\*", (MAX_PATH*2), NULL );
        FindHandle = FindFirstFile( ProfilesDir, &FileData );

        if( FindHandle != INVALID_HANDLE_VALUE ) {

            do {
                //
                // We got something, but remember that we only want directories.
                //
                if( (FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                    (wcscmp(FileData.cFileName,L"."))                      &&
                    (wcscmp(FileData.cFileName,L"..")) ) {

                    //
                    // He's a directory and he's not parent or current.
                    // Generate a path to his hive.
                    //
                    dwSize = (MAX_PATH * 2);
                    GetProfilesDirectory( HiveName, &dwSize );

                    pSetupConcatenatePaths( HiveName, FileData.cFileName, (MAX_PATH*2), NULL );
                    pSetupConcatenatePaths( HiveName, L"\\NTUSER.DAT", (MAX_PATH*2), NULL );

                    rc = RegLoadKey( HKEY_LOCAL_MACHINE,
                                     L"MiniSetupTemp",
                                     HiveName );


                    if( rc == ERROR_SUCCESS ) {

                        //
                        // Take care of the 'International' key
                        //
                        rc = MyCopyKey( HKEY_LOCAL_MACHINE,
                                        L"MiniSetupTemp\\Control Panel\\International",
                                        HKEY_CURRENT_USER,
                                        L"Control Panel\\International" );
                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint2( L"Setup: FixupUserHive - Failed to update Control Panel\\International in %ws (%d)", HiveName, rc );
                        }


                        //
                        // Take care of the 'Keyboard Layout' key
                        //
                        rc = MyCopyKey( HKEY_LOCAL_MACHINE,
                                        L"MiniSetupTemp\\Keyboard Layout",
                                        HKEY_CURRENT_USER,
                                        L"Keyboard Layout" );
                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint2( L"Setup: FixupUserHive - Failed to update Keyboard Layout in %ws (%d)", HiveName, rc );
                        }


                        //
                        // Take care of the 'Input Method' key
                        //
                        rc = MyCopyKey( HKEY_LOCAL_MACHINE,
                                        L"MiniSetupTemp\\Control Panel\\Input Method",
                                        HKEY_CURRENT_USER,
                                        L"Control Panel\\Input Method" );
                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint2( L"Setup: FixupUserHive - Failed to update Input Method in %ws (%d)", HiveName, rc );
                        }


                        //
                        // If the user has modified the internationalization settings
                        // in intl.cpl, then there's likely a 'Run' key.  We need to migrate that
                        // too.  We need to be careful here though.  The established users may already
                        // have value keys set under here.  We only need to set *our* single value
                        // key under here.  That value is called 'internat.exe'.  If it's there, we
                        // need to prop it out to the hives we're modifying.
                        //
                        rc = RegOpenKeyEx( HKEY_CURRENT_USER,
                                           REGSTR_PATH_RUN,
                                           0,
                                           KEY_READ,
                                           &TmpKey1 );
                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint1( L"Setup: FixupUserHive - Failed to open Run key (%d)", rc );
                        } else {

                            DataSize = sizeof(ValueBuffer);
                            rc = RegQueryValueEx( TmpKey1,
                                                  L"internat.exe",
                                                  NULL,
                                                  &Type,
                                                  (PBYTE)ValueBuffer,
                                                  &DataSize );

                            RegCloseKey( TmpKey1 );

                            if( rc == ERROR_SUCCESS ) {
                                //
                                // It's there.  Prop it into the existing hives too.
                                // We can't just use RegSetValueEx though because that API
                                // may tell us we succeeded, when in fact if the key doesn't
                                // exist, we won't set it.  To fix that, first create the
                                // key.
                                //
                                rc = RegCreateKeyEx ( HKEY_LOCAL_MACHINE,
                                                      TEXT("MiniSetupTemp\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"),
                                                      0,
                                                      NULL,
                                                      REG_OPTION_NON_VOLATILE,
                                                      KEY_WRITE,
                                                      NULL,
                                                      &TmpKey1,
                                                      &DataSize);

                                if( rc == ERROR_SUCCESS ) {

                                    wcscpy( ValueBuffer, L"internat.exe" );
                                    rc = RegSetValueEx( TmpKey1,
                                                        L"Internat.exe",
                                                        0,
                                                        REG_SZ,
                                                        (LPBYTE)ValueBuffer,
                                                        (lstrlen(ValueBuffer)+1)*sizeof(WCHAR) );

                                    RegCloseKey( TmpKey1 );

                                    if( rc != ERROR_SUCCESS ) {
                                        SetupDebugPrint2( L"Setup: FixupUserHive - Failed to set internat.exe key in hive %ws (%d)", HiveName, rc );
                                    }


                                } else {
                                    SetupDebugPrint1( L"Setup: FixupUserHive - Failed to create MiniSetupTemp\\Software\\Microsoft\\Windows\\CurrentVersion\\Run key (%d)", rc );
                                }


                            }

                        }



                        rc = RegUnLoadKey( HKEY_LOCAL_MACHINE,
                                           L"MiniSetupTemp" );

                        if( rc != ERROR_SUCCESS ) {
                            SetupDebugPrint2( L"Setup: FixupUserHive - Failed to unload %ws (%d)", HiveName, rc );
                        }

                    } else {
                        SetupDebugPrint2( L"Setup: FixupUserHive - Failed to load %ws (%d)", HiveName, rc );
                    }
                }
            } while( FindNextFile( FindHandle, &FileData ) );

        }

    } else {
        SetupDebugPrint( L"Setup: FixupUserHive - Failed to get Profiles path." );
    }

    return rc;

}


void LogPidValues()
{
    LONG rc;
    HKEY hkey = NULL;
    WCHAR RegProductId[MAX_PRODUCT_ID+1];
    BYTE  RegDigitalProductId[DIGITALPIDMAXLEN];
    DWORD Size;
    DWORD Type;

#ifdef PRERELEASE
    ValidateProductIDInReg();
#endif
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,WinntSoftwareKeyName,0,KEY_READ,&hkey);
    if (rc == ERROR_SUCCESS)
    {
        *RegProductId = L'\0';
        Size = sizeof(RegProductId);
        rc = RegQueryValueEx(hkey,L"ProductId",NULL,&Type,(PBYTE)RegProductId,&Size);
        if (rc == ERROR_SUCCESS)
        {
            if (*RegProductId == L'\0')
            {
                SetupDebugPrint(L"LogPidValues: ProductId20FromProductId30 is empty\n");    
            }
            else
            {
                SetupDebugPrint(L"LogPidValues: ProductId20FromProductId30 is NOT empty\n");    
            }
        }
        else
        {
            SetupDebugPrint1(L"LogPidValues: RegQueryValueEx on ProductId failed. Error code:%d\n",rc);    
        }
        *RegDigitalProductId = 0;
        Size = sizeof(RegDigitalProductId);
        rc = RegQueryValueEx(hkey,L"DigitalProductId",NULL,&Type,(PBYTE)RegDigitalProductId,&Size);
        if (rc == ERROR_SUCCESS)
        {
            if (*RegDigitalProductId == 0)
            {
                SetupDebugPrint(L"LogPidValues: DigitalProductId is empty\n");    
            }
            else
            {
                SetupDebugPrint(L"LogPidValues: DigitalProductId is NOT empty\n");    
            }
        }
        else
        {
            SetupDebugPrint1(L"LogPidValues: RegQueryValueEx on DigitalProductId failed. Error code:%d\n",rc);    
        }
        RegCloseKey(hkey);
    }
    else
    {
        SetupDebugPrint1(L"LogPidValues: RegOpenKeyEx on %1 failed\n",WindowsCurrentVersionKeyName);    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\ps2ppg.c ===
#include "setupp.h"
#pragma hdrstop

#include <windowsx.h>

//
// PAGE_INFO and related Prototypes
//
typedef struct _PAGE_INFO {
    HDEVINFO         deviceInfoSet;
    PSP_DEVINFO_DATA deviceInfoData;

    HKEY             hKeyDev;

    DWORD            enableWheelDetect;
    DWORD            sampleRate;
    DWORD            bufferLength;
    DWORD            mouseInitPolled;
} PAGE_INFO, * PPAGE_INFO;

PPAGE_INFO
PS2Mouse_CreatePageInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

void
PS2Mouse_DestroyPageInfo(
    PPAGE_INFO PageInfo
    );

//
// Function Prototypes
//
HPROPSHEETPAGE
PS2Mouse_CreatePropertyPage(
    PROPSHEETPAGE *  PropSheetPage,
    PPAGE_INFO       PageInfo
    );

UINT CALLBACK
PS2Mouse_PropPageCallback(
    HWND            Hwnd,
    UINT            Message,
    LPPROPSHEETPAGE PropSheetPage
    );

INT_PTR
APIENTRY
PS2Mouse_DlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

void
PS2Mouse_InitializeControls(
    HWND        ParentHwnd,
    PPAGE_INFO  PageInfo
    );

void
PS2Mouse_OnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    );

BOOL
PS2Mouse_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    );

INT_PTR
PS2Mouse_OnCtlColorStatic(
    HDC  DC,
    HWND Hwnd
    );

void
PS2Mouse_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    );

BOOL
PS2Mouse_OnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    );

BOOL
PS2Mouse_OnNotify(
    HWND    ParentHwnd,
    LPNMHDR NmHdr
    );

//
// Message macros for up down controls
//
#define UpDown_SetRange(hwndUD, nLower, nUpper)                 \
    (VOID) SendMessage((hwndUD), UDM_SETRANGE, (WPARAM) 0,      \
                       (LPARAM) MAKELONG((short) (nUpper), (short) (nLower)) )

#define UpDown_GetPos(hwndUD)                                   \
    (DWORD) SendMessage((hwndUD), UDM_GETPOS, (WPARAM) 0, (LPARAM) 0)

#define UpDown_SetPos(hwndUD, nPos)                             \
    (short) SendMessage((hwndUD), UDM_SETPOS, (WPARAM) 0,       \
                        (LPARAM) MAKELONG((short) (nPos), 0) )

#define UpDown_SetAccel(hwndUD, nCount, pAccels)                \
    (BOOL) SendMessage((hwndUD), UDM_SETACCEL, (WPARAM) nCount, \
                        (LPARAM) pAccels)

//
// Constants and strings
//
#define MOUSE_INIT_POLLED_DEFAULT 0

#define MAX_DETECTION_TYPES 3
#define WHEEL_DETECT_DEFAULT 2 // Default is now 2 for Beta3  /* 1 */

#define DATA_QUEUE_MIN      100
#define DATA_QUEUE_MAX      300
#define DATA_QUEUE_DEFAULT  100

#define SAMPLE_RATE_DEFAULT  100

const DWORD PS2Mouse_SampleRates[] =
{
    20,
    40,
    60,
    80,
    100,
    200
};

#define MAX_SAMPLE_RATES (sizeof(PS2Mouse_SampleRates)/sizeof(PS2Mouse_SampleRates[0]))

#define IDH_DEVMGR_MOUSE_ADVANCED_RATE      2002100
#define IDH_DEVMGR_MOUSE_ADVANCED_DETECT    2002110
#define IDH_DEVMGR_MOUSE_ADVANCED_BUFFER    2002120
#define IDH_DEVMGR_MOUSE_ADVANCED_INIT      2002130
#define IDH_DEVMGR_MOUSE_ADVANCED_DEFAULT   2002140

const DWORD PS2Mouse_HelpIDs[] = {
    IDC_SAMPLE_RATE,        IDH_DEVMGR_MOUSE_ADVANCED_RATE,
    IDC_WHEEL_DETECTION,    IDH_DEVMGR_MOUSE_ADVANCED_DETECT,
    IDC_BUFFER,             IDH_DEVMGR_MOUSE_ADVANCED_BUFFER,
    IDC_BUFFER_SPIN,        IDH_DEVMGR_MOUSE_ADVANCED_BUFFER,
    IDC_FAST_INIT,          IDH_DEVMGR_MOUSE_ADVANCED_INIT,
    IDC_DEFAULT,            IDH_DEVMGR_MOUSE_ADVANCED_DEFAULT,
    0, 0
    };

TCHAR szDevMgrHelp[] = L"devmgr.hlp";

TCHAR szMouseDataQueueSize[] =    L"MouseDataQueueSize";
TCHAR szSampleRate[] =            L"SampleRate";
TCHAR szEnableWheelDetection[] =  L"EnableWheelDetection";
TCHAR szMouseInitializePolled[] = L"MouseInitializePolled";
TCHAR szDisablePolledUI[] =       L"DisableInitializePolledUI";

PPAGE_INFO
PS2Mouse_CreatePageInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData)
{
    PPAGE_INFO tmp = (PPAGE_INFO) MyMalloc(sizeof(PAGE_INFO));

    if (!tmp) {
        return NULL;
    }

    tmp->deviceInfoSet = DeviceInfoSet;
    tmp->deviceInfoData = DeviceInfoData;

    tmp->hKeyDev =
        SetupDiOpenDevRegKey(DeviceInfoSet,
                             DeviceInfoData,
                             DICS_FLAG_GLOBAL,
                             0,
                             DIREG_DEV,
                             KEY_ALL_ACCESS);

    return tmp;
}

void
PS2Mouse_DestroyPageInfo(
    PPAGE_INFO PageInfo
    )
{
    if (PageInfo->hKeyDev != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(PageInfo->hKeyDev);
    }

    MyFree(PageInfo);
}

HPROPSHEETPAGE
PS2Mouse_CreatePropertyPage(
    PROPSHEETPAGE *  PropSheetPage,
    PPAGE_INFO       PageInfo
    )
{
    //
    // Add the Port Settings property page
    //
    PropSheetPage->dwSize      = sizeof(PROPSHEETPAGE);
    PropSheetPage->dwFlags     = PSP_USECALLBACK; // | PSP_HASHELP;
    PropSheetPage->hInstance   = MyModuleHandle;
    PropSheetPage->pszTemplate = MAKEINTRESOURCE(IDD_PROP_PAGE_PS2_MOUSE);

    //
    // following points to the dlg window proc
    //
    PropSheetPage->pfnDlgProc = PS2Mouse_DlgProc;
    PropSheetPage->lParam     = (LPARAM) PageInfo;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    PropSheetPage->pfnCallback = PS2Mouse_PropPageCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(PropSheetPage);
}

BOOL APIENTRY
PS2MousePropPageProvider(
    LPVOID               Info,
    LPFNADDPROPSHEETPAGE AddFunction,
    LPARAM               Lparam)
{
    PSP_PROPSHEETPAGE_REQUEST ppr;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;
    PPAGE_INFO       ppi = NULL;
    ULONG devStatus, devProblem;
    CONFIGRET cr;

    ppr = (PSP_PROPSHEETPAGE_REQUEST) Info;

    if (ppr->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {
        ppi = PS2Mouse_CreatePageInfo(ppr->DeviceInfoSet, ppr->DeviceInfoData);

        if (!ppi) {
            return FALSE;
        }

        //
        // If this fails, it is most likely that the user does not have
        //  write access to the devices key/subkeys in the registry.
        //  If you only want to read the settings, then change KEY_ALL_ACCESS
        //  to KEY_READ in CreatePageInfo.
        //
        // Administrators usually have access to these reg keys....
        //
        if (ppi->hKeyDev == (HKEY) INVALID_HANDLE_VALUE) {
            PS2Mouse_DestroyPageInfo(ppi);
            return FALSE;
        }

        //
        // Retrieve the status of this device instance.
        //
        cr = CM_Get_DevNode_Status(&devStatus,
                                   &devProblem,
                                   ppr->DeviceInfoData->DevInst,
                                   0);
        if ((cr == CR_SUCCESS) &&
            (devStatus & DN_HAS_PROBLEM) &&
            (devProblem & CM_PROB_DISABLED_SERVICE)) {
            //
            // If the controlling service has been disabled, do not show any
            // additional property pages.
            //
            return FALSE;
        }

        hpsp = PS2Mouse_CreatePropertyPage(&psp, ppi);

        if (!hpsp) {
            return FALSE;
        }

        if (!AddFunction(hpsp, Lparam)) {
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }
   }

   return TRUE;
}

UINT CALLBACK
PS2Mouse_PropPageCallback(
    HWND            Hwnd,
    UINT            Message,
    LPPROPSHEETPAGE PropSheetPage
    )
{
    PPAGE_INFO ppi;

    switch (Message) {
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        ppi = (PPAGE_INFO) PropSheetPage->lParam;
        PS2Mouse_DestroyPageInfo(ppi);

        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}


INT_PTR
APIENTRY
PS2Mouse_DlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {
    case WM_COMMAND:
        PS2Mouse_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_CONTEXTMENU:
        return PS2Mouse_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        PS2Mouse_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_CTLCOLORSTATIC:
        return PS2Mouse_OnCtlColorStatic((HDC) wParam, (HWND) lParam);

    case WM_INITDIALOG:
        return PS2Mouse_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return PS2Mouse_OnNotify(hDlg,  (NMHDR *)lParam);
    }

    return FALSE;
}

DWORD
PS2Mouse_GetSampleRateIndex(
    DWORD SampleRate
    )
{
    ULONG i;

    for (i = 0; i < MAX_SAMPLE_RATES; i++) {
        if (PS2Mouse_SampleRates[i] == SampleRate) {
            return i; 
        }
    }

    return 0;
}

void
PS2Mouse_OnDefault(
    HWND ParentHwnd,
    PPAGE_INFO PageInfo
    )
{
    UpDown_SetPos(GetDlgItem(ParentHwnd, IDC_BUFFER_SPIN), DATA_QUEUE_DEFAULT);
    ComboBox_SetCurSel(GetDlgItem(ParentHwnd, IDC_SAMPLE_RATE),
                       PS2Mouse_GetSampleRateIndex(SAMPLE_RATE_DEFAULT));
    ComboBox_SetCurSel(GetDlgItem(ParentHwnd, IDC_WHEEL_DETECTION), WHEEL_DETECT_DEFAULT);
    Button_SetCheck(GetDlgItem(ParentHwnd, IDC_FAST_INIT), !MOUSE_INIT_POLLED_DEFAULT);

    PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
}

void
PS2Mouse_OnCommand(
    HWND ParentHwnd,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PPAGE_INFO pageInfo = (PPAGE_INFO) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    if (NotifyCode == CBN_SELCHANGE) {
        PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
    }
    else {
        switch (ControlId) {
        case IDC_DEFAULT:
            PS2Mouse_OnDefault(ParentHwnd, pageInfo);
            break;

        case IDC_FAST_INIT:
            PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
            break;
        }
    }
}

BOOL
PS2Mouse_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    WinHelp(HwndControl,
            szDevMgrHelp,
            HELP_CONTEXTMENU,
            (ULONG_PTR) PS2Mouse_HelpIDs);

    return FALSE;
}

INT_PTR
PS2Mouse_OnCtlColorStatic(
    HDC  DC,
    HWND HStatic
    )
{
    UINT id = GetDlgCtrlID(HStatic);

    //
    // WM_CTLCOLORSTATIC is sent for the edit controls because they are read
    // only
    //
    if (id == IDC_BUFFER) {
        SetBkColor(DC, GetSysColor(COLOR_WINDOW));
        return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
    }

    return FALSE;
}

void
PS2Mouse_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                szDevMgrHelp,
                HELP_WM_HELP,
                (ULONG_PTR) PS2Mouse_HelpIDs);
    }
}

BOOL
PS2Mouse_OnInitDialog(
    HWND    ParentHwnd,
    HWND    FocusHwnd,
    LPARAM  Lparam
    )
{
    PPAGE_INFO pageInfo = (PPAGE_INFO) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    pageInfo = (PPAGE_INFO) ((LPPROPSHEETPAGE)Lparam)->lParam;
    SetWindowLongPtr(ParentHwnd, DWLP_USER, (ULONG_PTR) pageInfo);

    PS2Mouse_InitializeControls(ParentHwnd, pageInfo);

    return TRUE;
}

void
PS2Mouse_OnApply(
    HWND        ParentHwnd,
    PPAGE_INFO  PageInfo
    )
{
    DWORD uiEnableWheelDetect, uiSampleRate, uiBufferLength, uiMouseInitPolled;
    int iSel;
    BOOL reboot = FALSE;

    uiEnableWheelDetect =
        ComboBox_GetCurSel(GetDlgItem(ParentHwnd, IDC_WHEEL_DETECTION));
    uiBufferLength = UpDown_GetPos(GetDlgItem(ParentHwnd, IDC_BUFFER_SPIN));
    uiMouseInitPolled = !Button_GetCheck(GetDlgItem(ParentHwnd, IDC_FAST_INIT));

    //
    // Must index the array as opposed to getting a real value
    //
    iSel = ComboBox_GetCurSel(GetDlgItem(ParentHwnd, IDC_SAMPLE_RATE));
    if (iSel == CB_ERR) {
        uiSampleRate = PageInfo->sampleRate;
    }
    else {
        uiSampleRate = PS2Mouse_SampleRates[iSel];
    }

    //
    // See if anything has changed
    //
    if (uiEnableWheelDetect != PageInfo->enableWheelDetect) {
        RegSetValueEx(PageInfo->hKeyDev,
                      szEnableWheelDetection,
                      0,
                      REG_DWORD,
                      (PBYTE) &uiEnableWheelDetect,
                      sizeof(DWORD));
        reboot = TRUE;
    }

    if (uiSampleRate != PageInfo->sampleRate) {
        RegSetValueEx(PageInfo->hKeyDev,
                      szSampleRate,
                      0,
                      REG_DWORD,
                      (PBYTE) &uiSampleRate,
                      sizeof(DWORD));
        reboot = TRUE;
    }

    if (uiBufferLength != PageInfo->bufferLength) {
        RegSetValueEx(PageInfo->hKeyDev,
                      szMouseDataQueueSize,
                      0,
                      REG_DWORD,
                      (PBYTE) &uiBufferLength,
                      sizeof(DWORD));
        reboot = TRUE;
    }

    if (uiMouseInitPolled) {
        //
        // make sure if it is nonzero that it is 1
        //
        uiMouseInitPolled = 1;
    }

    if (uiMouseInitPolled != PageInfo->mouseInitPolled) {
        RegSetValueEx(PageInfo->hKeyDev,
                      szMouseInitializePolled,
                      0,
                      REG_DWORD,
                      (PBYTE) &uiMouseInitPolled,
                      sizeof(DWORD));
        reboot = TRUE;
    }

    if (reboot) {
        SP_DEVINSTALL_PARAMS   dip;

        ZeroMemory(&dip, sizeof(dip));
        dip.cbSize = sizeof(dip);

        SetupDiGetDeviceInstallParams(PageInfo->deviceInfoSet,
                                      PageInfo->deviceInfoData,
                                      &dip);

        dip.Flags |= DI_NEEDREBOOT;

        SetupDiSetDeviceInstallParams(PageInfo->deviceInfoSet,
                                      PageInfo->deviceInfoData,
                                      &dip);
    }
}

BOOL
PS2Mouse_OnNotify(
    HWND    ParentHwnd,
    LPNMHDR NmHdr
    )
{
    PPAGE_INFO pageInfo = (PPAGE_INFO) GetWindowLongPtr(ParentHwnd, DWLP_USER);

    switch (NmHdr->code) {

    //
    // The user is about to change an up down control
    //
    case UDN_DELTAPOS:
        PropSheet_Changed(GetParent(ParentHwnd), ParentHwnd);
        return FALSE;

    //
    // Sent when the user clicks on Apply OR OK !!
    //
    case PSN_APPLY:
        //
        // Write out the com port options to the registry
        //
        PS2Mouse_OnApply(ParentHwnd, pageInfo);
        SetWindowLongPtr(ParentHwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
        return TRUE;

    default:
        return FALSE;
    }
}

DWORD
PS2Mouse_SetupSpinner(
    HKEY  Hkey,
    HWND  SpinnerHwnd,
    TCHAR ValueName[],
    short MinVal,
    short MaxVal,
    short DefaultVal,
    short IncrementVal
    )
{
    DWORD dwValue, dwSize;
    UDACCEL accel;

    UpDown_SetRange(SpinnerHwnd, MinVal, MaxVal);
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        ValueName,
                        0,
                        NULL,
                        (PBYTE) &dwValue,
                        &dwSize) != ERROR_SUCCESS) {
        dwValue = DefaultVal;
    }
    if (((short) dwValue) < MinVal || ((short) dwValue) > MaxVal) {
        dwValue = DefaultVal;
    }

    if (dwValue % IncrementVal) {
        //
        // Set the value to a good one and return the one we took out of the
        // registry.  When the user applies the changes the value in the control
        // will be different and we will write the value out
        //
        UpDown_SetPos(SpinnerHwnd, dwValue - (dwValue % IncrementVal));
    }
    else {
        UpDown_SetPos(SpinnerHwnd, dwValue);
    }

    accel.nSec = 0;
    accel.nInc = IncrementVal;
    UpDown_SetAccel(SpinnerHwnd, 1, &accel);

    return dwValue;
}

DWORD
PS2Mouse_SetupSampleRate(
    HWND        ComboBoxHwnd,
    HKEY        Hkey
    )
{
    int     i;
    DWORD   dwValue, dwSize;
    BOOL    badValue = FALSE;
    TCHAR   szValue[32];

    //
    // First setup the cb, then find the correct selection
    //
    for (i = 0; i < MAX_SAMPLE_RATES; i++) {
        wsprintf(szValue, TEXT("%d"), PS2Mouse_SampleRates[i]);
        ComboBox_AddString(ComboBoxHwnd, szValue);
    }

    //
    // Get the value out of the registry.  If it not what we expect or it is not
    // there, then make sure when the user clicks OK, the values are written out
    //
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        szSampleRate,
                        0,
                        NULL,
                        (PBYTE) &dwValue,
                        &dwSize) != ERROR_SUCCESS) {
        dwValue = SAMPLE_RATE_DEFAULT;
        badValue = TRUE;
    }

    //
    // Assume the value is wrong
    //
    badValue = TRUE;
    for (i = 0; i < MAX_SAMPLE_RATES; i++) {
        if (PS2Mouse_SampleRates[i] == dwValue) {
            badValue = FALSE;
            break;
        }
    }

    if (badValue) {
        dwValue = SAMPLE_RATE_DEFAULT;
    }

    ComboBox_SetCurSel(ComboBoxHwnd, PS2Mouse_GetSampleRateIndex(dwValue));

    if (badValue) {
        return 0xffffffff;
    }
    else {
        return dwValue;
    }
}

DWORD
PS2Mouse_SetupWheelDetection(
    HWND        ComboBoxHwnd,
    HKEY        Hkey
    )
{
    int     i;
    DWORD   dwValue, dwSize;
    BOOL    badValue = FALSE;
    TCHAR   szDescription[80];
    UINT    stringIDs[MAX_DETECTION_TYPES] = {
                IDS_PS2_DETECTION_DISABLED,
                IDS_PS2_DETECTION_LOOK,
                IDS_PS2_DETECTION_ASSUME_PRESENT
            };

    //
    // First setup the cb, then find the correct selection
    //
    for (i = 0; i < MAX_DETECTION_TYPES; i++) {
        LoadString(MyModuleHandle,
                   stringIDs[i],
                   szDescription,
                   sizeof(szDescription) / sizeof(TCHAR));
        ComboBox_AddString(ComboBoxHwnd, szDescription);
    }

    //
    // Get the value out of the registry.  If it not what we expect or it is not
    // there, then make sure when the user clicks OK, the values are written out
    //
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        szEnableWheelDetection,
                        0,
                        NULL,
                        (PBYTE) &dwValue,
                        &dwSize) != ERROR_SUCCESS) {
        dwValue = WHEEL_DETECT_DEFAULT;
        badValue = TRUE;
    }

    if (dwValue > 2) {
        dwValue = WHEEL_DETECT_DEFAULT;
        badValue = TRUE;
    }

    ComboBox_SetCurSel(ComboBoxHwnd, dwValue);

    if (badValue) {
        return 0xffffffff;
    }
    else {
        return dwValue;
    }
}

ULONG
PSMouse_SetupFastInit(
    HWND CheckBoxHwnd,
    HKEY Hkey
    )
{
    DWORD dwSize, dwValue, dwDisable = FALSE;
    BOOL  badValue = FALSE;

    //
    // Get the value out of the registry.  If it not what we expect or it is not
    // there, then make sure when the user clicks OK, the values are written out
    //
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        szMouseInitializePolled,
                        0,
                        NULL,
                        (PBYTE) &dwValue,
                        &dwSize) != ERROR_SUCCESS) {
        dwValue = MOUSE_INIT_POLLED_DEFAULT;
        badValue = TRUE;
    }

    //
    // Make sure the value is 1 or 0.  If it is nonzero and not 1, it is assumed
    // to be 1
    //
    if (dwValue != 0 && dwValue != 1) {
        dwValue = 1;
        badValue = TRUE;
    }

    //
    // This is a bit confusing.  The UI has fast initialization, but underneath
    // it is represented as initialize polled which is fast when it is false,
    // but we must show true to the user
    //
    Button_SetCheck(CheckBoxHwnd, !dwValue);

    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(Hkey,
                        szDisablePolledUI,
                        0,
                        NULL,
                        (PBYTE) &dwDisable,
                        &dwSize) == ERROR_SUCCESS &&
        dwDisable != FALSE) {
        EnableWindow(CheckBoxHwnd, FALSE);
    }

    if (badValue) {
        return -1;
    }
    else {
        return dwValue;
    }
}

void
PS2Mouse_InitializeControls(
    HWND       ParentHwnd,
    PPAGE_INFO PageInfo
    )
{
    HKEY        hKey;
    HWND        hwnd;
    DWORD       dwValue, dwSize;
    int         i;

    if (PageInfo->hKeyDev == (HKEY) INVALID_HANDLE_VALUE) {
        //
        // Disable all of the controls
        //
        return;
    }

    PageInfo->bufferLength =
        PS2Mouse_SetupSpinner(PageInfo->hKeyDev,
                              GetDlgItem(ParentHwnd, IDC_BUFFER_SPIN),
                              szMouseDataQueueSize,
                              DATA_QUEUE_MIN,
                              DATA_QUEUE_MAX,
                              DATA_QUEUE_DEFAULT,
                              10);

    PageInfo->sampleRate =
        PS2Mouse_SetupSampleRate(GetDlgItem(ParentHwnd, IDC_SAMPLE_RATE),
                                 PageInfo->hKeyDev);

    PageInfo->enableWheelDetect =
        PS2Mouse_SetupWheelDetection(GetDlgItem(ParentHwnd, IDC_WHEEL_DETECTION),
                                     PageInfo->hKeyDev);

    PageInfo->mouseInitPolled =
        PSMouse_SetupFastInit(GetDlgItem(ParentHwnd, IDC_FAST_INIT),
                              PageInfo->hKeyDev);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\printupg.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    printupg.c

Abstract:

    Module to upgrade printer drivers and related stuff.

    Top-level routines: UpgradePrinters

Author:

    Ted Miller (tedm) 4-Aug-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
//  Maximum time to wait for the spooler service to start
//
#define MAXIMUM_WAIT_TIME   30000

DWORD
UpgradePrinters(
    VOID
    )

/*++

Routine Description:

    Top level routine to upgrade printer drivers.

    Call out to ntprint.dll to to the upgrade.

Arguments:

    None.

Return Value:

    Win32 error code indicating outcome of operation.
    NO_ERROR if successful.

--*/

{
    DWORD ReturnCode;
    BOOL b;
    SERVICE_STATUS ServiceStatus;
    DWORD InitialTickCount;
    SC_HANDLE hSC,hService;
    HINSTANCE NtPrintLibrary;
    UPGRADEPRINTERSPROC UpgradeRoutine;


    //
    // Make sure the spooler is running.
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT);
    SetupDebugPrint( L"UpgradePrinters: Just opened SCManager");
    if(hSC == NULL) {
        ReturnCode = GetLastError();
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenSCManager,
            ReturnCode,
            L"SC_MANAGER_CONNECT",
            NULL,NULL);
        return(ReturnCode);
    }
    hService = OpenService(hSC,L"Spooler",SERVICE_START | SERVICE_QUERY_STATUS);
    SetupDebugPrint1( L"UpgradePrinters: Just opened service spooler, ret = %d", hService);
    CloseServiceHandle(hSC);
    if(hService == NULL) {
        ReturnCode = GetLastError();
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenService,
            ReturnCode,
            L"Spooler",
            NULL,NULL);
        return(ReturnCode);
    }
    if( !StartSpooler()) {
        ReturnCode = GetLastError();
        SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_PRINTUPG_FAILED, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_PARAM_RETURNED_WINERR,
                szStartService,
                ReturnCode,
                L"Spooler",
                NULL,NULL);
        KdPrint(("SETUP: Unable to start spooler for printer upgrade (%u)\n",ReturnCode));
        CloseServiceHandle(hService);
        return(ReturnCode);
    }

    //
    // Wait for the service to start.
    //
    InitialTickCount = GetTickCount();
    while(TRUE) {
        if(QueryServiceStatus(hService,&ServiceStatus)) {
            if( ServiceStatus.dwCurrentState == SERVICE_RUNNING ) {
                KdPrint(("SETUP: spooler started after %u seconds. \n",(GetTickCount() - InitialTickCount) /1000));
                break;
            } else if( ServiceStatus.dwCurrentState == SERVICE_START_PENDING ) {
                if( ( GetTickCount() - InitialTickCount ) < MAXIMUM_WAIT_TIME ) {
                    // KdPrint(("SETUP: spooler has been starting for the past %u seconds. \n",(GetTickCount() - InitialTickCount) /1000));
                    // Sleep( ServiceStatus.dwWaitHint );
                    Sleep( 1000 );
                } else {
                    //
                    //  Assume that the service is hung
                    //
                    KdPrint(("SETUP: the spooler appears to be hung. It has been starting for more than %u seconds. \n", MAXIMUM_WAIT_TIME/1000));
                    SetuplogError(
                        LogSevWarning,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_PRINTUPG_FAILED, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_SPOOLER_TIMEOUT, NULL,
                        NULL);
                    //
                    //  Return the same error code that EnumPrinterDrivers()
                    //  would return if called, but the spooler wasn't started
                    //
                    CloseServiceHandle(hService);
                    return(RPC_S_SERVER_UNAVAILABLE);
                }
            } else {
                //
                //  The service is not running and is not starting
                //
                KdPrint(("SETUP: Spooler is not running and is is not starting. ServiecState = (%u)\n", ServiceStatus.dwCurrentState));
                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_PRINTUPG_FAILED, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_SPOOLER_NOT_RUNNING, NULL,
                    NULL);
                //
                //  Return the same error code that EnumPrinterDrivers()
                //  would return if called, but the spooler wasn't started
                //
                CloseServiceHandle(hService);
                return(RPC_S_SERVER_UNAVAILABLE);
            }
        } else {
            //
            //  If unable to query the spooler status, then ignore the
            //  error, wait for some time, and assume that the service is up
            //  and running. If it is not started, then the EnumeratePrinterDrivers
            //  will fail, an we will catch the error there.
            //
            ReturnCode = GetLastError();
            KdPrint(("SETUP: Unable to query spooler status. Error = (%u)\n",ReturnCode));
            Sleep( 10000 );
            break;
        }
    }
    CloseServiceHandle(hService);

    NtPrintLibrary = LoadLibrary(L"NTPRINT");
    if(!NtPrintLibrary) {

        ReturnCode = GetLastError();
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            L"LoadLibrary",
            ReturnCode,
            L"NTPRINT.DLL",
            NULL,NULL);

        return(ReturnCode);
    }

    UpgradeRoutine = (UPGRADEPRINTERSPROC)GetProcAddress(
                                            NtPrintLibrary,
                                            UPGRADEPRINTERSPROCNAME
                                            );

    if(!UpgradeRoutine) {
        ReturnCode = GetLastError();
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            L"GetProcAddress",
            ReturnCode,
            L"NTPRINT.DLL",
            NULL,NULL);

        FreeLibrary(NtPrintLibrary);
        return(ReturnCode);
    }


    ReturnCode = UpgradeRoutine(MainWindowHandle,&InternalSetupData);
    if(ReturnCode != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PRINTUPG_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            L"NTPRINT.DLL",
            ReturnCode,
            NULL,NULL);
    }

    FreeLibrary(NtPrintLibrary);
    SetupDebugPrint1( L"UpgradePrinters: leaving ret = %d", ReturnCode);
    return(ReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\repair.c ===
#include "setupp.h"
#pragma hdrstop


#define SYSTEM_HIVE             (LPWSTR)L"system"
#define SOFTWARE_HIVE           (LPWSTR)L"software"
#define SECURITY_HIVE           (LPWSTR)L"security"
#define SAM_HIVE                (LPWSTR)L"sam"
#define DEFAULT_USER_HIVE       (LPWSTR)L".default"
#define DEFAULT_USER_HIVE_FILE  (LPWSTR)L"default"
#define NTUSER_HIVE_FILE        (LPWSTR)L"ntuser.dat"
#define REPAIR_DIRECTORY        (LPWSTR)L"\\repair"
#define SETUP_LOG_FILE          (LPWSTR)L"setup.log"

#define NTUSER_COMPRESSED_FILE_NAME     ( LPWSTR )L"ntuser.da_"
#define AUTOEXEC_NT_FILE_NAME           ( LPWSTR )L"autoexec.nt"
#define CONFIG_NT_FILE_NAME             ( LPWSTR )L"config.nt"

//
// Relative costs to perform various actions,
// to help make the gas gauge mean something.
//
#define COST_SAVE_HIVE      3
#define COST_COMPRESS_HIVE  20
#define COST_SAVE_VDM_FILE  1


//
//  Structure used in the array of hives to be saved.
//  This structure contains the predefined key that contains the hive
//  to be saved, and the name of the hive root, and the name of the file
//  where the hive should be saved.
//

typedef struct _HIVE_INFO {
    HKEY            PredefinedKey;
    PWSTR           HiveName;
    PWSTR           FileName;
    } HIVE_INFO, *PHIVE_INFO;


//
//  The array below contains the location and name of all hives that
//  we need to save. When the utility is operating on the silent mode,
//  (invoked from setup), then all hives will be saved. Otherwise, only
//  system and software will be saved.
//  For this reason, do not change the order of the hives in the array
//  below. System and software must be the first elements of
//  the array.
//
static
HIVE_INFO   HiveList[] = {
    { HKEY_LOCAL_MACHINE, SYSTEM_HIVE,       SYSTEM_HIVE },
    { HKEY_LOCAL_MACHINE, SOFTWARE_HIVE,     SOFTWARE_HIVE },
    { HKEY_USERS,         DEFAULT_USER_HIVE, DEFAULT_USER_HIVE_FILE },
    { HKEY_LOCAL_MACHINE, SECURITY_HIVE,     SECURITY_HIVE },
    { HKEY_LOCAL_MACHINE, SAM_HIVE,          SAM_HIVE }
};

static
PWSTR   VdmFiles[] = {
    AUTOEXEC_NT_FILE_NAME,
    CONFIG_NT_FILE_NAME
};


DWORD
SaveOneHive(
    IN     LPWSTR DirectoryName,
    IN     LPWSTR HiveName,
    IN     HKEY   hkey,
    IN     HWND   hWnd,
    IN OUT PDWORD GaugePosition,
    IN     DWORD  GaugeDeltaUnit
    )

/*++

Routine Description:

    Save one registry hive.  The way we will do this is to do a RegSaveKey
    of the hive into a temporary localtion, and then call the LZ apis to
    compress the file from that temporary location to the floppy.

    LZ must have already been initialized via InitGloablBuffersEx()
    BEFORE calling this routine.

Arguments:

    DirectoryName - Full path of the directory where the hive will be saved.

    HiveName - base name of the hive file to save.  The file will end up
               compressed on disk with the name <HiveName>._.

    hkey - supplies handle to open key of root of hive to save.

    GaugePosition - in input, supplies current position of the gas gauge.
        On output, supplies new position of gas gauge.

    GaugeDeltaUnit - supplies cost of one unit of activity.

Return Value:

    DWORD - Return ERROR_SUCCESS if the hive was saved. Otherwise, it returns
            an error code.

--*/

{
    DWORD Status;
    WCHAR SaveFilename[ MAX_PATH + 1 ];
    WCHAR CompressPath[ MAX_PATH + 1 ];
    CHAR SaveFilenameAnsi[ MAX_PATH + 1 ];
    CHAR CompressPathAnsi[ MAX_PATH + 1 ];
    LPWSTR TempName = ( LPWSTR )L"\\$$hive$$.tmp";

    //
    // Create the name of the file into which we will save the
    // uncompressed hive.
    //

    wsprintf(SaveFilename,L"%ls\\%ls.",DirectoryName,HiveName);
    wsprintfA(SaveFilenameAnsi,"%ls\\%ls.",DirectoryName,HiveName);

    //
    // Delete the file just in case, because RegSaveKey will fail if the file
    // already exists.
    //
    SetFileAttributes(SaveFilename,FILE_ATTRIBUTE_NORMAL);
    DeleteFile(SaveFilename);

    //
    // Save the registry hive into the temporary file.
    //
    Status = RegSaveKey(hkey,SaveFilename,NULL);

    //
    //  Update the gas gauge.
    //
    *GaugePosition += GaugeDeltaUnit * COST_SAVE_HIVE;
    SendMessage(
        hWnd,
        PBM_SETPOS,
        *GaugePosition,
        0L
        );

    //
    //  If the hive was saved successfully, then delete the old compressed
    //  one if it happens to be there.
    //

    if(Status == ERROR_SUCCESS) {
        //
        // Form the name of the file into which the saved hive file is
        // to be compressed.
        //
        wsprintf(CompressPath,L"%ls\\%ls._",DirectoryName,HiveName);
        wsprintfA(CompressPathAnsi,"%ls\\%ls._",DirectoryName,HiveName );

        //
        // Delete the destination file just in case.
        //
        SetFileAttributes(CompressPath,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompressPath);
    }

    return(Status);
}

VOID
SaveRepairInfo(
    IN  HWND    hWnd,
    IN  ULONG   StartAtPercent,
    IN  ULONG   StopAtPercent
    )

/*++

Routine Description:

    This routine implements the thread that saves all system configuration
    files into the repair directory. It first saves and compresses the
    registry hives, and then it save the VDM configuration files (autoexec.nt
    and config.nt).
    If the application is running in the SilentMode (invoked by setup),
    then system, software, default, security and sam hives will be saved
    and compressed.
    If the application was invoked by the user, then only system, software
    and default will be saved.

    This thread will send messages to the gas gauge dialog prcedure, so that
    the gas gauge gets updated after each configuration file is saved.
    This thread will also inform the user about errors that might have
    occurred during the process of saving the configuration files.

Arguments:

    hWnd - handle to progress gauge

    StartAtPercent - Position where the progress window should start (0% to 100%).

    StopAtPercent - Maximum position where the progress window can be moved to (0% to 100%).

Return Value:

    None.
    However, the this routine will send a message to the dialog procedure
    that created the thread, informing the outcome the operation.

--*/

{
    DWORD    i;
    HKEY     hkey;
    BOOL     ErrorOccurred;
    CHAR     SourceUserHivePathAnsi[ MAX_PATH + 1 ];
    CHAR     UncompressedUserHivePathAnsi[ MAX_PATH + 1 ];
    CHAR     CompressedUserHivePathAnsi[ MAX_PATH + 1 ];
    WCHAR    ProfilesDirectory[ MAX_PATH + 1 ];
    WCHAR    RepairDirectory[ MAX_PATH + 1 ];
    WCHAR    SystemDirectory[ MAX_PATH + 1 ];
    WCHAR    Source[ MAX_PATH + 1 ];
    WCHAR    Target[ MAX_PATH + 1 ];
    DWORD    GaugeDeltaUnit;
    DWORD    GaugeTotalCost;
    DWORD    GaugeRange;
    DWORD    GaugePosition;
    DWORD    NumberOfHivesToSave;
    DWORD    NumberOfUserHivesToSave;
    DWORD    NumberOfVdmFiles;
    DWORD    dwSize;
    DWORD    Error;
    DWORD    Status;
    HANDLE   Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID     Luid;


    Error = ERROR_SUCCESS;

    ErrorOccurred = FALSE;
    //
    //  Compute the cost of saving the hives and vdm files.
    //  For every hive we save, we have to save a key into a file and then
    //  compress the file. After each of these tasks is completed, we upgrade
    //  the gas gauge by the amount dicated by the COST_xxx values.
    //  The cost of saving the hives depends on the mode that the utility is
    //  running.
    //
    NumberOfHivesToSave = sizeof( HiveList ) / sizeof( HIVE_INFO );

    NumberOfUserHivesToSave = 1;
    NumberOfVdmFiles = sizeof( VdmFiles ) / sizeof( PWSTR );

    GaugeTotalCost = (COST_SAVE_HIVE * NumberOfHivesToSave)
                   + (COST_SAVE_VDM_FILE * NumberOfVdmFiles);

    GaugeRange = (GaugeTotalCost*100/(StopAtPercent-StartAtPercent));
    GaugeDeltaUnit = 1;
    GaugePosition = GaugeRange*StartAtPercent/100;
    SendMessage(hWnd, WMX_PROGRESSTICKS, GaugeTotalCost, 0);
    SendMessage(hWnd,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
    SendMessage(hWnd,PBM_SETPOS,GaugePosition,0);

    //
    //  Enable BACKUP privilege
    //
    if(OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {

        if(LookupPrivilegeValue(NULL,SE_BACKUP_NAME,&Luid)) {

            NewPrivileges.PrivilegeCount = 1;
            NewPrivileges.Privileges[0].Luid = Luid;
            NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            AdjustTokenPrivileges(Token,FALSE,&NewPrivileges,0,NULL,NULL);
        }
    }

    Status = GetWindowsDirectory( RepairDirectory, sizeof( RepairDirectory ) / sizeof( WCHAR ) );
    if( Status == 0) {
        MYASSERT(FALSE);
        return;
    }
    lstrcat( RepairDirectory, REPAIR_DIRECTORY );

    dwSize = MAX_PATH + 1;
    GetDefaultUserProfileDirectoryW (ProfilesDirectory, &dwSize);

    GetSystemDirectory( SystemDirectory, sizeof( SystemDirectory ) / sizeof( WCHAR ) );

    //
    //  Make sure that the repair directory already exists.
    //  If it doesn't exist, then create one.
    //
    if( CreateDirectory( RepairDirectory, NULL )  ||
        ( ( Error = GetLastError() ) == ERROR_ALREADY_EXISTS ) ||
        ( Error == ERROR_ACCESS_DENIED )
      ) {
        //
        //  If the repair directory didn't exist and we were able to create it,
        //  or if the repair directory already exists, then save and compress
        //  the hives.
        //

        Error = ERROR_SUCCESS;
        for( i=0; i < NumberOfHivesToSave; i++ ) {
            //
            //  First open the root of the hive to be saved
            //
            Status = RegOpenKeyEx( HiveList[i].PredefinedKey,
                                   HiveList[i].HiveName,
                                   REG_OPTION_RESERVED,
                                   READ_CONTROL,
                                   &hkey );

            //
            //  If unable to open the key, update the gas gauge to reflect
            //  that the operation on this hive was completed.
            //  Otherwise, save the hive. Note that Save hive will update
            //  the gas gauge, as it saves and compresses the hive.
            //
            if(Status != ERROR_SUCCESS) {
                //
                // If this is the first error while saving the hives,
                // then save the error code, so that we can display the
                // correct error message to the user.
                //
                if( Error == ERROR_SUCCESS ) {
                    Error = Status;
                }

                //
                // Update the gas gauge
                //
                GaugePosition += GaugeDeltaUnit * (COST_SAVE_HIVE + COST_COMPRESS_HIVE);
                SendMessage( hWnd,
                             PBM_SETPOS,
                             GaugePosition,
                             0L );

            } else {
                //
                //  Save and compress the hive.
                //  Note that the gas gauge will up be updated by SaveOneHive
                //  Note also that when we save the default user hive, we skip
                //  the first character of the
                //

                Status = SaveOneHive(RepairDirectory,
                                     HiveList[i].FileName,
                                     hkey,
                                     hWnd,
                                     &GaugePosition,
                                     GaugeDeltaUnit );
                //
                // If this is the first error while saving the hives,
                // then save the error code, so that we can display the
                // correct error message to the user.
                //

                if( Error == ERROR_SUCCESS ) {
                    Error = Status;
                }

                RegCloseKey(hkey);
            }
        }

        //
        //  Save the hive for the Default User
        //

        wsprintfA(SourceUserHivePathAnsi,"%ls\\%ls",ProfilesDirectory,NTUSER_HIVE_FILE);
        wsprintfA(UncompressedUserHivePathAnsi,"%ls\\%ls",RepairDirectory,NTUSER_HIVE_FILE);
        wsprintfA(CompressedUserHivePathAnsi,  "%ls\\%ls",RepairDirectory,NTUSER_COMPRESSED_FILE_NAME);


        Status = CopyFileA (
            SourceUserHivePathAnsi,
            UncompressedUserHivePathAnsi,
            FALSE);

        if(Status) {
            //
            // Delete the destination file just in case.
            //
            SetFileAttributesA(CompressedUserHivePathAnsi,FILE_ATTRIBUTE_NORMAL);
            DeleteFileA(CompressedUserHivePathAnsi);
        } else if(Error == ERROR_SUCCESS) {
            //
            // If this is the first error, remember it.
            //
            Error = GetLastError();
        }

        //
        // Now that the hives are saved, save the vdm files
        //

        for( i = 0; i < NumberOfVdmFiles; i++ ) {
            wsprintf(Source,L"%ls\\%ls",SystemDirectory,VdmFiles[i]);
            wsprintf(Target,L"%ls\\%ls",RepairDirectory,VdmFiles[i]);
            if( !CopyFile( Source, Target, FALSE ) ) {
                Status = GetLastError();
                if( Error != ERROR_SUCCESS ) {
                    Error = Status;
                }
            }
            GaugePosition += GaugeDeltaUnit * COST_SAVE_VDM_FILE;
            SendMessage( ( HWND )hWnd,
                         PBM_SETPOS,
                         GaugePosition,
                         0L );

        }
    }

    if( Error != ERROR_SUCCESS ) {
        SetupDebugPrint1( L"SETUP: SaveRepairInfo() failed.  Error = %d", Error );
    }

    //
    // Set security on all the files.
    //
    ApplySecurityToRepairInfo();

    //
    // At this point, the operation was completed (successfully, or not).
    // So update the gas gauge to 100%
    //
    GaugePosition = GaugeRange*StopAtPercent/100;
    SendMessage(hWnd,PBM_SETPOS,GaugePosition,0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\security.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Routines to deal with security, user accounts, etc.

    Externally exposed routines:

        SignalLsa
        CreateSamEvent
        WaitForSam

        SetAccountsDomainSid
        CreateLocalAdminAccount
        CreateLocalUserAccount
        SetLocalUserPassword

Author:

    Ted Miller (tedm) 5-Apr-1995
    adapted from legacy\dll\security.c

Revision History:

--*/

#include "setupp.h"
#include <Lmaccess.h>
#pragma hdrstop


PCWSTR SamEventName = L"\\SAM_SERVICE_STARTED";

PCWSTR SsiAccountNamePostfix = L"$";
PCWSTR SsiSecretName = L"$MACHINE.ACC";

#define DOMAIN_NAME_MAX 33
#define PASSWORD_MAX 14

//
// Constants used for logging that are specific to this source file.
//
PCWSTR szLsaOpenPolicy              = L"LsaOpenPolicy";
PCWSTR szLsaSetInformationPolicy    = L"LsaSetInformationPolicy";
PCWSTR szLsaQueryInformationPolicy  = L"LsaQueryInformationPolicy";
PCWSTR szNtSetEvent                 = L"NtSetEvent";
PCWSTR szNtCreateEvent              = L"NtCreateEvent";
PCWSTR szSamConnect                 = L"SamConnect";
PCWSTR szGetAccountsDomainName      = L"GetAccountsDomainName";
PCWSTR szSamLookupDomainInSamServer = L"SamLookupDomainInSamServer";
PCWSTR szSamOpenDomain              = L"SamOpenDomain";
PCWSTR szSamEnumerateUsersInDomain  = L"SamEnumerateUsersInDomain";
PCWSTR szSamOpenUser                = L"SamOpenUser";
PCWSTR szSamChangePasswordUser      = L"SamChangePasswordUser";
PCWSTR szSamCreateUserInDomain      = L"SamCreateUserInDomain";
PCWSTR szSamQueryInformationUser    = L"SamQueryInformationUser";
PCWSTR szSamSetInformationUser      = L"SamSetInformationUser";
PCWSTR szMyAddLsaSecretObject       = L"MyAddLsaSecretObject";


VOID
SetupLsaInitObjectAttributes(
    IN OUT POBJECT_ATTRIBUTES           ObjectAttributes,
    IN OUT PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
    );

BOOL
GetAccountsDomainName(
    IN  LSA_HANDLE hPolicy,         OPTIONAL
    OUT PWSTR      Name,
    IN  DWORD      NameBufferSize
    );

LSA_HANDLE
OpenLsaPolicy(
    VOID
    );

PSID
CreateSidFromSidAndRid(
    IN PSID  DomainSid,
    IN DWORD Rid
    );

NTSTATUS
MyAddLsaSecretObject(
    IN PCWSTR Password
    );


BOOL
SetAccountsDomainSid(
    IN DWORD  Seed,
    IN PCWSTR DomainName
    )

/*++

Routine Description:

    Routine to set the sid of the AccountDomain.

Arguments:

    Seed - The seed is used to generate a unique Sid.  The seed should
        be generated by looking at the systemtime before and after
        a dialog and subtracting the milliseconds field.

    DomainName - supplies name to give to local domain

Return value:

    Boolean value indicating outcome.

--*/

{
    PSID                        Sid;
    PSID                        SidPrimary ;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE                  PolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyCurrentAccountDomainInfo = NULL;
    NTSTATUS                    Status;
    BOOL bResult;

    //
    //
    // Open the LSA Policy object to set the account domain sid.  The access
    // mask needed for this is POLICY_TRUST_ADMIN.
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);

    Status = LsaOpenPolicy(NULL,&ObjectAttributes,MAXIMUM_ALLOWED,&PolicyHandle);
    if(!NT_SUCCESS(Status)) {

        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SETACCOUNTDOMAINSID, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szLsaOpenPolicy,
            Status,
            NULL,NULL);

        return(FALSE);
    }

    Status = LsaQueryInformationPolicy(
                 PolicyHandle,
                 PolicyAccountDomainInformation,
                 &PolicyCurrentAccountDomainInfo
                 );

    if(NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&PolicyCurrentAccountDomainInfo->DomainName,DomainName);


        Status = LsaSetInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     (PVOID) PolicyCurrentAccountDomainInfo
                     );

        LsaFreeMemory( PolicyCurrentAccountDomainInfo );
    }

    if(NT_SUCCESS(Status)) {
        bResult = TRUE;
    } else {
        bResult = FALSE;
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_SETACCOUNTDOMAINSID, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szLsaSetInformationPolicy,
            Status,
            NULL,NULL);
    }

    LsaClose(PolicyHandle);
    return(bResult);
}


VOID
SetupLsaInitObjectAttributes(
    IN OUT POBJECT_ATTRIBUTES           ObjectAttributes,
    IN OUT PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
    )

/*++

Routine Description:

    This function initializes the given Object Attributes structure, including
    Security Quality Of Service.  Memory must be allcated for both
    ObjectAttributes and Security QOS by the caller. Borrowed from
    lsa

Arguments:

    ObjectAttributes - Pointer to Object Attributes to be initialized.

    SecurityQualityOfService - Pointer to Security QOS to be initialized.

Return Value:

    None.

--*/

{
    SecurityQualityOfService->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService->ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService->EffectiveOnly = FALSE;

    InitializeObjectAttributes(ObjectAttributes,NULL,0,NULL,NULL);
    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //
    ObjectAttributes->SecurityQualityOfService = SecurityQualityOfService;
}


BOOL
CreateLocalUserAccount(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    IN PSID*  PointerToUserSid   OPTIONAL
    )
/*++

Routine Description:

    Routine to add a local user account to the AccountDomain. This account
    is created with the password indicated.

Arguments:

    UserName - supplies name for user account

    Password - supplies initial password for user account.

    PointerToUserSid - If this argument is present, then on return it will contain the
                       pointer to the user sid. It is the responsibility of the caller
                       to free the Sid, using MyFree.

Return value:

    Boolean value indicating outcome.

--*/

{
    return (NT_SUCCESS(CreateLocalAdminAccount(UserName, 
                                               Password, 
                                               PointerToUserSid
                                               )
                       )
            );
}

NTSTATUS
CreateLocalAdminAccountEx(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    IN PCWSTR Description,
    IN PSID*  PointerToUserSid   OPTIONAL
    )

/*++

Routine Description:

    Routine to add a local user account to the AccountDomain. This account
    has ADMINISTRATOR priveledges and is created with the password indicated.

Arguments:

    UserName - supplies name for user account

    Password - supplies initial password for user account.

    Description - Description that appears in user manager.

    PointerToUserSid - If this argument is present, then on return it will contain the
                       pointer to the user sid. It is the responsibility of the caller
                       to free the Sid, using MyFree.

Return value:

    Boolean value indicating outcome.

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    UNICODE_STRING UnicodeString;
    SAM_HANDLE ServerHandle;
    SAM_HANDLE DomainHandle;
    SAM_HANDLE UserHandle;
    SAM_HANDLE AliasHandle;
    SAM_HANDLE BuiltinDomainHandle;
    WCHAR AccountsDomainName[DOMAIN_NAME_MAX];
    NTSTATUS Status;
    PSID BuiltinDomainId;
    PSID UserSid;
    ULONG User_RID;
    PUSER_CONTROL_INFORMATION UserControlInfo;
    USER_SET_PASSWORD_INFORMATION UserPasswordInfo;
    LSA_HANDLE                  PolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyCurrentAccountDomainInfo = NULL;
    USER_ADMIN_COMMENT_INFORMATION AdminCommentInfo;

    //
    // Use SamConnect to connect to the local domain ("") and get a handle
    // to the local sam server.
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);
    RtlInitUnicodeString(&UnicodeString,L"");
    Status = SamConnect(
                 &UnicodeString,
                 &ServerHandle,
                 SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN,
                 &ObjectAttributes
                 );

    if(!NT_SUCCESS(Status)) {
        goto err0;
    }

    //
    //  Use the LSA to retrieve the name of the Accounts domain.
    //
    if(!GetAccountsDomainName(NULL,AccountsDomainName,DOMAIN_NAME_MAX)) {
        goto err1;
    }

    //
    // Open the AccountDomain.  First find the Sid for this
    // in the Sam and then open the domain using this sid
    //
    //
    // Open the LSA Policy object to set the account domain sid.
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);

    Status = LsaOpenPolicy(NULL,&ObjectAttributes,MAXIMUM_ALLOWED,&PolicyHandle);
    if(NT_SUCCESS(Status)) {

        Status = LsaQueryInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     &PolicyCurrentAccountDomainInfo
                     );

        if(NT_SUCCESS(Status)) {

            Status = SamOpenDomain(
                         ServerHandle,
                         DOMAIN_READ | DOMAIN_LIST_ACCOUNTS | DOMAIN_LOOKUP |
                                            DOMAIN_READ_PASSWORD_PARAMETERS | DOMAIN_CREATE_USER,
                         PolicyCurrentAccountDomainInfo->DomainSid,
                         &DomainHandle
                         );
        }

        LsaClose( PolicyHandle );
    }

    if (!NT_SUCCESS(Status)) {
        goto err2;
    }

    //
    // Use SamCreateUserInDomain to create a new user with the username
    // specified.  This user account is created disabled with the
    // password not required.
    //
    RtlInitUnicodeString(&UnicodeString,UserName);
    Status = SamCreateUserInDomain(
                 DomainHandle,
                 &UnicodeString,
                 //USER_READ_ACCOUNT | USER_WRITE_ACCOUNT | USER_FORCE_PASSWORD_CHANGE,
				 USER_ALL_ACCESS,
                 &UserHandle,
                 &User_RID
                 );

    if(!NT_SUCCESS(Status)) {
        goto err3;
    }

    //
    // Query all the default control information about the user added
    //
    Status = SamQueryInformationUser(UserHandle,UserControlInformation,&UserControlInfo);
    if(!NT_SUCCESS(Status)) {
        goto err4;
    }

    //
    // If the password is a Null password, make sure the
    // password_not required bit is set before the null
    // password is set.
    //
    if(!Password[0]) {
        UserControlInfo->UserAccountControl |= USER_PASSWORD_NOT_REQUIRED;
        Status = SamSetInformationUser(UserHandle,UserControlInformation,UserControlInfo);
        if(!NT_SUCCESS(Status)) {
            goto err5;
        }
    }

    //
    // Set the password ( NULL or non NULL )
    //
    RtlInitUnicodeString(&UserPasswordInfo.Password,Password);
    UserPasswordInfo.PasswordExpired = FALSE;
    Status = SamSetInformationUser(UserHandle,UserSetPasswordInformation,&UserPasswordInfo);
    if(!NT_SUCCESS(Status)) {
        goto err5;
    }


    //
    // Set the information bits - User Password not required is cleared
    // The normal account bit is enabled and the account disabled bit
    // is also reset
    //
    UserControlInfo->UserAccountControl &= ~USER_PASSWORD_NOT_REQUIRED;
    UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
    UserControlInfo->UserAccountControl |=  USER_NORMAL_ACCOUNT;
    Status = SamSetInformationUser(UserHandle,UserControlInformation,UserControlInfo);
    if(!NT_SUCCESS(Status)) {
        goto err5;
    }


    // Set the description is one is given
    //
    if ( Description[0])
    {
        // Convert description to unicode string
        //
        RtlInitUnicodeString(&AdminCommentInfo.AdminComment,Description);

        // We do not care if this fails and therefore will not set the status
        //
        SamSetInformationUser(UserHandle,UserAdminCommentInformation,&AdminCommentInfo);
    }

    //
    //  If this is a non-standlone server we're done.
    //
    if(ISDC(ProductType)) {
        Status = STATUS_SUCCESS;
        goto err5;
    }

    //
    // Finally add this to the administrators alias in the BuiltIn Domain
    //
    RtlInitUnicodeString(&UnicodeString,L"Builtin");
    Status = SamLookupDomainInSamServer(ServerHandle,&UnicodeString,&BuiltinDomainId);
    if(!NT_SUCCESS(Status)) {
        goto err5;
    }

    Status = SamOpenDomain(
                 ServerHandle,
                 DOMAIN_READ | DOMAIN_ADMINISTER_SERVER | DOMAIN_EXECUTE,
                 BuiltinDomainId,
                 &BuiltinDomainHandle
                 );

    if(!NT_SUCCESS(Status)) {
        goto err6;
    }

    UserSid = CreateSidFromSidAndRid(PolicyCurrentAccountDomainInfo->DomainSid,User_RID);
    if(!UserSid) {
        goto err7;
    }

    Status = SamOpenAlias(BuiltinDomainHandle,ALIAS_ADD_MEMBER,DOMAIN_ALIAS_RID_ADMINS,&AliasHandle);
    if(!NT_SUCCESS(Status)) {
        goto err8;
    }

    Status = SamAddMemberToAlias(AliasHandle,UserSid);
    if(!NT_SUCCESS(Status)) {
        goto err9;
    }

    MYASSERT(NT_SUCCESS(Status));

err9:
    SamCloseHandle(AliasHandle);
err8:
    if(NT_SUCCESS(Status) && (PointerToUserSid != NULL )) {
        *PointerToUserSid = UserSid;
    } else {
        MyFree(UserSid);
    }
err7:
    SamCloseHandle(BuiltinDomainHandle);
err6:
    SamFreeMemory(BuiltinDomainId);
err5:
    SamFreeMemory(UserControlInfo);
err4:
    SamCloseHandle(UserHandle);
err3:
    SamCloseHandle(DomainHandle);
err2:
    LsaFreeMemory( PolicyCurrentAccountDomainInfo );
err1:
    SamCloseHandle(ServerHandle);
err0:
    return(Status);
}


NTSTATUS
CreateLocalAdminAccount(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    IN PSID*  PointerToUserSid   OPTIONAL
    )
/*++

Routine Description:
  
    Please see CreateLocalAdminAccountEx description.


--*/
{
    return ( CreateLocalAdminAccountEx(UserName, Password, L"", PointerToUserSid) );
}

BOOL
GetAccountsDomainName(
    IN  LSA_HANDLE PolicyHandle,    OPTIONAL
    OUT PWSTR      Name,
    IN  DWORD      NameBufferSize
    )
{
    POLICY_ACCOUNT_DOMAIN_INFO *pPadi;
    NTSTATUS Status ;
    BOOL PolicyOpened;

    PolicyOpened = FALSE;
    if(PolicyHandle == NULL) {
        if((PolicyHandle = OpenLsaPolicy()) == NULL) {
            return(FALSE);
        }

        PolicyOpened = TRUE;
    }

    Status = LsaQueryInformationPolicy(PolicyHandle,PolicyAccountDomainInformation,&pPadi);
    if(NT_SUCCESS(Status)) {
         if(NameBufferSize <= (pPadi->DomainName.Length/sizeof(WCHAR))) {
             Status = STATUS_BUFFER_TOO_SMALL;
         } else {
             wcsncpy(Name,pPadi->DomainName.Buffer,pPadi->DomainName.Length/sizeof(WCHAR));
             Name[pPadi->DomainName.Length/sizeof(WCHAR)] = 0;
         }
         LsaFreeMemory(pPadi);
    }

    if(PolicyOpened) {
        LsaClose(PolicyHandle);
    }

    return(NT_SUCCESS(Status));
}


LSA_HANDLE
OpenLsaPolicy(
    VOID
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE PolicyHandle;
    NTSTATUS Status;

    PolicyHandle = NULL;
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);
    Status = LsaOpenPolicy(NULL,&ObjectAttributes,GENERIC_EXECUTE,&PolicyHandle);

    return(NT_SUCCESS(Status) ? PolicyHandle : NULL);
}


PSID
CreateSidFromSidAndRid(
    IN PSID  DomainSid,
    IN DWORD Rid
    )

/*++

Routine Description:

    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.

Arguments:

    DomainSid - supplies sid for domain of account

    Rid - supplies relative id of account

Return Value:

    Pointer to Sid, or NULL on failure.
    The returned Sid must be freed with MyFree.

--*/
{

    NTSTATUS Status;
    PSID AccountSid;
    UCHAR AccountSubAuthorityCount;
    ULONG AccountSidLength;
    PULONG RidLocation;

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    if(AccountSid = (PSID)MyMalloc(AccountSidLength)) {
        //
        // Copy the domain sid into the first part of the account sid
        //
        Status = RtlCopySid(AccountSidLength, AccountSid, DomainSid);

        //
        // Increment the account sid sub-authority count
        //
        *RtlSubAuthorityCountSid(AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //
        RidLocation = RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount - 1);
        *RidLocation = Rid;
    }

    return(AccountSid);
}


BOOL
SetLocalUserPassword(
    IN PCWSTR AccountName,
    IN PCWSTR OldPassword,
    IN PCWSTR NewPassword
    )

/*++

Routine Description:

    Change the password for the local user account.

Arguments:

Return value:

    Boolean value indicating outcome.

--*/

{
    NTSTATUS Status;
    BOOL b;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING OtherUnicodeString;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR AccountsDomainName[DOMAIN_NAME_MAX];
    SAM_HANDLE ServerHandle;
    SAM_HANDLE DomainHandle;
    SAM_HANDLE UserHandle;
    BOOL UserFound;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    SAM_RID_ENUMERATION *SamRidEnumeration;
    UINT i;
    UINT CountOfEntries;
    ULONG UserRid;
    LSA_HANDLE                  PolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyCurrentAccountDomainInfo = NULL;

    b = FALSE;

    //
    // Use SamConnect to connect to the local domain ("") and get a handle
    // to the local sam server
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);
    RtlInitUnicodeString(&UnicodeString,L"");
    Status = SamConnect(
                 &UnicodeString,
                 &ServerHandle,
                 SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN,
                 &ObjectAttributes
                 );

    if(!NT_SUCCESS(Status)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szSamConnect,
            Status,
            NULL,NULL);
        goto err0;
    }

    //
    //  Use the LSA to retrieve the name of the Accounts domain.
    //
    if(!GetAccountsDomainName(NULL,AccountsDomainName,DOMAIN_NAME_MAX)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_STRING,
            szGetAccountsDomainName,
            szFALSE,
            NULL,NULL);
        goto err1;
    }

    //
    // Open the AccountDomain.  First find the Sid for this
    // in the Sam and then open the domain using this sid.
    //

    //
    // Get the AccountDomainSid from the Lsa
    //

    //
    //
    // Open the LSA Policy object to set the account domain sid.
    //
    SetupLsaInitObjectAttributes(&ObjectAttributes,&SecurityQualityOfService);

    Status = LsaOpenPolicy(NULL,&ObjectAttributes,MAXIMUM_ALLOWED,&PolicyHandle);
    if(NT_SUCCESS(Status)) {

        Status = LsaQueryInformationPolicy(
                     PolicyHandle,
                     PolicyAccountDomainInformation,
                     &PolicyCurrentAccountDomainInfo
                     );

        if(NT_SUCCESS(Status)) {

            Status = SamOpenDomain(
                         ServerHandle,
                         DOMAIN_READ | DOMAIN_LIST_ACCOUNTS | DOMAIN_LOOKUP |
                                            DOMAIN_READ_PASSWORD_PARAMETERS,
                         PolicyCurrentAccountDomainInfo->DomainSid,
                         &DomainHandle
                         );
            LsaFreeMemory( PolicyCurrentAccountDomainInfo );
        }

        LsaClose( PolicyHandle );
    }

    if(!NT_SUCCESS(Status)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_NTSTATUS,
            szSamOpenDomain,
            Status,
            AccountsDomainName,
            NULL,NULL);
        goto err2;
    }

    //
    // Find the account name in this domain - and extract the rid.
    //
    UserFound = FALSE;
    EnumerationContext = 0;
    RtlInitUnicodeString(&UnicodeString,AccountName);
    do {
        Status = SamEnumerateUsersInDomain(
                     DomainHandle,
                     &EnumerationContext,
                     0L,
                     &SamRidEnumeration,
                     0L,
                     &CountOfEntries
                     );

        if(!NT_SUCCESS(Status) && (Status != STATUS_MORE_ENTRIES)) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CHANGING_PW_FAIL,
                AccountName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_NTSTATUS,
                szSamEnumerateUsersInDomain,
                Status,
                NULL,NULL);
            goto err3;
        }

        //
        // go through the the SamRidEnumeration buffer for count entries.
        //
        for(i = 0; (i<CountOfEntries) && !UserFound; i++ ) {
            if(RtlEqualUnicodeString(&UnicodeString,&SamRidEnumeration[i].Name,TRUE)) {
                UserRid = SamRidEnumeration[i].RelativeId;
                UserFound = TRUE;
            }
        }

        SamFreeMemory(SamRidEnumeration);

    } while((Status == STATUS_MORE_ENTRIES) && !UserFound);

    if(!UserFound) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_USERNOTFOUND,
            NULL,NULL);
        goto err3;
    }

    //
    // Open the user
    //
    Status = SamOpenUser(
                 DomainHandle,
                 USER_READ_ACCOUNT | USER_WRITE_ACCOUNT | USER_CHANGE_PASSWORD | USER_FORCE_PASSWORD_CHANGE,
                 UserRid,
                 &UserHandle
                 );

    if(!NT_SUCCESS(Status)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szSamOpenUser,
            Status,
            NULL,NULL);
        goto err3;
    }

    //
    // Use SAM API to change the password for this Account.
    //
    RtlInitUnicodeString(&UnicodeString,OldPassword);
    RtlInitUnicodeString(&OtherUnicodeString,NewPassword);
    Status = SamChangePasswordUser(UserHandle,&UnicodeString,&OtherUnicodeString);
    if(!NT_SUCCESS(Status)) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGING_PW_FAIL,
            AccountName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_NTSTATUS,
            szSamChangePasswordUser,
            Status,
            NULL,NULL);
        goto err4;
    }

    b = TRUE;

err4:
    SamCloseHandle(UserHandle);
err3:
    SamCloseHandle(DomainHandle);
err2:
err1:
    SamCloseHandle(ServerHandle);
err0:
    return(b);
}



VOID
GenerateRandomPassword(
    OUT PWSTR Password
    )
{
    static DWORD Seed = 98725757;
    static PCWSTR UsableChars = L"ABCDEFGHIJKLMOPQRSTUVWYZabcdefghijklmopqrstuvwyz0123456789";

    UINT UsableCount;
    UINT i;

    UsableCount = lstrlen(UsableChars);
    Seed ^= GetCurrentTime();

    for(i=0; i<PASSWORD_MAX; i++) {
        Password[i] = UsableChars[RtlRandom(&Seed) % UsableCount];
    }

    Password[i] = 0;
}


NTSTATUS
MyAddLsaSecretObject(
    IN PCWSTR Password
    )

/*++

Routine Description:

    Create the Secret Object necessary to support a machine account
    on an NT domain.

Arguments:

    Password - supplies password to machine account

Return value:

    NT Status code indicating outcome.

--*/
{
    UNICODE_STRING SecretName;
    UNICODE_STRING UnicodePassword;
    NTSTATUS Status;
    LSA_HANDLE LsaHandle;
    LSA_HANDLE SecretHandle;
    OBJECT_ATTRIBUTES ObjAttr;

    RtlInitUnicodeString(&SecretName,SsiSecretName) ;
    RtlInitUnicodeString(&UnicodePassword,Password);

    InitializeObjectAttributes(&ObjAttr,NULL,0,NULL,NULL);

    Status = LsaOpenPolicy(NULL,&ObjAttr,MAXIMUM_ALLOWED,&LsaHandle);
    if(NT_SUCCESS(Status)) {

        Status = LsaCreateSecret(LsaHandle,&SecretName,SECRET_ALL_ACCESS,&SecretHandle);
        if(NT_SUCCESS(Status)) {

            Status = LsaSetSecret(SecretHandle,&UnicodePassword,&UnicodePassword);
            LsaClose(SecretHandle);
        }

        LsaClose(LsaHandle);
    }

    return(Status);
}


BOOL
AdjustPrivilege(
    IN PCWSTR   Privilege,
    IN BOOL     Enable
    )
/*++

Routine Description:

    This routine enables or disable a priviliege of the current process.

Arguments:

    Privilege - String with the name of the privilege to be adjusted.

    Enable - TRUE if the privilege is to be enabled.
             FALSE if the privilege is to be disabled.

Return Value:

    Returns TRUE if the privilege could be adjusted.
    Returns FALSE, otherwise.


--*/
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;

    TOKEN_PRIVILEGES    TokenPrivileges;


    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        SetupDebugPrint1(L"SYSSETUP: OpenProcessToken() failed. Error = %d \n", GetLastError() );
        return( FALSE );
    }


    if( !LookupPrivilegeValue( NULL,
                               Privilege,
                               &( LuidAndAttributes.Luid ) ) ) {
        SetupDebugPrint1(L"SYSSETUP: LookupPrivilegeValue failed, Error = %d \n", GetLastError() );
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    if( Enable ) {
        LuidAndAttributes.Attributes |= SE_PRIVILEGE_ENABLED;
    } else {
        LuidAndAttributes.Attributes &= ~SE_PRIVILEGE_ENABLED;
    }

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        SetupDebugPrint1(L"SYSSETUP: AdjustTokenPrivileges failed, Error = %d \n", GetLastError() );
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    CloseHandle( TokenHandle );
    return( TRUE );
}


NTSTATUS
DisableLocalUserAccount(
    PWSTR   AccountName
    )
/*++

Routine Description:

    This routine disables the local administrator account.

Arguments:

    AccountName - Name of the local account to be disabled.

Return Value:

    NTSTATUS, depending on the outcome of the operations.

--*/

{
LONG        rc;
PUSER_INFO_1 ui1;


    // Get the info.
    rc = NetUserGetInfo( NULL,
                         AccountName,
                         1,
                         (PBYTE *)(&ui1) );

    if( rc == NO_ERROR ) {

        // set the disable flag and store the info back out.
        ui1->usri1_flags |= UF_ACCOUNTDISABLE;

        rc = NetUserSetInfo( NULL,
                             AccountName,
                             1,
                             (PBYTE)ui1,
                             NULL );

        NetApiBufferFree((PVOID)ui1);
    }

    return rc;
}


NTSTATUS
DisableLocalAdminAccount(
    VOID
    )
/*++

Routine Description:

    This routine disables the local administrator account.

Arguments:

    None.

Return Value:

    NTSTATUS, depending on the outcome of the operations.

--*/

{
NTSTATUS    Status = STATUS_SUCCESS;
WCHAR       AdminAccountName[MAX_PATH];


    GetAdminAccountName( AdminAccountName );

    Status = DisableLocalUserAccount( AdminAccountName );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\services.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    services.c

Abstract:

    Routines to deal with the Windows NT service controller
    and service entries in the registry,

    Externally exposed routines:

        MyCreateService
        MyChangeServiceStart
        MyChangeServiceConfig

Author:

    Ted Miller (tedm) 5-Apr-1995
    adapted from legacy\dll\sc.c

Revision History:
    Dan Elliott (dane) 14-Aug-2000  Added WaitForScmInitialization().

--*/

#include "setupp.h"
#pragma hdrstop

//
// Constants used in logging specific to this module.
//
PCWSTR szOpenSCManager       = L"OpenSCManager";
PCWSTR szCreateService       = L"CreateService";
PCWSTR szChangeServiceConfig = L"ChangeServiceConfig";
PCWSTR szOpenService         = L"OpenService";
PCWSTR szStartService        = L"StartService";
PCWSTR szEnumDependentService= L"EnumDependentService";

PCWSTR szServicesKeyPath         = L"SYSTEM\\CurrentControlSet\\Services";
PCWSTR szDependOnService         = L"DependOnService";
PCWSTR szServicesToRename        = L"ServicesToRename";

BOOL
pSetupWaitForScmInitialization()
/*++

Routine Description:

    Wait for services.exe to signal that the Services Control Manager is
    running and autostart services have been started.

Arguments:
    None.

Return value:

    Boolean indicating whether the the SCM was started successfully.

--*/
{
    HANDLE      hEventHandle;
    DWORD       WaitStatus;

    hEventHandle = OpenEvent( SYNCHRONIZE, FALSE, SC_AUTOSTART_EVENT_NAME );
    if( hEventHandle != NULL ) {

        SetupDebugPrint1(L"SETUP: Waiting on event %ls \n", SC_AUTOSTART_EVENT_NAME );
        WaitStatus = WaitForSingleObject( hEventHandle, INFINITE );
        if( WaitStatus != WAIT_FAILED ) {
            if( WaitStatus == WAIT_OBJECT_0 ) {
                SetupDebugPrint1(L"SETUP: Wait on event %ls completed successfully \n", SC_AUTOSTART_EVENT_NAME );
            } else {
                SetupDebugPrint2(L"SETUP: Wait on event %ls failed. WaitStatus = %d \n", SC_AUTOSTART_EVENT_NAME, WaitStatus );
            }
        } else {
            DWORD   Error;

            Error = GetLastError();
            SetupDebugPrint2(L"SETUP: Wait on event %ls failed. Error = %d \n", SC_AUTOSTART_EVENT_NAME, Error );
        }
        CloseHandle( hEventHandle );
    }
    else {
        return FALSE;
    }

    return (WAIT_OBJECT_0 == WaitStatus);
}

BOOL
MyCreateService(
    IN PCWSTR  ServiceName,
    IN PCWSTR  DisplayName,         OPTIONAL
    IN DWORD   ServiceType,
    IN DWORD   StartType,
    IN DWORD   ErrorControl,
    IN PCWSTR  BinaryPathName,
    IN PCWSTR  LoadOrderGroup,      OPTIONAL
    IN PWCHAR  DependencyList,
    IN PCWSTR  ServiceStartName,    OPTIONAL
    IN PCWSTR  Password             OPTIONAL
    )

/*++

Routine Description:

    Stub for calling CreateService. If CreateService fails with
    the error code indicating that the service already exists, this routine
    calls the routine for ChangeServiceConfig to ensure that the
    parameters passed in are reflected in the services database.

Arguments:

    ServiceName - Name of service

    DisplayName - Localizable name of Service or ""

    ServiceType - Service type, e.g. SERVICE_KERNEL_DRIVER

    StartType - Service Start value, e.g. SERVICE_BOOT_START

    ErrorControl - Error control value, e.g. SERVICE_ERROR_NORMAL

    BinaryPathName - Full Path of the binary image containing service

    LoadOrderGroup - Group name for load ordering or ""

    Dependencies - MultiSz list of dependencies for this service. Any dependency
        component having + as the first character is a group dependency.
        The others are service dependencies.

    ServiceStartName - Service Start name (account name in which this service is run).

    Password - Password used for starting the service.

Return value:

    Boolean value indicating outcome.

--*/

{
    SC_HANDLE hSC;
    SC_HANDLE hSCService;
    DWORD dwTag,dw;
    BOOL b;

    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CREATESVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);
        return(FALSE);
    }

    //
    // Process the optional "" parameters passed in and make them NULL.
    //
    if(DisplayName && !DisplayName[0]) {
        DisplayName = NULL;
    }
    if(LoadOrderGroup && !LoadOrderGroup[0]) {
        LoadOrderGroup = NULL;
    }
    if(ServiceStartName && !ServiceStartName[0]) {
        ServiceStartName = NULL;
    }
    if(Password && !Password[0]) {
        Password = NULL;
    }

    //
    // Create the service.
    //

    hSCService = CreateService(
                     hSC,
                     ServiceName,
                     DisplayName,
                     0,
                     ServiceType,
                     StartType,
                     ErrorControl,
                     BinaryPathName,
                     LoadOrderGroup,
                     LoadOrderGroup ? &dwTag : NULL,
                     DependencyList,
                     ServiceStartName,
                     Password
                     );
    //
    // If we were unable to create the service, check if the service already
    // exists in which case all we need to do is change the configuration
    // parameters in the service.
    //
    if(hSCService) {
        //
        // Note that we won't do anything with the tag.
        //
        CloseServiceHandle(hSCService);
        b = TRUE;
    } else {
        if((dw = GetLastError()) == ERROR_SERVICE_EXISTS) {

            b = MyChangeServiceConfig(
                    ServiceName,
                    ServiceType,
                    StartType,
                    ErrorControl,
                    BinaryPathName,
                    LoadOrderGroup,
                    DependencyList,
                    ServiceStartName,
                    Password,
                    DisplayName
                    );
        } else {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CREATESVC_FAIL,
                ServiceName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_WINERR,
                szCreateService,
                dw,
                NULL,NULL);
            b = FALSE;
        }
    }

    CloseServiceHandle(hSC);
    return(b);
}


BOOL
MyChangeServiceConfig(
    IN PCWSTR ServiceName,
    IN DWORD  ServiceType,
    IN DWORD  StartType,
    IN DWORD  ErrorControl,
    IN PCWSTR BinaryPathName,   OPTIONAL
    IN PCWSTR LoadOrderGroup,   OPTIONAL
    IN PWCHAR DependencyList,
    IN PCWSTR ServiceStartName, OPTIONAL
    IN PCWSTR Password,         OPTIONAL
    IN PCWSTR DisplayName       OPTIONAL
    )

/*++

Routine Description:

    Wrapper for ChangeServiceConfig.

Arguments:

    ServiceName - Name of service

    ServiceType - Service type, e.g. SERVICE_KERNEL_DRIVER

    StartType - Service Start value, e.g. SERVICE_BOOT_START

    ErrorControl - Error control value, e.g. SERVICE_ERROR_NORMAL

    BinaryPathName - Full Path of the binary image containing service

    LoadOrderGroup - Group name for load ordering

    DependencyList - Multisz string having dependencies.  Any dependency
        component having + as the first character is a
        group dependency.  The others are service dependencies.

    ServiceStartName - Service Start name (account name in which this
        service is run).

    Password - Password used for starting the service.

    DisplayName - Localizable name of Service.

Return value:

    Boolean value indicating outcome.

--*/

{
    SC_LOCK sclLock;
    SC_HANDLE hSC;
    SC_HANDLE hSCService;
    DWORD dw;
    BOOL b;

    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGESVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);
        return(FALSE);
    }

    //
    // Try to lock the database, if possible. If we are not able to lock
    // the database we will still modify the services entry. This is because
    // we are just modifying a single service and chances are very low that
    // anybody else is manipulating the same entry at the same time.
    //
    SetupDebugPrint1(L"MyChangeServiceConfig: LockingServiceDatabase for service %s", ServiceName);
    sclLock = LockServiceDatabase(hSC);

    //
    // Process optional parameters
    //
    if(BinaryPathName && !BinaryPathName[0]) {
        BinaryPathName = NULL;
    }
    if(LoadOrderGroup && !LoadOrderGroup[0]) {
        LoadOrderGroup = NULL;
    }
    if(ServiceStartName && !ServiceStartName[0]) {
        ServiceStartName = NULL;
    }
    if(Password && !Password[0]) {
        Password = NULL;
    }
    if(DisplayName && !DisplayName[0]) {
        DisplayName = NULL;
    }

    //
    // Open the service with SERVICE_CHANGE_CONFIG access
    //
    if(hSCService = OpenService(hSC,ServiceName,SERVICE_CHANGE_CONFIG)) {

        b = ChangeServiceConfig(
                hSCService,
                ServiceType,
                StartType,
                ErrorControl,
                BinaryPathName,
                LoadOrderGroup,
                NULL,
                DependencyList,
                ServiceStartName,
                Password,
                DisplayName
                );

        if(!b) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CHANGESVC_FAIL,
                ServiceName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_RETURNED_WINERR,
                szChangeServiceConfig,
                GetLastError(),
                NULL,NULL);
        }
        CloseServiceHandle(hSCService);
    } else {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CHANGESVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenService,
            GetLastError(),
            NULL,NULL);
    }

    //
    // Unlock the database if locked and then close the service controller
    // handle
    //
    if(sclLock) {
        UnlockServiceDatabase(sclLock);
        SetupDebugPrint1(L"MyChangeServiceConfig: Unlocked ServiceDatabase for service %s", ServiceName);
    }

    CloseServiceHandle(hSC);
    return(b);
}


BOOL
MyChangeServiceStart(
    IN PCWSTR ServiceName,
    IN DWORD  StartType
    )

/*++

Routine Description:

    Routine to change the start value of a service. This turns
    around and calls the stub to ChangeServiceConfig.

Arguments:

    ServiceName - Name of service

    StartType - Service Start value, e.g. SERVICE_BOOT_START

Return value:

    Boolean value indicating outcome.

--*/
{
    BOOL b;

    b = MyChangeServiceConfig(
                ServiceName,
                SERVICE_NO_CHANGE,
                StartType,
                SERVICE_NO_CHANGE,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );

    return(b);
}


BOOL
SetupStartService(
    IN PCWSTR ServiceName,
    IN BOOLEAN Wait        // if TRUE, try to wait until it is started.
    )
{
    SC_HANDLE hSC,hSCService;
    BOOL b;
    DWORD d;
    DWORD dwDesiredAccess;

    b = FALSE;
    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_STARTSVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);
        return(FALSE);
    }

    if (Wait) {
        dwDesiredAccess = SERVICE_START | SERVICE_QUERY_STATUS;
    } else {
        dwDesiredAccess = SERVICE_START;
    }
    if(hSCService = OpenService(hSC,ServiceName,dwDesiredAccess)) {
        SetupDebugPrint1(L"SetupStartService: Sending StartService to <%ws>\n", ServiceName);
        b = StartService(hSCService,0,NULL);
        SetupDebugPrint1(L"SetupStartService: Sent StartService to <%ws>\n", ServiceName);
        if(!b && ((d = GetLastError()) == ERROR_SERVICE_ALREADY_RUNNING)) {
            //
            // Service is already running.
            //
            b = TRUE;
        }
        if(!b) {
            SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_STARTSVC_FAIL,
                ServiceName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_PARAM_RETURNED_WINERR,
                szStartService,
                d,
                ServiceName,
                NULL,NULL);
        }
        if (b && Wait) {
#define SLEEP_TIME 4000
#define LOOP_COUNT 30
            SERVICE_STATUS ssStatus;
            DWORD loopCount = 0;
            //SetupDebugPrint(L"  )) Looping waiting for start\n");
            do {
                b = QueryServiceStatus( hSCService, &ssStatus);
                if ( !b ) {
                    //SetupDebugPrint(L"FAILED %d\n", GetLastError());
                    break;
                }
                if (ssStatus.dwCurrentState == SERVICE_START_PENDING) {
                    //SetupDebugPrint(L"PENDING\n");
                    if ( loopCount++ == LOOP_COUNT ) {
                        //SetupDebugPrint2(L"SYSSETUP: STILL PENDING after %d times: <%ws> service\n", loopCount, ServiceName);
                        break;
                    }
                    Sleep( SLEEP_TIME );
                } else {
                    //SetupDebugPrint3(L"SYSSETUP: WAITED %d times: <%ws> service, status %d\n", loopCount, ServiceName, ssStatus.dwCurrentState);
                    break;
                }
            } while ( TRUE );
        }
        CloseServiceHandle(hSCService);
    } else {
        b = FALSE;
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_STARTSVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenService,
            GetLastError(),
            ServiceName,
            NULL,NULL);
    }

    CloseServiceHandle(hSC);

    return(b);
}

BOOL
FixServiceDependency(
    IN PCWSTR ServiceName,
    IN PCWSTR OldDependencyName,
    IN PCWSTR NewDependencyName
    )
{
    ULONG     Error;
    HKEY      hKey;
    WCHAR     ServicePath[ MAX_PATH + 1 ];
    PBYTE     OldValueData;
    PBYTE     NewValueData;
    ULONG     OldValueSize;
    ULONG     NewValueSize;
    DWORD     Type;
    PBYTE     p,q;
    BOOL      ChangeDependencyList;

    //
    //  Open the key that describes the service
    //

    lstrcpy( ServicePath, szServicesKeyPath );
    pSetupConcatenatePaths(ServicePath,ServiceName,sizeof( ServicePath )/sizeof( WCHAR ),NULL);

    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          ServicePath,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey );

    if( Error != ERROR_SUCCESS ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegOpenKeyEx,
            Error,
            ServicePath,
            NULL,NULL);
         return( FALSE );
    }

    //
    //  Allocate a buffer for the old value data
    //

    OldValueSize = 0;
    Error = RegQueryValueEx(hKey,
                            szDependOnService,
                            NULL,
                            &Type,
                            NULL,
                            &OldValueSize);
    if( ( Error != ERROR_SUCCESS ) && ( Error != ERROR_MORE_DATA ) ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegQueryValueEx,
            Error,
            szDependOnService,
            NULL,NULL);
         RegCloseKey( hKey );
         return( FALSE );
    }

    OldValueData = MyMalloc( OldValueSize );
    if( OldValueData == NULL ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
         RegCloseKey( hKey );
         return( FALSE );
    }

    //
    //  Read the value entry that lists the dependencies
    //

    Error = RegQueryValueEx(hKey,
                            szDependOnService,
                            NULL,
                            &Type,
                            OldValueData,
                            &OldValueSize);
    if( Error != ERROR_SUCCESS ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegQueryValueEx,
            Error,
            szDependOnService,
            NULL,NULL);
         MyFree( OldValueData );
         RegCloseKey( hKey );
         return( FALSE );
    }

    //
    //  Find out if the OldValueData, explicitly list OldDependencyName.
    //  If not, then the service depends on another service that depends
    //  on OlDependencyName, and in this case there is no need to change
    //  the dependency list.
    //
    p = OldValueData;
    ChangeDependencyList = FALSE;
    while( (ULONG)(p - OldValueData) < OldValueSize ) {
        if( ( lstrcmpi( (PWSTR)p, OldDependencyName ) == 0 ) ) {
            ChangeDependencyList = TRUE;
            break;
        }
        p += (lstrlen( (PWSTR)p ) + 1)*sizeof(WCHAR);
    }
    if( !ChangeDependencyList ) {
         MyFree( OldValueData );
         RegCloseKey( hKey );
         //
         // Let the caller think that the dependency list was fixed
         //
         return( TRUE );
    }

    //
    //  Allocate a buffer for the new value data
    //
    NewValueSize = OldValueSize -
                    ( lstrlen( OldDependencyName ) - lstrlen( NewDependencyName ) )*sizeof(WCHAR);

    NewValueData = MyMalloc( NewValueSize );
    if( NewValueData == NULL ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_OUTOFMEMORY,
            NULL,NULL);
         MyFree( OldValueData );
         RegCloseKey( hKey );
         return( FALSE );
    }

    //
    //  Replace the old dependency name with the new one
    //
    p = OldValueData;
    q = NewValueData;

    lstrcpy( (PWSTR)q, NewDependencyName );
    q += (lstrlen( (PWSTR)q ) + 1)*sizeof(WCHAR);
    while( (ULONG)(p - OldValueData) < OldValueSize ) {
        if( ( lstrcmpi( (PWSTR)p, OldDependencyName ) != 0 ) &&
            ( lstrcmpi( (PWSTR)p, NewDependencyName ) != 0 )
          ) {
            lstrcpy( (PWSTR)q, (PWSTR)p );
            q += (lstrlen( (PWSTR)q ) + 1)*sizeof(WCHAR);
        }
        p += (lstrlen( (PWSTR)p ) + 1)*sizeof(WCHAR);
    }

    //
    //  Save the value entry with the new dependency name
    //
    Error = RegSetValueEx( hKey,
                           szDependOnService,
                           0,
                           REG_MULTI_SZ,
                           NewValueData,
                           (DWORD)(q-NewValueData) // NewValueSize
                         );

    if( Error != ERROR_SUCCESS ) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FIX_SERVICE_FAILED,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szRegSetValueEx,
            Error,
            szDependOnService,
            NULL,NULL);
         MyFree( OldValueData );
         MyFree( NewValueData );
         RegCloseKey( hKey );
         return( FALSE );
    }

    //
    //  Free the allocated buffers
    //

    MyFree( OldValueData );
    MyFree( NewValueData );

    //
    //  Close the key
    //
    RegCloseKey( hKey );
    return( TRUE );
}


BOOL
UpdateServicesDependencies(
    IN HINF InfHandle
    )
{
    INFCONTEXT            InfContext;
    PCWSTR                OldServiceName,NewServiceName;
    BOOL                  b;
    SC_HANDLE             hSC, hSCService;
    LPENUM_SERVICE_STATUS DependentsList;
    DWORD                 BytesNeeded;
    DWORD                 ServicesReturned;
    HKEY                  hKey;
    ULONG                 Error;
    ULONG                 i;

    //
    // Iterate the [ServicesToRename] section in the inf.
    // Each line is the name of a dependecy service that needs to be renamed.
    //
    if(SetupFindFirstLine(InfHandle,szServicesToRename,NULL,&InfContext)) {
        b = TRUE;
    } else {
        SetuplogError( LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_NO_SECTION,
            szServicesToRename,NULL,NULL);
        return(FALSE);
    }

    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);
        return(FALSE);
    }

    do {
        //
        // Fetch the name of a service that got renamed
        //
        if((OldServiceName = pSetupGetField(&InfContext,0))
        && (NewServiceName = pSetupGetField(&InfContext,1))) {

            //
            //  Create a dummy service that has the same name as the old service
            //  This is necessarey so that we can get a handle to this service,
            //  and pass it to EnumDependentServices to find out the services that
            //  depend on this one.
            //

            if( !MyCreateService( OldServiceName,
                                  NULL,
                                  SERVICE_WIN32_OWN_PROCESS,
                                  SERVICE_DISABLED,
                                  SERVICE_ERROR_NORMAL,
                                  L"%SystemRoot%\\System32\\dummy.exe",
                                  NULL,
                                  L"",
                                  NULL,
                                  NULL ) ) {

                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_CANT_CREATE_DUMMY_SERVICE,
                    OldServiceName,
                    NULL,NULL);

                b = FALSE;
                continue;
            }

            //
            //  Open the service that was just created
            //

            hSCService = OpenService(hSC,OldServiceName,SERVICE_ENUMERATE_DEPENDENTS | DELETE);
            if( hSCService == NULL) {
                Error = GetLastError();
                SetupDebugPrint2( L"SYSSETUP: Unable to open service = %ls. Error = %d \n", OldServiceName, Error );
                SetuplogError( LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_PARAM_RETURNED_WINERR,
                    szOpenService,
                    Error,
                    OldServiceName,
                    NULL,NULL);
                //
                //  Force deletion of the service cretated
                //
                b = FALSE;
                Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      szServicesKeyPath,
                                      0,
                                      MAXIMUM_ALLOWED,
                                      &hKey );
                if( Error == ERROR_SUCCESS ) {
                    pSetupRegistryDelnode( hKey, OldServiceName );
                    RegCloseKey( hKey );
                }
                continue;
            }

            //
            //  Determine all services that depend on the service that was renamed
            //

            BytesNeeded = 0;
            ServicesReturned = 0;
            DependentsList = NULL;
            if( !EnumDependentServices( hSCService,
                                        SERVICE_ACTIVE | SERVICE_INACTIVE,
                                        DependentsList,
                                        0,
                                        &BytesNeeded,
                                        &ServicesReturned ) &&
                ( Error = GetLastError()) != ERROR_MORE_DATA ) {

                SetuplogError( LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_PARAM_FAILED,
                    OldServiceName, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_RETURNED_WINERR,
                    szEnumDependentService,
                    Error,
                    NULL,NULL);

                b = FALSE;
                goto delete_dummy_service;
            }

            DependentsList = MyMalloc( BytesNeeded );
            if( DependentsList == NULL ) {

                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_PARAM_FAILED,
                    OldServiceName, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_OUTOFMEMORY,
                    NULL,NULL);

                b = FALSE;
                goto delete_dummy_service;
            }

            if( !EnumDependentServices( hSCService,
                                        SERVICE_ACTIVE | SERVICE_INACTIVE,
                                        DependentsList,
                                        BytesNeeded,
                                        &BytesNeeded,
                                        &ServicesReturned ) ) {

                SetuplogError( LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_UPDATE_SERVICES_PARAM_FAILED,
                    OldServiceName, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_RETURNED_WINERR,
                    szEnumDependentService,
                    GetLastError(),
                    NULL,NULL);

                MyFree( DependentsList );
                b = FALSE;
                goto delete_dummy_service;
            }

            for( i = 0; i < ServicesReturned; i++ ) {
                //
                //  Fix the dependency for this service
                //
                b = b && FixServiceDependency( DependentsList[i].lpServiceName,
                                               OldServiceName,
                                               NewServiceName );
            }
            MyFree( DependentsList );

delete_dummy_service:

            if( !DeleteService(hSCService) &&
                ((Error = GetLastError()) != ERROR_SERVICE_MARKED_FOR_DELETE)
              ) {
                SetupDebugPrint2( L"SYSSETUP: Unable to delete service %ls. Error = %d \n", OldServiceName, Error );
#if 0
                //
                //  Force deletion of the dummy service
                //
                Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      szServicesKeyPath,
                                      0,
                                      MAXIMUM_ALLOWED,
                                      &hKey );
                if( Error == ERROR_SUCCESS ) {
                    pSetupRegistryDelnode( hKey, OldServiceName );
                    RegCloseKey( hKey );
                }
#endif
            }
            CloseServiceHandle(hSCService);


        } else {
            SetuplogError( LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_UPDATE_SERVICES_FAILED, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NO_SECTION,
                szServicesToRename,NULL,NULL);
        }

    } while(SetupFindNextLine(&InfContext,&InfContext));

    CloseServiceHandle(hSC);
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#include "..\inc\cmnres.h"

#define IDS_TITLE_INSTALL_W             1
#define IDS_TITLE_INSTALL_S             2
#define IDS_TITLE_UPGRADE_W             3
#define IDS_TITLE_UPGRADE_S             4
#define IDS_ERROR                       5
#define IDS_UNKNOWN                     6
#define IDS_FATALERROR                  7
#define IDS_DEFWALLPAPER                8
#define IDS_SETUP                       9
#define IDS_WINNT_SETUP                 10
#define IDS_DISPLAYAPPLET               11
#define IDS_ADMINISTRATOR               12
#define IDS_GUEST                       13
#define IDS_LOCAL_PORT                  14
#define IDS_MSSERIF                     15
#define IDS_LARGEFONTSIZE               16
#define IDS_LOGSEV                      17
#define IDS_LOGSEVINFO                  18
#define IDS_LOGSEVWARN                  19
#define IDS_LOGSEVERR                   20
#define IDS_LOGSEVFATAL                 21
#define IDS_MB                          22
#define IDS_INSTALLED                   23
#define IDS_HAVEDISKCAPTION             24
#define IDS_SPECIALOC_TEXT              25
#define IDS_STEPS                       26
#define IDS_STEPS_UPGRADE               27
#define IDS_FILE_PRINT_LIC_NAME         28
#define IDS_FILE_PRINT_LIC_FAMILY_NAME  29
#define IDS_LIC_SERV_DISPLAY_NAME       30
#define IDS_LOG_DEFAULT_HEADING         31
#define IDS_LOG_WINDOW_HEADING          32
#define IDS_NEWDEVFOUND_WAIT            33
#define IDS_NEWDEVFOUND_NOAUTO          34
#define IDS_NEWDEVFOUND_NOTADMIN        35
#define IDS_DEVNAME_UNK                 36
#define IDS_SEARCHING                   37
#define IDS_NEWDEVFOUND_CAPTION         38
#define IDS_CONFIRM_DEVINSTALL          39
#define IDS_DEVINSTALL_ERROR            40
#define IDS_SVCDISPLAY_TO_FRIENDLYNAME  41
#define IDS_SVCNAME_TO_FRIENDLYNAME     42
#define IDS_PROGRAM_FILES_DIRECTORY     43
#define IDS_COMMON_FILES_DIRECTORY      44
#define IDS_NODRIVER                    45
#define IDS_NETADAPTER_PROMPT1          46
#define IDS_NETADAPTER_PROMPT2          47
#define IDS_NETADAPTER_CAPTION          48
#define IDD_WELCOME                     49
#define IDS_KBDLAYOUT_MSG               49
#define IDD_LAST_WIZARD_PAGE            50
#define IDS_KBDLAYOUT_MSG2              50
#define IDD_STEPS1                      51
#define IDS_LOCALE_MSG                  51
#define IDD_EULA                        52
#define IDD_NAMEORG                     53
#define IDS_UNKNOWN_PARENS              53
#define IDD_COMPUTERNAME                54
#define IDS_PREPARING_INSTALL           54
#define IDS_SETUP_MODE                  55
#define IDD_USERACCOUNT                 56
#define IDS_REGIONAL_SETTINGS           56
#define IDD_PID                         57
#define IDS_REGIONAL_SETTINGS_SUB       57
#define IDD_PID_CD                      58
#define IDS_PREPARING_INSTALL_SUB       58
#define IDD_PID_OEM                     59
#define IDS_SETUP_MODE_SUB              59
#define IDD_ADMINPASSWORD               60
#define IDS_NAMEORG                     60
#define IDD_REPAIRDISK                  61
#define IDS_NAMEORG_SUB                 61
#define IDD_BILLBOARD1                  62
#define IDS_PID                         62
#define IDD_DONE_SUCCESS                63
#define IDS_PID_SUB                     63
#define IDD_WELCOMEBUTTONS              64
#define IDS_COMPUTERNAME                64
#define IDD_OPTIONS_YESNO               65
#define IDS_COMPUTERNAME_SUB            65
#define IDD_OPTIONS                     66
#define IDD_OPTIONS2                    67
#define IDD_OPTIONS_DETAILS_SETUP       68
#define IDS_ADMINPW                     68
#define IDD_OPTIONS_DETAILS             69
#define IDS_ADMINPW_SUB                 69
#define IDD_CPL_HAVEDISK                70
#define IDS_FPERRATA                    70
#define IDD_SPECIAL_OPTIONS             71
#define IDS_FPERRATA_SUB                71
#define IDD_PREPARING                   72
#define IDS_REPAIRDISK                  72
#define IDD_ACLPROGRESS                 73
#define IDS_REPAIRDISK_SUB              73
#define IDD_VIEWLOG                     74
#define IDS_OPTIONALCOMP                74
#define IDD_CAIRODOMAINNAME             75
#define IDS_OPTIONALCOMP_SUB            75
#define IDD_CAIROUSERACCOUNT            76
#define IDS_ACCESS_UTIL                 76
#define IDD_PENTIUM                     77
#define IDS_WORKSTATION_WELCOME_1       77
#define IDD_SELECTCLASS                 78
#define IDS_WORKSTATION_WELCOME_2       78
#define IDD_HELP                        79
#define IDS_SERVER_WELCOME_1            79
#define IDS_SERVER_WELCOME_2            80
#define IDI_SETUP                       81
#define IDS_OEM                         81
#define IDI_CUSTOM                      82
#define IDS_OEM_SUB                     82
#define IDI_COMPACT                     83
#define IDS_WELCOME_FONT_NAME           83
#define IDI_TYPICAL                     84
#define IDS_WELCOME_FONT_SIZE           84
#define IDI_PORTABLE                    85
#define IDS_EULA                        85
#define IDI_MSN                         86
#define IDS_EULA_SUB                    86
#define IDI_EXCHANGE                    87
#define IDS_COPYFILES                   87
#define IDI_FAX                         88
#define IDS_COPYFILES_SUB2              88
#define IDI_SAFE                        89
#define IDS_COPYFILES_SUB1              89
#define IDI_NEWDEVICEICON               90
#define IDS_PROGRAM_FILES_DIRECTORY_WX86 90
#define IDI_CTAPE                       91
#define IDS_USERNAME                    91
#define IDB_WELCOME                     92
#define IDS_USERNAME_SUB                92
#define IDB_WIZARD1                     93
#define IDS_ASR                         93
#define IDB_REBOOT                      94
#define IDS_ASR_SUB                     94
#define IDB_BACKGROUND                  95
#define IDD_REGIONAL_SETTINGS           96
#define IDD_LOCALE                      97
#define IDD_HARDWARE                    98
#define IDS_MAINTOBS_MSG1               99
#define IDS_SAFEMODENOTALLOWED          100
#define IDI_CDDRIVE                     101
#define IDI_FLPDRIVE                    102
#define IDT_COMPONENTS                  102
#define IDB_ARROW                       102
#define IDT_INSTRUCTIONS                103
#define IDD_OCM_WIZARD_PAGE             103
#define IDB_CHECK                       103
#define IDI_GLOBE                       103
#define IDD_OCM_PROGRESS_PAGE           104
#define IDT_SPACE_NEEDED_NUM            105
#define IDD_OCM_DETAILS                 105
#define IDA_FILECOPY                    105
#define IDB_OEM                         105
#define IDT_SPACE_AVAIL_NUM             106
#define IDB_CDKEY                       106
#define IDD_COPYFILES                   106
#define IDT_TIP                         107
#define IDD_COPYFILES2                  107
#define IDD_WELCOME2                    108
#define IDD_WELCOME3                    109
#define IDD_LAST_WIZARD_PAGE2           110
#define IDB_HEADER                      113
#define IDD_COPYFILES3                  114
#define IDD_LAST_WIZARD_PAGE3           115
#define IDD_COMPUTERNAME2               117
#define IDD_ADMINPASSWORD2              118
#define IDD_SETUPINIT                   119
#define IDD_SETUPINIT_ASR               120
#define IDA_SETUPINIT                   122
#define IDB_BITMAP1                     124
#define IDI_ADMIN                       125
#define IDB_SETUPINIT                   125
#define IDB_INIT_WORKSTATION            125
#define IDI_COMPUTER                    126
#define IDD_COPYFILES4                  126
#define IDI_NAME                        127
#define IDB_INIT_SERVER                 128
#define IDI_SCROLL                      131
#define IDB_BACKGROUND_SERVER           132
#define IDB_BACKGROUND_WORKSTATION      133
#define IDD_PREPARING2                  134
#define IDT_LOCALE                      201
#define IDT_KBD_LAYOUT                  202
#define IDS_OCPAGE_HEADER               203
#define IDS_OCPAGE_SUBHEAD              204
#define IDS_PROGPAGE_HEADER             205
#define IDS_PROGPAGE_SUBHEAD            206
#define IDD_PROP_PAGE_PS2_MOUSE         207
#define IDD_PID_SELECT                  208
#define IDS_SELECT                      209
#define IDS_SELECT_SUB                  210
#define IDT_NAME                        1000
#define IDT_ORGANIZATION                1001
#define IDB_DETAILS                     1001
#define IDT_RICHEDIT1                   1002
#define IDB_BUTTON_1                    1003
#define IDB_BUTTON_2                    1004
#define IDB_BUTTON_3                    1005
#define IDB_BUTTON_4                    1006
#define IDC_LISTBOX                     1006
#define IDB_RADIO_1                     1007
#define IDB_RADIO_2                     1008
#define IDB_RADIO_3                     1009
#define IDC_PROGRESS                    1009
#define IDC_RADIO_1                     1010
#define IDA_EXTERNAL_PROGRAM            1010
#define IDC_RADIO_2                     1011
#define IDT_EDIT1                       1012
#define IDT_EDIT2                       1013
#define IDT_EDIT3                       1014
#define IDT_COMP_TITLE                  1014
#define IDT_EDIT4                       1015
#define IDT_THERM_LABEL                 1015
#define IDT_STATIC                      1016
#define IDT_STATIC_1                    1017
#define IDT_STATIC_2                    1018
#define IDT_STATIC_3                    1019
#define IDT_STATIC_4                    1020
#define IDT_STATIC_5                    1021
#define IDT_STATIC_6                    1022
#define IDT_STATIC4                     1023
#define IDC_GROUP1                      1024
#define IDC_ICON1                       1025
#define IDC_TYPICAL                     1026
#define IDC_PORTABLE                    1027
#define IDC_COMPACT                     1028
#define IDC_CUSTOM                      1029
#define IDT_EDIT_PID1                   1030
#define IDT_EDIT_PID2                   1031
#define IDT_EDIT_PID3                   1032
#define IDT_EDIT_PID4                   1033
#define IDC_LIST1                       1033
#define IDT_EDIT_PID5                   1034
#define IDT_INSTALLED                   1034
#define IDC_MSN                         1035
#define IDC_EXCHANGE                    1036
#define IDC_FAX                         1037
#define IDC_MSN_SPACE                   1038
#define IDC_EXCHANGE_SPACE              1039
#define IDC_FAX_SPACE                   1040
#define IDC_PROGRESS1                   1041
#define IDC_PROGRESS2                   1042
#define IDC_NEWDEV_DESCRIPTION          1043
#define IDC_NEWDEV_INSTRUCTIONS         1044
#define IDC_NEWDEV_DEFAULTDRV           1045
#define IDC_NEWDEV_OEMDRV               1046
#define IDC_NEWDEV_NODRV                1047
#define IDC_NEWDEV_SELECTDRV            1048
#define IDC_NEWDEV_CLASSICON            1049
#define IDC_NDW_TEXT                    1050
#define IDC_NDW_PICKCLASS_HWTYPES       1051
#define IDC_NDW_PICKCLASS_CLASSLIST     1052
#define IDB_CHANGE_LOCALE               1053
#define IDB_CHANGE_KBD_LAYOUT           1054
#define IDB_KBDLAYOUT                   1055
#define IDB_LOCALE                      1056
#define IDC_COPY_BMP                    1058
#define IDC_CONFIGURE_BMP               1059
#define IDC_SAVE_BMP                    1060
#define IDC_REMOVE_BMP                  1061
#define IDC_COPY_TXT                    1062
#define IDC_CONFIGURE_TXT               1063
#define IDC_SAVE_TXT                    1064
#define IDC_REMOVE_TXT                  1065
#define IDC_COPY_BMP2                   1066
#define IDC_EDIT1                       1070
#define IDC_EDIT2                       1071
#define IDC_ANIMATE1                    1074
#define IDC_PREPARETEXT                 1075
#define IDC_SAMPLE_RATE                 1076
#define IDC_SAMPLE_RATE_SPIN            1077
#define IDC_BUFFER                      1078
#define IDC_BUFFER_SPIN                 1079
#define IDC_WHEEL_DETECTION             1080
#define IDC_DEFAULT                     1081
#define IDC_FAST_INIT                   1082
#define IDC_BITMAP                      1083
#define IDD_PREPARING_ASR               1084
#define IDC_UPGRADE_TXT                 1084
#define IDD_LAST_ASR_PAGE               1085
#define IDC_UPGRADE_BMP                 1085
#define IDD_PROP_LEGACY_SERVICE         1086
#define IDC_STATIC_SERVICE_NAME         1087
#define IDC_STATIC_DISPLAY_NAME         1088
#define IDC_EDIT_DISPLAY_NAME           1089
#define IDC_EDIT_SERVICE_NAME           1091
#define IDC_GROUP_CURRENT_STATUS        1092
#define IDC_STATIC_CURRENT_STATUS_STATIC 1093
#define IDC_STATIC_CURRENT_STATUS       1094
#define IDC_BUTTON_START                1095
#define IDC_BUTTON_STOP                 1096
#define IDC_GROUP_STARTUP_TYPE          1097
#define IDC_STATIC_STARTUP_TYPE         1098
#define IDC_COMBO_STARTUP_TYPE          1099
#define IDC_PROP_LEGACY_ICON            1100
#define IDC_PROP_LEGACY_DESC            1101
#define IDS_SERVICE_STARTUP_AUTOMATIC   1102
#define IDS_SERVICE_STARTUP_BOOT        1103
#define IDS_SERVICE_STARTUP_DEMAND      1104
#define IDS_SERVICE_STARTUP_SYSTEM      1105
#define IDS_SERVICE_STARTUP_DISABLED    1106
#define IDC_LEGACY_DETAILS              1109
#define IDD_DRIVERFILES                 1110
#define IDC_DRIVERFILES_FILELIST        1111
#define IDC_DRIVERFILES_PROVIDER        1112
#define IDC_DRIVERFILES_VERSION         1113
#define IDC_DRIVERFILES_COPYRIGHT       1114
#define IDC_DRIVERFILES_ICON            1115
#define IDC_DRIVERFILES_DESC            1116
#define IDC_DRIVERFILES_FILES           1117
#define IDC_DRIVERFILES_TITLE_PROVIDER  1118
#define IDC_DRIVERFILES_TITLE_VERSION   1119
#define IDC_DRIVERFILES_TITLE_COPYRIGHT 1120
#define IDD_PCIHAL_PROPPAGE             1121
#define IDC_PCIHAL_ICON                 1122
#define IDC_PCIHAL_DEVDESC              1123
#define IDC_PCIHAL_ENABLE               1124
#define IDC_PCIHAL_MSSPEC               1125
#define IDC_PCIHAL_REALMODE             1126
#define IDC_PCIHAL_SETDEFAULTS          1127
#define IDC_PCIHAL_RESULTS              1128
#define IDS_PCIHAL_ERROR                1129
#define IDS_PCIHAL_ENABLED              1130
#define IDS_PCIHAL_DISABLED             1131
#define IDS_PCIHAL_NOSTATUS             1132
#define IDS_PCIHAL_TABLE_ERROR          1133
#define IDS_PCIHAL_TABLE_NONE           1134
#define IDS_PCIHAL_TABLE_REGISTRY       1135
#define IDS_PCIHAL_TABLE_MSSPEC         1136
#define IDS_PCIHAL_TABLE_REALMODE       1137
#define IDS_PCIHAL_TABLE_BAD            1138
#define IDS_PCIHAL_TABLE_SUCCESS        1139
#define IDS_PCIHAL_MINIPORT_ERROR       1140
#define IDS_PCIHAL_MINIPORT_NORMAL      1141
#define IDS_PCIHAL_MINIPORT_COMPATIBLE  1142
#define IDS_PCIHAL_MINIPORT_OVERRIDE    1143
#define IDS_PCIHAL_MINIPORT_NONE        1144
#define IDS_PCIHAL_MINIPORT_NOKEY       1145
#define IDS_PCIHAL_MINIPORT_SUCCESS     1146
#define IDS_PCIHAL_MINIPORT_INVALID     1147
#define IDS_FAIL_INPUT_WHQL_REQS        1148
#define IDS_FAIL_INPUT_WHQL_REQS_AVERTED 1149
#define IDS_FAIL_INPUT_WHQL_REQS_NO_ALT 1150
#define IDS_PS2_DETECTION_DISABLED      1151
#define IDS_PS2_DETECTION_LOOK          1152
#define IDS_PS2_DETECTION_ASSUME_PRESENT 1153
#define IDS_SVC_STATUS_STARTED          1154
#define IDS_SVC_STATUS_STOPPED          1155
#define IDS_SVC_STATUS_PAUSED           1156
#define IDS_SVC_STATUS_STARTING         1157
#define IDS_SVC_STATUS_STOPPING         1158
#define IDS_SVC_STATUS_PAUSING          1159
#define IDS_SVC_STATUS_RESUMING         1160
#define IDS_SVC_STATUS_UNKNOWN          1161
#define IDS_SVC_START_ERROR             1162
#define IDS_SVC_STOP_ERROR              1163
#define IDS_BB_COPY_TXT                 1164
#define IDS_BB_CONFIGURE                1165
#define IDS_BB_UPGRADE                  1166
#define IDC_ASR_PNP_TXT                 1167
#define IDS_BB_SAVE                     1168
#define IDC_ASR_EXTERN_TXT              1169
#define IDS_BB_REMOVE                   1170
#define IDC_ASR_PNP_BMP                 1171
#define IDC_ASR_EXTERN_BMP              1172
#define IDS_ASR_ERROR_UNABLE_TO_LAUNCH_APP      1173
#define IDS_ASR_ERROR_RECOVERY_APP_FAILED       1174
#define IDS_ASR_ERROR_UNABLE_TO_OPEN_SCM        1175
#define IDS_ASR_ERROR_UNABLE_TO_START_SERVICE   1176
#define IDS_BB_INSTALLING_DEVICES       1177
#define IDS_TIMEESTIMATE_UNKNOWN        1178
#define IDS_TIMEESTIMATE_MINUTES        1179
#define IDS_TIMEESTIMATE_LESSTHENONEMINUTE 1180
#define IDS_OWNER                       1181
#define IDS_TITLE_INSTALL_P             1182
#define IDS_TITLE_UPGRADE_P             1183
#define IDS_EMPTY_STRING                1184
#define IDD_SERVICE_STOP_DEPENDENCIES   1190
#define IDC_ICON_WARN_SERVICES          1192
#define IDC_LIST_SERVICES               1193
#define IDS_COMPUTERNAME2               1194
#define IDS_COMPUTERNAME2_SUB           1195
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1110
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\resource.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Routines that manipulate resources (strings, messages, etc).

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop



PWSTR
MyLoadString(
    IN UINT StringId
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing string. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    WCHAR Buffer[4096];
    UINT Length;

    Length = LoadString(MyModuleHandle,StringId,Buffer,sizeof(Buffer)/sizeof(WCHAR));
    if(!Length) {
        Buffer[0] = 0;
    }

    return(pSetupDuplicateString(Buffer));
}


PWSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module and
    format it using FormatMessage.

Arguments:

    StringId - supplies string table identifier for the string.

    ArgumentList - supplies list of strings to be substituted in the
        format string.

Return Value:

    Pointer to buffer containing formatted message. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    PWSTR FormatString;
    va_list arglist;
    PWSTR Message;
    PWSTR Return;
    DWORD d;

    //
    // First, load the format string.
    //
    FormatString = MyLoadString(FormatStringId);
    if(!FormatString) {
        return(NULL);
    }

    //
    // Now format the message using the arguments the caller passed.
    //
    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            FormatString,
            0,
            0,
            (PWSTR)&Message,
            0,
            ArgumentList
            );

    MyFree(FormatString);

    if(!d) {
        return(NULL);
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Return = pSetupDuplicateString(Message);
    LocalFree((HLOCAL)Message);
    return(Return);
}


PWSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module and
    format it using FormatMessage.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing formatted message. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PWSTR p;

    va_start(arglist,FormatStringId);
    p = FormatStringMessageV(FormatStringId,&arglist);
    va_end(arglist);

    return(p);
}


PWSTR
RetrieveAndFormatMessageV(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    PWSTR Buffer;
    PWSTR Message;
    WCHAR ModuleName[MAX_PATH];
    WCHAR ErrorNumber[24];
    PWCHAR p;
    PWSTR Args[2];
    DWORD Msg_Type;
    UINT Msg_Id = MessageId;

    if(MessageString > SETUPLOG_USE_MESSAGEID) {
        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                MessageString,
                0,
                0,
                (PWSTR)&Buffer,
                0,
                ArgumentList
                );
    } else {

        if( Msg_Id & 0x0FFF0000 )
            Msg_Type = FORMAT_MESSAGE_FROM_SYSTEM;      // If the facility bits are set this is still Win32
        else{
            Msg_Id &= 0x0000FFFF;                       // Mask out Severity and Facility bits so that we do the right thing
            Msg_Type = ((Msg_Id < MSG_FIRST) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE);
        }


        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | Msg_Type,
                (PVOID)MyModuleHandle,
                MessageId,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (PWSTR)&Buffer,
                0,
                ArgumentList
                );
    }


    if(!d) {
        if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
            return(NULL);
        }

        wsprintf(ErrorNumber,L"%x",MessageId);
        Args[0] = ErrorNumber;

        Args[1] = ModuleName;

        if(GetModuleFileName(MyModuleHandle,ModuleName,MAX_PATH)) {
            if(p = wcsrchr(ModuleName,L'\\')) {
                Args[1] = p+1;
            }
        } else {
            ModuleName[0] = 0;
        }

        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                ERROR_MR_MID_NOT_FOUND,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (PWSTR)&Buffer,
                0,
                (va_list *)Args
                );

        if(!d) {
            //
            // Give up.
            //
            return(NULL);
        }
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = pSetupDuplicateString(Buffer);

    LocalFree((HLOCAL)Buffer);

    return(Message);
}


PWSTR
RetrieveAndFormatMessage(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    ...
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ... - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PWSTR p;

    va_start(arglist,MessageId);
    p = RetrieveAndFormatMessageV(MessageString,MessageId,&arglist);
    va_end(arglist);

    return(p);
}


int
MessageBoxFromMessageExV (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    IN va_list ArgumentList
    )

/*++

Routine Description:

    Creates a dialog box containing a specified message

Arguments:

    Severity - Severity and flags for the error message.  Currently only the
        flags are significant.

    Onwer - handle to parent window

    MessageId - ID of message to display

    Caption - string to use as caption for dialog box

    CaptionStringId - ID of string to use as caption for dialog box (but not
    used if Caption is specified)

    Style - flags to specify the type of dialog box

    ArgumentList - parameters to MessageId

Return Value:

    return status from MessageBox

--*/

{
    static SETUPLOG_CONTEXT Context = {0};
    PCWSTR Message;
    PCWSTR Title;
    int i;
    BOOL b;


    if(!Context.AllocMem) {
        Context.AllocMem = MyMalloc;
        Context.FreeMem = MyFree;
        Context.Format = RetrieveAndFormatMessageV;
    }
    Message = SetuplogFormatMessageWithContextV(
        &Context,
        Severity,
        (PTSTR)MessageString,
        MessageId,
        &ArgumentList);

    b = FALSE;
    i = IDOK;

    if(Message) {

        if(Title = Caption ? Caption : MyLoadString(CaptionStringId)) {

            b = TRUE;
            i = MessageBox(Owner,Message,Title,Style);

            if(Title != Caption) {
                MyFree(Title);
            }
        }
        MyFree(Message);
    }

    if(!b) {
        pSetupOutOfMemory(Owner);
    }
    return(i);
}

int
MessageBoxFromMessageEx (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    )

/*

    Wrapper for MessageBoxFromMessageExV

*/

{
    va_list ArgumentList;
    int Status;

    va_start(ArgumentList,Style);
    Status = MessageBoxFromMessageExV (
        Owner, Severity, MessageString, MessageId, Caption,
        CaptionStringId, Style, ArgumentList);
    va_end(ArgumentList);
    return Status;
}

int
MessageBoxFromMessage(
    IN HWND   Owner,            OPTIONAL
    IN UINT   MessageId,
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    )
{
    PCWSTR Message;
    PCWSTR Title;
    va_list ArgumentList;
    int i;
    BOOL b;

    va_start(ArgumentList,Style);
    Message = RetrieveAndFormatMessageV(NULL,MessageId,&ArgumentList);
    va_end(ArgumentList);

    b = FALSE;
    i = IDOK;

    if(Message) {

        if(Title = Caption ? Caption : MyLoadString(CaptionStringId)) {

            b = TRUE;
            i = MessageBox(Owner,Message,Title,Style);

            if(Title != Caption) {
                MyFree(Title);
            }
        }
        MyFree(Message);
    }

    if(!b) {
        pSetupOutOfMemory(Owner);
    }
    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\setupasr.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    setupasr.c

Abstract:

    Services in this module implement the Automatic System Recovery (ASR)
    routines of guimode setup.

Revision History:
    Initial Code                Michael Peterson (v-michpe)     20.Jan.1998
    Code cleanup and changes    Guhan Suriyanarayanan (guhans)  21.Sep.1999

--*/

#include "setupp.h"
#pragma hdrstop
#include <setupapi.h>
#include <mountmgr.h>
#include <accctrl.h>
#include <aclapi.h>

#define THIS_MODULE 'S'
#include "asrpriv.h"


///////////////////////////////////////////////////////////////////////////////
// Private Type and constant declarations
///////////////////////////////////////////////////////////////////////////////

const PCWSTR AsrSifPath             = L"%systemroot%\\repair\\asr.sif\0";
const PCWSTR AsrCommandsSectionName = L"COMMANDS";
const PCWSTR AsrCommandSuffix       = L"/sifpath=%systemroot%\\repair\\asr.sif";
const PCWSTR AsrTempDir             = L"%systemdrive%\\TEMP";

const PCWSTR AsrLogFileName         = L"\\asr.log";
const PCWSTR AsrErrorFileName       = L"\\asr.err";

const PCWSTR Asr_ControlAsrRegKey        = L"SYSTEM\\CurrentControlSet\\Control\\ASR";
const PCWSTR Asr_LastInstanceRegValue    = L"Instance";

//
// The following are to update system and boot partition devices
// in setup.log
//
const PCWSTR Asr_SystemDeviceEnvName    = L"%ASR_C_SYSTEM_PARTITION_DEVICE%";
const PCWSTR Asr_SystemDeviceWin32Path  = L"\\\\?\\GLOBALROOT%ASR_C_SYSTEM_PARTITION_DEVICE%";
const PCWSTR Asr_WinntDeviceEnvName     = L"%ASR_C_WINNT_PARTITION_DEVICE%";

const PCWSTR Asr_SetupLogFilePath       = L"%systemroot%\\repair\\setup.log";
const PCWSTR Asr_AsrLogFilePath         = L"%systemroot%\\repair\\asr.log";
const PCWSTR Asr_AsrErrorFilePath       = L"%systemroot%\\repair\\asr.err";
const PCWSTR Asr_OldAsrErrorFilePath    = L"%systemroot%\\repair\\asr.err.old";

const PCWSTR Asr_FatalErrorCommand      = L"notepad.exe %systemroot%\\repair\\asr.err";


///////////////////////////////////////////////////////////////////////////////
// Data global to this module
///////////////////////////////////////////////////////////////////////////////
BOOL Gbl_IsAsrEnabled = FALSE;
PWSTR Gbl_AsrErrorFilePath = NULL;
PWSTR Gbl_AsrLogFilePath = NULL;
HANDLE Gbl_AsrLogFileHandle = NULL;
HANDLE Gbl_AsrSystemVolumeHandle = NULL;
WCHAR g_szErrorMessage[4196];


///////////////////////////////////////////////////////////////////////////////
// Macros
///////////////////////////////////////////////////////////////////////////////

//
// ASR Memory allocation and free wrappers
//

//
// _AsrAlloc
// Macro description:
//  ASSERTS first if ptr is non-NULL.  The expectation is that
//  all ptrs must be initialised to NULL before they are allocated.
//  That way, we can catch instances where we try to re-allocate
//  memory without freeing first.
//
// IsNullFatal:  flag to indicate if mem allocation failures are fatal
//
#define _AsrAlloc(ptr,sz,IsNullFatal)   {           \
                                                    \
    if (ptr != NULL) {                              \
        AsrpPrintDbgMsg(_asrinfo, "Pointer being allocated not NULL.\r\n"); \
        MYASSERT(0);                                  \
    }                                               \
                                                    \
    ptr = MyMalloc(sz);                             \
                                                    \
    if (ptr) {                                      \
        memset(ptr, 0, sz);                         \
    }                                               \
                                                    \
    if (!ptr) {                                     \
        if ((BOOLEAN) IsNullFatal) {                \
            AsrpPrintDbgMsg(_asrerror, "Setup was unable to allocate memory.\r\n"); \
            FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0); \
        }                                           \
        else {                                      \
            AsrpPrintDbgMsg(_asrwarn, "Warning.  Setup was unable to allocate memory.\r\n"); \
        }                                           \
    }                                               \
}


//
// _AsrFree
// Macro description:
//  Frees ptr and resets it to NULL.
//  Asserts if ptr was already NULL
//
#define _AsrFree(ptr)    {  \
                            \
    if (NULL != ptr) {      \
        MyFree(ptr);        \
        ptr = NULL;         \
    }                       \
    else {                  \
        AsrpPrintDbgMsg(_asrlog, "Attempt to free null Pointer.\r\n");   \
        MYASSERT(0);          \
    }                       \
}


#define _AsrFreeIfNotNull(ptr) {    \
    if (NULL != ptr) {      \
        MyFree(ptr);        \
        ptr = NULL;         \
    }                       \
}

//
// One ASR_RECOVERY_APP_NODE struct is created for each entry
// in the [COMMANDS] section of asr.sif.
//
typedef struct _ASR_RECOVERY_APP_NODE {
    struct _ASR_RECOVERY_APP_NODE *Next;

    //
    // Expect this to always be 1
    //
    LONG SystemKey;

    //
    // The sequence number according to which the apps are run.  If
    // two apps have the same sequence number, the app that appears
    // first in the sif file is run.
    //
    LONG SequenceNumber;

    //
    // The "actionOnCompletion" field for the app.  If CriticalApp is
    // non-zero, and the app returns an non-zero exit-code, we shall
    // consider it a fatal failure and quit out of ASR.
    //
    LONG CriticalApp;

    //
    // The app to be launched
    //
    PWSTR RecoveryAppCommand;

    //
    // The paramaters for the app.  This is just concatenated to the
    // string above.  May be NULL.
    //
    PWSTR RecoveryAppParams;

} ASR_RECOVERY_APP_NODE, *PASR_RECOVERY_APP_NODE;


//
// This contains our list of entries in the COMMANDS section,
// sorted in order of sequence numbers.
//
typedef struct _ASR_RECOVERY_APP_LIST {
    PASR_RECOVERY_APP_NODE  First;      // Head
    PASR_RECOVERY_APP_NODE  Last;       // Tail
    LONG AppCount;                      // NumEntries
} ASR_RECOVERY_APP_LIST, *PASR_RECOVERY_APP_LIST;



//
// We call this to change the boot.ini timeout value to 30 seconds
//
extern BOOL
ChangeBootTimeout(IN UINT Timeout);

//
// From asr.c
//
extern BOOL
AsrpRestoreNonCriticalDisksW(
    IN PCWSTR   lpSifPath,
    IN BOOL     bAllOrNothing
    );


extern BOOL
AsrpRestoreTimeZoneInformation(
    IN PCWSTR   lpSifPath
    );

//
// Indices for fields in the [COMMANDS] section.
//
typedef enum _SIF_COMMANDS_FIELD_INDEX {
    ASR_SIF_COMMANDS_KEY = 0,
    ASR_SIF_SYSTEM_KEY,             // Expected to always be "1"
    ASR_SIF_SEQUENCE_NUMBER,
    ASR_SIF_ACTION_ON_COMPLETION,
    ASR_SIF_COMMAND_STRING,
    ASR_SIF_COMMAND_PARAMETERS,     // May be NULL
    SIF_SIF_NUMFIELDS               // Must always be last
} SIF_COMMANDS_FIELD_INDEX;

#define _Asr_CHECK_BOOLEAN(b,msg) \
    if((b) == FALSE) { \
        AsrpFatalErrorExit(MSG_FATAL_ERROR, __LINE__, (msg)); \
    }


///////////////////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////////////////////



//
// Logs the message to the asr error file.  Note that
// AsrpInitialiseErrorFile must have been called once before
// this routine is used.
//
VOID
AsrpLogErrorMessage(
    IN PCWSTR buffer
    )
{
    HANDLE hFile = NULL;
    DWORD bytesWritten = 0;

    if (Gbl_AsrErrorFilePath) {
        //
        // Open the error log
        //
        hFile = CreateFileW(
            Gbl_AsrErrorFilePath,           // lpFileName
            GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,                           // lpSecurityAttributes
            OPEN_ALWAYS,                  // dwCreationFlags
            FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes
            NULL                            // hTemplateFile
            );
        if ((!hFile) || (INVALID_HANDLE_VALUE == hFile)) {
            return;
        }

        //
        // Move to the end of file
        //
        SetFilePointer(hFile, 0L, NULL, FILE_END);

        //
        // Add our error string
        //
        WriteFile(hFile,
            buffer,
            (wcslen(buffer) * sizeof(WCHAR)),
            &bytesWritten,
            NULL
            );

        //
        // And we're done
        //
        CloseHandle(hFile);
    }
}


//
// Logs the message to the asr log file.  Note that
// AsrpInitialiseLogFile must have been called once before
// this routine is used.
//
VOID
AsrpLogMessage(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN CONST PCSTR Message
    )
{
    SYSTEMTIME currentTime;
    DWORD bytesWritten = 0;
    char buffer[4196];
    GetSystemTime(&currentTime);

    sprintf(buffer,
        "[%04hu/%02hu/%02hu %02hu:%02hu:%02hu.%03hu] %c%lu %s%s",
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        currentTime.wMilliseconds,
        Module,
        Line,
        ((DPFLTR_ERROR_LEVEL == MesgLevel) ? "(Error:ASR) " :  (DPFLTR_WARNING_LEVEL == MesgLevel ? "(Warning:ASR) " : "")),
        Message
        );

    if (Gbl_AsrLogFileHandle) {
        WriteFile(Gbl_AsrLogFileHandle,
            buffer,
            (strlen(buffer) * sizeof(char)),
            &bytesWritten,
            NULL
            );
    }

}


VOID
AsrpPrintDbgMsg(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN PCSTR FormatString,
    ...)
/*++
Description:
    This prints a debug message AND makes the appropriate entries in
    the log and error files.

Arguments:
    Line            pass in __LINE__
    MesgLevel       DPFLTR_ levels
    FormatString    Formatted Message String to be printed.

Returns:

--*/
{
    char str[4096];     // the message better fit in this
    va_list arglist;

    DbgPrintEx(DPFLTR_SETUP_ID, MesgLevel, "ASR %c%lu ", Module, Line);

    va_start(arglist, FormatString);
    wvsprintfA(str, FormatString, arglist);
    va_end(arglist);

    DbgPrintEx(DPFLTR_SETUP_ID, MesgLevel, str);

    if ((DPFLTR_ERROR_LEVEL == MesgLevel) ||
        (DPFLTR_WARNING_LEVEL == MesgLevel) ||
        (DPFLTR_TRACE_LEVEL == MesgLevel)
        ) {
        AsrpLogMessage(Module, Line, MesgLevel, str);
    }
}


//
// This will terminate Setup and cause a reboot.  This is called
// on Out of Memory errors
//
VOID
AsrpFatalErrorExit(
    IN LONG MsgValue,
    IN LONG LineNumber,
    IN PWSTR MessageString
   )
{
    AsrpPrintDbgMsg(THIS_MODULE, LineNumber, DPFLTR_ERROR_LEVEL, "Fatal Error: %ws (%lu)",
        (MessageString ? MessageString : L"(No error string)"), GetLastError()
        );

    FatalError(MsgValue, MessageString, 0, 0);
}


//
// This just adds the new node to the end of the list.
// Note that this does NOT sort the list by sequenceNumber:
// we'll do that later on
//
VOID
AsrpAppendNodeToList(
    IN PASR_RECOVERY_APP_LIST pList,
    IN PASR_RECOVERY_APP_NODE pNode
   )
{
    //
    // Insert at end of list.
    //
    pNode->Next = NULL;

    if (pList->AppCount == 0) {
        pList->First = pNode;
    } else {
        pList->Last->Next = pNode;
    }

    pList->Last  = pNode;
    pList->AppCount += 1;
}


//
// Pops off the first node in the list.  The list is sorted
// in order of increasing SequenceNumber's at this point.
//
PASR_RECOVERY_APP_NODE
AsrpRemoveFirstNodeFromList(
    IN PASR_RECOVERY_APP_LIST pList
   )
{
    PASR_RECOVERY_APP_NODE pNode;

    if(pList->AppCount == 0) {
        return NULL;
    }

    pNode = pList->First;
    pList->First = pNode->Next;
    pList->AppCount -= 1;

    MYASSERT(pList->AppCount >= 0);

    return  pNode;
}


PWSTR   // must be freed by caller
AsrpExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    )
{
    PWSTR expandedString = NULL;
    UINT cchSize = MAX_PATH + 1,    // start with a reasonable default
        cchRequiredSize = 0;
    BOOL result = FALSE;

    _AsrAlloc(expandedString, (cchSize * sizeof(WCHAR)), TRUE);

    cchRequiredSize = ExpandEnvironmentStringsW(OriginalString,
        expandedString,
        cchSize
        );

    if (cchRequiredSize > cchSize) {
        //
        // Buffer wasn't big enough; free and re-allocate as needed
        //
        _AsrFree(expandedString);
        cchSize = cchRequiredSize + 1;

        _AsrAlloc(expandedString, (cchSize * sizeof(WCHAR)), TRUE);
        cchRequiredSize = ExpandEnvironmentStringsW(OriginalString,
            expandedString,
            cchSize
            );
    }

    if ((0 == cchRequiredSize) || (cchRequiredSize > cchSize)) {
        //
        // Either the function failed, or the buffer wasn't big enough
        // even on the second try
        //
        _AsrFree(expandedString);   // sets it to NULL
    }

    return expandedString;
}

//
// Builds the invocation string, as the name suggests.  It expands out
// the environment variables that apps are allowed to use in the
// sif file, and adds in /sifpath=<path to the sif file> at the end
// of the command.  So for an entry in the COMMANDS section of
// the form:
// 4=1,3500,0,"%TEMP%\app.exe","/param1 /param2"
//
// the invocation string would be of the form:
// c:\windows\temp\app.exe /param1 /param2 /sifpath=c:\windows\repair\asr.sif
//
//
PWSTR
AsrpBuildInvocationString(
    IN PASR_RECOVERY_APP_NODE pNode     // must not be NULL
   )
{
    PWSTR app   = pNode->RecoveryAppCommand,
        args    = pNode->RecoveryAppParams,
        cmd     = NULL,
        fullcmd = NULL;

    DWORD size  = 0;

    MYASSERT(app);

    //
    // Build an command line that looks like...
    //
    //      "%TEMP%\ntbackup recover /1 /sifpath=%systemroot%\repair\asr.sif"
    //
    // The /sifpath parameter is added to all apps being launched
    //

    //
    //  Allocate memory for the cmd line
    //
    size = sizeof(WCHAR) *
        (
        wcslen(app) +                       // app name     "%TEMP%\ntbackup"
        (args ? wcslen(args) : 0) +         // arguments    "recover /1"
        wcslen(AsrCommandSuffix) +          // suffix       "/sifpath=%systemroot%\repair\asr.sif"
        4                                   // spaces and null
        );
    _AsrAlloc(cmd, size, TRUE); // won't return if alloc fails

    //
    // Build the string
    //
    swprintf(cmd,
        L"%ws %ws %ws",
        app,
        (args? args: L""),
        AsrCommandSuffix
       );

    //
    // Expand the %% stuff, to build the full path
    //
    fullcmd = AsrpExpandEnvStrings(cmd);

    _AsrFree(cmd);
    return fullcmd;
}


BOOL
AsrpRetryIsServiceRunning(
    IN PWSTR ServiceName,
    IN UINT MaxRetries
    )
{
    SERVICE_STATUS status;
    SC_HANDLE svcHandle = NULL, // handle to the service
        scmHandle = NULL;       // handle to the service control manager
    UINT count = 0;
    BOOL errorsEncountered = FALSE;
    PWSTR errString = NULL;

    scmHandle = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (!scmHandle) {
        //
        // OpenSCManager() call failed - we are broke.
        //
        AsrpPrintDbgMsg(_asrerror,
            "Setup was unable to open the service control manager.  The error code returned was 0x%x.\r\n",
            GetLastError()
            );

        errString = MyLoadString(IDS_ASR_ERROR_UNABLE_TO_OPEN_SCM);

        if (errString) {
            swprintf(g_szErrorMessage, errString, GetLastError());
            AsrpLogErrorMessage(g_szErrorMessage);
            MyFree(errString);
            errString = NULL;
        }
        else {
            FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
        }


        errorsEncountered = TRUE;
        goto EXIT;
    }

    svcHandle = OpenServiceW(scmHandle, ServiceName, SERVICE_QUERY_STATUS);
    if (!svcHandle) {
        //
        // OpenService() call failed - we are broke.
        //
        AsrpPrintDbgMsg(_asrerror,
            "Setup was unable to start the service \"%ws\".  The error code returned was 0x%x.\r\n",
            ServiceName,
            GetLastError()
            );

        errString = MyLoadString(IDS_ASR_ERROR_UNABLE_TO_START_SERVICE);

        if (errString) {
            swprintf(g_szErrorMessage, errString, ServiceName, GetLastError());
            AsrpLogErrorMessage(g_szErrorMessage);
            MyFree(errString);
            errString = NULL;
        }
        else {
            FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
        }


        errorsEncountered = TRUE;
        goto EXIT;
    }

    //
    // Got the service opened for query. See if it's running, and
    // if not, go thru the retry loop.
    //
    while (count < MaxRetries) {

        if (!QueryServiceStatus(svcHandle, &status)) {
            //
            // Couldn't query the status of the service
            //
            AsrpPrintDbgMsg(_asrerror,
                "Setup was unable to query the status of service \"%ws\".  The error code returned was 0x%x\r\n",
                ServiceName,
                GetLastError()
                );

            errString = MyLoadString(IDS_ASR_ERROR_UNABLE_TO_START_SERVICE);

            if (errString) {
                swprintf(g_szErrorMessage, errString, ServiceName, GetLastError());
                AsrpLogErrorMessage(g_szErrorMessage);
                MyFree(errString);
                errString = NULL;
            }
            else {
                FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
            }

            errorsEncountered = TRUE;
            goto EXIT;
        }

        if (status.dwCurrentState == SERVICE_RUNNING) {
            //
            // Service is running - we can proceed.
            //
            break;
        }

        ++count;

        AsrpPrintDbgMsg(_asrinfo,
            "Attempting to start service [%ws]: status = [%d], retry [%d]\r\n",
            ServiceName,
            status.dwCurrentState,
            count
           );

        Sleep(2000);
    }

EXIT:
    if ((svcHandle) && (INVALID_HANDLE_VALUE != svcHandle)) {
        CloseServiceHandle(svcHandle);
        svcHandle = NULL;
    }

    if ((scmHandle) && (INVALID_HANDLE_VALUE != svcHandle)) {
        CloseServiceHandle(scmHandle);
        scmHandle = NULL;
    }

    if ((errorsEncountered) || (count >= MaxRetries)) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}


//
// Before launching apps, we need RSM (specifically, the backup app
// might need RSM to access its backup media)
//
VOID
AsrpStartNtmsService(VOID)
{
    BOOL result = TRUE;
    DWORD exitCode = ERROR_SUCCESS;
    PWSTR registerNtmsCommand = NULL;

    AsrpPrintDbgMsg(_asrinfo, "Entered InitNtmsService()\r\n");

    //
    // RSM isn't setup to run during GUI mode setup, but the back-up app is
    // likely going to need access to tape-drives and other RSM devices.
    // So we regsvr32 the appropriate dll's and start the service
    //
    // Register the ntmssvc.dll using:
    //   regsvr32 /s %Systemroot%\system32\ntmssvc.dll
    //
    result = FALSE;
    registerNtmsCommand = AsrpExpandEnvStrings(L"regsvr32 /s %systemroot%\\system32\\rsmps.dll");
    if (registerNtmsCommand) {
        result = InvokeExternalApplication(NULL, registerNtmsCommand, &exitCode);
    }
    _Asr_CHECK_BOOLEAN(result, L"regsvr32 /s %systemroot%\\rsmps.dll failed\r\n");

    AsrpPrintDbgMsg(_asrlog, "Executed [%ws]\r\n", registerNtmsCommand);
    _AsrFree(registerNtmsCommand);

    //
    // Register the ntmsapi.dll using:
    //  regsvr32 /s %SystemRoot%\system32\ntmsapi.dll
    //
    result = FALSE;
    registerNtmsCommand = AsrpExpandEnvStrings(L"regsvr32 /s %systemroot%\\system32\\ntmssvc.dll");

    if (registerNtmsCommand) {
        result = InvokeExternalApplication(NULL, registerNtmsCommand, &exitCode);
    }
    _Asr_CHECK_BOOLEAN(result, L"regsvr32 /s %systemroot%\\ntmssvc.dll failed\r\n");

    AsrpPrintDbgMsg(_asrlog, "Executed [%ws]\r\n", registerNtmsCommand);
    _AsrFree(registerNtmsCommand);

    result = FALSE;
    registerNtmsCommand = AsrpExpandEnvStrings(L"%systemroot%\\system32\\rsmsink.exe /regserver");

    if (registerNtmsCommand) {
      result = InvokeExternalApplication(NULL, registerNtmsCommand, &exitCode);
    }
    _Asr_CHECK_BOOLEAN(result, L"%systemroot%\\system32\\rsmsink.exe /regserver failed\r\n");

    AsrpPrintDbgMsg(_asrlog, "Executed [%ws]\r\n", registerNtmsCommand);
    _AsrFree(registerNtmsCommand);

    //
    // Now, start the ntms service.
    //
    result = SetupStartService(L"ntmssvc", FALSE);
    _Asr_CHECK_BOOLEAN(result, L"Could not start RSM service (ntmssvc).\r\n");

    //
    // Check for ntms running, give a few retries.
    //
    result = AsrpRetryIsServiceRunning(L"ntmssvc", 30);
    _Asr_CHECK_BOOLEAN(result, L"Failed to start RSM service after 30 retries.\r\n");

    AsrpPrintDbgMsg(_asrinfo, "RSM service (ntmssvc) started.\r\n");
}


PWSTR
AsrpReadField(
    PINFCONTEXT pInfContext,
    DWORD       FieldIndex,
    BOOL        NullOkay
   )
{
    PWSTR   data        = NULL;
    UINT    reqdSize    = 0;
    BOOL    result      = FALSE;

    //
    //  Allocate memory and read the data
    //
    _AsrAlloc(data, (sizeof(WCHAR) * (MAX_PATH + 1)), TRUE);

    result = SetupGetStringFieldW(
        pInfContext,
        FieldIndex,
        data,
        MAX_PATH + 1,
        &reqdSize
       );

    if (!result) {
        DWORD status = GetLastError();
        //
        // If our buffer was too small, allocate a larger buffer
        // and try again
        //
        if (ERROR_INSUFFICIENT_BUFFER == status) {
            status = ERROR_SUCCESS;

            _AsrFree(data);
            _AsrAlloc(data, (sizeof(WCHAR) * reqdSize), TRUE);

            result = SetupGetStringFieldW(
                pInfContext,
                FieldIndex,
                data,
                reqdSize,
                NULL    // don't need required size any more
               );
        }
    }

    if (!result) {
        _AsrFree(data);
        _Asr_CHECK_BOOLEAN(NullOkay, L"Could not read entry from commands section");
        // Never returns if NullOkay is FALSE.
        // Memory leaks here then, since we don't free some structs.  But
        // it's a fatal error, so the system must be rebooted anyway
        //
    }

    return data;
}

//
// This adds in the "Instance" value under the ASR key.
// Third party applications (or Windows components like DTC) can use
// this to determine if a new ASR has been run since the last time we
// booted, and can take any actions they need to.  For instance, the
// DTC log file needs to be recreated after an ASR, since it is not
// backed-up or restored by the backup app, and Dtc refuses to start
// if it doesn't find a log file when it expects one.
//
VOID
AsrpAddRegistryEntry()
{

    LONG result = 0;
    HKEY regKey = NULL;

    WCHAR   szLastInstanceData[40];
    DWORD   cbLastInstanceData = 0;

    SYSTEMTIME currentTime;

    GUID asrInstanceGuid;

    PWSTR lpGuidString = NULL;

    RPC_STATUS rpcStatus = RPC_S_OK;

    //
    // We try to set the key to a newly generated GUID, to make sure it is
    // unique (and different from the previous value stored there).  If, for
    // some reason, we aren't able to generate a GUID, we'll just store the
    // current date and time as a string--that should be unique, too.
    //
    rpcStatus = UuidCreate(
        &asrInstanceGuid
        );

    if (RPC_S_OK == rpcStatus) {
        //
        // Convert the GUID to a printable string
        //
        rpcStatus = UuidToStringW(
            &asrInstanceGuid,
            &lpGuidString
            );

        if (RPC_S_OK == rpcStatus) {
            wsprintf(szLastInstanceData,
                L"%ws",
                lpGuidString
                );
            cbLastInstanceData = wcslen(szLastInstanceData)*sizeof(WCHAR);
        }

        if (lpGuidString) {
            RpcStringFreeW(&lpGuidString);
        }
    }


    if (RPC_S_OK != rpcStatus)  {
        //
        // We couldn't get a GUID.  Let's store the time-stamp ...
        //
        GetSystemTime(&currentTime);
        wsprintf(szLastInstanceData,
            L"%04hu%02hu%02hu%02hu%02hu%02hu%03hu",
            currentTime.wYear,
            currentTime.wMonth,
            currentTime.wDay,
            currentTime.wHour,
            currentTime.wMinute,
            currentTime.wSecond,
            currentTime.wMilliseconds
            );
        cbLastInstanceData = wcslen(szLastInstanceData)*sizeof(WCHAR);
    }

    result = RegCreateKeyExW(
        HKEY_LOCAL_MACHINE, // hKey
        Asr_ControlAsrRegKey,       // lpSubKey
        0,                  // reserved
        NULL,               // lpClass
        REG_OPTION_NON_VOLATILE,    // dwOptions
        MAXIMUM_ALLOWED,     // samDesired
        NULL,               // lpSecurityAttributes
        &regKey,            // phkResult
        NULL                // lpdwDisposition
        );
    if ((ERROR_SUCCESS != result) || (!regKey)) {
        AsrpPrintDbgMsg(_asrwarn,
            "Could not create the Control\\ASR registry entry (0x%x).\r\n",
            result
            );
        return;
    }

    result = RegSetValueExW(
        regKey,             // hKey
        Asr_LastInstanceRegValue,       // lpValueName
        0L,                 // reserved
        REG_SZ,             // dwType
        (LPBYTE)szLastInstanceData,     // lpData
        cbLastInstanceData              // cbData
        );

    RegCloseKey(regKey);

    if (ERROR_SUCCESS != result) {
        AsrpPrintDbgMsg(_asrwarn,
            "Could not set the ASR instance-ID in the registry (0x%x).\r\n",
            result
            );
        return;
    }

    AsrpPrintDbgMsg(_asrlog,
        "Set the ASR instance-ID at [%ws\\%ws] value to [%ws]\r\n",
        Asr_ControlAsrRegKey,
        Asr_LastInstanceRegValue,
        szLastInstanceData
        );

}

VOID
AsrpSetEnvironmentVariables()
{

    PWSTR TempPath = AsrpExpandEnvStrings(AsrTempDir);

    if (!CreateDirectoryW(TempPath, NULL)) {
        AsrpPrintDbgMsg(_asrwarn,
            "Unable to create TEMP directory [%ws] (%lu)\r\n",
            TempPath, GetLastError()
            );
    }

    AsrpPrintDbgMsg(_asrlog,
        "Setting environment variables TEMP and TMP to [%ws]\r\n",
        TempPath
        );

    if (!SetEnvironmentVariableW(L"TEMP", TempPath)) {
        AsrpPrintDbgMsg(_asrwarn,
            "Unable to set environment variable TEMP to [%ws] (%lu)\r\n",
            TempPath, GetLastError()
            );
    }


    if (!SetEnvironmentVariableW(L"TMP", TempPath)) {
        AsrpPrintDbgMsg(_asrwarn,
            "Unable to set environment variable TEMP to [%ws] (%lu)\r\n",
            TempPath, GetLastError()
            );
    }

    _AsrFree(TempPath);

    return;

}


VOID
AsrpInitExecutionEnv(
    OUT PASR_RECOVERY_APP_LIST List
   )
{
    PWSTR   stateFileName   = NULL;
    HINF    sifHandle       = NULL;

    LONG    lineCount       = 0,
            line            = 0;

    BOOL    result          = FALSE;

    INFCONTEXT infContext;

    //
    // Start the RSM service
    //
    AsrpStartNtmsService();

    //
    // Open the asr.sif file and build the list
    // of commands to be launched.
    //
    stateFileName = AsrpExpandEnvStrings(AsrSifPath);
    if (!stateFileName) {
        AsrpPrintDbgMsg(_asrerror, "Setup was unable to locate the ASR state file asr.sif on this machine.\r\n");
        FatalError(MSG_LOG_SYSINFBAD, L"asr.sif",0,0);
    }

    sifHandle = SetupOpenInfFileW(
        stateFileName,
        NULL,               // Inf Class
        INF_STYLE_WIN4,
        NULL                // Error-line
       );

    if ((!sifHandle) || (INVALID_HANDLE_VALUE == sifHandle)) {
        AsrpPrintDbgMsg(_asrerror,
            "Setup was unable to process the ASR state file %ws (0x%x).  This could indicate that the file is corrupt, or has been modified since the last ASR backup.\r\n",
            stateFileName,
            GetLastError());
        _AsrFree(stateFileName);

        FatalError(MSG_LOG_SYSINFBAD, L"asr.sif",0,0);
    }
    _AsrFree(stateFileName);

    //
    // Read the COMMANDS section, and add each command to our list
    //
    lineCount = SetupGetLineCountW(sifHandle, AsrCommandsSectionName);
    for (line = 0; line < lineCount; line++) {

        //
        // Create a new node
        //
        PASR_RECOVERY_APP_NODE pNode = NULL;
        _AsrAlloc(pNode, (sizeof(ASR_RECOVERY_APP_NODE)), TRUE);

        //
        //  Get the inf context for the line in asr.sif.  This will be used
        //  to read the fields on that line
        //
        result = SetupGetLineByIndexW(
            sifHandle,
            AsrCommandsSectionName,
            line,
            &infContext
           );
        _Asr_CHECK_BOOLEAN(result, L"SetupGetLinebyIndex failed");

        //
        // Read in the int fields
        //
        result = SetupGetIntField(
            &infContext,
            ASR_SIF_SYSTEM_KEY,
            &(pNode->SystemKey)
           );
        _Asr_CHECK_BOOLEAN(result, L"could not get system key in commands section");

        result = SetupGetIntField(
            &infContext,
            ASR_SIF_SEQUENCE_NUMBER,
            &(pNode->SequenceNumber)
           );
        _Asr_CHECK_BOOLEAN(result, L"could not get sequence number in commands section");

        result = SetupGetIntField(
            &infContext,
            ASR_SIF_ACTION_ON_COMPLETION,
            &(pNode->CriticalApp)
           );
        _Asr_CHECK_BOOLEAN(result, L"could not get criticalApp in commands section");

        //
        // Read in the string fields
        //
        pNode->RecoveryAppCommand = AsrpReadField(
            &infContext,
            ASR_SIF_COMMAND_STRING,
            FALSE                   // Null not okay
           );

        pNode->RecoveryAppParams = AsrpReadField(
            &infContext,
            ASR_SIF_COMMAND_PARAMETERS,
            TRUE                   // Null okay
           );

        //
        // Add this node to our list, and move on to next
        //
        AsrpAppendNodeToList(List, pNode);
    }

    SetupCloseInfFile(sifHandle);
}


//
// Bubble sort ...
//
VOID
AsrpSortAppListBySequenceNumber(PASR_RECOVERY_APP_LIST pList)
{
    PASR_RECOVERY_APP_NODE
        pCurr       = NULL,
        pNext       = NULL,
        *ppPrev     = NULL;

    BOOLEAN done    = FALSE;

    if ((!pList) || (!pList->First)) {
        MYASSERT(0 && L"Recovery App List pList is NULL");
        return;
    }

    //
    // Start the outer loop. Each iteration of the outer loop includes a
    // full pass down the list, and runs until the inner loop is satisfied
    // that no more passes are needed.
    //
    while (!done) {
        //
        // Start at the beginning of the list for each inner (node) loop.
        //
        // We will initialize a pointer *to the pointer* which points to
        // the current node - this pointer might be the address of the "list
        // first" pointer (as it always will be at the start of an inner loop),
        // or as the inner loop progresses, it might be the address of the
        // "next" pointer in the previous node. In either case, the pointer
        // to which ppPrev points will be changed in the event of a node swap.
        //
        pCurr  =   pList->First;
        ppPrev = &(pList->First);
        done = TR