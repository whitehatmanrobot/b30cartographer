_WARNING|FA_MIXER,
                ("MinValue %X of Control %X of type %X on Channel %X is out of range! Correcting",
                pChannelStepping->MinValue,
                pControl->Control.dwControlID,
                pControl->Control.dwControlType,
                i) );
            pChannelStepping->MinValue = DEFAULT_RANGE_MIN;
        }
        if (!(pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536)) {
            DPF(DL_WARNING|FA_MIXER,
                ("MaxValue %X of Control %X of type %X on Channel %X is out of range! Correcting",
                pChannelStepping->MaxValue,
                pControl->Control.dwControlID,
                pControl->Control.dwControlType,
                i) );
            pChannelStepping->MaxValue = DEFAULT_RANGE_MAX;
        }
        if (!(pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535)) {
            DPF(DL_WARNING|FA_MIXER,
                ("Steps %X of Control %X of type %X on Channel %X is out of range! Correcting",
                pChannelStepping->Steps,
                pControl->Control.dwControlID,
                pControl->Control.dwControlType,
                i) );
            pChannelStepping->Steps    = DEFAULT_RANGE_STEPS;
            pControl->Control.Metrics.cSteps = DEFAULT_RANGE_STEPS;
        }

        DPF(DL_TRACE|FA_MIXER,( "Channel %d ranges from %08x to %08x by %08x steps",
               i,
               pChannelStepping->MinValue,
               pChannelStepping->MaxValue,
               pChannelStepping->Steps ) );

        // Use the next Stepping structure, if there is one.
        if (++i < pMemberHeader->MembersCount) {
            pSteppingLong++;
        }
    }

    AudioFreeMemory_Unknown( &pPropDesc );
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// FindTopologyConnectionTo
//
// Scans through the connection table looking for a connection that
// matches the ToNode/ToNodePin criteria.
//
//

ULONG
kmxlFindTopologyConnectionTo(
    IN CONST KSTOPOLOGY_CONNECTION* pConnections,   // The connection table
    IN ULONG                        cConnections,   // The # of connections
    IN ULONG                        StartIndex,     // Index to start search
    IN ULONG                        ToNode,         // The Node ID to look for
    IN ULONG                        ToNodePin       // The Pin ID to look for
)
{
    ULONG i;

    PAGED_CODE();
    for( i = StartIndex; i < cConnections; i++ ) {
        if( ( ( pConnections[ i ].ToNode      == ToNode         )   ||
              ( ToNode                        == PINID_WILDCARD ) ) &&
            ( ( pConnections[ i ].ToNodePin   == ToNodePin      )   ||
              ( ToNodePin                     == PINID_WILDCARD ) ) ) {
            return( i );
        }
    }
    return( (ULONG) -1 );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNumMuxLines
//
//

DWORD
kmxlGetNumMuxLines(
    IN PKSTOPOLOGY  pTopology,
    IN ULONG        NodeId
)
{
    ULONG Index = 0,
          Count = 0;

    PAGED_CODE();
    do {

        Index = kmxlFindTopologyConnectionTo(
            pTopology->TopologyConnections,
            pTopology->TopologyConnectionsCount,
            Index,
            NodeId,
            PINID_WILDCARD
            );
        if( Index == (ULONG) -1 ) {
            break;
        }

        ++Count;
        ++Index;


    } while( 1 );

    return( Count );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetMuxLineNames
//
//

VOID
kmxlGetMuxLineNames(
    IN PMIXEROBJECT pmxobj,
    IN PMXLCONTROL  pControl
)
{
    PMXLNODE  pNode;
    ULONG i, Index = 0, NodeId;

    ASSERT( pmxobj );
    ASSERT( pControl );
    PAGED_CODE();


    if( !NT_SUCCESS( AudioAllocateMemory_Paged(pControl->Control.cMultipleItems * sizeof( MIXERCONTROLDETAILS_LISTTEXT ),
                                               TAG_AudG_GETMUXLINE,
                                               ZERO_FILL_MEMORY,
                                               &pControl->Parameters.lpmcd_lt ) ) )
    {
        DPF(DL_WARNING|FA_USER,("Failing non failable routine!") );
        return;
    }


    if( !NT_SUCCESS( AudioAllocateMemory_Paged(pControl->Control.cMultipleItems * sizeof( ULONG ),
                                               TAG_AudG_GETMUXLINE,
                                               ZERO_FILL_MEMORY,
                                               &pControl->Parameters.pPins ) ) )
    {
        AudioFreeMemory( pControl->Control.cMultipleItems * sizeof( MIXERCONTROLDETAILS_LISTTEXT ),
                         &pControl->Parameters.lpmcd_lt );
        pControl->Parameters.Count = 0;
        DPF(DL_WARNING|FA_USER,("Failing non failable routine!") );
        return;
    }

    ASSERT( pControl->Parameters.lpmcd_lt );
    ASSERT( pControl->Parameters.pPins );

    pControl->Parameters.Count = pControl->Control.cMultipleItems;

    for( i = 0; i < pControl->Control.cMultipleItems; i++ ) {

        Index = kmxlFindTopologyConnectionTo(
            pmxobj->pTopology->TopologyConnections,
            pmxobj->pTopology->TopologyConnectionsCount,
            Index,
            pControl->Id,
            PINID_WILDCARD
            );
        if( Index != (ULONG) -1 ) {

            NodeId = pmxobj->pTopology->TopologyConnections[ Index ].FromNode;
            if( NodeId == KSFILTER_NODE ) {
                pControl->Parameters.lpmcd_lt[ i ].dwParam1 = pmxobj->pTopology->TopologyConnections[ Index ].FromNodePin;
                pControl->Parameters.lpmcd_lt[ i ].dwParam2 = (DWORD) -1;
                pControl->Parameters.pPins[ i ]
                    = pmxobj->pTopology->TopologyConnections[ Index ].ToNodePin;

                ++Index;
                continue;
            } else {
                pNode = &pmxobj->pNodeTable[ NodeId ];
            }
            ++Index;
            while( pNode ) {

                if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_SUM ) ||
                    IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUX ) ||
                    ( kmxlParentListLength( pNode ) > 1 ) )
                {
                    pControl->Parameters.lpmcd_lt[ i ].dwParam1 = 0x8000 + pNode->Id;
                    pControl->Parameters.lpmcd_lt[ i ].dwParam2 = (DWORD) -1;
                    pControl->Parameters.pPins[ i ]
                        = pmxobj->pTopology->TopologyConnections[ Index - 1 ].ToNodePin;
                    break;
                }

                if( pNode->Type == SOURCE ) {
                    pControl->Parameters.lpmcd_lt[ i ].dwParam1 = pNode->Id;
                    pControl->Parameters.lpmcd_lt[ i ].dwParam2 = (DWORD) -1;
                    pControl->Parameters.pPins[ i ]
                        = pmxobj->pTopology->TopologyConnections[ Index - 1 ].ToNodePin;
                    break;
                } // if
                if( kmxlFirstParentNode( pNode ) ) {
                    pNode = (kmxlFirstParentNode( pNode ))->pNode;
                } else {
                    pNode = NULL;
                }
            } // while
        } // if
    } // for
} // kmxlGetMuxLineNames
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\kmxlutil.c ===
//---------------------------------------------------------------------------
//
//  Module:   kmxlutil.c
//
//  Description:
//    Utility routines used by the kernel mixer line driver (KMXL).
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          I N C L U D E S                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#include "WDMSYS.H"


#undef SUPER_DEBUG

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                   U T I L I T Y   F U N C T I O N S               //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//
// kmxlOpenSysAudio
//
// Opens the topology driver and dereferences the handle to get the
// file object.
//
//

PFILE_OBJECT
kmxlOpenSysAudio(
)
{
    PFILE_OBJECT pfo = NULL;
    HANDLE       hDevice = NULL;
    ULONG        ulDefault;
    NTSTATUS     Status;

    PAGED_CODE();
    //
    // Open the topology driver.
    //

    Status = OpenSysAudio(&hDevice, &pfo);

    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_SYSAUDIO,("OpenSysAudio failed Status=%X",Status) );
        return( NULL );
    }

    //
    // The handle is no longer necessary so close it.
    //

    NtClose( hDevice );

    ulDefault = KSPROPERTY_SYSAUDIO_MIXER_DEFAULT;

    Status = SetSysAudioProperty(
      pfo,
      KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT,
      sizeof(ulDefault),
      &ulDefault);

    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_SYSAUDIO,("SetSysAudioProperty failed Status=%X",Status) );
        return( NULL );
    }

    return( pfo );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlCloseSysAudio
//
// Close the topology device by dereferencing the file object.
//
//

VOID
kmxlCloseSysAudio(
    IN PFILE_OBJECT pfo     // Pointer to the file object to close
)
{
    PAGED_CODE();
    ObDereferenceObject( pfo );
}


///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestination
//
// In the list of destinations, it finds the destination matching
// the given id.
//
//

PMXLNODE
kmxlFindDestination(
    IN NODELIST listDests,  // The list of destinations to search
    IN ULONG    Id          // The node Id to look for in the list
)
{
    PMXLNODE pTemp = kmxlFirstInList( listDests );

    PAGED_CODE();
    while( pTemp ) {
        if( pTemp->Id == Id ) {
            return( pTemp );
        }
        pTemp = kmxlNextNode( pTemp );
    }

    return( NULL );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAppendListToList
//
// Finds the end of the source list and makes the next element point
// to the head of target list.
//
//

VOID
kmxlAppendListToList(
    IN OUT PSLIST* plistTarget,   // The list to append to
    IN     PSLIST  listSource     // the list to append
)
{
    PSLIST pTemp;

    PAGED_CODE();

    if( *plistTarget == NULL ) {
        *plistTarget = listSource;
        return;
    }

    //
    // If source is NULL, there's no need to append.
    //

    if( listSource == NULL ) {
        return;
    }

    //
    // First find the end of the source list.  At this point,
    // listSource has at least 1 element.
    //

    pTemp = listSource;
    while( pTemp->Next ) {
        pTemp = pTemp->Next;
    }

    //
    // Attach the target list onto the end.
    //

    pTemp->Next = *plistTarget;
    *plistTarget = listSource;

}

///////////////////////////////////////////////////////////////////////
//
// kmxlAppendListToEndOfList
//
// Finds the end of the target list and points the next to the source
// list.
//
//

VOID
kmxlAppendListToEndOfList(
    IN OUT PSLIST* plistTarget,         // The list to append to
    IN     PSLIST  listSource           // the list to append
)
{
    PSLIST pTemp;

    PAGED_CODE();

    if( *plistTarget == NULL ) {
        *plistTarget = listSource;
        return;
    }

    //
    // Find the end of the target list.  Target list must contain
    // at least one element at this point.
    //

    pTemp = *plistTarget;
    while( pTemp->Next ) {
        pTemp = pTemp->Next;
    }

    pTemp->Next = listSource;

}

////////////////////////////////////////////////////////////////////////
//
// kmxlListCount
//
// Loops through the Next fields to count the elements.
//
//

ULONG
kmxlListCount(
    IN PSLIST pList     // The list to count the elements of
)
{
    ULONG   Count = 0;
    PSLIST  pTemp = pList;

    PAGED_CODE();
    while( pTemp ) {
        ++Count;
        pTemp = pTemp->Next;
    }

    return( Count );
}


///////////////////////////////////////////////////////////////////////
//
// kmxlInList
//
// Loops through the given list looking for pNewNode.
//
//

BOOL
kmxlInList(
    IN PEERLIST  list,      // The list to search
    IN PMXLNODE  pNewNode   // The new to search for
)
{
    PEERNODE* pTemp = kmxlFirstInList( list );

    PAGED_CODE();
    // Zing through the list checking to see if there is a node with
    // the same Id and Type.  These two checks are suffient to ensure
    // uniquness.  Ids are unique among all sources and destinations,
    // and Ids, or node numbers, are unique among all nodes.  Note
    // that a source (or destination) node and a node can have the same
    // Id.

    while( pTemp ) {
        if( ( pTemp->pNode->Id   == pNewNode->Id   ) &&
            ( pTemp->pNode->Type == pNewNode->Type ) )
            return( TRUE );
        pTemp = kmxlNextPeerNode( pTemp );
    }

    // No match in the entire list, the new node is not already in the
    // list.

    return( FALSE );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlInChildList
//
// Calls kmxlInList on the child list of the node.
//
//

BOOL
kmxlInChildList(
    IN NODELIST list,       // The list to search the parent list
    IN PMXLNODE pNewNode    // The node to search for
)
{
    ASSERT( list )    ;
    ASSERT( pNewNode );

    PAGED_CODE();

    return( kmxlInList( list->Children, pNewNode ) );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlInParentList
//
// Calls kmxlInList on the parent list of the node.
//
//

BOOL
kmxlInParentList(
    IN NODELIST list,       // The list to search the parent list
    IN PMXLNODE pNewNode    // The node to search for
)
{
    ASSERT( list     );
    ASSERT( pNewNode );

    PAGED_CODE();

    return( kmxlInList( list->Parents, pNewNode ) );
}

  
///////////////////////////////////////////////////////////////////////
//
// kmxlFreePeerList
//
//
// NOTES
//   This only frees the peer nodes in a peer list.  The nodes pointed
//   to be the pNode member must be clean up in some other manner.
//
//

VOID
kmxlFreePeerList(
    IN PEERLIST list    // The PeerList to free
)
{
    PEERNODE* pPeerNode = kmxlRemoveFirstPeerNode( list );

    PAGED_CODE();
    while( pPeerNode ) {
        AudioFreeMemory( sizeof(PEERNODE),&pPeerNode );
        pPeerNode = kmxlRemoveFirstPeerNode( list );
    }
}


///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateMixerControl
//
// Calls AudioAllocateMemory() to allocate and zero fill the MXLCONTROL.
//
//

MXLCONTROL*
kmxlAllocateControl(
    IN ULONG ultag
)
{
    MXLCONTROL* p = NULL;

    PAGED_CODE();
    if( NT_SUCCESS( AudioAllocateMemory_Paged(sizeof( MXLCONTROL ),
                                              ultag,
                                              ZERO_FILL_MEMORY,
                                              &p) ) )
    {    
#ifdef DEBUG
        p->Tag=CONTROL_TAG;
#endif
        return( p );
    } else {
        return( NULL );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFreeControl
//
// Frees the memory associated with a control.  It also checkes the
// special cases for some controls that have special memory associated
// with them. And, if the control supports change notifications, it gets
// turned off here.
//
//
VOID
kmxlFreeControl(
    IN PMXLCONTROL pControl
)
{
    NTSTATUS Status;
    PAGED_CODE();
    DPFASSERT( IsValidControl( pControl ) );

    //
    // Need to disable change notifications on this node if it supported them!
    //
    kmxlDisableControlChangeNotifications(pControl);

    if( pControl->NodeType ) {

        if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUX ) &&
            !pControl->Parameters.bHasCopy ) {
            AudioFreeMemory_Unknown( &pControl->Parameters.lpmcd_lt );
            AudioFreeMemory_Unknown( &pControl->Parameters.pPins );
        }

        if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
            if (InterlockedDecrement(pControl->Parameters.pReferenceCount)==0) {
                AudioFreeMemory_Unknown( &pControl->Parameters.pMixCaps );
                AudioFreeMemory_Unknown( &pControl->Parameters.pMixLevels );
                AudioFreeMemory( sizeof(LONG),&pControl->Parameters.pReferenceCount );
                }
        }
    }

    // Check that we're not in the case where Numchannels == 0 And we have a valid
    // pControl->pChannelStepping.  If this were true, we'd end up leaking
    // pChannelStepping.
    
    ASSERT( !(pControl->pChannelStepping && pControl->NumChannels == 0) );
        
    if ( pControl->pChannelStepping && pControl->NumChannels > 0 ) {
        RtlZeroMemory( pControl->pChannelStepping, pControl->NumChannels * sizeof( CHANNEL_STEPPING ) );
        AudioFreeMemory_Unknown( &pControl->pChannelStepping );
    }
  
    //
    // Why do we zero the memory on this free?
    //
    RtlZeroMemory( pControl, sizeof( MXLCONTROL ) );
    AudioFreeMemory( sizeof( MXLCONTROL ),&pControl );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateLine
//
// Calls AudioAllocateMemory() to allocate and zero fill the MXLLINE.
//
//
//
// Workitem: Tag all these structures in debug!
//

MXLLINE*
kmxlAllocateLine(
    IN ULONG ultag
)
{
    MXLLINE* p = NULL;
    PAGED_CODE();
    if( NT_SUCCESS( AudioAllocateMemory_Paged( sizeof( MXLLINE ), 
                                               ultag, 
                                               ZERO_FILL_MEMORY, 
                                               &p ) ) ) 
    {    
        p->SourceId = INVALID_ID;
        p->DestId   = INVALID_ID;
        return( p );
    } else {
        return( NULL );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateNode
//
// Calls AudioAllocateMemory() to allocate and zero fill the MXLNODE.
//
//

MXLNODE*
kmxlAllocateNode(
    IN ULONG ultag
)
{
    MXLNODE* p = NULL;

    PAGED_CODE();
    if( NT_SUCCESS( AudioAllocateMemory_Paged( sizeof( MXLNODE ), 
                                               ultag, 
                                               ZERO_FILL_MEMORY, 
                                               &p ) ) ) 
    {    
        return( p );
    } else {
        return( NULL );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocatePeerNode
//
// Calls AudioAllocateMemory() to allocate and zero fill the PEERNODE.
//
//

PEERNODE*
kmxlAllocatePeerNode(
    IN PMXLNODE pNode OPTIONAL, // The node to associate with the peer
    IN ULONG ultag
)
{
    PEERNODE* p = NULL;

    PAGED_CODE();
    if( NT_SUCCESS( AudioAllocateMemory_Paged( sizeof( PEERNODE ), 
                                               ultag, 
                                               ZERO_FILL_MEMORY, 
                                               &p ) ) ) 
    {
        p->pNode = pNode;
        return( p );
    } else {
        return( NULL );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAddToEndOfList
//
// Finds the end of the list and sets the next field to the new element.
//
//

VOID
kmxlAddElemToEndOfList(
    IN OUT PSLIST* list,                // The list to add to the end of
    IN PSLIST      elem                 // The element or list to add
)
{
    PSLIST pTemp;

    PAGED_CODE();
    ASSERT( list );
    ASSERT( elem->Next == NULL );

    //
    // If the list doesn't have anything in it, the element becomes the
    // list.
    //

    if( *list == NULL ) {
        *list = elem;
        return;
    }

    //
    // Find the end of the list.
    //

    pTemp = *list;
    while( pTemp->Next ) {
        pTemp = pTemp->Next;
    }

    //
    // And attach the element to it.
    //

    pTemp->Next = elem;
}

#define LINEAR_RANGE 0xFFFF     // 64k

#define DFLINEAR_RANGE  ( 96.0 * 65535.0 )

#define NEG_INF_DB   0x80000000 // -32767 * 64k dB

///////////////////////////////////////////////////////////////////////
//
// kmxlVolLogToLinear
//
// Converts from the hardware range (dB) to the liner mixer line range (0-64k).
//
//


DWORD
kmxlVolLogToLinear(
    IN PMXLCONTROL  pControl,
    IN LONG         Value,
    IN MIXERMAPPING Mapping,
    IN ULONG        Channel
)
{
    KFLOATING_SAVE      FloatSave;
    double              LinearRange;
    double              dfValue;
    double              dfResult;
    double              dfRatio;
    DWORD               Result;
    PCHANNEL_STEPPING   pChannelStepping;

    PAGED_CODE();
    if( Value == NEG_INF_DB ) {
        return( 0 );
    }

    ASSERT( Channel < pControl->NumChannels );
    // Get the proper range for the specified channel
    pChannelStepping = &pControl->pChannelStepping[Channel];

    if( NT_SUCCESS( KeSaveFloatingPointState( &FloatSave ) ) ) {

        LinearRange = (double) LINEAR_RANGE;
        dfValue     = (double) Value;

        switch( Mapping ) {

            ////////////////////////////////////////////////////////////
            case MIXER_MAPPING_LOGRITHMIC:
            ////////////////////////////////////////////////////////////

                dfRatio = ( (double) pChannelStepping->MaxValue -
                            (double) pChannelStepping->MinValue ) / DFLINEAR_RANGE;

                if( dfRatio < 1.0 ) {
                    dfRatio = 1.0;
                }

                dfValue = ( dfValue - pChannelStepping->MaxValue ) / LinearRange;
                dfResult = LinearRange * pow( 10.0, dfValue / ( 20.0 * dfRatio ) );

                if( dfResult >= LINEAR_RANGE ) {
                    Result = LINEAR_RANGE;
                } else if ( dfResult < 0.0 ) {
                   Result = 0;
                } else {
                   Result = (DWORD) ( dfResult + 0.5 );
                }

                break;

            ////////////////////////////////////////////////////////////
            case MIXER_MAPPING_LINEAR:
            ////////////////////////////////////////////////////////////

                dfResult = ( LinearRange * ( dfValue - pChannelStepping->MinValue ) ) /
                           ( pChannelStepping->MaxValue - pChannelStepping->MinValue );
                Result = (DWORD) ( dfResult + 0.5 );
                break;

            ////////////////////////////////////////////////////////////
            default:
            ////////////////////////////////////////////////////////////

                ASSERT( 0 );
                Result = 0;
        }

        KeRestoreFloatingPointState( &FloatSave );

        DPF(DL_TRACE|FA_MIXER,
            ( "kmxlVolLogToLinear( %x [%d] ) =%d= %x [%d]",
            Value,
            Value,
            Mapping,
            (WORD) Result,
            (WORD) Result
            ) );

        return( Result );

    } else {

        return( (DWORD) ( LINEAR_RANGE *
                          ( (LONGLONG) Value - (LONGLONG) pChannelStepping->MinValue ) /
                            ( (LONGLONG) pChannelStepping->MaxValue -
                              (LONGLONG) pChannelStepping->MinValue ) ) );
    }


#ifdef LEGACY_SCALE
    WORD Result;

    Result = VolLogToLinear( (WORD) ( Value / ( -1 * LINEAR_RANGE ) ) );

    #ifdef API_TRACE
    TRACE( "WDMAUD: kmxlVolLogToLinear( %x [%d] ) = %x [%d]\n",
        Value,
        Value,
        (WORD) Result,
        (WORD) Result
        );
    #endif

    return( Result );

#endif // LEGACY_SCALE

#ifdef LONG_CALC_SCALE
    LONGLONG ControlRange = (LONGLONG) pChannelStepping->MaxValue -
                            (LONGLONG) pChannelStepping->MinValue;
    LONGLONG MinValue = (LONGLONG) pChannelStepping->MinValue;
    LONGLONG Result;

    ASSERT( ControlRange );

    Result = LINEAR_RANGE * ( (LONGLONG) Value - MinValue ) / ControlRange;

    #ifdef API_TRACE
    TRACE( "WDMAUD: kmxlVolLogToLinear( %x [%d] ) = %x [%d]\n",
        Value,
        Value,
        (WORD) Result,
        (WORD) Result
        );
    #endif

    return( (WORD) Result );
#endif // LONG_CALC_SCALE
}

///////////////////////////////////////////////////////////////////////
//
// kmxlVolLinearToLog
//
// Converts from the mixer line range (0-64k) to the hardware range (dB).
//
//

LONG
kmxlVolLinearToLog(
    IN PMXLCONTROL  pControl,
    IN DWORD        Value,
    IN MIXERMAPPING Mapping,
    IN ULONG        Channel
)
{
    KFLOATING_SAVE      FloatSave;
    double              LinearRange;
    double              dfValue;
    double              dfResult;
    double              dfRatio;
    LONG                Result;
    PCHANNEL_STEPPING   pChannelStepping;

    PAGED_CODE();
    if( Value == 0 ) {
        return( NEG_INF_DB );
    }

    ASSERT( Channel < pControl->NumChannels );
    // Get the proper range for the specified channel
    pChannelStepping = &pControl->pChannelStepping[Channel];

    if( NT_SUCCESS( KeSaveFloatingPointState( &FloatSave ) ) ) {

        LinearRange = (double) LINEAR_RANGE;
        dfValue     = (double) Value;

        switch( Mapping ) {

            ////////////////////////////////////////////////////////////
            case MIXER_MAPPING_LOGRITHMIC:
            ////////////////////////////////////////////////////////////

                dfRatio = ( (double) pChannelStepping->MaxValue -
                            (double) pChannelStepping->MinValue ) / DFLINEAR_RANGE;

                if( dfRatio < 1.0 ) {
                    dfRatio = 1.0;
                }

                dfResult = LinearRange * dfRatio * 20.0 * log10( dfValue / LinearRange );
                if( dfResult < 0.0 ) {
                    Result = (LONG) ( dfResult - 0.5 ) + pChannelStepping->MaxValue;
                } else {
                    Result = (LONG) ( dfResult + 0.5 ) + pChannelStepping->MaxValue;
                }
                break;

            ////////////////////////////////////////////////////////////
            case MIXER_MAPPING_LINEAR:
            ////////////////////////////////////////////////////////////

                dfResult = ( dfValue * ( pChannelStepping->MaxValue - pChannelStepping->MinValue ) ) /
                           LinearRange + pChannelStepping->MinValue;
                if( dfResult < 0.0 ) {
                    Result = (LONG) ( dfResult - 0.5 );
                } else {
                    Result = (LONG) ( dfResult + 0.5 );
                }
                break;

            ////////////////////////////////////////////////////////////
            default:
            ////////////////////////////////////////////////////////////

                ASSERT( 0 );
                Result = NEG_INF_DB;

        }

        KeRestoreFloatingPointState( &FloatSave );

        DPF(DL_TRACE|FA_MIXER, 
            ( "kmxlVolLinearToLog( %x [%d]) =%d= %x [%d]",
            Value,
            Value,
            Mapping,
            (LONG) Result,
            (LONG) Result
            ) );

        return( Result );

    } else {

        return( (LONG)
            ( (LONGLONG) Value *
              (LONGLONG) ( pChannelStepping->MaxValue - pChannelStepping->MinValue )
              / ( LONGLONG ) LINEAR_RANGE + (LONGLONG) pChannelStepping->MinValue )
            );
    }

#ifdef LEGACY_SCALE
    LONG Result;

    if( Value == 0 ) {
        Result = NEG_INF_DB;
    } else {
        Result = (LONG) VolLinearToLog( Value ) * -1 * (LONG) LINEAR_RANGE + pChannelStepping->MaxValue;
    }

    #ifdef API_TRACE
    TRACE( "WDMAUD: kmxlVolLinearToLog( %x [%d]) = %x [%d]\n",
        Value,
        Value,
        (LONG) Result,
        (LONG) Result
        );
    #endif

    return( Result );
#endif // LEGACY_SCALE

#ifdef LONG_CALC_SCALE

    LONGLONG ControlRange = (LONGLONG) pChannelStepping->MaxValue -
                            (LONGLONG) pChannelStepping->MinValue;
    LONGLONG MinValue = pChannelStepping->MinValue;
    LONGLONG Result;

    ASSERT( ControlRange );

    Result = (LONGLONG) Value * ControlRange / LINEAR_RANGE + MinValue;

    #ifdef API_TRACE
    TRACE( "WDMAUD: kmxlVolLinearToLog( %x [%d]) = %x [%d]\n",
        Value,
        Value,
        (LONG) Result,
        (LONG) Result
        );
    #endif

    return( (LONG) Result );
#endif // LONG_CALC_SCALE
}


///////////////////////////////////////////////////////////////////////
//
// kmxlSortByDestination
//
// Performs a sort by destination in numerical increasing order.
//
//

NTSTATUS
kmxlSortByDestination(
    IN LINELIST* list                   // The pointer to the list to sort
)
{
    PMXLLINE pTemp1,
             pTemp2;
    MXLLINE  Temp;
    ULONG    Count = kmxlListLength( *list );

    PAGED_CODE();
    //
    // If there are only 0 or 1 elements, there's no reason to even try to
    // sort.
    //

    if( Count < 2 ) {
        return( STATUS_SUCCESS );
    }

    //
    // Pretty standard BubbleSort.
    //

    while( --Count ) {

        //
        // Loop over each element in the list.
        //

        pTemp1 = kmxlFirstInList( *list );
        while( pTemp1 ) {

            //
            // Loop over the remaining elements.
            //

            pTemp2 = kmxlNextLine( pTemp1 );
            while( pTemp2 ) {

                //
                // The destination is strictly bigger.  Swap 'em.
                //

                if( pTemp1->DestId > pTemp2->DestId ) {
                    SwapEm( pTemp1, pTemp2, &Temp, sizeof( MXLLINE ) );
                    break;
                }

                //
                // The destinations are the same, but the source is
                // bigger.  Swap 'em.
                //

                if( pTemp1->DestId == pTemp2->DestId ) {
                    if( pTemp1->SourceId > pTemp2->SourceId ) {
                        SwapEm( pTemp1, pTemp2, &Temp, sizeof( MXLLINE ) );
                        break;
                    }
                }
                pTemp2 = kmxlNextLine( pTemp2 );
            }

            pTemp1 = kmxlNextLine( pTemp1 );
        }

    }

    return( STATUS_SUCCESS );

}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//              M I X E R L I N E  W R A P P E R S                   //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#pragma warning( disable : 4273 )

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocDeviceInfo
//
// Note: when allocating DeviceInfo structure, we know that the structure's
// definition includes one character for the DeviceInterface, so we only need
// to allocate additional length for the string but not its NULL terminator
//
///////////////////////////////////////////////////////////////////////
NTSTATUS kmxlAllocDeviceInfo(
    LPDEVICEINFO *ppDeviceInfo, 
    PCWSTR DeviceInterface, 
    DWORD dwFlags,
    ULONG ultag
)
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = AudioAllocateMemory_Paged(sizeof(**ppDeviceInfo)+(wcslen(DeviceInterface)*sizeof(WCHAR)),
                                       ultag,
                                       ZERO_FILL_MEMORY,
                                       ppDeviceInfo);
    if (NT_SUCCESS(Status))
    {
        wcscpy((*ppDeviceInfo)->wstrDeviceInterface, DeviceInterface);
        (*ppDeviceInfo)->DeviceType   = MixerDevice;
        (*ppDeviceInfo)->dwFormat     = UNICODE_TAG;
        (*ppDeviceInfo)->dwFlags      = dwFlags;
    } else {
        *ppDeviceInfo = NULL;
    }
    return Status;
}

///////////////////////////////////////////////////////////////////////
//
// mixerGetControlDetails
//
//

MMRESULT
WINAPI
kmxlGetControlDetails(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERCONTROLDETAILS pmxcd,
    DWORD fdwDetails
)
{
    LPDEVICEINFO DeviceInfo = NULL;
    NTSTATUS Status;
    MMRESULT mmr;

    PAGED_CODE();
    if (!NT_SUCCESS(kmxlAllocDeviceInfo(&DeviceInfo, DeviceInterface, fdwDetails,TAG_AudD_DEVICEINFO))) {
        return MMSYSERR_NOMEM;
    }

    Status = kmxlGetControlDetailsHandler( pWdmaContext, DeviceInfo, pmxcd, pmxcd->paDetails );
    mmr = DeviceInfo->mmr;
    AudioFreeMemory_Unknown( &DeviceInfo);
    return mmr;
}

///////////////////////////////////////////////////////////////////////
//
// mixerGetLineControls
//
//

MMRESULT
WINAPI
kmxlGetLineControls(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERLINECONTROLS pmxlc,
    DWORD fdwControls
)
{
    LPDEVICEINFO DeviceInfo = NULL;
    NTSTATUS Status;
    MMRESULT mmr;

    PAGED_CODE();
    if (!NT_SUCCESS(kmxlAllocDeviceInfo(&DeviceInfo, DeviceInterface, fdwControls,TAG_AudD_DEVICEINFO))) {
        return MMSYSERR_NOMEM;
    }

    Status = kmxlGetLineControlsHandler( pWdmaContext, DeviceInfo, pmxlc, pmxlc->pamxctrl );
    mmr = DeviceInfo->mmr;
    AudioFreeMemory_Unknown(&DeviceInfo);
    return mmr;
}

///////////////////////////////////////////////////////////////////////
//
// mixerGetLineInfo
//
//

MMRESULT
WINAPI
kmxlGetLineInfo(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERLINE pmxl,
    DWORD fdwInfo
)
{
    LPDEVICEINFO DeviceInfo = NULL;
    NTSTATUS Status;
    MMRESULT mmr;

    PAGED_CODE();
    if (!NT_SUCCESS(kmxlAllocDeviceInfo(&DeviceInfo, DeviceInterface, fdwInfo, TAG_AudD_DEVICEINFO))) {
        return MMSYSERR_NOMEM;
    }

    Status = kmxlGetLineInfoHandler( pWdmaContext, DeviceInfo, pmxl );
    mmr = DeviceInfo->mmr;
    AudioFreeMemory_Unknown(&DeviceInfo);
    return mmr;
}

///////////////////////////////////////////////////////////////////////
//
// mixerSetControlDetails
//
//

MMRESULT
WINAPI
kmxlSetControlDetails(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    LPMIXERCONTROLDETAILS pmxcd,
    DWORD fdwDetails
)
{
    LPDEVICEINFO DeviceInfo = NULL;
    NTSTATUS Status;
    MMRESULT mmr;

    PAGED_CODE();
    if (!NT_SUCCESS(kmxlAllocDeviceInfo(&DeviceInfo, DeviceInterface, fdwDetails, TAG_AudD_DEVICEINFO))) {
        return MMSYSERR_NOMEM;
    }

    Status =
        kmxlSetControlDetailsHandler( pWdmaContext,
                                      DeviceInfo,
                                      pmxcd,
                                      pmxcd->paDetails,
                                      MIXER_FLAG_PERSIST
                                    );
    mmr = DeviceInfo->mmr;
    AudioFreeMemory_Unknown(&DeviceInfo);
    return mmr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\mixer.c ===
//---------------------------------------------------------------------------
//
//  Module:   mixer.c
//
//  Description:
//    Contains the kernel mode portion of the mixer line driver.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          I N C L U D E S                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#include "WDMSYS.H"

typedef struct {
    VOID *pNext;
    PMXLCONTROL pControl;
#ifdef DEBUG
    DWORD dwSig;  // CONTROLLINK_SIGNATURE
#endif

} CONTROLLINK, *PCONTROLLINK;

//
// Data structure for Notification list.
//
typedef struct {    
    PVOID pNext;             // Pointer to next node in linked list.

    DWORD NodeId;            // This is the control's Id as seen by SysAudio

    DWORD LineID;            // Line that this control lives on
    DWORD ControlID;         // ControlID from pControl->Control.dwControlID
    DWORD ControlType;       //

    // context specific stuff...

    PWDMACONTEXT pContext;   // Pointer to Global Context structure
    PMIXERDEVICE pmxd;       // The mixer device for this control
//    PFILE_OBJECT pfo;        // File Object to SysAudio for this Context
    PCONTROLLINK pcLink;     // points to structure that contains valid
                             // pControl addresses in this context.
    KDPC NodeEventDPC;       // For handling the DPCs
    KSEVENTDATA NodeEventData;

#ifdef DEBUG
    DWORD dwSig;             // NOTIFICATION_SIGNATURE
#endif

} NOTENODE, *PNOTENODE;

#ifdef DEBUG
BOOL
IsValidNoteNode(
    IN PNOTENODE pnnode
    );

BOOL
IsValidControlLink(
    IN PCONTROLLINK pcLink
    );

/////////////////////////////////////////////////////////////////////////////
//
// IsValidNoteNode
//
// Validates that the pointer is a PNOTENODE type.
//
BOOL
IsValidNoteNode(
    IN PNOTENODE pnnode)
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if(pnnode->dwSig != NOTIFICATION_SIGNATURE)
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->dwSig(%08X)",pnnode->dwSig) );
            Status=STATUS_UNSUCCESSFUL;
        }      
/*
        if(pnnode->pfo == NULL)
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->pfo(%08X)",pnnode->pfo) );
            Status=STATUS_UNSUCCESSFUL;
        }
*/
        if( !IsValidWdmaContext(pnnode->pContext) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->pContext(%08X)",pnnode->pContext) );
            Status=STATUS_UNSUCCESSFUL;
        }

        if( !IsValidMixerDevice(pnnode->pmxd) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->pmxd(%08X)",pnnode->pmxd) );
            Status=STATUS_UNSUCCESSFUL;
        }

        if( !IsValidControlLink(pnnode->pcLink) )
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pnnode->pcLink(%08X)",pnnode->pcLink) );
            Status=STATUS_UNSUCCESSFUL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// IsValidControlLink
//
// Validates that the pointer is a PNOTENODE type.
//
BOOL
IsValidControlLink(
    IN PCONTROLLINK pcLink)
{
    NTSTATUS Status=STATUS_SUCCESS;
    try
    {
        if(pcLink->dwSig != CONTROLLINK_SIGNATURE)
        {
            DPF(DL_ERROR|FA_ASSERT,("Invalid pcLink->dwSig(%08X)",pcLink->dwSig) );
            Status=STATUS_UNSUCCESSFUL;
        }      
        if( !IsValidControl(pcLink->pControl) )
        {
            Status=STATUS_UNSUCCESSFUL;
        }
        //
        // pcLink->pNext is a pointer to another CONTROLLINK structure.  Thus,
        // if it's not NULL, the structure that it points to should also be valid.
        //
        if( pcLink->pNext )
        {
            PCONTROLLINK pTmp=pcLink->pNext;
            if( pTmp->dwSig != CONTROLLINK_SIGNATURE )
            {
                DPF(DL_ERROR|FA_ASSERT,("Invalid pcLink->pNext->dwSig(%08X)",pTmp->dwSig) );
                Status=STATUS_UNSUCCESSFUL;
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }
    if( NT_SUCCESS(Status) )
    {
        return TRUE;
    } else {
        return FALSE;
    }
}


#endif



PNOTENODE 
kmxlNewNoteNode(
    );

PCONTROLLINK
kmxlNewControlLink(
    IN PMXLCONTROL pControl
    );

VOID
kmxlFreeControlLink(
    IN OUT PCONTROLLINK pcLink
    );

VOID 
kmxlFreeNoteNode(
    IN OUT PNOTENODE pnnode
    );

VOID 
kmxlAddNoteNodeToList(
    IN OUT PNOTENODE pnnode
    );

VOID 
kmxlRemoveNoteNodeFromList(
    IN OUT PNOTENODE pnnode
    );

PNOTENODE
kmxlFindControlInNoteList(
    IN PMXLCONTROL pControl 
    );

NTSTATUS
kmxlFindNodeInNoteList(
    IN PNOTENODE pnlookupnode 
    );

PNOTENODE
kmxlFindIdInContextInNoteList(
    IN PWDMACONTEXT pWdmaContext,
    IN PMIXERDEVICE pmxd,
    IN DWORD Id
    );

PNOTENODE
kmxlFindContextInNoteList(
    IN PWDMACONTEXT pWdmaContext
    );

NTSTATUS
kmxlAddControlToNoteList(
    IN OUT PNOTENODE   pnnode,
    IN     PMXLCONTROL pControl
    );

PCONTROLLINK 
kmxlRemoveControlFromNoteList(
    IN OUT PNOTENODE   pnnode,
    IN     PMXLCONTROL pControl
    );

NTSTATUS
kmxlQueryControlChange(
    IN PFILE_OBJECT pfo,
    IN ULONG NodeId
    );

NTSTATUS
kmxlEnableControlChange(
    IN     PFILE_OBJECT pfo,
    IN     ULONG NodeId,
    IN OUT PKSEVENTDATA pksed
    );

NTSTATUS
kmxlDisableControlChange(
    IN     PFILE_OBJECT pfo,  
    IN     ULONG NodeId,
    IN OUT PKSEVENTDATA pksed
    );

NTSTATUS 
kmxlEnableControlChangeNotifications(
    IN PMIXEROBJECT pmxobj,
    IN PMXLLINE     pLine,
    IN PMXLCONTROL  pControl
    );

VOID
kmxlRemoveContextFromNoteList(
    IN PWDMACONTEXT pWdmaContext
    );

NTSTATUS
kmxlEnableAllControls(
    IN PMIXEROBJECT pmxobj
    );

//
// Used in persist
//
extern NTSTATUS
kmxlPersistSingleControl(
    IN PFILE_OBJECT pfo,
    IN PMIXERDEVICE pmxd,
    IN PMXLCONTROL  pControl,
    IN PVOID        paDetails
    );

VOID 
PersistHWControlWorker(
    IN LPVOID pData
    );

VOID
kmxlGrabNoteMutex(
    );

VOID
kmxlReleaseNoteMutex(
    );

VOID 
kmxlCloseMixerDevice(
    IN OUT PMIXERDEVICE pmxd
    );



#pragma LOCKED_CODE
#pragma LOCKED_DATA

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          F U N C T I O N S                        //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//
// This is the head of the notification list.  mtxNotification is used to
// handle the list manipulcation.  The allocated memory in the firstnotenode
// list will be touched at DPC level.
//
PNOTENODE firstnotenode=NULL;
extern KMUTEX mtxNote;
#ifdef DEBUG
LONG totalnotificationcount=0;
#endif

#define CALLBACKARRAYSIZE 128

typedef struct {
    DWORD  dwControlID;
    DWORD  dwLineID;
    DWORD  dwCallbackType;
} CBINFO, *PCBINFO;


ULONG emptyindex=0;

volatile ULONG loadindex=0;
CBINFO callbacks[CALLBACKARRAYSIZE]={0};

KSPIN_LOCK       HardwareCallbackSpinLock;
LIST_ENTRY       HardwareCallbackListHead;

PKEVENT          pHardwareCallbackEvent=NULL;
PKSWORKER        HardwareCallbackWorkerObject=NULL;
WORK_QUEUE_ITEM  HardwareCallbackWorkItem;
ULONG            HardwareCallbackScheduled=0;

typedef struct tagHWLink {
    LIST_ENTRY Next;
    PNOTENODE pnnode;
#ifdef DEBUG
    DWORD dwSig;
#endif    
} HWLINK, *PHWLINK;




/////////////////////////////////////////////////////////////////////////////
//
// NodeEventDPCHandler
//
// This routine is called at DISPATCH_LEVEL, thus you can not touch anything
// but pnnode ellements.  pnnode is fixed in memory thus it is safe.
//

VOID NodeEventDPCHandler(
    IN PKDPC Dpc, 
    IN PVOID DeferredContext, 
    IN PVOID SystemArgument1, 
    IN PVOID SystemArgument2
    )
{
    PHWLINK phwlink=NULL;
    PNOTENODE pnnode=(PNOTENODE)DeferredContext;
    PCBINFO pcbinfo;

    //
    // WorkItem: Use proper synchronization so that we never go away if there is
    // a work item scheduled!
    //
    DPFASSERT( pnnode->dwSig == NOTIFICATION_SIGNATURE );

    DPF(DL_TRACE|FA_HARDWAREEVENT, ("** ++ Event Signaled ++ **") );

    DPF(DL_TRACE|FA_HARDWAREEVENT, ("NodeId = %d LineID = %X ControlID = %X ControlType = %X",
                                    pnnode->NodeId,pnnode->LineID, 
                                    pnnode->ControlID,pnnode->ControlType) );

    callbacks[loadindex%CALLBACKARRAYSIZE].dwControlID=pnnode->ControlID;
    callbacks[loadindex%CALLBACKARRAYSIZE].dwLineID=pnnode->LineID;
    callbacks[loadindex%CALLBACKARRAYSIZE].dwCallbackType=MIXER_CONTROL_CALLBACK;

    //
    // Now we want to setup a work item to persist the hardware event.  The idea
    // is that we'll put all the events in a list and then remove them from the list
    // in the handler.  If we already have a workitem outstanding to service the
    // list, we don't schedule another.
    if( HardwareCallbackWorkerObject )
    {
        //
        // Always allocate an entry in our list to service this DPC.  We'll free this
        // event in the worker routine.
        //
        if( NT_SUCCESS(AudioAllocateMemory_Fixed(sizeof(HWLINK),
                                                 TAG_AuDF_HARDWAREEVENT,
                                                 ZERO_FILL_MEMORY,
                                                 &phwlink) ) )
        {
            phwlink->pnnode=pnnode;
#ifdef DEBUG
            phwlink->dwSig=HWLINK_SIGNATURE;
#endif

            ExInterlockedInsertTailList(&HardwareCallbackListHead,
                                        &phwlink->Next,
                                        &HardwareCallbackSpinLock);
            //
            // Now, if we haven't scheduled a work item yet, do so to service this
            // info in the list. HardwareCallbackSchedule will be 0 at
            // initialization time.  This variable will be set to 0 in the 
            // work item handler.  If we increment and it's any other value other 
            // then 1, we've already scheduled a work item.  
            //
            if( InterlockedIncrement(&HardwareCallbackScheduled) == 1 )
            {
                KsQueueWorkItem(HardwareCallbackWorkerObject, &HardwareCallbackWorkItem);
            } 
        }
    } 

    // Now if the control was a mute, then send line change as well.
    if (pnnode->ControlType==MIXERCONTROL_CONTROLTYPE_MUTE) {
        callbacks[loadindex%CALLBACKARRAYSIZE].dwCallbackType|=MIXER_LINE_CALLBACK;
    }

    loadindex++;

    if (pHardwareCallbackEvent!=NULL) {
        KeSetEvent(pHardwareCallbackEvent, 0 , FALSE);
    }
}


#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA


/////////////////////////////////////////////////////////////////////////////
//
// kmxlNewNoteNode
//
// This routine allocates another Notification node.  Note that AudioAllocateMemory zeros
// all successful memory allocations.
//
// The return value is a pointer to a Notification Node or NULL.
//

PNOTENODE 
kmxlNewNoteNode(
    )
{
    PNOTENODE pnnode = NULL;
    NTSTATUS  Status;

    PAGED_CODE();
    Status = AudioAllocateMemory_Fixed(sizeof( NOTENODE ),
                                       TAG_AuDN_NOTIFICATION,
                                       ZERO_FILL_MEMORY,
                                       &pnnode );
    if( !NT_SUCCESS( Status ) ) {
        return( NULL );
    }
    DPF(DL_MAX|FA_NOTE, ("New notification node allocated %08X",pnnode) );

#ifdef DEBUG
    pnnode->dwSig=NOTIFICATION_SIGNATURE;
#endif

    return pnnode;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlNewControlLink
//
// This routine allocates another CONTROLLINK node.  Note that AudioAllocateMemory zeros
// all successful memory allocations.
//
// The return value is a pointer to a Notification Node or NULL.
//
PCONTROLLINK
kmxlNewControlLink(
    IN PMXLCONTROL pControl
    )
{
    PCONTROLLINK pcLink = NULL;
    NTSTATUS     Status;

    PAGED_CODE();
    Status = AudioAllocateMemory_Fixed(sizeof( CONTROLLINK ),
                                       TAG_AuDL_LINK,
                                       ZERO_FILL_MEMORY,
                                       &pcLink );
    if( !NT_SUCCESS( Status ) ) {
        return( NULL );
    }

    DPF(DL_MAX|FA_NOTE, ("New controllink node allocated %08X",pcLink) );

#ifdef DEBUG
    pcLink->dwSig=CONTROLLINK_SIGNATURE;
#endif
    //
    // Setup the pcontrol first and then link it in.
    //
    pcLink->pControl=pControl;

    return pcLink;
}

VOID
kmxlFreeControlLink(
    IN OUT PCONTROLLINK pcLink
    )
{
    DPFASSERT(IsValidControlLink(pcLink));
    PAGED_CODE();

#ifdef DEBUG
    pcLink->dwSig=(DWORD)0xDEADBEEF;
#endif

    AudioFreeMemory(sizeof( CONTROLLINK ),&pcLink);
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFreeNoteNode
//
// This routine frees a Notification Node.
//
VOID 
kmxlFreeNoteNode(
    IN OUT PNOTENODE pnnode
    )
{
    PCONTROLLINK pcLink,pcTmp;
    PAGED_CODE();

    DPFASSERT( pnnode->dwSig == NOTIFICATION_SIGNATURE );
    DPFASSERT( pnnode->pNext == NULL );
    DPFASSERT( pnnode->pcLink == NULL );

    DPF(DL_MAX|FA_NOTE,("NotificationNode freed %08X",pnnode) );
    AudioFreeMemory( sizeof( NOTENODE ),&pnnode );
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlAddNoteNodeToList
//
// This routine adds the NotificationNode to the list.  It places the node
// at the head of the list.
//
VOID 
kmxlAddNoteNodeToList(
    IN OUT PNOTENODE pnnode
    )
{
    PAGED_CODE();

    pnnode->pNext=firstnotenode;
    firstnotenode=pnnode;
#ifdef DEBUG
    totalnotificationcount++;
#endif
    DPF(DL_TRACE|FA_INSTANCE,("New NoteNode head %08X, Total=%d",pnnode,totalnotificationcount) );
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlRemoveNoteNodeFromList
//
// This routine removes a node from the list.
//
VOID 
kmxlRemoveNoteNodeFromList(
    IN OUT PNOTENODE pnnode
    )
{
    PNOTENODE pTmp;

    PAGED_CODE();

    DPFASSERT(pnnode->dwSig == NOTIFICATION_SIGNATURE);

    // are we the head of the list?  If so, move the next to the head.
    if( pnnode == firstnotenode )
    {
        firstnotenode=firstnotenode->pNext;
        DPF(DL_MAX|FA_NOTE,("removed notenode head") );
    } else {
        // we are somewhere in the list we need to walk the list until we find
        // our node and clip it out.
        for (pTmp=firstnotenode;pTmp!=NULL;pTmp=pTmp->pNext)
        {
            DPFASSERT(pTmp->dwSig==NOTIFICATION_SIGNATURE);

            // Did we find our node in the next position?  If so, we
            // need to clip it out.  Thus, pTmp.next needs to point to
            // (our node)'s next.
            if(pTmp->pNext == pnnode)
            {    
                pTmp->pNext = pnnode->pNext;
                DPF(DL_MAX|FA_NOTE,("removed middle") );
                break;
            }   
        }
    }
#ifdef DEBUG
    totalnotificationcount--;
#endif

    //
    // to indicate that this node has been removed, pNext gets set to NULL!
    //
    pnnode->pNext=NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindControlInNoteList
//
// This routine walks the linked list looking for this control.  Because all controls
// are globally allocated, all pControl addresses will be unique.  Thus, all
// we really need to do is find the control.  If an exact match is found, 
// pnnode is returned.
//
PNOTENODE
kmxlFindControlInNoteList(
    IN PMXLCONTROL pControl )
{
    PNOTENODE pnnode;
    PCONTROLLINK pcLink;

    PAGED_CODE();
    for (pnnode=firstnotenode;pnnode!=NULL;pnnode=pnnode->pNext)
    {
        //
        // Can't check entire structure because pmxd may have been cleaned out.
        //
        DPFASSERT(pnnode->dwSig == NOTIFICATION_SIGNATURE);

        for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
        {
            DPFASSERT(IsValidControlLink(pcLink));
            if( pcLink->pControl == pControl )
            {
                //
                // We found this control in the list!
                //
                return pnnode;
            }
        }
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindControlTypeInList
//
// This routine walks 
//
PMXLCONTROL
kmxlFindControlTypeInList(
    IN PNOTENODE pnnode,
    IN DWORD dwControlType )
{
    PCONTROLLINK pcLink;

    PAGED_CODE();

    for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
    {
        DPFASSERT(IsValidControlLink(pcLink));
        if( pcLink->pControl->Control.dwControlType == dwControlType )
        {
            //
            // We found this control in the list!  Types match.
            //
            DPF(DL_TRACE|FA_NOTE,("Found Correct pControl %08X",pcLink->pControl) );
            return pcLink->pControl;
        }
    }

    return NULL;
}


#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindAddressInNoteList
//
// This routine walks the linked list looking for this control within this
// context.  If an exact match is found, pnnode is returned.
//
VOID
kmxlFindAddressInNoteList(
    IN PMXLCONTROL pControl 
    )
{
    PNOTENODE pnnode;
    PCONTROLLINK pcLink;

    PAGED_CODE();
    for (pnnode=firstnotenode;pnnode!=NULL;pnnode=pnnode->pNext)
    {
        DPFASSERT(pnnode->dwSig == NOTIFICATION_SIGNATURE);
        //
        // Let's look to see if this address is one of our pControls!
        //
        for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
        {
            DPFASSERT(pcLink->dwSig == CONTROLLINK_SIGNATURE);
            if( pcLink->pControl == pControl )
            {
                //
                // We found this control in the list - in the right context!
                //
                DPF(DL_ERROR|FA_NOTE,("Found pControl(%08X) in our list!",pControl) );
                return ;
            }
        }
    }
    return ;
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindNodeInNoteList
//
// Walks the node list looking for this node.  This must be called within the
// mtxMutex.
//
NTSTATUS
kmxlFindNodeInNoteList(
    IN PNOTENODE pnlookupnode )
{
    PNOTENODE pnnode;

    PAGED_CODE();
    for (pnnode=firstnotenode;pnnode!=NULL;pnnode=pnnode->pNext)
    {
        if( pnnode == pnlookupnode )
        {    
            //
            // Only if we find what we're looking for do we actually verify
            // that it's still good.
            //
            DPFASSERT(IsValidNoteNode(pnnode));
            //
            // we found this control in the list
            //
            return STATUS_SUCCESS;
        }   
    }
    return STATUS_UNSUCCESSFUL;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindIdInContextInNoteList
//
// Walks the notification list looking for the node that contains this id in
// this context.
//
PNOTENODE
kmxlFindIdInContextInNoteList(
    IN PWDMACONTEXT pWdmaContext,
    IN PMIXERDEVICE pmxd,
    IN DWORD NodeId
)
{
    PNOTENODE pnTmp;

    PAGED_CODE();
    for (pnTmp=firstnotenode;pnTmp!=NULL;pnTmp=pnTmp->pNext)
    {
        DPFASSERT(IsValidNoteNode(pnTmp));

        if(( pnTmp->NodeId == NodeId ) &&
           ( pnTmp->pmxd == pmxd ) &&
           ( pnTmp->pContext == pWdmaContext ) )
        {    
            //
            // we found this control in the list in this context.
            //
            return pnTmp;
        }   
    }
    //
    // We have walked the list.  There is no control with this ID in this Context.
    //
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlFindContextInNoteList
//
PNOTENODE
kmxlFindContextInNoteList(
    IN PWDMACONTEXT pWdmaContext
    )
{
    PNOTENODE pnTmp;

    PAGED_CODE();
    for (pnTmp=firstnotenode;pnTmp!=NULL;pnTmp=pnTmp->pNext)
    {
        DPFASSERT(IsValidNoteNode(pnTmp));

        if( pnTmp->pContext == pWdmaContext )
        {    
            //
            // Found this context in our list.
            //
            DPFBTRAP();
            return pnTmp;
        }   
    }
    //
    // We have walked the list.  There is no control with this ID in this Context.
    //

    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlAddControlToNoteList
//
// Adds this pControl to pcLink list.
//
NTSTATUS
kmxlAddControlToNoteList(
    IN OUT PNOTENODE   pnnode,
    IN     PMXLCONTROL pControl
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    PCONTROLLINK pcLink = NULL;

    PAGED_CODE();
#ifdef DEBUG
    //
    // Let's walk the list and make double sure that this node is not already in
    // the list.
    //
    for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
    {
        if( pcLink->pControl == pControl )
        {
            DPF(DL_ERROR|FA_NOTE,("pControl(%08X) already in list!") );
            return STATUS_UNSUCCESSFUL;
        }
    }
#endif

    Status = AudioAllocateMemory_Fixed(sizeof( CONTROLLINK ),
                                       TAG_AuDL_LINK,
                                       ZERO_FILL_MEMORY,
                                       &pcLink );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_ERROR|FA_NOTE,("Wasn't able to add control to list! Status=%08X",Status) );
        return Status;
    }

#ifdef DEBUG
    pcLink->dwSig=CONTROLLINK_SIGNATURE;
#endif
    pcLink->pControl=pControl;
    //
    // Make new head.
    //
//    if( pnnode->pcLink != NULL )
//        _asm int 3
    pcLink->pNext=pnnode->pcLink;
    pnnode->pcLink=pcLink;
    DPF(DL_TRACE|FA_NOTE,("Added pControl %d to pnnode(%08X)",pControl->Control.dwControlID,pnnode) );
    return Status;
}


PCONTROLLINK
kmxlRemoveControlFromNoteList(
    IN OUT PNOTENODE   pnnode,
    IN     PMXLCONTROL pControl
    )
{
    PCONTROLLINK pcLink,pcTmp;

    PAGED_CODE();

    //
    // Does the first node contain our pControl?
    //
    DPFASSERT(IsValidControlLink(pnnode->pcLink));

    for(pcLink=pnnode->pcLink;pcLink!=NULL;pcLink=pcLink->pNext)
    {
        if( pcLink->pControl == pControl )
            break;
    }

    if( pcLink == pnnode->pcLink )
    {
        pnnode->pcLink = pcLink->pNext;
        DPF(DL_TRACE|FA_NOTE,("removed head pControlLink") );
    } else {
        for( pcTmp=pnnode->pcLink;pcTmp!=NULL;pcTmp=pcTmp->pNext)
        {
            if( pcTmp->pNext == pcLink )
            {
                pcTmp->pNext = pcLink->pNext;
                DPF(DL_TRACE|FA_NOTE,("Removed Middle pControlLink") );
                break;
            }
        }
    }
//    DPFASSERT(IsValidNoteNode(pnnode));

    return pcLink;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlQueryControlChange
//
// Query's to see if control change notifications are supported on this 
// control.
//
NTSTATUS
kmxlQueryControlChange(
    IN PFILE_OBJECT pfo,    // Handle of the topology driver instance
    IN ULONG NodeId        //PMXLCONTROL pControl
    )
{
    NTSTATUS        Status;

    KSE_NODE        KsNodeEvent;
    ULONG           BytesReturned;

    PAGED_CODE();
    // initialize event for basic support query
    RtlZeroMemory(&KsNodeEvent,sizeof(KSE_NODE));
    KsNodeEvent.Event.Set = KSEVENTSETID_AudioControlChange;
    KsNodeEvent.Event.Id = KSEVENT_CONTROL_CHANGE;
    KsNodeEvent.Event.Flags = KSEVENT_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
    KsNodeEvent.NodeId = NodeId;

    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_ENABLE_EVENT") );

    Status = KsSynchronousIoControlDevice(
        pfo,                    // The FILE_OBJECT for SysAudio
        KernelMode,             // Call originates in Kernel mode
        IOCTL_KS_ENABLE_EVENT,  // KS PROPERTY IOCTL
        &KsNodeEvent,           // Pointer to the KSNODEPROPERTY struct
        sizeof(KSE_NODE),        // Number or bytes input
        NULL,                   // Pointer to the buffer to store output
        0,                      // Size of the output buffer
        &BytesReturned          // Number of bytes returned from the call
        );

    if (!NT_SUCCESS(Status)) {
        DPF( DL_MAX|FA_HARDWAREEVENT, ("NODE #%d:  KSEVENT_CONTROL_CHANGE Not Supported Error %08X",NodeId,Status) );
        RETURN( Status );
    }

    DPF(DL_TRACE|FA_HARDWAREEVENT ,("NodeId #%d: KSEVENT_CONTROL_CHANGE Supported",NodeId) );

    return Status;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlEnableControlChange
//
// Turns on Control chnage notifications on this control.
//
NTSTATUS
kmxlEnableControlChange(
    IN     PFILE_OBJECT pfo,    // Handle of the topology driver instance
    IN     ULONG NodeId,        //PMXLCONTROL pControl,
    IN OUT PKSEVENTDATA pksed
    )
{
    NTSTATUS        Status;
    KSE_NODE        KsNodeEvent;
    ULONG           BytesReturned;

    PAGED_CODE();
    // try to add an event
    RtlZeroMemory(&KsNodeEvent,sizeof(KSE_NODE));
    KsNodeEvent.Event.Set = KSEVENTSETID_AudioControlChange;
    KsNodeEvent.Event.Id = KSEVENT_CONTROL_CHANGE;
    KsNodeEvent.Event.Flags = KSEVENT_TYPE_ENABLE | KSPROPERTY_TYPE_TOPOLOGY;
    KsNodeEvent.NodeId = NodeId;

    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_ENABLE_EVENT") );

    Status = KsSynchronousIoControlDevice(
    pfo,                    // The FILE_OBJECT for SysAudio
    KernelMode,             // Call originates in Kernel mode
    IOCTL_KS_ENABLE_EVENT,  // KS PROPERTY IOCTL
    &KsNodeEvent,           // Pointer to the KSNODEPROPERTY struct
    sizeof(KSE_NODE),       // Number or bytes input
    pksed,                  // Pointer to the buffer to store output
    sizeof(KSEVENTDATA),    // Size of the output buffer
    &BytesReturned          // Number of bytes returned from the call
    );

    if (!NT_SUCCESS(Status)) {
        DPF(DL_WARNING|FA_HARDWAREEVENT ,("KSEVENT_CONTROL_CHANGE Enable FAILED Error %08X",Status) );
        RETURN( Status );
    }

    DPF(DL_TRACE|FA_HARDWAREEVENT ,
        ("KSEVENT_CONTROL_CHANGE Enabled on NodeId #%d",NodeId) );

    return Status;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlDisableControlChange
//
// Turns off Control chnage notifications on this control.
//
NTSTATUS
kmxlDisableControlChange(
    IN     PFILE_OBJECT pfo,    // Handle of the topology driver instance
    IN     ULONG NodeId,        //PMXLCONTROL pControl,
    IN OUT PKSEVENTDATA pksed
    )
{
    NTSTATUS        Status;
    KSE_NODE        KsNodeEvent;
    ULONG           BytesReturned;

    PAGED_CODE();
    // initialize event for basic support query
    RtlZeroMemory(&KsNodeEvent,sizeof(KSE_NODE));
    KsNodeEvent.Event.Set = KSEVENTSETID_AudioControlChange;
    KsNodeEvent.Event.Id = KSEVENT_CONTROL_CHANGE;
    KsNodeEvent.Event.Flags = KSEVENT_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
    KsNodeEvent.NodeId = NodeId;


    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_DISABLE_EVENT") );

    Status = KsSynchronousIoControlDevice(
              pfo,                    // The FILE_OBJECT for SysAudio
              KernelMode,             // Call originates in Kernel mode
              IOCTL_KS_DISABLE_EVENT, // KS PROPERTY IOCTL
              pksed,                  // Pointer to the buffer to store output
              sizeof(KSEVENTDATA),    // Size of the output buffer
              NULL,                   // Pointer to the KSNODEPROPERTY struct
              0,                      // Number or bytes input
              &BytesReturned          // Number of bytes returned from the call
             );

    if (!NT_SUCCESS(Status)) {
       DPF(DL_WARNING|FA_HARDWAREEVENT,("KSEVENT_CONTROL_CHANGE Disable FAILED") );
       RETURN( Status );
    }

    DPF(DL_TRACE|FA_HARDWAREEVENT, 
        ("KSEVENT_CONTROL_CHANGE disabled on NodeId #%d",NodeId) );

    return Status;
}


VOID
kmxlGrabNoteMutex(
    )
{
    //
    // Turn off the APCDisable flag in the thread structure before going for our
    // mutex.  This will prevent us from getting suspeneded while holding this
    // mutex.
    //
    KeEnterCriticalRegion();
    KeWaitForMutexObject(&mtxNote, Executive, KernelMode, FALSE, NULL);
}

VOID
kmxlReleaseNoteMutex(
    )
{
    KeReleaseMutex(&mtxNote, FALSE);
    KeLeaveCriticalRegion();
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlEnableControlChangeNotifications
//
// This routine gets called every time a new control is created.  At that point
// we're going to query the node to see if it supports change notifications
// and enable them in this context.
//
NTSTATUS 
kmxlEnableControlChangeNotifications(
    IN PMIXEROBJECT pmxobj,
    IN PMXLLINE     pLine,        // Line that owns control
    IN PMXLCONTROL  pControl      // Control to Enable
    )
{
    PNOTENODE pnnode;
    NTSTATUS    Status;
    LONG i;
    PMIXERDEVICE pmxd;
    PWDMACONTEXT pWdmaContext;
    
    kmxlGrabNoteMutex();

    DPFASSERT(IsValidMixerObject(pmxobj));

    pmxd=pmxobj->pMixerDevice;

    DPFASSERT(IsValidMixerDevice(pmxd));

    pWdmaContext=pmxd->pWdmaContext;

    PAGED_CODE();

    //
    // Never allow anything in the list if it's not valid!
    //
    DPFASSERT(IsValidControl(pControl));

    //
    // The first thing we do is look to see if a control of this ID is enabled in
    // this context.  If so, we'll get a PNOTENODE structure returned to us that
    // contains that ID.  All we should have to do is add our new pControl.
    //
    if( pnnode=kmxlFindIdInContextInNoteList(pWdmaContext,pmxd,pControl->Id) ) // Not pControl->Control.dwControlID
    {
        //
        // yes there is.  Add this pControl to this pnnode and we're done.
        //
        Status=kmxlAddControlToNoteList(pnnode,pControl);

    } else {
        //
        // There is no Control with this ID in this Context.  Let's try to 
        // Add one.
        //
        //
        // This node is not in our list, we need to add it if and only if it
        // supports change notifications
        //
        Status=kmxlQueryControlChange(pmxd->pfo,pControl->Id); //pLocfo
        if( NT_SUCCESS(Status) )
        {
            //
            // This control supports notifications, thus add info to our
            // global list - if it's not already there...
            //
            if( (pnnode=kmxlNewNoteNode()) != NULL )
            {
                if( (pnnode->pcLink=kmxlNewControlLink(pControl)) != NULL )
                {
                    pnnode->NodeId=pControl->Id;
                    //
                    // We have a new notification node to fill out.
                    //
                    pnnode->ControlID=pControl->Control.dwControlID;
                    pnnode->ControlType=pControl->Control.dwControlType;
                    pnnode->LineID=pLine->Line.dwLineID;

                    pnnode->pContext=pWdmaContext; //NOTENODE
                    pnnode->pmxd=pmxd;

                    DPF(DL_TRACE|FA_NOTE ,
                        ("Init pnnode, NodeId=#%d: CtrlID=%X CtrlType=%X Context=%08X",
                             pnnode->NodeId,             //pControl->Id
                             pnnode->ControlID,      //pControl->Control.dwControlID,
                             pnnode->ControlType,
                             pnnode->pContext) ); //pControl->Control.dwControlType) );
                    //
                    // Now setup the DPC handling
                    //
                    KeInitializeDpc(&pnnode->NodeEventDPC,NodeEventDPCHandler,pnnode);

                    pnnode->NodeEventData.NotificationType=KSEVENTF_DPC;
                    pnnode->NodeEventData.Dpc.Dpc=&pnnode->NodeEventDPC;

                    //
                    // At this point, we've got a little window.  We call and enable
                    // events on this control.  From that time until the time we actually
                    // add it to the list, if an event fires, we will not find this node
                    // in the list - thus we will not process it.
                    //
                    Status=kmxlEnableControlChange(pnnode->pmxd->pfo,
                                                   pnnode->NodeId, //pControl,
                                                   &pnnode->NodeEventData);
                                               //&NodeEvent[NumEventDPCs].NodeEventData);
                    if( NT_SUCCESS(Status) )
                    {
                        DPF(DL_TRACE|FA_HARDWAREEVENT,("Enabled Control #%d in context(%08X)!",pControl->Id,pWdmaContext) );
                        //
                        // Now let's add it to our global list
                        //
                        //
                        kmxlAddNoteNodeToList(pnnode);

                        DPFASSERT(IsValidNoteNode(pnnode));
                    } else {
                        DPF(DL_WARNING|FA_HARDWAREEVENT,("Failed to Enable Control #%d!",pControl->Id) );
                        DPFBTRAP();
                        //
                        // For some reason, this node failed to enable.
                        //
                        kmxlFreeControlLink(pnnode->pcLink);
                        kmxlFreeNoteNode(pnnode);
                    }

                } else {
                    DPF(DL_ERROR|FA_NOTE,("kmxlNewControlLink failed") );
                    kmxlFreeNoteNode(pnnode);
                }
            } else {
                DPF(DL_WARNING|FA_NOTE,("kmxlNewNoteNode failed") );
            }
        } else {
            DPF(DL_MAX|FA_HARDWAREEVENT,("This control #%d doesn't support change notifications",pControl->Id) );
        }
    }    

    kmxlReleaseNoteMutex();

    return Status;
}


/////////////////////////////////////////////////////////////////////////////
//
// kmxlDisableControlChangeNotifications
//
// This routine gets called every time a control is freed.  We walk the list
// of enable controls and see if it's there.  If so, we disable and clean up.
// if it's not in the list, it didn't support change notifications.
//

NTSTATUS
kmxlDisableControlChangeNotifications(
    IN PMXLCONTROL pControl
    )
{
    NTSTATUS Status=STATUS_SUCCESS;
    PNOTENODE pnnode;

    PAGED_CODE();

    kmxlGrabNoteMutex();

    DPFASSERT(IsValidControl(pControl));

    //
    // Find this control in our list.
    //
    if(pnnode=kmxlFindControlInNoteList(pControl))  //pWdmaContext,
    {
        PCONTROLLINK pcLink;

#ifdef DEBUG
        if( pControl->Id != pnnode->NodeId )
        {
            DPF(DL_ERROR|FA_NOTE,("Control NodeId Changed! CtrlId=%08X,pnnodeID=%08X",
                                  pControl->Id,pnnode->NodeId) );
        }

#endif
        //
        // This call removes pControl from this node.  note that after this 
        // control is removed, pnnode->pcLink will be NULL if there are no
        // more controls hanging on this Notification node.  Thus, we need
        // to disable it.
        //
        pcLink=kmxlRemoveControlFromNoteList(pnnode,pControl);
        if( pnnode->pcLink == NULL )
        {
            //
            // During cleanup, the mixer device structure will have already been
            // cleaned up.  This can be seen because the pmxd->Device entry will
            // be UNUSED_DEVICE.  Thus, we can't do anything on that mixerdevice.
            //
            if( ( pnnode->pmxd->Device != UNUSED_DEVICE ) && 
                ( pnnode->pmxd->pfo != NULL ) )
            {
                //
                // There are no references to this node, we can free it. But, if
                // this disable call fails, then the node was already distroyed.
                //
                Status=kmxlDisableControlChange(pnnode->pmxd->pfo,pnnode->NodeId,&pnnode->NodeEventData);
                if( !NT_SUCCESS(Status) )
                {
                    DPF(DL_WARNING|FA_NOTE,("Not able to disable! pnnode %08X",pnnode) );
                }

            } else {
                DPF(DL_WARNING|FA_NOTE,("pmxd is invalid %08X",pnnode->pmxd) );
            }
            kmxlRemoveNoteNodeFromList(pnnode);

            kmxlFreeNoteNode(pnnode);
        } 

        DPF(DL_TRACE|FA_NOTE,("Removed PCONTROLLINK(%08X) for pControl(%08X)",pcLink,pcLink->pControl) );

        kmxlFreeControlLink(pcLink);

    } else {
        //
        // We get called on every control free.  Thus, many will not be in our list.
        //
        DPF(DL_MAX|FA_NOTE,("Control=%d not in List!",pControl->Id) );
    }

    kmxlReleaseNoteMutex();
    return Status;
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlRemoveContextFromNoteList
//
// This routine gets called when this context is going away.  Thus, we need to
// remove it from our list.
//
VOID
kmxlRemoveContextFromNoteList(
    IN PWDMACONTEXT pContext
    )
{
    NTSTATUS Status;
    PNOTENODE pnnode;
    PCONTROLLINK pcLink;

    PAGED_CODE();

    kmxlGrabNoteMutex();

    //
    // If we find this context is still alive in our list, someone leaked a control.
    // Things should have been cleaned up when the controls went away!  But, for 
    // some reasons they didn't.
    //
    // There could be multiple pContext nodes in list.
    //
    while( (pnnode=kmxlFindContextInNoteList(pContext)) != NULL )
    {
        DPFASSERT(IsValidNoteNode(pnnode));
        DPF(DL_ERROR|FA_NOTE,("pContext(%08X) found in Notification List!",pContext) );

        kmxlRemoveNoteNodeFromList(pnnode);
        //
        // There can be multiple Controls on this Notification node.
        //
        while( (pnnode->pcLink != NULL) && 
               ( (pcLink=kmxlRemoveControlFromNoteList(pnnode,pnnode->pcLink->pControl)) != NULL) )
        {
            //
            // To get here, pcLink is Valid.  If it was the last pControl, then
            // we want to turn off change notifications on it.
            //
            if( pnnode->pcLink == NULL )
            {
                //
                // There are no references to this node, we can free it.
                //
                Status=kmxlDisableControlChange(pnnode->pmxd->pfo,pnnode->NodeId,&pnnode->NodeEventData);
                DPFASSERT( Status == STATUS_SUCCESS );
                DPFBTRAP();
            } 
            kmxlFreeControlLink(pcLink);
            DPFBTRAP();
        }
        kmxlFreeNoteNode(pnnode);
        DPFBTRAP();
    } 

    DPF(DL_TRACE|FA_NOTE,("pWdmaContext %08X going away",pContext) );

    kmxlReleaseNoteMutex();
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlCleanupNotelist
//
// Driver is unloading, turn everything off and free the memory!
//
VOID
kmxlCleanupNoteList(
    )
{
    NTSTATUS Status;
    PNOTENODE pnnode,pnnodeFree;
    PCONTROLLINK pcLink;

    PAGED_CODE();

    kmxlGrabNoteMutex();

    //
    // If we find this context is still alive in our list, someone leaked a control.
    // Things should have been cleaned up when the controls went away!  But, for 
    // some reasons they didn't.
    //
    // There could be multiple pContext nodes in list.
    //
    pnnode=firstnotenode;
    while( pnnode )
    {
        DPFASSERT(IsValidNoteNode(pnnode));
        DPF(DL_ERROR|FA_NOTE,("pnnode(%08X) found in Notification List!",pnnode) );

        kmxlRemoveNoteNodeFromList(pnnode);
        //
        // There can be multiple Controls on this Notification node.
        //
        while( (pnnode->pcLink != NULL) && 
               ( (pcLink=kmxlRemoveControlFromNoteList(pnnode,pnnode->pcLink->pControl)) != NULL) )
        {
            //
            // To get here, pcLink is Valid.  If it was the last pControl, then
            // we want to turn off change notifications on it.
            //
            if( pnnode->pcLink == NULL )
            {
                //
                // There are no references to this node, we can free it.
                //
                Status=kmxlDisableControlChange(pnnode->pmxd->pfo,pnnode->NodeId,&pnnode->NodeEventData);
                DPFASSERT( Status == STATUS_SUCCESS );
                DPFBTRAP();
            } 
            kmxlFreeControlLink(pcLink);
            DPFBTRAP();
        }
        pnnodeFree=pnnode;
        pnnode=pnnode->pNext;
        kmxlFreeNoteNode(pnnodeFree);
        DPFBTRAP();
    } 

    DPF(DL_TRACE|FA_NOTE,("Done with cleanup") );

    kmxlReleaseNoteMutex();
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlPersistHWControlWorker
//
// When kmxlPersistHWControlWorker gets called, the pData value is a pointer
// to a globally allocated NOTENODE structure.  Thus, we have all the context
// we need with regard to persisting the control.  We just need to make sure
// that our node didn't go away between the time the evern was scheduled and
// when we got called.
//
VOID 
kmxlPersistHWControlWorker(
    PVOID pReference
    )
{
    NTSTATUS  Status;
    PMXLCONTROL pControl;
    PVOID     paDetails = NULL; // kmxlPersistSingleControl() allocates paDetails
                                // via kmxlGetCurrentControlValue()
    PNOTENODE pnnode;
    PHWLINK phwlink;

    PLIST_ENTRY ple;

    PAGED_CODE();
    //
    // We set HardwareCallbackSchedule to 0 here so that we can start adding new 
    // events for handling hardware notifications.  Note: we do that here at the 
    // start of the routine so that there will not be a window where we have 
    // something in the list that we never get a event scheduled for.  In other
    // words, this routine handles empty lists.
    //
    HardwareCallbackScheduled=0;
    //
    // while we have events in our queue, get one and service it.
    //
    while((ple = ExInterlockedRemoveHeadList(&HardwareCallbackListHead,
                                             &HardwareCallbackSpinLock)) != NULL) 
    {
        phwlink = CONTAINING_RECORD(ple, HWLINK, Next);

        DPFASSERT(phwlink->dwSig == HWLINK_SIGNATURE);

        //
        // Get our data for this event and then free the link that was allocated in
        // the DPC handler.
        //
        pnnode=phwlink->pnnode;
        AudioFreeMemory(sizeof(HWLINK),&phwlink);

        //
        // We are going to be working in this context for a while.  Thus, we're going
        // to enter our mtxNote mutex to make sure that our node doesn't go away
        // while we're persisting the values!
        //
        kmxlGrabNoteMutex();

        //
        // Now our list can't chnage!  Is this node still valid?  If we don't find
        // it in the list, it was removed before this event fired.  Thus, there is
        // nothing that we can do.  ---  Free mutex and leave.
        //
        Status=kmxlFindNodeInNoteList(pnnode);
        if( NT_SUCCESS(Status) )
        {
            DPF( DL_TRACE|FA_HARDWAREEVENT ,
                 ("Entering NodeId %d LineID %X  ControlID %d ControlType = %X",
                  pnnode->NodeId, pnnode->LineID, pnnode->ControlID, pnnode->ControlType) );

            //
            // Yes.  It's still valid.  Persist the control.
            //
            pControl=kmxlFindControlTypeInList(pnnode,pnnode->ControlType);
            if( pControl )
            {
                Status = kmxlPersistSingleControl(
                            pnnode->pmxd->pfo,
                            pnnode->pmxd,
                            pControl,  // pControl here...
                            paDetails
                            );
            }
            if( !NT_SUCCESS(Status) )
            {
                //
                // On shutdown, we might get an event that fires after things have 
                // been cleaned up.
                //
                if( Status != STATUS_TOO_LATE )
                {
                    DPF(DL_WARNING|FA_NOTE, ("Failure from kmxlPersistSingleControl Status=%X",Status) );
                }
            }
            else {
                DPF(DL_TRACE|FA_HARDWAREEVENT ,("Done - success") );
            }

        } else {
            DPF(DL_WARNING|FA_NOTE,("pnnode=%08X has been removed!",pnnode) );
        }

        //
        // Persist this control!
        //

        kmxlReleaseNoteMutex();

    }

    DPF(DL_TRACE|FA_HARDWAREEVENT ,("exit") );
}

/////////////////////////////////////////////////////////////////////////////
//
// kmxlGetLineForControl
//
// For every line on this mixer device, look at every control to see if we
// can find this control.  If found, return this line pointer.
//
NTSTATUS
kmxlEnableAllControls(
    IN PMIXEROBJECT pmxobj
    )
{
    NTSTATUS        Status=STATUS_SUCCESS;
    PMIXERDEVICE    pmxd;
    PMXLLINE        pLine;
    PMXLCONTROL     pControl;

    PAGED_CODE();

    //
    // The first time through we will most likily not have a pfo in the MIXERDEVICE
    // structure, thus fill it in!
    //
    DPFASSERT(pmxobj->dwSig == MIXEROBJECT_SIGNATURE );
    DPFASSERT(pmxobj->pMixerDevice != NULL );
    DPFASSERT(pmxobj->pMixerDevice->dwSig == MIXERDEVICE_SIGNATURE );

    pmxd=pmxobj->pMixerDevice;

    if( pmxd->pfo == NULL )
    {
        DPF(DL_WARNING|FA_NOTE,("fo is NULL, it should have been set!") );
        //
        // We need to assign a SysAudio FILE_OBJECT to this mixer device so that
        // we can talk to it.
        //
        if( NULL==(pmxd->pfo=kmxlOpenSysAudio())) {
            DPF(DL_WARNING|FA_NOTE,("OpenSysAudio failed") );
            return STATUS_UNSUCCESSFUL;
        }

        Status = SetSysAudioProperty(
            pmxd->pfo,
            KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
            sizeof( pmxd->Device ),
            &pmxd->Device
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlCloseSysAudio( pmxd->pfo );
            pmxd->pfo=NULL;
            DPF(DL_WARNING|FA_NOTE,("SetSysAudioProperty failed %X",Status) );
            return Status;
        }
    }

    DPFASSERT(IsValidMixerObject(pmxobj));

    for(pLine = kmxlFirstInList( pmxd->listLines );
        pLine != NULL;
        pLine = kmxlNextLine( pLine )
        )
    {
        DPFASSERT(IsValidLine(pLine));
        for(pControl = kmxlFirstInList( pLine->Controls );
            pControl != NULL;
            pControl = kmxlNextControl( pControl )
                )
        {
            DPFASSERT(IsValidControl(pControl));

            //
            // Enable Notifications if it supports it here.
            //
            DPF(DL_TRACE|FA_NOTE,("pControl->Id=%d, pControl->Control.dwControlID=%d",
                                  pControl->Id,pControl->Control.dwControlID) );

            Status = kmxlEnableControlChangeNotifications(pmxobj,pLine,pControl);

        }
    }
    return Status;
}

VOID 
kmxlCloseMixerDevice(
    IN OUT PMIXERDEVICE pmxd
    )
{
    if(pmxd->pfo)
    {
        kmxlCloseSysAudio( pmxd->pfo );
        pmxd->pfo = NULL;
    }
}





/////////////////////////////////////////////////////////////////////////////
//
// GetHardwareEventData
//
// Called by user mode driver to get the notification information.
//
VOID GetHardwareEventData(LPDEVICEINFO pDeviceInfo)
{
    PAGED_CODE();
    if (emptyindex!=loadindex) {
        (pDeviceInfo->dwID)[0]=callbacks[emptyindex%CALLBACKARRAYSIZE].dwControlID;
        pDeviceInfo->dwLineID=callbacks[emptyindex%CALLBACKARRAYSIZE].dwLineID;
        pDeviceInfo->dwCallbackType=callbacks[emptyindex%CALLBACKARRAYSIZE].dwCallbackType;
        pDeviceInfo->ControlCallbackCount=1;
        emptyindex++;
    }

    pDeviceInfo->mmr=MMSYSERR_NOERROR;

}



///////////////////////////////////////////////////////////////////////
//
// kmxdInit
//
// Checks to see if the mixer lines have been built for the given
// index.  If not, it calls kmxlBuildLines() to build up the lines.
//
// The topology information is kept around so that it can be dumped
// via a debugger command.
//
//

NTSTATUS
kmxlInit(
    IN PFILE_OBJECT pfo,    // Handle of the topology driver instance
    IN PMIXERDEVICE pMixer
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hKey;
    ULONG ResultLength;

    PAGED_CODE();
    //
    // Check to see if the lines have already been built for this device.
    // If so, return success.
    //

    if( pMixer->listLines ) {
        RETURN( STATUS_SUCCESS );
    }

    //
    // Build the lines for this device.
    //

    Status = kmxlBuildLines(
        pMixer,
        pfo,
        &pMixer->listLines,
        &pMixer->cDestinations,
        &pMixer->Topology
        );

    if( NT_SUCCESS( Status ) ) {

        Status = kmxlOpenInterfaceKey( pfo, pMixer->Device, &hKey );
        if( !NT_SUCCESS( Status ) ) {
            pMixer->Mapping = MIXER_MAPPING_LOGRITHMIC;
            Status = STATUS_SUCCESS;
            goto exit;
        }

        Status = kmxlRegQueryValue( hKey,
            L"CurveType",
            &pMixer->Mapping,
            sizeof( pMixer->Mapping ),
            &ResultLength
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlRegCloseKey( hKey );
            pMixer->Mapping = MIXER_MAPPING_LOGRITHMIC;
            Status = STATUS_SUCCESS;
            goto exit;
        }

        kmxlRegCloseKey( hKey );
    }

exit:
    //
    // Free up the topology allocated when the lines are built (RETAIL only).
    //

#ifndef DEBUG
    if(pMixer->Topology.Categories) {
        ExFreePool(
            ( (( PKSMULTIPLE_ITEM )
            pMixer->Topology.Categories )) - 1 );
            pMixer->Topology.Categories = NULL;
    }

    if(pMixer->Topology.TopologyNodes) {
        ExFreePool(
        ( (( PKSMULTIPLE_ITEM )
            pMixer->Topology.TopologyNodes )) - 1 );
            pMixer->Topology.TopologyNodes = NULL;
    }
    if(pMixer->Topology.TopologyConnections) {
        ExFreePool(
        ( (( PKSMULTIPLE_ITEM )
            pMixer->Topology.TopologyConnections )) - 1 );
            pMixer->Topology.TopologyConnections = NULL;
    }
#endif // !DEBUG

    RETURN( Status );
}

////////////////////////////////////////////////////////////////////////
//
// kmxdDeInit
//
// Loops through each of the lines freeing the control structures and
// then the line structures.
//
//

NTSTATUS
kmxlDeInit(
    PMIXERDEVICE pMixer
)
{
    PMXLLINE    pLine       = NULL;
    PMXLCONTROL pControl = NULL;

    PAGED_CODE();

    if( pMixer->Device != UNUSED_DEVICE ) {

        while( pMixer->listLines ) {
            pLine = kmxlRemoveFirstLine( pMixer->listLines );

            while( pLine && pLine->Controls ) {
                pControl = kmxlRemoveFirstControl( pLine->Controls );
                kmxlFreeControl( pControl );
            }

            AudioFreeMemory( sizeof(MXLLINE),&pLine );
        }

        //
        // Here we need to close sysaudio as used in this mixer device.
        //
        kmxlCloseMixerDevice(pMixer);

        ASSERT( pMixer->listLines == NULL );

        //
        // Free up the topology (DEBUG only)
        //

#ifdef DEBUG
        if(pMixer->Topology.Categories) {
            ExFreePool(( (( PKSMULTIPLE_ITEM )
                           pMixer->Topology.Categories )) - 1 );
            pMixer->Topology.Categories = NULL;
        }

        if(pMixer->Topology.TopologyNodes) {
            ExFreePool(( (( PKSMULTIPLE_ITEM )
                           pMixer->Topology.TopologyNodes )) - 1 );
            pMixer->Topology.TopologyNodes = NULL;
        }
        if(pMixer->Topology.TopologyConnections) {
            ExFreePool(( (( PKSMULTIPLE_ITEM )
                           pMixer->Topology.TopologyConnections )) - 1 );
            pMixer->Topology.TopologyConnections = NULL;
        }
#endif // !DEBUG

    } // if

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildLines
//
// Builds up the line structures and count of destinations for the
// given instance.
//
//

NTSTATUS
kmxlBuildLines(
    IN     PMIXERDEVICE pMixer,         // The mixer
    IN     PFILE_OBJECT pfoInstance,    // The FILE_OBJECT of a filter instance
    IN OUT LINELIST*    plistLines,     // Pointer to the list of all lines
    IN OUT PULONG       pcDestinations, // Pointer to the number of dests
    IN OUT PKSTOPOLOGY  pTopology       // Pointer to a topology structure
)
{
    NTSTATUS   Status          = STATUS_SUCCESS;
    MIXEROBJECT mxobj;
    LINELIST   listSourceLines = NULL;
    NODELIST   listSources     = NULL;
    NODELIST   listDests       = NULL;
    PMXLNODE   pTemp           = NULL;
    ULONG      i;

    PAGED_CODE();

    ASSERT( pfoInstance    );
    ASSERT( plistLines     );
    ASSERT( pcDestinations );
    ASSERT( pTopology      );

    RtlZeroMemory( &mxobj, sizeof( MIXEROBJECT ) );

    // Set up the MIXEROBJECT.  Note that this structure is used only within
    // the scope of this function, so it is okay to simply copy the
    // DeviceInterface pointer from the MIXERDEV structure.
    mxobj.pfo       = pfoInstance;
    mxobj.pTopology = pTopology;
    mxobj.pMixerDevice = pMixer;
    mxobj.DeviceInterface = pMixer->DeviceInterface;
#ifdef DEBUG
    mxobj.dwSig = MIXEROBJECT_SIGNATURE;
#endif
    //
    // Read the topology from the device
    //
    DPF(DL_TRACE|FA_MIXER,("Querying Topology") );

    Status = kmxlQueryTopology( mxobj.pfo, mxobj.pTopology );
    if( !NT_SUCCESS( Status ) ) {
        goto exit;
    }

    //
    // Build up the node table.  The node table is the mixer line's internal
    // representation of the topology for easier processing.
    //
    DPF(DL_TRACE|FA_MIXER,("Building Node Table") );

    mxobj.pNodeTable = kmxlBuildNodeTable( mxobj.pTopology );
    if( !mxobj.pNodeTable ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DPF(DL_WARNING|FA_MIXER,("kmxlBuildNodeTable failed") );
        goto exit;
    }

    //
    // Parse the topology and build the necessary data structures
    // to walk the topology.
    //
    DPF(DL_TRACE|FA_MIXER,("Parsing Topology") );

    Status = kmxlParseTopology(
        &mxobj,
        &listSources,
        &listDests );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_MIXER,("kmxlParseTopoloty failed Status=%X",Status) );
        goto exit;
    }

    //
    // Build up a list of destination lines.
    //
    DPF(DL_TRACE|FA_MIXER,("Building Destination lines") );

    *plistLines = kmxlBuildDestinationLines(
        &mxobj,
        listDests
        );
    if( !(*plistLines) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DPF(DL_WARNING|FA_MIXER,("kmxlBuildDestinationLines failed") );
        goto exit;
    }

    //
    // Assign the line Ids and the Control Ids for the destinations.  Also,
    // fill in the number of destinations.
    //

    kmxlAssignLineAndControlIds( &mxobj, (*plistLines), DESTINATION_LIST );
    *pcDestinations = kmxlListLength( (*plistLines) );

    //
    // Build up a list of source lines
    //
    DPF(DL_TRACE|FA_MIXER,("Building Source lines") );

    listSourceLines = kmxlBuildSourceLines(
        &mxobj,
        listSources,
        listDests
        );
    if( !listSourceLines ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DPF(DL_WARNING|FA_MIXER,("kmxlBuildSourceLines failed") );
        goto exit;
    }

    //
    // Polish off the lines.  First sort them by destination so that
    // the source Ids will be assigned correctly.
    //
    DPF(DL_TRACE|FA_MIXER,("Sort By Destination") );

    kmxlSortByDestination( &listSourceLines );
    DPF(DL_TRACE|FA_MIXER,("Assign Line and Control Ids") );
    kmxlAssignLineAndControlIds( &mxobj, listSourceLines, SOURCE_LIST );

    //
    // Now assign destinations to sources and construct the line Ids for
    // the source lines.
    //
    DPF(DL_TRACE|FA_MIXER,("Assign Destinations to Sources") );

    kmxlAssignDestinationsToSources( listSourceLines, (*plistLines) );

    //
    // Update the number of sources mapping to each of the destinations.
    //
    DPF(DL_TRACE|FA_MIXER,("Update Destination Connection Count") );

    kmxlUpdateDestintationConnectionCount( listSourceLines, (*plistLines) );

    //
    // Assign the dwComponentIds for the source and destination lines.
    //
    DPF(DL_TRACE|FA_MIXER,("Assign Conponent IDs") );

    kmxlAssignComponentIds( &mxobj, listSourceLines, (*plistLines) );

    //
    // Construct a single list of lines.  Destinations will be first in
    // increasing numerical order by line id, folowed by sources in
    // increasing numerical order.
    //

    kmxlAppendListToEndOfList( (PSLIST*) plistLines, (PSLIST) listSourceLines );

    //
    // Eliminate any lines that are invalid.
    //
    DPF(DL_TRACE|FA_MIXER,("Eliminate Invalid Lines") );

    kmxlEliminateInvalidLines( plistLines );

    //
    // Update the mux line IDs to match real line IDs
    //
    DPF(DL_TRACE|FA_MIXER,("Assign Mux IDs") );

    kmxlAssignMuxIds( &mxobj, *plistLines );

    //
    // Here is where we want to Enable Change Notifications on all controls
    // that support notifications.
    //
    DPF(DL_TRACE|FA_MIXER,("Enable All Controls") );

    kmxlEnableAllControls(&mxobj);


exit:

    //
    // If we got here because of an error, clean up all the mixer lines
    //

    if( !NT_SUCCESS( Status ) ) {
        PMXLLINE    pLine;
        PMXLCONTROL pControl;

        while( (*plistLines) ) {
            pLine = kmxlRemoveFirstLine( (*plistLines) );
            while( pLine && pLine->Controls ) {
                pControl = kmxlRemoveFirstControl( pLine->Controls );
                kmxlFreeControl( pControl );
            }
            AudioFreeMemory( sizeof(MXLLINE),&pLine );
        }
    }

    //
    // Free up the mux control list.  Note that we don't want to free
    // the controls using kmxlFreeControl() because we need the special
    // mux instance data to persist.
    //

    {
        PMXLCONTROL pControl;

        while( mxobj.listMuxControls ) {
            pControl = kmxlRemoveFirstControl( mxobj.listMuxControls );
            ASSERT( pControl->pChannelStepping == NULL);
            AudioFreeMemory( sizeof(MXLCONTROL),&pControl );

        }
    }

    //
    // Free up the source and destination lists.  Both types of these lists
    // are allocated list nodes and allocated nodes.  Both need to be freed.
    // The Children and Parent lists, though, are only allocated list nodes.
    // The actual nodes are contained in the node table and will be deallocated
    // in one chunk in the next block of code.
    //

    while( listSources ) {
        pTemp = kmxlRemoveFirstNode( listSources );
        kmxlFreePeerList( pTemp->Children );
        AudioFreeMemory( sizeof(MXLNODE),&pTemp );
    }

    while( listDests ) {
        pTemp = kmxlRemoveFirstNode( listDests );
        kmxlFreePeerList( pTemp->Parents );
        AudioFreeMemory( sizeof(MXLNODE),&pTemp );
    }

    //
    // Free up the peer lists for the children and parents inside the
    // nodes of the node table.  Finally, deallocate the array of nodes.
    //

    if( mxobj.pNodeTable ) {
        for( i = 0; i < mxobj.pTopology->TopologyNodesCount; i++ ) {
            kmxlFreePeerList( mxobj.pNodeTable[ i ].Children );
            kmxlFreePeerList( mxobj.pNodeTable[ i ].Parents );
        }
        AudioFreeMemory_Unknown( &mxobj.pNodeTable );
    }


    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//               M I X E R L I N E  F U N C T I O N S                //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildDestinationLines
//
// Loops through each of the destination nodes, allocates a line
// structure for it, and calls kmxlBuildDestinationControls to
// build the controls for that line.
//
//

LINELIST
kmxlBuildDestinationLines(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST     listDests     // The list of destination nodes
)
{
    LINELIST    listDestLines = NULL;
    PMXLNODE    pDest         = NULL;
    PMXLLINE    pLine         = NULL;
    PMXLCONTROL pControl      = NULL;
    ULONG       MaxChannelsForLine;

    ASSERT( pmxobj );
    ASSERT( listDests );

    PAGED_CODE();

    //
    // Loop over all the destination node allocating a line structure
    // for each.
    //

    pDest = kmxlFirstInList( listDests );
    while( pDest ) {

        //
        // Allocate a new line structure and add it to the list of
        // destination lines.
        //
        pLine = kmxlAllocateLine( TAG_AudL_LINE );
        if( !pLine ) {
            goto exit;
        }

        kmxlAddToList( listDestLines, pLine );

        //
        // Fill in the details of the line structure.  Some fields will
        // be filled in later.
        //

        pLine->DestId             = pDest->Id;
        pLine->Type               = pDest->NodeType;
        pLine->Communication      = pDest->Communication;
        pLine->Line.cbStruct      = sizeof( MIXERLINE );
        pLine->Line.dwSource      = (DWORD) -1;
        pLine->Line.dwDestination = (DWORD) -1;

        kmxlGetPinName( pmxobj->pfo, pDest->Id, pLine );

        //
        // HACK! The ACTIVE flag should only be set when the line is active
        // but then no lines show up in SNDVOL32.  It works if the flag is
        // always set to ACTIVE for destinations.  Also, the number of channels
        // should be queried not hard coded.  WDM Audio does not provide a
        // way to easily query this.
        //

        pLine->Line.fdwLine       = MIXERLINE_LINEF_ACTIVE;
        pLine->Line.cChannels     = 1;  // should this default to 1 or 2?

        //
        // Build up a list of the controls on this destination
        //

        if( !NT_SUCCESS( kmxlBuildDestinationControls(
                            pmxobj,
                            pDest,
                            pLine
                            ) ) )
        {
            DPF(DL_WARNING|FA_MIXER,("kmxlBuildDestinationControls failed") );
            goto exit;
        }

        pDest = kmxlNextNode( pDest );
    }

    pLine = kmxlFirstInList( listDestLines );
    while( pLine ) {
        MaxChannelsForLine = 1;

        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {
            ASSERT( IsValidControl( pControl ) );
            if ( pControl->NumChannels > MaxChannelsForLine) {
                MaxChannelsForLine = pControl->NumChannels;
            }
            pControl = kmxlNextControl( pControl );
        }

        if( pLine->Controls == NULL ) {
            pLine->Line.cChannels = 1;  // should this default to 1 or 2?
        } else {
            pLine->Line.cChannels = MaxChannelsForLine;
        }

        pLine = kmxlNextLine( pLine );
    }

    return( listDestLines );

exit:

    //
    // A memory allocation failed.  Clean up the destination lines and
    // return failure.
    //

    while( listDestLines ) {
        pLine = kmxlRemoveFirstLine( listDestLines );
        while( pLine && pLine->Controls ) {
            pControl = kmxlRemoveFirstControl( pLine->Controls );
            kmxlFreeControl( pControl );
        }
        AudioFreeMemory_Unknown( &pLine );
    }

    return( NULL );

}

///////////////////////////////////////////////////////////////////////
//
// BuildDestinationControls
//
// Starts at the destination node and translates all the parent nodes
// to mixer line controls.  This process stops when the first SUM node
// is encountered, indicating the end of a destination line.
//
//

NTSTATUS
kmxlBuildDestinationControls(
    IN  PMIXEROBJECT pmxobj,
    IN  PMXLNODE     pDest,         // The destination to built controls for
    IN  PMXLLINE     pLine          // The line to add the controls to
)
{
    PPEERNODE    pTemp  = NULL;
    PMXLCONTROL  pControl;

    PAGED_CODE();

    ASSERT( pmxobj );
    ASSERT( pLine    );

    //
    // Start at the immediate parent of the node passed.
    //

    pTemp = kmxlFirstParentNode( pDest );
    while( pTemp ) {

        if( IsEqualGUID( &pTemp->pNode->NodeType, &KSNODETYPE_SUM ) ||
          ( pTemp->pNode->Type == SOURCE ) ||
      ( pTemp->pNode->Type == DESTINATION ) ) {

            //
            // We've found a SUM node.  Discontinue the loop... we've
            // found all the controls.
            //

            break;
        }

        if( IsEqualGUID( &pTemp->pNode->NodeType, &KSNODETYPE_MUX ) ) {
            if (kmxlTranslateNodeToControl( pmxobj, pTemp->pNode, &pControl )) {
                kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );
            }
            break;
        }

        if( ( kmxlParentListLength( pTemp->pNode ) > 1 ) ) {
            //
            // Found a node with multiple parents that is not a SUM node.
            // Can't handle that here so add any controls for this node
            // and discontinue the loop.
            //

            if( kmxlTranslateNodeToControl( pmxobj, pTemp->pNode, &pControl ) ) {
                kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );
            }

            break;

        }

        //
        // By going up through the parents and inserting nodes at
        // the front of the list, the list will contain the controls
        // in the right order.
        //

        if( kmxlTranslateNodeToControl( pmxobj, pTemp->pNode, &pControl ) ) {
            kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );
        }

        pTemp = kmxlFirstParentNode( pTemp->pNode );
    }

    DPF(DL_TRACE|FA_MIXER,(
        "Found %d controls on destination %d:",
        kmxlListLength( pLine->Controls ),
        pDest->Id
        ) );

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildSourceLines
//
// Loops through each of the source nodes, allocating a new line
// structure, and calling kmxlBuildPath() to build the controls
// for the line (and possibly creating new lines if there are splits
// in the topology).
//
//

LINELIST
kmxlBuildSourceLines(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST     listSources,    // The list of source nodes
    IN NODELIST     listDests       // The list of dest. nodes
)
{
    NTSTATUS     Status;
    LINELIST     listSourceLines = NULL;
    PMXLNODE     pSource         = NULL;
    PMXLLINE     pTemp           = NULL;
    PMXLCONTROL  pControl;
    ULONG        MaxChannelsForLine;

    ASSERT( pmxobj             );
    ASSERT( pmxobj->pfo        );
    ASSERT( pmxobj->pNodeTable );
    ASSERT( listSources        );
    ASSERT( listDests          );

    PAGED_CODE();

    pSource = kmxlFirstInList( listSources );
    while( pSource ) {

        //
        // Allocate a new line structure and insert it into the list of
        // source lines.
        //
        pTemp = kmxlAllocateLine( TAG_AudL_LINE );
        if( !pTemp ) {
            goto exit;
        }

        kmxlAddToEndOfList( listSourceLines, pTemp );

        //
        // Fill in the fields of the line structure.  Some fields will need
        // to be filled in later.
        //

        pTemp->SourceId            = pSource->Id;
        pTemp->Type                = pSource->NodeType;
        pTemp->Communication       = pSource->Communication;
        pTemp->Line.cbStruct       = sizeof( MIXERLINE );
        pTemp->Line.dwSource       = (DWORD) -1;
        pTemp->Line.dwDestination  = (DWORD) -1;
        pTemp->Line.fdwLine        = MIXERLINE_LINEF_SOURCE |
                                     MIXERLINE_LINEF_ACTIVE;

        kmxlGetPinName( pmxobj->pfo, pSource->Id, pTemp );

//        DPF(DL_TRACE|FA_MIXER,( "Building path for %s (%d).",
//            PinCategoryToString( &pSource->NodeType ),
//            pSource->Id
//            ) );

        //
        // Build the controls for this line and identify the destination(s)
        // it conntects to.
        //

        Status = kmxlBuildPath(
            pmxobj,
            pSource,            // The source line to build controls for
            pSource,            // The node to start with
            pTemp,              // The line structure to add to
            &listSourceLines,   // The list of all source lines
            listDests           // THe list of all destinations
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_MIXER,("kmxlBuildPath failed Status=%X",Status) );
            goto exit;
        }


        pSource = kmxlNextNode( pSource );
    } // while( pSource )

    pTemp = kmxlFirstInList( listSourceLines );
    while( pTemp ) {
        MaxChannelsForLine = 1;

        pControl = kmxlFirstInList( pTemp->Controls );
        while( pControl ) {
            ASSERT( IsValidControl( pControl ) );
            if ( pControl->NumChannels > MaxChannelsForLine) {
                MaxChannelsForLine = pControl->NumChannels;
            }
            pControl = kmxlNextControl( pControl );
        }

        if( pTemp->Controls == NULL ) {
            pTemp->Line.cChannels = 1;  // should this default to 1 or 2?
        } else {
            pTemp->Line.cChannels = MaxChannelsForLine;
        }

        pTemp = kmxlNextLine( pTemp );
    }

    return( listSourceLines );

exit:

    //
    // Something went wrong.  Clean up all memory allocated and return NULL
    // to indicate the error.
    //

    while( listSourceLines ) {
        pTemp = kmxlRemoveFirstLine( listSourceLines );
        while( pTemp && pTemp->Controls ) {
            pControl = kmxlRemoveFirstControl( pTemp->Controls );
            kmxlFreeControl( pControl );
        }
        AudioFreeMemory_Unknown( &pTemp );
    }

    return( NULL );

}

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildPath
//
// Builds the controls for a source line.  A source line ends when a
// SUM node, a destination node, a node contained in a destination line
// is encountered.  When splits are encountered in the topology, new
// lines need to be created and the controls on those lines enumerated.
//
// kmxlBuildPath will recurse to find the controls on subnodes.
//
//

NTSTATUS
kmxlBuildPath(
    IN     PMIXEROBJECT pmxobj,
    IN     PMXLNODE     pSource,      // The source node for this path
    IN     PMXLNODE     pNode,        // The current node in the path
    IN     PMXLLINE     pLine,        // The current line
    IN OUT LINELIST*    plistLines,   // The list of lines build so far
    IN     NODELIST     listDests     // The list of the destinations
)
{
    NTSTATUS    Status;
    PMXLCONTROL pControl  = NULL;
    PMXLLINE    pNewLine  = NULL;
    ULONG       nControls;
    PPEERNODE   pChild    = NULL;

    ASSERT( pmxobj      );
    ASSERT( pSource     );
    ASSERT( pNode       );
    ASSERT( pLine       );
    ASSERT( plistLines  );

    PAGED_CODE();

    DPF(DL_TRACE|FA_MIXER,( "Building path for %d(0x%x) (%s) NODE=%08x",
        pNode->Id,pNode->Id,
        NodeTypeToString( &pNode->NodeType ),
        pNode ) );

    //
    // Check to see if this is the end of this line.
    //


    if( ( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_SUM   ) ) ||
        ( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUX   ) ) ||
        ( pNode->Type == DESTINATION                       )   ||
        ( kmxlIsDestinationNode( listDests, pNode )        ) )
    {

        //
        // Find the destination node and update the line structure.
        // If this IS the destination node, then set the ID in the line
        // structure and return.  There is no need to check the children,
        // since there won't be any.
        //

        if( pNode->Type == DESTINATION ) {
            pLine->DestId = pNode->Id;
            RETURN( STATUS_SUCCESS );
        }

        //
        // Find the destination node for the source.  It is possible to
        // have branches in the topology, so this may recurse.
        //

        pLine->DestId = kmxlFindDestinationForNode(
            pmxobj,
            pNode,
            pNode,
            pLine,
            plistLines
            );

        RETURN( STATUS_SUCCESS );
    }

    //
    // Retrieve and translate the node for the first child, appending any
    // controls created onto the list of controls for this line.
    //

    pChild = kmxlFirstChildNode( pNode );
    if( pChild == NULL ) {
        RETURN( STATUS_SUCCESS );
    }

    //
    // Save the number of controls here.  If a split occurs beneath this
    // node, we don't want to include children followed on the first
    // child's path.
    //

    nControls = kmxlListLength( pLine->Controls );

    if (kmxlTranslateNodeToControl(pmxobj, pChild->pNode, &pControl) ) {

        if( pControl && IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUX ) ) {
            if( kmxlIsDestinationNode( listDests, pChild->pNode ) ) {
                pControl->Parameters.bPlaceholder = TRUE;
            }
        }
        kmxlAppendListToEndOfList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );
    }

    //
    // Recurse to build the controls for this child.
    //

    Status = kmxlBuildPath(
            pmxobj,
            pSource,
            pChild->pNode,
            pLine,
            plistLines,
            listDests
            );

    if( !NT_SUCCESS( Status ) ) {
        RETURN( Status );
    }

    //
    // For the rest of the children
    //
    //   Create a new line based on pSource.
    //   Duplicate the list of controls in pLine.
    //   Recurse over the child node.
    //

    pChild = kmxlNextPeerNode( pChild );
    while( pChild ) {
        pNewLine = kmxlAllocateLine( TAG_AudL_LINE );
        if( pNewLine == NULL ) {
            RETURN( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        // Insert this new node into the list of source lines
        //

        RtlCopyMemory( pNewLine, pLine, sizeof( MXLLINE ) );
        pNewLine->List.Next = NULL;
        pNewLine->Controls  = NULL;

        kmxlAddToEndOfList( *plistLines, pNewLine );

        //
        // Since this is a new line, the control structures also need to be
        // duplicated.
        //

        Status = kmxlDuplicateLineControls( pNewLine, pLine, nControls );
        if( !NT_SUCCESS( Status ) ) {
            RETURN( Status );
        }

        //
        // Just as for the first child, translate the node, append the
        // controls to the list of controls for this list, and recurse
        // to build the controls for its children.
        //

        if (kmxlTranslateNodeToControl(
            pmxobj,
            pChild->pNode,
            &pControl ) ) {

            kmxlAppendListToEndOfList( (PSLIST*) &pNewLine->Controls, (PSLIST) pControl );
        }

        Status = kmxlBuildPath(
            pmxobj,
            pSource,
            pChild->pNode,
            pNewLine,
            plistLines,
            listDests
            );
        if( !NT_SUCCESS( Status ) ) {
            RETURN( Status );
        }

        pChild = kmxlNextPeerNode( pChild );
    } // while( pChild )


    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlIsDestinationNode
//
// Searches all the list of controls on the given list of destinations
// to see if the node appears in any of those lists.
//
//

BOOL
kmxlIsDestinationNode(
    IN NODELIST listDests,              // The list of destinations
    IN PMXLNODE pNode                   // The node to check
)
{
    PMXLNODE  pTemp;
    PPEERNODE pParent;

    PAGED_CODE();
    if( pNode->Type == SOURCE ) {
        return( FALSE );
    }

    if( pNode->Type == DESTINATION ) {
        return( TRUE );
    }

    ASSERT(pNode->Type == NODE);

    //
    // Loop over each of the destinations
    //

    pTemp = kmxlFirstInList( listDests );
    while( pTemp ) {

        //
        // Loop over the parent.
        //

        pParent = kmxlFirstParentNode( pTemp );
        while( pParent ) {

            if( ( pParent->pNode->Type == NODE   ) &&
                ( pParent->pNode->Id == pNode->Id) ) {

                return( TRUE );
            }

            if( ( IsEqualGUID( &pParent->pNode->NodeType, &KSNODETYPE_SUM   ) ) ||
                ( IsEqualGUID( &pParent->pNode->NodeType, &KSNODETYPE_MUX   ) ) ||
                ( pParent->pNode->Type == SOURCE                            ) )
            {
                break;
            }

            //
            // Check for the node Ids matching.
            //

            pParent = kmxlFirstParentNode( pParent->pNode );
        }

        pTemp = kmxlNextNode( pTemp );
    }

    return( FALSE );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlDuplicateLine
//
// Duplicates a line and the associated controls.
//
//

NTSTATUS
kmxlDuplicateLine(
    IN PMXLLINE* ppTargetLine,          // Pointer to the new line
    IN PMXLLINE  pSourceLine            // The line to duplicate
)
{
    PAGED_CODE();

    ASSERT( ppTargetLine );
    ASSERT( pSourceLine  );

    DPF(DL_TRACE|FA_MIXER,( "Duplicated line with source=%d.",
            pSourceLine->SourceId ) );

    //
    // Allocate a new line structure and copy the information from the
    // source line.
    //
    *ppTargetLine = kmxlAllocateLine( TAG_AudL_LINE );
    if( *ppTargetLine == NULL ) {
        RETURN( STATUS_INSUFFICIENT_RESOURCES );
    }

    ASSERT( *ppTargetLine );

//    DPF(DL_TRACE|FA_MIXER,( "Duplicated %s (%d).",
//        PinCategoryToString( &pSourceLine->Type ),
//        pSourceLine->SourceId
//        ) );

    RtlCopyMemory( *ppTargetLine, pSourceLine, sizeof( MXLLINE ) );

    //
    // Null out the controls and next pointer.  This line does not have
    // either of its own yet.
    //

    (*ppTargetLine)->List.Next = NULL;
    (*ppTargetLine)->Controls = NULL;

    //
    // Duplicate all the controls for the source line.
    //

    return( kmxlDuplicateLineControls(
        *ppTargetLine,
        pSourceLine,
        kmxlListLength( pSourceLine->Controls )
        )
    );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlDuplicateLineControls
//
// Duplicates the controls for a line by allocating a new control
// structure for each and copying the information to the new node.
//
//

NTSTATUS
kmxlDuplicateLineControls(
    IN PMXLLINE pTargetLine,            // The line to put the controls into
    IN PMXLLINE pSourceLine,            // The line with the controls to dup
    IN ULONG    nCount                  // The number of controls to dup
)
{
    PMXLCONTROL pControl,
                pNewControl;
    NTSTATUS    Status;

    PAGED_CODE();
    ASSERT( pTargetLine->Controls == NULL );

    if( nCount == 0 ) {
        RETURN( STATUS_SUCCESS );
    }

    //
    // Iterate over the list allocating and copying the controls
    //

    pControl = kmxlFirstInList( pSourceLine->Controls );
    while( pControl ) {
        ASSERT( IsValidControl( pControl ) );

        //
        // Allocate a new control structure.
        //
        pNewControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( pNewControl == NULL ) {
            goto exit;
        }

        //
        // Copy the entire MXLCONTROL structure and NULL out the
        // List.Next field.  This control will be part of a different
        // list.
        //

        RtlCopyMemory( pNewControl, pControl, sizeof( MXLCONTROL ) );

        pNewControl->List.Next = NULL;
        pNewControl->pChannelStepping = NULL;

        //
        // Copy the channel steppings from the original control
        //

        ASSERT(pControl->NumChannels > 0);

        Status = AudioAllocateMemory_Paged(pNewControl->NumChannels * sizeof( CHANNEL_STEPPING ),
                                           TAG_AuDD_CHANNEL,
                                           DEFAULT_MEMORY,
                                           &pNewControl->pChannelStepping );
        if( !NT_SUCCESS( Status ) ) {
            pNewControl->NumChannels = 0;
            goto exit;
        }

        RtlCopyMemory( pNewControl->pChannelStepping,
                       pControl->pChannelStepping,
                       pNewControl->NumChannels * sizeof( CHANNEL_STEPPING ) );

        //
        // We just made a copy of a MUX node.  Mark the datastructures
        // is has as a copy so it doesn't get freed from underneath
        // somebody else.
        //

        if( IsEqualGUID( pNewControl->NodeType, &KSNODETYPE_MUX ) ) {
            pNewControl->Parameters.bHasCopy = TRUE;
        }

        kmxlAddToList( pTargetLine->Controls, pNewControl );

        //
        // Decrement and check the number of controls copied.  If we copied
        // the requested number, stop.
        //

        --nCount;
        if( nCount == 0 ) {
            break;
        }

        pControl = kmxlNextControl( pControl );
    }
    RETURN( STATUS_SUCCESS );

exit:

    //
    // Failed to allocate the control structure.  Free up all the
    // controls already allocated and return an error.
    //

    while( pTargetLine->Controls ) {
        pControl = kmxlRemoveFirstControl( pTargetLine->Controls );
        kmxlFreeControl( pControl );
    }
    RETURN( STATUS_INSUFFICIENT_RESOURCES );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestinationForNode
//
// Finds a destination for the given node, duplicating lines if splits
// are found in the topology.
//
//

ULONG
kmxlFindDestinationForNode(
    IN     PMIXEROBJECT pmxobj,
    IN     PMXLNODE     pNode,             // The node to find dest for
    IN     PMXLNODE     pParent,           // The original parent
    IN     PMXLLINE     pLine,             // The current line it's on
    IN OUT LINELIST*    plistLines         // The list of all lines
)
{
    PPEERNODE pChild, pPeerChild;
    PMXLLINE  pNewLine;
    PMXLNODE  pShadow = pNode;

    PAGED_CODE();
    DPF(DL_TRACE|FA_MIXER,( "Finding destination for node %d(0x%x) (%s), parent %d(0x%x) (%s).",
            pNode->Id,pNode->Id,
            NodeTypeToString( &pNode->NodeType ),
            pParent->Id,pParent->Id,
            NodeTypeToString( &pNode->NodeType ) ) );

    ASSERT( pmxobj )   ;
    ASSERT( pNode      );
    ASSERT( pParent    );
    ASSERT( pLine      );
    ASSERT( plistLines );

    if( pNode->Type == DESTINATION ) {
        return( pNode->Id );
    }

    //
    // Loop over the first children.
    //

    pChild = kmxlFirstChildNode( pNode );
    while( pChild ) {

            DPF(DL_TRACE|FA_MIXER,( "First child is %d(0x%x) (%s) NODE:%08x.",
                pChild->pNode->Id,
                pChild->pNode->Id,
                NodeTypeToString( &pChild->pNode->NodeType ),
                pChild->pNode ) );

        if( pChild->pNode == pParent ) {
            DPF(DL_TRACE|FA_MIXER,( "Child node is same as original parent!" ) );
            return( INVALID_ID );
        }

        //
        // Loop over the rest of the children.
        //

        pPeerChild = kmxlNextPeerNode( pChild );
        while( pPeerChild ) {

            if( pPeerChild->pNode == pParent ) {
                DPF(DL_TRACE|FA_MIXER,( "Child node is same as original parent!" ) );
                return( INVALID_ID );
            }

            DPF(DL_TRACE|FA_MIXER,( "Peer node of %d(0x%x) (%s) is %d(0x%x) (%s).",
                    pChild->pNode->Id,pChild->pNode->Id,
                    NodeTypeToString( &pChild->pNode->NodeType ),
                    pPeerChild->pNode->Id,pPeerChild->pNode->Id,
                    NodeTypeToString( &pPeerChild->pNode->NodeType ) ) );

            //
            // This line has more than 1 child.  Duplicate this line
            // and add it to the list of lines.
            //

            if( !NT_SUCCESS( kmxlDuplicateLine( &pNewLine, pLine ) ) ) {
                DPF(DL_WARNING|FA_MIXER,("kmxlDuplicateLine failed") );
                continue;
            }
            kmxlAddToEndOfList( *plistLines, pNewLine );

            if( IsEqualGUID( &pPeerChild->pNode->NodeType, &KSNODETYPE_MUX ) ) {

                //
                // We've found a MUX after a SUM or another MUX node.  Mark
                // the current line as invalid and build a new, virtual
                // line that feeds into the MUX.
                //

                pNewLine->DestId = INVALID_ID;
                kmxlBuildVirtualMuxLine(
                    pmxobj,
                    pShadow,
                    pPeerChild->pNode,
                    plistLines
                    );

            } else {

                //
                // Now to find the destination for this new line.  Recurse
                // on the node of this child.
                //

                pNewLine->DestId = kmxlFindDestinationForNode(
                    pmxobj,
                    pPeerChild->pNode,
                    pParent,
                    pNewLine,
                    plistLines
                    );
            }

            DPF(DL_TRACE|FA_MIXER,( "Found %x as dest for %d(0x%x) (%s).",
                    pNewLine->DestId, pPeerChild->pNode->Id,pPeerChild->pNode->Id,
                    NodeTypeToString( &pPeerChild->pNode->NodeType ),
                    pPeerChild->pNode ) );

            pPeerChild = kmxlNextPeerNode( pPeerChild );
        }

        if( IsEqualGUID( &pChild->pNode->NodeType, &KSNODETYPE_MUX ) ) {

                //
                // We've found a MUX after a SUM or another MUX node.  Mark
                // the current line as invalid and build a new, virtual
                // line that feeds into the MUX.
                //

                kmxlBuildVirtualMuxLine(
                    pmxobj,
                    pShadow,
                    pChild->pNode,
                    plistLines
                    );

                return( INVALID_ID );
        }

        //
        // Found the destination!
        //

        if( pChild->pNode->Type == DESTINATION ) {

            DPF(DL_TRACE|FA_MIXER,( "Found %x as dest for %d.",
                    pChild->pNode->Id,
                    pNode->Id ) );

            return( pChild->pNode->Id );
        }

        pShadow = pChild->pNode;
        pChild = kmxlFirstChildNode( pChild->pNode );
    }

    DPF(DL_WARNING|FA_MIXER,("returning INVALID_ID") );
    return( INVALID_ID );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildVirtualMuxLine
//
//

NTSTATUS
kmxlBuildVirtualMuxLine(
    IN PMIXEROBJECT  pmxobj,
    IN PMXLNODE      pParent,
    IN PMXLNODE      pMux,
    IN OUT LINELIST* plistLines
)
{
    PMXLLINE    pLine, pTemp;
    PMXLNODE    pNode;
    PMXLCONTROL pControl;
    MXLCONTROL  Control;

    PAGED_CODE();
    //
    // Allocate a new line to represent the virtual mux input line.
    //

    pLine = kmxlAllocateLine( TAG_AudL_LINE );
    if( pLine == NULL ) {
        RETURN( STATUS_INSUFFICIENT_RESOURCES );
    }

    DPF(DL_TRACE|FA_MIXER,("Virtual line %08x for Parent NODE:%08x",pLine,pParent) );
    //
    // Translate the mux control so that it will appear in this line.
    //

    if (kmxlTranslateNodeToControl(
        pmxobj,
        pMux,
        &pControl
        ) ) {

        pControl->Parameters.bPlaceholder = TRUE;
        kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );

    }

    //
    // Now start searching up from the parent.
    //

    pNode = pParent;
    while( pNode ) {

        //
        // Translate the control.
        //

        if (kmxlTranslateNodeToControl(
            pmxobj,
            pNode,
            &pControl
            ) ) {

            kmxlAppendListToList( (PSLIST*) &pLine->Controls, (PSLIST) pControl );

        }

        //
        // If we found a node with multiple parents, then this will be the
        // "pin" for this line.
        //

        if( ( kmxlParentListLength( pNode ) > 1                ) ||
            ( pNode->Type == SOURCE                            ) ||
            ( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUX ) ) ||
            ( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_SUM ) ) ) {

            //
            // Check to see if this node has already been used in a virtual
            // line.
            //

            pTemp = kmxlFirstInList( *plistLines );
            while( pTemp ) {

                if( pTemp->SourceId == ( 0x8000 + pNode->Id ) ) {
                    while( pLine->Controls ) {
                        pControl = kmxlRemoveFirstControl( pLine->Controls );
                        kmxlFreeControl( pControl );
                    }
                    AudioFreeMemory_Unknown( &pLine );
                    RETURN( STATUS_SUCCESS );
                }

                pTemp = kmxlNextLine( pTemp );
            }

            //
            // Set up the pin.  The name will be the name of the node.
            //

            pLine->SourceId = 0x8000 + pNode->Id;
            Control.NodeType = &pNode->NodeType;
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, &Control );
            RtlCopyMemory(
                pLine->Line.szShortName,
                Control.Control.szShortName,
                min(
                    sizeof( pLine->Line.szShortName ),
                    sizeof( Control.Control.szShortName )
                    )
                );
            RtlCopyMemory(
                pLine->Line.szName,
                Control.Control.szName,
                min(
                    sizeof( pLine->Line.szName ),
                    sizeof( Control.Control.szName )
                   )
                );
            break;
        }

        pNode = (kmxlFirstParentNode( pNode ))->pNode;
    }

    //
    // By making this line type of "SUM" (which technically it is), it
    // will guarantee that this line gets a target type of UNDEFINED.
    //

    pLine->Type               = KSNODETYPE_SUM;
    pLine->Communication      = KSPIN_COMMUNICATION_NONE;
    pLine->Line.cbStruct      = sizeof( MIXERLINE );
    pLine->Line.dwSource      = (DWORD) -1;
    pLine->Line.dwDestination = (DWORD) -1;
    pLine->Line.fdwLine       = MIXERLINE_LINEF_SOURCE |
                                MIXERLINE_LINEF_ACTIVE;

    kmxlAddToEndOfList( plistLines, pLine );

    pLine->DestId = kmxlFindDestinationForNode(
        pmxobj, pMux, pMux, pLine, plistLines
        );

    RETURN( STATUS_SUCCESS );
}


///////////////////////////////////////////////////////////////////////
//
// kmxlTranslateNodeToControl
//
//
// Translates a NodeType GUID into a mixer line control.  The memory
// for the control(s) is allocated and as much information about the
// control is filled in.
//
// NOTES
//   This function returns the number of controls added to the ppControl
// array.
//
// Returns the number of controls actually created.
//
//

ULONG
kmxlTranslateNodeToControl(
    IN  PMIXEROBJECT  pmxobj,
    IN  PMXLNODE      pNode,            // The node to translate into a control
    OUT PMXLCONTROL*  ppControl         // The control to fill in
)
{
    PMXLCONTROL            pControl;
    NTSTATUS               Status = STATUS_SUCCESS;

    ASSERT( pmxobj      );
    ASSERT( pNode       );
    ASSERT( ppControl   );

    PAGED_CODE();

    //
    // Bug fix.  The caller might not clear this.  This needs to be NULL do
    // the caller doesn't think controls were created when the function
    // fails.
    //

    *ppControl = NULL;

    //
    // If the node is NULL, there's nothing to do.
    //
    if( pNode == NULL ) {
        *ppControl = NULL;
        return( 0 );
    }

    DPF(DL_TRACE|FA_MIXER,( "Translating %d(0x%x) ( %s ) NODE:%08x",
        pNode->Id,pNode->Id,
        NodeTypeToString( &pNode->NodeType ),
        pNode ) );

    ///////////////////////////////////////////////////////////////////
    if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_AGC ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // AGC is represented by an ONOFF control.
    //
    // AGC is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports AGC.
        //

        Status = kmxlSupportsControl( pmxobj->pfo, pNode->Id, KSPROPERTY_AUDIO_AGC );
        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "AGC node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure.
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            DPF(DL_ERROR|FA_MIXER,( "failed to allocate AGC control!" ) );
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_AGC;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_AGC;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct         = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_ONOFF;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = 0;
        (*ppControl)->Control.Bounds.dwMaximum = 1;
        (*ppControl)->Control.Metrics.cSteps   = 0;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_LOUDNESS ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // LOUNDNESS is represented by an ONOFF-type control.
    //
    // LOUDNESS is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports LOUDNESS.
        //

        Status = kmxlSupportsControl( pmxobj->pfo, pNode->Id, KSPROPERTY_AUDIO_LOUDNESS );
        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Loudness node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_LOUDNESS;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_LOUDNESS;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct         = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_LOUDNESS;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = 0;
        (*ppControl)->Control.Bounds.dwMaximum = 1;
        (*ppControl)->Control.Metrics.cSteps   = 0;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUTE ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // MUTE is represented by an ONOFF-type control.
    //
    // MUTE is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports MUTE.
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_MUTE );
        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Mute node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_MUTE;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_MUTE;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct         = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_MUTE;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = 0;
        (*ppControl)->Control.Bounds.dwMaximum = 1;
        (*ppControl)->Control.Metrics.cSteps   = 0;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_TONE ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // A TONE node can represent up to 3 controls:
    //   Treble:     A fader control
    //   Bass:       A fader control
    //   Bass Boost: A OnOff control
    //
    // Both Treble and Bass are UNIFORM (mono) controls.
    //
    // To determine which control(s) the TONE node represents, a helper
    // function is called to query the particular property.  If the
    // helper function succeeds, a control is created for that property.
    //
    ///////////////////////////////////////////////////////////////////

        Status = kmxlSupportsControl( pmxobj->pfo,
                                      pNode->Id,
                                      KSPROPERTY_AUDIO_BASS_BOOST );
        if (NT_SUCCESS(Status)) {
            //
            // Bass boost control is supported.  Allocate a new structure.
            //

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl == NULL ) {
                goto exit;
            }

            //
            // Fill in as much information as possible.
            //

            pControl->NodeType                  = &KSNODETYPE_TONE;
            pControl->Id                        = pNode->Id;
            pControl->PropertyId                = KSPROPERTY_AUDIO_BASS_BOOST;
            pControl->bScaled                   = FALSE;
            pControl->Control.cbStruct          = sizeof( MIXERCONTROL );
            pControl->Control.dwControlType     = MIXERCONTROL_CONTROLTYPE_ONOFF;
            pControl->Control.cMultipleItems    = 0;
            pControl->Control.Bounds.dwMinimum  = 0;
            pControl->Control.Bounds.dwMaximum  = 1;
            pControl->Control.Metrics.cSteps    = 0;

            Status = kmxlGetControlChannels( pmxobj->pfo, pControl );
            if (!NT_SUCCESS(Status))
            {
                kmxlFreeControl( pControl );
                pControl = NULL;
                goto exit;
            }

            kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl);

            ASSERT( IsValidControl( pControl ) );

            //
            // Add this new control to the list.
            //

            kmxlAddToList( *ppControl, pControl );

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl ) {
                RtlCopyMemory( pControl, *ppControl, sizeof( MXLCONTROL ) );

                //
                // Copy the channel steppings from the original control
                //
                //
                // Sense we copied the control above, we might have gotten
                // a pChannelStepping pointer in the copy.  We'll NULL that out
                // for the memory allocation.
                //
                pControl->pChannelStepping = NULL;

                ASSERT(pControl->NumChannels > 0);
                
                Status = AudioAllocateMemory_Paged(pControl->NumChannels * sizeof( CHANNEL_STEPPING ),
                                                   TAG_AuDC_CHANNEL,
                                                   DEFAULT_MEMORY,
                                                   &pControl->pChannelStepping );
                if( !NT_SUCCESS( Status ) ) {
                    pControl->NumChannels = 0;
                    kmxlFreeControl( pControl );
                    pControl = NULL;
                    goto exit;
                }

                RtlCopyMemory( pControl->pChannelStepping,
                               (*ppControl)->pChannelStepping,
                               pControl->NumChannels * sizeof( CHANNEL_STEPPING ) );

                pControl->Control.dwControlType = MIXERCONTROL_CONTROLTYPE_BASS_BOOST;

                kmxlAddToList( *ppControl, pControl );
                ASSERT( IsValidControl( pControl ) );
            }

        }

        Status = kmxlSupportsBassControl( pmxobj->pfo, pNode->Id );
        if (NT_SUCCESS(Status)) {
            //
            // Bass control is supported.  Allocate a new structure.
            //

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl == NULL ) {
                goto exit;
            }

            //
            // Fill in as much information as possible.
            //

            pControl->NodeType                  = &KSNODETYPE_TONE;
            pControl->Id                        = pNode->Id;
            pControl->PropertyId                = KSPROPERTY_AUDIO_BASS;
            pControl->bScaled                   = TRUE;
            pControl->Control.cbStruct          = sizeof( MIXERCONTROL );
            pControl->Control.dwControlType     = MIXERCONTROL_CONTROLTYPE_BASS;
            pControl->Control.fdwControl        = MIXERCONTROL_CONTROLF_UNIFORM;
            pControl->Control.cMultipleItems    = 0;
            pControl->Control.Bounds.dwMinimum  = DEFAULT_STATICBOUNDS_MIN;
            pControl->Control.Bounds.dwMaximum  = DEFAULT_STATICBOUNDS_MAX;
            pControl->Control.Metrics.cSteps    = DEFAULT_STATICMETRICS_CSTEPS;

            Status = kmxlGetControlRange( pmxobj->pfo, pControl );
            if (!NT_SUCCESS(Status))
            {
                kmxlFreeControl( pControl );
                pControl = NULL;
                goto exit;
            } else {

                kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl);

                //
                // Add this new control to the list.
                //

                ASSERT( IsValidControl( pControl ) );

                kmxlAddToList( *ppControl, pControl );
            }
        }

        Status = kmxlSupportsTrebleControl( pmxobj->pfo, pNode->Id );
        if (NT_SUCCESS(Status)) {
            //
            // Treble is supported.  Allocate a new control structure.
            //

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl == NULL ) {
                goto exit;
            }

            //
            // Fill in as much information as possible.
            //

            pControl->NodeType                  = &KSNODETYPE_TONE;
            pControl->Id                        = pNode->Id;
            pControl->PropertyId                = KSPROPERTY_AUDIO_TREBLE;
            pControl->bScaled                   = TRUE;
            pControl->Control.cbStruct          = sizeof( MIXERCONTROL );
            pControl->Control.dwControlType     = MIXERCONTROL_CONTROLTYPE_TREBLE;
            pControl->Control.fdwControl        = MIXERCONTROL_CONTROLF_UNIFORM;
            pControl->Control.cMultipleItems    = 0;
            pControl->Control.Bounds.dwMinimum  = DEFAULT_STATICBOUNDS_MIN;
            pControl->Control.Bounds.dwMaximum  = DEFAULT_STATICBOUNDS_MAX;
            pControl->Control.Metrics.cSteps    = DEFAULT_STATICMETRICS_CSTEPS;

            Status = kmxlGetControlRange( pmxobj->pfo, pControl );
            if (!NT_SUCCESS(Status))
            {
                kmxlFreeControl( pControl );
                pControl = NULL;
                goto exit;
            } else {

                kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl);

                //
                // Add this new control to the list.
                //

                ASSERT( IsValidControl( pControl ) );

                kmxlAddToList( *ppControl, pControl );
            }
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_VOLUME ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // A VOLUME is a fader-type control
    //
    // To determine if a node supports volume changes
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports volume
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_VOLUMELEVEL
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Volume node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_VOLUME;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_VOLUMELEVEL;
        (*ppControl)->bScaled                  = TRUE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_VOLUME;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;
        (*ppControl)->Control.cMultipleItems   = 0;

        Status = kmxlGetControlRange( pmxobj->pfo, (*ppControl) );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        }

        kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

        ASSERT( IsValidControl( *ppControl ) );

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_PEAKMETER ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // To determine if a node supports peak meter properties
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports peakmeter
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_PEAKMETER
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Peakmeter node fails property!" ) );
            goto exit;
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_PEAKMETER;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_PEAKMETER;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_PEAKMETER;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;
        (*ppControl)->Control.cMultipleItems   = 0;

        Status = kmxlGetControlRange( pmxobj->pfo, (*ppControl) );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        }

        kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

        ASSERT( IsValidControl( *ppControl ) );

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_MUX ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // A MUX is a single select type control.
    //
    ///////////////////////////////////////////////////////////////////

    {
        ULONG Line;

        //
        // Do a quick check and see if the mux responds properly.
        // If not, just get out of here quick.
        //

        if( !NT_SUCCESS( kmxlGetNodeProperty(
            pmxobj->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MUX_SOURCE,
            pNode->Id,
            0,
            NULL,
            &Line,
            sizeof( Line ) ) ) )
        {
            goto exit;
        }

        //
        // Look to see if a control has already been generated for this
        // node.  If so, the control information can be used from it
        // instead of creating a new one.
        //

        pControl = kmxlFirstInList( pmxobj->listMuxControls );
        while( pControl ) {
            ASSERT( IsValidControl( pControl ) );

            if( pControl->Id == pNode->Id ) {
                break;
            }

            pControl = kmxlNextControl( pControl );
        }

        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        if( pControl == NULL ) {

            //
            // This node has not been seen before.  Fill in as much info as
            // possible.
            //

            (*ppControl)->NodeType                 = &KSNODETYPE_MUX;
            (*ppControl)->Id                       = pNode->Id;
            (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_MUX_SOURCE;
            (*ppControl)->bScaled                  = FALSE;
            (*ppControl)->Control.cbStruct         = sizeof( MIXERCONTROL );
            (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_MUX;
            (*ppControl)->Control.cMultipleItems   = kmxlGetNumMuxLines(
                                                        pmxobj->pTopology,
                                                        pNode->Id
                                                        );
            (*ppControl)->Control.fdwControl       = MIXERCONTROL_CONTROLF_MULTIPLE |
                                                     MIXERCONTROL_CONTROLF_UNIFORM;
            (*ppControl)->Control.Bounds.dwMinimum = 0;
            (*ppControl)->Control.Bounds.dwMaximum = (*ppControl)->Control.cMultipleItems - 1;
            (*ppControl)->Control.Metrics.cSteps   = (*ppControl)->Control.cMultipleItems;

            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));
            kmxlGetMuxLineNames( pmxobj, *ppControl );


            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl == NULL ) {
                kmxlFreeControl( *ppControl );
                *ppControl = NULL;
                goto exit;
            }

            //
            // Make a copy of this control for the mux list
            //

            (*ppControl)->Control.dwControlID = pmxobj->dwControlId++;
            RtlCopyMemory( pControl, *ppControl, sizeof( MXLCONTROL ) );
            ASSERT( IsValidControl( pControl ) );
            pControl->Parameters.bHasCopy = TRUE;
            (*ppControl)->Parameters.bHasCopy = FALSE;
            kmxlAddToList( pmxobj->listMuxControls, pControl );

        } else {

            RtlCopyMemory( *ppControl, pControl, sizeof( MXLCONTROL ) );
            ASSERT( IsValidControl( *ppControl ) );
            (*ppControl)->Parameters.bHasCopy = TRUE;
            (*ppControl)->List.Next = NULL;

        }
    }

#ifdef STEREO_ENHANCE
    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_STEREO_WIDE ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // Stereo Enhance is a boolean control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports stereo wide
        //

        Status = kmxlSupportsControl(
            pfoInstance,
            pNode->Id,
            KSPROPERTY_AUDIO_WIDE_MODE
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Stereo Wide node fails property!" ) );
            goto exit;
        }


        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_STEREO_ENHANCE;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_WIDE_MODE;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_STEREOENH;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = 0;
        (*ppControl)->Control.Bounds.dwMaximum = 1;
        (*ppControl)->Control.Metrics.cSteps   = 0;

        Status = kmxlGetControlChannels( pfoInstance, *ppControl );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        }

        kmxlGetNodeName( pfoInstance, pNode->Id, (*ppControl));
#endif

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_STEREO_WIDE ) ) {
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports stereo wide
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_WIDENESS
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Stereo wide node fails property!" ) );
            goto exit;
        }


        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_STEREO_WIDE;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_WIDENESS;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_FADER;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;

        Status = kmxlGetControlRange( pmxobj->pfo, (*ppControl) );
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        }

        kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

        ASSERT( IsValidControl( *ppControl ) );

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_CHORUS ) ) {
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports chorus
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_CHORUS_LEVEL
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Chorus node fails property!" ) );
            goto exit;
        }


        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_CHORUS;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_CHORUS_LEVEL;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_FADER;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;
        // (*ppControl)->Control.Metrics.cSteps   = 0xFFFF;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );  // Should we also get the range?
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_REVERB ) ) {
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports reverb
        //

        Status = kmxlSupportsControl(
            pmxobj->pfo,
            pNode->Id,
            KSPROPERTY_AUDIO_REVERB_LEVEL
            );

        if (!NT_SUCCESS(Status)) {
            DPF(DL_TRACE|FA_MIXER,( "Reverb node fails property!" ) );
            goto exit;
        }


        //
        // Allocate the new control structure
        //

        *ppControl = kmxlAllocateControl( TAG_AudC_CONTROL );
        if( *ppControl == NULL ) {
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //

        (*ppControl)->NodeType                 = &KSNODETYPE_REVERB;
        (*ppControl)->Id                       = pNode->Id;
        (*ppControl)->PropertyId               = KSPROPERTY_AUDIO_REVERB_LEVEL;
        (*ppControl)->bScaled                  = FALSE;
        (*ppControl)->Control.cbStruct = sizeof( MIXERCONTROL );
        (*ppControl)->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_FADER;
        (*ppControl)->Control.cMultipleItems   = 0;
        (*ppControl)->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
        (*ppControl)->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
        (*ppControl)->Control.Metrics.cSteps   = DEFAULT_STATICMETRICS_CSTEPS;
        // (*ppControl)->Control.Metrics.cSteps   = 0xFFFF;

        Status = kmxlGetControlChannels( pmxobj->pfo, *ppControl );  // Should we also get the range?
        if (!NT_SUCCESS(Status))
        {
            kmxlFreeControl( *ppControl );
            *ppControl = NULL;
            goto exit;
        } else {
            kmxlGetNodeName( pmxobj->pfo, pNode->Id, (*ppControl));

            ASSERT( IsValidControl( *ppControl ) );
        }

    ///////////////////////////////////////////////////////////////////
    } else if( IsEqualGUID( &pNode->NodeType, &KSNODETYPE_SUPERMIX ) ) {
    ///////////////////////////////////////////////////////////////////
    //
    // SuperMix nodes can be supported as MUTE controls if the MUTE
    // property is supported.
    //
    ///////////////////////////////////////////////////////////////////

        PKSAUDIO_MIXCAP_TABLE pMixCaps;
        PLONG                 pReferenceCount = NULL;
        ULONG                 i,
                              Size;
        BOOL                  bMutable;
        BOOL                  bVolume = FALSE;
        PKSAUDIO_MIXLEVEL     pMixLevels = NULL;
        #ifdef SUPERMIX_AS_VOL
        ULONG                 Channels;
        #endif

        if( !NT_SUCCESS( kmxlGetSuperMixCaps( pmxobj->pfo, pNode->Id, &pMixCaps ) ) ) {
            goto exit;
        }

        Status = AudioAllocateMemory_Paged(sizeof( LONG ),
                                           TAG_AudS_SUPERMIX,
                                           ZERO_FILL_MEMORY,
                                           &pReferenceCount );
        if( !NT_SUCCESS( Status ) ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            *ppControl = NULL;
            goto exit;
        }
        *pReferenceCount=0;

        Size = pMixCaps->InputChannels * pMixCaps->OutputChannels;

        Status = AudioAllocateMemory_Paged(Size * sizeof( KSAUDIO_MIXLEVEL ),
                                           TAG_Audl_MIXLEVEL,
                                           ZERO_FILL_MEMORY,
                                           &pMixLevels );
        if( !NT_SUCCESS( Status ) ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            AudioFreeMemory( sizeof(LONG),&pReferenceCount );
            *ppControl = NULL;
            goto exit;
        }

        Status = kmxlGetNodeProperty(
            pmxobj->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pNode->Id,
            0,
            NULL,
            pMixLevels,
            Size * sizeof( KSAUDIO_MIXLEVEL )
            );
        if( !NT_SUCCESS( Status ) ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            AudioFreeMemory( sizeof(LONG),&pReferenceCount );
            AudioFreeMemory_Unknown( &pMixLevels );
            DPF(DL_WARNING|FA_MIXER,("kmxlGetNodeProperty failed Status=%X",Status) );
            *ppControl = NULL;
            goto exit;
        }

        bMutable = TRUE;
        for( i = 0; i < Size; i++ ) {

            //
            // If the channel is mutable, then all is well for this entry.
            //

            if( pMixCaps->Capabilities[ i ].Mute ) {
                continue;
            }

            //
            // The the entry is not mutable but is fully attenuated,
            // this will work too.
            //

            if( ( pMixCaps->Capabilities[ i ].Minimum == LONG_MIN ) &&
                ( pMixCaps->Capabilities[ i ].Maximum == LONG_MIN ) &&
                ( pMixCaps->Capabilities[ i ].Reset   == LONG_MIN ) )
            {
                continue;
            }

            bMutable = FALSE;
            break;
        }

        #ifdef SUPERMIX_AS_VOL

        bVolume = TRUE;
        Channels = 0;
        for( i = 0; i < Size; i += pMixCaps->OutputChannels + 1 ) {

            if( ( pMixCaps->Capabilities[ i ].Maximum -
                  pMixCaps->Capabilities[ i ].Minimum ) > 0 )
            {
                ++Channels;
                continue;
            }

            bVolume = FALSE;
            break;
        }
        #endif
        //
        // This node cannot be used as a MUTE control.
        //

        if( !bMutable && !bVolume ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            AudioFreeMemory( sizeof(LONG),&pReferenceCount );
            AudioFreeMemory_Unknown( &pMixLevels );
            *ppControl = NULL;
            goto exit;
        }

        if( bMutable ) {

            //
            // The Supermix is verifiably usable as a MUTE.  Fill in all the
            // details.
            //

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );

            if( pControl != NULL ) {

                pControl->NodeType                 = &KSNODETYPE_SUPERMIX;
                pControl->Id                       = pNode->Id;
                pControl->PropertyId               = KSPROPERTY_AUDIO_MIX_LEVEL_TABLE;
                pControl->bScaled                  = FALSE;
                pControl->Control.cbStruct         = sizeof( MIXERCONTROL );
                pControl->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_MUTE;
                pControl->Control.fdwControl       = MIXERCONTROL_CONTROLF_UNIFORM;
                pControl->Control.cMultipleItems   = 0;
                pControl->Control.Bounds.dwMinimum = 0;
                pControl->Control.Bounds.dwMaximum = 1;
                pControl->Control.Metrics.cSteps   = 0;

                InterlockedIncrement(pReferenceCount);
                pControl->Parameters.pReferenceCount = pReferenceCount;
                pControl->Parameters.Size          = pMixCaps->InputChannels *
                                                     pMixCaps->OutputChannels;
                pControl->Parameters.pMixCaps      = pMixCaps;
                pControl->Parameters.pMixLevels    = pMixLevels;

                Status = AudioAllocateMemory_Paged(sizeof( CHANNEL_STEPPING ),
                                                   TAG_AuDE_CHANNEL,
                                                   ZERO_FILL_MEMORY,
                                                   &pControl->pChannelStepping );
                if( !NT_SUCCESS( Status ) ) {
                    AudioFreeMemory_Unknown( &pMixCaps );
                    AudioFreeMemory( sizeof(LONG),&pReferenceCount );
                    AudioFreeMemory_Unknown( &pMixLevels );
                    *ppControl = NULL;
                    goto exit;
                }

                pControl->NumChannels                       = 1;
                pControl->pChannelStepping->MinValue        = pMixCaps->Capabilities[ 0 ].Minimum;
                pControl->pChannelStepping->MaxValue        = pMixCaps->Capabilities[ 0 ].Maximum;
                pControl->pChannelStepping->Steps           = 32;

                kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl);

                kmxlAddToList( *ppControl, pControl );
                ASSERT( IsValidControl( pControl ) );
            }
        }

        #ifdef SUPERMIX_AS_VOL
        if( bVolume ) {

            pControl = kmxlAllocateControl( TAG_AudC_CONTROL );
            if( pControl != NULL ) {

                pControl->NodeType                 = &KSNODETYPE_SUPERMIX;
                pControl->Id                       = pNode->Id;
                pControl->PropertyId               = KSPROPERTY_AUDIO_MIX_LEVEL_TABLE;
                pControl->bScaled                  = TRUE;
                pControl->Control.cbStruct         = sizeof( MIXERCONTROL );
                pControl->Control.dwControlType    = MIXERCONTROL_CONTROLTYPE_VOLUME;
                pControl->Control.cMultipleItems   = 0;
                pControl->Control.Bounds.dwMinimum = DEFAULT_STATICBOUNDS_MIN;
                pControl->Control.Bounds.dwMaximum = DEFAULT_STATICBOUNDS_MAX;
                pControl->Control.Metrics.cSteps   = 32;

                InterlockedIncrement(pReferenceCount);
                pControl->Parameters.pReferenceCount = pReferenceCount;
                pControl->Parameters.Size          = pMixCaps->InputChannels *
                                                     pMixCaps->OutputChannels;
                pControl->Parameters.pMixCaps      = pMixCaps;
                pControl->Parameters.pMixLevels    = pMixLevels;

                if( Channels == 1 ) {
                    pControl->Control.fdwControl = MIXERCONTROL_CONTROLF_UNIFORM;
                } else {
                    pControl->Control.fdwControl = 0;
                }

                kmxlGetNodeName( pmxobj->pfo, pNode->Id, pControl );

                kmxlAddToList( *ppControl, pControl );
                ASSERT( IsValidControl( pControl ) );

            }

        }
        #endif // SUPERMIX_AS_VOL

        if( *ppControl == NULL ) {
            AudioFreeMemory_Unknown( &pMixCaps );
            AudioFreeMemory( sizeof(LONG),&pReferenceCount );
            AudioFreeMemory_Unknown( &pMixLevels );
        }
    }

exit:

    if( *ppControl ) {
        DPF(DL_TRACE|FA_MIXER,( "Translated %d controls.", kmxlListLength( *ppControl ) ) );
        return( kmxlListLength( *ppControl ) );
    } else {
        DPF(DL_TRACE|FA_MIXER,( "Translated no controls." ) );
        return( 0 );
    }
}

#define KsAudioPropertyToString( Property )                 \
    Property == KSPROPERTY_AUDIO_VOLUMELEVEL ? "Volume"   : \
    Property == KSPROPERTY_AUDIO_MUTE        ? "Mute"     : \
    Property == KSPROPERTY_AUDIO_BASS        ? "Bass"     : \
    Property == KSPROPERTY_AUDIO_TREBLE      ? "Treble"   : \
    Property == KSPROPERTY_AUDIO_AGC         ? "AGC"      : \
    Property == KSPROPERTY_AUDIO_LOUDNESS    ? "Loudness" : \
    Property == KSPROPERTY_AUDIO_PEAKMETER   ? "Peakmeter" : \
        "Unknown"

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsControl
//
// Queries for property on control to see if it is actually supported
//
//

NTSTATUS
kmxlSupportsControl(
    IN PFILE_OBJECT pfoInstance,    // The instance to check for
    IN ULONG        Node,           // The node id to query
    IN ULONG        Property        // The property to check for
)
{
    NTSTATUS      Status;
    LONG          Level;

    ASSERT( pfoInstance );

    PAGED_CODE();

    //
    // Check to see if the property works on the first channel.
    //
    Status = kmxlGetAudioNodeProperty(
        pfoInstance,
        Property,
        Node,
        0, // Channel 0 - first channel
        NULL, 0,
        &Level, sizeof( Level )
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_MIXER,( "SupportsControl for (%d,%X) failed on first channel with %x.",
                Node, Property, Status ) );
    }

    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsMultiChannelControl
//
// Queries for property on the second channel of the control to see
// independent levels can be set.  It is assumed that the first channel
// already succeeded in kmxlSupportsControl
//
//

NTSTATUS
kmxlSupportsMultiChannelControl(
    IN PFILE_OBJECT pfoInstance,    // The instance to check for
    IN ULONG        Node,           // The node id to query
    IN ULONG        Property        // The property to check for
)
{
    NTSTATUS                  Status;
    LONG                      Level;

    ASSERT( pfoInstance );

    PAGED_CODE();

    //
    // Just check the property on the second channel because we have already checked
    // the first channel already.
    //
    Status = kmxlGetAudioNodeProperty(
        pfoInstance,
        Property,
        Node,
        1, // Second channel equals a channel value of 1
        NULL, 0,
        &Level, sizeof( Level )
        );

    RETURN( Status );
}


NTSTATUS
kmxlAssignLineAndControlIdsWorker(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST listLines,              // The list to assign ids for
    IN ULONG    ListType,                // LIST_SOURCE or LIST_DESTINATION
    IN OUT ULONG *pLineID,
    IN GUID *pDestGuid
)
{
    NTSTATUS    Status    = STATUS_SUCCESS;
    PMXLLINE    pLine     = NULL;
    PMXLCONTROL pControl  = NULL;
    ULONG       LineID    = 0;
    ULONG       Dest;

    PAGED_CODE();
    ASSERT ( ListType==SOURCE_LIST || ListType==DESTINATION_LIST );

    if (pLineID!=NULL) {
        LineID=*pLineID;
        }

    //
    // Loop through each of the line structures
    //

    pLine = kmxlFirstInList( listLines );
    if( pLine == NULL ) {
        RETURN( Status );
    }

    Dest = pLine->DestId;
    while( pLine ) {

        //
        // For destinations, set the dwDestination field and set
        // the dwSource field for sources.
        //

        if( ListType == DESTINATION_LIST ) {

            // Check if this line has already been assigned an ID.
            // If so, then go to next line in list.
            if (pLine->Line.dwDestination!=(DWORD)(-1)) {
                pLine = kmxlNextLine( pLine );
                continue;
                }

            // Now if we can only number lines of a particular GUID,
            // then make sure this destination line type matches that guid.
            if (pDestGuid!=NULL && !IsEqualGUID( pDestGuid, &pLine->Type )) {
                pLine = kmxlNextLine( pLine );
                continue;
                }


            //
            // Assign the destination Id.  Create the line Id by
            // using -1 for the source in the highword and the
            // destination in the loword.
            //

            pLine->Line.dwDestination = LineID++;
            pLine->Line.dwLineID = MAKELONG(
                pLine->Line.dwDestination,
                -1
                );

            if (pLineID!=NULL) {
                *pLineID=LineID;
                }

        } else if( ListType == SOURCE_LIST ) {
            pLine->Line.dwSource = LineID++;
        } else {
            RETURN( STATUS_INVALID_PARAMETER );
        }

        //
        // Set up the number of controls on this line.
        //

        pLine->Line.cControls = kmxlListLength( pLine->Controls );

        //
        // Loop through the controls, assigning them a control ID
        // that is a pointer to the MXLCONTROL structure for that
        // control.
        //

        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {

            if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {
                //
                // MUX controls are already numbered by this point.  Just skip
                // it and go onto the next one.
                //
                pControl = kmxlNextControl( pControl );
                continue;
            }

            pControl->Control.dwControlID = pmxobj->dwControlId++;
            pControl = kmxlNextControl( pControl );
        }

        pLine = kmxlNextLine( pLine );
        if( pLine == NULL ) {
            continue;
        }
        if( ( ListType == SOURCE_LIST ) && ( pLine->DestId != Dest ) ) {
            LineID = 0;
            Dest = pLine->DestId;
        }
    }

    RETURN( Status );
}



#define GUIDCOUNT 13

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignLineAndControlIds
//
// Loops through the list of lines and assigns ids for those line.
// For destinations, the Id starts a 0 and is incremented each time.
// The line id is a long of -1 and the dest id.  For sources, the
// line Ids will need to be specified elsewhere so only dwSource
// field is assigned.
//
// For controls, each control is given an Id of the address to the
// MXLCONTROL structure.
//
//

NTSTATUS
kmxlAssignLineAndControlIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST listLines,              // The list to assign ids for
    IN ULONG    ListType                // LIST_SOURCE or LIST_DESTINATION
)

{


    PAGED_CODE();
ASSERT ( ListType==SOURCE_LIST || ListType==DESTINATION_LIST );

if (SOURCE_LIST==ListType) {

    return( kmxlAssignLineAndControlIdsWorker(pmxobj, listLines, ListType, NULL, NULL) );

    }

else if (DESTINATION_LIST==ListType) {

    // In order to help sndvol32 do the right thing as far as which
    // lines displayed as the default playback and record lines, we
    // number lines based on what their destinations are.

    // We use guid the pLine->Type field to decide how to number lines.
    // Lines are prioritized in the following way: speakers, then
    // headphones, then telephones.  Non prioritized guids are assigned
    // last in whatever order they appear in the list.

    ULONG LineID=0;
    ULONG i;

    GUID prioritizeddestinationguids[GUIDCOUNT]= {
        STATIC_KSNODETYPE_ROOM_SPEAKER,
        STATIC_KSNODETYPE_DESKTOP_SPEAKER,
        STATIC_KSNODETYPE_SPEAKER,
        STATIC_KSNODETYPE_COMMUNICATION_SPEAKER,
        STATIC_KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO,
        STATIC_KSNODETYPE_ANALOG_CONNECTOR,
        STATIC_KSNODETYPE_SPDIF_INTERFACE,
        STATIC_KSNODETYPE_HEADPHONES,
        STATIC_KSNODETYPE_TELEPHONE,
        STATIC_KSNODETYPE_PHONE_LINE,
        STATIC_KSNODETYPE_DOWN_LINE_PHONE,
        STATIC_PINNAME_CAPTURE,
        STATIC_KSCATEGORY_AUDIO,
        };

    // Cycle through the list for each prioritized guid and number
    // those lines that match that particular guid.
    for (i=0; i<GUIDCOUNT; i++) {

        kmxlAssignLineAndControlIdsWorker(pmxobj, listLines, ListType,
            &LineID, &prioritizeddestinationguids[i]);

        }

    // Now, number anything left over with a number that depends solely on
    // its random order in the list.

    return( kmxlAssignLineAndControlIdsWorker(pmxobj, listLines, ListType, &LineID, NULL) );

    }
else {
    RETURN( STATUS_INVALID_PARAMETER );
    }

}


///////////////////////////////////////////////////////////////////////
//
// kmxlAssignDestinationsToSources
//
// Loops through each source looking for a destination lines that
// have a matching destination id.  Source line Ids are assigned
// by putting the source id in the hiword and the dest id in the
// loword.
//
//

NTSTATUS
kmxlAssignDestinationsToSources(
    IN LINELIST listSourceLines,        // The list of all source lines
    IN LINELIST listDestLines           // The list of all dest lines
)
{
    PMXLLINE pSource = NULL,
             pDest   = NULL;

    PAGED_CODE();
    //
    // For each source line, loop throught the destinations until a
    // line is found matching the Id.  The dwDestination field will
    // be the zero-index Id of the destination.
    //

    pSource = kmxlFirstInList( listSourceLines );
    while( pSource ) {

        pDest = kmxlFirstInList( listDestLines );
        while( pDest ) {

            if( pSource->DestId == pDest->DestId ) {
                //
                // Heh, whatchya know?
                //
                pSource->Line.dwDestination = pDest->Line.dwDestination;
                pSource->Line.dwLineID = MAKELONG(
                    (WORD) pSource->Line.dwDestination,
                    (WORD) pSource->Line.dwSource
                    );
                break;
            }
            pDest = kmxlNextLine( pDest );
        }
        pSource = kmxlNextLine( pSource );
    }

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlUpdateDestinationConnectionCount
//
// For each of the destinations, loop through each of the sources
// and find those that connect to this destination.  That count is
// then stored in the MIXERLINE.cConnections for the line.
//
//

NTSTATUS
kmxlUpdateDestintationConnectionCount(
    IN LINELIST listSourceLines,    // The list of source lines
    IN LINELIST listDestLines       // The list of destination lines
)
{
    PMXLLINE pDest,
             pSource;
    ULONG    Count;

    PAGED_CODE();
    //
    // Loop through each destination finding all the sources that connect
    // to it.  The total number of sources connecting to a destination
    // is sourced in the cConnections field of the MIXERLINE struct.
    //

    pDest = kmxlFirstInList( listDestLines );
    while( pDest ) {

        //
        // Initialize the source ID.  This will mark this as a valid
        // destination.
        //

        pDest->SourceId = (ULONG) -1;

        Count = 0;

        //
        // Loop through the sources looking for sources that connect to
        // the current destination.
        //

        pSource = kmxlFirstInList( listSourceLines );
        while( pSource ) {

            //
            // Found a match.  Increment the count.
            //

            if( pSource->DestId == pDest->DestId ) {
                ++Count;
            }

            pSource = kmxlNextLine( pSource );
        }

        pDest->Line.cConnections = Count;
        pDest = kmxlNextLine( pDest );
    }

    RETURN( STATUS_SUCCESS );
}

VOID
CleanupLine(
    PMXLLINE pLine
    )
{
    PMXLCONTROL pControl;

    while( pLine->Controls ) {
        pControl = kmxlRemoveFirstControl( pLine->Controls );
        kmxlFreeControl( pControl );
    }
    AudioFreeMemory( sizeof(MXLLINE),&pLine );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlEliminateInvalidLines
//
// Loops through the lines removing lines that are invalid.  Refer
// to the function for IsValidLine() for details on what is an invalid
// line.
//
//

NTSTATUS
kmxlEliminateInvalidLines(
    IN LINELIST* listLines               // The list of lines
)
{
    PMXLLINE    pLine, pTemp, pShadow;

    PAGED_CODE();
    //
    // Eliminate all invalid lines at the start of the list.
    //

    pLine = kmxlFirstInList( *listLines );
    while( pLine ) {

        //
        // Found the first valid line.  Break out of this loop.
        //

        if( Is_Valid_Line( pLine ) ) {
            break;
        }

        //
        // This is an invalid line.  Remove it from the list, free up
        // all its control structures, and free the line structure.
        //

        pTemp = kmxlRemoveFirstLine( pLine );
        CleanupLine(pTemp);
    }

    //
    // Assign listLines to point to the first valid line.
    //

    *listLines = pLine;

    if( pLine == NULL ) {
        RETURN( STATUS_SUCCESS );
    }

    //
    // At this point, pLine is a valid line.  Keeping a hold on the prev
    // line, loop through the lines eliminating the invalid ones.
    //

    pShadow = pLine;
    while( pShadow && kmxlNextLine( pShadow ) ) {

        pLine = kmxlNextLine( pShadow );

        if( pLine && !Is_Valid_Line( pLine ) ) {

            //
            // Remove the invalid line from the list
            //

            pShadow->List.Next = pLine->List.Next;
            pLine->List.Next   = NULL;

            CleanupLine(pLine);

            continue;
        }
        pShadow = kmxlNextLine( pShadow );
    }


    // All the invalid lines have been eliminated.  Now eliminate bad
    // duplicates.

    pShadow = kmxlFirstInList( *listLines );
    while( pShadow ) {

        //
        // Walk all the lines looking for a match.
        //
        pLine = kmxlNextLine( pShadow );
        pTemp = NULL;
        while( pLine ) {
        
            if( ( pShadow->SourceId == pLine->SourceId ) &&
                ( pShadow->DestId   == pLine->DestId   ) )
            {
                DPF(DL_TRACE|FA_MIXER,( "Line %x is equal to line %x!",
                    pShadow->Line.dwLineID,
                    pLine->Line.dwLineID
                    ) );
                //
                // Found a match.
                //
                if( pTemp == NULL )
                {
                    //
                    // pShadow is our previous line.  Remove this line from the 
                    // list.
                    //
                    pShadow->List.Next = pLine->List.Next;
                    pLine->List.Next   = NULL;

                    CleanupLine(pLine);

                    //
                    // Now adjust pLine to the next line and loop
                    //
                    pLine = kmxlNextLine( pShadow );
                    continue;
                } else {
                    //
                    // pTemp is our previous line.  Remove this line from the
                    // list.
                    //
                    pTemp->List.Next = pLine->List.Next;
                    pLine->List.Next   = NULL;

                    CleanupLine(pLine);

                    //
                    // Now adjust pLine to the next line and loop
                    //
                    pLine = kmxlNextLine( pTemp );
                    continue;
                }
            }
            pTemp = pLine;  //temp is previous line
            pLine = kmxlNextLine( pLine );
        }

        pShadow = kmxlNextLine( pShadow );
    }

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignComponentIds
//
// Loops through all the destinations then the sources and determines
// their component type and target types.
//
//

VOID
kmxlAssignComponentIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST     listSourceLines,
    IN LINELIST     listDestLines
)
{
    PMXLLINE pLine;

    PAGED_CODE();
    //
    // Loop through the destinations...
    //

    pLine = kmxlFirstInList( listDestLines );
    while( pLine ) {
        pLine->Line.dwComponentType = kmxlDetermineDestinationType(
            pmxobj,
            pLine
            );
        pLine = kmxlNextLine( pLine );
    }

    //
    // Loop through the sources...
    //

    pLine = kmxlFirstInList( listSourceLines );
    while( pLine ) {
        pLine->Line.dwComponentType = kmxlDetermineSourceType(
            pmxobj,
            pLine
            );
        pLine = kmxlNextLine( pLine );
    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlUpdateMuxLines
//
// Updates the name, line ID, and componenttype of a line that has
// a mux control on it.  The MixerControlDetails array is searched for
// an entry that has a matching source id and replaced with the info
// from this line.
//
//

VOID
kmxlUpdateMuxLines(
    IN PMXLLINE    pLine,
    IN PMXLCONTROL pControl
)
{
    ULONG i;

    PAGED_CODE();
    for( i = 0; i < pControl->Parameters.Count; i++ ) {

        if( ( pLine->SourceId == pControl->Parameters.lpmcd_lt[ i ].dwParam1 ) &&
            ( pControl->Parameters.lpmcd_lt[ i ].dwParam2 == (DWORD) -1 ) )
        {

            wcscpy(
                pControl->Parameters.lpmcd_lt[ i ].szName,
                pLine->Line.szName
                );
            pControl->Parameters.lpmcd_lt[ i ].dwParam1 =
                pLine->Line.dwLineID;
            pControl->Parameters.lpmcd_lt[ i ].dwParam2 =
                pLine->Line.dwComponentType;
        }

    }
}


///////////////////////////////////////////////////////////////////////
//
// kmxlAssignMuxIds
//
// Updates the source IDs stored in the MixerControlDetails array of
// the muxes and removes the muxes placed in lines as place holders.
//
//

NTSTATUS
kmxlAssignMuxIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST     listLines
)
{
    PMXLLINE pLine;
    PMXLCONTROL pControl;
    CONTROLLIST listControls = NULL;

    PAGED_CODE();
    pLine = kmxlFirstInList( listLines );
    while( pLine ) {

        //
        // Loop through the controls by removing them from the line's
        // control list and building a new control list.  This new
        // control list will have the extra mux controls removed.
        //

        pControl = kmxlRemoveFirstControl( pLine->Controls );
        while( pControl ) {

            if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUX ) ) {

                kmxlUpdateMuxLines( pLine, pControl );

                if( pControl->Parameters.bPlaceholder ) {

                    //
                    // This mux was here only to mark this line.  Free
                    // up only the control memory and leave the parameters
                    // memeory alone.
                    //

                    ASSERT( pControl->pChannelStepping == NULL);
                    AudioFreeMemory_Unknown( &pControl );
                    --pLine->Line.cControls;
                } else {

                    //
                    // This is a real mux control. Add it back into the
                    // list.
                    //

                    kmxlAddToEndOfList( listControls, pControl );
                }

            } else {

                //
                // Wasn't a mux.  Put it onto the end of the new control
                // list.

                kmxlAddToEndOfList( listControls, pControl );

            }

            //
            // Remove the next one!
            //

            pControl = kmxlRemoveFirstControl( pLine->Controls );
        }

        //
        // Reassign the new control list back into this line.
        //

        pLine->Controls = listControls;
        pLine = kmxlNextLine( pLine );
        listControls = NULL;
    }

    RETURN( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// TargetCommon
//
// Fills in the common fields of the target function.
//
//

VOID
TargetCommon(
    IN PMIXEROBJECT  pmxobj,
    IN PMXLLINE      pLine,
    IN DWORD         DeviceType
)
{
    PWDMACONTEXT pWdmaContext;
    PWAVEDEVICE  paWaveOutDevs, paWaveInDevs;
    PMIDIDEVICE  paMidiOutDevs, paMidiInDevs;
    ULONG    i;

    PAGED_CODE();
    pWdmaContext  = pmxobj->pMixerDevice->pWdmaContext;
    paWaveOutDevs = pWdmaContext->WaveOutDevs;
    paWaveInDevs  = pWdmaContext->WaveInDevs;
    paMidiOutDevs = pWdmaContext->MidiOutDevs;
    paMidiInDevs  = pWdmaContext->MidiInDevs;

    for( i = 0; i < MAXNUMDEVS; i++ ) {

        if( DeviceType == WaveOutDevice ) {

            if( (paWaveOutDevs[i].Device != UNUSED_DEVICE) &&
                !MyWcsicmp(pmxobj->DeviceInterface, paWaveOutDevs[ i ].DeviceInterface) ) {

                WAVEOUTCAPS wc;

                ((PWAVEOUTCAPSA)(PVOID)&wc)->wMid=UNICODE_TAG;

                wdmaudGetDevCaps( pWdmaContext, WaveOutDevice, i, (BYTE*) &wc, sizeof( WAVEOUTCAPS ) );
                wcsncpy( pLine->Line.Target.szPname, wc.szPname, MAXPNAMELEN );
                pLine->Line.Target.wMid           = wc.wMid;
                pLine->Line.Target.wPid           = wc.wPid;
                pLine->Line.Target.vDriverVersion = wc.vDriverVersion;
                return;

            }
        }

        if( DeviceType == WaveInDevice ) {

            if( (paWaveInDevs[i].Device != UNUSED_DEVICE) &&
                !MyWcsicmp(pmxobj->DeviceInterface, paWaveInDevs[ i ].DeviceInterface) ) {

                WAVEINCAPS wc;

                ((PWAVEINCAPSA)(PVOID)&wc)->wMid=UNICODE_TAG;

                wdmaudGetDevCaps( pWdmaContext, WaveInDevice, i, (BYTE*) &wc, sizeof( WAVEINCAPS ) );
                wcsncpy( pLine->Line.Target.szPname, wc.szPname, MAXPNAMELEN );
                pLine->Line.Target.wMid           = wc.wMid;
                pLine->Line.Target.wPid           = wc.wPid;
                pLine->Line.Target.vDriverVersion = wc.vDriverVersion;
                return;

            }

        }

        if( DeviceType == MidiOutDevice ) {

            if( (paMidiOutDevs[i].Device != UNUSED_DEVICE) &&
                !MyWcsicmp(pmxobj->DeviceInterface, paMidiOutDevs[ i ].DeviceInterface) ) {

                MIDIOUTCAPS mc;

                ((PMIDIOUTCAPSA)(PVOID)&mc)->wMid=UNICODE_TAG;

                wdmaudGetDevCaps( pWdmaContext, MidiOutDevice, i, (BYTE*) &mc, sizeof( MIDIOUTCAPS ) );
                wcsncpy( pLine->Line.Target.szPname, mc.szPname, MAXPNAMELEN );
                pLine->Line.Target.wMid           = mc.wMid;
                pLine->Line.Target.wPid           = mc.wPid;
                pLine->Line.Target.vDriverVersion = mc.vDriverVersion;
                return;
            }
        }

        if( DeviceType == MidiInDevice ) {

            if( (paMidiInDevs[i].Device != UNUSED_DEVICE) &&
                !MyWcsicmp(pmxobj->DeviceInterface, paMidiInDevs[ i ].DeviceInterface) ) {

                MIDIINCAPS mc;

                ((PMIDIINCAPSA)(PVOID)&mc)->wMid=UNICODE_TAG;

                wdmaudGetDevCaps( pWdmaContext, MidiInDevice, i, (BYTE*) &mc, sizeof( MIDIINCAPS ) );
                wcsncpy( pLine->Line.Target.szPname, mc.szPname, MAXPNAMELEN) ;
                pLine->Line.Target.wMid           = mc.wMid;
                pLine->Line.Target.wPid           = mc.wPid;
                pLine->Line.Target.vDriverVersion = mc.vDriverVersion;
                return;
            }
        }

    }

}

///////////////////////////////////////////////////////////////////////
//
// TargetTypeWaveOut
//
// Fills in the fields of aLine's target structure to be a waveout
// target.
//
//

VOID
TargetTypeWaveOut(
    IN PMIXEROBJECT pmxobj,
    IN PMXLLINE     pLine
)
{
    PAGED_CODE();
    pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_WAVEOUT;
    TargetCommon( pmxobj, pLine, WaveOutDevice );
}

///////////////////////////////////////////////////////////////////////
//
// TargetTypeWaveIn
//
// Fills in the fields of aLine's target structure to be a wavein
// target.
//
//

#define TargetTypeWaveIn( pmxobj, pLine )                             \
        (pLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_WAVEIN;    \
        (pLine)->Line.Target.wPid   = MM_MSFT_WDMAUDIO_WAVEIN;        \
        TargetCommon( pmxobj, pLine, WaveInDevice )

///////////////////////////////////////////////////////////////////////
//
// TargetTypeMidiOut
//
// Fills in the fields of aLine's target structure to be a midi out
// target.
//
//

#define TargetTypeMidiOut( pmxobj, pLine )                          \
        (pLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_MIDIOUT; \
        (pLine)->Line.Target.wPid   = MM_MSFT_WDMAUDIO_MIDIOUT;     \
        TargetCommon( pmxobj, pLine, MidiOutDevice )

///////////////////////////////////////////////////////////////////////
//
// TargetTypeMidiIn
//
// Fills in the fields of aLine's target structure to be a midi in
// target.
//
//


#define TargetTypeMidiIn( pmxobj, pLine )                             \
        (aLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_MIDIOUT;   \
        (aLine)->Line.Target.wPid   = MM_MSFT_WDMAUDIO_MIDIIN;        \
        TargetCommon( pmxobj, pLine, MidiInDevice )

///////////////////////////////////////////////////////////////////////
//
// TargetTypeAuxCD
//
// Fills in the fields of aLine's target structure to be a CD
// target.
//
//


#define TargetTypeAuxCD( pmxobj, pLine )                              \
        (pLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_AUX;       \
        TargetCommon( pmxobj, pLine, WaveOutDevice );   \
        (pLine)->Line.Target.wPid   = MM_MSFT_SB16_AUX_CD

///////////////////////////////////////////////////////////////////////
//
// TargetTypeAuxLine
//
// Fills in the fields of aLine's target structure to be a aux line
// target.
//
//


#define TargetTypeAuxLine( pmxobj, pLine )                         \
        (pLine)->Line.Target.dwType = MIXERLINE_TARGETTYPE_AUX;    \
        TargetCommon( pmxobj, pLine, WaveOutDevice );\
        (pLine)->Line.Target.wPid   = MM_MSFT_SB16_AUX_LINE

///////////////////////////////////////////////////////////////////////
//
// kmxlDetermineDestinationType
//
// Determines the destination and target types by using the Type
// GUID stored in the line structure.
//
//

ULONG
kmxlDetermineDestinationType(
    IN PMIXEROBJECT pmxobj,         // Instance data
    IN PMXLLINE     pLine           // The line to determine type of
)
{
    PAGED_CODE();
    //
    // Speaker type destinations
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_SPEAKER ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_DESKTOP_SPEAKER ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_ROOM_SPEAKER ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_COMMUNICATION_SPEAKER ) ) {

        TargetTypeWaveOut( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_DST_SPEAKERS );

    }

    //
    // WaveIn type destinations
    //

    if( IsEqualGUID( &pLine->Type, &KSCATEGORY_AUDIO )
        || IsEqualGUID( &pLine->Type, &PINNAME_CAPTURE )
        ) {

         TargetTypeWaveIn( pmxobj, pLine );
         return( MIXERLINE_COMPONENTTYPE_DST_WAVEIN );

    }

    //
    // Headphone destination
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_HEADPHONES ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO ) ) {

        TargetTypeWaveOut( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_DST_HEADPHONES );
    }

    //
    // Telephone destination
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_TELEPHONE       ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_PHONE_LINE      ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_DOWN_LINE_PHONE ) )
    {
        pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
        return( MIXERLINE_COMPONENTTYPE_DST_TELEPHONE );
    }

    //
    // Ambiguous destination type.  Figure out the destination type by looking
    // at the Communication.
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_ANALOG_CONNECTOR ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_SPDIF_INTERFACE ) ) {

        if (pLine->Communication == KSPIN_COMMUNICATION_BRIDGE) {
            TargetTypeWaveOut( pmxobj, pLine );
            return( MIXERLINE_COMPONENTTYPE_DST_SPEAKERS );
        } else {
            TargetTypeWaveIn( pmxobj, pLine );
            return( MIXERLINE_COMPONENTTYPE_DST_WAVEIN );
        }

    }

    //
    // Does not match the others.  Default to Undefined destination.
    //

    pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
    return( MIXERLINE_COMPONENTTYPE_DST_UNDEFINED );

}

///////////////////////////////////////////////////////////////////////
//
// kmxlDetermineSourceType
//
// Determines the destination and target types by using the Type
// GUID stored in the line structure.
//
//

ULONG
kmxlDetermineSourceType(
    IN PMIXEROBJECT pmxobj,         // Instance data
    IN PMXLLINE     pLine           // The line to determine type of
)
{
    PAGED_CODE();
    //
    // All microphone type sources are a microphone source.
    //

    //
    // We are only checking two microphone GUIDs here.  We may 
    // want to consider the rest of the microphone types in 
    // ksmedia.h
    //
    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_MICROPHONE ) 
        || IsEqualGUID( &pLine->Type, &KSNODETYPE_DESKTOP_MICROPHONE )
       ) 
    {

        TargetTypeWaveIn( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE );
    }

    //
    // Legacy audio connector and the speaker type sources represent a
    // waveout source.
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_LEGACY_AUDIO_CONNECTOR    )
        || IsEqualGUID( &pLine->Type, &KSNODETYPE_SPEAKER                )
        || IsEqualGUID( &pLine->Type, &KSCATEGORY_AUDIO                  )
        )
    {

        TargetTypeWaveOut( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT );
    }

    //
    // CD player is a compact disc source.
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_CD_PLAYER ) ) {

        TargetTypeAuxCD( pmxobj, pLine );
        pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
        return( MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC );

    }

    //
    // Synthesizer is a sythesizer source.
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_SYNTHESIZER ) ) {

        TargetTypeMidiOut( pmxobj, pLine );
        return( MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER );

    }

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_LINE_CONNECTOR ) ) {

        TargetTypeAuxLine( pmxobj, pLine );
        pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
        return( MIXERLINE_COMPONENTTYPE_SRC_LINE );

    }

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_PHONE_LINE      ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_TELEPHONE       ) ||
        IsEqualGUID( &pLine->Type, &KSNODETYPE_DOWN_LINE_PHONE ) )
    {
        pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
        return( MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE );
    }

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_ANALOG_CONNECTOR ) ) {
        //
        // Ambiguous src type.  Figure out the destination type by looking
        // at the Communication.
        //
        if (pLine->Communication == KSPIN_COMMUNICATION_BRIDGE) {
            TargetTypeWaveIn( pmxobj, pLine );
        }
        else {
            TargetTypeWaveOut( pmxobj, pLine );
        }
        return( MIXERLINE_COMPONENTTYPE_SRC_ANALOG );
    }

    //
    // Digital in/out (SPDIF) source
    //

    if( IsEqualGUID( &pLine->Type, &KSNODETYPE_SPDIF_INTERFACE ) ) {
        //
        // Ambiguous src type.  Figure out the destination type by looking
        // at the Communication.
        //
        if (pLine->Communication == KSPIN_COMMUNICATION_BRIDGE) {
            TargetTypeWaveIn( pmxobj, pLine );
        }
        else {
            TargetTypeWaveOut( pmxobj, pLine );
        }
        return( MIXERLINE_COMPONENTTYPE_SRC_DIGITAL );
    }

    //
    // All others are lumped under Undefined source.
    //

    pLine->Line.Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
    return( MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED );

}

///////////////////////////////////////////////////////////////////////
//
// PinCategoryToString
//
// Converts the Pin category GUIDs to a string.

#ifdef DEBUG
#pragma LOCKED_CODE
#endif

#define _EG_(x,y) if (IsEqualGUID( NodeType, &x)) { return y; }

const char*
PinCategoryToString
(
    IN CONST GUID* NodeType // The GUID to translate
)
{
    _EG_(KSNODETYPE_MICROPHONE,"Microphone");
    _EG_(KSNODETYPE_DESKTOP_MICROPHONE,"Desktop Microphone");
    _EG_(KSNODETYPE_SPEAKER,"Speaker");
    _EG_(KSNODETYPE_HEADPHONES,"Headphones");
    _EG_(KSNODETYPE_LEGACY_AUDIO_CONNECTOR,"Wave");
    _EG_(KSNODETYPE_CD_PLAYER,"CD Player");
    _EG_(KSNODETYPE_SYNTHESIZER,"Synthesizer");
    _EG_(KSCATEGORY_AUDIO,"Wave");
    _EG_(PINNAME_CAPTURE,"Wave In");
    _EG_(KSNODETYPE_LINE_CONNECTOR,"Aux Line");
    _EG_(KSNODETYPE_TELEPHONE,"Telephone");
    _EG_(KSNODETYPE_PHONE_LINE,"Phone Line");
    _EG_(KSNODETYPE_DOWN_LINE_PHONE,"Downline Phone");
    _EG_(KSNODETYPE_ANALOG_CONNECTOR,"Analog connector");

    //New debug names...
    _EG_(KSAUDFNAME_MONO_OUT,"Mono Out");
    _EG_(KSAUDFNAME_STEREO_MIX,"Stereo Mix");
    _EG_(KSAUDFNAME_MONO_MIX,"Mono Mix");
    _EG_(KSAUDFNAME_AUX,"Aux");
    _EG_(KSAUDFNAME_VIDEO,"Video");
    _EG_(KSAUDFNAME_LINE_IN,"Line In");

    DPF(DL_WARNING|FA_MIXER,("Path Trap send me GUID - dt %08X _GUID",NodeType) );
    return "Unknown Pin Category";
}

///////////////////////////////////////////////////////////////////////
//
// NodeTypeToString
//
// Converts a NodeType GUID to a string
//
//

const char*
NodeTypeToString
(
    IN CONST GUID* NodeType // The GUID to translate
)
{
   _EG_(KSNODETYPE_DAC,"DAC");
   _EG_(KSNODETYPE_ADC,"ADC");
   _EG_(KSNODETYPE_SRC,"SRC");
   _EG_(KSNODETYPE_SUPERMIX,"SuperMIX");
   _EG_(KSNODETYPE_SUM,"Sum");
   _EG_(KSNODETYPE_MUTE,"Mute");
   _EG_(KSNODETYPE_VOLUME,"Volume");
   _EG_(KSNODETYPE_TONE,"Tone");
   _EG_(KSNODETYPE_AGC,"AGC");
   _EG_(KSNODETYPE_DELAY,"Delay");
   _EG_(KSNODETYPE_LOUDNESS,"LOUDNESS");
   _EG_(KSNODETYPE_3D_EFFECTS,"3D Effects");
   _EG_(KSNODETYPE_DEV_SPECIFIC,"Dev Specific"); 
   _EG_(KSNODETYPE_STEREO_WIDE,"Stereo Wide");
   _EG_(KSNODETYPE_REVERB,"Reverb");
   _EG_(KSNODETYPE_CHORUS,"Chorus");
    _EG_(KSNODETYPE_ACOUSTIC_ECHO_CANCEL,"AEC");
   _EG_(KSNODETYPE_EQUALIZER,"Equalizer");
   _EG_(KSNODETYPE_MUX,"Mux");
   _EG_(KSNODETYPE_DEMUX,"Demux");
   _EG_(KSNODETYPE_STEREO_ENHANCE,"Stereo Enhance");
   _EG_(KSNODETYPE_SYNTHESIZER,"Synthesizer");
   _EG_(KSNODETYPE_PEAKMETER,"Peakmeter");
    _EG_(KSNODETYPE_LINE_CONNECTOR,"Line Connector");
   _EG_(KSNODETYPE_SPEAKER,"Speaker");
   _EG_(KSNODETYPE_DESKTOP_SPEAKER,"");
   _EG_(KSNODETYPE_ROOM_SPEAKER,"Room Speaker");
   _EG_(KSNODETYPE_COMMUNICATION_SPEAKER,"Communication Speaker");
   _EG_(KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER,"? Whatever...");
   _EG_(KSNODETYPE_HANDSET,"Handset");
   _EG_(KSNODETYPE_HEADSET,"Headset");
   _EG_(KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION,"Speakerphone no echo reduction");
   _EG_(KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE,"Echo Suppressing Speakerphone");
   _EG_(KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE,"Echo Canceling Speakerphone");
    _EG_(KSNODETYPE_CD_PLAYER,"CD Player");
   _EG_(KSNODETYPE_MICROPHONE,"Microphone");
   _EG_(KSNODETYPE_DESKTOP_MICROPHONE,"Desktop Microphone");
   _EG_(KSNODETYPE_PERSONAL_MICROPHONE,"Personal Microphone");
   _EG_(KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE,"Omni Directional Microphone");
   _EG_(KSNODETYPE_MICROPHONE_ARRAY,"Microphone Array");
   _EG_(KSNODETYPE_PROCESSING_MICROPHONE_ARRAY,"Processing Microphone Array");
    _EG_(KSNODETYPE_ANALOG_CONNECTOR,"Analog Connector");
   _EG_(KSNODETYPE_PHONE_LINE,"Phone Line");
   _EG_(KSNODETYPE_HEADPHONES,"Headphones");
   _EG_(KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO,"Head Mounted Display Audio");
    _EG_(KSNODETYPE_LEGACY_AUDIO_CONNECTOR,"Legacy Audio Connector");
//   _EG_(KSNODETYPE_SURROUND_ENCODER,"Surround Encoder");
   _EG_(KSNODETYPE_NOISE_SUPPRESS,"Noise Suppress");
   _EG_(KSNODETYPE_DRM_DESCRAMBLE,"DRM Descramble");
   _EG_(KSNODETYPE_SWMIDI,"SWMidi");
   _EG_(KSNODETYPE_SWSYNTH,"SWSynth");
   _EG_(KSNODETYPE_MULTITRACK_RECORDER,"Multitrack Recorder");
   _EG_(KSNODETYPE_RADIO_TRANSMITTER,"Radio Transmitter");
   _EG_(KSNODETYPE_TELEPHONE,"Telephone");

   _EG_(KSAUDFNAME_MONO_OUT,"Mono Out");
   _EG_(KSAUDFNAME_LINE_IN,"Line in");
   _EG_(KSAUDFNAME_VIDEO,"Video");
   _EG_(KSAUDFNAME_AUX,"Aux");
   _EG_(KSAUDFNAME_MONO_MIX,"Mono Mix");
   _EG_(KSAUDFNAME_STEREO_MIX,"Stereo Mix");

    _EG_(KSCATEGORY_AUDIO,"Audio");
    _EG_(PINNAME_VIDEO_CAPTURE,"Video Capture");

    DPF(DL_WARNING|FA_MIXER,("Path Trap send me GUID - dt %08X _GUID",NodeType) );
    return "Unknown NodeType";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\midi.c ===
/****************************************************************************
 *
 *   midi.c
 *
 *   Midi routines for wdmaud.sys
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *                S.Mohanraj (MohanS)
 *                M.McLaughlin (MikeM)
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmsys.h"

#define IRP_LATENCY_100NS   3000

//
// This is just a scratch location that is never used for anything
// but a parameter to core functions.  
//                
IO_STATUS_BLOCK gIoStatusBlock ;

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

ULONGLONG 
GetCurrentMidiTime()
{
    LARGE_INTEGER   liFrequency,liTime;

    PAGED_CODE();
    //  total ticks since system booted
    liTime = KeQueryPerformanceCounter(&liFrequency);

    //  Convert ticks to 100ns units using Ks macro
    //
    return (KSCONVERT_PERFORMANCE_TIME(liFrequency.QuadPart,liTime));
}

//
// This routine gives us a pMidiPin to play with.
//
NTSTATUS 
OpenMidiPin(
    PWDMACONTEXT        pWdmaContext,
    ULONG               DeviceNumber,
    ULONG               DataFlow      //DataFlow is either in or out.
)
{
    PMIDI_PIN_INSTANCE  pMidiPin = NULL;
    NTSTATUS            Status;
    PKSPIN_CONNECT      pConnect = NULL;
    PKSDATARANGE        pDataRange;
    PCONTROLS_LIST      pControlList = NULL;
    ULONG               Device;
    ULONG               PinId;


    PAGED_CODE();
    //
    // Because of the ZERO_FILL_MEMORY flag, are pMidiPin structure will come
    // back zero'd out.
    //
    Status = AudioAllocateMemory_Fixed(sizeof(MIDI_PIN_INSTANCE),
                                       TAG_Audi_PIN,
                                       ZERO_FILL_MEMORY,
                                       &pMidiPin);
    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    pMidiPin->dwSig           = MIDI_PIN_INSTANCE_SIGNATURE;
    pMidiPin->DataFlow        = DataFlow;
    pMidiPin->DeviceNumber    = DeviceNumber;
    pMidiPin->PinState        = KSSTATE_STOP;

    KeInitializeSpinLock( &pMidiPin->MidiPinSpinLock );

    KeInitializeEvent ( &pMidiPin->StopEvent,SynchronizationEvent,FALSE ) ;

    if( KSPIN_DATAFLOW_IN == DataFlow )
    {
        pMidiPin->pMidiDevice = &pWdmaContext->MidiOutDevs[DeviceNumber];

        if (NULL == pWdmaContext->MidiOutDevs[DeviceNumber].pMidiPin)
        {
            pWdmaContext->MidiOutDevs[DeviceNumber].pMidiPin = pMidiPin;
        }
        else
        {
            DPF(DL_TRACE|FA_MIDI, ("Midi device in use") );

            AudioFreeMemory( sizeof(MIDI_PIN_INSTANCE),&pMidiPin );
            Status =  STATUS_DEVICE_BUSY;
            goto exit;
        }
    } else {
        //
        // KSPIN_DATAFLOW_OUT
        //
        pMidiPin->pMidiDevice = &pWdmaContext->MidiInDevs[DeviceNumber];

        InitializeListHead(&pMidiPin->MidiInQueueListHead);

        KeInitializeSpinLock(&pMidiPin->MidiInQueueSpinLock);

        if (NULL == pWdmaContext->MidiInDevs[DeviceNumber].pMidiPin)
        {
            pWdmaContext->MidiInDevs[DeviceNumber].pMidiPin = pMidiPin;
        }
        else
        {
            AudioFreeMemory( sizeof(MIDI_PIN_INSTANCE),&pMidiPin );
            Status =  STATUS_DEVICE_BUSY;
            goto exit;
        }
    }

    //
    // We only support one midi client at a time, the check above will
    // only add this structure if there is not already one there.  If there
    // was something there already, we skip all the following code and 
    // go directly to the exit lable.  Thus, fGraphRunning must not be
    // set when we are here.
    //
    ASSERT( !pMidiPin->fGraphRunning );

    pMidiPin->fGraphRunning++;

    //
    // Because of the ZERO_FILL_MEMORY flag our pConnect structure will
    // come back all zero'd out.
    //
    Status = AudioAllocateMemory_Fixed(sizeof(KSPIN_CONNECT) + sizeof(KSDATARANGE),
                                       TAG_Audt_CONNECT,
                                       ZERO_FILL_MEMORY,
                                       &pConnect);
    if(!NT_SUCCESS(Status))
    {
        pMidiPin->fGraphRunning--;
        goto exit ;
    }

    pDataRange = (PKSDATARANGE)(pConnect + 1);

    PinId = pMidiPin->pMidiDevice->PinId;
    Device = pMidiPin->pMidiDevice->Device;

    pConnect->Interface.Set = KSINTERFACESETID_Standard ;
    pConnect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    pConnect->Medium.Set = KSMEDIUMSETID_Standard;
    pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
    pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    pConnect->Priority.PrioritySubClass = 1;
    pDataRange->MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
    pDataRange->SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
    pDataRange->Specifier = KSDATAFORMAT_SPECIFIER_NONE;
    pDataRange->FormatSize = sizeof( KSDATARANGE );
    pDataRange->Reserved = 0 ;

    Status = AudioAllocateMemory_Fixed((sizeof(CONTROLS_LIST) +
                                         ( (MAX_MIDI_CONTROLS - 1) * sizeof(CONTROL_NODE) ) ),
                                       TAG_AudC_CONTROL,
                                       ZERO_FILL_MEMORY,
                                       &pControlList) ;
    if(!NT_SUCCESS(Status))
    {
        pMidiPin->fGraphRunning--;
        AudioFreeMemory( sizeof(KSPIN_CONNECT) + sizeof(KSDATARANGE),&pConnect );
        goto exit ;
    }

    pControlList->Count = MAX_MIDI_CONTROLS ;
    pControlList->Controls[MIDI_CONTROL_VOLUME].Control = KSNODETYPE_VOLUME ;
    pMidiPin->pControlList = pControlList ;


    // Open a pin
    Status = OpenSysAudioPin(Device,
                             PinId,
                             pMidiPin->DataFlow,
                             pConnect,
                             &pMidiPin->pFileObject,
                             &pMidiPin->pDeviceObject,
                             pMidiPin->pControlList);

    AudioFreeMemory( sizeof(KSPIN_CONNECT) + sizeof(KSDATARANGE),&pConnect );

    if (!NT_SUCCESS(Status))
    {
        CloseMidiDevicePin(pMidiPin->pMidiDevice);
        goto exit ;
    }

    //
    // OpenSysAudioPin sets the file object in the pin.  Now that we have
    // successfully returned from the call, validate that we have non-NULL
    // items.
    //
    ASSERT(pMidiPin->pFileObject);
    ASSERT(pMidiPin->pDeviceObject);

    //
    //  For output we put the device in a RUN state on open
    //  For input we have to wait until the device gets told
    //     to start
    //
    if ( KSPIN_DATAFLOW_IN == pMidiPin->DataFlow )
    {
        Status = AttachVirtualSource(pMidiPin->pFileObject, pMidiPin->pMidiDevice->pWdmaContext->VirtualMidiPinId);

        if (NT_SUCCESS(Status))
        {
            Status = StateMidiOutPin(pMidiPin, KSSTATE_RUN);
        }

        if (!NT_SUCCESS(Status))
        {
            CloseMidiDevicePin(pMidiPin->pMidiDevice);
        }
    }
    else
    {
        //
        //  Pause will queue a bunch of IRPs
        //
        Status = StateMidiInPin(pMidiPin, KSSTATE_PAUSE);
        if (!NT_SUCCESS(Status))
        {
            CloseMidiDevicePin(pMidiPin->pMidiDevice);
        }
    }

exit:

    RETURN( Status );
}


//
// This routine is called from multiple places.  As long as it's not reentrant, it should be
// ok.  Should check for that.
//
// This routine gets called from RemoveDevNode.  RemoveDevNode gets called from user mode
// or from the ContextCleanup routine.  Both routines are in the global mutex.
//
VOID 
CloseMidiDevicePin(
    PMIDIDEVICE pMidiDevice
)
{
    PAGED_CODE();
    if (NULL != pMidiDevice->pMidiPin )
    {
        //
        // CloseMidiPin must not fail.
        //
        CloseMidiPin ( pMidiDevice->pMidiPin ) ;
        //
        // AudioFreeMemory Nulls out this memory location.
        //
        AudioFreeMemory( sizeof(MIDI_PIN_INSTANCE),&pMidiDevice->pMidiPin ) ;
    }
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//
// The idea behind this SpinLock is that we want to protect the NumPendingIos
// value in the Irp completion routine.  There, there is a preemption issue
// that we can't have an InterlockedIncrement or InterlockedDecrement interfer
// with.
//
void
LockedMidiIoCount(
    PMIDI_PIN_INSTANCE  pCurMidiPin,
    BOOL bIncrease
    )
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&pCurMidiPin->MidiPinSpinLock,&OldIrql);

    if( bIncrease )
        pCurMidiPin->NumPendingIos++;
    else 
        pCurMidiPin->NumPendingIos--;
    
    KeReleaseSpinLock(&pCurMidiPin->MidiPinSpinLock, OldIrql);
}

VOID 
FreeIrpMdls(
    PIRP pIrp
    )
{
    if (pIrp->MdlAddress != NULL)
    {
        PMDL Mdl, nextMdl;

        for (Mdl = pIrp->MdlAddress; Mdl != (PMDL) NULL; Mdl = nextMdl)
        {
            nextMdl = Mdl->Next;
            MmUnlockPages( Mdl );
            AudioFreeMemory_Unknown( &Mdl );
        }

        pIrp->MdlAddress = NULL;
    }
}


#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//
// This routine can not fail.  When it returns, pMidiPin will be freed.  
//
VOID 
CloseMidiPin(
    PMIDI_PIN_INSTANCE pMidiPin
)
{
    PMIDIINHDR pHdr;
    PMIDIINHDR pTemp;
    KSSTATE    State;

    PAGED_CODE();

    // This is designed to bring us back to square one, even
    // if we were not completely opened
    if( !pMidiPin->fGraphRunning )
    {
        ASSERT(pMidiPin->fGraphRunning == 1);
        return ;
    }

    pMidiPin->fGraphRunning--;

    // Close the file object (pMidiPin->pFileObject, if it exists)
    if(pMidiPin->pFileObject)
    {
        //
        //  For Midi Input we need to flush the queued up scratch IRPs by
        //  issuing a STOP command.
        //
        //  We don't want to do that for Midi Output because we might loose
        //  the "all notes off" sequence that needs to get to the device.
        //
        //  Regardless, in both cases we need to wait until we have
        //  compeletely flushed the device before we can close it.
        //
        if ( KSPIN_DATAFLOW_OUT == pMidiPin->DataFlow )
        {
            PLIST_ENTRY ple;

            //
            //  This is kind of a catch-22.  We need to release
            //  the mutex which was grabbed when we entered the
            //  ioctl dispatch routine to allow the midi input
            //  irps which are queued up in a work item waiting
            //  until the mutex is free in order to be send
            //  down to portcls.
            //
            WdmaReleaseMutex(pMidiPin->pMidiDevice->pWdmaContext);
 
            //
            // This loop removes an entry and frees it until the list is empty.
            //
            while((ple = ExInterlockedRemoveHeadList(&pMidiPin->MidiInQueueListHead,
                                                     &pMidiPin->MidiInQueueSpinLock)) != NULL) 
            {
                LPMIDIDATA              pMidiData;
                PIRP                    UserIrp;
                PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

                pHdr = CONTAINING_RECORD(ple,MIDIINHDR,Next);
                //
                //  Get into locals and zero out midi data
                //
                UserIrp             = pHdr->pIrp;
                pMidiData           = pHdr->pMidiData;
                pPendingIrpContext  = pHdr->pPendingIrpContext;
                ASSERT(pPendingIrpContext);
                RtlZeroMemory(pMidiData, sizeof(MIDIDATA));

                //
                //  unlock memory before completing the Irp
                //
                wdmaudUnmapBuffer(pHdr->pMdl);
                AudioFreeMemory_Unknown(&pHdr);

                //
                //  Now complete the Irp for wdmaud.drv to process
                //
                DPF(DL_TRACE|FA_MIDI, ("CloseMidiPin: Freeing pending UserIrp: 0x%08lx",UserIrp));
                wdmaudUnprepareIrp ( UserIrp,
                                     STATUS_CANCELLED,
                                     sizeof(DEVICEINFO),
                                     pPendingIrpContext );
            }
        }

        //
        // At this point we know that the list is empty, but there
        // still might be an Irp in the completion process.  We have
        // to call the standard wait routine to make sure it gets completed.
        //
        pMidiPin->StoppingSource = TRUE ;

        if ( KSPIN_DATAFLOW_OUT == pMidiPin->DataFlow )
        {            
            StatePin ( pMidiPin->pFileObject, KSSTATE_STOP, &pMidiPin->PinState ) ;
        }

        //
        // Need to wait for all in and out data to complete.
        //
        MidiCompleteIo( pMidiPin, FALSE );

        if ( KSPIN_DATAFLOW_OUT == pMidiPin->DataFlow )
        {
            //
            //  Grab back the mutex which was freed before we started
            //  waiting on the I/O to complete.
            //
            WdmaGrabMutex(pMidiPin->pMidiDevice->pWdmaContext);
        }

        CloseSysAudio(pMidiPin->pMidiDevice->pWdmaContext, pMidiPin->pFileObject);
        pMidiPin->pFileObject = NULL;
    } 


    //
    // AudioFreeMemory_Unknown Nulls out this location
    //
    AudioFreeMemory_Unknown ( &pMidiPin->pControlList ) ;
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA
//
// This is the IRP completion routine.
//
NTSTATUS 
WriteMidiEventCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
)
{
    KIRQL               OldIrql;
    PMIDI_PIN_INSTANCE  pMidiOutPin;

    pMidiOutPin = pStreamHeader->pMidiPin;

    if (pMidiOutPin)
    {
        KeAcquireSpinLock(&pMidiOutPin->MidiPinSpinLock,&OldIrql);
        //
        // One less Io packet outstanding, thus we always decrement the 
        // outstanding count.  Then, we compare to see if we're the last
        // packet and we're stopping then we signal the saiting thead.
        //
        if( ( 0 == --pMidiOutPin->NumPendingIos ) && pMidiOutPin->StoppingSource )
        {
            KeSetEvent ( &pMidiOutPin->StopEvent, 0, FALSE ) ;
        }

        //
        // Upon releasing this spin lock pMidiOutPin will no longer be valid.  
        // Thus we must not touch it.
        //
        KeReleaseSpinLock(&pMidiOutPin->MidiPinSpinLock,OldIrql);
    }

    //
    // If there are any Mdls, free them here otherwise IoCompleteRequest will do it after the
    // freeing of our data buffer below.
    //
    FreeIrpMdls(pIrp);
    AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);
    return STATUS_SUCCESS;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA


NTSTATUS 
WriteMidiEventPin(
    PMIDIDEVICE pMidiOutDevice,
    ULONG       ulEvent
)
{
    PKSMUSICFORMAT      pMusicFormat;
    PSTREAM_HEADER_EX   pStreamHeader = NULL;
    PMIDI_PIN_INSTANCE  pMidiPin;
    NTSTATUS            Status = STATUS_SUCCESS;
    BYTE                bEvent;
    ULONG               TheEqualizer;
    ULONGLONG           nsPlayTime;
    KEVENT              keEventObject;
    PWDMACONTEXT        pWdmaContext;

    PAGED_CODE();
    pMidiPin = pMidiOutDevice->pMidiPin;

    if (!pMidiPin ||!pMidiPin->fGraphRunning || !pMidiPin->pFileObject )
    {
        DPF(DL_WARNING|FA_MIDI,("Not ready pMidiPin=%X",pMidiPin) );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    //
    // allocate enough memory for the stream header
    // the midi/music header, the data, the work item,
    // and the DeviceNumber.  The memroy allocation
    // is zero'd with the ZERO_FILL_MEMORY flag
    //
    Status = AudioAllocateMemory_Fixed(sizeof(STREAM_HEADER_EX) + sizeof(KSMUSICFORMAT) +
                                           sizeof(ULONG),
                                       TAG_Audh_STREAMHEADER,
                                       ZERO_FILL_MEMORY,
                                       &pStreamHeader);   // ulEvent

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    // Get a pointer to the music header
    pMusicFormat = (PKSMUSICFORMAT)(pStreamHeader + 1);

    // Play 0 ms from the time-stamp in the KSSTREAM_HEADER
    pMusicFormat->TimeDeltaMs = 0;
    RtlCopyMemory((BYTE *)(pMusicFormat + 1), // the actual data
                  &ulEvent,
                  sizeof(ulEvent));

    // setup the stream header
    pStreamHeader->Header.Data = pMusicFormat;

    pStreamHeader->Header.FrameExtent  = sizeof(KSMUSICFORMAT) + sizeof(ULONG);
    pStreamHeader->Header.Size = sizeof( KSSTREAM_HEADER );
    pStreamHeader->Header.DataUsed     = pStreamHeader->Header.FrameExtent;

    nsPlayTime = GetCurrentMidiTime() - pMidiPin->LastTimeNs + IRP_LATENCY_100NS;
    pStreamHeader->Header.PresentationTime.Time        = nsPlayTime;
    pStreamHeader->Header.PresentationTime.Numerator   = 1;
    pStreamHeader->Header.PresentationTime.Denominator = 1;

    pStreamHeader->pMidiPin = pMidiPin;

    //
    // Figure out how many bytes in this
    // event are valid.
    //
    bEvent = (BYTE)ulEvent;
    TheEqualizer = 0;
    if(!IS_STATUS(bEvent))
    {
        if (pMidiPin->bCurrentStatus)
        {
            bEvent = pMidiPin->bCurrentStatus;
            TheEqualizer = 1;
        }
        else
        {
            // Bad MIDI Stream didn't have a running status
            DPF(DL_WARNING|FA_MIDI,("No running status") );
            AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);
            RETURN( STATUS_UNSUCCESSFUL );
        }
    }

    if(IS_SYSTEM(bEvent))
    {
        if( IS_REALTIME(bEvent)    ||
            bEvent == MIDI_TUNEREQ ||
            bEvent == MIDI_SYSX    ||
            bEvent == MIDI_EOX )
        {
            pMusicFormat->ByteCount = 1;
        }
        else if(bEvent == MIDI_SONGPP)
        {
            pMusicFormat->ByteCount = 3;
        }
        else
        {
            pMusicFormat->ByteCount = 2;
        }
    }
    // Check for three byte messages
    else if((bEvent < MIDI_PCHANGE) || (bEvent >= MIDI_PBEND))
    {
        pMusicFormat->ByteCount = 3 - TheEqualizer;
    }
    else
    {
        pMusicFormat->ByteCount = 2 - TheEqualizer;
    }

    //
    //  Cache the running status
    //
    if ( (bEvent >= MIDI_NOTEOFF) && (bEvent < MIDI_CLOCK) )
    {
        pMidiPin->bCurrentStatus = (BYTE)((bEvent < MIDI_SYSX) ? bEvent : 0);
    }

    //
    // Initialize our wait event, in case we need to wait.
    //
    KeInitializeEvent(&keEventObject,
                      SynchronizationEvent,
                      FALSE);

    LockedMidiIoCount(pMidiPin,INCREASE);

    //
    //  Need to release the mutex so that during full-duplex
    //  situations, we can get the midi input buffers down
    //  to the device without blocking.
    //
    pWdmaContext = pMidiPin->pMidiDevice->pWdmaContext;
    WdmaReleaseMutex(pWdmaContext);

    // Set the packet to the device.
    Status = KsStreamIo(
        pMidiPin->pFileObject,
        &keEventObject,         // Event
        NULL,                   // PortContext
        WriteMidiEventCallBack,
        pStreamHeader,              // CompletionContext
        KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
        &gIoStatusBlock,
        pStreamHeader,
        sizeof( KSSTREAM_HEADER ),
        KSSTREAM_WRITE | KSSTREAM_SYNCHRONOUS,
        KernelMode
    );

    if ( (Status != STATUS_PENDING) && (Status != STATUS_SUCCESS) )
    {
        DPF(DL_WARNING|FA_MIDI, ("KsStreamIO failed: 0x%08lx",Status));
    }

    //
    // Wait a minute here!!!  If the Irp comes back pending, we
    // can NOT complete our user mode Irp!  But, there is no
    // infastructure for storing the Irp in this call stack.  The
    // other routines use wdmaudPrepareIrp to complete that user
    // Irp.  Also, pPendingIrpContext is stored in the Irp context
    // so that the completion routine has the list to get the
    // user mode Irp from.
    //
    // .... Or, we need to make this routine synchronous and 
    // wait like WriteMidiOutPin.  I believe that this is bug
    // #551052.  It should be fixed eventually.
    //
    //
    // Here is the fix.  Wait if it is pending.
    //
    if ( STATUS_PENDING == Status )
    {
        //
        // Wait for the completion.
        //
        Status = KeWaitForSingleObject( &keEventObject,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER) NULL );
    }
    //
    //  Now grab the mutex again
    //
    WdmaGrabMutex(pWdmaContext);

    RETURN( Status );
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//
// This is an IRP completion routine.
//
NTSTATUS 
WriteMidiCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
)
{
    //
    // If there are any Mdls, free them here otherwise IoCompleteRequest will do it after the
    // freeing of our data buffer below.
    //
    FreeIrpMdls(pIrp);
    //
    // Cleanup after this synchronous write
    //
    AudioFreeMemory_Unknown(&pStreamHeader->Header.Data);  // Music data

    wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
    AudioFreeMemory_Unknown(&pStreamHeader->pMidiHdr);

    AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);
    return STATUS_SUCCESS;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS 
WriteMidiOutPin(
    LPMIDIHDR           pMidiHdr,
    PSTREAM_HEADER_EX   pStreamHeader,
    BOOL               *pCompletedIrp
)
{
    NTSTATUS       Status = STATUS_INVALID_DEVICE_REQUEST;
    PKSMUSICFORMAT pMusicFormat = NULL;
    KEVENT         keEventObject;
    ULONG          AlignedLength;
    ULONGLONG      nsPlayTime;
    PMIDI_PIN_INSTANCE  pMidiPin;
    PWDMACONTEXT   pWdmaContext;

    PAGED_CODE();

    pMidiPin = pStreamHeader->pMidiPin;

    if (!pMidiPin ||!pMidiPin->fGraphRunning || !pMidiPin->pFileObject )
    {
        DPF(DL_WARNING|FA_MIDI,("Not Ready") );
        wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
        AudioFreeMemory_Unknown( &pMidiHdr );
        AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    //
    //  FrameExtent contains dwBufferLength right now
    //
    AlignedLength = ((pStreamHeader->Header.FrameExtent + 3) & ~3);

    Status = AudioAllocateMemory_Fixed(sizeof(KSMUSICFORMAT) + AlignedLength,
                                       TAG_Audm_MUSIC,
                                       ZERO_FILL_MEMORY,
                                       &pMusicFormat);

    if(!NT_SUCCESS(Status))
    {
        wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
        AudioFreeMemory_Unknown( &pMidiHdr );
        AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
        return Status;
    }

    // Play 0 ms from the time-stamp in the KSSTREAM_HEADER
    pMusicFormat->TimeDeltaMs = 0;

    //
    //  the system mapped data was stored in the data field
    //  of the stream header
    //
    RtlCopyMemory((BYTE *)(pMusicFormat + 1), // the actual data
                  pStreamHeader->Header.Data,
                  pStreamHeader->Header.FrameExtent);

    //
    // Setup the number of bytes of midi data we're sending
    //
    pMusicFormat->ByteCount = pStreamHeader->Header.FrameExtent;

    // setup the stream header
    pStreamHeader->Header.Data        = pMusicFormat;

    // Now overwrite FrameExtent with the correct rounded up dword aligned value
    pStreamHeader->Header.FrameExtent = sizeof(KSMUSICFORMAT) + AlignedLength;
    pStreamHeader->Header.OptionsFlags= 0;
    pStreamHeader->Header.Size = sizeof( KSSTREAM_HEADER );
    pStreamHeader->Header.TypeSpecificFlags = 0;
    pStreamHeader->Header.DataUsed    = pStreamHeader->Header.FrameExtent;
    pStreamHeader->pMidiHdr           = pMidiHdr;

    nsPlayTime = GetCurrentMidiTime() - pStreamHeader->pMidiPin->LastTimeNs + IRP_LATENCY_100NS;
    pStreamHeader->Header.PresentationTime.Time        = nsPlayTime;
    pStreamHeader->Header.PresentationTime.Numerator   = 1;
    pStreamHeader->Header.PresentationTime.Denominator = 1;

    //
    // Initialize our wait event, in case we need to wait.
    //
    KeInitializeEvent(&keEventObject,
                      SynchronizationEvent,
                      FALSE);

    //
    //  Need to release the mutex so that during full-duplex
    //  situations, we can get the midi input buffers down
    //  to the device without blocking.
    //
    pWdmaContext = pMidiPin->pMidiDevice->pWdmaContext;
    WdmaReleaseMutex(pWdmaContext);

    // Send the packet to the device.
    Status = KsStreamIo(
        pMidiPin->pFileObject,
        &keEventObject,             // Event
        NULL,                       // PortContext
        WriteMidiCallBack,
        pStreamHeader,              // CompletionContext
        KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
        &gIoStatusBlock,
        &pStreamHeader->Header,
        sizeof( KSSTREAM_HEADER ),
        KSSTREAM_WRITE | KSSTREAM_SYNCHRONOUS,
        KernelMode
    );

    //
    // Wait if it is pending.
    //
    if ( STATUS_PENDING == Status )
    {

        //
        // Wait for the completion.
        //
        Status = KeWaitForSingleObject( &keEventObject,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        (PLARGE_INTEGER) NULL );
    }
    //
    // From the Wait above, we can see that this routine is
    // always synchronous.  Thus, any Irp that we passed down
    // in the KsStreamIo call will have been completed and KS
    // will have signaled keEventObject.  Thus, we can 
    // now complete our Irp.  
    //
    // ... Thus we leave pCompletedIrp set to FALSE.
    //

    //
    //  Now grab the mutex again
    //
    WdmaGrabMutex(pWdmaContext);

    RETURN( Status );
}

NTSTATUS 
ResetMidiInPin(
    PMIDI_PIN_INSTANCE pMidiPin
)
{
    NTSTATUS    Status;

    PAGED_CODE();

    if (!pMidiPin || !pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Not Ready") );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    Status = StateMidiInPin ( pMidiPin, KSSTATE_PAUSE );

    RETURN( Status );
}

NTSTATUS 
StateMidiOutPin(
    PMIDI_PIN_INSTANCE pMidiPin,
    KSSTATE State
)
{
    NTSTATUS  Status;

    PAGED_CODE();

    if (!pMidiPin || !pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Not Ready") );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    if (State == KSSTATE_RUN)
    {
        pMidiPin->LastTimeNs = GetCurrentMidiTime();
    }
    else if (State == KSSTATE_STOP)
    {
        pMidiPin->LastTimeNs = 0;
    }

    Status = StatePin ( pMidiPin->pFileObject, State, &pMidiPin->PinState ) ;

    RETURN( Status );
}

//
// Waits for all the Irps to complete.
//
void
MidiCompleteIo(
    PMIDI_PIN_INSTANCE pMidiPin,
    BOOL Yield
    )
{
    PAGED_CODE();

    if ( pMidiPin->NumPendingIos )
    {
        DPF(DL_TRACE|FA_MIDI, ("Waiting on %d I/Os to flush Midi device",
                                      pMidiPin->NumPendingIos ));
        if( Yield )
        {
            //
            //  This is kind of a catch-22.  We need to release
            //  the mutex which was grabbed when we entered the
            //  ioctl dispatch routine to allow the midi input
            //  irps which are queued up in a work item waiting
            //  until the mutex is free in order to be send
            //  down to portcls.
            //
            WdmaReleaseMutex(pMidiPin->pMidiDevice->pWdmaContext);

        }
        //
        // Wait for all the Irps to complete.  The last one will
        // signal us to wake.
        //
        KeWaitForSingleObject ( &pMidiPin->StopEvent,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL ) ;

        if( Yield )
        {
            WdmaGrabMutex(pMidiPin->pMidiDevice->pWdmaContext);
        }

        DPF(DL_TRACE|FA_MIDI, ("Done waiting to flush Midi device"));
    }

    //
    // Why do we have this?
    //
    KeClearEvent ( &pMidiPin->StopEvent );

    //
    // All the IRPs have completed. We now restore the StoppingSource
    // variable so that we can recycle the pMidiPin.
    //
    pMidiPin->StoppingSource = FALSE;

}
//
// If the driver failed the KSSTATE_STOP request, we return that error
// code to the caller.
//
NTSTATUS 
StopMidiPinAndCompleteIo(
    PMIDI_PIN_INSTANCE pMidiPin,
    BOOL Yield
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    //
    // Indicate to the completion routine that we are stopping now.
    //
    pMidiPin->StoppingSource = TRUE;

    //
    // Tell the driver to stop.  Regardless, we will wait for the 
    // IRPs to complete if there are any outstanding.
    //
    Status = StatePin( pMidiPin->pFileObject, KSSTATE_STOP, &pMidiPin->PinState ) ;
    //
    // NOTE: On success, the pMidiPin->PinState value will be
    // KSSTATE_STOP.  On Error it will be the old state.
    //
    // This raises the question - Do we hang on failure?
    //
    MidiCompleteIo( pMidiPin,Yield );

    return Status;
}

NTSTATUS
StateMidiInPin(
    PMIDI_PIN_INSTANCE pMidiPin,
    KSSTATE State
)
{
    NTSTATUS           Status;

    PAGED_CODE();

    if (!pMidiPin || !pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Not Ready") );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    //
    //  We need to complete any pending SysEx buffers on a midiInStop
    //
    //
    // Here, if we're asked to go to the paused state and we're not
    // already in the paused state, we have to go through a stop.
    // Thus we stop the driver, wait for it to complete all the outstanding
    // IRPs and then place the driver in pause and place buffers
    // down on it again.
    //
    if( (KSSTATE_PAUSE == State) &&
        (KSSTATE_PAUSE != pMidiPin->PinState) )
    {
        Status = StopMidiPinAndCompleteIo(pMidiPin,TRUE);

        //
        // If we were successful at stopping the driver, we set
        // the pin back up in the pause state.
        //
        if (NT_SUCCESS(Status))
        {
            ULONG BufferCount;

            //
            // Put the driver back in the pause state.
            //
            Status = StatePin ( pMidiPin->pFileObject, State, &pMidiPin->PinState ) ;

            if (NT_SUCCESS(Status))
            {
                //
                // This loop places STREAM_BUFFERS (128) of them down on the
                // device.  NumPendingIos should be 128 when this is done.
                //
                for (BufferCount = 0; BufferCount < STREAM_BUFFERS; BufferCount++)
                {
                    Status = ReadMidiPin( pMidiPin );
                    if (!NT_SUCCESS(Status))
                    {
                        CloseMidiPin( pMidiPin );
                        //
                        // Appears that this error path is not correct.  If we
                        // call CloseMidiPin fGraphRunning will get reduced to 0.
                        // Then, on the next close call CloseMidiPin will assert
                        // because the pin is not running.  We need to be able to
                        // error out of this path without messing up the fGraphRunning
                        // state.
                        //
                        DPFBTRAP();
                        break;
                    }
                }
            }
        }

    } else {

        //
        // Else we're not going to the pause state, so just make the state
        // change.
        //
        Status = StatePin ( pMidiPin->pFileObject, State, &pMidiPin->PinState ) ;
    }

    RETURN( Status );
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA


NTSTATUS 
ReadMidiCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
)
{
    WRITE_CONTEXT       *pwc;
    PMIDI_PIN_INSTANCE  pMidiInPin;
    PMIDIINHDR          pMidiInHdr;
    PKSMUSICFORMAT      IrpMusicHdr;
    ULONG               IrpDataLeft;
    LPBYTE              IrpData;
    ULONG               RunningTimeMs;
    BOOL                bResubmit = TRUE;
    BOOL                bDataError = FALSE;
    NTSTATUS            Status = STATUS_SUCCESS;
    KIRQL               OldIrql;
    PLIST_ENTRY         ple;

    DPF(DL_TRACE|FA_MIDI, ("Irp.Status = 0x%08lx",pIrp->IoStatus.Status));

    pMidiInPin = pStreamHeader->pMidiPin;

    //
    // No pin should ever be closed before all the Io comes back.  So
    // we'll sanity check that here.
    //
    ASSERT(pMidiInPin);

    if( pMidiInPin )
    {
        DPF(DL_TRACE|FA_MIDI, ("R%d: 0x%08x", pMidiInPin->NumPendingIos, pStreamHeader));

        //
        // This routine should do an ExInterlockedRemoveHeadList to get the
        // head of the list.
        //
        if((ple = ExInterlockedRemoveHeadList(&pMidiInPin->MidiInQueueListHead,
                                                 &pMidiInPin->MidiInQueueSpinLock)) != NULL) 
        {
            PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
            LPMIDIDATA              pMidiData;
            PIRP                    UserIrp;

            //
            // We have something to do.
            //
            pMidiInHdr = CONTAINING_RECORD(ple, MIDIINHDR, Next);

            //
            //  Pull some information into locals
            //
            IrpData             = (LPBYTE)((PKSMUSICFORMAT)(pStreamHeader->Header.Data) + 1);
            UserIrp             = pMidiInHdr->pIrp;
            pMidiData           = pMidiInHdr->pMidiData;
            pPendingIrpContext  = pMidiInHdr->pPendingIrpContext;
            ASSERT(pPendingIrpContext);

            //
            //  Let's see what we have here
            //
            DPF(DL_TRACE|FA_MIDI, ("IrpData = 0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
                                          *(LPBYTE)IrpData,*(LPBYTE)IrpData+1,*(LPBYTE)IrpData+2,
                                          *(LPBYTE)IrpData+3,*(LPBYTE)IrpData+4,*(LPBYTE)IrpData+5,
                                          *(LPBYTE)IrpData+6,*(LPBYTE)IrpData+7,*(LPBYTE)IrpData+8,
                                          *(LPBYTE)IrpData+9,*(LPBYTE)IrpData+10,*(LPBYTE)IrpData+11) );
            //
            //  Copy over the good stuff...
            //
            RtlCopyMemory(&pMidiData->StreamHeader,
                          &pStreamHeader->Header,
                          sizeof(KSSTREAM_HEADER));
            RtlCopyMemory(&pMidiData->MusicFormat,
                          pStreamHeader->Header.Data,
                          sizeof(KSMUSICFORMAT));
            RtlCopyMemory(&pMidiData->MusicData,
                          ((PKSMUSICFORMAT)(pStreamHeader->Header.Data) + 1),
                          3 * sizeof( DWORD )); // cheesy

            //
            //  unlock memory before completing the Irp
            //
            wdmaudUnmapBuffer(pMidiInHdr->pMdl);
            AudioFreeMemory_Unknown(&pMidiInHdr);

            //
            //  Now complete the Irp for wdmaud.drv to process
            //
            wdmaudUnprepareIrp( UserIrp,
                                pIrp->IoStatus.Status,
                                sizeof(MIDIDATA),
                                pPendingIrpContext );
        } else {
            //  !!! Break here to catch underflow !!!
            if (pIrp->IoStatus.Status == STATUS_SUCCESS)
            {
                DPF(DL_TRACE|FA_MIDI, ("!!! Underflowing MIDI Input !!!"));
                //_asm { int 3 };
            }
        }
    }
    //
    // If there are any Mdls, free them here otherwise IoCompleteRequest will do it after the
    // freeing of our data buffer below.
    //
    FreeIrpMdls(pIrp);

    AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);

    if(pMidiInPin)
    {
        KeAcquireSpinLock(&pMidiInPin->MidiPinSpinLock,&OldIrql);

        pMidiInPin->NumPendingIos--;

        if ( pMidiInPin->StoppingSource || (pIrp->IoStatus.Status == STATUS_CANCELLED) ||
             (pIrp->IoStatus.Status == STATUS_NO_SUCH_DEVICE) || (pIrp->Cancel) )
        {
            bResubmit = FALSE;

            if ( 0 == pMidiInPin->NumPendingIos )
            {
                 KeSetEvent ( &pMidiInPin->StopEvent, 0, FALSE ) ;
            }
        }
        //
        // We need to be careful about using pMidiPin after releasing the spinlock.
        // if we are closing down and the NumPendingIos goes to zero the pMidiPin
        // can be freed.  In that case we must not touch pMidiPin.  bResubmit
        // protects us below.
        //
        KeReleaseSpinLock(&pMidiInPin->MidiPinSpinLock, OldIrql);

        //
        //  Resubmit to keep the cycle going...and going. Note that bResubmit
        //  must be first in this comparison.  If bResubmit is FALSE, then pMidiInPin
        //  could be freed.  
        //
        if (bResubmit && pMidiInPin->fGraphRunning )
        {
            //
            // This call to ReadMidiPin causes wdmaud.sys to place another
            // buffer down on the device.  One call, one buffer.
            //
            ReadMidiPin(pMidiInPin);
        }
    }

    return STATUS_SUCCESS;
}

//
// Called from Irp completion routine, thus this code must be locked.
//
NTSTATUS 
ReadMidiPin(
    PMIDI_PIN_INSTANCE  pMidiPin
)
{
    PKSMUSICFORMAT      pMusicFormat;
    PSTREAM_HEADER_EX   pStreamHeader = NULL;
    PWORK_QUEUE_ITEM    pWorkItem;
    NTSTATUS            Status = STATUS_SUCCESS;

    DPF(DL_TRACE|FA_MIDI, ("Entered"));

    if (!pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Bad fGraphRunning") );
        RETURN( STATUS_DEVICE_NOT_READY );
    }

    Status = AudioAllocateMemory_Fixed(sizeof(STREAM_HEADER_EX) + sizeof(WORK_QUEUE_ITEM) +
                                          MUSICBUFFERSIZE,
                                       TAG_Audh_STREAMHEADER,
                                       ZERO_FILL_MEMORY,
                                       &pStreamHeader);

    if(!NT_SUCCESS(Status))
    {
        RETURN( Status );
    }

    pWorkItem = (PWORK_QUEUE_ITEM)(pStreamHeader + 1);

    pStreamHeader->Header.Size = sizeof( KSSTREAM_HEADER );
    pStreamHeader->Header.PresentationTime.Numerator   = 10000;
    pStreamHeader->Header.PresentationTime.Denominator = 1;

    pMusicFormat = (PKSMUSICFORMAT)((BYTE *)pWorkItem + sizeof(WORK_QUEUE_ITEM));
    pStreamHeader->Header.Data         = pMusicFormat;
    pStreamHeader->Header.FrameExtent  = MUSICBUFFERSIZE;

    pStreamHeader->pMidiPin = pMidiPin;

    ASSERT( pMidiPin->pFileObject );

    //
    // Increase the number of outstanding IRPs as we get ready to add
    // this one to the list.
    //
    LockedMidiIoCount( pMidiPin,INCREASE );
    ObReferenceObject( pMidiPin->pFileObject );

    Status = QueueWorkList( pMidiPin->pMidiDevice->pWdmaContext,
                            ReadMidiEventWorkItem,
                            pStreamHeader,
                            0 );
    if (!NT_SUCCESS(Status))
    {
        //
        // If the memory allocation fails in QueueWorkItem then it can fail.  We
        // will need to free our memory and unlock things.
        //
        LockedMidiIoCount(pMidiPin,DECREASE);
        ObDereferenceObject(pMidiPin->pFileObject);
        AudioFreeMemory( sizeof(STREAM_HEADER_EX),&pStreamHeader );
    }

    RETURN( Status );
}



#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA
//
// This is a work item that midi schedules.  Notice that the caller did a reference
// on the file object so that it would still be valid when we're here. We should never
// get called and find that the file object is invalid.  Same holds for the StreamHeader
// and the corresponding pMidiPin.
//
VOID 
ReadMidiEventWorkItem(
    PSTREAM_HEADER_EX   pStreamHeader,
    PVOID               NotUsed
)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PFILE_OBJECT    MidiFileObject;

    PAGED_CODE();

    ASSERT( pStreamHeader->pMidiPin->pFileObject );

    DPF(DL_TRACE|FA_MIDI, ("A%d: 0x%08x", pStreamHeader->pMidiPin->NumPendingIos, pStreamHeader));

    //
    // We need to store the MidiFileObject here because the pStreamHeader
    // will/may get freed during the KsStreamIo call.  Basically, when
    // you call KsStreamIo the Irp may get completed and the pStreamHeader
    // will get freed.  But, it's safe to store the file object because of
    // this reference count.
    //
    MidiFileObject = pStreamHeader->pMidiPin->pFileObject;

    Status = KsStreamIo(
        pStreamHeader->pMidiPin->pFileObject,
        NULL,                   // Event
        NULL,                   // PortContext
        ReadMidiCallBack,
        pStreamHeader,              // CompletionContext
        KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
        &gIoStatusBlock,
        &pStreamHeader->Header,
        sizeof( KSSTREAM_HEADER ),
        KSSTREAM_READ,
        KernelMode
    );

    //
    // We are done with the file object.
    //
    ObDereferenceObject( MidiFileObject );

    // WorkItem: shouldn't this be if( !NTSUCCESS(Status) )?
    if ( STATUS_UNSUCCESSFUL == Status )
        DPF(DL_WARNING|FA_MIDI, ("KsStreamIo failed2: Status = 0x%08lx", Status));

    //
    // Warning: If, for any reason, the completion routine is not called
    // for this Irp, wdmaud.sys will hang.  It's been discovered that 
    // KsStreamIo may error out in low memory conditions.  There is an
    // outstanding bug to address this.
    //

    return;
}

//
// pNewMidiHdr will always be valid.  The caller just allocated it!
//
NTSTATUS 
AddBufferToMidiInQueue(
    PMIDI_PIN_INSTANCE  pMidiPin,
    PMIDIINHDR          pNewMidiInHdr
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PMIDIINHDR  pTemp;

    PAGED_CODE();

    if (!pMidiPin || !pMidiPin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_MIDI,("Bad fGraphRunning") );
        RETURN( STATUS_DEVICE_NOT_READY ); 
    }

    DPF(DL_TRACE|FA_MIDI, ("received sysex buffer"));

    ExInterlockedInsertTailList(&pMidiPin->MidiInQueueListHead,
                                &pNewMidiInHdr->Next,
                                &pMidiPin->MidiInQueueSpinLock);

    Status = STATUS_PENDING;

    RETURN( Status );
}


VOID 
CleanupMidiDevices(
    IN  PWDMACONTEXT pWdmaContext
)
{
    DWORD               DeviceNumber;
    DWORD               DeviceType;
    PMIDI_PIN_INSTANCE  pMidiPin=NULL;

    PAGED_CODE();
    for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
    {
        for (DeviceType = MidiInDevice; DeviceType < MixerDevice; DeviceType++)
        {
            if (DeviceType == MidiInDevice)
            {
                pMidiPin = pWdmaContext->MidiInDevs[DeviceNumber].pMidiPin;
            }
            else if (DeviceType == MidiOutDevice)
            {
                pMidiPin = pWdmaContext->MidiOutDevs[DeviceNumber].pMidiPin;
            }
            else
            {
                ASSERT(!"CleanupMidiDevices: Out of range!");
            }

            if (pWdmaContext->apCommonDevice[DeviceType][DeviceNumber]->Device != UNUSED_DEVICE)
            {
                if (pMidiPin != NULL)
                {
                    NTSTATUS    Status;
                    KSSTATE     State;

                    StopMidiPinAndCompleteIo( pMidiPin, FALSE );

                    //
                    //  Probably redundant, but this frees memory associated
                    //  with the MIDI device.
                    //
                    if( DeviceType == MidiInDevice )
                    {
                        CloseMidiDevicePin(&pWdmaContext->MidiInDevs[DeviceNumber]);
                    }
                    if( DeviceType == MidiOutDevice )
                    {
                        CloseMidiDevicePin(&pWdmaContext->MidiOutDevs[DeviceNumber]);
                    }

                }  // end for active pins

            }  // end for valid Device

        } // end for DeviceTypes

    } // end for DeviceNumber

} // CleanupMidiDevices
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\kmxluser.c ===
//---------------------------------------------------------------------------
//
//  Module:   kmxluser.c
//
//  Description:
//    Contains the handlers for the ring 3 mixer line api functions.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          I N C L U D E S                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#include "WDMSYS.H"


FAST_MUTEX ReferenceCountMutex;
ULONG      ReferenceCount = 0;

#define NOT16( di ) if( di->dwFormat == ANSI_TAG ) DPF(DL_WARNING|FA_USER,("Invalid dwFormat.") );


#pragma PAGEABLE_CODE


///////////////////////////////////////////////////////////////////////
//
// kmxlInitializeMixer
//
// Queries SysAudio to find the number of devices and builds the mixer
// line structures for each of those devices.
//
//

NTSTATUS
kmxlInitializeMixer(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface,
    ULONG cDevices
)
{
    NTSTATUS     Status;
    ULONG        Device;
    BOOLEAN      Error = FALSE;
//    PFILE_OBJECT pfo;
    PMIXERDEVICE pmxd;

    PAGED_CODE();

    ExInitializeFastMutex( &ReferenceCountMutex );

    DPF(DL_TRACE|FA_USER, ("Found %d mixer devices for DI: %ls", cDevices, DeviceInterface));


    //
    // Current limitation is MAXNUMDEVS.  If more devices are supported
    // than that, limit it to the first MAXNUMDEVS.
    //

    if( cDevices > MAXNUMDEVS ) {
        cDevices = MAXNUMDEVS;
    }

    for( Device = 0; Device < cDevices; Device++ ) {

        DWORD TranslatedDeviceNumber;

        TranslatedDeviceNumber =
                  wdmaudTranslateDeviceNumber(pWdmaContext,
                                              MixerDevice,
                                              DeviceInterface,
                                              Device);

        if(TranslatedDeviceNumber == MAXULONG) {
             continue;
        }

        pmxd = &pWdmaContext->MixerDevs[ TranslatedDeviceNumber ];

        //
        // Open SysAudio
        //
        DPFASSERT(pmxd->pfo == NULL);

        pmxd->pfo = kmxlOpenSysAudio();
        if( pmxd->pfo == NULL ) {
            DPF(DL_WARNING|FA_USER,( "failed to open SYSAUDIO!" ) );
            RETURN( STATUS_UNSUCCESSFUL );
        }
        //
        // Set the current device instance in SysAudio.
        //

        Status = SetSysAudioProperty(
            pmxd->pfo,
            KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
            sizeof( pmxd->Device ),
            &pmxd->Device
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER, ( "failed to set SYSAUDIO device instance" ) );
//            DPF(DL_ERROR|FA_ALL,("If fo is NULL, we must exit here!") );
            kmxlCloseSysAudio( pmxd->pfo );
            pmxd->pfo=NULL;
            Error = TRUE;
        } else {

            //
            // Initialize the topology for this device
            //

            Status = kmxlInit( pmxd->pfo, pmxd );
            if( !NT_SUCCESS( Status ) ) {
                DPF(DL_WARNING|FA_USER, ( "failed to initialize topology for device %d (%x)!",
                                  TranslatedDeviceNumber, Status ) );
                Error = TRUE;
            } else {

                //
                // Here we want to optimize out the restoring of values on the mixer
                // device.  If we find that there is another mixer device in some
                // other open context, then we will NOT call kmxlRetrieveAll to
                // set the values on the device.
                //
                DPF(DL_TRACE|FA_USER,( "Looking for Mixer: %S",pmxd->DeviceInterface ) );

                if( !NT_SUCCESS(EnumFsContext( HasMixerBeenInitialized, pmxd, pWdmaContext )) )
                {
                    //
                    // Here we find that this device was not found, thus this is
                    // the first time through.  Set the defaults here.
                    //
                    DPF(DL_TRACE|FA_USER,( "Did not find Mixer - initializing: %S",pmxd->DeviceInterface ) );

                    kmxlRetrieveAll( pmxd->pfo, pmxd );
                } else {
                    DPF(DL_TRACE|FA_USER,( "Found Mixer: %S",pmxd->DeviceInterface ) );
                }
            }
        }
    }

    if( Error ) {
        RETURN( STATUS_UNSUCCESSFUL );
    } else {
        return( STATUS_SUCCESS );
    }
}

//
// This routine looks in the WDMACONTEXT structure to see if this mixer device
// has already been initialized.  It does this by walking the MixerDevice list and
// checking to see if there are any devices that match this mixer devices's
// DeviceInterface string.  If it finds that there is a match, it routines 
// STATUS_SUCCESS, else it returns STATUS_MORE_ENTRIES so that the enum function
// will call it again until the list is empty.
//
NTSTATUS
HasMixerBeenInitialized(
    PWDMACONTEXT pContext,
    PVOID pvoidRefData,
    PVOID pvoidRefData2
    )
{
    NTSTATUS     Status;
    PMIXERDEVICE pmxdMatch;
    PMIXERDEVICE pmxd;
    DWORD        TranslatedDeviceNumber;
    ULONG        Device;
    PWDMACONTEXT pCurContext;

    //
    // Default is that we did not find this entry in the list.
    //
    Status = STATUS_MORE_ENTRIES;
    //
    // The reference data is a PMIXERDEVICE.
    //
    pmxdMatch = (PMIXERDEVICE)pvoidRefData;
    pCurContext = (PWDMACONTEXT)pvoidRefData2;

    if( pCurContext != pContext )
    {
        for( Device = 0; Device < MAXNUMDEVS; Device++ ) 
        {
            //
            // If this mixer device translates, that means that it can
            // be found in this context.
            //
            TranslatedDeviceNumber =
                      wdmaudTranslateDeviceNumber(pContext,
                                                  MixerDevice,
                                                  pmxdMatch->DeviceInterface,
                                                  Device);

            //
            // If it doesn't, we'll keep looking.
            //
            if( MAXULONG != TranslatedDeviceNumber ) 
            {
                DPF(DL_TRACE|FA_USER,( "Found Mixer: %S",pmxdMatch->DeviceInterface ) );

                Status = STATUS_SUCCESS;
                break;
            }
        }
    } else {
        DPF(DL_TRACE|FA_USER,( "Same context: %x",pCurContext ) );
    }
    return Status;
}

///////////////////////////////////////////////////////////////////////
//
// kmxlOpenHandler
//
// Handles the MXDM_OPEN message.  Copies the callback info from the
// caller and opens an instance of SysAudio set to the device number
// the caller has selected.
//
//

NTSTATUS
kmxlOpenHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,      // Info structure
    IN LPVOID       DataBuffer       // Unused
)
{
    NTSTATUS       Status = STATUS_SUCCESS;
    PMIXERDEVICE   pmxd;

    PAGED_CODE();

    ASSERT( DeviceInfo );
    //
    // BUGBUG: we should not need this any more!
    //
    ASSERT( DeviceInfo->dwInstance == 0 );

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        goto exit;
    }
    DPF(DL_TRACE|FA_INSTANCE,( "param=( %d ) = pmxd = %X",
              DeviceInfo->DeviceNumber,pmxd));

    ExAcquireFastMutex( &ReferenceCountMutex );

    ++ReferenceCount;

    ExReleaseFastMutex( &ReferenceCountMutex );

    DeviceInfo->mmr = MMSYSERR_NOERROR;

exit:
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlCloseHandler
//
// Handles the MXDM_CLOSE message.  Clears the callback info and
// closes the handle to SysAudio.
//
//

NTSTATUS
kmxlCloseHandler(
    IN LPDEVICEINFO DeviceInfo,         // Info structure
    IN LPVOID       DataBuffer          // Unused
)
{
    PAGED_CODE();
    ASSERT( DeviceInfo );
    ASSERT( DeviceInfo->dwInstance );

    DPF(DL_TRACE|FA_INSTANCE,( "kmxlCloseHandler"));
    
    ExAcquireFastMutex( &ReferenceCountMutex );

    --ReferenceCount;

    ExReleaseFastMutex( &ReferenceCountMutex );

    DeviceInfo->mmr = MMSYSERR_NOERROR;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoHandler
//
// Handles the MXDM_GETLINEINFO message.  Determines which query
// is requested by looking at dwFlags and performs that query.
//
//

NTSTATUS
kmxlGetLineInfoHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer          // MIXERLINE(16) to fill
)
{
    MIXERLINE ml;

    PAGED_CODE();
    ASSERT( DeviceInfo );

    if( DataBuffer == NULL ) {
        DPF(DL_WARNING|FA_USER,( "DataBuffer is NULL" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    ml.cbStruct = sizeof( MIXERLINE );

    switch( DeviceInfo->dwFlags & MIXER_GETLINEINFOF_QUERYMASK ) {

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_COMPONENTTYPE:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   dwComponentType                                         //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.cbStruct        = sizeof( MIXERLINE );
            ml.dwComponentType = ( (LPMIXERLINE) DataBuffer) ->dwComponentType;

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoByComponent( %s )",
                    ComponentTypeToString( ml.dwComponentType ) ));

            return( kmxlGetLineInfoByComponent( pWdmaContext,
                                                DeviceInfo,
                                                DataBuffer,
                                                ml.dwComponentType
                                              )
                  );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_DESTINATION:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   dwDestination                                           //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.dwDestination = ( (LPMIXERLINE) DataBuffer)->dwDestination;
            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoById( S=%08X, D=%08X )",
                       -1, ml.dwDestination ));

            return( kmxlGetLineInfoByID( pWdmaContext,
                                         DeviceInfo,
                                         DataBuffer,
                                         (WORD) -1,
                                         (WORD) ml.dwDestination ) );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_LINEID:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   dwLineID                                                //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.dwLineID = ( (LPMIXERLINE) DataBuffer)->dwLineID;

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoById( S=%08X, D=%08X )",
                       HIWORD( ml.dwLineID ), LOWORD( ml.dwLineID ) ));

            return( kmxlGetLineInfoByID( pWdmaContext,
                                         DeviceInfo,
                                         DataBuffer,
                                         HIWORD( ml.dwLineID ),
                                         LOWORD( ml.dwLineID ) ) );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_SOURCE:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   dwSource                                                //
        //   dwDestination                                           //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.dwSource      = ( (LPMIXERLINE) DataBuffer)->dwSource;
            ml.dwDestination = ( (LPMIXERLINE) DataBuffer)->dwDestination;

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoById( S=%08X, D=%08X )",
                       ml.dwSource, ml.dwDestination ));

            return( kmxlGetLineInfoByID( pWdmaContext,
                                         DeviceInfo,
                                         DataBuffer,
                                         (WORD) ml.dwSource,
                                         (WORD) ml.dwDestination ) );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINEINFOF_TARGETTYPE:
        ///////////////////////////////////////////////////////////////
        // Valid fields:                                             //
        //   cbStruct                                                //
        //   Target.dwType                                           //
        //   Target.wMid                                             //
        //   Target.wPid                                             //
        //   Target.vDriverVersion                                   //
        //   Target.szPname                                          //
        ///////////////////////////////////////////////////////////////

            NOT16( DeviceInfo );
            ml.Target.dwType         = ((LPMIXERLINE) DataBuffer)->Target.dwType;

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineInfoByType( %x -- %s )",
                       ml.Target.dwType,
                       TargetTypeToString( ml.Target.dwType ) ));

            return( kmxlGetLineInfoByType( pWdmaContext,
                                           DeviceInfo,
                                           DataBuffer,
                                           ml.Target.dwType ) );

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            DPF(DL_WARNING|FA_USER,( "invalid flags ( %x )", DeviceInfo->dwFlags ));
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( STATUS_SUCCESS );
    }

    DPF(DL_WARNING|FA_USER,("Unmatched di->dwFlag") );
    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineControlsHandler
//
// Handles the MXDM_GETLINECONTROLS message.  Determines the query
// requested and finds the controls.
//
//

NTSTATUS
kmxlGetLineControlsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer,         // MIXERLINECONTROLS(16) to fill
    IN LPVOID       pamxctrl
)
{
    PMIXERDEVICE   pmxd;
    PMXLLINE       pLine;
    PMXLCONTROL    pControl;
    ULONG          Count;
    DWORD          dwLineID,
                   dwControlID,
                   dwControlType,
                   cControls,
                   cbmxctrl;

    PAGED_CODE();
    ASSERT( DeviceInfo );

    //
    // Check some pre-conditions so we don't blow up later.
    //

    if( DataBuffer == NULL ) {
        DPF(DL_WARNING|FA_USER,( "DataBuffer is NULL!" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pamxctrl == NULL ) {
        DPF(DL_WARNING|FA_USER,( "pamxctrl is NULL!" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( DeviceInfo->DeviceNumber > MAXNUMDEVS ) {
        DPF(DL_WARNING|FA_USER,( "device Id is invalid!" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    //
    // Get a instance reference
    //

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // Copy out some parameters necessary to find the controls
    //

    NOT16( DeviceInfo );
    dwLineID      = ((LPMIXERLINECONTROLS) DataBuffer)->dwLineID;
    dwControlID   = ((LPMIXERLINECONTROLS) DataBuffer)->dwControlID;
    dwControlType = ((LPMIXERLINECONTROLS) DataBuffer)->dwControlType;
    cControls     = ((LPMIXERLINECONTROLS) DataBuffer)->cControls;
    cbmxctrl      = ((LPMIXERLINECONTROLS) DataBuffer)->cbmxctrl;

    switch( DeviceInfo->dwFlags & MIXER_GETLINECONTROLSF_QUERYMASK ) {

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINECONTROLSF_ALL:
        ///////////////////////////////////////////////////////////////

            //
            // Find the line that matches the dwLineID field
            //

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineControls( ALL, %08X )",dwLineID ));

            pLine = kmxlFindLine( pmxd, dwLineID );
            if( pLine == NULL ) {
                DPF(DL_WARNING|FA_USER,( "ALL - invalid line Id %x!",dwLineID ));
                DeviceInfo->mmr = MIXERR_INVALLINE;
                return( STATUS_SUCCESS );
            }

            //
            // Loop through the controls, copying them into the user buffer.
            //

            Count = 0;
            pControl = kmxlFirstInList( pLine->Controls );
            while( pControl && Count < cControls ) {

                NOT16( DeviceInfo );
                RtlCopyMemory(
                    &((LPMIXERCONTROL) pamxctrl)[ Count ],
                    &pControl->Control,
                    min(cbmxctrl,sizeof(MIXERCONTROL)) );

                pControl = kmxlNextControl( pControl );
                ++Count;
            }

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            return( STATUS_SUCCESS );

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINECONTROLSF_ONEBYID:
        ///////////////////////////////////////////////////////////////

            pControl = kmxlFindControl( pmxd, dwControlID );
            pLine = kmxlFindLineForControl(
                    pControl,
                    pmxd->listLines
                    );
            if( pLine == NULL ) {
                DPF(DL_WARNING|FA_USER,( "ONEBYID - invalid control Id %x!", dwControlID ));
                DeviceInfo->mmr = MIXERR_INVALCONTROL;
                return( STATUS_SUCCESS );
            }

            DPF(DL_TRACE|FA_USER,( "kmxlGetLineControls( ONEBYID, Ctrl=%08X, Line=%08X )",
                       dwControlID, pLine->Line.dwLineID ));

            if( pControl ) {

                NOT16( DeviceInfo );
                RtlCopyMemory((LPMIXERLINECONTROLS) pamxctrl,
                              &pControl->Control,
                              min(cbmxctrl,sizeof(MIXERCONTROL)) );

                ((PMIXERLINECONTROLS) DataBuffer)->dwLineID =
                    (DWORD) pLine->Line.dwLineID;

                DeviceInfo->mmr = MMSYSERR_NOERROR;
                return( STATUS_SUCCESS );

            } else {
                DPF(DL_WARNING|FA_USER,( "ONEBYID - invalid dwControlID %08X!", dwControlID ));
                DeviceInfo->mmr = MIXERR_INVALCONTROL;
                return( STATUS_SUCCESS );
            }

        ///////////////////////////////////////////////////////////////
        case MIXER_GETLINECONTROLSF_ONEBYTYPE:
        ///////////////////////////////////////////////////////////////

            //
            // Find the line that matches the dwLineID field
            //

            pLine = kmxlFindLine( pmxd, dwLineID );
            if( pLine == NULL ) {
                DPF(DL_WARNING|FA_USER,( "ONEBYTYPE - invalid dwLineID %08X!", dwControlType ));
                DeviceInfo->mmr = MIXERR_INVALLINE;
                return( STATUS_SUCCESS );
            }

            DPF(DL_TRACE|FA_USER, ("kmxlGetLineControls( ONEBYTYPE, Type=%s, Line=%08X )",
                    ControlTypeToString( dwControlType ),
                    pLine->Line.dwLineID ));

            //
            // Now look through the controls and find the control that
            // matches the type the caller has passed.
            //

            pControl = kmxlFirstInList( pLine->Controls );
            while( pControl ) {

                if( pControl->Control.dwControlType == dwControlType )
                {

                    NOT16 ( DeviceInfo );
                    RtlCopyMemory((LPMIXERCONTROL) pamxctrl,
                                  &pControl->Control,
                                  min(cbmxctrl,sizeof(MIXERCONTROL)) );
                    DeviceInfo->mmr = MMSYSERR_NOERROR;
                    return( STATUS_SUCCESS );
                }

                pControl = kmxlNextControl( pControl );
            }

            DPF(DL_WARNING|FA_USER,( "(ONEBYTYPE,Type=%x,Line=%08X ) no such control type on line",
                             dwControlType, pLine->Line.dwLineID ));
            DeviceInfo->mmr = MIXERR_INVALCONTROL;
            return( STATUS_SUCCESS );

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            DPF(DL_WARNING|FA_USER,( "invalid flags %x",DeviceInfo->dwFlags ));
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( STATUS_SUCCESS );

    }
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlDetailsHandler
//
// Determines which control is being queried and calls the appropriate
// handler to perform the get property.
//
//

NTSTATUS
kmxlGetControlDetailsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info Structure
    IN LPVOID       DataBuffer,         // MIXERCONTROLDETAILS structure
    IN LPVOID       paDetails           // Flat pointer to details struct(s)
)
{
    LPMIXERCONTROLDETAILS pmcd     = (LPMIXERCONTROLDETAILS) DataBuffer;
    PMXLCONTROL           pControl;
    PMIXERDEVICE          pmxd;
    NTSTATUS              Status;
    PMXLLINE              pLine;

    PAGED_CODE();
    ASSERT( DeviceInfo );

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    pControl = kmxlFindControl( pmxd, pmcd->dwControlID );
    if( pControl == NULL ) {
        DPF(DL_WARNING|FA_USER,( "control %x not found",pmcd->dwControlID ));
        DeviceInfo->mmr = MIXERR_INVALCONTROL;
        return( STATUS_SUCCESS );
    }

    pLine = kmxlFindLineForControl(
        pControl,
        pmxd->listLines
        );
    if( pLine == NULL ) {
        DPF(DL_WARNING|FA_USER,( "invalid control id %x!",pmcd->dwControlID ));
        DeviceInfo->mmr = MIXERR_INVALCONTROL;
        return( STATUS_SUCCESS );
    }

    if( ( pControl->Control.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM ) &&
        ( pmcd->cChannels != 1 ) &&
        ( pControl->Control.dwControlType != MIXERCONTROL_CONTROLTYPE_MUX )) {
        DPF(DL_WARNING|FA_USER,( "incorrect cChannels ( %d ) on UNIFORM control %x!",
            pmcd->cChannels, pmcd->dwControlID  ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pmcd->cChannels > pLine->Line.cChannels ) {
        DPF(DL_WARNING|FA_USER,( "incorrect number of channels( %d )!",pmcd->cChannels ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pmcd->cMultipleItems != pControl->Control.cMultipleItems ) {
        DPF(DL_WARNING|FA_USER,( "incorrect number of items( %d )!",pmcd->cMultipleItems ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    switch( DeviceInfo->dwFlags & MIXER_GETCONTROLDETAILSF_QUERYMASK ) {

        ///////////////////////////////////////////////////////////////
        case MIXER_GETCONTROLDETAILSF_LISTTEXT:
        ///////////////////////////////////////////////////////////////

        {
            ULONG cMultipleItems;
            LPMIXERCONTROLDETAILS_LISTTEXT lplt;

            DPF(DL_TRACE|FA_USER,( "kmxlGetControlDetails( Ctrl=%d )",
                       pControl->Control.dwControlID ));

            NOT16( DeviceInfo );

            lplt = (LPMIXERCONTROLDETAILS_LISTTEXT) paDetails;
            for( cMultipleItems = 0;
                 cMultipleItems < pmcd->cMultipleItems;
                 cMultipleItems++ )
            {
                RtlCopyMemory(
                    &lplt[ cMultipleItems ],
                    &pControl->Parameters.lpmcd_lt[ cMultipleItems ],
                    sizeof( MIXERCONTROLDETAILS_LISTTEXT )
                    );
            }
        }

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            break;

        ///////////////////////////////////////////////////////////////
        case MIXER_GETCONTROLDETAILSF_VALUE:
        ///////////////////////////////////////////////////////////////

            switch( pControl->Control.dwControlType ) {

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_MIXER:
                ///////////////////////////////////////////////////////

                    DeviceInfo->mmr = MMSYSERR_NOTSUPPORTED;
                    DPF(DL_WARNING|FA_USER,( "mixers are not supported" ));
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_PEAKMETER:
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleGetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        MIXER_FLAG_SCALE
                        );
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_MUTE:
                ///////////////////////////////////////////////////////

                    if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUTE ) ) {
                        Status = kmxlHandleGetUnsigned(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            KSPROPERTY_AUDIO_MUTE,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            0
                            );
                    } else if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
                        Status = kmxlHandleGetMuteFromSuperMix(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            0
                            );
                    } else {
                        DPF(DL_WARNING|FA_USER,("Unmatched GUID") );
                    }
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_VOLUME:
                //////////////////////////////////////////////////////

                    #ifdef SUPERMIX_AS_VOL
                    if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_VOLUME ) ) {
                    #endif
                        Status = kmxlHandleGetUnsigned(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            pControl->PropertyId,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            MIXER_FLAG_SCALE
                            );
                    #ifdef SUPERMIX_AS_VOL
                    } else if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
                        Status = kmxlHandleGetVolumeFromSuperMix(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            MIXER_FLAG_SCALE
                            );

                    } else {
                        DPF(DL_WARNING|FA_USER,("Invalid GUID for Control.") );
                    }
                    #endif // SUPERMIX_AS_VOL
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_TREBLE:
                case MIXERCONTROL_CONTROLTYPE_BASS:
                ///////////////////////////////////////////////////////
                // These all take 32-bit parameters per channel but  //
                // need to be scale from dB to linear                //
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleGetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        MIXER_FLAG_SCALE
                        );
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_LOUDNESS:
                case MIXERCONTROL_CONTROLTYPE_ONOFF:
                case MIXERCONTROL_CONTROLTYPE_BOOLEAN:
                case MIXERCONTROL_CONTROLTYPE_MUX:
                case MIXERCONTROL_CONTROLTYPE_FADER:
                case MIXERCONTROL_CONTROLTYPE_BASS_BOOST:
                ///////////////////////////////////////////////////////
                // These all take up to 32-bit parameters per channel//
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleGetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        0
                        );
                    break;

                ///////////////////////////////////////////////////////
                default:
                ///////////////////////////////////////////////////////

                    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                    break;
            }
            break;

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            DeviceInfo->mmr = MMSYSERR_NOTSUPPORTED;
            break;
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlSetControlDetailsHandler
//
// Determines which control is being set and calls the appropriate
// handler to perform the set property.
//
//

NTSTATUS
kmxlSetControlDetailsHandler(
    IN PWDMACONTEXT pWdmaContext,
    IN OUT LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer,         // MIXERCONTROLDETAILS structure
    IN LPVOID       paDetails,          // Flat pointer to detail struct(s)
    IN ULONG        Flags
)
{
    LPMIXERCONTROLDETAILS pmcd     = (LPMIXERCONTROLDETAILS) DataBuffer;
    PMXLCONTROL           pControl;
    NTSTATUS              Status;
    PMIXERDEVICE          pmxd;
    PMXLLINE              pLine;

    PAGED_CODE();
    ASSERT( DeviceInfo );

    //
    // Get a instance reference
    //

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    pControl = kmxlFindControl( pmxd, pmcd->dwControlID );
    if( pControl == NULL ) {
        DPF(DL_WARNING|FA_USER,( "control %d not found",pmcd->dwControlID ));
        DeviceInfo->mmr = MIXERR_INVALCONTROL;
        return( STATUS_SUCCESS );
    }

    pLine = kmxlFindLineForControl(
        pControl,
        pmxd->listLines
        );
    if( pLine == NULL ) {
        DPF(DL_WARNING|FA_USER,( "invalid control id %d",pControl->Control.dwControlID ));
        DeviceInfo->mmr = MIXERR_INVALCONTROL;
        return( STATUS_SUCCESS );
    }

    if( ( pControl->Control.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM ) &&
        ( pmcd->cChannels != 1 ) &&
        ( pControl->Control.dwControlType != MIXERCONTROL_CONTROLTYPE_MUX )) {
        DPF(DL_WARNING|FA_USER,( "incorrect cChannels ( %d ) on UNIFORM control %d",
                         pmcd->cChannels,
                         pControl->Control.dwControlID ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pmcd->cChannels > pLine->Line.cChannels ) {
        DPF(DL_WARNING|FA_USER,( "incorrect number of channels ( %d ) on line %08x",
                         pmcd->cChannels,
                         pLine->Line.dwLineID ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    if( pmcd->cMultipleItems != pControl->Control.cMultipleItems ) {
        DPF(DL_WARNING|FA_USER,( "incorrect number of items ( %d ) on control %d ( %d )",
                         pmcd->cMultipleItems,
                         pControl->Control.dwControlID,
                         pControl->Control.cMultipleItems ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    switch( DeviceInfo->dwFlags & MIXER_SETCONTROLDETAILSF_QUERYMASK ) {

        ///////////////////////////////////////////////////////////////
        case MIXER_SETCONTROLDETAILSF_VALUE:
        ///////////////////////////////////////////////////////////////

            switch( pControl->Control.dwControlType ) {

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_MIXER:
                ///////////////////////////////////////////////////////

                    DeviceInfo->mmr = MMSYSERR_NOTSUPPORTED;
                    DPF(DL_WARNING|FA_USER,( "mixers are not supported" ));
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_PEAKMETER:
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleSetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        Flags | MIXER_FLAG_SCALE
                        );
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_MUTE:
                ///////////////////////////////////////////////////////

                    if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_MUTE ) ) {
                        Status = kmxlHandleSetUnsigned(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            KSPROPERTY_AUDIO_MUTE,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            Flags
                            );
                    } else if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
                        Status = kmxlHandleSetMuteFromSuperMix(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            Flags
                            );
                    } else {
                        DPF(DL_WARNING|FA_USER,("Invalid GUID for Control Type Mute.") );
                    }

                    kmxlNotifyLineChange(
                        DeviceInfo,
                        pmxd,
                        pLine,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails
                        );
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_VOLUME:
                ///////////////////////////////////////////////////////

                    #ifdef SUPERMIX_AS_VOL
                    if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_VOLUME ) ) {
                    #endif // SUPERMIX_AS_VOL
                        Status = kmxlHandleSetUnsigned(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            pControl->PropertyId,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            Flags | MIXER_FLAG_SCALE
                            );
                    #ifdef SUPERMIX_AS_VOL
                    } else if( IsEqualGUID( pControl->NodeType, &KSNODETYPE_SUPERMIX ) ) {
                        Status = kmxlHandleSetVolumeFromSuperMix(
                            DeviceInfo,
                            pmxd,
                            pControl,
                            (LPMIXERCONTROLDETAILS) DataBuffer,
                            (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                            Flags | MIXER_FLAG_SCALE
                            );
                    } else {
                        DPF(DL_WARNING|FA_USER,("Invalid GUID for Control Type Volume.") );
                    }
                    #endif
                    break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_TREBLE:
                case MIXERCONTROL_CONTROLTYPE_BASS:
                ///////////////////////////////////////////////////////
                // These all take 32-bit parameters per channel but  //
                // need to be scale from linear to dB                //
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleSetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        Flags | MIXER_FLAG_SCALE
                        );
                     break;

                ///////////////////////////////////////////////////////
                case MIXERCONTROL_CONTROLTYPE_LOUDNESS:
                case MIXERCONTROL_CONTROLTYPE_ONOFF:
                case MIXERCONTROL_CONTROLTYPE_BOOLEAN:
                case MIXERCONTROL_CONTROLTYPE_MUX:
                case MIXERCONTROL_CONTROLTYPE_FADER:
                case MIXERCONTROL_CONTROLTYPE_BASS_BOOST:
                ///////////////////////////////////////////////////////
                // These all take up to 32-bit parameters per channel//
                ///////////////////////////////////////////////////////

                    Status = kmxlHandleSetUnsigned(
                        DeviceInfo,
                        pmxd,
                        pControl,
                        pControl->PropertyId,
                        (LPMIXERCONTROLDETAILS) DataBuffer,
                        (LPMIXERCONTROLDETAILS_UNSIGNED) paDetails,
                        Flags
                        );
                    break;

                ///////////////////////////////////////////////////////
                default:
                ///////////////////////////////////////////////////////

                    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                    break;
            }
            break;

        ///////////////////////////////////////////////////////////////
        default:
        ///////////////////////////////////////////////////////////////

            DPF(DL_WARNING|FA_USER,( "invalid flags %x",DeviceInfo->dwFlags ));
            DeviceInfo->mmr = MMSYSERR_NOTSUPPORTED;
            break;
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFindControl
//
//

PMXLCONTROL
kmxlFindControl(
    IN PMIXERDEVICE pmxd,             // The mixer instance to search
    IN DWORD        dwControlID       // The control ID to find
)
{
    PMXLLINE    pLine;
    PMXLCONTROL pControl;

    PAGED_CODE();
    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {
            if( pControl->Control.dwControlID == dwControlID ) {
                return( pControl );
            }
            pControl = kmxlNextControl( pControl );
        }

        pLine = kmxlNextLine( pLine );
    }

    return( NULL );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFindLine
//
// For the given line ID, kmxlFindLine will find the matching
// MXLLINE structure for it.
//
//

PMXLLINE
kmxlFindLine(
    IN PMIXERDEVICE   pmxd,
    IN DWORD          dwLineID          // The line ID to find
)
{
    PMXLLINE pLine;

    PAGED_CODE();
    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        if( pLine->Line.dwLineID == dwLineID ) {
            return( pLine );
        }

        pLine = kmxlNextLine( pLine );
    }

    return( NULL );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByID
//
// Loops through the lines looking for a line that has a matching
// source and destination Id.
//
//

NTSTATUS
kmxlGetLineInfoByID(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer,         // MIXERLINE(16) structure
    IN WORD         Source,             // Source line id
    IN WORD         Destination         // Destination line id
)
{
    PMIXERDEVICE   pmxd;
    PMXLLINE       pLine;
    BOOL           bDestination;

    PAGED_CODE();

    ASSERT( DeviceInfo );
    ASSERT( DataBuffer );

    if( DeviceInfo->DeviceNumber > MAXNUMDEVS ) {
        DPF(DL_WARNING|FA_USER,( "invalid device number %d",DeviceInfo->DeviceNumber ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // If the source is -1 (0xFFFF), then this line is a destination.
    //

    if( Source == (WORD) -1 ) {
        bDestination = TRUE;
        Source       = 0;
    } else {
        bDestination = FALSE;
    }

    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        if( ( bDestination                                 &&
              ( pLine->Line.dwDestination == Destination ) &&
              ( pLine->Line.cConnections > 0             ) ) ||
            ( ( pLine->Line.dwSource      == Source )      &&
              ( pLine->Line.dwDestination == Destination ) ) )
        {

            NOT16( DeviceInfo );
            RtlCopyMemory((LPMIXERLINE) DataBuffer,
                          &pLine->Line,
                          sizeof( MIXERLINE ) );

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            return( STATUS_SUCCESS );
        }
        pLine = kmxlNextLine( pLine );
    }

    //
    // There are no lines for the device number.
    //

    DPF(DL_WARNING|FA_USER,( "no matching lines for (S=%08X, D=%08X)",
                     Source,
                     Destination ));
    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByType
//
// Loops through all the lines looking for the first line that matches
// the Target type specified. Note that this will always only find the
// first one!
//
//

NTSTATUS
kmxlGetLineInfoByType(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device info structure
    IN LPVOID       DataBuffer,         // MIXERLINE(16) structure
    IN DWORD        dwType              // Line type to search for
)
{
    PMXLLINE       pLine;
    PMIXERDEVICE   pmxd;

    PAGED_CODE();
    ASSERT( DeviceInfo );
    ASSERT( DataBuffer );

    if( DeviceInfo->DeviceNumber > MAXNUMDEVS ) {
        DPF(DL_WARNING|FA_USER,( "invalid device id %x",DeviceInfo->DeviceNumber ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // Loop through all the lines looking for a line that has the
    // specified target type.  Note that this will only return the
    // first one.
    //

    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        if( pLine->Line.Target.dwType == dwType ) {

            LPMIXERLINE lpMxl = (LPMIXERLINE) DataBuffer;
            NOT16( DeviceInfo );

            if( lpMxl->Target.wMid != pLine->Line.Target.wMid ) {
                DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                return( STATUS_SUCCESS );
            }

            if( lpMxl->Target.wPid != pLine->Line.Target.wPid ) {
                DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                return( STATUS_SUCCESS );
            }

            if( wcscmp( pLine->Line.Target.szPname, lpMxl->Target.szPname ) )
            {
                DeviceInfo->mmr = MMSYSERR_INVALPARAM;
                return( STATUS_SUCCESS );
            }

            RtlCopyMemory((LPMIXERLINE) DataBuffer,
                          &pLine->Line,
                          sizeof( MIXERLINE ) );

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            return( STATUS_SUCCESS );
        }
        pLine = kmxlNextLine( pLine );
    }

    //
    // The line was not found.  Return invalid parameter.
    //

    DPF(DL_WARNING|FA_USER,( "no matching line found for %x",dwType ));
    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetLineInfoByComponent
//
// Loops through the list of lines looking for a line that has a matching
// dwComponentType.  Note that this will always find only the first!
//
//

NTSTATUS
kmxlGetLineInfoByComponent(
    IN PWDMACONTEXT pWdmaContext,
    IN LPDEVICEINFO DeviceInfo,         // Device Info structure
    IN LPVOID       DataBuffer,         // MIXERLINE(16) structure
    IN DWORD        dwComponentType     // Component type to search for
)
{
    PMXLLINE       pLine;
    PMIXERDEVICE   pmxd;

    PAGED_CODE();
    ASSERT( DeviceInfo );
    ASSERT( DataBuffer );

    if( DeviceInfo->DeviceNumber > MAXNUMDEVS ) {
        DPF(DL_WARNING|FA_USER,( "invalid device id %x",DeviceInfo->DeviceNumber ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    pmxd = kmxlReferenceMixerDevice( pWdmaContext, DeviceInfo );
    if( pmxd == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // Loop through all the lines looking for a line that has a component
    // type matching what the user requested.
    //

    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        if( pLine->Line.dwComponentType == dwComponentType ) {

            //
            // Copy the data into the user buffer
            //
            NOT16( DeviceInfo );
            RtlCopyMemory((LPMIXERLINE) DataBuffer,
                          &pLine->Line,
                          sizeof( MIXERLINE ) );

            DeviceInfo->mmr = MMSYSERR_NOERROR;
            return( STATUS_SUCCESS );
        }

        pLine = kmxlNextLine( pLine );
    }

    DPF(DL_WARNING|FA_USER,( "no matching line found for type %x",dwComponentType ));
    DeviceInfo->mmr = MMSYSERR_INVALPARAM;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNumDestinations
//
// Returns the number of destinations stored in the mixer device
//
//

DWORD
kmxlGetNumDestinations(
    IN PMIXERDEVICE pMixerDevice        // The device
)
{
    PAGED_CODE();

    return( pMixerDevice->cDestinations );
}


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//               I N S T A N C E   R O U T I N E S                   //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// kmxlReferenceInstance
//
// Determines if the dwInstance field of the DeviceInfo structure
// is valid.  If not, it creates a valid instance and sets a
// reference count of 1 on it.
//
//

LONG nextinstanceid=0;

DWORD kmxlUniqueInstanceId(VOID)
{
    PAGED_CODE();
    // Update our next valid instance id.  Do NOT allow zero.
    // Since that is used to signal that we want to allocate
    // a new instance.
    if (0==InterlockedIncrement(&nextinstanceid))
        InterlockedIncrement(&nextinstanceid);

    return nextinstanceid;
}



/////////////////////////////////////////////////////////////////////////////
//
// kmxlReferenceMixerDevice
//
// This routine Translates the device number and makes sure that there is a
// open SysAudio PFILE_OBJECT in this mixier device.  This will be the FILE_OBJECT
// that we use to talk to this mixer device.
//
// return:  PMIXERDEVICE on success NULL otherwise.
//
PMIXERDEVICE
kmxlReferenceMixerDevice(
    IN     PWDMACONTEXT pWdmaContext,
    IN OUT LPDEVICEINFO DeviceInfo      // Device Information
)
{
    NTSTATUS       Status;
    DWORD          TranslatedDeviceNumber;
    PMIXERDEVICE   pmxd;


    PAGED_CODE();
    DPFASSERT(IsValidDeviceInfo(DeviceInfo));


    TranslatedDeviceNumber =
              wdmaudTranslateDeviceNumber(pWdmaContext,
                                          DeviceInfo->DeviceType,
                                          DeviceInfo->wstrDeviceInterface,
                                          DeviceInfo->DeviceNumber);

    if( TranslatedDeviceNumber == MAXULONG ) {
        DPF(DL_WARNING|FA_INSTANCE,("Could not translate DeviceNumber! DT=%08X, DI=%08X, DN=%08X",
                                    DeviceInfo->DeviceType,
                                    DeviceInfo->wstrDeviceInterface,
                                    DeviceInfo->DeviceNumber) );
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( NULL );
    }

    pmxd = &pWdmaContext->MixerDevs[ TranslatedDeviceNumber ];

    if( pmxd->pfo == NULL )
    {
        DPF(DL_WARNING|FA_NOTE,("pmxd->pfo should have been set!") );
        //
        // This is the first time through this code.  Open SysAudio on this device
        // and set the mixer device.
        //
        // set the SysAudio file object
        if( NULL==(pmxd->pfo=kmxlOpenSysAudio())) {
            DPF(DL_WARNING|FA_INSTANCE,("OpenSysAudio failed") );
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( NULL );
        }

        Status = SetSysAudioProperty(
            pmxd->pfo,
            KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
            sizeof( pmxd->Device ),
            &pmxd->Device
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlCloseSysAudio( pmxd->pfo );
            pmxd->pfo=NULL;
            DPF(DL_WARNING|FA_INSTANCE,("SetSysAudioProperty DEVICE_INSTANCE failed %X",Status) );
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( NULL );
        }
    }
    //
    // BUGBUG:  we should not need this any more.
    //
    DeviceInfo->dwInstance=kmxlUniqueInstanceId();;

    return pmxd;
}



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//           G E T / S E T  D E T A I L  H A N D L E R S             //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlIsSpeakerDestinationVolume
//
// Returns TRUE if the control is a volume control on the Speakers
// destination.
//
//

BOOL
kmxlIsSpeakerDestinationVolume(
     IN PMIXERDEVICE   pmxd,         // The mixer
     IN PMXLCONTROL    pControl      // The control to check
)
{
     PMXLLINE pLine;

     PAGED_CODE();
     DPFASSERT( IsValidMixerDevice(pmxd) );
     DPFASSERT( IsValidControl(pControl) );

     //
     // Find a line for this control.  If none is found, then this can't
     // be a destination volume.
     //

     pLine = kmxlFindLineForControl( pControl, pmxd->listLines );
     if( !pLine ) {
          return( FALSE );
     }

     if( pLine->Line.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS ) {
          return( TRUE );
     } else {
          return( FALSE );
     }

}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetUnsigned
//
//
// Handles getting an unsigned (32-bit) value for a control.  Note
// that signed 32-bit and boolean values are also retrieved via this
// handler.
//
//

NTSTATUS
kmxlHandleGetUnsigned(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     ULONG                          ulProperty,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG     Level;
    DWORD    dwLevel;
    ULONG    i;
    ULONG    Channel;
    MIXERMAPPING Mapping = MIXER_MAPPING_LOGRITHMIC;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    DPFASSERT( IsValidControl(pControl)  );

    if( paDetails == NULL ) {
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_SUCCESS );
    }

    //
    // Use a different mapping algorithm if this is a speaker
    // dest volume control.
    //

    if( kmxlIsSpeakerDestinationVolume( pmxd, pControl ) ) {
         Mapping = pmxd->Mapping;
    }

    //
    // Service the Mux
    //
    if ( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX) {

        Status = kmxlGetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            pControl->PropertyId,
            pControl->Id,
            0,
            NULL,
            &Level,
            sizeof( Level )
        );
        if( !NT_SUCCESS( Status ) ) {            
            DPF(DL_WARNING|FA_USER,( "kmxlHandleGetUnsigned( Ctrl=%d, Id=%d ) failed GET on MUX with %x",
                             pControl->Control.dwControlID,
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

        DPF(DL_TRACE|FA_USER,( "kmxlHandleGetUnsigned( Ctrl=%d, Id=%d ) = %d [1]",
                   pControl->Control.dwControlID,
                   pControl->Id,
                   Level ));

        for( i = 0; i < pControl->Parameters.Count; i++ ) {
            if( (ULONG) Level == pControl->Parameters.pPins[ i ] ) {
//                APITRACE(( "1" ));
                paDetails[ i ].dwValue = 1;
            } else {
                paDetails[ i ].dwValue = 0;
//                APITRACE(( "1" ));
            }
        }

//        APITRACE(( "]\n" ));

    }
    else {

        paDetails->dwValue = 0; // initialize to zero for now so that the coalesced case works

        // Loop over the channels for now.  Fix this so that only one request is made.
        Channel = 0;
        do
        {
            Status = kmxlGetAudioNodeProperty(
                pmxd->pfo,
                ulProperty,
                pControl->Id,
                Channel,
                NULL,   0,                  // No extra input bytes
                &Level, sizeof( Level )
                );
            if ( !NT_SUCCESS( Status ) ) {                
                DPF(DL_TRACE|FA_USER,( "kmxlHandleGetUnsigned( Ctrl=%d [%s], Id=%d ) failed GET on MASTER channel with %x",
                           pControl->Control.dwControlID,
                           ControlTypeToString( pControl->Control.dwControlType ),
                           pControl->Id,
                           Status ));
                DPF(DL_WARNING|FA_PROPERTY, 
                    ( "GetAudioNodeProp failed on MASTER channel with %X for %s!",
                       Status,
                       ControlTypeToString( pControl->Control.dwControlType ) ) );
                DeviceInfo->mmr = MMSYSERR_ERROR;
                return( STATUS_SUCCESS );
            }

            if ( pControl->bScaled ) {
                dwLevel = kmxlVolLogToLinear( pControl, Level, Mapping, Channel );
            } else {
                dwLevel = (DWORD)Level;
            }

            if(  ( pmcd->cChannels == 1 ) &&
                !( pControl->Control.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM ) ) {

                //
                // Coalesce values: If the user requests only 1 channel for a N channel
                // control, then return the greatest channel value.
                //
                if (dwLevel > paDetails->dwValue) {
                    paDetails->dwValue = dwLevel;
                }

            } else if (Channel < pmcd->cChannels) {

                paDetails[ Channel ].dwValue = dwLevel;
                DPF(DL_TRACE|FA_USER,( "kmxlHandleGetUnsigned( Ctrl=%d, Id=%d ) returning (Chan#%d) = (%x)",
                      pControl->Control.dwControlID,
                      pControl->Id,
                      Channel,
                      paDetails[ Channel ].dwValue
                      ));

            } else {
                // No need to keep trying
                break;
            }

            Channel++;

        } while ( Channel < pControl->NumChannels );
    }

    if( NT_SUCCESS( Status ) ) {
        DeviceInfo->mmr = MMSYSERR_NOERROR;
    } else {
        DeviceInfo->mmr = MMSYSERR_ERROR;
    }
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetMuteFromSuperMix
//
// Handles getting the mute state from a supermix node.
//

NTSTATUS
kmxlHandleGetMuteFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status;
    ULONG i;
    BOOL bMute = FALSE;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl );

    ASSERT( pControl->Parameters.pMixCaps   );
    ASSERT( pControl->Parameters.pMixLevels );

    //
    // Read the current state of the supermix
    //

    Status = kmxlGetNodeProperty(
        pmxd->pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        pControl->Id,
        0,
        NULL,
        pControl->Parameters.pMixLevels,
        pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ),
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_USER,( "kmxlHandleGetMuteFromSupermix ( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                   pControl->Control.dwControlID,
                   ControlTypeToString( pControl->Control.dwControlType ),
                   pControl->Id,
                   Status
                   ));
        DeviceInfo->mmr = MMSYSERR_ERROR;
        return( STATUS_SUCCESS );
    }

    for( i = 0; i < pControl->Parameters.Size; i++ ) {

        if( pControl->Parameters.pMixLevels[ i ].Mute )
        {
            bMute = TRUE;
            continue;
        }

        if( pControl->Parameters.pMixLevels[ i ].Level == LONG_MIN )
        {
            bMute = TRUE;
            continue;
        }

        bMute = FALSE;
        break;
    }

    paDetails->dwValue = (DWORD) bMute;
    DeviceInfo->mmr = MMSYSERR_NOERROR;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetUnsigned
//
// Handles setting an unsigned (32-bit) value for a control.  Note
// that signed 32-bit and boolean values are also set via this
// handler.
//
//

NTSTATUS
kmxlHandleSetUnsigned(
    IN OUT LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     ULONG                          ulProperty,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS       Status = STATUS_SUCCESS;
    LONG           Level, Current;
    DWORD          dwValue;
    BOOL           bUniform, bEqual = TRUE;
    ULONG          i;
    ULONG          Channel;
    MIXERMAPPING   Mapping = MIXER_MAPPING_LOGRITHMIC;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl  );

    if( paDetails == NULL ) {
        DPF(DL_WARNING|FA_USER,( "paDetails is NULL" ));
        DeviceInfo->mmr = MMSYSERR_INVALPARAM;
        return( STATUS_INVALID_PARAMETER );
    }

    bUniform = ( pControl->Control.fdwControl & MIXERCONTROL_CONTROLF_UNIFORM ) ||
               ( pmcd->cChannels == 1 );

    //
    // Use a different mapping if this control is a speaker destination
    // volume control.
    //

    if( kmxlIsSpeakerDestinationVolume( pmxd, pControl ) ) {
         Mapping = pmxd->Mapping;
    }

    //
    //  Service the mux
    //
    if ( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX) {

        // Proken APITRACE statement.
        //DPF(DL_TRACE|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%d, " ));


        // First validate the paDetails parameter and make sure it has the correct
        // format.  If not, then punt with an invalid parameter error.
                {
                LONG selectcount=0;

        for( i = 0; i < pmcd->cMultipleItems; i++ ) {
            if( paDetails[ i ].dwValue ) {
                selectcount++;
//                APITRACE(( "1" ));
            } else {
//                APITRACE(( "0" ));
            }

        }

        if (selectcount!=1) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%d ) invalid paDetails parameter for SET on MUX",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id));
            DeviceInfo->mmr = MMSYSERR_INVALPARAM;
            return( STATUS_SUCCESS );
                }

                }


        for( i = 0; i < pmcd->cMultipleItems; i++ ) {
            if( paDetails[ i ].dwValue ) {
//                APITRACE(( "1" ));
                Level = pControl->Parameters.pPins[ i ];
            } else {
//                APITRACE(( "0" ));
            }

        }

//        APITRACE(( " ). Setting pin %d on MUX.\n", Level ));

        Status = kmxlSetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            pControl->PropertyId,
            pControl->Id,
            0,
            NULL,
            &Level,
            sizeof( Level )
        );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%d ) failed SET on MUX with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }
        bEqual = FALSE;
    }
    else {
        // Loop over the channels for now.  Fix this so that only one request is made.
        Channel = 0;
        do
        {
            if( bUniform ) {
                //
                // Some controls are mono in the eyes of SNDVOL but are in
                // fact stereo.  This hack fixes this problem.
                //
                dwValue = paDetails[ 0 ].dwValue;
            } else if (Channel < pmcd->cChannels) {
                dwValue = paDetails[ Channel ].dwValue;
            } else {
                // No need to keep trying
                break;
            }

            if( pControl->bScaled ) {
                Level = kmxlVolLinearToLog( pControl, dwValue, Mapping, Channel );
            } else {
                Level = (LONG)dwValue;
            }

            Status = kmxlGetAudioNodeProperty(
                pmxd->pfo,
                ulProperty,
                pControl->Id,
                Channel,
                NULL,   0,                  // No extra input bytes
                &Current, sizeof( Current )
                );
            if( !NT_SUCCESS( Status ) ) {
                DPF(DL_WARNING|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%d ) failed GET on channel %d with %x",
                                 pControl->Control.dwControlID,
                                 ControlTypeToString( pControl->Control.dwControlType ),
                                 pControl->Id,
                                 Channel,
                                 Status ));
                DeviceInfo->mmr = MMSYSERR_ERROR;
                return( STATUS_SUCCESS );
            }

            if( Level != Current ) {

                bEqual = FALSE;

                Status = kmxlSetAudioNodeProperty(
                    pmxd->pfo,
                    ulProperty,
                    pControl->Id,
                    Channel,
                    NULL,   0,                  // No extra input bytes
                    &Level, sizeof( Level )
                    );
                if( !NT_SUCCESS( Status ) ) {
                    DPF(DL_WARNING|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d [%s], Id=%x ) failed SET on channel %d with %x",
                                     pControl->Control.dwControlID,
                                     ControlTypeToString( pControl->Control.dwControlType ),
                                     pControl->Id,
                                     Channel,
                                     Status ));
                    DeviceInfo->mmr = MMSYSERR_ERROR;
                    return( STATUS_SUCCESS );
                }

                DPF(DL_TRACE|FA_USER,( "kmxlHandleSetUnsigned( Ctrl=%d, Id=%d ) using (%x) on Chan#%d",
                          pControl->Control.dwControlID,
                          pControl->Id,
                          paDetails[ Channel ].dwValue,
                          Channel
                        ));
            }

            Channel++;

        } while ( Channel < pControl->NumChannels );
    }

    if( NT_SUCCESS( Status ) ) {

        DeviceInfo->mmr = MMSYSERR_NOERROR;

        if( Flags & MIXER_FLAG_PERSIST ) {

            kmxlPersistControl(
                pmxd->pfo,
                pmxd,
                pControl,
                paDetails
                );
        }

        if( !bEqual && !( Flags & MIXER_FLAG_NOCALLBACK ) ) {
            kmxlNotifyControlChange( DeviceInfo, pmxd, pControl );
        }

    } else {
        DeviceInfo->mmr = MMSYSERR_ERROR;
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetMuteFromSuperMix
//
//  Handles setting the mute state using a supermixer.
//
//

NTSTATUS
kmxlHandleSetMuteFromSuperMix(
    IN OUT LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status;
    ULONG i;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl );

    ASSERT( pControl->Parameters.pMixCaps   );
    ASSERT( pControl->Parameters.pMixLevels );

    if( paDetails->dwValue ) {

        //
        // Query the current values from the supermix and save those away.
        // These values will be used to restore the supermix to the state
        // we found it prior to muting.
        //

        Status = kmxlGetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pControl->Id,
            0,
            NULL,
            pControl->Parameters.pMixLevels,
            pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ),
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetMuteFromSuperMix( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

        //
        // For any entry in the table that supports muting, mute it.
        //

        for( i = 0; i < pControl->Parameters.Size; i++ ) {

            if( pControl->Parameters.pMixCaps->Capabilities[ i ].Mute ) {
                pControl->Parameters.pMixLevels[ i ].Mute = TRUE;
            }
        }

        //
        // Set this new supermixer state.
        //

        Status = kmxlSetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pControl->Id,
            0,
            NULL,
            pControl->Parameters.pMixLevels,
            pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ),
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetMuteFromSuperMix( Ctrl=%d [%s], Id=%d ) failed SET on MIX_LEVEL_TABLE with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

    } else {

        Status = kmxlGetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pControl->Id,
            0,
            NULL,
            pControl->Parameters.pMixLevels,
            pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ),
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetMuteFromSuperMix( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

        //
        // For any entry in the table that supports muting, mute it.
        //

        for( i = 0; i < pControl->Parameters.Size; i++ ) {

            if( pControl->Parameters.pMixCaps->Capabilities[ i ].Mute ) {
                pControl->Parameters.pMixLevels[ i ].Mute = FALSE;
            }
        }

        //
        // Set this new supermixer state.
        //

        Status = kmxlSetNodeProperty(
            pmxd->pfo,
            &KSPROPSETID_Audio,
            KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
            pControl->Id,
            0,
            NULL,
            pControl->Parameters.pMixLevels,
            pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ),
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_USER,( "kmxlHandleSetMuteFromSuperMix( Ctrl=%d [%s], Id=%d ) failed SET on MIX_LEVEL_TABLE with %x",
                             pControl->Control.dwControlID,
                             ControlTypeToString( pControl->Control.dwControlType ),
                             pControl->Id,
                             Status ));
            DeviceInfo->mmr = MMSYSERR_ERROR;
            return( STATUS_SUCCESS );
        }

    }

    if( NT_SUCCESS( Status ) ) {
        if( Flags & MIXER_FLAG_PERSIST ) {

            kmxlPersistControl(
                pmxd->pfo,
                pmxd,
                pControl,
                paDetails
                );

        }

        kmxlNotifyControlChange( DeviceInfo, pmxd, pControl );
        DeviceInfo->mmr = MMSYSERR_NOERROR;
    } else {
        DeviceInfo->mmr = MMSYSERR_ERROR;
    }

    return( STATUS_SUCCESS );
}

#ifdef SUPERMIX_AS_VOL
///////////////////////////////////////////////////////////////////////
//
// kmxlHandleGetVolumeFromSuperMix
//
//

NTSTATUS
kmxlHandleGetVolumeFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status;
    ULONG i, Channels, Index, MaxChannel = 0;
    LONG  Max = LONG_MIN; // -Inf dB

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl  );
    ASSERT( pmcd      );
    ASSERT( paDetails );

    Status = kmxlGetNodeProperty(
        pmxd->pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        pControl->Id,
        0,
        NULL,
        pControl->Parameters.pMixLevels,
        pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ),
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_USER,( "kmxlHandleGetVolumeFromSuperMix( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                         pControl->Control.dwControlID,
                         ControlTypeToString( pControl->Control.dwControlType ),
                         pControl->Id,
                         Status ));
        DeviceInfo->mmr = MMSYSERR_ERROR;
        return( STATUS_SUCCESS );
    }

    //
    // Count the number of channels
    //

    for( i = 0, Channels = 0;
         i < pControl->Parameters.Size;
         i += pControl->Parameters.pMixCaps->OutputChannels + 1,
         Channels++ )
    {
        if( pControl->Parameters.pMixLevels[ i ].Level > Max ) {
            Max = pControl->Parameters.pMixLevels[ i ].Level;
            MaxChannel = Channels;
        }
    }

    //
    // Return the translated volume levels
    //

    if( ( pmcd->cChannels == 1 ) && ( Channels > 1 ) ) {

        //
        // As per SB16 sample, if the caller wants only 1 channel but
        // the control is multichannel, return the maximum of all the
        // channels.
        //

        paDetails->dwValue = kmxlVolLogToLinear(
            pControl,
            Max,
            MIXER_MAPPING_LOGRITHMIC,
            MaxChannel
            );
    } else {

        //
        // Translate each of the channel value into linear and
        // store them away.
        //

        for( i = 0; i < pmcd->cChannels; i++ ) {

            Index = i * ( pControl->Parameters.pMixCaps->OutputChannels + 1 );
            paDetails[ i ].dwValue = kmxlVolLogToLinear(
                pControl,
                pControl->Parameters.pMixLevels[ Index ].Level,
                MIXER_MAPPING_LOGRITHMIC,
                i
                );
        }

    }

    DeviceInfo->mmr = MMSYSERR_NOERROR;
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlHandleSetVolumeFromSuperMix
//
//

NTSTATUS
kmxlHandleSetVolumeFromSuperMix(
    IN     LPDEVICEINFO                   DeviceInfo,
    IN     PMIXERDEVICE                   pmxd,
    IN     PMXLCONTROL                    pControl,
    IN     LPMIXERCONTROLDETAILS          pmcd,
    IN OUT LPMIXERCONTROLDETAILS_UNSIGNED paDetails,
    IN     ULONG                          Flags
)
{
    NTSTATUS Status;
    ULONG i, Index;

    PAGED_CODE();

    DPFASSERT( IsValidMixerDevice(pmxd) );
    ASSERT( pControl  );
    ASSERT( pmcd      );
    ASSERT( paDetails );

    //
    // Query the current values for the mix levels.
    //

    Status = kmxlGetNodeProperty(
        pmxd->pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        pControl->Id,
        0,
        NULL,
        pControl->Parameters.pMixLevels,
        pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ),
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_USER,( "kmxlHandleSetVolumeFromSuperMix( Ctrl=%d [%s], Id=%d ) failed GET on MIX_LEVEL_TABLE with %x",
                         pControl->Control.dwControlID,
                         ControlTypeToString( pControl->Control.dwControlType ),
                         pControl->Id,
                         Status ));
        DeviceInfo->mmr = MMSYSERR_ERROR;
        return( STATUS_SUCCESS );
    }

    //
    // Adjust the values on the diagonal to those the user specified.
    //

    for( i = 0; i < pmcd->cChannels; i++ ) {

        Index = i * ( pControl->Parameters.pMixCaps->OutputChannels + 1 );
        pControl->Parameters.pMixLevels[ Index ].Level = kmxlVolLinearToLog(
            pControl,
            paDetails[ i ].dwValue,
            MIXER_MAPPING_LOGRITHMIC,
            i
            );
    }

    //
    // Set these new values.
    //

    Status = kmxlSetNodeProperty(
        pmxd->pfo,
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
        pControl->Id,
        0,
        NULL,
        pControl->Parameters.pMixLevels,
        pControl->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ),
        );

    if( NT_SUCCESS( Status ) ) {
        DeviceInfo->mmr = MMSYSERR_NOERROR;
    } else {
        DPF(DL_WARNING|FA_USER,( "kmxlHandleSetVolumeFromSuperMix( Ctrl=%d [%s], Id=%d ) failed SET on MIX_LEVEL_TABLE with %x",
                         pControl->Control.dwControlID,
                         ControlTypeToString( pControl->Control.dwControlType ),
                         pControl->Id,
                         Status ));
        DeviceInfo->mmr = MMSYSERR_ERROR;
    }
    return( STATUS_SUCCESS );
}
#endif // SUPERMIX_AS_VOL

///////////////////////////////////////////////////////////////////////
//
// kmxlNotifyLineChange
//
//

VOID
kmxlNotifyLineChange(
    OUT LPDEVICEINFO                  DeviceInfo,
    IN PMIXERDEVICE                   pmxd,
    IN PMXLLINE                       pLine,
    IN LPMIXERCONTROLDETAILS_UNSIGNED paDetails
)
{
    PAGED_CODE();

    ASSERT( (DeviceInfo->dwCallbackType&MIXER_LINE_CALLBACK) == 0 );

    DeviceInfo->dwLineID=pLine->Line.dwLineID;
    DeviceInfo->dwCallbackType|=MIXER_LINE_CALLBACK;
}


///////////////////////////////////////////////////////////////////////
//
// kmxlNotifyControlChange
//
//

VOID
kmxlNotifyControlChange(
    OUT LPDEVICEINFO  DeviceInfo,
    IN PMIXERDEVICE   pmxd,
    IN PMXLCONTROL    pControl
)
{
    WRITE_CONTEXT* pwc;

    PAGED_CODE();

    //
    // If there are no open instances, there is no reason to even attempt
    // a callback... no one is listening.
    //

    ExAcquireFastMutex( &ReferenceCountMutex );

    if( ReferenceCount == 0 ) {
        ExReleaseFastMutex( &ReferenceCountMutex );
        return;
    }

    ExReleaseFastMutex( &ReferenceCountMutex );


    {
        PMXLLINE    pLine;
        PMXLCONTROL pCtrl;

        LONG callbackcount;

        callbackcount=0;

        pLine = kmxlFirstInList( pmxd->listLines );
        while( pLine ) {

            pCtrl = kmxlFirstInList( pLine->Controls );
            while( pCtrl ) {

                if ( pCtrl->Id == pControl->Id ) {

                    //ASSERT( (DeviceInfo->dwCallbackType&MIXER_CONTROL_CALLBACK) == 0 );
                    ASSERT( callbackcount < MAXCALLBACKS );

                    if ( callbackcount < MAXCALLBACKS ) {
                        (DeviceInfo->dwID)[callbackcount++]=pCtrl->Control.dwControlID;
                        }

                    DeviceInfo->dwCallbackType|=MIXER_CONTROL_CALLBACK;

                    }
                pCtrl = kmxlNextControl( pCtrl );
            }
            pLine = kmxlNextLine( pLine );
        }

    DeviceInfo->ControlCallbackCount=callbackcount;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\persist.c ===
//---------------------------------------------------------------------------
//
//  Module:   persist.c
//
//  Description:
//
//    Contains the routines that persist the mixer line driver settings.
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "WDMSYS.H"
#include "kmxluser.h"

///////////////////////////////////////////////////////////////////////
//
// kmxlGetInterfaceName
//
//

NTSTATUS
kmxlGetInterfaceName(
    IN  PFILE_OBJECT pfo,
    IN  ULONG        Device,
    OUT PWCHAR*      pszInterfaceName
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    Size;
    WCHAR*   szInterfaceName = NULL;

    PAGED_CODE();
    ASSERT( pfo );

    //
    // Retrieve the size of the internface name.
    //

    Status = GetSysAudioProperty(
        pfo,
        KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
        Device,
        sizeof( Size ),
        &Size
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_PERSIST,("GetSysAudioProperty failed Status=%X",Status) );
        goto exit;
    }

    //
    // Allocate enough memory to hold the interface name
    //

    Status = AudioAllocateMemory_Paged(Size,
                                       TAG_Audp_NAME,
                                       ZERO_FILL_MEMORY | LIMIT_MEMORY,
                                       &szInterfaceName );
    if( !NT_SUCCESS( Status ) ) {
        goto exit;
    }

    ASSERT( szInterfaceName );

    //
    // Retieve the interface name for this device.
    //

    Status = GetSysAudioProperty(
        pfo,
        KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
        Device,
        Size,
        szInterfaceName
        );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_PERSIST,("GetSysAudioProperty failed Status=%X",Status) );
        goto exit;
    }

exit:

    if( !NT_SUCCESS( Status ) ) {
        AudioFreeMemory_Unknown( &szInterfaceName );
    } else {
        *pszInterfaceName = szInterfaceName;
    }
    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlOpenInterfaceKey
//
//

NTSTATUS
kmxlOpenInterfaceKey(
    IN  PFILE_OBJECT pfo,
    IN  ULONG Device,
    OUT HANDLE* phKey
)
{
    NTSTATUS       Status;
    HANDLE         hKey;
    WCHAR*         szName;
    UNICODE_STRING ustr;

    PAGED_CODE();
    Status = kmxlGetInterfaceName( pfo, Device, &szName );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_WARNING|FA_PERSIST,("kmxlGetInterfaceName failed Status=%X",Status) );
        RETURN( Status );
    }

    RtlInitUnicodeString( &ustr, szName );

    Status = IoOpenDeviceInterfaceRegistryKey(
        &ustr,
        KEY_ALL_ACCESS,
        &hKey
        );
    if( !NT_SUCCESS( Status ) ) {
        AudioFreeMemory_Unknown( &szName );
        RETURN( Status );
    }

    *phKey = hKey;
    AudioFreeMemory_Unknown( &szName );
    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegCreateKey
//
//

NTSTATUS
kmxlRegCreateKey(
    IN HANDLE hRootKey,
    IN PWCHAR szKeyName,
    OUT PHANDLE phKey
)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    ustr;
    ULONG             Disposition;

    PAGED_CODE();
    RtlInitUnicodeString( &ustr, szKeyName );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &ustr,
        0,      // Attributes
        hRootKey,
        NULL    // Security
        );

    return( ZwCreateKey(
            phKey,
            KEY_ALL_ACCESS,
            &ObjectAttributes,
            0,                  // TitleIndex
            NULL,               // Class
            REG_OPTION_NON_VOLATILE,
            &Disposition
            )
        );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegOpenKey
//
//

NTSTATUS
kmxlRegOpenKey(
    IN HANDLE hRootKey,
    IN PWCHAR szKeyName,
    OUT PHANDLE phKey
)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ustr;

    PAGED_CODE();
    RtlInitUnicodeString( &ustr, szKeyName );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &ustr,
        0,
        hRootKey,
        NULL
        );

    return( ZwOpenKey(
        phKey,
        KEY_ALL_ACCESS,
        &ObjectAttributes
        )
    );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegSetValue
//
//

NTSTATUS
kmxlRegSetValue(
    IN HANDLE hKey,
    IN PWCHAR szValueName,
    IN ULONG  Type,
    IN PVOID  pData,
    IN ULONG  cbData
)
{
    UNICODE_STRING ustr;

    PAGED_CODE();
    RtlInitUnicodeString( &ustr, szValueName );
    return( ZwSetValueKey(
            hKey,
            &ustr,
            0,
            Type,
            pData,
            cbData
            )
        );

}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegQueryValue
//
//

NTSTATUS
kmxlRegQueryValue(
    IN HANDLE  hKey,
    IN PWCHAR  szValueName,
    IN PVOID   pData,
    IN ULONG   cbData,
    OUT PULONG pResultLength
)
{
    NTSTATUS Status;
    UNICODE_STRING ustr;
    KEY_VALUE_FULL_INFORMATION FullInfoHeader;
    PKEY_VALUE_FULL_INFORMATION FullInfoBuffer = NULL;

    PAGED_CODE();
    RtlInitUnicodeString( &ustr, szValueName );
    Status = ZwQueryValueKey(
        hKey,
        &ustr,
        KeyValueFullInformation,
        &FullInfoHeader,
        sizeof( FullInfoHeader ),
        pResultLength
        );
    if( !NT_SUCCESS( Status ) ) {

        if( Status == STATUS_BUFFER_OVERFLOW ) {

            if( !NT_SUCCESS( AudioAllocateMemory_Paged(*pResultLength, 
                                                       TAG_AudA_PROPERTY,
                                                       ZERO_FILL_MEMORY,
                                                       &FullInfoBuffer ) ) ) 
            {            
                RETURN( STATUS_INSUFFICIENT_RESOURCES );
            }

            Status = ZwQueryValueKey(
                hKey,
                &ustr,
                KeyValueFullInformation,
                FullInfoBuffer,
                *pResultLength,
                pResultLength
                );

            if( NT_SUCCESS( Status ) ) {
                RtlCopyMemory(
                    pData,
                    (PUCHAR) FullInfoBuffer + FullInfoBuffer->DataOffset,
                    cbData
                    );
            }

            AudioFreeMemory_Unknown( &FullInfoBuffer );
        }
    }

    DPFRETURN( Status,(2,Status,STATUS_OBJECT_NAME_NOT_FOUND) );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRegOpenMixerKey
//
//

NTSTATUS
kmxlRegOpenMixerKey(
    IN PFILE_OBJECT pfo,
    IN PMIXERDEVICE pmxd,
    OUT PHANDLE     phMixerKey
)
{
    NTSTATUS Status;
    HANDLE   hKey;

    PAGED_CODE();
    Status = kmxlOpenInterfaceKey( pfo, pmxd->Device, &hKey );
    if( !NT_SUCCESS( Status ) ) {
        RETURN( Status );
    }

    Status = kmxlRegOpenKey( hKey, MIXER_KEY_NAME, phMixerKey );
    if( NT_SUCCESS( Status ) ) {
        kmxlRegCloseKey( hKey );
    }
    RETURN( Status );

}


///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestById
//
//

PMXLLINE
kmxlFindDestById(
    IN LINELIST listLines,
    IN ULONG    LineId
)
{
    PMXLLINE pLine;

    PAGED_CODE();
    pLine = kmxlFirstInList( listLines );
    while( pLine ) {
        if( pLine->Line.dwLineID == LineId ) {
            return( pLine );
        }
        pLine = kmxlNextLine( pLine );
    }

    return( NULL );
}


extern instancereleasedcount;

///////////////////////////////////////////////////////////////////////
//
//
//

NTSTATUS
kmxlGetCurrentControlValue(
    IN PFILE_OBJECT pfo,        // The instance to persist for
    IN PMIXERDEVICE pmxd,
    IN PMXLLINE     pLine,
    IN PMXLCONTROL  pControl,   // The control to retrieve
    OUT PVOID*      ppaDetails
)
{
    NTSTATUS                      Status;
    LPDEVICEINFO                  pDevInfo = NULL;
    MIXERCONTROLDETAILS           mcd;
    PMIXERCONTROLDETAILS_UNSIGNED paDetails = NULL;
    ULONG                         Index;
    ULONG                         Devices;


    PAGED_CODE();
    *ppaDetails = NULL;

    //
    // Initialize a Device Info structure to make the query look like
    // it comes from user mode.
    //
    Status = kmxlAllocDeviceInfo(&pDevInfo, pmxd->DeviceInterface, MIXER_GETCONTROLDETAILSF_VALUE,TAG_AudD_DEVICEINFO );
    if (!NT_SUCCESS(Status)) {
        RETURN( Status );
    }

    for( Devices = 0, Index = 0; Devices < MAXNUMDEVS; Devices++ ) {

        if( pmxd == &pmxd->pWdmaContext->MixerDevs[ Devices ] ) {
            pDevInfo->DeviceNumber = Index;
            break;
        }

        if ( !MyWcsicmp(pmxd->DeviceInterface, pmxd->pWdmaContext->MixerDevs[ Devices ].DeviceInterface) ) {
            Index++;
        }

    }

    //
    // Create an MIXERCONTROLDETAILS structure for this query.
    //
    RtlZeroMemory( &mcd, sizeof( MIXERCONTROLDETAILS ) );
    mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
    mcd.dwControlID    = pControl->Control.dwControlID;
    mcd.cMultipleItems = pControl->Control.cMultipleItems;
    mcd.cChannels      = pControl->NumChannels;

    if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {
        Status = AudioAllocateMemory_Paged(mcd.cMultipleItems * sizeof( MIXERCONTROLDETAILS_UNSIGNED ),
                                           TAG_Audd_DETAILS,
                                           ZERO_FILL_MEMORY,
                                           &paDetails );
        mcd.cbDetails      = mcd.cMultipleItems * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    } else {
        Status = AudioAllocateMemory_Paged(mcd.cChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED ),
                                           TAG_Audd_DETAILS,
                                           ZERO_FILL_MEMORY,
                                           &paDetails );
        mcd.cbDetails      = mcd.cChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    }

    if (NT_SUCCESS(Status))
    {
        mcd.paDetails      = paDetails;

        //
        // Make the actual query call.
        //
        Status = kmxlGetControlDetailsHandler(pmxd->pWdmaContext, pDevInfo, &mcd, paDetails);

        if( NT_SUCCESS( Status ) ) {
            *ppaDetails = paDetails;
        } else {
            AudioFreeMemory_Unknown( &paDetails );
        }
    }

    AudioFreeMemory_Unknown( &pDevInfo );
    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
//
//

NTSTATUS
kmxlSetCurrentControlValue(
    IN PFILE_OBJECT pfo,        // The instance to persist for
    IN PMIXERDEVICE pmxd,
    IN PMXLLINE     pLine,
    IN PMXLCONTROL  pControl,   // The control to retrieve
    IN PVOID        paDetails
)
{
    NTSTATUS                      Status;
    LPDEVICEINFO                  pDevInfo = NULL;
    MIXERCONTROLDETAILS           mcd;
    ULONG                         Index;
    ULONG                         Devices;

    PAGED_CODE();
    //
    // Initialize a Device Info structure to make the query look like
    // it comes from user mode.
    //
    Status = kmxlAllocDeviceInfo(&pDevInfo, pmxd->DeviceInterface, MIXER_SETCONTROLDETAILSF_VALUE,TAG_AudD_DEVICEINFO );
    if (!NT_SUCCESS(Status)) RETURN( Status );

    for( Devices = 0, Index = 0;
         Devices < MAXNUMDEVS;
         Devices++ ) {

        if( pmxd == &pmxd->pWdmaContext->MixerDevs[ Devices ] ) {
            pDevInfo->DeviceNumber = Index;
            break;
        }

        if ( !MyWcsicmp(pmxd->DeviceInterface, pmxd->pWdmaContext->MixerDevs[ Devices ].DeviceInterface) ) {
            Index++;
        }
    }

    //
    // Create an MIXERCONTROLDETAILS structure for this query.
    //
    RtlZeroMemory( &mcd, sizeof( MIXERCONTROLDETAILS ) );
    mcd.cMultipleItems   = pControl->Control.cMultipleItems;
    mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
    mcd.dwControlID    = pControl->Control.dwControlID;
    mcd.cChannels      = pControl->NumChannels;    
    //
    // For a MUX, we know that NumChannels will be zero and cChannels will be zero.
    //
    if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {
        mcd.cbDetails      = mcd.cMultipleItems * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    } else {
        mcd.cbDetails      = mcd.cChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    }
    mcd.paDetails      = paDetails;

    //
    // Make the actual query call.
    //
    Status = kmxlSetControlDetailsHandler( pmxd->pWdmaContext,
                       pDevInfo,
                       &mcd,
                       paDetails,
                       0
                     );

    //
    // workitem:  Should map the error code here for invalid topologies!
    //
    AudioFreeMemory_Unknown(&pDevInfo);
    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlPersistAll
//
//

NTSTATUS
kmxlPersistAll(
    IN PFILE_OBJECT pfo,        // The instance to persist
    IN PMIXERDEVICE pmxd
)
{
    NTSTATUS          Status = STATUS_SUCCESS;
    HANDLE            hKey = NULL,
                      hMixerKey = NULL,
                      hLineKey = NULL,
                      hAllControlsKey = NULL,
                      hControlKey = NULL;
    WCHAR             sz[ 16 ];
    ULONG             LineNum,
                      ControlNum,
                      i,
                      Channels;
    PMXLLINE          pLine;
    PMXLCONTROL       pControl;
    PVOID             paDetails;
    PCHANNEL_STEPPING pChannelStepping;
    BOOL              bValidMultichannel;

    PAGED_CODE();

    ASSERT( pfo );
    ASSERT( pmxd );

    Status = kmxlOpenInterfaceKey( pfo, pmxd->Device, &hKey );
    if( !NT_SUCCESS( Status ) ) {
        goto exit;
    }

    Status = kmxlRegCreateKey(
        hKey,
        MIXER_KEY_NAME,
        &hMixerKey
        );
    if( !NT_SUCCESS( Status ) ) {
        goto exit;
    }

    kmxlRegCloseKey( hKey );

    i = kmxlListLength( pmxd->listLines );
    kmxlRegSetValue(
        hMixerKey,
        LINE_COUNT_VALUE_NAME,
        REG_DWORD,
        &i,
        sizeof( i )
        );

    LineNum = 0;
    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        //
        // Store the line id as the key
        //

        swprintf( sz, LINE_KEY_NAME_FORMAT, LineNum++ );
        Status = kmxlRegCreateKey(
            hMixerKey,
            sz,
            &hLineKey
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_PERSIST,("kmxlRegCreateKey failed Status=%X",Status) );
            goto exit;
        }

        kmxlRegSetValue(
            hLineKey,
            LINE_ID_VALUE_NAME,
            REG_DWORD,
            &pLine->Line.dwLineID,
            sizeof( pLine->Line.dwLineID )
            );

        //
        // Save the number of controls underneath the line id key
        //

        kmxlRegSetValue(
            hLineKey,
            CONTROL_COUNT_VALUE_NAME,
            REG_DWORD,
            &pLine->Line.cControls,
            sizeof( pLine->Line.cControls )
            );

        //
        // Save the source pin Id underneath the line id key
        //

        kmxlRegSetValue(
            hLineKey,
            SOURCE_ID_VALUE_NAME,
            REG_DWORD,
            &pLine->SourceId,
            sizeof( pLine->SourceId )
            );

        //
        // Save the destination pin Id underneath the line id key
        //

        kmxlRegSetValue(
            hLineKey,
            DEST_ID_VALUE_NAME,
            REG_DWORD,
            &pLine->DestId,
            sizeof( pLine->DestId )
            );

        //
        // Create the Controls key to store all the controls under
        //

        Status = kmxlRegCreateKey(
            hLineKey,
            CONTROLS_KEY_NAME,
            &hAllControlsKey
            );
        if( !NT_SUCCESS( Status ) ) {
            DPF(DL_WARNING|FA_PERSIST,("kmxlRegCreateKey failed Status=%X",Status) );
            goto exit;
        }

        kmxlRegCloseKey( hLineKey );

        //
        // Persist all the controls underneath the controls key
        //

        ControlNum = 0;
        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {

            swprintf( sz, CONTROL_KEY_NAME_FORMAT, ControlNum++ );
            Status = kmxlRegCreateKey(
                hAllControlsKey,
                sz,
                &hControlKey
                );
            if( !NT_SUCCESS( Status ) ) {
                DPF(DL_WARNING|FA_PERSIST,("kmxlRegCreateKey failed Status=%X",Status) );
                goto exit;
            }

            kmxlRegSetValue(
                hControlKey,
                CONTROL_TYPE_VALUE_NAME,
                REG_DWORD,
                &pControl->Control.dwControlType,
                sizeof( pControl->Control.dwControlType )
                );

            kmxlRegSetValue(
                hControlKey,
                CONTROL_MULTIPLEITEMS_VALUE_NAME,
                REG_DWORD,
                &pControl->Control.cMultipleItems,
                sizeof( pControl->Control.cMultipleItems )
                );

            //
            // As in kmxlRetrieveAll, this code should be in the control creation
            // code path as well as here.  We should never write anything to the registry
            // that doesn't conform to what we understand.
            //
            if (pControl->pChannelStepping) {

                pChannelStepping = pControl->pChannelStepping;
                for (i = 0; i < pControl->NumChannels; i++, pChannelStepping++) {
                    /*
                    ASSERT ( pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536 );
                    ASSERT ( pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536 );
                    ASSERT ( pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535 );
                    */

                    if (!(pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536)) {
                        DPF(DL_WARNING|FA_PERSIST,
                            ("MinValue %X of Control %X of type %X on Line %X Channel %X is out of range!",
                            pChannelStepping->MinValue,
                            pControl->Control.dwControlID,
                            pControl->Control.dwControlType,
                            pLine->Line.dwLineID,
                            i) );
                        pChannelStepping->MinValue = DEFAULT_RANGE_MIN;
                    }
                    if (!(pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536)) {
                        DPF(DL_WARNING|FA_PERSIST,
                            ("MaxValue %X of Control %X of type %X on Line %X Channel %X is out of range!",
                            pChannelStepping->MaxValue,
                            pControl->Control.dwControlID,
                            pControl->Control.dwControlType,
                            pLine->Line.dwLineID,
                            i) );
                        pChannelStepping->MaxValue = DEFAULT_RANGE_MAX;
                    }
                    if (!(pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535)) {
                        DPF(DL_WARNING|FA_PERSIST,
                            ("Steps %X of Control %X of type %X on Line %X Channel %X is out of range!",
                            pChannelStepping->Steps,
                            pControl->Control.dwControlID,
                            pControl->Control.dwControlType,
                            pLine->Line.dwLineID,
                            i) );
                        pChannelStepping->Steps    = DEFAULT_RANGE_STEPS;
                        pControl->Control.Metrics.cSteps = DEFAULT_RANGE_STEPS;
                    }
                }
            }

            Status = kmxlGetCurrentControlValue(
                pfo,
                pmxd,
                pLine,
                pControl,
                &paDetails
                );

            if( NT_SUCCESS( Status ) ) {

                if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {

                    for( i = 0; i < pControl->Control.cMultipleItems; i++ ) {
                        swprintf( sz, MULTIPLEITEM_VALUE_NAME_FORMAT, i );

                        Status = kmxlRegSetValue(
                            hControlKey,
                            sz,
                            REG_DWORD,
                            &((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ],
                            sizeof( ((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ] )
                            );
                        if( !NT_SUCCESS( Status ) ) {
                            AudioFreeMemory_Unknown( &paDetails );
                            DPF(DL_WARNING|FA_PERSIST,("KmxlRegSetValue failed Status=%X",Status) );
                            goto exit;
                        }

                    }


                } else {

                    Channels = pControl->NumChannels;

                    kmxlRegSetValue(
                        hControlKey,
                        CHANNEL_COUNT_VALUE_NAME,
                        REG_DWORD,
                        &Channels,
                        sizeof( Channels )
                        );

                    for( i = 0; i < Channels; i++ ) {
                        swprintf( sz, CHANNEL_VALUE_NAME_FORMAT, i );

                        Status = kmxlRegSetValue(
                            hControlKey,
                            sz,
                            REG_DWORD,
                            &((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ],
                            sizeof( ((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ] )
                            );
                        if( !NT_SUCCESS( Status ) ) {
                            AudioFreeMemory_Unknown( &paDetails );
                            DPF(DL_WARNING|FA_PERSIST,("KmxlRegSetValue failed Status=%X",Status) );
                            goto exit;
                        }
                    }
                }
                AudioFreeMemory_Unknown( &paDetails );
            }

            kmxlRegCloseKey( hControlKey );
            pControl = kmxlNextControl( pControl );
        }

        kmxlRegCloseKey( hAllControlsKey );
        pLine = kmxlNextLine( pLine );
    }

    //
    //  After all of the persisting is done, save out a value indicating that the channel
    //  values are all valid for a multichannel restore.  This is to avoid the situation
    //  where the data for some of the channels is invalid.
    //
    bValidMultichannel = TRUE;
    kmxlRegSetValue(
        hMixerKey,
        VALID_MULTICHANNEL_MIXER_VALUE_NAME,
        REG_DWORD,
        &bValidMultichannel,
        sizeof( bValidMultichannel )
        );

    kmxlRegCloseKey( hMixerKey );

exit:

    if( hControlKey ) {
        kmxlRegCloseKey( hControlKey );
    }

    if( hAllControlsKey ) {
        kmxlRegCloseKey( hAllControlsKey );
    }

    if( hLineKey ) {
        kmxlRegCloseKey( hLineKey );
    }

    if( hMixerKey ) {
        kmxlRegCloseKey( hMixerKey );
    }

    if( hKey ) {
        kmxlRegCloseKey( hKey );
    }

    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlRetrieveAll
//
//

NTSTATUS
kmxlRetrieveAll(
    IN PFILE_OBJECT pfo,        // The instance to retrieve
    IN PMIXERDEVICE pmxd        // Mixer device info
)
{
    NTSTATUS    Status;
    WCHAR       sz[ 16 ];
    HANDLE      hMixerKey = NULL,
                hLineKey = NULL,
                hAllControlsKey = NULL,
                hControlKey = NULL;
    ULONG       ResultLength, Value, NumChannels, ControlCount;
    ULONG       LineCount = 0;
    ULONG       i,j;
    BOOL        bInvalidTopology = FALSE;
    PMXLLINE    pLine;
    PMXLCONTROL pControl;
    MIXERCONTROLDETAILS_UNSIGNED* paDetails = NULL;
    PCHANNEL_STEPPING pChannelStepping;
    BOOL              bValidMultichannel = FALSE;

    PAGED_CODE();
    //
    // Open the Mixer key under the interface key.  If somethings goes
    // wrong here, this does not have a valid topology.
    //

    Status = kmxlRegOpenMixerKey( pfo, pmxd, &hMixerKey );
    if( !NT_SUCCESS( Status ) ) {
        DPF(DL_TRACE|FA_PERSIST,( "failed to open mixer reg key!" ) );
        bInvalidTopology = TRUE;
        goto exit;
    } // if

    //
    //  Query for a valid multichannel mixer persistance
    //
    Status = kmxlRegQueryValue(
        hMixerKey,
        VALID_MULTICHANNEL_MIXER_VALUE_NAME,
        &bValidMultichannel,
        sizeof( bValidMultichannel ),
        &ResultLength
        );
    if( !NT_SUCCESS( Status ) ) {
        //  This should be set to FALSE for upgrades from Win2000 where the registry
        //  entries could be invalid for channels other than the first channel.
        bValidMultichannel = FALSE;
    } // if

    //
    // Query the total number of lines that have been persisted.
    //

    Status = kmxlRegQueryValue(
        hMixerKey,
        LINE_COUNT_VALUE_NAME,
        &LineCount,
        sizeof( LineCount ),
        &ResultLength
        );
    if( !NT_SUCCESS( Status ) ) {    
        DPF(DL_TRACE|FA_PERSIST,( "failed to read number of persisted lines!" ) );        
        bInvalidTopology = TRUE;
        goto exit;
    } // if

    //
    // Check to ensure the number of lines persisted is the same as
    // what is stored in memory.
    //

    if( LineCount != kmxlListLength( pmxd->listLines ) ) {
        DPF(DL_TRACE|FA_PERSIST,( "# of persisted lines does not match current topology!" ) );
        bInvalidTopology = TRUE;
        goto exit;
    } // if

    for( i = 0; i < LineCount; i++ ) {

        //
        // Construct the line key name and open the key.
        //

        swprintf( sz, LINE_KEY_NAME_FORMAT, i );
        Status = kmxlRegOpenKey(
            hMixerKey,
            sz,
            &hLineKey
            );
        if( !NT_SUCCESS( Status ) ) {
            break;
        } // if

        //
        // Query the line Id of this line.
        //

        Status = kmxlRegQueryValue(
            hLineKey,
            LINE_ID_VALUE_NAME,
            &Value,
            sizeof( Value ),
            &ResultLength
            );
        if( !NT_SUCCESS( Status ) ) {
            continue;
        } // if

        //
        // Verify the line Id is valid and retrieve a pointer to the line
        // structure.
        //

        pLine = kmxlFindDestById( pmxd->listLines, Value );
        if( pLine == NULL ) {
            DPF(DL_TRACE|FA_PERSIST,( "persisted line ID is invalid!" ) );
            bInvalidTopology = TRUE;
            break;
        } // if

        //
        // Retrieve the number of controls for this line.
        //

        Status = kmxlRegQueryValue(
            hLineKey,
            CONTROL_COUNT_VALUE_NAME,
            &Value,
            sizeof( Value ),
            &ResultLength
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlRegCloseKey( hLineKey );
            continue;
        } // if

        if( Value != pLine->Line.cControls ) {
            DPF(DL_TRACE|FA_PERSIST,( "the number of controls for line %x is invalid!",
                pLine->Line.dwLineID
                ) );
            bInvalidTopology = TRUE;
            break;
        } // if

        Status = kmxlRegOpenKey(
            hLineKey,
            CONTROLS_KEY_NAME,
            &hAllControlsKey
            );
        if( !NT_SUCCESS( Status ) ) {
            kmxlRegCloseKey( hLineKey );
            continue;
        } // if

        //
        // Query all the information for each control
        //

        ControlCount = 0;
        pControl = kmxlFirstInList( pLine->Controls );
        while( pControl ) {

            swprintf( sz, CONTROL_KEY_NAME_FORMAT, ControlCount++ );

            Status = kmxlRegOpenKey(
                hAllControlsKey,
                sz,
                &hControlKey
                );
            if( !NT_SUCCESS( Status ) ) {
                break;
            } // if

            Status = kmxlRegQueryValue(
                hControlKey,
                CHANNEL_COUNT_VALUE_NAME,
                &NumChannels,
                sizeof( NumChannels ),
                &ResultLength
                );
            if( !NT_SUCCESS( Status ) ) {
                if( pControl->Control.cMultipleItems == 0 ) {
                    //
                    // Controls that have multiple items (such as MUXes)
                    // don't have channel counts.  If this control does
                    // not have multiple items, then there is a problem
                    // in the registry.
                    //
                    kmxlRegCloseKey( hControlKey );
                    pControl = kmxlNextControl( pControl );
                    continue;
                }
            } // if

            if( ( NumChannels != pControl->NumChannels ) &&
                ( pControl->Control.cMultipleItems == 0 ) ) {
                DPF(DL_TRACE|FA_PERSIST,( "the number of channels for control %d on line %x is invalid.",
                    pControl->Control.dwControlID,
                    pLine->Line.dwLineID
                    ) );
                bInvalidTopology = TRUE;
                goto exit;
            }

            Status = kmxlRegQueryValue(
                hControlKey,
                CONTROL_TYPE_VALUE_NAME,
                &Value,
                sizeof( Value ),
                &ResultLength
                );
            if( !NT_SUCCESS( Status ) ) {
                kmxlRegCloseKey( hControlKey );
                pControl = kmxlNextControl( pControl );
                continue;
            } // if

            if( Value != pControl->Control.dwControlType ) {
                kmxlRegCloseKey( hControlKey );
                pControl = kmxlNextControl( pControl );
                continue;
            } // if

            Status = kmxlRegQueryValue(
                hControlKey,
                CONTROL_MULTIPLEITEMS_VALUE_NAME,
                &Value,
                sizeof( Value ),
                &ResultLength
                );
            if( !NT_SUCCESS( Status ) ) {
                bInvalidTopology = TRUE;
                DPF(DL_TRACE|FA_PERSIST, ( "cMultipleItems value not found!" ) );
                goto exit;
            }

            if( Value != pControl->Control.cMultipleItems ) {
                bInvalidTopology = TRUE;
                DPF(DL_TRACE|FA_PERSIST, ( "cMultipleItems does not match for control %x!",
                    pControl->Control.dwControlID
                    ) );
                goto exit;
            }

            //
            // Allocate memory for the data structures and
            // set the value.
            //

            if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {

                if( !NT_SUCCESS( AudioAllocateMemory_Paged(pControl->Control.cMultipleItems *
                                                              sizeof( MIXERCONTROLDETAILS_UNSIGNED ),
                                                           TAG_Audd_DETAILS,
                                                           ZERO_FILL_MEMORY,
                                                           &paDetails ) ) )
                {
                    kmxlRegCloseKey( hControlKey );
                    pControl = kmxlNextControl( pControl );
                    continue;
                }

                for( Value = 0; Value < pControl->Control.cMultipleItems; Value++ ) {
                    swprintf( sz, MULTIPLEITEM_VALUE_NAME_FORMAT, Value );

                    Status = kmxlRegQueryValue(
                        hControlKey,
                        sz,
                        &paDetails[ Value ].dwValue,
                        sizeof( paDetails[ Value ].dwValue ),
                        &ResultLength
                        );
                    if( !NT_SUCCESS( Status ) ) {
                        break;
                    }
                }


            } else {

                if( !NT_SUCCESS( AudioAllocateMemory_Paged(NumChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED ),
                                                           TAG_Audd_DETAILS,
                                                           ZERO_FILL_MEMORY,
                                                           &paDetails ) ) )
                {
                    kmxlRegCloseKey( hControlKey );
                    pControl = kmxlNextControl( pControl );
                    continue;
                } // if

                for( Value = 0; Value < NumChannels; Value++ ) {

                    //  check to see if the persisted values are valid for all channels
                    if ( ( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUTE ) &&
                         ( bValidMultichannel == FALSE ) )
                    {
                        swprintf( sz, CHANNEL_VALUE_NAME_FORMAT, 0 );  // Lock the persistance key to the first channel.
                                                                       // This is the only channel that we know is valid
                                                                       // at this time.
                    }
                    else
                    {
                        swprintf( sz, CHANNEL_VALUE_NAME_FORMAT, Value );
                    }

                    Status = kmxlRegQueryValue(
                        hControlKey,
                        sz,
                        &paDetails[ Value ].dwValue,
                        sizeof( paDetails[ Value ].dwValue ),
                        &ResultLength
                        );
                    if( !NT_SUCCESS( Status ) ) {
                        break;
                    } // if

                } // for( Value );
            }

            if( NT_SUCCESS( Status ) ) {

                //
                // This correction code should be here along with in the control
                // creation code.  Basically, if we're reading something from the 
                // registry that doesn't conform, we fix it up, but, chances are
                // it should be in the correct form.
                //
                if (pControl->pChannelStepping) {

                    pChannelStepping = pControl->pChannelStepping;
                    for (j = 0; j < pControl->NumChannels; j++, pChannelStepping++) {
                        /*
                        ASSERT ( pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536 );
                        ASSERT ( pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536 );
                        ASSERT ( pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535 );
                        */

                        if (!(pChannelStepping->MinValue >= -150*65536 && pChannelStepping->MinValue <= 150*65536)) {
                            DPF(DL_WARNING|FA_PERSIST,
                                ("MinValue %X of Control %X of type %X on Line %X Channel %X is out of range!",
                                pChannelStepping->MinValue,
                                pControl->Control.dwControlID,
                                pControl->Control.dwControlType,
                                pLine->Line.dwLineID,
                                j) );
                            pChannelStepping->MinValue = DEFAULT_RANGE_MIN;
                        }
                        if (!(pChannelStepping->MaxValue >= -150*65536 && pChannelStepping->MaxValue <= 150*65536)) {
                            DPF(DL_WARNING|FA_PERSIST,
                                ("MaxValue %X of Control %X of type %X on Line %X Channel %X is out of range!",
                                pChannelStepping->MaxValue,
                                pControl->Control.dwControlID,
                                pControl->Control.dwControlType,
                                pLine->Line.dwLineID,
                                j) );
                            pChannelStepping->MaxValue = DEFAULT_RANGE_MAX;
                        }
                        if (!(pChannelStepping->Steps >= 0 && pChannelStepping->Steps <= 65535)) {
                            DPF(DL_TRACE|FA_PERSIST,
                                ("Steps %X of Control %X of type %X on Line %X Channel %X is out of range!",
                                pChannelStepping->Steps,
                                pControl->Control.dwControlID,
                                pControl->Control.dwControlType,
                                pLine->Line.dwLineID,
                                j) );
                            pChannelStepping->Steps    = DEFAULT_RANGE_STEPS;
                            pControl->Control.Metrics.cSteps = DEFAULT_RANGE_STEPS;
                        }
                    }
                }

                kmxlSetCurrentControlValue(
                    pfo,
                    pmxd,
                    pLine,
                    pControl,
                    paDetails
                );

            }

            AudioFreeMemory_Unknown( &paDetails );
            kmxlRegCloseKey( hControlKey );
            pControl = kmxlNextControl( pControl );
        } // while( pControl );


        kmxlRegCloseKey( hAllControlsKey );
        kmxlRegCloseKey( hLineKey );

    } // for( i );

exit:

    if( hLineKey ) {
        kmxlRegCloseKey( hLineKey );
    }

    if( hMixerKey ) {
        kmxlRegCloseKey( hMixerKey );
    }

    if( bInvalidTopology ) {
        DPF(DL_TRACE|FA_PERSIST,( "Invalid topology persisted or key not found.  Rebuilding." ) );
        Status = kmxlRegOpenMixerKey( pfo, pmxd, &hMixerKey );
        if( NT_SUCCESS( Status ) ) {
            ZwDeleteKey( hMixerKey );
        }

        return( kmxlPersistAll( pfo, pmxd ) );
    }

    return( STATUS_SUCCESS );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlFindLineForControl
//
//

PMXLLINE
kmxlFindLineForControl(
    IN PMXLCONTROL pControl,
    IN LINELIST    listLines
)
{
    PMXLLINE    pLine;
    PMXLCONTROL pTControl;

    PAGED_CODE();
    if( pControl == NULL ) {
        return( NULL );
    }

    if( listLines == NULL ) {
        return( NULL );
    }

    pLine = kmxlFirstInList( listLines );
    while( pLine ) {

        pTControl = kmxlFirstInList( pLine->Controls );
        while( pTControl ) {
            if( pTControl == pControl ) {
                return( pLine );
            }

            pTControl = kmxlNextControl( pTControl );
        }
        pLine = kmxlNextLine( pLine );
    }

    return( NULL );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlPersistSingleControl
//
//

NTSTATUS
kmxlPersistSingleControl(
    IN PFILE_OBJECT pfo,        // The instance to retrieve
    IN PMIXERDEVICE pmxd,       // Mixer device info
    IN PMXLCONTROL  pControl,   // The control to persist
    IN PVOID        paDetails   // The channel values to persist
)
{
    NTSTATUS    Status;
    HANDLE      hMixerKey = NULL,
                hLineKey = NULL,
                hAllControlsKey = NULL,
                hControlKey = NULL;
    PMXLLINE    pTLine, pLine;
    PMXLCONTROL pTControl;
    ULONG       LineNum, ControlNum, i, Channels;
    WCHAR       sz[ 16 ];
    BOOL        bPersistAll = FALSE;
    BOOL        bValidMultichannel = FALSE;
    ULONG       ResultLength;

    PAGED_CODE();
    Status = kmxlRegOpenMixerKey( pfo, pmxd, &hMixerKey );
    if( !NT_SUCCESS( Status ) ) {
        return( kmxlPersistAll( pfo, pmxd ) );
    }

    //
    //  If we've never written out valid multichannel mixer settings, go ahead and
    //  do it here.
    //
    Status = kmxlRegQueryValue(
        hMixerKey,
        VALID_MULTICHANNEL_MIXER_VALUE_NAME,
        &bValidMultichannel,
        sizeof( bValidMultichannel ),
        &ResultLength
        );
    if( !NT_SUCCESS( Status ) || !(bValidMultichannel) ) {
        return( kmxlPersistAll( pfo, pmxd ) );
    }

    pLine = kmxlFindLineForControl( pControl, pmxd->listLines );
    if( pLine == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        DPF(DL_WARNING|FA_PERSIST,("KmxlFindLineForControl failed Status=%X",Status) );
        goto exit;
    }

    LineNum = 0;
    pTLine = kmxlFirstInList( pmxd->listLines );
    while( pTLine ) {

        if( pTLine == pLine ) {

            swprintf( sz, LINE_KEY_NAME_FORMAT, LineNum );
            Status = kmxlRegOpenKey( hMixerKey, sz, &hLineKey );
            if( !NT_SUCCESS( Status ) ) {
                bPersistAll = TRUE;
                goto exit;
            }

            Status = kmxlRegOpenKey( hLineKey, CONTROLS_KEY_NAME, &hAllControlsKey );
            if( !NT_SUCCESS( Status ) ) {
                bPersistAll = TRUE;
                goto exit;
            }

            ControlNum = 0;
            pTControl = kmxlFirstInList( pTLine->Controls );
            while( pTControl ) {

                if( pTControl == pControl ) {

                    swprintf( sz, CONTROL_KEY_NAME_FORMAT, ControlNum );
                    Status = kmxlRegOpenKey( hAllControlsKey, sz, &hControlKey );
                    if( !NT_SUCCESS( Status ) ) {
                        bPersistAll = TRUE;
                        goto exit;
                    }

                    kmxlRegSetValue(
                        hControlKey,
                        CONTROL_TYPE_VALUE_NAME,
                        REG_DWORD,
                        &pControl->Control.dwControlType,
                        sizeof( pControl->Control.dwControlType )
                        );

                    Status = kmxlGetCurrentControlValue(
                        pfo,
                        pmxd,
                        pLine,
                        pControl,
                        &paDetails
                        );

                    if( NT_SUCCESS( Status ) ) {

                        if( pControl->Control.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX ) {
                            for( i = 0; i < pControl->Control.cMultipleItems; i++ ) {

                                swprintf( sz, MULTIPLEITEM_VALUE_NAME_FORMAT, i );

                                Status = kmxlRegSetValue(
                                    hControlKey,
                                    sz,
                                    REG_DWORD,
                                    &((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ],
                                    sizeof( ((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ] )
                                    );

                            }

                        } else {

                            Channels = pControl->NumChannels;

                            kmxlRegSetValue(
                                hControlKey,
                                CHANNEL_COUNT_VALUE_NAME,
                                REG_DWORD,
                                &Channels,
                                sizeof( Channels )
                                );

                            for( i = 0; i < Channels; i++ ) {
                                swprintf( sz, CHANNEL_VALUE_NAME_FORMAT, i );

                                Status = kmxlRegSetValue(
                                    hControlKey,
                                    sz,
                                    REG_DWORD,
                                    &((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ],
                                    sizeof( ((PMIXERCONTROLDETAILS_UNSIGNED) paDetails)[ i ] )
                                    );
                            }
                        }
                        AudioFreeMemory_Unknown( &paDetails );
                    }
                    goto exit;

                } else {
                    pTControl = kmxlNextControl( pTControl );
                    ++ControlNum;
                }
            }

            Status = STATUS_SUCCESS;
            goto exit;

        } else {
            pTLine = kmxlNextLine( pTLine );
            ++LineNum;
        }

    }

    Status = STATUS_OBJECT_NAME_NOT_FOUND;
    DPF(DL_WARNING|FA_PERSIST,("kmxlPersistSingleControl failing Status=%X",Status) );

exit:

    if( hMixerKey ) {
        kmxlRegCloseKey( hMixerKey );
    }

    if( hLineKey ) {
        kmxlRegCloseKey( hLineKey );
    }

    if( hAllControlsKey ) {
        kmxlRegCloseKey( hAllControlsKey );
    }

    if( hControlKey ) {
        kmxlRegCloseKey( hControlKey );
    }

    if( bPersistAll ) {
        return( kmxlPersistAll( pfo, pmxd ) );
    }

    RETURN( Status );
}

///////////////////////////////////////////////////////////////////////
//
// kmxlPersistControl
//
//

NTSTATUS
kmxlPersistControl(
    IN PFILE_OBJECT pfo,        // The instance to retrieve
    IN PMIXERDEVICE pmxd,       // Mixer device info
    IN PMXLCONTROL  pControl,   // The control to persist
    IN PVOID        paDetails   // The channel values to persist
)
{
    PMXLLINE    pLine;
    PMXLCONTROL pCtrl;
    NTSTATUS    Status;
    NTSTATUS    OverallStatus;


    PAGED_CODE();
    OverallStatus=STATUS_SUCCESS;

    //
    // Persist the control that just changed.  Do not abort if this persist fails.
    //

    Status = kmxlPersistSingleControl( pfo, pmxd, pControl, paDetails );
    if( !NT_SUCCESS( Status ) ) {
        OverallStatus=Status;
        }

    //
    // Check all other controls and see if another control shares the same
    // node ID.  If so, persist that control with the new value also.
    // Again, do not abort if any of the persists fail.  Simply return the last
    // error status.
    //

    pLine = kmxlFirstInList( pmxd->listLines );
    while( pLine ) {

        pCtrl = kmxlFirstInList( pLine->Controls );
        while( pCtrl ) {

            if( pCtrl->Id==pControl->Id && pCtrl!=pControl ) {
                Status = kmxlPersistSingleControl( pfo, pmxd, pCtrl, paDetails );
                if( !NT_SUCCESS( Status ) ) {
                    OverallStatus=Status;
                }
            }

            pCtrl = kmxlNextControl( pCtrl );
        }

        pLine = kmxlNextLine( pLine );

    }

    RETURN( OverallStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\mixer.h ===
//---------------------------------------------------------------------------
//
//  Module:   mixer.h
//
//  Description:
//
//    Contains the declarations and prototypes for the Kernel Portion
//    of the mixer line driver (KMXL).
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//    D. Baumberger
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//---------------------------------------------------------------------------

#ifndef _MIXER_H_INCLUDED_
#define _MIXER_H_INCLUDED_

//#define API_TRACE
//#define PARSE_TRACE
#define SUPERMIX_AS_VOL

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//       M I X E R   L I N E  1 6 - b i t  S T R U C T U R E S       //
//                            ( A N S I )                            //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#ifdef WIN32
#    include <pshpack1.h>
#else
#    ifndef RC_INVOKED
#        pragma pack(1)
#    endif
#endif

typedef struct tagMIXERLINE16 {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    DWORD       dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    CHAR        szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR        szName[MIXER_LONG_NAME_CHARS];
    struct {
        DWORD   dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
        DWORD   dwDeviceID;             /* target device ID of device type */
        WORD    wMid;                   /* of target device */
        WORD    wPid;                   /*      " */
        WORD    vDriverVersion;       /*      " */
        CHAR    szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINE16, *PMIXERLINE16, *LPMIXERLINE16;

typedef struct tagMIXERCONTROL16 {
    DWORD           cbStruct;           /* size in bytes of MIXERCONTROL */
    DWORD           dwControlID;        /* unique control id for mixer device */
    DWORD           dwControlType;      /* MIXERCONTROL_CONTROLTYPE_xxx */
    DWORD           fdwControl;         /* MIXERCONTROL_CONTROLF_xxx */
    DWORD           cMultipleItems;     /* if MIXERCONTROL_CONTROLF_MULTIPLE set */
    CHAR            szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR            szName[MIXER_LONG_NAME_CHARS];
    union {
        struct {
            LONG    lMinimum;           /* signed minimum for this control */
            LONG    lMaximum;           /* signed maximum for this control */
        };
        struct {
            DWORD   dwMinimum;          /* unsigned minimum for this control */
            DWORD   dwMaximum;          /* unsigned maximum for this control */
        };
        DWORD       dwReserved[6];
    } Bounds;
    union {
        DWORD       cSteps;             /* # of steps between min & max */
        DWORD       cbCustomData;       /* size in bytes of custom data */
        DWORD       dwReserved[6];      /* !!! needed? we have cbStruct.... */
    } Metrics;
} MIXERCONTROL16, *PMIXERCONTROL16, *LPMIXERCONTROL16;

typedef struct tagMIXERLINECONTROLS16 {
    DWORD            cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD            dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
        DWORD        dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
        DWORD        dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD            cControls;      /* count of controls pmxctrl points to */
    DWORD            cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    LPMIXERCONTROL16 pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLS16, *PMIXERLINECONTROLS16, *LPMIXERLINECONTROLS16;

typedef struct tagMIXERCONTROLDETAILS_LISTTEXT16 {
    DWORD           dwParam1;
    DWORD           dwParam2;
    CHAR            szName[MIXER_LONG_NAME_CHARS];
} MIXERCONTROLDETAILS_LISTTEXT16, *PMIXERCONTROLDETAILS_LISTTEXT16, *LPMIXERCONTROLDETAILS_LISTTEXT16;

#ifdef WIN32
#    include <poppack.h>
#else
#    ifndef RC_INVOKED
#        pragma pack()
#    endif
#endif

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                          D E F I N E S                            //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#define PINID_WILDCARD ( (ULONG) -2 )

#define DESTINATION_LIST ( 0x01 )
#define SOURCE_LIST      ( 0x02 )

#define SLIST  SINGLE_LIST_ENTRY
#define PSLIST SLIST*

#define MAX_CHANNELS    0xFFFF

//#define MIXERCONTROL_CONTROLTYPE_BASS_BOOST 0x20012277

#define INVALID_ID ( 0xDEADBEEF )

#define TOPOLOGY_DRIVER_NAME L"\\DosDevices\\sysaudio\\MIXER"
//#define TOPOLOGY_DRIVER_NAME L"\\DosDevices\\PortClass0\\TOPOLOGY"

#define STR_SHORT_AGC         "AGC"
#define STR_AGC               "Automatic Gain Control"
#define STR_SHORT_LOUDNESS    "Loudness"
#define STR_LOUDNESS          STR_SHORT_LOUDNESS
#define STR_SHORT_MUTE        "Mute"
#define STR_MUTE              STR_SHORT_MUTE
#define STR_SHORT_TREBLE      "Treble"
#define STR_TREBLE            STR_SHORT_TREBLE
#define STR_SHORT_BASS        "Bass"
#define STR_BASS              STR_SHORT_BASS
#define STR_SHORT_VOLUME      "Volume"
#define STR_VOLUME            STR_SHORT_VOLUME
#define STR_SHORT_MUX         "Mux"
#define STR_MUX               "Source Mux"
#define STR_SHORT_BASS_BOOST  "Bass Boost"
#define STR_BASS_BOOST        STR_SHORT_BASS_BOOST

//
// The SwapEm macro function will swap the contents of any SLIST based
// list.  A and B are the elements to swap.  T is a temporary variable
// of the same type as A and B to use a temporary storage.  size is
// the size of the structure in the list, including the SLIST element.
// The macro does not copy the pointer stored in SLIST.
//

#define SwapEm(A, B, T, size)                \
    memcpy( ((BYTE*) (T)) + sizeof( SLIST ), \
            ((BYTE*) (A)) + sizeof( SLIST ), \
            size - sizeof( SLIST ) );        \
    memcpy( ((BYTE*) (A)) + sizeof( SLIST ), \
            ((BYTE*) (B)) + sizeof( SLIST ), \
            size - sizeof( SLIST ) );        \
    memcpy( ((BYTE*) (B)) + sizeof( SLIST ), \
            ((BYTE*) (T)) + sizeof( SLIST ), \
            size - sizeof( SLIST ) )

//
// IsValidLine determines if the line pointed to by pLine is valid.  A valid
// line is determined by having valid Source and Dest Ids.
//

#define Is_Valid_Line( pLine ) ( ( pLine->SourceId != INVALID_ID ) && \
                                 ( pLine->DestId   != INVALID_ID ) )


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//   F O R W A R D   R E F E R E N C E S
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

typedef struct tag_MIXERDEVICE *PMIXERDEVICE;

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                       S T R U C T U R E S                         //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

typedef struct tag_CHANNEL_STEPPING {
    LONG MinValue;
    LONG MaxValue;
    LONG Steps;
} CHANNEL_STEPPING, *PCHANNEL_STEPPING;

typedef enum tagMXLNODE_TYPE { SOURCE, DESTINATION, NODE } MXLNODE_TYPE;

typedef struct tagMXLCONTROL {
    SLIST         List;          // MUST BE THE FIRST MEMBER!
    MIXERCONTROL  Control;       // The MixerControl structure for the control
    CONST GUID*   NodeType;      // The type of node this control represents
    ULONG         Id;            // The Node Id this control represents
    ULONG         PropertyId;    // The KS property used for GET/SET
    BOOL          bScaled;       // Linear->Log scaling

    ULONG             NumChannels;
    PCHANNEL_STEPPING pChannelStepping;

    union {

        //
        // Supermixer parameters
        //

        struct {
            PLONG                 pReferenceCount;
            ULONG                 Size;
            PKSAUDIO_MIXCAP_TABLE pMixCaps;
            PKSAUDIO_MIXLEVEL     pMixLevels;   // Stored mix levels
        };

        //
        // Parameters for muxes
        //

        struct {
            BOOL                           bPlaceholder;
            BOOL                           bHasCopy;    // bHasCopy must be
                                                        // set to TRUE unless
                                                        // this control owns
                                                        // the original mem.
            ULONG                          Count;
            LPMIXERCONTROLDETAILS_LISTTEXT lpmcd_lt;
            ULONG*                         pPins;
        };

    } Parameters;
#ifdef DEBUG
    DWORD         Tag;           // 'CTRL' if valid control
#endif
} MXLCONTROL, *PMXLCONTROL, *CONTROLLIST;

typedef struct tagMXLLINE {
    SLIST               List;          // MUST BE THE FIRST MEMBER!
    MIXERLINE           Line;          // The MixerLine structure for the line
    CONTROLLIST         Controls;      // The list of controls associated with line
    ULONG               SourceId;      // Source Pin Id this line corresponds to
    ULONG               DestId;        // Dest Pin Id this line corresponds to
    GUID                Type;          // The type of line this is
    KSPIN_COMMUNICATION Communication; // KSPIN_COMMUNICATION of the line
    BOOL                bMute;
} MXLLINE, *PMXLLINE, *LINELIST;

typedef struct tagPEERNODE* PEERLIST;

typedef struct tagMXLNODE {
    SLIST               List;           // MUST BE THE FIRST MEMBER!
    MXLNODE_TYPE        Type;           // Type of node: SOURCE, DEST, or NODE
    GUID                NodeType;       // KSNODETYPE of the node
    KSPIN_COMMUNICATION Communication;  // KSPIN_COMMUNICATION of the node
    ULONG               Id;             // Pin or node ID
    PEERLIST            Children;       // List of Children
    PEERLIST            Parents;        // List of Parents
} MXLNODE, *PMXLNODE, *NODELIST;

typedef struct tagPEERNODE {
    SLIST        List;           // MUST BE THE FIRST MEMBER!
    PMXLNODE     pNode;          // Pointer to the mixer node
} PEERNODE, *PPEERNODE;

typedef struct tagMIXEROBJECT {
    PFILE_OBJECT pfo;
    PMXLNODE     pNodeTable;
    PKSTOPOLOGY  pTopology;
    CONTROLLIST  listMuxControls;
    DWORD        dwControlId;
    PMIXERDEVICE pMixerDevice;
#ifdef DEBUG
    DWORD        dwSig;
#endif
    PWSTR        DeviceInterface;
} MIXEROBJECT, *PMIXEROBJECT;

typedef enum {
     MIXER_MAPPING_LOGRITHMIC,
     MIXER_MAPPING_LINEAR,
     MIXER_MAPPING_EXPONENTIAL
} MIXERMAPPING;


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                        M A C R O  C I T Y :                       //
//    L I S T  M A N A G E M E N T  M A C R O  F U N C T I O N S     //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//
// Next in list retrieval macros
//

#define NextInList( pList, Type )   (( Type* ) ( pList->List.Next ) )

#define kmxlNextNode( pNode )       NextInList( pNode,    MXLNODE    )
#define kmxlNextPeerNode( pNode )   NextInList( pNode,    PEERNODE   )
#define kmxlNextControl( pControl ) NextInList( pControl, MXLCONTROL )
#define kmxlNextLine( pLine )       NextInList( pLine,    MXLLINE    )

//
// First in list retrieval macros
//

#define kmxlFirstInList( NodeList )  ( NodeList )
#define kmxlFirstChildNode( pNode )  (( PEERNODE* ) (pNode)->Children )
#define kmxlFirstParentNode( pNode ) (( PEERNODE* ) (pNode)->Parents  )

//
// List count macros
//

#define kmxlParentListLength( pNode ) kmxlListCount( (PSLIST) pNode->Parents  )
#define kmxlChildListLength( pNode )  kmxlListCount( (PSLIST) pNode->Children )
#define kmxlListLength( List )        kmxlListCount( (PSLIST) List            )

//
// Added to a list macros
//

#define kmxlAddToList( pNodeList, pNode )                             \
            if( pNodeList ) {                                         \
                (pNode)->List.Next = (PSLIST) (pNodeList);            \
                (pNodeList)        = (pNode);                         \
            } else {                                                  \
                (pNode)->List.Next = NULL;                            \
                (pNodeList) = (pNode);                                \
            }

#define kmxlAddToEndOfList( list, node )                              \
            kmxlAddElemToEndOfList( ((PSLIST*) &(list)), (PSLIST) (node) )

#define kxmlAddLineToEndOfList( list, node )
#define kmxlAddToChildList( NodeList, Node )                          \
            ASSERT( (Node)->pNode );                                  \
            kmxlAddToList( (NodeList)->Children, (Node) );

#define kmxlAddToParentList( NodeList, Node )                         \
            ASSERT( (Node)->pNode );                                  \
            kmxlAddToList( (NodeList)->Parents, (Node) );


//
// Remove from a list macros
//

#define RemoveFirstEntry( list, Type )                                \
            (Type*) (list);                                           \
            {                                                         \
                PSLIST pRFETemp;                                      \
                pRFETemp = (PSLIST) (list);                           \
                if( (list) ) {                                        \
                    (list) = (Type*) (list)->List.Next;               \
                    if( pRFETemp ) {                                  \
                        ((Type*) pRFETemp)->List.Next = NULL;         \
                    }                                                 \
                }                                                     \
            }


#define kmxlRemoveFirstNode( pNodeList )                              \
            RemoveFirstEntry( (pNodeList), MXLNODE )

#define kmxlRemoveFirstControl( pControlList )                        \
            RemoveFirstEntry( (pControlList), MXLCONTROL )

#define kmxlRemoveFirstLine( pLineList )                              \
            RemoveFirstEntry( (pLineList), MXLLINE )

#define kmxlRemoveFirstPeerNode( pPeerList )                          \
            RemoveFirstEntry( (pPeerList), PEERNODE )

#define kmxlRemoveFirstChildNode( pNode )                             \
            RemoveFirstEntry( (pNode)->Children, PEERNODE )

#define kmxlRemoveFirstParentNode( pNode )                            \
            RemoveFirstEntry( (pNode)->Parents, PEERNODE )

#ifdef DEBUG
#define CONTROL_TAG 'LRTC'  //CTRL as seen in memory.
#else
#define CONTROL_TAG
#endif // DEBUG

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                        P R O T O T Y P E S                        //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//   I N I T I A L I Z A T I O N / D E I N I T I A L I Z A T I O N   //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlInit
//
// Retrieves and parses the topology for a given mixer device number.
// The pfo is an open file object to an instance of a filter that
// will provide the topology.
//
//

NTSTATUS
kmxlInit(
    IN PFILE_OBJECT pfo,        // Handle of the topology driver instance
    IN PMIXERDEVICE pMixerDevice    // The device to initialize for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlDeInit
//
// Cleans up all memory for all devices.
//
//

NTSTATUS
kmxlDeInit(
    IN PMIXERDEVICE pMixerDevice
);

///////////////////////////////////////////////////////////////////////
//
// BuildMixerLines
//
// Build the list of mixer lines and stores them into plistLines.
// pcDestinations contains the count of total destinations for the
// given topology, pTopology.
//
//

NTSTATUS
kmxlBuildLines(
    IN     PMIXERDEVICE pMixer,         // The mixer device
    IN     PFILE_OBJECT pfoInstance,    // The FILE_OBJECT of a filter instance
    IN OUT LINELIST*    plistLines,     // Pointer to the list of all lines
    IN OUT PULONG       pcDestinations, // Pointer to the number of dests
    IN OUT PKSTOPOLOGY  pTopology       // Pointer to a topology structure
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                 T O P O L O G Y  F U N C T I O N S                //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// QueryTopology
//
// Queries the topology property on the given instance and stores
// it into pTopology.  Note that memory is allocated to store the
// topology.
//
//

NTSTATUS
kmxlQueryTopology(
    IN  PFILE_OBJECT pfoInstance,   // The instance to query
    OUT PKSTOPOLOGY  pTopology      // The topology structure to fill in
);

///////////////////////////////////////////////////////////////////////
//
// ParseTopology
//
// Parses the topology in pTopology and builds a graph of sources and
// destinations.  ppSources will contain a list of all sources nodes
// and ppDests will contain a list of dests.  The elements in pNodeTable
// will be updated.
//
//

NTSTATUS
kmxlParseTopology(
    IN      PMIXEROBJECT pmxobj,
    OUT     NODELIST*    ppSources,   // Pointer to the sources list to build
    OUT     NODELIST*    ppDests      // Pointer to the dests list to build
);

///////////////////////////////////////////////////////////////////////
//
// BuildChildGraph
//
// For a given node, BuildChildGraph() will build the graph of each
// of the node's children.  pNodeTable is updated.
//
//

NTSTATUS
kmxlBuildChildGraph(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST    listDests,     // The list of destinations
    IN PMXLNODE    pNode,         // The node to build the graph for
    IN ULONG       FromNode,      // The node's ID
    IN ULONG       FromNodePin    // The Pin connection to look for
);

///////////////////////////////////////////////////////////////////////
//
// BuildNodeTable
//
// Allocates and fills in the table of nodes for the topology.
//
//

PMXLNODE
kmxlBuildNodeTable(
    IN PKSTOPOLOGY pTopology       // The topology structure to build from
);

///////////////////////////////////////////////////////////////////////
//
// FindTopologyConnection
//
// Finds the specified connection, if it exists, starting at the
// StartIndex index into the connections table.  It will return the
// index into the connection table of a connection starting from
// the given FromNode and FromNodePin.  FromNodePin may be PINID_WILDCARD
// if a connection on a node is present rather than a specific connection.
//
//

ULONG
kmxlFindTopologyConnection(
    IN PMIXEROBJECT                 pmxobj,
    //IN CONST KSTOPOLOGY_CONNECTION* pConnections,   // The connection table
    //IN ULONG                        cConnections,   // The # of connections
    IN ULONG                        StartIndex,     // Index to start search
    IN ULONG                        FromNode,       // The Node ID to look for
    IN ULONG                        FromNodePin     // The Pin ID to look for
);

///////////////////////////////////////////////////////////////////////
//
// GetProperty
//
// Retrieves the specified property from an open filter.  Flags may
// contain values such as KSPROPERTY_TYPE_TOPOLOGY.  The output
// buffer is allocated to the correct size and returned by this
// function.
//
//

NTSTATUS
kmxlGetProperty(
    PFILE_OBJECT pFileObject,       // The instance of the filter
    CONST GUID   *pguidPropertySet, // The requested property set
    ULONG        ulPropertyId,      // The ID of the specific property
    ULONG        cbInput,           // The number of extra input bytes
    PVOID        pInputData,        // Pointer to the extra input bytes
    ULONG        Flags,             // Additional flags
    PVOID        *ppPropertyOutput  // Pointer to a pointer of the output
);

///////////////////////////////////////////////////////////////////////
//
// kmxlNodeProperty
//
// NodeProperty() gets or sets the property on an individual node.
// The output is not allocated and must be passed in by the caller.
// Flags can be KSPROPERTY_TYPE_GET or KSPROPERTY_TYPE_SET.
//
//

NTSTATUS
kmxlNodeProperty(
    IN  PFILE_OBJECT pFileObject,       // Instance of the filter owning node
    IN  CONST GUID*  pguidPropertySet,  // The GUID of the property set
    IN  ULONG        ulPropertyId,      // The specific property in the set
    IN  ULONG        ulNodeId,          // The virtual node id
    IN  ULONG        cbInput,           // # of extra input bytes
    IN  PVOID        pInputData,        // Pointer to the extra input bytes
    OUT PVOID        pPropertyOutput,   // Pointer to the output data
    IN  ULONG        cbPropertyOutput,  // Size of the output data buffer
    IN  ULONG        Flags              // KSPROPERTY_TYPE_GET or SET
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNodeProperty
//
// Get the specified property for a node.  See kmxlNodeProperty for
// details on parameters and returns.
//
//

#define kmxlGetNodeProperty( pfo,pguid,Id,Node,cbIn,pIn,pOut,cbOut ) \
    kmxlNodeProperty( pfo,pguid,Id,Node,cbIn,pIn,pOut,cbOut,KSPROPERTY_TYPE_GET )

///////////////////////////////////////////////////////////////////////
//
// kmxlSetNodeProperty
//
// Sets the specified property for a node.  See kmxlNodeProperty for
// details on parameters and returns.
//
//

#define kmxlSetNodeProperty( pfo,pguid,Id,Node,cbIn,pIn,pOut,cbOut ) \
    kmxlNodeProperty( pfo,pguid,Id,Node,cbIn,pIn,pOut,cbOut,KSPROPERTY_TYPE_SET )

///////////////////////////////////////////////////////////////////////
//
// kmxlAudioNodeProperty
//
// Sets or get the audio specific node property.  The property set
// is always KSPROPSETID_Audio.  lChannel specifies which channel to
// apply the property to.  0 is left, 1 is right, -1 is master (all).
// Flags can be either KSPROPERTY_TYPE_GET or KSPROPERTY_TYPE_SET.
//
//

NTSTATUS
kmxlAudioNodeProperty(
    IN  PFILE_OBJECT pfo,               // Instance of the filter owning node
    IN  ULONG        ulPropertyId,      // The audio property to get
    IN  ULONG        ulNodeId,          // The virtual node id
    IN  LONG         lChannel,          // The channel number
    IN  PVOID        pInData,           // Pointer to extra input bytes
    IN  ULONG        cbInData,          // Number of extra input bytes
    OUT PVOID        pOutData,          // Pointer to output buffer
    IN  LONG         cbOutData,         // Size of the output buffer
    IN  ULONG        Flags              // KSPROPERTY_TYPE_GET or SET
);

///////////////////////////////////////////////////////////////////////
//
// kxmlGetAudioNodeProperty
//
// Gets the specified audio property on a node.  See kmxlAudioNodeProperty
// for details on parameters and return values.
//
//

#define kmxlGetAudioNodeProperty(pfo,Id,Node,Chan,pIn,cbIn,pOut,cbOut) \
    kmxlAudioNodeProperty( pfo,Id,Node,Chan,pIn,cbIn,pOut,cbOut,KSPROPERTY_TYPE_GET )

///////////////////////////////////////////////////////////////////////
//
// kxmlSetAudioNodeProperty
//
// Sets the specified audio property on a node.  See kmxlAudioNodeProperty
// for details on parameters and return values.
//
//

#define kmxlSetAudioNodeProperty(pfo,Id,Node,Chan,pIn,cbIn,pOut,cbOut) \
    kmxlAudioNodeProperty( pfo,Id,Node,Chan,pIn,cbIn,pOut,cbOut,KSPROPERTY_TYPE_SET )

///////////////////////////////////////////////////////////////////////
//
// kmxlGetPinName
//
// Retrieves the name of the pin given by NodeId.
//
//

VOID
kmxlGetPinName(
    IN PFILE_OBJECT pfo,                // Instance of the owning filter
    IN ULONG        PinId,              // Id of the pin
    IN PMXLLINE     pLine               // The line to store the name into
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNodeName
//
// Retrieves the name of a node (control).
//
//

VOID
kmxlGetNodeName(
    IN PFILE_OBJECT pfo,                // Instance of the owning filter
    IN ULONG        NodeId,             // The node id
    IN PMXLCONTROL  pControl            // The control to store the name
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetSuperMixCaps
//
//

NTSTATUS
kmxlGetSuperMixCaps(
    IN PFILE_OBJECT        pfo,
    IN ULONG               ulNodeId,
    OUT PKSAUDIO_MIXCAP_TABLE* paMixCaps
);

///////////////////////////////////////////////////////////////////////
//
// kmxlQueryPropertyRange
//
//

NTSTATUS
kmxlQueryPropertyRange(
    IN  PFILE_OBJECT             pfo,
    IN  CONST GUID*              pguidPropSet,
    IN  ULONG                    ulPropertyId,
    IN  ULONG                    ulNodeId,
    OUT PKSPROPERTY_DESCRIPTION* ppPropDesc
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlChannels
//
//

NTSTATUS
kmxlGetControlChannels(
    IN PFILE_OBJECT pfo,
    IN PMXLCONTROL  pControl
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetControlRange
//
//

NTSTATUS
kmxlGetControlRange(
    IN PFILE_OBJECT pfo,
    IN PMXLCONTROL  pControl
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetNumMuxLines
//
//

DWORD
kmxlGetNumMuxLines(
    IN PKSTOPOLOGY  pTopology,
    IN ULONG        NodeId
);

///////////////////////////////////////////////////////////////////////
//
// kmxlGetMuxLineNames
//
//

VOID
kmxlGetMuxLineNames(
    IN PMIXEROBJECT pmxobj,
    IN PMXLCONTROL  pControl
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//               M I X E R L I N E  F U N C T I O N S                //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildDestinationLines
//
// Builds up a list of destination lines given a list of the destination
// nodes.
//
// Returns NULL on error.
//
//

LINELIST
kmxlBuildDestinationLines(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST     listDests     // The list of destination nodes
);

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildDestinationControls
//
// Builds a list of mixer line controls for a given destination line.
//
//

NTSTATUS
kmxlBuildDestinationControls(
    IN  PMIXEROBJECT pmxobj,
    IN  PMXLNODE     pDest,         // The destination to built controls for
    IN  PMXLLINE     pLine          // The line to add the controls to
);


///////////////////////////////////////////////////////////////////////
//
// kmxlBuildSourceLines
//
// Builds a list of mixer source lines for the given topology.
//
//

LINELIST
kmxlBuildSourceLines(
    IN PMIXEROBJECT pmxobj,
    IN NODELIST     listSources,    // The list of source nodes
    IN NODELIST     listDests       // The list of dest. nodes
);

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildPath
//
// Builds the controls for each of the source lines, building new
// source lines of splits are detected in the topology.  plistLines
// may have new lines added if splits are encountered.  Destinations
// for each of the sources is also determined.
//
//

NTSTATUS
kmxlBuildPath(
    IN     PMIXEROBJECT pmxobj,
    IN     PMXLNODE     pSource,      // The source node for this path
    IN     PMXLNODE     pNode,        // The current node in the path
    IN     PMXLLINE     pLine,        // The current line
    IN OUT LINELIST*    plistLines,   // The list of lines build so far
    IN     NODELIST     listDests     // The list of the destinations
);

///////////////////////////////////////////////////////////////////////
//
// kmxlIsDestinationNode
//
// Return TRUE if the given node appears in the node list of any
// of the destinations in listDests.
//
//

BOOL
kmxlIsDestinationNode(
    IN NODELIST listDests,              // The list of destinations
    IN PMXLNODE pNode                   // The node to check
);

///////////////////////////////////////////////////////////////////////
//
// kmxlDuplicateLine
//
// Duplicates the given line, including all controls on that line.
//
//

NTSTATUS
kmxlDuplicateLine(
    IN PMXLLINE* ppTargetLine,          // Pointer to the new line
    IN PMXLLINE  pSourceLine            // The line to duplicate
);

///////////////////////////////////////////////////////////////////////
//
// kmxlDuplicateLineControls
//
// Duplicate up to nCount controls on the source line and stores them
// into the target line.
//
//

NTSTATUS
kmxlDuplicateLineControls(
    IN PMXLLINE pTargetLine,            // The line to put the controls into
    IN PMXLLINE pSourceLine,            // The line with the controls to dup
    IN ULONG    nCount                  // The number of controls to dup
);

///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestinationForNode
//
// For a given node, this function finds the destination it is assoicated
// with.  plistLines needs to be included since new lines will need to
// be created if a split is encountered in the topology.
//
//

ULONG
kmxlFindDestinationForNode(
    IN     PMIXEROBJECT pmxobj,
    IN     PMXLNODE     pNode,             // The node to find dest for
    IN     PMXLNODE     pParent,           // The original parent
    IN     PMXLLINE     pLine,             // The current line it's on
    IN OUT LINELIST*    plistLines         // The list of all lines
);

///////////////////////////////////////////////////////////////////////
//
// kmxlBuildVirtualMuxLine
//
//

NTSTATUS
kmxlBuildVirtualMuxLine(
    IN PMIXEROBJECT  pmxobj,
    IN PMXLNODE      pParent,
    IN PMXLNODE      pMux,
    IN OUT LINELIST* plistLines
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignLineAndControlIds
//
// For a specific set of lines, this function assigns the mixer line
// line Ids and controls Ids.  Only sources or only destinations can
// be assigned per call.
//
//

NTSTATUS
kmxlAssignLineAndControlIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST listLines,              // The list to assign ids for
    IN ULONG    ListType                // LIST_SOURCE or LIST_DESTINATION
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignDestinationsToSources
//
// For each line, the destination field of the MIXERLINE structure
// is filled in and a unique LineId is assigned.
//
//

NTSTATUS
kmxlAssignDestinationsToSources(
    IN LINELIST listSourceLines,        // The list of all source lines
    IN LINELIST listDestLines           // The list of all dest lines
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignMuxIds
//
//

NTSTATUS
kmxlAssignMuxIds(
    IN PMIXEROBJECT pmxobj,
    IN LINELIST     listSourceLines
);

///////////////////////////////////////////////////////////////////////
//
// TranslateNodeToControl
//
// Translates the node specified by its GUID into 0 or more mixer
// line controls.  The return value indicates how many controls
// the node was really translated into.
//
//

ULONG
kmxlTranslateNodeToControl(
    IN  PMIXEROBJECT  pmxobj,
    IN  PMXLNODE      pNode,            // The node to translate into a control
    OUT PMXLCONTROL*  ppControl         // The control to fill in
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsControl
//
// Queries for property on control to see if it is actually supported
//
//

NTSTATUS
kmxlSupportsControl(
    IN PFILE_OBJECT pfoInstance,        // The instance to check for
    IN ULONG        Node,               // The node ID on the instance
    IN ULONG        Property            // The property to query support
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsMultiChannelControl
//
// Queries for property on the second channel of the control to see
// independent levels can be set.  It is assumed that the first channel
// already succeeded in kmxlSupportsControl
//
//

NTSTATUS
kmxlSupportsMultiChannelControl(
    IN PFILE_OBJECT pfoInstance,    // The instance to check for
    IN ULONG        Node,           // The node id to query
    IN ULONG        Property        // The property to check for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsTrebleControl
//
// Querys the node to see if it supports KSPROPERTY_AUDIO_TREBLE.
// See kmxlSupportsControl for return value details.
//
//

#define kmxlSupportsTrebleControl( pfo, Node ) \
    kmxlSupportsControl( pfo, Node, KSPROPERTY_AUDIO_TREBLE )

///////////////////////////////////////////////////////////////////////
//
// kmxlSupportsBassControl
//
// Querys the node to see if it supports KSPROPERTY_AUDIO_BASS.
// See kmxlSupportsControl for return value details.
//
//

#define kmxlSupportsBassControl( pfo, Node ) \
    kmxlSupportsControl( pfo, Node, KSPROPERTY_AUDIO_BASS )

///////////////////////////////////////////////////////////////////////
//
// kmxlUpdateDestinationConnectionCount
//
// Counts the number of sources mapping to a single destination and
// stores that value in the MIXERLINE.cConnections field for that
// destination.
//
//

NTSTATUS
kmxlUpdateDestintationConnectionCount(
    IN LINELIST listSourceLines,        // The list of sources
    IN LINELIST listDestLines           // The list of destinations
);

///////////////////////////////////////////////////////////////////////
//
// kmxlElminiateInvalidLines
//
// Loops through all the lines and eliminates the ones that are
// invalid by the IsValidLine() macro function test.
//
//

NTSTATUS
kmxlEliminateInvalidLines(
    IN LINELIST* listLines               // The list of sources
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAssignComponentIds
//
// For each source and destination line, it assignes the
// MIXERLINE.dwComonentType field for that line.
//
//

VOID
kmxlAssignComponentIds(
    IN PMIXEROBJECT pmxobj,             // Instance data
    IN LINELIST     listSourceLines,    // The list of source lines
    IN LINELIST     listDestLines       // The list of destination lines
);


///////////////////////////////////////////////////////////////////////
//
// kmxlDetermineDestinationType
//
// Determines the dwComponentId and Target.dwType fields for the
// given line.  Determination is made by the MXLLINE.Type field.
//
//

ULONG
kmxlDetermineDestinationType(
    IN PMIXEROBJECT pmxobj,             // Instance data
    IN PMXLLINE     pLine               // The line to update
);

///////////////////////////////////////////////////////////////////////
//
// kmxlDetermineSourceType
//
// Determines the dwComponentId and Target.dwType fields for the
// given line.  Determination is made by the MXLLINE.Type field.
//
//

ULONG
kmxlDetermineSourceType(
    IN PMIXEROBJECT pmxobj,             // Instance data
    IN PMXLLINE     pLine               // The line to update
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//                  U T I L I T Y  F U N C T I O N S                 //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlOpenSysAudio
//
// Opens the SysAudio device and returns the file object.
//
//

PFILE_OBJECT
kmxlOpenSysAudio(
);

///////////////////////////////////////////////////////////////////////
//
// kmxlCloseSysAudio
//
// Closes the SysAudio device opened by kmxlOpenSysAudio.
//
//

VOID
kmxlCloseSysAudio(
    IN PFILE_OBJECT pfo                 // The instance to close
);

///////////////////////////////////////////////////////////////////////
//
// kmxlFindDestination
//
// Finds a destination id in the list of all the destinations and returns
// a pointer to that node.  Returns NULL on failure.
//
//

PMXLNODE
kmxlFindDestination(
    IN NODELIST listDests,              // The list of destinations to search
    IN ULONG    Id                      // The node Id to look for in the list
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAppendListToList
//
// Appends listSource onto the front of plistTarget.
//
//

VOID
kmxlAppendListToList(
    IN OUT PSLIST* plistTarget,         // The list to append to
    IN     PSLIST  listSource           // the list to append
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAppendListToList
//
// Appends listSource onto the end of plistTarget
//
//


VOID
kmxlAppendListToEndOfList(
    IN OUT PSLIST* plistTarget,         // The list to append to
    IN     PSLIST  listSource           // the list to append
);

///////////////////////////////////////////////////////////////////////
//
// kmxlListCount
//
// Returns the number of elements in the list.
//
//

ULONG
kmxlListCount(
    IN PSLIST pList                     // The list to count the elements of
);

///////////////////////////////////////////////////////////////////////
//
// kmxlInList
//
// Return TRUE if pNewNode is in the list.
//
//

BOOL
kmxlInList(
    IN PEERLIST  list,                  // The list to search
    IN PMXLNODE  pNewNode               // The new to search for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAddElemToEndOfList
//
// Adds an element to the end of the given list.
//
//

VOID
kmxlAddElemToEndOfList(
    IN OUT PSLIST* list,                // The list to add to the end of
    IN PSLIST      elem                 // The element or list to add
);

///////////////////////////////////////////////////////////////////////
//
// kmxlInChildList
//
// Return TRUE if pNewNode is contained in the child list of the list.
//
//

BOOL
kmxlInChildList(
    IN NODELIST list,                   // The list to search the parent list
    IN PMXLNODE pNewNode                // The node to search for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlInParentList
//
// Returns TRUE if pNewNode is contained in the parent list of the list.
//
//

BOOL
kmxlInParentList(
    IN NODELIST list,                   // The list to search the parent list
    IN PMXLNODE pNewNode                // The node to search for
);

///////////////////////////////////////////////////////////////////////
//
// kmxlSortByDestination
//
// Sorts the given list by destination id in increasing order.
//
//

NTSTATUS
kmxlSortByDestination(
    IN LINELIST* list                   // The pointer to the list to sort
);

///////////////////////////////////////////////////////////////////////
//
// kmxlVolLinearToLog
//
//

LONG
kmxlVolLinearToLog(
    IN PMXLCONTROL  pControl,
    IN DWORD        dwLin,
    IN MIXERMAPPING Mapping,
    IN ULONG        Channel
);

///////////////////////////////////////////////////////////////////////
//
// kmxlVolLogToLinear
//
//

DWORD
kmxlVolLogToLinear(
    IN PMXLCONTROL  pControl,
    IN LONG         lLog,
    IN MIXERMAPPING Mapping,
    IN ULONG        Channel
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//    M E M O R Y  A L L O C A T I O N / D E A L L O C A T I O N     //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocMem
//
// Allocates size bytes and stores that pointer in pp.  Returns
// STATUS_SUCCESS or another STATUS failure code.
//
//

//NTSTATUS
//kmxlAllocMem(
//    IN PVOID *pp,                       // Pointer to put the new memory in
//    IN ULONG size,                      // The number of bytes to allocate
//    IN ULONG ultag
//);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocDeviceInfo
//

NTSTATUS kmxlAllocDeviceInfo(
    OUT LPDEVICEINFO *pp,
    PCWSTR DeviceInterface,
    DWORD dwFlags,
    ULONG ultag
);

///////////////////////////////////////////////////////////////////////
//
// kmxlFreeMem
//
//
// Frees the memory pointed to by p.  Does nothing if p is NULL.
//
//

//VOID
//kmxlFreeMem(
//    IN PVOID p                          // The pointer to the buffer to free
//);

///////////////////////////////////////////////////////////////////////
//
// kmxlFreePeerList
//
// Loops through a peer list freeing all the peer nodes.
//
//

VOID
kmxlFreePeerList(
    IN PEERLIST list                    // The PeerList to free
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateControl
//
// Allocates and zero fills a new MXLCONTROL structure.
//
//

MXLCONTROL*
kmxlAllocateControl(
    IN ULONG ultag
);

VOID kmxlFreeControl(
    IN PMXLCONTROL pControl
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateLine
//
// Allocates and zero filles a new MXLLINE structure.
//
//

MXLLINE*
kmxlAllocateLine(
    IN ULONG ultag
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocateNode
//
// Allocates and zero filles a new MXLNODE structure.
//
//

MXLNODE*
kmxlAllocateNode(
    IN ULONG ultag
);

///////////////////////////////////////////////////////////////////////
//
// kmxlAllocatePeerNode
//
// Allocates and zero fills a new PEERNODE structure.
//
//

PEERNODE*
kmxlAllocatePeerNode(
    IN PMXLNODE pNode OPTIONAL,          // The node to associate with the peer
    IN ULONG ultag
);

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//             P E R S I S T A N C E  F U N C T I O N S              //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

NTSTATUS
kmxlOpenInterfaceKey(
    IN  PFILE_OBJECT pfo,
    IN  ULONG Device,
    OUT HANDLE* phKey
);

NTSTATUS
kmxlRegQueryValue(
    IN HANDLE  hKey,
    IN PWCHAR  szValueName,
    IN PVOID   pData,
    IN ULONG   cbData,
    OUT PULONG pResultLength
);




///////////////////////////////////////////////////////////////////////
//
// kmxlRegCloseKey
//
// Closes the given key and NULLs the pointer.
//
//

#define kmxlRegCloseKey( hKey ) \
    {                    \
        ZwClose( hKey ); \
        hKey = NULL;     \
    }


///////////////////////////////////////////////////////////////////////
//
// PinCategoryToString
//
// Translates a PinCategory GUID into a string.
//
//

const char*
PinCategoryToString
(
    IN CONST GUID* NodeType     // The node to translate
);


///////////////////////////////////////////////////////////////////////
//
// NodeTypeToString
//
// Translates a NodeType GUID to a string.
//
//

const char*
NodeTypeToString
(
    IN CONST GUID* NodeType     // The node to translate
);

#define ControlTypeToString( dwType )                                \
    (dwType) == MIXERCONTROL_CONTROLTYPE_BOOLEAN    ? "Boolean"        : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_ONOFF      ? "On Off"         : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_MUTE       ? "Mute"           : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_MONO       ? "Mono"           : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_LOUDNESS   ? "Loudness"       : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_STEREOENH  ? "Stereo Enhance" : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_VOLUME     ? "Volume"         : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_BASS       ? "Bass"           : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_TREBLE     ? "Treble"         : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_BASS_BOOST ? "Bass Boost"     : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_PEAKMETER  ? "Peakmeter"      : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_MUX        ? "Mux"            : \
    (dwType) == MIXERCONTROL_CONTROLTYPE_MIXER      ? "Mixer"          : \
        "Unknown ControlType"

///////////////////////////////////////////////////////////////////////
//
// ComponentTypeToString
//
// Translates one of the MIXERLINE_COMPONENTTYPE constants to a string.
//
//

#define ComponentTypeToString( dwType )                                           \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_DIGITAL     ? "Digital line"        : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_HEADPHONES  ? "Headphones"          : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_LINE        ? "Line"                : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_MONITOR     ? "Monitor"             : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS    ? "Speakers"            : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_TELEPHONE   ? "Telephone"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_UNDEFINED   ? "Undefined"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_VOICEIN     ? "Voicein"             : \
    (dwType) == MIXERLINE_COMPONENTTYPE_DST_WAVEIN      ? "Wavein"              : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_ANALOG      ? "Analog line"         : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY   ? "Auxiliary"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC ? "Compact disc"        : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_DIGITAL     ? "Digital line"        : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_LINE        ? "Line"                : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE  ? "Microphone"          : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER   ? "PC Speaker"          : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER ? "Synthesizer"         : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE   ? "Telephone"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED   ? "Undefined"           : \
    (dwType) == MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT     ? "Waveout"             : \
        "Unknown ComponentType"

///////////////////////////////////////////////////////////////////////
//
// TargetTypeToString
//
// Translates one of hte MIXERLINE_TARGETTYPE constants to a string.
//
//

#define TargetTypeToString( dwType )                            \
    (dwType) == MIXERLINE_TARGETTYPE_AUX       ? "Aux"       :  \
    (dwType) == MIXERLINE_TARGETTYPE_MIDIIN    ? "MidiIn"    :  \
    (dwType) == MIXERLINE_TARGETTYPE_MIDIOUT   ? "MidiOut"   :  \
    (dwType) == MIXERLINE_TARGETTYPE_UNDEFINED ? "Undefined" :  \
    (dwType) == MIXERLINE_TARGETTYPE_WAVEIN    ? "WaveIn"    :  \
    (dwType) == MIXERLINE_TARGETTYPE_WAVEOUT   ? "WaveOut"   :  \
        "Unknown TargetType"

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                                                                   //
//               D E B U G  O N L Y  F U N C T I O N S               //
//                                                                   //
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

#ifdef DEBUG

///////////////////////////////////////////////////////////////////////
//
// LineFlagsToString
//
// Converts on of the MIXERLINE_LINEF flags to a string.
//
//

#define LineFlagsToString( fdwFlags )                               \
    ( fdwFlags & MIXERLINE_LINEF_ACTIVE )       ? "ACTIVE "       : \
    ( fdwFlags & MIXERLINE_LINEF_DISCONNECTED ) ? "DISCONNECTED " : \
    ( fdwFlags & MIXERLINE_LINEF_SOURCE       ) ? "SOURCE "       : \
        "Unknown"


///////////////////////////////////////////////////////////////////////
//
// DumpChildGraph
//
// For a given node, it dumps the child of that node onto the debug
// monitor.  CurrentIndent is the number of spaces to indent before
// display.
//
//

VOID
DumpChildGraph(
    IN PMXLNODE pNode,          // The node to display the children of
    IN ULONG    CurrentIndent   // The number of spaces to ident
);

///////////////////////////////////////////////////////////////////////
//
// DumpMemList
//
// Dumps the list of currently allocated memory blocks.
//
//

VOID
DumpMemList(
);

#endif // DEBUG

VOID GetHardwareEventData(LPDEVICEINFO pDeviceInfo);

#endif // _MIXER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\robust.c ===
#include "wdmsys.h"

#pragma LOCKED_CODE
#pragma LOCKED_DATA


//
// Robust checking enables bugchecks in the retail version of this component.
//
BOOL gbRobustChecking = FALSE;

#if 0
//
// PagedCode:  This routine should be used in routines that touch pageable
// code and data.  Notice that this is not the PAGED_CODE() macro so that it
// will be in the retail code.
//
void
PagedCode(
    void
    )
{
    if( KeGetCurrentIrql() > APC_LEVEL )
    {
        KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_NOT_BELOW_DISPATCH_LEVEL,0,0,0);
    }
}

void
ValidatePassiveLevel(
    void
    )
{
    if( KeGetCurrentIrql() != PASSIVE_LEVEL )
    {
        KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_NOT_AT_PASSIVE_LEVEL,0,0,0);
    }
}

//
// If bExclusive is TRUE, the caller wants to know if the mutex is acquired multiple
// times on the same thread.  If they don't want this checking done, they should 
// set bExclusive to FALSE.
//
NTSTATUS
AudioEnterMutex(
    IN PKMUTEX pmutex,
    IN BOOL    bExclusive
    )
{
    PRKTHREAD pkt;
    NTSTATUS  Status;
    LONG      lMutexState;

    Status = KeWaitForSingleObject ( pmutex,Executive,KernelMode,FALSE,NULL ) ;
    if( gbRobustChecking && bExclusive )
    {
        //
        // After entering the mutex, we sanity check our nested count, but we
        // only do this if we need to.  If the caller said that they designed the
        // code only for exclusive access, we'll bugcheck if we get nested.
        // 
        if( (lMutexState = KeReadStateMutex(pmutex)) < 0 )
        {
            //
            // Every time you acquire a mutex the state will be decremented.  1 means
            // that it's available, 0 means it's held, -1 means this is the second time
            // it's acquired, -2 means it's the third and so on.  Thus, if we're nested
            // on this thread, we'll end up here.
            //
            KeBugCheckEx(AUDIO_BUGCHECK_CODE,
                         AUDIO_NESTED_MUTEX_SITUATION,
                         (ULONG_PTR)pmutex,
                         lMutexState,
                         0);
        }
    }
    return Status;
}

//
// This routine yields if we're at PASSIVE_LEVEL
//
void
AudioPerformYield(
    void
    )
{
    PRKTHREAD pthrd;
    KPRIORITY kpriority;

    //
    // After releasing the mutex we want to yield execution to all other threads
    // on the machine to try to expose preemption windows.
    //
    if( ( gbRobustChecking ) && 
        ( KeGetCurrentIrql() == PASSIVE_LEVEL ) )
    {
        if( (pthrd = KeGetCurrentThread()) )
        {
            kpriority = KeQueryPriorityThread(KeGetCurrentThread());
            //
            // Lower this thrread's priority so another thread will
            // get scheduled.
            //
            KeSetPriorityThread(pthrd,1); // Is that low enough?

            //
            // This might be overkill, but yield.
            //
            ZwYieldExecution();

            //
            // Now restore the priority for this thread and party on.
            //
            KeSetPriorityThread(pthrd,kpriority);
        }

    }
}

void
AudioLeaveMutex(
    IN PKMUTEX pmutex
    )
{
    PRKTHREAD pthrd;
    KPRIORITY kpriority;

    KeReleaseMutex ( pmutex, FALSE ) ;

    AudioPerformYield();
}

NTSTATUS
AudioIoCallDriver (
    IN PDEVICE_OBJECT pDevice,
    IN PIRP           pIrp 
    )
{
    NTSTATUS Status;

    Status = IoCallDriver(pDevice,pIrp);

    AudioPerformYield();

    return Status;
}


void
AudioEnterSpinLock(
    IN  PKSPIN_LOCK pSpinLock,
    OUT PKIRQL      pOldIrql
    )
{
    //
    // KeAcquireSpinLock can only be called less then or equal to dispatch level.
    // let's verify that here.
    //
    if( ( gbRobustChecking ) &&    
        ( KeGetCurrentIrql() > DISPATCH_LEVEL ) )
    {
        KeBugCheckEx(AUDIO_BUGCHECK_CODE,
                     AUDIO_INVALID_IRQL_LEVEL,
                     0,
                     0,
                     0);
    }

    KeAcquireSpinLock ( pSpinLock, pOldIrql ) ;
}

void
AudioLeaveSpinLock(
    IN PKSPIN_LOCK pSpinLock,
    IN KIRQL       OldIrql
    )
{
    KeReleaseSpinLock ( pSpinLock, OldIrql ) ;
    AudioPerformYield();
}


void
AudioObDereferenceObject(
    IN PVOID pvObject
    )
{
    ObDereferenceObject(pvObject);
    AudioPerformYield();
}

void
AudioIoCompleteRequest(
    IN PIRP  pIrp, 
    IN CCHAR PriorityBoost
    )
{
    IoCompleteRequest(pIrp,PriorityBoost);

    AudioPerformYield();
}
#endif

#define MEMORY_LIMIT_CHECK 262144

//
// This routine assumes that pptr points to a memory location that currently
// contains a NULL value.  Thus, on failure, this routine does not have to
// write back a NULL value.
//
// Entry:
// if dwFlags contains:
//#define DEFAULT_MEMORY    0x00 // Standard ExAllocatePool call
//#define ZERO_FILL_MEMORY  0x01 // Zero the memory
//#define QUOTA_MEMORY      0x02 // ExAllocatePoolWithQuota call
//#define LIMIT_MEMORY      0x04 // Never allocation more then 1/4 Meg
//#define FIXED_MEMORY      0x08 // Use locked memory
//#define PAGED_MEMORY      0x10 // use pageable memory
//
NTSTATUS
AudioAllocateMemory(
    IN SIZE_T    bytes,
    IN ULONG     tag,
    IN AAMFLAGS  dwFlags,
    OUT PVOID   *pptr
    )
{
    NTSTATUS Status;
    POOL_TYPE pooltype;
    PVOID pInit;
    KIRQL irql;
    PVOID ptr = NULL;

    ASSERT(*pptr == NULL);

    if( 0 == bytes )
    {
        //
        // The code should never be asking for zero bytes.  The core will bugcheck
        // on a call like this.  In debug mode we'll assert.  In retail, we'll
        // return an error.
        //
        ASSERT(0);
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        if( dwFlags & FIXED_MEMORY )
            pooltype = NonPagedPool;
        else
            pooltype = PagedPool;

        //
        // Allocating pageable memory at DISPATCH_LEVEL is a bad thing to do.
        // here we make sure that is not the case.
        //
        if( ( (irql = KeGetCurrentIrql()) > DISPATCH_LEVEL ) || 
            ((DISPATCH_LEVEL == irql ) && (NonPagedPool != pooltype)) )
        {
            //
            // Either way, we've got an error, bugcheck or exit.
            //
            if( gbRobustChecking )
            {
                KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_INVALID_IRQL_LEVEL,0,0,0);
            } else {
                //
                // If we can't bugcheck, then we're going to return an error
                // in this case.
                //
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
        }
        //
        // Let's see if the caller has asked to limit the allocation to a "reasonable" 
        // number of bytes.  If so, "reasonable" is 1/4 meg.
        //
        if( ( dwFlags & LIMIT_MEMORY ) && ( bytes > MEMORY_LIMIT_CHECK ) )
        {
            //
            // For some reason, this allocation is trying to allocate more then was designed.
            // Why is the caller allocating so much?
            //
            if( gbRobustChecking )
                KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_ABSURD_ALLOCATION_ATTEMPTED,0,0,0);

            //
            // Checked build will assert if robust checking is not enabled.
            //
            ASSERT("Memory Allocation Unreasonable!");
        }

        //
        // Allocate the memory, NULL is returned on failure in the normal case, an exception
        // is raised with quota.  ptr is NULLed out above for the Quota routine.
        //
        if( dwFlags & QUOTA_MEMORY )
        {
            //
            // Caller wants to charge the allocation to the current user context.
            //
            try
            {

                ptr = ExAllocatePoolWithQuotaTag(pooltype,bytes,tag);

            }except (EXCEPTION_EXECUTE_HANDLER) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            //
            // Don't want to assign this memory to the quota.
            //
            ptr = ExAllocatePoolWithTag(pooltype, bytes, tag);
        }

        if( ptr )
        {
            if( dwFlags & ZERO_FILL_MEMORY )
            {
                RtlFillMemory( ptr,bytes,0 );
            }
            //
            // Never allocate over the top of an existing pointer.  Interlock exchange
            // with the location.  This interlock updates the location in the caller.
            //
            if( pInit = InterlockedExchangePointer(pptr,ptr) )
            {
                //
                // If we get a return value from this exchange it means that there
                // was already a pointer in the location that we added a pointer too.
                // If this is the case, most likely we overwrote a valid memory 
                // pointer.  With robust checking we don't want this to happen.
                //
                if( gbRobustChecking )
                {
                    KeBugCheckEx(AUDIO_BUGCHECK_CODE,
                                 AUDIO_MEMORY_ALLOCATION_OVERWRITE,
                                 (ULONG_PTR)pInit,
                                 0,0);
                }
                //
                // If we end up here, we've overwritten a memory pointer with a 
                // successful memory allocation.  Or ASSERT at the top of this
                // function should have fired.  In any case, we can return success
                // and how that nothing bad happens.
                //
            }
            Status = STATUS_SUCCESS;
        } else {
            //
            // Our memory allocation failed.  *pptr should still be NULL
            // return error.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
exit:
    return Status;
}

//
// This routine is safe to call with a NULL memory pointer.  It will return
// STATUS_UNSUCCESSFUL and do nothing if passed a NULL pointer.  Also, this routine
// reads the location atomically so it should be safe in a multiproc environment.
//
void
AudioFreeMemory(
    IN SIZE_T  bytes,
    IN OUT PVOID *pptr
    )
{
    PVOID    pFree;
    KIRQL    irql;

    //
    // Interlockedexhchange the pointer will NULL, validate that it's non-NULL
    // trash the memory if needed and then free the pointer.
    //
    pFree = InterlockedExchangePointer(pptr,NULL);
    if( pFree )
    {
        //
        // We have a pointer to free.
        //
        if( gbRobustChecking )
        {
            //
            // The docs say that we need to be careful how we call the free routine
            // with regard to IRQlevel.  Thus, if we're being robust we'll do this
            // extra work.
            //
            if( (irql = KeGetCurrentIrql()) > DISPATCH_LEVEL )
            {
                KeBugCheckEx(AUDIO_BUGCHECK_CODE,AUDIO_INVALID_IRQL_LEVEL,0,0,0);
            }

            //
            // Under debug we're going to put 'k's in the memory location in order
            // to make extra sure that no one is using this memory.
            //
            if( UNKNOWN_SIZE != bytes )
            {
                RtlFillMemory( pFree,bytes,'k' );
            }
        }

        //
        // Now we actually free the memory.
        //
        ExFreePool(pFree);

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\sysaudio.c ===
/****************************************************************************
 *
 *   sysaudio.c
 *
 *   System Audio Device (SAD) interfaces
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-12-97 - Mike McLaughlin (MikeM)
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmsys.h"
#include <wdmguid.h>

static const WCHAR MediaCategories[] = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\MediaCategories\\";
static const WCHAR NodeNameValue[] =   L"Name";

#pragma PAGEABLE_DATA

ULONG gMidiPreferredDeviceNumber = MAXULONG;
ULONG gWavePreferredSysaudioDevice = MAXULONG;

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

int MyWcsicmp(const wchar_t *pwstr1, const wchar_t *pwstr2)
{
    PAGED_CODE();
    if (!pwstr1) {
        DPF( DL_TRACE|FA_SYSAUDIO,("pwstr1 == NULL"));
        return (-1);
    }

    if (!pwstr2) {
        DPF( DL_TRACE|FA_SYSAUDIO, ("pwstr2 == NULL"));
        return (-1);
    }

    return _wcsicmp(pwstr1, pwstr2);
}

extern
DWORD
_cdecl
_NtKernPhysicalDeviceObjectToDevNode(
        IN PDEVICE_OBJECT PhysicalDeviceObject
);

#ifndef IO_NO_PARAMETER_CHECKING
#define IO_NO_PARAMETER_CHECKING        0x0100
NTKERNELAPI NTSTATUS IoCreateFile
(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options
    );
#endif // !IO_NO_PARAMETER_CHECKING

NTSTATUS OpenSysAudioPin
(
    ULONG          Device,
    ULONG          PinId,
    KSPIN_DATAFLOW DataFlowRequested,
    PKSPIN_CONNECT pPinConnect,
    PFILE_OBJECT *ppFileObjectPin,
    PDEVICE_OBJECT *ppDeviceObjectPin,
    PCONTROLS_LIST pControlList
)
{
    PFILE_OBJECT pFileObjectDevice = NULL;
    KSPIN_COMMUNICATION Communication;
    HANDLE hDevice = NULL;
    HANDLE hPin = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    Status = OpenSysAudio(&hDevice, &pFileObjectDevice);

    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    //
    // Set the default renderer
    //
    Status = SetSysAudioProperty(pFileObjectDevice,
                                 KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
                                 sizeof(Device),
                                 &Device);
    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    Status = GetPinProperty(pFileObjectDevice,
                            KSPROPERTY_PIN_COMMUNICATION,
                            PinId,
                            sizeof(KSPIN_COMMUNICATION),
                            &Communication);
    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    if(Communication != KSPIN_COMMUNICATION_SINK &&
       Communication != KSPIN_COMMUNICATION_BOTH)
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    pPinConnect->PinId = PinId;
    pPinConnect->PinToHandle = NULL;

    if (DataFlowRequested == KSPIN_DATAFLOW_OUT)
    {
        Status = KsCreatePin(hDevice,
                             pPinConnect,
                             GENERIC_READ,
                             &hPin);
    }
    else // KSPIN_DATAFLOW_OUT
    {
        Status = KsCreatePin(hDevice,
                             pPinConnect,
                             GENERIC_WRITE,
                             &hPin);
    }

    if(!NT_SUCCESS(Status))
    {
        if(STATUS_NO_MATCH == Status)
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
        hPin = NULL;
        goto exit;
    }

    Status = ObReferenceObjectByHandle(hPin,
                                       GENERIC_READ | GENERIC_WRITE,
                                       NULL,
                                       KernelMode,
                                       ppFileObjectPin,
                                       NULL);
    if(!NT_SUCCESS(Status))
    {
        DPF(DL_WARNING|FA_SYSAUDIO,("ObReferenceObjectByHandle failed Status=%X",Status) ); 
        goto exit;
    }

    GetControlNodes ( pFileObjectDevice,
                      *ppFileObjectPin,
                      PinId,
                      pControlList ) ;

    *ppDeviceObjectPin = IoGetRelatedDeviceObject(*ppFileObjectPin);

exit:
    if(hPin != NULL)
    {
        NtClose(hPin);
    }
    if(pFileObjectDevice != NULL)
    {
        ObDereferenceObject(pFileObjectDevice);
    }
    if(hDevice != NULL)
    {
        NtClose(hDevice);
    }
    RETURN(Status);
}

VOID CloseSysAudio
(
    PWDMACONTEXT pWdmaContext,
    PFILE_OBJECT pFileObjectPin
)
{
    ULONG d;

    PAGED_CODE();
    ObDereferenceObject(pFileObjectPin);
    UpdatePreferredDevice(pWdmaContext);
}

NTSTATUS OpenSysAudio
(
    PHANDLE pHandle,
    PFILE_OBJECT *ppFileObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR pwstrSymbolicLinkList = NULL;
    PWSTR pwstr;

    PAGED_CODE();
    ASSERT(*pHandle == NULL);
    ASSERT(*ppFileObject == NULL);

    Status = IoGetDeviceInterfaces(
      &KSCATEGORY_SYSAUDIO,
      NULL,
      0,
      &pwstrSymbolicLinkList);

    if(!NT_SUCCESS(Status)) {
        DPF( DL_TRACE|FA_SYSAUDIO, ("IoGetDeviceInterfaces failed: Status=%08x", Status));
        goto exit;
    }

    // There is a double UNICODE_NULL at the end of the list
    pwstr = pwstrSymbolicLinkList;
    while(*pwstr != UNICODE_NULL) {

        Status = OpenDevice(pwstr, pHandle);
        if(NT_SUCCESS(Status)) {
            break;
        }
        ASSERT(*pHandle == NULL);

        // Get next symbolic link
        while(*pwstr++ != UNICODE_NULL);
    }

    if(*pHandle == NULL) {
        Status = OpenDevice(L"\\DosDevices\\sysaudio", pHandle);
        if(!NT_SUCCESS(Status)) {
            DPF( DL_TRACE|FA_SYSAUDIO, ("OpenDevice failed: Status=%08x", Status));
            goto exit;
        }
    }

    //
    //  Security-Penetration issue:
    //
    //  It has been brought up that using this handle is a security issue since in the time
    //  between creating the handle and now, the handle might be pointing to a different
    //  fileobject altogether.  I am assured that as long as I don't touch any of the fields
    //  in the file object and only send 'safe' Ioctls, this will not be a problem.
    //
    Status = ObReferenceObjectByHandle(
      *pHandle,
      FILE_READ_DATA | FILE_WRITE_DATA,
      *IoFileObjectType,
      ExGetPreviousMode(),
      ppFileObject,
      NULL);

    if(!NT_SUCCESS(Status)) {
        DPF( DL_TRACE|FA_SYSAUDIO, ("ObReferenceObjectByHandle failed: Status=%08x", Status));
        goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
        if(*ppFileObject != NULL) {
            ObDereferenceObject(*ppFileObject);
            *ppFileObject = NULL;
        }
        if(*pHandle != NULL) {
            NtClose(*pHandle);
            *pHandle = NULL;
        }
    }
    AudioFreeMemory_Unknown(&pwstrSymbolicLinkList);
    RETURN(Status);
}

NTSTATUS OpenDevice
(
    PWSTR pwstrDevice,
    PHANDLE pHandle
)
{
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      UnicodeDeviceString;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    PAGED_CODE();
    RtlInitUnicodeString(&UnicodeDeviceString, pwstrDevice);

    InitializeObjectAttributes(
      &ObjectAttributes,
      &UnicodeDeviceString,
      0,
      NULL,
      NULL);

    return(IoCreateFile(
        pHandle,
        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        0,
        0,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0,
        CreateFileTypeNone,
        NULL,
        IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING));
}

NTSTATUS GetPinProperty
(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    ULONG cbProperty,
    PVOID pProperty
)
{
    ULONG BytesReturned;
    KSP_PIN Property;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Property.Property.Set = KSPROPSETID_Pin;
        Property.Property.Id = PropertyId;
        Property.Property.Flags = KSPROPERTY_TYPE_GET;
        Property.PinId = PinId;
        Property.Reserved = 0;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, PinId=%X",
                                   PropertyId, PinId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &Property,
          sizeof(Property),
          pProperty,
          cbProperty,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pProperty=%X,cbProperty=%X,BytesRet=%d",
                                   Status,pProperty,cbProperty,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Property query failed Status=%X",Status) );
            goto exit;
        }
        ASSERT(BytesReturned == cbProperty);
    }
exit:
    RETURN(Status);
}

NTSTATUS GetPinPropertyEx
(
    PFILE_OBJECT    pFileObject,
    ULONG           PropertyId,
    ULONG           PinId,
    PVOID           *ppProperty
)
{
    ULONG       BytesReturned;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    KSP_PIN     Pin;

    PAGED_CODE();
    if (pFileObject)
    {
        Pin.Property.Set    = KSPROPSETID_Pin;
        Pin.Property.Id     = PropertyId;
        Pin.Property.Flags  = KSPROPERTY_TYPE_GET;
        Pin.PinId           = PinId;
        Pin.Reserved        = 0;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, PinId=%X",
                                   PropertyId, PinId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &Pin,
          sizeof(KSP_PIN),
          NULL,
          0,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        ASSERT(!NT_SUCCESS(Status));
        if(Status != STATUS_BUFFER_OVERFLOW) {
            //
            // The driver should have returned the number of bytes that we needed 
            // to allocate and STATUS_BUFFER_OVERFLOW.  But, if they returned a
            // successful error code, we must not return success.  Thus, we're making
            // up a new return code - STATUS_INVALID_BUFFER_SIZE.
            //
            if( NT_SUCCESS(Status) )
                Status = STATUS_INVALID_BUFFER_SIZE;

            goto exit;
        }

        if(BytesReturned == 0)
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto exit;
        }

        Status = AudioAllocateMemory_Paged(BytesReturned,
                                           TAG_AudQ_PROPERTY,
                                           ZERO_FILL_MEMORY,
                                           ppProperty  );
        if(!NT_SUCCESS(Status))
        {
            goto exit;
        }

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, PinId=%X",
                                   PropertyId, PinId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &Pin,
          sizeof(KSP_PIN),
          *ppProperty,
          BytesReturned,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status))
        {
            AudioFreeMemory_Unknown(ppProperty);
            goto exit;
        }
    }

exit:
    if( !NT_SUCCESS(Status) )
    {
        *ppProperty = NULL;
    }

    RETURN(Status);
}

VOID GetControlNodes
(
   PFILE_OBJECT   pDeviceFileObject,
   PFILE_OBJECT   pPinFileObject,
   ULONG          PinId,
   PCONTROLS_LIST pControlList
)
{
   ULONG   i ;

   PAGED_CODE();
   if ( pControlList == NULL )
   {
       return ;
   }

   for ( i = 0; i < pControlList->Count; i++ ) \
   {
       pControlList->Controls[i].NodeId =
                   ControlNodeFromGuid (
                            pDeviceFileObject,
                            pPinFileObject,
                            PinId,
                            &pControlList->Controls[i].Control ) ;
   }
}

ULONG ControlNodeFromGuid
(
   PFILE_OBJECT  pDeviceFileObject,
   PFILE_OBJECT  pPinFileObject,
   ULONG         PinId,
   GUID*         NodeType
)
{
   ULONG                   NumNodes, NumConnections ;
   ULONG                   FirstConnectionIndex ;
   PKSMULTIPLE_ITEM        pNodeItems, pConnectionItems ;
   GUID*                   pNodes ;
   PKSTOPOLOGY_CONNECTION  pConnections, pConnection ;
   ULONG                   NodeId ;

   PAGED_CODE();
   // assume there are no nodes
   NodeId = INVALID_NODE ;
   pNodeItems = NULL ;
   pConnectionItems = NULL ;

   // Get the array of Node GUIDs
   pNodeItems = GetTopologyProperty ( pDeviceFileObject,
                                  KSPROPERTY_TOPOLOGY_NODES ) ;

   if ( pNodeItems == NULL )
   {
       DPF(DL_WARNING|FA_SYSAUDIO,("GetTopologyProperty NODES failed") );
       goto exit ;
   }

   NumNodes = pNodeItems->Count ;
   pNodes = (GUID *)(pNodeItems+1) ;

   // Get the array of Connections
   pConnectionItems = GetTopologyProperty ( pDeviceFileObject,
                                        KSPROPERTY_TOPOLOGY_CONNECTIONS ) ;

   if ( pConnectionItems == NULL )
   {
       DPF(DL_WARNING|FA_SYSAUDIO,("GetTopologyProperty CONNECTIONS failed") );
       goto exit ;
   }
   NumConnections = pConnectionItems->Count ;
   pConnections = (PKSTOPOLOGY_CONNECTION)(pConnectionItems+1) ;

   // First get the start connection for the given PinId

   FirstConnectionIndex = GetFirstConnectionIndex ( pPinFileObject ) ;

   if ( FirstConnectionIndex == 0xffffffff )
   {
       DPF(DL_WARNING|FA_SYSAUDIO,("GetFirstConnectionIndex failed") );
       goto exit ;
   }
   pConnection = pConnections + FirstConnectionIndex ;

   ASSERT ( pConnection ) ;

   // NOTE : Assumes DataFlowOut. Need to modify if we want to support
   //        Volume for wavein pins.

   while ((pConnection) && (pConnection->ToNode != KSFILTER_NODE) )
   {
       if ( pConnection->ToNode >= NumNodes )
       {
           ASSERT ( 0 ) ;
       }
       else
       {
           if (IsEqualGUID(&pNodes[pConnection->ToNode], NodeType))
           {
               NodeId = pConnection->ToNode ;
               break ;
           }
       }
       pConnection = FindConnection ( pConnections,
                                     NumConnections,
                                     pConnection->ToNode,
                                     0,
                                     WILD_CARD,
                                     WILD_CARD ) ;
   }

exit:
   AudioFreeMemory_Unknown( &pConnectionItems ) ;
   AudioFreeMemory_Unknown( &pNodeItems ) ;
   return ( NodeId ) ;
}

PVOID GetTopologyProperty
(
   PFILE_OBJECT  pDeviceFileObject,
   ULONG         PropertyId
)
{
   KSPROPERTY              Property ;
   PVOID                   pBuf = NULL;
   ULONG                   BytesReturned ;
   NTSTATUS                Status = STATUS_INVALID_PARAMETER;

   PAGED_CODE();
   pBuf = NULL ;

   if (pDeviceFileObject)
   {
       Property.Set = KSPROPSETID_Topology ;
       Property.Id = PropertyId ;
       Property.Flags = KSPROPERTY_TYPE_GET;

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X",
                                  PropertyId) );

       Status = KsSynchronousIoControlDevice(
         pDeviceFileObject,
         KernelMode,
         IOCTL_KS_PROPERTY,
         &Property,
         sizeof(Property),
         NULL,
         0,
         &BytesReturned);

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, BytesRet=%d",
                                  Status,BytesReturned) );

       ASSERT(!NT_SUCCESS(Status));
       if(Status != STATUS_BUFFER_OVERFLOW) {
           DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
           goto exit;
       }

       Status = AudioAllocateMemory_Paged(BytesReturned,
                                          TAG_Audq_PROPERTY,
                                          ZERO_FILL_MEMORY|LIMIT_MEMORY,
                                          &pBuf );
       if(!NT_SUCCESS(Status))
       {
           goto exit;
       }

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X",
                                  PropertyId) );

       Status = KsSynchronousIoControlDevice(
         pDeviceFileObject,
         KernelMode,
         IOCTL_KS_PROPERTY,
         &Property,
         sizeof(Property),
         pBuf,
         BytesReturned,
         &BytesReturned);

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,pBuf=%X,BytesRet=%d",
                                  Status,pBuf,BytesReturned) );

       if(!NT_SUCCESS(Status))
       {
           DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
           AudioFreeMemory_Unknown ( &pBuf ) ;
           goto exit;
       }
   }
exit:
   return pBuf ;
}

PKSTOPOLOGY_CONNECTION FindConnection
(
   PKSTOPOLOGY_CONNECTION pConnections,
   ULONG                  NumConnections,
   ULONG                  FromNode,
   ULONG                  FromPin,
   ULONG                  ToNode,
   ULONG                  ToPin
)
{
   PKSTOPOLOGY_CONNECTION pConnection ;
   ULONG i ;

   PAGED_CODE();
   pConnection = pConnections ;

   for ( i = 0; i < NumConnections; i++ )
   {
       if ( ((FromNode == WILD_CARD) || (FromNode == pConnection->FromNode)) &&
            ((FromPin == WILD_CARD) || (FromPin == pConnection->FromNodePin)) &&
            ((ToNode == WILD_CARD) || (ToNode == pConnection->ToNode)) &&
            ((ToPin == WILD_CARD) || (ToPin == pConnection->ToNodePin)) )
           return pConnection ;
       pConnection++ ;
   }
   return ( NULL ) ;
}

ULONG GetFirstConnectionIndex
(
   PFILE_OBJECT pPinFileObject
)
{
   KSPROPERTY              Property ;
   ULONG                   Index = 0xffffffff;
   ULONG                   BytesReturned ;
   NTSTATUS                Status = STATUS_INVALID_PARAMETER ;

   PAGED_CODE();
   if (pPinFileObject)
   {
       Property.Set = KSPROPSETID_Sysaudio_Pin ;
       Property.Id = KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX ;
       Property.Flags = KSPROPERTY_TYPE_GET;

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X",
                                  Property.Id) );

       Status = KsSynchronousIoControlDevice(
         pPinFileObject,
         KernelMode,
         IOCTL_KS_PROPERTY,
         &Property,
         sizeof(Property),
         &Index,
         sizeof ( Index ),
         &BytesReturned);

       DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, Index=%X,BytesRet=%d",
                                  Status,Index,BytesReturned) );
   }

   if(!NT_SUCCESS(Status))
   {
       DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
       return ( 0xffffffff ) ;
   }
   return ( Index ) ;
}

VOID UpdatePreferredDevice
(
    PWDMACONTEXT pWdmaContext
)
{
    ULONG d;
    PAGED_CODE();
    //
    // This causes the preferred sysaudio device to be queried if there
    // are no open midi out streams.
    //
    for(d = 0; d < MAXNUMDEVS; d++)
    {
        if(pWdmaContext->MidiOutDevs[d].Device != UNUSED_DEVICE &&
           pWdmaContext->MidiOutDevs[d].pMidiPin                &&
           pWdmaContext->MidiOutDevs[d].pMidiPin->fGraphRunning)
        {
            return;
        }
    }
    pWdmaContext->PreferredSysaudioWaveDevice = gWavePreferredSysaudioDevice;
}

NTSTATUS SetPreferredDevice
(
    PWDMACONTEXT pContext,
    LPDEVICEINFO pDeviceInfo
)
{
    SYSAUDIO_PREFERRED_DEVICE Preferred;
    ULONG TranslatedDeviceNumber;
    ULONG SysaudioDevice;
    ULONG BytesReturned;
    NTSTATUS Status;

    PAGED_CODE();
    if(pContext->pFileObjectSysaudio == NULL) {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    TranslatedDeviceNumber = wdmaudTranslateDeviceNumber(
      pContext,
      pDeviceInfo->DeviceType,
      pDeviceInfo->wstrDeviceInterface,
      pDeviceInfo->DeviceNumber);

    if(MAXULONG == TranslatedDeviceNumber) {
        DPF(DL_WARNING|FA_SYSAUDIO,("Invalid Device Number") );
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    SysaudioDevice = pContext->apCommonDevice
      [pDeviceInfo->DeviceType][TranslatedDeviceNumber]->Device;

    switch(pDeviceInfo->DeviceType) {
        case WaveOutDevice:
            Preferred.Index = KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT;
            gWavePreferredSysaudioDevice = SysaudioDevice;
            UpdatePreferredDevice(pContext);
            break;

        case WaveInDevice:
            Preferred.Index = KSPROPERTY_SYSAUDIO_RECORD_DEFAULT;
            break;

        case MidiOutDevice:
            Preferred.Index = KSPROPERTY_SYSAUDIO_MIDI_DEFAULT;
            gMidiPreferredDeviceNumber = TranslatedDeviceNumber;
            break;

        default:
            Status = STATUS_SUCCESS;
            goto exit;
    }
    Preferred.Property.Set = KSPROPSETID_Sysaudio;
    Preferred.Property.Id = KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE;
    Preferred.Property.Flags = KSPROPERTY_TYPE_SET;

    if(pDeviceInfo->dwFlags == 0) {
        Preferred.Flags = 0;
    }
    else {
        Preferred.Flags = SYSAUDIO_FLAGS_CLEAR_PREFERRED;
        if(pDeviceInfo->DeviceType == WaveOutDevice) {
            gWavePreferredSysaudioDevice = MAXULONG;
        }
        else if(pDeviceInfo->DeviceType == MidiOutDevice) {
            gMidiPreferredDeviceNumber = MAXULONG;
        }
    }

    DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, Preferred=%X",
                               Preferred,Preferred.Property.Id) );

    Status = KsSynchronousIoControlDevice(
      pContext->pFileObjectSysaudio,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Preferred,
      sizeof(Preferred),
      &SysaudioDevice,
      sizeof(SysaudioDevice),
      &BytesReturned);

    DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, SysaudioDevice=%X,BytesRet=%d",
                               Status,SysaudioDevice,BytesReturned) );

    if(!NT_SUCCESS(Status)) {
        DPF(DL_WARNING|FA_SYSAUDIO,("Property Query failed Status=%X",Status) );
        goto exit;
    }
    if(pDeviceInfo->DeviceType == WaveOutDevice &&
       gMidiPreferredDeviceNumber != MAXULONG) {
        ULONG d;

        d = pContext->apCommonDevice[MidiOutDevice]
          [gMidiPreferredDeviceNumber]->PreferredDevice;

        if(d != MAXULONG &&
          (d == gMidiPreferredDeviceNumber ||
           pContext->apCommonDevice[MidiOutDevice][d]->PreferredDevice == d)) {

            Preferred.Index = KSPROPERTY_SYSAUDIO_MIDI_DEFAULT;

            DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Property.Id=%X, Preferred=%X",
                                       Preferred,Preferred.Property.Id) );

            Status = KsSynchronousIoControlDevice(
              pContext->pFileObjectSysaudio,
              KernelMode,
              IOCTL_KS_PROPERTY,
              &Preferred,
              sizeof(Preferred),
              &SysaudioDevice,
              sizeof(SysaudioDevice),
              &BytesReturned);

            DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, SysaudioDevice=%X,BytesRet=%d",
                                       Status,SysaudioDevice,BytesReturned) );

            if(!NT_SUCCESS(Status)) {
                DPF(DL_WARNING|FA_SYSAUDIO,("Property Query failed Status=%X",Status) );
                goto exit;
            }
        }
    }
exit:
    RETURN(Status);
}

NTSTATUS GetSysAudioProperty
(
    PFILE_OBJECT pFileObject,
    ULONG        PropertyId,
    ULONG        DeviceIndex,
    ULONG        cbProperty,
    PVOID        pProperty
)
{
    ULONG           BytesReturned;
    KSPROPERTYPLUS  Property;
    NTSTATUS        Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Property.Property.Set = KSPROPSETID_Sysaudio;
        Property.Property.Id = PropertyId;
        Property.Property.Flags = KSPROPERTY_TYPE_GET;
        Property.DeviceIndex = DeviceIndex;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X, DI=%X",PropertyId,DeviceIndex) );

        Status = KsSynchronousIoControlDevice(pFileObject,
                                              KernelMode,
                                              IOCTL_KS_PROPERTY,
                                              &Property,
                                              sizeof(Property),
                                              pProperty,
                                              cbProperty,
                                              &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pProperty=%X,cbProperty=%X,BytesRet=%d",
                                   Status,pProperty,cbProperty,BytesReturned) );
    }

    RETURN( Status );
}

NTSTATUS SetSysAudioProperty
(
    PFILE_OBJECT pFileObject,
    ULONG        PropertyId,
    ULONG        cbProperty,
    PVOID        pProperty
)
{
    ULONG      BytesReturned;
    KSPROPERTY Property;
    NTSTATUS   Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Property.Set = KSPROPSETID_Sysaudio;
        Property.Id = PropertyId;
        Property.Flags = KSPROPERTY_TYPE_SET;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X",
                                   PropertyId) );

        Status = KsSynchronousIoControlDevice(pFileObject,
                                              KernelMode,
                                              IOCTL_KS_PROPERTY,
                                              &Property,
                                              sizeof(Property),
                                              pProperty,
                                              cbProperty,
                                              &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pProperty=%X,cbProperty=%X,BytesRet=%d",
                                   Status,pProperty,cbProperty,BytesReturned) );
    }

    RETURN(Status);
}

DWORD wdmaudTranslateDeviceNumber
(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    PCWSTR       DeviceInterface,
    DWORD        DeviceNumber
)
{
    PCOMMONDEVICE *ppCommonDevice;
    DWORD d, j;

    PAGED_CODE();
    ppCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];

    for (d = 0; d < MAXNUMDEVS; d++ )
    {
        if (ppCommonDevice[d]->Device == UNUSED_DEVICE ||
            MyWcsicmp(ppCommonDevice[d]->DeviceInterface, DeviceInterface))
        {
            continue;
        }
        if(ppCommonDevice[d]->PreferredDevice == MAXULONG ||
           ppCommonDevice[d]->PreferredDevice == d)
        {
            if (DeviceNumber == 0)
            {
                if (ppCommonDevice[d]->PreferredDevice == d)
                {
                    if(pWdmaContext->PreferredSysaudioWaveDevice != MAXULONG)
                    {
                        for (j = 0; j < MAXNUMDEVS; j++)
                        {
                            if (j == d)
                                continue;

                            if (ppCommonDevice[j]->PreferredDevice == d &&
                                ppCommonDevice[j]->Device ==
                                  pWdmaContext->PreferredSysaudioWaveDevice)
                            {
                                return j;
                            }
                        }
                    }
                }
                return d;
            }
            else
            {
                DeviceNumber--;
            }
        }
    }

    return MAXULONG;
}

int
CmpStr(
    PWSTR pwstr1,
    PWSTR pwstr2
)
{
    PAGED_CODE();
    if(pwstr1 == NULL && pwstr2 == NULL) {
        return(0);
    }
    if(pwstr1 == NULL || pwstr2 == NULL) {
        return(1);
    }
    return(wcscmp(pwstr1, pwstr2));
}

NTSTATUS AddDevice
(
    PWDMACONTEXT    pWdmaContext,
    ULONG           Device,
    DWORD           DeviceType,
    PCWSTR          DeviceInterface,
    ULONG           PinId,
    PWSTR           pwstrName,
    BOOL            fUsePreferred,
    PDATARANGES     pDataRanges,
    PKSCOMPONENTID  ComponentId
)
{
    PCOMMONDEVICE      *papCommonDevice;
    DWORD               DeviceNumber;
    DWORD               d;
    PKSDATARANGE_MUSIC  MusicDataRange;

    PAGED_CODE();
    switch(DeviceType)
    {
        case MidiOutDevice:
            MusicDataRange = (PKSDATARANGE_MUSIC)&pDataRanges->aDataRanges[0];
            if ( !IsEqualGUID( &KSMUSIC_TECHNOLOGY_SWSYNTH, &MusicDataRange->Technology ) )
            {
                fUsePreferred = FALSE;
            }
            break;

        case MidiInDevice:
            fUsePreferred = FALSE;
            break;

        default:
            // Do nothing
            break;
    }

    DPF( DL_TRACE|FA_SYSAUDIO, ("D# %02x DT %02x DI %ls PI %02x %01x",
      Device, DeviceType, DeviceInterface, PinId, fUsePreferred));

    papCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];

    for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
    {
        if (papCommonDevice[DeviceNumber]->Device != UNUSED_DEVICE &&
            !MyWcsicmp(papCommonDevice[DeviceNumber]->DeviceInterface, DeviceInterface) &&
            !CmpStr(papCommonDevice[DeviceNumber]->pwstrName, pwstrName))
        {
            papCommonDevice[DeviceNumber]->Device = Device;
            papCommonDevice[DeviceNumber]->PinId = PinId;
            ASSERT(
              (!fUsePreferred &&
               papCommonDevice[DeviceNumber]->PreferredDevice ==
                MAXULONG) ||
              (fUsePreferred &&
               papCommonDevice[DeviceNumber]->PreferredDevice !=
                MAXULONG));
            break;
        }
    }

    if (DeviceNumber < MAXNUMDEVS)
    {
        // We found an existing device that matches this one.  We need to free
        // some stuff before setting up the new stuff
        AudioFreeMemory_Unknown(&papCommonDevice[DeviceNumber]->pwstrName);
        AudioFreeMemory_Unknown(&papCommonDevice[DeviceNumber]->DeviceInterface);
        AudioFreeMemory_Unknown(&papCommonDevice[DeviceNumber]->ComponentId);
        switch (DeviceType)
        {
            case WaveOutDevice:
                AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[DeviceNumber].AudioDataRanges);
                break;
            case WaveInDevice:
                AudioFreeMemory_Unknown(&pWdmaContext->WaveInDevs[DeviceNumber].AudioDataRanges);
                break;
            case MidiOutDevice:
                AudioFreeMemory_Unknown(&pWdmaContext->MidiOutDevs[DeviceNumber].MusicDataRanges);
                break;
            case MidiInDevice:
                AudioFreeMemory_Unknown(&pWdmaContext->MidiInDevs[DeviceNumber].MusicDataRanges);
                break;
        }
    } else {
        // We didn't find an existing device that matches the new one.  Search
        // for an unused slot in our device lists
        for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
        {
            if (papCommonDevice[DeviceNumber]->Device == UNUSED_DEVICE)
                break;
        }
    }

    if (DeviceNumber == MAXNUMDEVS)
        RETURN( STATUS_INSUFFICIENT_RESOURCES );

    if (!NT_SUCCESS(AudioAllocateMemory_Paged((wcslen(DeviceInterface)+1)*sizeof(WCHAR),
                                              TAG_AudD_DEVICEINFO,
                                              DEFAULT_MEMORY,
                                              &papCommonDevice[DeviceNumber]->DeviceInterface)))
    {
        RETURN( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy(papCommonDevice[DeviceNumber]->DeviceInterface, DeviceInterface);

    papCommonDevice[DeviceNumber]->Device = Device;
    papCommonDevice[DeviceNumber]->PinId = PinId;
    papCommonDevice[DeviceNumber]->pwstrName = pwstrName;
    papCommonDevice[DeviceNumber]->PreferredDevice = MAXULONG;
    papCommonDevice[DeviceNumber]->ComponentId = ComponentId;

    switch(DeviceType)
    {
        case WaveOutDevice:
            pWdmaContext->WaveOutDevs[DeviceNumber].AudioDataRanges = pDataRanges;
            break;

        case WaveInDevice:
            pWdmaContext->WaveInDevs[DeviceNumber].AudioDataRanges= pDataRanges;
            break;

        case MidiOutDevice:
            pWdmaContext->MidiOutDevs[DeviceNumber].MusicDataRanges = pDataRanges;
            break;

        case MidiInDevice:
            pWdmaContext->MidiInDevs[DeviceNumber].MusicDataRanges = pDataRanges;
            break;

        case AuxDevice:
            break;

        default:
            ASSERT(FALSE);
            RETURN(STATUS_INVALID_PARAMETER);
    }

    if (fUsePreferred)
    {
        papCommonDevice[DeviceNumber]->PreferredDevice =
          DeviceNumber;

        for (d = 0; d < MAXNUMDEVS; d++)
        {
            if (d == DeviceNumber)
                continue;

            if (papCommonDevice[d]->Device == UNUSED_DEVICE)
                continue;

            if (papCommonDevice[d]->PreferredDevice != d)
                continue;

            if(CmpStr(papCommonDevice[d]->pwstrName, pwstrName) != 0)
                continue;

            papCommonDevice[DeviceNumber]->PreferredDevice = d;
            ASSERT(papCommonDevice[d]->PreferredDevice == d);
            break;
        }
    }

    return STATUS_SUCCESS;
}

WORD GetMidiTechnology
(
    PKSDATARANGE_MUSIC   MusicDataRange
)
{
    WORD Technology = MOD_MIDIPORT; // default to MIDIPORT

    PAGED_CODE();
    if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_FMSYNTH,
                      &MusicDataRange->Technology ) )
    {
        Technology = MOD_FMSYNTH;
    }
    else if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_WAVETABLE,
                           &MusicDataRange->Technology ) )
    {
        Technology = MOD_WAVETABLE;
    }
    else if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_SWSYNTH,
                           &MusicDataRange->Technology ) )
    {
        Technology = MOD_SWSYNTH;
    }
    else if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_SQSYNTH,
                           &MusicDataRange->Technology ) )
    {
        Technology = MOD_SQSYNTH;
    }
    else if ( IsEqualGUID( &KSMUSIC_TECHNOLOGY_PORT,
                           &MusicDataRange->Technology ) )
    {
        Technology = MOD_MIDIPORT;
    }

    return Technology;
}

DWORD GetFormats
(
    PKSDATARANGE_AUDIO  AudioDataRange
)
{
    DWORD   dwSamples = 0;
    DWORD   dwChannels = 0;
    DWORD   dwBits = 0;

    PAGED_CODE();
    // The WAVE_FORMAT_XXXX flags are bit flags
    //
    // So we take advantage of that by determining three
    // sets of information:
    // - frequencies that are in the valid range
    // - valid bits per sample
    // - number of channels
    //
    // We than bitwise-AND the three values to get
    // the intersection of valid formats
    //

    // Is 11.025 KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 11025 &&
        AudioDataRange->MaximumSampleFrequency >= 11025)
    {
        dwSamples |= WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08 | WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16;
    }

    // Is 22.05 KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 22050 &&
        AudioDataRange->MaximumSampleFrequency >= 22050)
    {
        dwSamples |= WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08 | WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16;
    }

    // Is 44.1KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 44100 &&
        AudioDataRange->MaximumSampleFrequency >= 44100)
    {
        dwSamples |= WAVE_FORMAT_44M08 | WAVE_FORMAT_44S08 | WAVE_FORMAT_44M16 | WAVE_FORMAT_44S16;
    }

    // Is 48 KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 48000 &&
        AudioDataRange->MaximumSampleFrequency >= 48000)
    {
        dwSamples |= WAVE_FORMAT_48M08 | WAVE_FORMAT_48S08 | WAVE_FORMAT_48M16 | WAVE_FORMAT_48S16;
    }

    // Is 96 KHz valid?
    if (AudioDataRange->MinimumSampleFrequency <= 96000 &&
        AudioDataRange->MaximumSampleFrequency >= 96000)
    {
        dwSamples |= WAVE_FORMAT_96M08 | WAVE_FORMAT_96S08 | WAVE_FORMAT_96M16 | WAVE_FORMAT_96S16;
    }

    // Is 8 bit per sample valid?
    if (AudioDataRange->MinimumBitsPerSample <= 8 &&
        AudioDataRange->MaximumBitsPerSample >= 8)
    {
        dwBits |= WAVE_FORMAT_1M08  | WAVE_FORMAT_1S08  | WAVE_FORMAT_2M08  |
                  WAVE_FORMAT_2S08  | WAVE_FORMAT_44M08 | WAVE_FORMAT_44S08 |
                  WAVE_FORMAT_48M08 | WAVE_FORMAT_48S08 | WAVE_FORMAT_96M08 |
                  WAVE_FORMAT_96S08;
    }

    // Is 16 bits per sample valid?
    if (AudioDataRange->MinimumBitsPerSample <= 16 &&
        AudioDataRange->MaximumBitsPerSample >= 16)
    {
        dwBits |= WAVE_FORMAT_1M16  | WAVE_FORMAT_1S16  | WAVE_FORMAT_2M16  |
                  WAVE_FORMAT_2S16  | WAVE_FORMAT_44M16 | WAVE_FORMAT_44S16 |
                  WAVE_FORMAT_48M16 | WAVE_FORMAT_48S16 | WAVE_FORMAT_96M16 |
                  WAVE_FORMAT_96S16;
    }

    // Is one channel (aka mono sound) valid?
    if (AudioDataRange->MaximumChannels >= 1)
    {
        dwChannels |= WAVE_FORMAT_1M08  | WAVE_FORMAT_1M16  | WAVE_FORMAT_2M08  |
                      WAVE_FORMAT_2M16  | WAVE_FORMAT_44M08 | WAVE_FORMAT_44M16 |
                      WAVE_FORMAT_48M08 | WAVE_FORMAT_48M16 | WAVE_FORMAT_96M08 |
                      WAVE_FORMAT_48M16;
    }

    // Are two channels (aka stereo sound) valid?
    if (AudioDataRange->MaximumChannels >= 2)
    {
        dwChannels |= WAVE_FORMAT_1S08  | WAVE_FORMAT_1S16  | WAVE_FORMAT_2S08  |
                      WAVE_FORMAT_2S16  | WAVE_FORMAT_44S08 | WAVE_FORMAT_44S16 |
                      WAVE_FORMAT_48S08 | WAVE_FORMAT_48S16 | WAVE_FORMAT_96S08 |
                      WAVE_FORMAT_96S16;
    }

    dwSamples = dwSamples & dwBits & dwChannels;

    return dwSamples;
}

//
//  Assist with unicode conversions
//
VOID CopyUnicodeStringtoAnsiString
(
        LPSTR lpstr,
        LPCWSTR lpwstr,
        int len
)
{
        UNICODE_STRING SourceString;
        ANSI_STRING DestinationString;
        NTSTATUS Status;

        PAGED_CODE();
        RtlInitUnicodeString(&SourceString, lpwstr);

        Status = RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, TRUE);

        if (NT_SUCCESS(Status)) {

                if (DestinationString.MaximumLength<len) {
                        len=DestinationString.MaximumLength;
                        }

                RtlCopyMemory(lpstr, DestinationString.Buffer, len);

                RtlFreeAnsiString(&DestinationString);

                lpstr[len-1]=0;

                }
        else if (len>0) {

                *lpstr=0;

                }

}

VOID CopyAnsiStringtoUnicodeString
(
    LPWSTR lpwstr,
    LPCSTR lpstr,
    int len
)
{

    PAGED_CODE();
while (len)
    {
        *lpwstr = (WCHAR) *lpstr;
        lpwstr++;
        lpstr++;
        len--;
    }

lpwstr--;
*lpwstr=0;

}


UINT GetCapsIndex
(
    PWDMACONTEXT    pWdmaContext,
    PWSTR           pwstrName,
    DWORD           DeviceType,
    DWORD           DeviceNumber
)
{
    PCOMMONDEVICE  *ppCommonDevice;
    UINT            MatchCount = 0;
    DWORD           d;

    PAGED_CODE();
    ppCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];

    //
    //  Loop through all of the devices for a particular devicetype
    //
    for( d = 0; d < MAXNUMDEVS; d++ )
    {
        if (ppCommonDevice[d]->Device != UNUSED_DEVICE &&
            !CmpStr(ppCommonDevice[d]->pwstrName, pwstrName))
        {
            MatchCount++;
            if (DeviceNumber == d)
            {
                break;
            }
        }
    }

    //
    //  returns index of the friendly name.
    //
    return MatchCount;
}

NTSTATUS
ReadProductNameFromMediaCategories(
    IN REFGUID ProductNameGuid,
    OUT PWSTR *NameBuffer
    )
/*++

Routine Description:

    Queries the "Name" key from the specified category GUID.

Arguments:

    ProductNameGuid -
        The GUID to locate the name value for.

    NameBuffer -
        The place in which to put the value.
--*/
{
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    HANDLE                          CategoryKey;
    KEY_VALUE_PARTIAL_INFORMATION   PartialInfoHeader;
    WCHAR                           RegistryPath[sizeof(MediaCategories) + 39];
    UNICODE_STRING                  RegistryString;
    UNICODE_STRING                  ValueName;
    ULONG                           BytesReturned;

    PAGED_CODE();
    //
    // Build the registry key path to the specified category GUID.
    //
    Status = RtlStringFromGUID(ProductNameGuid, &RegistryString);
    if (!NT_SUCCESS(Status)) {
        RETURN( Status );
    }
    wcscpy(RegistryPath, MediaCategories);
    wcscat(RegistryPath, RegistryString.Buffer);
    RtlFreeUnicodeString(&RegistryString);
    RtlInitUnicodeString(&RegistryString, RegistryPath);
    InitializeObjectAttributes(&ObjectAttributes, &RegistryString, OBJ_CASE_INSENSITIVE, NULL, NULL);
    if (!NT_SUCCESS(Status = ZwOpenKey(&CategoryKey, KEY_READ, &ObjectAttributes))) {
        RETURN( Status );
    }
    //
    // Read the "Name" value beneath this category key.
    //
    RtlInitUnicodeString(&ValueName, NodeNameValue);
    Status = ZwQueryValueKey(
        CategoryKey,
        &ValueName,
        KeyValuePartialInformation,
        &PartialInfoHeader,
        sizeof(PartialInfoHeader),
        &BytesReturned);
    //
    // Even if the read did not cause an overflow, just take the same
    // code path, as such a thing would not normally happen.
    //
    if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) {
        PKEY_VALUE_PARTIAL_INFORMATION  PartialInfoBuffer = NULL;

        //
        // Allocate a buffer for the actual size of data needed.
        //
        Status = AudioAllocateMemory_Paged(BytesReturned,
                                           TAG_Audp_NAME,
                                           ZERO_FILL_MEMORY,
                                           &PartialInfoBuffer );
        if (NT_SUCCESS(Status)) {
            //
            // Retrieve the actual name.
            //
            Status = ZwQueryValueKey(
                CategoryKey,
                &ValueName,
                KeyValuePartialInformation,
                PartialInfoBuffer,
                BytesReturned,
                &BytesReturned);
            if (NT_SUCCESS(Status)) {
                //
                // Make sure that there is always a value.
                //
                if (!PartialInfoBuffer->DataLength || (PartialInfoBuffer->Type != REG_SZ)) {
                    Status = STATUS_UNSUCCESSFUL;
                } else {
                    Status = AudioAllocateMemory_Paged(PartialInfoBuffer->DataLength,
                                                       TAG_Audp_NAME,
                                                       DEFAULT_MEMORY,
                                                       NameBuffer );
                    if (NT_SUCCESS(Status)) {

                        RtlCopyMemory(
                            *NameBuffer,
                            PartialInfoBuffer->Data,
                            PartialInfoBuffer->DataLength);
                    }
                }
            }
            AudioFreeMemory_Unknown(&PartialInfoBuffer);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    ZwClose(CategoryKey);
    RETURN( Status );
}

WORD ChooseCorrectMid
(
    REFGUID     Manufacturer
)
{
    PAGED_CODE();
    if (IS_COMPATIBLE_MMREG_MID(Manufacturer))
    {
        return EXTRACT_MMREG_MID(Manufacturer);
    }
    else
    {
        return MM_UNMAPPED;
    }
}

WORD ChooseCorrectPid
(
    REFGUID     Product
)
{
    PAGED_CODE();
    if (IS_COMPATIBLE_MMREG_PID(Product))
    {
        return EXTRACT_MMREG_PID(Product);
    }
    else
    {
        return MM_PID_UNMAPPED;
    }
}

NTSTATUS FillWaveOutDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    WAVEOUTCAPS2W       wc2;
    WAVEDEVICE          WaveDevice;
    PDATARANGES         AudioDataRanges;
    PKSDATARANGE_AUDIO  pDataRange;
    ULONG               d;
    UINT                CapsIndex;
    WCHAR               szTemp[256];

    PAGED_CODE();
    WaveDevice = pWdmaContext->WaveOutDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (WaveDevice.PreferredDevice == MAXULONG) &&
         (WaveDevice.ComponentId) )
    {
        wc2.NameGuid = WaveDevice.ComponentId->Name;

        wc2.wMid = ChooseCorrectMid(&WaveDevice.ComponentId->Manufacturer);
        wc2.ManufacturerGuid = WaveDevice.ComponentId->Manufacturer;

        wc2.wPid = ChooseCorrectPid(&WaveDevice.ComponentId->Product);
        wc2.ProductGuid = WaveDevice.ComponentId->Product;

        wc2.vDriverVersion = (WaveDevice.ComponentId->Version << 8) |
                             (WaveDevice.ComponentId->Revision & 0xFF);
    }
    else
    {
        wc2.NameGuid = GUID_NULL;

        wc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &wc2.ManufacturerGuid, wc2.wMid );

        wc2.wPid = MM_MSFT_WDMAUDIO_WAVEOUT;
        INIT_MMREG_PID( &wc2.ProductGuid, wc2.wPid );

        wc2.vDriverVersion = 0x050a;
    }

    //
    //  Assume that KMixer is sample accurate
    //
    wc2.dwSupport = WAVECAPS_VOLUME | WAVECAPS_LRVOLUME |
                    WAVECAPS_SAMPLEACCURATE ;

    //
    //  Compute the wChannels and dwFormats by consolidating the caps
    //  from each of the dataranges
    //
    wc2.wChannels = 0;
    wc2.dwFormats = 0;

    AudioDataRanges = WaveDevice.AudioDataRanges;
    pDataRange = (PKSDATARANGE_AUDIO)&AudioDataRanges->aDataRanges[0];

    for(d = 0; d < AudioDataRanges->Count; d++)
    {
        if (pDataRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO))
        {
            //
            //  Only produce caps for PCM formats
            //
            if ( EXTRACT_WAVEFORMATEX_ID(&pDataRange->DataRange.SubFormat) ==
                 WAVE_FORMAT_PCM )
            {
                //  Get the largest number of supported channels
                if ( (WORD)pDataRange->MaximumChannels > wc2.wChannels)
                    wc2.wChannels = (WORD)pDataRange->MaximumChannels;

                wc2.dwFormats |= GetFormats( pDataRange );
            }
        }

        // Get the pointer to the next data range
        (PUCHAR)pDataRange += ((pDataRange->DataRange.FormatSize +
                                FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
    }

    //
    //  Add an index in the form of "(%d)" to the end of the szPname string if two or more
    //  devices have the same name
    //
    ASSERT(WaveDevice.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, WaveDevice.pwstrName, WaveOutDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(wc2.szPname, WaveDevice.pwstrName, MAXPNAMELEN);
    }
    else
    {
        swprintf(szTemp, STR_PNAME, WaveDevice.pwstrName, CapsIndex);
        wcsncpy(wc2.szPname, szTemp, MAXPNAMELEN);
    }
    wc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    //
    //  Copy the caps information into the caller supplied buffer
    //
    RtlCopyMemory(lpCaps, &wc2, min(dwSize, sizeof(wc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillWaveInDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    WAVEINCAPS2W        wc2;
    WAVEDEVICE          WaveDevice;
    PDATARANGES         AudioDataRanges;
    PKSDATARANGE_AUDIO  pDataRange;
    ULONG               d;
    UINT                CapsIndex;
    WCHAR               szTemp[256];

    PAGED_CODE();
    WaveDevice = pWdmaContext->WaveInDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (WaveDevice.PreferredDevice == MAXULONG) &&
         (WaveDevice.ComponentId) )
    {
        wc2.NameGuid = WaveDevice.ComponentId->Name;

        wc2.wMid = ChooseCorrectMid(&WaveDevice.ComponentId->Manufacturer);
        wc2.ManufacturerGuid = WaveDevice.ComponentId->Manufacturer;

        wc2.wPid = ChooseCorrectPid(&WaveDevice.ComponentId->Product);
        wc2.ProductGuid = WaveDevice.ComponentId->Product;

        wc2.vDriverVersion = (WaveDevice.ComponentId->Version << 8) |
                             (WaveDevice.ComponentId->Revision & 0xFF);
    }
    else
    {
        wc2.NameGuid = GUID_NULL;

        wc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &wc2.ManufacturerGuid, wc2.wMid );

        wc2.wPid = MM_MSFT_WDMAUDIO_WAVEIN;
        INIT_MMREG_PID( &wc2.ProductGuid, wc2.wPid );

        wc2.vDriverVersion = 0x050a;
    }

    //
    //  Compute the wChannels and dwFormats by consolidating the caps
    //  from each of the dataranges
    //
    wc2.wChannels = 0;
    wc2.dwFormats = 0;

    AudioDataRanges = WaveDevice.AudioDataRanges;
    pDataRange = (PKSDATARANGE_AUDIO)&AudioDataRanges->aDataRanges[0];

    for(d = 0; d < AudioDataRanges->Count; d++)
    {
        if (pDataRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO))
        {
            //
            //  Only produce caps for PCM formats
            //
            if ( EXTRACT_WAVEFORMATEX_ID(&pDataRange->DataRange.SubFormat) ==
                 WAVE_FORMAT_PCM )
            {
                //  Get the largest number of supported channels
                if ( (WORD)pDataRange->MaximumChannels > wc2.wChannels)
                    wc2.wChannels = (WORD)pDataRange->MaximumChannels;

                wc2.dwFormats |= GetFormats( pDataRange );
            }
        }

        // Get the pointer to the next data range
        (PUCHAR)pDataRange += ((pDataRange->DataRange.FormatSize +
                                FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
    }

    //
    //  Add an index in the form of "(%d)" to the end of the szPname string if two or more
    //  devices have the same name
    //
    ASSERT(WaveDevice.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, WaveDevice.pwstrName, WaveInDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(wc2.szPname, WaveDevice.pwstrName, MAXPNAMELEN);
    }
    else
    {
        swprintf(szTemp, STR_PNAME, WaveDevice.pwstrName, CapsIndex);
        wcsncpy(wc2.szPname, szTemp, MAXPNAMELEN);
    }
    wc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    //
    //  Copy the caps information into the caller supplied buffer
    //
    RtlCopyMemory(lpCaps, &wc2, min(dwSize, sizeof(wc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillMidiOutDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    MIDIOUTCAPS2W       mc2;
    MIDIDEVICE          MidiDevice;
    PDATARANGES         MusicDataRanges;
    PKSDATARANGE_MUSIC  pDataRange;
    UINT                CapsIndex;
    WCHAR               szTemp[256];

    PAGED_CODE();
    MidiDevice = pWdmaContext->MidiOutDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (MidiDevice.PreferredDevice == MAXULONG) &&
         (MidiDevice.ComponentId) )
    {
        mc2.NameGuid = MidiDevice.ComponentId->Name;

        mc2.wMid = ChooseCorrectMid(&MidiDevice.ComponentId->Manufacturer);
        mc2.ManufacturerGuid = MidiDevice.ComponentId->Manufacturer;

        mc2.wPid = ChooseCorrectPid(&MidiDevice.ComponentId->Product);
        mc2.ProductGuid = MidiDevice.ComponentId->Product;

        mc2.vDriverVersion = (MidiDevice.ComponentId->Version << 8) |
                             (MidiDevice.ComponentId->Revision & 0xFF);
    }
    else
    {
        mc2.NameGuid = GUID_NULL;

        mc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &mc2.ManufacturerGuid, mc2.wMid );

        mc2.wPid = MM_MSFT_WDMAUDIO_MIDIOUT;
        INIT_MMREG_PID( &mc2.ProductGuid, mc2.wMid );

        mc2.vDriverVersion = 0x050a;
    }

    MusicDataRanges = MidiDevice.MusicDataRanges;
    pDataRange = (PKSDATARANGE_MUSIC)&MusicDataRanges->aDataRanges[0];

    //
    //  Use the first datarange.  Could cause problems for pins
    //  that support multiple music dataranges.
    //
    if (pDataRange->DataRange.FormatSize < sizeof(KSDATARANGE_MUSIC))
    {
        mc2.wTechnology = MOD_MIDIPORT;
        mc2.wVoices     = 0;
        mc2.wNotes      = 0;
        mc2.wChannelMask= 0;
    }
    else
    {
        mc2.wTechnology = GetMidiTechnology( pDataRange );
        mc2.wVoices     = (WORD)pDataRange->Channels;
        mc2.wNotes      = (WORD)pDataRange->Notes;
        mc2.wChannelMask= (WORD)pDataRange->ChannelMask;
    }

    mc2.dwSupport = 0L;
    if (mc2.wTechnology != MOD_MIDIPORT)
    {
        mc2.dwSupport |= MIDICAPS_VOLUME | MIDICAPS_LRVOLUME;
    }

    ASSERT(MidiDevice.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, MidiDevice.pwstrName, MidiOutDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(mc2.szPname, MidiDevice.pwstrName, MAXPNAMELEN);
    }
    else
    {
        // Only add the index to the string if we need to
        swprintf(szTemp, STR_PNAME, MidiDevice.pwstrName, CapsIndex);
        wcsncpy(mc2.szPname, szTemp, MAXPNAMELEN);
    }
    mc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    RtlCopyMemory(lpCaps, &mc2, min(dwSize, sizeof(mc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillMidiInDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    MIDIINCAPS2W    mc2;
    MIDIDEVICE      MidiDevice;
    UINT            CapsIndex;
    WCHAR           szTemp[256];

    PAGED_CODE();
    MidiDevice = pWdmaContext->MidiInDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (MidiDevice.PreferredDevice == MAXULONG) &&
         (MidiDevice.ComponentId) )
    {
        mc2.NameGuid = MidiDevice.ComponentId->Name;

        mc2.wMid = ChooseCorrectMid(&MidiDevice.ComponentId->Manufacturer);
        mc2.ManufacturerGuid = MidiDevice.ComponentId->Manufacturer;

        mc2.wPid = ChooseCorrectPid(&MidiDevice.ComponentId->Product);
        mc2.ProductGuid = MidiDevice.ComponentId->Product;

        mc2.vDriverVersion = (MidiDevice.ComponentId->Version << 8) |
                             (MidiDevice.ComponentId->Revision & 0xFF);
    }
    else
    {
        mc2.NameGuid = GUID_NULL;

        mc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &mc2.ManufacturerGuid, mc2.wMid );

        mc2.wPid = MM_MSFT_WDMAUDIO_MIDIIN;
        INIT_MMREG_PID( &mc2.ProductGuid, mc2.wPid );

        mc2.vDriverVersion = 0x050a;
    }

    mc2.dwSupport = 0L;   /* functionality supported by driver */

    ASSERT(MidiDevice.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, MidiDevice.pwstrName, MidiInDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(mc2.szPname, MidiDevice.pwstrName, MAXPNAMELEN);
    }
    else
    {
        // Only add the index to the string if we need to
        swprintf(szTemp, STR_PNAME, MidiDevice.pwstrName, CapsIndex);
        wcsncpy(mc2.szPname, szTemp, MAXPNAMELEN);
    }
    mc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    RtlCopyMemory(lpCaps, &mc2, min(dwSize, sizeof(mc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillMixerDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    MIXERCAPS2W     mc2;
    MIXERDEVICE     Mixer;
    UINT            CapsIndex;
    WCHAR           szTemp[256];

    PAGED_CODE();
    Mixer = pWdmaContext->MixerDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (Mixer.PreferredDevice == MAXULONG) &&
         (Mixer.ComponentId) )
    {
        mc2.NameGuid = Mixer.ComponentId->Name;

        mc2.wMid = ChooseCorrectMid(&Mixer.ComponentId->Manufacturer);
        mc2.ManufacturerGuid = Mixer.ComponentId->Manufacturer;

        mc2.wPid = ChooseCorrectPid(&Mixer.ComponentId->Product);
        mc2.ProductGuid = Mixer.ComponentId->Product;

        mc2.vDriverVersion = (Mixer.ComponentId->Version << 8) |
                             (Mixer.ComponentId->Revision & 0xFF);
    }
    else
    {
        mc2.NameGuid = GUID_NULL;

        mc2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &mc2.ManufacturerGuid, mc2.wMid );

        mc2.wPid = MM_MSFT_WDMAUDIO_MIXER;
        INIT_MMREG_PID( &mc2.ProductGuid, mc2.wPid );

        mc2.vDriverVersion = 0x050a;
    }

    mc2.fdwSupport = 0L;     /* functionality supported by driver */
    mc2.cDestinations = kmxlGetNumDestinations( &Mixer );

    ASSERT(Mixer.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, Mixer.pwstrName, MixerDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(mc2.szPname, Mixer.pwstrName, MAXPNAMELEN);
    }
    else
    {
        // Only add the index to the string if we need to
        swprintf(szTemp, STR_PNAME, Mixer.pwstrName, CapsIndex);
        wcsncpy(mc2.szPname, szTemp, MAXPNAMELEN);
    }
    mc2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    RtlCopyMemory(lpCaps, &mc2, min(dwSize, sizeof(mc2)));

    return STATUS_SUCCESS;
}

NTSTATUS FillAuxDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    AUXCAPS2W   ac2;
    AUXDEVICE   AuxDev;
    UINT        CapsIndex;
    WCHAR       szTemp[256];

    PAGED_CODE();
    AuxDev = pWdmaContext->AuxDevs[DeviceNumber];

    //
    //  If available, use the ComponentId to gather information about the device.
    //  Otherwise, fall back to hardcoded devcaps.
    //
    if ( (AuxDev.PreferredDevice == MAXULONG) &&
         (AuxDev.ComponentId) )
    {
        ac2.NameGuid = AuxDev.ComponentId->Name;

        ac2.wMid = ChooseCorrectMid(&AuxDev.ComponentId->Manufacturer);
        ac2.ManufacturerGuid = AuxDev.ComponentId->Manufacturer;

        ac2.wPid = ChooseCorrectPid(&AuxDev.ComponentId->Product);
        ac2.ProductGuid = AuxDev.ComponentId->Product;

        ac2.vDriverVersion = (AuxDev.ComponentId->Version << 8) |
                             (AuxDev.ComponentId->Revision & 0xFF);
    }
    else
    {
        ac2.NameGuid = GUID_NULL;

        ac2.wMid = MM_MICROSOFT;
        INIT_MMREG_MID( &ac2.ManufacturerGuid, ac2.wMid );

        ac2.wPid = MM_MSFT_WDMAUDIO_AUX;
        INIT_MMREG_PID( &ac2.ProductGuid, ac2.wPid );

        ac2.vDriverVersion = 0x050a;
    }


    ac2.wTechnology = AUXCAPS_CDAUDIO ; // | AUXCAPS_AUXIN ;
    ac2.dwSupport = AUXCAPS_LRVOLUME | AUXCAPS_VOLUME;


    ASSERT(AuxDev.pwstrName);
    CapsIndex = GetCapsIndex( pWdmaContext, AuxDev.pwstrName, AuxDevice, DeviceNumber );
    if (CapsIndex < 2)
    {
        wcsncpy(ac2.szPname, AuxDev.pwstrName, MAXPNAMELEN);
    }
    else
    {
        // Only add the index to the string if we need to
        swprintf(szTemp, STR_PNAME, AuxDev.pwstrName, CapsIndex);
        wcsncpy(ac2.szPname, szTemp, MAXPNAMELEN);
    }
    ac2.szPname[MAXPNAMELEN-1] = UNICODE_NULL;

    RtlCopyMemory(lpCaps, &ac2, min(dwSize, sizeof(ac2)));

    return STATUS_SUCCESS;
}

NTSTATUS wdmaudGetDevCaps
(
    PWDMACONTEXT    pWdmaContext,
    DWORD           DeviceType,
    DWORD           DeviceNumber,
    LPBYTE          lpCaps,
    DWORD           dwSize
)
{
    NTSTATUS        Status = STATUS_SUCCESS;

    PAGED_CODE();
    ASSERT(DeviceType == WaveOutDevice ||
           DeviceType == WaveInDevice  ||
           DeviceType == MidiOutDevice ||
           DeviceType == MidiInDevice  ||
           DeviceType == MixerDevice   ||
           DeviceType == AuxDevice);

    switch(DeviceType) {
        case WaveOutDevice:
            Status = FillWaveOutDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case WaveInDevice:
            Status = FillWaveInDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case MidiOutDevice:
            Status = FillMidiOutDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case MidiInDevice:
            Status = FillMidiInDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case MixerDevice:
            Status = FillMixerDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        case AuxDevice:
            Status = FillAuxDevCaps(pWdmaContext,DeviceNumber,lpCaps,dwSize);
            break;

        default:
            ASSERT(0);
    }

    return Status;
}

BOOL IsEqualInterface
(
    PKSPIN_INTERFACE    pInterface1,
    PKSPIN_INTERFACE    pInterface2
)
{
    PAGED_CODE();
    return ( IsEqualGUID(&pInterface1->Set, &pInterface2->Set) &&
             (pInterface1->Id    == pInterface2->Id)           &&
             (pInterface1->Flags == pInterface2->Flags) );
}

/****************************************************************************
 *
 *      PnPCompletionRoutine - Finish the PnP Irp
 *
 *      Not Exported.
 *
 *      ENTRY:  Standard PIO_COMPLETION_ROUTINE.
 *
 *      EXIT:   Standard NT status.
 *
 ***************************************************************************/
NTSTATUS
PnPCompletionRoutine(PDEVICE_OBJECT pDeviceObject, PIRP pIrp, PVOID pContext)
{
    PAGED_CODE();
    //
    // Wake ourselves: the device has finally started/stopped.
    //
    KeSetEvent((PKEVENT)pContext, 0, FALSE);

    //
    // The completion itself never fails.
    //
    RETURN(STATUS_MORE_PROCESSING_REQUIRED);
}

/****************************************************************************
 *
 *      SynchronousCallDriver - Synchronously send a plug and play irp
 *
 *      Not exported.
 *
 *      ENTRY:  pfdo is the function device object.
 *
 *              pIrp is the IRP to send.
 *
 *              ppResult is filled in with the information value.
 *
 *      EXIT:   Standard NT status.
 *
 ***************************************************************************/
NTSTATUS
SynchronousCallDriver(PDEVICE_OBJECT pfdo, PIRP pIrp, PVOID *ppResult)
{
        NTSTATUS                ntStatus;
        KEVENT                  keEventObject;

        PAGED_CODE();
        //
        // Set the thread (should typically be msgsrv32's).
        //
        pIrp->Tail.Overlay.Thread=PsGetCurrentThread();

        //
        // Initialize the status block.
        //
        pIrp->IoStatus.Status=STATUS_NOT_SUPPORTED;

        //
        // Initialize our wait event, in case we need to wait.
        //
        KeInitializeEvent(      &keEventObject,
                                SynchronizationEvent,
                                FALSE);

        //
        // Set our completion routine so we can free the IRP and wake
        // ourselfs.
        //
        IoSetCompletionRoutine( pIrp,
                                PnPCompletionRoutine,
                                &keEventObject,
                                TRUE,
                                TRUE,
                                TRUE);

        //
        // Call the stack now.
        //
        ntStatus=IoCallDriver(pfdo, pIrp);

        //
        // Wait if it is pending.
        //
        if (ntStatus==STATUS_PENDING) {

                //
                // Wait for the completion.
                //
                ntStatus=KeWaitForSingleObject( &keEventObject,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                (PLARGE_INTEGER) NULL );

                //
                // Three cases: timeout (which can't be since we pass null),
                // success or USER_APC (which I don't know what to do).
                //
                if (ntStatus==STATUS_USER_APC) {

//                      IopCancelAlertedRequest(&keEventObject, pIrp );
                }
        }

        //
        // Initialize the result, if requested.
        //
        if (ppResult)
                *ppResult=NULL;

        //
        // Otherwise return the result of the operation.
        //
        ntStatus=pIrp->IoStatus.Status;

        //
        // Fill in the result if requested.
        //
        if (ppResult)
                *ppResult=(PVOID)(pIrp->IoStatus.Information);

        RETURN(ntStatus);
}

BOOL IsPinForDevNode
(
    PFILE_OBJECT pFileObjectDevice,
    ULONG        Index,
    PCWSTR       DeviceInterface
)
{
    NTSTATUS            Status;
    WCHAR               szInterfaceName[256];
    BOOL                Result;

    PAGED_CODE();
    Status = GetSysAudioProperty(pFileObjectDevice,
                                 KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
                                 Index,
                                 sizeof(szInterfaceName),
                                 szInterfaceName);
    if (NT_SUCCESS(Status))
    {
        // TODO: Eventually will not need to munge the strings
        PWSTR pszIn = NULL;
        PWSTR pszSysaudio = NULL;

        Status = AudioAllocateMemory_Paged((wcslen(DeviceInterface)+1) * sizeof(WCHAR),
                                           TAG_Audp_NAME,
                                           DEFAULT_MEMORY,
                                           &pszIn );
        if (NT_SUCCESS(Status))
        {
            Status = AudioAllocateMemory_Paged((wcslen(szInterfaceName)+1) * sizeof(WCHAR),
                                               TAG_Audp_NAME,
                                               DEFAULT_MEMORY,
                                               &pszSysaudio );
            if (NT_SUCCESS(Status))
            {
                PWCHAR pch;

                wcscpy(pszIn, DeviceInterface);
                wcscpy(pszSysaudio, szInterfaceName);

                // pszIn[1] = '\\';
                pszSysaudio[1] = '\\';

                // _DbgPrintF( DEBUGLVL_VERBOSE, ("IsPinForDevnode: Sysaudio returns interface name %ls", pszSysaudio));
                // _DbgPrintF( DEBUGLVL_VERBOSE, ("IsPinForDevnode: Comparing against %ls", pszIn));
                if (!MyWcsicmp(pszIn, pszSysaudio)) {
                    Result = TRUE;
                } else {
                    Result = FALSE;
                }
                AudioFreeMemory_Unknown(&pszSysaudio);
            } else {
                Result = FALSE;
            }
            AudioFreeMemory_Unknown(&pszIn);
        } else {
            Result = FALSE;
        }
    } else {
        Result = FALSE;
    }

    return Result;
}

ULONG FindMixerForDevNode(
    IN PMIXERDEVICE paMixerDevs,
    IN PCWSTR DeviceInterface
)
{
    ULONG i;

    PAGED_CODE();
    for( i = 0; i < MAXNUMDEVS; i++ ) {

        if( ( paMixerDevs[ i ].Device != UNUSED_DEVICE ) &&
            !MyWcsicmp( paMixerDevs[ i ].DeviceInterface, DeviceInterface ) )
        {
            return( i );
        }
    }

    return( UNUSED_DEVICE );
}

NTSTATUS InitializeAuxGetNumDevs
(
    PWDMACONTEXT pWdmaContext,
    PCWSTR DeviceInterface
)
{
    NTSTATUS Status;
    PWSTR pwstrNameAux = NULL;
    DWORD dw;
    ULONG MixerIndex;
    PKSCOMPONENTID ComponentId = NULL;

    PAGED_CODE();
    //
    // Get the name from the mixer device
    //
    MixerIndex = FindMixerForDevNode(pWdmaContext->MixerDevs, DeviceInterface);
    if ( (MixerIndex != UNUSED_DEVICE) && (pWdmaContext->MixerDevs[MixerIndex].pwstrName != NULL) )
    {
        //
        // Check for CD volume control
        //
        Status = IsVolumeControl( pWdmaContext,
                                  DeviceInterface,
                                  MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC,
                                  &dw,
                                  &dw );

        if(NT_SUCCESS(Status))
        {
            Status = AudioAllocateMemory_Paged((wcslen(pWdmaContext->MixerDevs[MixerIndex].pwstrName) + 1) * sizeof(WCHAR),
                                               TAG_Audp_NAME,
                                               DEFAULT_MEMORY,
                                               &pwstrNameAux);
            if (NT_SUCCESS(Status))
            {
                wcscpy(pwstrNameAux, pWdmaContext->MixerDevs[MixerIndex].pwstrName);

                if (pWdmaContext->MixerDevs[MixerIndex].ComponentId)
                {
                    Status = AudioAllocateMemory_Paged(sizeof(*ComponentId),
                                                       TAG_Audp_NAME,
                                                       DEFAULT_MEMORY,
                                                       &ComponentId);
                    if (NT_SUCCESS(Status))
                    {
                        RtlCopyMemory(ComponentId, pWdmaContext->MixerDevs[MixerIndex].ComponentId, sizeof(*ComponentId));
                    }
                }
                else
                {
                    ComponentId = NULL;
                }

                Status = AddDevice(pWdmaContext,
                                   0,
                                   AuxDevice,
                                   DeviceInterface,
                                   0,
                                   pwstrNameAux,
                                   FALSE,
                                   NULL,
                                   ComponentId);
                if (NT_SUCCESS(Status))
                {
                    FindVolumeControl(pWdmaContext, DeviceInterface, AuxDevice);
                } else {
                    AudioFreeMemory_Unknown(&ComponentId);
                    AudioFreeMemory_Unknown(&pwstrNameAux);
                }
            }
        }
    }

    // if anything fails, still return success so InitializeGetNumDevs
    // returns 0 devices
    return(STATUS_SUCCESS);
}

NTSTATUS InitializeMixerGetNumDevs
(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface
)
{
    NTSTATUS Status;
    PMIXERDEVICE paMixerDevs;
    PWAVEDEVICE paWaveOutDevs;
    PWAVEDEVICE paWaveInDevs;
    ULONG i, j;

    PAGED_CODE();
    // WARNING !! WARNING !! WARNING !! WARNING !! WARNING !! WARNING
    //
    // This function makes a few assumptions.  If any of the assumptions
    // below change, this function must be updated accordingly!
    //
    // 1) Mixer devices are initialized after all other device classes.
    //
    // 2) SysAudio device numbers are the same for the different interfaces
    //    (WaveOut,WaveIn,MidiOut,MidiIn,Mixer) for a devnode.
    //
    // WARNING !! WARNING !! WARNING !! WARNING !! WARNING !! WARNING


    paWaveOutDevs = pWdmaContext->WaveOutDevs;
    paWaveInDevs = pWdmaContext->WaveInDevs;
    paMixerDevs = pWdmaContext->MixerDevs;

    for( i = 0; i < MAXNUMDEVS; i++ ) {

        //
        // Look for WaveOut interfaces
        //

        if( ( paWaveOutDevs[ i ].Device != UNUSED_DEVICE ) &&
            ( !MyWcsicmp(paWaveOutDevs[ i ].DeviceInterface, DeviceInterface) ) ) {

            for( j = 0; j < MAXNUMDEVS; j++ ) {

                //ASSERT(paMixerDevs[j].Device == UNUSED_DEVICE ?
                //       NULL == paMixerDevs[j].DeviceInterface :
                //      NULL != paMixerDevs[j].DeviceInterface);

                if( ( paMixerDevs[ j ].Device != UNUSED_DEVICE ) &&
                    ( !MyWcsicmp(paMixerDevs[ j ].DeviceInterface, DeviceInterface) ) )
                {
                    //
                    // We've found a devnode that has already been added
                    // to the mixer list.
                    //
                    kmxlDeInit(&paMixerDevs[j]);
                    paMixerDevs[ j ].Device = paWaveOutDevs[ i ].Device;
                    break;
                }

            } // for

            if( j == MAXNUMDEVS ) {

                for( j = 0; j < MAXNUMDEVS; j++ ) {
                    if( paMixerDevs[ j ].Device == UNUSED_DEVICE ) {
                        break;
                    }
                }

                if( j == MAXNUMDEVS ) {
                    RETURN( STATUS_INSUFFICIENT_RESOURCES );
                }

                Status = AudioAllocateMemory_Paged((wcslen(paWaveOutDevs[i].pwstrName) + 1) * sizeof(WCHAR),
                                                   TAG_Audp_NAME,
                                                   DEFAULT_MEMORY,
                                                   &paMixerDevs[j].pwstrName);

                if (NT_SUCCESS(Status))
                {
                    wcscpy(paMixerDevs[j].pwstrName, paWaveOutDevs[i].pwstrName);

                    Status = AudioAllocateMemory_Paged((wcslen(paWaveOutDevs[i].DeviceInterface) + 1) * sizeof(WCHAR),
                                                       TAG_AudD_DEVICEINFO,
                                                       DEFAULT_MEMORY,
                                                       &paMixerDevs[j].DeviceInterface);

                    if (NT_SUCCESS(Status))
                    {
                        wcscpy(paMixerDevs[j].DeviceInterface, paWaveOutDevs[i].DeviceInterface);
                        paMixerDevs[j].Device = paWaveOutDevs[i].Device;
                        paMixerDevs[j].PreferredDevice = paWaveOutDevs[i].PreferredDevice;

                        if (paWaveOutDevs[i].ComponentId)
                        {
                            Status = AudioAllocateMemory_Paged(sizeof(KSCOMPONENTID),
                                                               TAG_Audp_NAME,
                                                               DEFAULT_MEMORY,
                                                               &paMixerDevs[j].ComponentId);
                            if (NT_SUCCESS(Status))
                            {
                                RtlCopyMemory(paMixerDevs[j].ComponentId, paWaveOutDevs[i].ComponentId, sizeof(KSCOMPONENTID));
                            }
                        }
                        else
                        {
                            paMixerDevs[j].ComponentId = NULL;
                        }
                    } else {
                        AudioFreeMemory_Unknown(&paMixerDevs[j].pwstrName);
                    }
                }

                if (!NT_SUCCESS(Status)) {
                    RETURN( Status );
                }
            } // if

        } // if

        //
        // Loop for WaveIn interfaces.
        //

        if( ( paWaveInDevs[ i ].Device != UNUSED_DEVICE ) &&
            ( !MyWcsicmp(paWaveInDevs[ i ].DeviceInterface, DeviceInterface) ) ) {

            for( j = 0; j < MAXNUMDEVS; j++ ) {

                ASSERT(paMixerDevs[j].Device == UNUSED_DEVICE ?
                       NULL == paMixerDevs[j].DeviceInterface :
                       NULL != paMixerDevs[j].DeviceInterface);

                if( ( paMixerDevs[ j ].Device != UNUSED_DEVICE ) &&
                    ( !MyWcsicmp(paMixerDevs[ j ].DeviceInterface, DeviceInterface) ) )
                {
                    //
                    // We've found a devnode that has already been added
                    // to the mixer list.
                    //
                    kmxlDeInit(&paMixerDevs[j]);
                    paMixerDevs[ j ].Device = paWaveInDevs[ i ].Device;
                    break;
                }

            } // for

            if( j == MAXNUMDEVS ) {

                for( j = 0; j < MAXNUMDEVS; j++ ) {
                    if( paMixerDevs[ j ].Device == UNUSED_DEVICE ) {
                        break;
                    }
                }

                if( j == MAXNUMDEVS ) {
                    RETURN( STATUS_INSUFFICIENT_RESOURCES );
                }

                Status = AudioAllocateMemory_Paged((wcslen(paWaveInDevs[i].pwstrName) + 1) * sizeof(WCHAR),
                                                   TAG_AudD_DEVICEINFO,
                                                   DEFAULT_MEMORY,
                                                   &paMixerDevs[j].pwstrName);

                if (NT_SUCCESS(Status))
                {
                    wcscpy(paMixerDevs[j].pwstrName, paWaveInDevs[i].pwstrName);

                    Status = AudioAllocateMemory_Paged((wcslen(paWaveInDevs[i].DeviceInterface) + 1) * sizeof(WCHAR),
                                                       TAG_AudD_DEVICEINFO,
                                                       DEFAULT_MEMORY,
                                                       &paMixerDevs[j].DeviceInterface);

                    if (NT_SUCCESS(Status))
                    {
                        wcscpy(paMixerDevs[j].DeviceInterface, paWaveInDevs[i].DeviceInterface);
                        paMixerDevs[j].Device = paWaveInDevs[i].Device;
                        paMixerDevs[j].PreferredDevice = paWaveInDevs[i].PreferredDevice;

                        if (paWaveInDevs[i].ComponentId)
                        {
                            Status = AudioAllocateMemory_Paged(sizeof(KSCOMPONENTID),
                                                               TAG_Audp_NAME,
                                                               DEFAULT_MEMORY,
                                                               &paMixerDevs[j].ComponentId);
                            if (NT_SUCCESS(Status))
                            {
                                RtlCopyMemory(paMixerDevs[j].ComponentId, paWaveInDevs[i].ComponentId, sizeof(KSCOMPONENTID));
                            }
                        }
                        else
                        {
                            paMixerDevs[j].ComponentId = NULL;
                        }
                    } else {
                        AudioFreeMemory_Unknown(&paMixerDevs[j].pwstrName);
                    }
                }

                if (!NT_SUCCESS(Status)) {
                    RETURN( Status );
                }
            } // if

        } // if

    } // for

    return( STATUS_SUCCESS );
}

NTSTATUS InitializeGetNumDevs
(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    PCWSTR       DeviceInterface,
    LPDWORD      lpNumberOfDevices
)
{
    NTSTATUS            Status=STATUS_SUCCESS;
    HANDLE              hDevice = NULL;
    PDATARANGES         pDataRanges = NULL;
    PIDENTIFIERS        pPinInterfaces = NULL;
    PFILE_OBJECT        pFileObjectDevice = NULL;
    KSPIN_INTERFACE     RequestedInterface;
    KSPIN_DATAFLOW      RequestedDataFlow;
    GUID                RequestedMajorFormat;
    GUID                RequestedSubFormat;
    GUID                guidCategory;
    ULONG               cPins;
    ULONG               PinId;
    ULONG               Device;
    ULONG               TotalDevices;
    ULONG               ulSize;
    DWORD               cDevs;
    ULONG               i;
    BOOL                fDeviceAdded = FALSE;

    PAGED_CODE();
    ASSERT(DeviceType == WaveOutDevice ||
           DeviceType == WaveInDevice  ||
           DeviceType == MidiOutDevice ||
           DeviceType == MidiInDevice  ||
           DeviceType == MixerDevice ||
           DeviceType == AuxDevice);

    DPF( DL_TRACE|FA_SYSAUDIO, ("Class = %d", DeviceType) );

    //
    //  Setup a structure to compare with the interfaces that
    //  we want to find the number of.
    //
    switch (DeviceType)
    {
        case WaveOutDevice:
            RequestedInterface.Set    = KSINTERFACESETID_Media;
            RequestedInterface.Id     = KSINTERFACE_MEDIA_WAVE_QUEUED;
            RequestedInterface.Flags  = 0;
            RequestedDataFlow         = KSPIN_DATAFLOW_IN;
            RequestedMajorFormat      = KSDATAFORMAT_TYPE_AUDIO;
            RequestedSubFormat        = KSDATAFORMAT_TYPE_WILDCARD;
            break;

        case WaveInDevice:
            RequestedInterface.Set    = KSINTERFACESETID_Standard;
            RequestedInterface.Id     = KSINTERFACE_STANDARD_STREAMING;
            RequestedInterface.Flags  = 0;
            RequestedDataFlow         = KSPIN_DATAFLOW_OUT;
            RequestedMajorFormat      = KSDATAFORMAT_TYPE_AUDIO;
            RequestedSubFormat        = KSDATAFORMAT_TYPE_WILDCARD;
            break;

        case MidiOutDevice:
            RequestedInterface.Set    = KSINTERFACESETID_Standard;
            RequestedInterface.Id     = KSINTERFACE_STANDARD_STREAMING;
            RequestedInterface.Flags  = 0;
            RequestedDataFlow         = KSPIN_DATAFLOW_IN;
            RequestedMajorFormat      = KSDATAFORMAT_TYPE_MUSIC;
            RequestedSubFormat        = KSDATAFORMAT_SUBTYPE_MIDI;
            break;

        case MidiInDevice:
            RequestedInterface.Set    = KSINTERFACESETID_Standard;
            RequestedInterface.Id     = KSINTERFACE_STANDARD_STREAMING;
            RequestedInterface.Flags  = 0;
            RequestedDataFlow         = KSPIN_DATAFLOW_OUT;
            RequestedMajorFormat      = KSDATAFORMAT_TYPE_MUSIC;
            RequestedSubFormat        = KSDATAFORMAT_SUBTYPE_MIDI;
            break;

        case MixerDevice:
            Status = InitializeMixerGetNumDevs( pWdmaContext, DeviceInterface );
            fDeviceAdded = NT_SUCCESS(Status);
            goto exit;

        case AuxDevice:
            Status = InitializeAuxGetNumDevs( pWdmaContext, DeviceInterface );
            fDeviceAdded = NT_SUCCESS(Status);
            goto exit;
    }
    
    //
    // Get a handle to sysaudio
    //
    Status = OpenSysAudio(&hDevice, &pFileObjectDevice);

    if(!NT_SUCCESS(Status))
    {    
        goto exit;
    }
    //
    // for every pin on every device see if the interface matches
    // the DeviceType requested from user mode
    //
    Status = GetSysAudioProperty(pFileObjectDevice,
                                 KSPROPERTY_SYSAUDIO_DEVICE_COUNT,
                                 0,  // not used
                                 sizeof(TotalDevices),
                                 &TotalDevices);
    if(!NT_SUCCESS(Status))
    {
        DPF(DL_WARNING|FA_SYSAUDIO,("GetSysAudioProperty failed Status=%X",Status) );
        goto exit;
    }

    for (Device = 0; Device < TotalDevices; Device++)
    {
        //
        // Set the default renderer
        //
        Status = SetSysAudioProperty(pFileObjectDevice,
                                     KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
                                     sizeof(Device),
                                     &Device);
        if(!NT_SUCCESS(Status))
        {
            DPF(DL_WARNING|FA_SYSAUDIO,("GetSysAudioProperty failed Status=%X",Status) );
            goto exit;
        }

        //
        //  Verify that this device matches the DevNode
        //  being enumerated
        //
        if (!IsPinForDevNode(pFileObjectDevice,Device,DeviceInterface))
        {
            continue;
        }

        //
        // Get the number of pins on the default renderer
        //
        Status = GetPinProperty(pFileObjectDevice,
                                KSPROPERTY_PIN_CTYPES,
                                0,
                                sizeof(cPins),
                                &cPins);

        if(!NT_SUCCESS(Status))
        {
            DPF(DL_WARNING|FA_SYSAUDIO,("GetPinProperty failed Status=%X",Status) );
            goto exit;
        }

        for(PinId = cPins; PinId > 0; PinId--)
        {
            KSPIN_DATAFLOW         DataFlow;
            KSPIN_COMMUNICATION    CommunicationType;
            PKSDATARANGE           pDataRange;
            PWSTR                  pwstrName = NULL;
            PKSCOMPONENTID         ComponentId = NULL;
            BOOL                   fInterfaceFound;
            BOOL                   fUsePreferred;
            ULONG                  index;
            ULONG                  d;

            //
            //  Check the dataflow
            //
            Status = GetPinProperty(pFileObjectDevice,
                                    KSPROPERTY_PIN_DATAFLOW,
                                    PinId-1,
                                    sizeof(KSPIN_DATAFLOW),
                                    &DataFlow);

            if(!NT_SUCCESS(Status))
            {
                DPF(DL_WARNING|FA_SYSAUDIO,("GetPinProperty failed Status=%X",Status) );
                goto exit;
            }

            if(RequestedDataFlow != DataFlow)
            {
                continue;
            }

            //
            //  Check the communication type
            //
            Status = GetPinProperty(pFileObjectDevice,
                                    KSPROPERTY_PIN_COMMUNICATION,
                                    PinId-1,
                                    sizeof(KSPIN_COMMUNICATION),
                                    &CommunicationType);

            if(!NT_SUCCESS(Status))
            {
                DPF(DL_WARNING|FA_SYSAUDIO,("GetPinProperty failed Status=%X",Status) );
                goto exit;
            }

            if(KSPIN_COMMUNICATION_SINK != CommunicationType &&
               KSPIN_COMMUNICATION_BOTH != CommunicationType)
            {
                continue;
            }

            //
            //  Allocates memory on my behalf.  Free later!!!
            //
            Status = GetPinPropertyEx(pFileObjectDevice,
                                      KSPROPERTY_PIN_INTERFACES,
                                      PinId-1,
                                      &pPinInterfaces);
            //
            // GetPinPropertyEx can return STATUS_PROPSET_NOT_FOUND which we
            // expect.  Thus, if we get this error, we need to keep looking rather
            // then fail.  If it returns STATUS_PROPSET_NOT_FOUND pPinInterfaces
            // will be NULL thus we must not touch it.
            //
            // Thus, if not successful AND not a successful error -> error out.
            //
            if(!NT_SUCCESS(Status) && Status != STATUS_PROPSET_NOT_FOUND )
            {
                DPF(DL_WARNING|FA_SYSAUDIO,("GetPinPropertyEx failed Status=%X",Status) );
                goto exit;
            }

            if( pPinInterfaces )
            {
                //
                //  Find an interface that matches
                //
                fInterfaceFound = FALSE;
                for(index = 0; index < pPinInterfaces->Count; index++)
                {
                    if (IsEqualInterface(&RequestedInterface,
                                         &pPinInterfaces->aIdentifiers[index]))
                    {
                        fInterfaceFound = TRUE;
                        break;
                    }
                }

                //
                //  We're done with the memory, so free
                //
                AudioFreeMemory_Unknown(&pPinInterfaces);

                if (!fInterfaceFound)
                {
                    continue;
                }
            }


            //
            //  If the device exposes a component Id, get it and cache it in AddDevice
            //
            Status = AudioAllocateMemory_Paged(sizeof(*ComponentId),
                                               TAG_Audp_NAME,
                                               ZERO_FILL_MEMORY,
                                               &ComponentId);
            if(NT_SUCCESS(Status))
            {
                Status = GetSysAudioProperty(pFileObjectDevice,
                                             KSPROPERTY_SYSAUDIO_COMPONENT_ID,
                                             Device,
                                             sizeof(*ComponentId),
                                             ComponentId);
                //
                // WorkItem: It is highly likely that GetSysAudioProperty will
                // return STATUS_INVALID_DEVICE_REQUEST for this call.  Why?
                //
                if (!NT_SUCCESS(Status))
                {
                    // Not a failure
                    AudioFreeMemory_Unknown(&ComponentId);
                    ComponentId = NULL;
                }
            }

            fUsePreferred = FALSE;
            pwstrName = NULL;

            //  Get the friendly name for this device.
            //  - First see if it the category is KSCATEGORY_WDMAUD_USE_PIN_NAME because
            //    SWMIDI uses this and there should only be one instance of SWMIDI
            //    in the system.
            //
            //  - Next check to see if the pins provide names, without using the
            //    KSCATEGORY_WDMAUD_USE_PIN_NAME category.  If so, use the name provided
            //    by the pin.
            //
            //  - Lastly, use the friendly name for the device if it exists.
            //
            //  If all attempts to get a name fail, then this pin is not used by WDMAUD.
            Status = GetPinProperty(pFileObjectDevice,
                                    KSPROPERTY_PIN_CATEGORY,
                                    PinId-1,
                                    sizeof(GUID),
                                    &guidCategory);
            //
            // WorkItem: GetPinProperty returns code c0000225 - STATUS_INVALID_DEVICE_REQUEST
            // for this call.  Why?
            //

            if(NT_SUCCESS(Status))
            {
                if(IsEqualGUID(&KSCATEGORY_WDMAUD_USE_PIN_NAME, &guidCategory))
                {
                    Status = GetPinPropertyEx(pFileObjectDevice,
                                              KSPROPERTY_PIN_NAME,
                                              PinId-1,
                                              &pwstrName);
                    //
                    // GetPinPropertyEx can return STATUS_PROPSET_NOT_FOUND which we
                    // expect.  Thus, if we get this error, we need to keep looking rather
                    // then fail.  If it returns STATUS_PROPSET_NOT_FOUND pwstrName
                    // will be NULL thus we must not touch it.
                    //
                    // Thus, if successful or it's the successful error code -> success
                    //
                    if(NT_SUCCESS(Status) || Status == STATUS_PROPSET_NOT_FOUND)
                    {
                        fUsePreferred = TRUE;
                    }
                    else
                    {
                        ASSERT(pwstrName == NULL);
                    }
                }
            }

            // As long as this is not SWMIDI, first try reading the name from the component ID
            if ((fUsePreferred == FALSE) && (ComponentId != NULL))
            {
                ReadProductNameFromMediaCategories(&ComponentId->Name,
                                                   &pwstrName);
            }

            // If that didn't work, take the regular old friendly name
            if(pwstrName == NULL)
            {
                Status = GetSysAudioProperty(
                  pFileObjectDevice,
                  KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
                  Device,
                  sizeof(ulSize),
                  &ulSize);

                if(NT_SUCCESS(Status))
                {
                    Status = AudioAllocateMemory_Paged(ulSize,
                                                       TAG_Audp_NAME,
                                                       ZERO_FILL_MEMORY,
                                                       &pwstrName);
                    if(!NT_SUCCESS(Status))
                    {
                        goto exit;
                    }

                    Status = GetSysAudioProperty(
                      pFileObjectDevice,
                      KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
                      Device,
                      ulSize,
                      pwstrName);

                    if (!NT_SUCCESS(Status))
                    {
                        AudioFreeMemory_Unknown(&pwstrName);
                    }
                }

                //
                //  Last chance...don't use devices without names
                //
                if (pwstrName == NULL)
                {
                    AudioFreeMemory_Unknown(&ComponentId);
                    continue;
                }
            }

            //
            //  Allocates memory on my behalf.  Store these
            //  dataranges in the structure of the device if
            //  we find a match that is good.
            //
            Status = GetPinPropertyEx(pFileObjectDevice,
                                      KSPROPERTY_PIN_DATARANGES,
                                      PinId-1,
                                      &pDataRanges);
            //
            // GetPinPropertyEx can return STATUS_PROPSET_NOT_FOUND which we
            // expect.  Thus, if we get this error, we need to keep looking rather
            // then fail.  If it returns STATUS_PROPSET_NOT_FOUND pDataRanges
            // will be NULL thus we must not touch it.
            //
            // Thus, if not successful AND not a successful error -> error out.
            //
            if (!NT_SUCCESS(Status) && Status != STATUS_PROPSET_NOT_FOUND )
            {
                DPF(DL_WARNING|FA_SYSAUDIO,("GetPinPropertyEx failed Status=%X",Status) );
                goto exit;
            }

            if( pDataRanges )
            {
                //
                //  See if we have a majorformat and subformat that
                //  we want
                //
                pDataRange = &pDataRanges->aDataRanges[0];

                for(d = 0; d < pDataRanges->Count; d++)
                {
                    if (IsEqualGUID(&RequestedMajorFormat,
                                    &pDataRange->MajorFormat) &&
                       (IsEqualGUID(&RequestedSubFormat,
                                    &KSDATAFORMAT_TYPE_WILDCARD) ||
                        IsEqualGUID(&RequestedSubFormat,
                                    &pDataRange->SubFormat) ) )
                    {

                        DPF( DL_TRACE|FA_SYSAUDIO, ("Found device!!!") );

                        //
                        //  Store so that we can retrieve later on
                        //  an open or getcaps call
                        //

                        Status = AddDevice(pWdmaContext,
                                           Device,
                                           DeviceType,
                                           DeviceInterface,
                                           PinId-1,
                                           pwstrName,
                                           fUsePreferred,
                                           pDataRanges,
                                           ComponentId);

                        if (NT_SUCCESS(Status))
                        {
                            fDeviceAdded = TRUE;

                            //
                            //  Mark these NULL so that it doesn't get freed
                            //  at the end of the loop.
                            //
                            //  This memory will get freed when the devnode
                            //  is removed and the device entry gets cleaned
                            //  up in RemoveDevNode.
                            //
                            pwstrName = NULL;
                            pDataRanges = NULL;
                            ComponentId = NULL;
                        }

                        break;  // Don't need to check anymore dataranges
                    }

                    // Get the pointer to the next data range
                    (PUCHAR)pDataRange += ((pDataRange->FormatSize +
                      FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);

                }
            }

            //
            //  We're done with the memory, so free
            //
            AudioFreeMemory_Unknown(&pDataRanges);
            AudioFreeMemory_Unknown(&pwstrName);
            AudioFreeMemory_Unknown(&ComponentId);

        } // pin enumeration

    } // device enumeration
exit:
    //
    //  Close down sysaudio for now
    //
    AudioFreeMemory_Unknown(&pPinInterfaces);
    AudioFreeMemory_Unknown(&pDataRanges);

    if(pFileObjectDevice != NULL)
    {
        ObDereferenceObject(pFileObjectDevice);
    }
    if(hDevice != NULL)
    {
        NtClose(hDevice);
    }

    if(fDeviceAdded)
    {
        PCOMMONDEVICE *ppCommonDevice;
        ULONG cRealDevs;

        ppCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];
        for (cRealDevs = cDevs = i = 0; i < MAXNUMDEVS; i++)
        {
            if (ppCommonDevice[i]->Device == UNUSED_DEVICE ||
                MyWcsicmp(ppCommonDevice[i]->DeviceInterface, DeviceInterface))
            {
                continue;
            }
            ++cRealDevs;
            if (ppCommonDevice[i]->PreferredDevice == MAXULONG ||
                ppCommonDevice[i]->PreferredDevice == i)
            {
                ++cDevs;
            }
        }
        if(cDevs == 0 && cRealDevs > 0) {
            *lpNumberOfDevices = MAXULONG;
        }
        else {
            *lpNumberOfDevices = cDevs;
        }
    }
    else
    {
        *lpNumberOfDevices = 0;
    }

    RETURN( Status );
}

NTSTATUS wdmaudGetNumDevs
(
    PWDMACONTEXT pContext,
    DWORD        DeviceType,
    PCWSTR       DeviceInterfaceIn,
    LPDWORD      lpNumberOfDevices
)
{
    PDEVNODE_LIST_ITEM pDevNodeListItem;
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER li = {0, 0};
    PLIST_ENTRY ple;

    PAGED_CODE();
    ASSERT(DeviceType == WaveOutDevice ||
           DeviceType == WaveInDevice  ||
           DeviceType == MidiOutDevice ||
           DeviceType == MidiInDevice  ||
           DeviceType == MixerDevice ||
           DeviceType == AuxDevice);

    *lpNumberOfDevices = 0;

    //
    // Can't use WdmaGrabMutex/WdmaReleaseMutex here
    //

    ASSERT(Status == STATUS_SUCCESS);

    for(ple = pContext->DevNodeListHead.Flink; ple != &pContext->DevNodeListHead; ple = ple->Flink) {
        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);

        if(!MyWcsicmp(pDevNodeListItem->DeviceInterface, DeviceInterfaceIn)) {

            if(pDevNodeListItem->cDevices[DeviceType] == MAXULONG) {

                DPF( DL_TRACE|FA_SYSAUDIO, ("MAXULONG: %ls[%d]",
                  DeviceInterfaceIn,
                  DeviceType));

                //
                // This status code there are still some pending add or
                // remove devices so the actual number of devices can't
                // be returned.
                //
                Status = STATUS_DEVICE_OFF_LINE;
            }
            else {
                *lpNumberOfDevices = pDevNodeListItem->cDevices[DeviceType];
                ASSERT(Status == STATUS_SUCCESS);
            }
            goto exit;
        }
    }
    //
    // This status code there are still some pending add or
    // remove devices so the actual number of devices can't
    // be returned.
    //
    Status = STATUS_DEVICE_OFF_LINE;
exit:
    if(NT_SUCCESS(Status)) {
        DPF( DL_TRACE|FA_SYSAUDIO, ("SUCCESS %ls[%d] %d",
          DeviceInterfaceIn,
          DeviceType,
          *lpNumberOfDevices));
    }

    RETURN(Status);
}

NTSTATUS PinProperty
(
    PFILE_OBJECT        pFileObject,
    const GUID          *pPropertySet,
    ULONG               ulPropertyId,
    ULONG               ulFlags,
    ULONG               cbProperty,
    PVOID               pProperty
)
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Property.Set = *pPropertySet;
        Property.Id = ulPropertyId;
        Property.Flags = ulFlags;

        ASSERT( pFileObject || !"PinProperty called with invalid pFileObject");

        if (ulPropertyId == KSPROPERTY_CONNECTION_STATE)
        {
            DPF( DL_TRACE|FA_SYSAUDIO, ("State=%d",*(PKSSTATE)pProperty));
        }

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X",ulPropertyId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &Property,
          sizeof(Property),
          pProperty,
          cbProperty,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pProperty=%X,cbProperty=%X,BytesRet=%d",
                                   Status,pProperty,cbProperty,BytesReturned) );

    }

    if(!NT_SUCCESS(Status))
    {
        DPF(DL_TRACE|FA_SYSAUDIO, ("FAILED SetState = %d",*(PKSSTATE)pProperty));
        goto exit;
    }
exit:
    RETURN(Status);
}

NTSTATUS PinMethod
(
    PFILE_OBJECT        pFileObject,
    const GUID          *pMethodSet,
    ULONG               ulMethodId,
    ULONG               ulFlags,
    ULONG               cbMethod,
    PVOID               pMethod
)
{
    KSMETHOD    Method;
    ULONG       BytesReturned;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();
    if (pFileObject)
    {
        Method.Set = *pMethodSet;
        Method.Id = ulMethodId;
        Method.Flags = ulFlags;

        ASSERT( pFileObject || !"PinMethod called with invalid pFileObject");

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X",ulMethodId) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_METHOD,
          &Method,
          sizeof(Method),
          pMethod,
          cbMethod,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X, pMethod=%X,cbMethod=%X,BytesRet=%d",
                                   Status,pMethod,cbMethod,BytesReturned) );
    }

    if(!NT_SUCCESS(Status))
    {
        DPF(DL_WARNING|FA_SYSAUDIO,("Failed Status=%X",Status) );
        goto exit;
    }
exit:
    RETURN(Status);
}

NTSTATUS
AttachVirtualSource(
    PFILE_OBJECT pFileObject,
    ULONG ulPinId
)
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE  AttachVirtualSource;
    NTSTATUS                        Status = STATUS_INVALID_PARAMETER;
    ULONG                           BytesReturned;

    PAGED_CODE();
    if (pFileObject)
    {
        if(ulPinId == MAXULONG) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Invalid ulPinId=%X",ulPinId) );
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
        AttachVirtualSource.Property.Set = KSPROPSETID_Sysaudio_Pin;
        AttachVirtualSource.Property.Id =
          KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
        AttachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;
        AttachVirtualSource.MixerPinId = ulPinId;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Id=%X",
                                   AttachVirtualSource.Property.Id) );

        Status = KsSynchronousIoControlDevice(
          pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &AttachVirtualSource,
          sizeof(AttachVirtualSource),
          NULL,
          0,
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );
    }

    if(!NT_SUCCESS(Status)) {
        DPF(DL_WARNING|FA_SYSAUDIO,("Failed Status=%X",Status) );
        goto exit;
    }
exit:
    RETURN(Status);
}

NTSTATUS
SysAudioPnPNotification(
    IN PVOID NotificationStructure,
    IN PVOID _Context
)
{
    PWDMACONTEXT pContext = (PWDMACONTEXT)_Context;
    PDEVICE_INTERFACE_CHANGE_NOTIFICATION pNotification;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    ASSERT(pContext);

    DPF( DL_TRACE|FA_SYSAUDIO,("pWdmaContext=%08Xh", pContext) );

    pNotification =
      (PDEVICE_INTERFACE_CHANGE_NOTIFICATION)NotificationStructure;

    // The notification sends null terminated unicode strings
    if(IsEqualGUID(&pNotification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {
        Status = QueueWorkList(pContext, InitializeSysaudio, pContext, 0);
        if (!NT_SUCCESS(Status)) {
            // At this point pContext->fInitializeSysaudio will still be false because we never
            // ran the work item.  If we don't signal this event, IOCTL_WDMAUD_INIT will deadlock.
            ASSERT(pContext->fInitializeSysaudio == FALSE);

            KeSetEvent(&pContext->InitializedSysaudioEvent, 0, FALSE);
        }
    }
    return(Status);
}

NTSTATUS
InitializeSysaudio(
    PVOID Reference1,
    PVOID Reference2
)
{
    PWDMACONTEXT pWdmaContext = (PWDMACONTEXT)Reference1;
    SYSAUDIO_CREATE_VIRTUAL_SOURCE CreateVirtualSource;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned;
    KSEVENT Event;

    PAGED_CODE();
    ASSERT(pWdmaContext);

    DPF( DL_TRACE|FA_SYSAUDIO,("pWdmaContext=%08Xh", pWdmaContext) );

    if(pWdmaContext->SysaudioWorkerObject == NULL) {
        goto exit;
    }

    if( pWdmaContext->pFileObjectSysaudio == NULL )
    {
        pWdmaContext->pFileObjectSysaudio = kmxlOpenSysAudio();
        if( pWdmaContext->pFileObjectSysaudio == NULL )
        {
            DPF(DL_WARNING|FA_SYSAUDIO,("NULL pFileObjectSysaudio, pWdmaContext=%08X",pWdmaContext) );        
            goto exit;
        }
    }
    //
    // Initialize the wave and synth virtual source lines
    //

    CreateVirtualSource.Property.Set = KSPROPSETID_Sysaudio;
    CreateVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;

    if(pWdmaContext->VirtualWavePinId == MAXULONG) {
        CreateVirtualSource.Property.Id =
          KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY;
        CreateVirtualSource.PinCategory = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;
        CreateVirtualSource.PinName = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY %X",CreateVirtualSource) );

        Status = KsSynchronousIoControlDevice(
          pWdmaContext->pFileObjectSysaudio,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &CreateVirtualSource,
          sizeof(CreateVirtualSource),
          &pWdmaContext->VirtualWavePinId,
          sizeof(pWdmaContext->VirtualWavePinId),
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
            goto exit;
        }
        ASSERT(BytesReturned == sizeof(pWdmaContext->VirtualWavePinId));
    }
    if(pWdmaContext->VirtualMidiPinId == MAXULONG) {
        CreateVirtualSource.Property.Id =
          KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
        CreateVirtualSource.PinCategory = KSNODETYPE_SYNTHESIZER;
        CreateVirtualSource.PinName = KSNODETYPE_SWSYNTH;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY %X",CreateVirtualSource) );

        Status = KsSynchronousIoControlDevice(
          pWdmaContext->pFileObjectSysaudio,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &CreateVirtualSource,
          sizeof(CreateVirtualSource),
          &pWdmaContext->VirtualMidiPinId,
          sizeof(pWdmaContext->VirtualMidiPinId),
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
            goto exit;
        }
        ASSERT(BytesReturned == sizeof(pWdmaContext->VirtualMidiPinId));
    }
    if(pWdmaContext->VirtualCDPinId == MAXULONG) {
        CreateVirtualSource.Property.Id =
          KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
        CreateVirtualSource.PinCategory = KSNODETYPE_CD_PLAYER;
        CreateVirtualSource.PinName = KSNODETYPE_CD_PLAYER;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY %X",CreateVirtualSource) );

        Status = KsSynchronousIoControlDevice(
          pWdmaContext->pFileObjectSysaudio,
          KernelMode,
          IOCTL_KS_PROPERTY,
          &CreateVirtualSource,
          sizeof(CreateVirtualSource),
          &pWdmaContext->VirtualCDPinId,
          sizeof(pWdmaContext->VirtualCDPinId),
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
            goto exit;
        }
        ASSERT(BytesReturned == sizeof(pWdmaContext->VirtualCDPinId));
    }

    //
    // Initialize the device add/remove ks event
    //
    if(!pWdmaContext->fInitializeSysaudio) {

        Event.Set = KSEVENTSETID_Sysaudio;
        Event.Id = KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE;
        Event.Flags = KSEVENT_TYPE_ENABLE;

        pWdmaContext->EventData.NotificationType = KSEVENTF_KSWORKITEM;
        pWdmaContext->EventData.KsWorkItem.WorkQueueItem =
          &pWdmaContext->SysaudioWorkItem;
        pWdmaContext->EventData.KsWorkItem.KsWorkerObject =
          pWdmaContext->SysaudioWorkerObject;
        pWdmaContext->EventData.KsWorkItem.Reserved = 0;

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY Event=%X",Event) );

        Status = KsSynchronousIoControlDevice(
          pWdmaContext->pFileObjectSysaudio,
          KernelMode,
          IOCTL_KS_ENABLE_EVENT,
          &Event,
          sizeof(Event),
          &pWdmaContext->EventData,
          sizeof(pWdmaContext->EventData),
          &BytesReturned);

        DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                   Status,BytesReturned) );

        if(!NT_SUCCESS(Status)) {
            DPF(DL_WARNING|FA_SYSAUDIO,("Failed Property query Status=%X",Status) );
            goto exit;
        }
        pWdmaContext->fInitializeSysaudio = TRUE;
    }
exit:
    KeSetEvent(&pWdmaContext->InitializedSysaudioEvent, 0, FALSE);
    RETURN(Status);
}

VOID
UninitializeSysaudio(
    PWDMACONTEXT pWdmaContext
)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    ULONG BytesReturned;

    PAGED_CODE();
    DPF( DL_TRACE|FA_SYSAUDIO, ("Entering") );
    if(pWdmaContext->pFileObjectSysaudio != NULL) {
        if(pWdmaContext->fInitializeSysaudio) {
            DPF( DL_TRACE|FA_SYSAUDIO,("KS_DISABLE_EVENT EventData=%X",
                                       pWdmaContext->EventData) );

            Status = KsSynchronousIoControlDevice(
              pWdmaContext->pFileObjectSysaudio,
              KernelMode,
              IOCTL_KS_DISABLE_EVENT,
              &pWdmaContext->EventData,
              sizeof(pWdmaContext->EventData),
              NULL,
              0,
              &BytesReturned);

            DPF( DL_TRACE|FA_SYSAUDIO,("KS_PROPERTY results Status=%X,BytesRet=%d",
                                       Status,BytesReturned) );

            pWdmaContext->VirtualWavePinId = MAXULONG;
            pWdmaContext->VirtualMidiPinId = MAXULONG;
            pWdmaContext->VirtualCDPinId = MAXULONG;
            pWdmaContext->fInitializeSysaudio = FALSE;

            DPF( DL_TRACE|FA_SYSAUDIO,("Exiting %08x", Status));
        }
    }
}

NTSTATUS
AddDevNode(
    PWDMACONTEXT pContext,
    PCWSTR       DeviceInterfaceIn,
    UINT         DeviceType
)
{
    NTSTATUS Status=STATUS_SUCCESS;
    PDEVNODE_LIST_ITEM pDevNodeListItem = NULL;
    PLIST_ENTRY ple;
    ULONG t;

    PAGED_CODE();
    DPF( DL_TRACE|FA_SYSAUDIO,("%08x [%ls] %d", pContext, DeviceInterfaceIn, DeviceType));

    for(ple = pContext->DevNodeListHead.Flink; ple != &pContext->DevNodeListHead; ple = ple->Flink) {
        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);
        if(!MyWcsicmp(pDevNodeListItem->DeviceInterface, DeviceInterfaceIn)) {
            ++pDevNodeListItem->cReference;
            DPF( DL_TRACE|FA_SYSAUDIO, ("cReference is now %d", pDevNodeListItem->cReference));
            goto exit;
        }
    }

    //  Limit the number of devnodes that can be added
    if (pContext->DevNodeListCount > MAXDEVNODES) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    pDevNodeListItem = NULL;
    Status = AudioAllocateMemory_Paged(sizeof(DEVNODE_LIST_ITEM),
                                       TAG_AudN_NODE,
                                       ZERO_FILL_MEMORY,
                                       &pDevNodeListItem);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF( DL_TRACE|FA_SYSAUDIO, ("New pDevNodeListItem (%08x)", pDevNodeListItem));

    Status = AudioAllocateMemory_Paged((wcslen(DeviceInterfaceIn)+1)*sizeof(WCHAR),
                                       TAG_AudD_DEVICEINFO,
                                       ZERO_FILL_MEMORY,
                                       &pDevNodeListItem->DeviceInterface);
    if (!NT_SUCCESS(Status)) {
        AudioFreeMemory(sizeof(DEVNODE_LIST_ITEM),&pDevNodeListItem);
        goto exit;
    }

    wcscpy(pDevNodeListItem->DeviceInterface, DeviceInterfaceIn);
    pDevNodeListItem->cReference = 1;
    DPF( DL_TRACE|FA_SYSAUDIO, ("cReference is now 1"));

    for(t = 0; t < MAX_DEVICE_CLASS; t++) {
        pDevNodeListItem->cDevices[t] = MAXULONG;
        pDevNodeListItem->fAdded[t] = FALSE;
    }
    InsertTailList(&pContext->DevNodeListHead, &pDevNodeListItem->Next);
    pContext->DevNodeListCount++;
exit:
    if (pDevNodeListItem)
    {
        pDevNodeListItem->fAdded[DeviceType] = TRUE;
        Status=ProcessDevNodeListItem(pContext, pDevNodeListItem, DeviceType);
    }

    RETURN( Status );
}

VOID
RemoveDevNode(
    PWDMACONTEXT pWdmaContext,
    PCWSTR       DeviceInterfaceIn,
    UINT         DeviceType
)
{
    PDEVNODE_LIST_ITEM pDevNodeListItem;
    PLIST_ENTRY ple, pleNext;
    PCOMMONDEVICE *papCommonDevice;
    ULONG d, j;

    PAGED_CODE();
    DPF( DL_TRACE|FA_SYSAUDIO, ("%08x %ls %d", pWdmaContext, DeviceInterfaceIn, DeviceType));

    papCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];

    for(ple = pWdmaContext->DevNodeListHead.Flink; ple != &pWdmaContext->DevNodeListHead; ple = pleNext) {
        pleNext = ple->Flink;
        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);
        if(!MyWcsicmp(pDevNodeListItem->DeviceInterface, DeviceInterfaceIn)) {

            for (d = 0; d < MAXNUMDEVS; d++) {

                if(papCommonDevice[d]->Device == UNUSED_DEVICE ||
                   MyWcsicmp(papCommonDevice[d]->DeviceInterface, DeviceInterfaceIn)) {
                    continue;
                }

                if(papCommonDevice[d]->PreferredDevice == d) {
                    ULONG p = MAXULONG;

                    for(j = 0; j < MAXNUMDEVS; j++) {

                        if(j == d)
                            continue;

                        if(papCommonDevice[j]->Device == UNUSED_DEVICE)
                            continue;

                        if(papCommonDevice[j]->PreferredDevice != d)
                            continue;

                        if(p == MAXULONG) {
                            p = j;
                        }
                        papCommonDevice[j]->PreferredDevice = p;
                    }
                }

                switch(DeviceType)
                {
                    case WaveOutDevice:
                        if ( pWdmaContext->WaveOutDevs[d].pTimer != NULL )
                            KeCancelTimer(pWdmaContext->WaveOutDevs[d].pTimer);

                        CleanupWavePins(&pWdmaContext->WaveOutDevs[d]);

                        AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[d].AudioDataRanges);
                        AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[d].pTimer);
                        AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[d].pDpc);
                        break;

                    case WaveInDevice:
                        CleanupWavePins(&pWdmaContext->WaveInDevs[d]);

                        AudioFreeMemory_Unknown(&pWdmaContext->WaveInDevs[d].AudioDataRanges);
                        break;

                    case MidiOutDevice:
                        CloseMidiDevicePin(&pWdmaContext->MidiOutDevs[d]);
                        AudioFreeMemory_Unknown(&pWdmaContext->MidiOutDevs[d].MusicDataRanges);
                        break;

                    case MidiInDevice:
                        CloseMidiDevicePin(&pWdmaContext->MidiInDevs[d]);
                        AudioFreeMemory_Unknown(&pWdmaContext->MidiInDevs[d].MusicDataRanges);
                        break;

                    case MixerDevice:
                        kmxlDeInit(&pWdmaContext->MixerDevs[d]);

                        break;
                }

                AudioFreeMemory_Unknown(&papCommonDevice[d]->pwstrName);
                AudioFreeMemory_Unknown(&papCommonDevice[d]->DeviceInterface);
                AudioFreeMemory_Unknown(&papCommonDevice[d]->ComponentId);

                papCommonDevice[d]->pwstrName = NULL;
                papCommonDevice[d]->DeviceInterface = NULL;
                papCommonDevice[d]->Device = UNUSED_DEVICE;
            }
            pDevNodeListItem->cDevices[DeviceType] = MAXULONG;
            pDevNodeListItem->fAdded[DeviceType] = FALSE;
            ASSERT(pDevNodeListItem->cReference > 0);

            if(--pDevNodeListItem->cReference > 0) {
                DPF( DL_TRACE|FA_SYSAUDIO, ("cReference is now %d", pDevNodeListItem->cReference));
                break;
            }

            DPF( DL_TRACE|FA_SYSAUDIO, ("Freeing %08x", pDevNodeListItem));
            RemoveEntryList(&pDevNodeListItem->Next);
            pWdmaContext->DevNodeListCount--;
            AudioFreeMemory_Unknown(&pDevNodeListItem->DeviceInterface);
            AudioFreeMemory_Unknown(&pDevNodeListItem);
            break;
        }
    }
}

VOID
SysaudioAddRemove(
    PWDMACONTEXT pContext
)
{
    PDEVNODE_LIST_ITEM pDevNodeListItem;
    PLIST_ENTRY ple;
    int t;

    PAGED_CODE();
    DPF( DL_TRACE|FA_SYSAUDIO, ("Entering"));
    WdmaGrabMutex(pContext);

    DPFASSERT(IsValidWdmaContext(pContext));

    if(pContext->SysaudioWorkerObject != NULL) {

    for(ple = pContext->DevNodeListHead.Flink;
        ple != &pContext->DevNodeListHead;
        ple = ple->Flink) {

        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);

        for(t = 0; t < MAX_DEVICE_CLASS; t++) {
        ProcessDevNodeListItem(pContext, pDevNodeListItem, t);
        }
    }
    }
    // Need this for to get more KS events
    pContext->SysaudioWorkItem.List.Blink = NULL;

    WdmaReleaseMutex(pContext);
    DPF(DL_TRACE|FA_SYSAUDIO, ("Exiting"));
}

NTSTATUS
ProcessDevNodeListItem
(
    PWDMACONTEXT pWdmaContext,
    PDEVNODE_LIST_ITEM pDevNodeListItem,
    ULONG DeviceType
)
{
    NTSTATUS Status=STATUS_SUCCESS;

    PAGED_CODE();
    if(!pWdmaContext->fInitializeSysaudio) {
        RETURN( STATUS_UNSUCCESSFUL );
    }
    if(!pDevNodeListItem->fAdded[DeviceType]) {
        ASSERT(pDevNodeListItem->cDevices[DeviceType] == MAXULONG);
        RETURN( Status );
    }
    DPF( DL_TRACE|FA_SYSAUDIO, ("%ls[%d]",
         pDevNodeListItem->DeviceInterface,
         DeviceType));

    Status=InitializeGetNumDevs(
      pWdmaContext,
      DeviceType,
      pDevNodeListItem->DeviceInterface,
      &pDevNodeListItem->cDevices[DeviceType]);

    if (!NT_SUCCESS(Status)) {
        RETURN( Status );
        }

    if(DeviceType == MixerDevice &&
       (pDevNodeListItem->fAdded[WaveOutDevice] ||
        pDevNodeListItem->fAdded[WaveInDevice])) {

        Status = kmxlInitializeMixer( pWdmaContext,
                                      pDevNodeListItem->DeviceInterface,
                                      pDevNodeListItem->cDevices[MixerDevice] );

        if(NT_SUCCESS(Status) && pDevNodeListItem->cDevices[MixerDevice]) {
            if(pDevNodeListItem->fAdded[WaveOutDevice]) {
                FindVolumeControl(pWdmaContext, pDevNodeListItem->DeviceInterface, WaveOutDevice);
            }
            if(pDevNodeListItem->fAdded[MidiOutDevice]) {
                FindVolumeControl(pWdmaContext, pDevNodeListItem->DeviceInterface, MidiOutDevice);
            }
        }
    }

    RETURN( Status );
}

#pragma LOCKED_CODE

NTSTATUS
QueueWorkList
(
    PWDMACONTEXT pContext,
    VOID (*Function)(
        PVOID Reference1,
        PVOID Reference2
    ),
    PVOID Reference1,
    PVOID Reference2
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWORK_LIST_ITEM pWorkListItem = NULL;

    if(pContext->WorkListWorkerObject == NULL) {
    ASSERT(NT_SUCCESS(Status));
    goto exit;
    }

    Status = AudioAllocateMemory_Fixed(sizeof(WORK_LIST_ITEM),
                                       TAG_AudE_EVENT,
                                       ZERO_FILL_MEMORY,
                                       &pWorkListItem);
    if(!NT_SUCCESS(Status))
    {
        DPF( DL_TRACE|FA_SYSAUDIO, ("Failing QueueWorkList: %08x", Status));
        goto exit;
    }

    pWorkListItem->Reference1 = Reference1;
    pWorkListItem->Reference2 = Reference2;
    pWorkListItem->Function = Function;

    ExInterlockedInsertTailList(&pContext->WorkListHead,
                                &pWorkListItem->Next,
                                &pContext->WorkListSpinLock);

    if(InterlockedIncrement(&pContext->cPendingWorkList) == 1) {
        KsQueueWorkItem(pContext->WorkListWorkerObject, &pContext->WorkListWorkItem);
    }
exit:
    RETURN( Status );
}

VOID
WorkListWorker(
    PVOID pReference
)
{
    PWDMACONTEXT pContext = (PWDMACONTEXT)pReference;
    PWORK_LIST_ITEM pWorkListItem;
    PLIST_ENTRY ple;

    ASSERT(pContext);

    WdmaGrabMutex(pContext);

    while((ple = ExInterlockedRemoveHeadList(
      &pContext->WorkListHead,
      &pContext->WorkListSpinLock)) != NULL) 
    {

        pWorkListItem = CONTAINING_RECORD(ple, WORK_LIST_ITEM, Next);

        (*pWorkListItem->Function)(pWorkListItem->Reference1,pWorkListItem->Reference2);

        AudioFreeMemory(sizeof(sizeof(WORK_LIST_ITEM)),&pWorkListItem);

        if(InterlockedDecrement(&pContext->cPendingWorkList) == 0) {
            break;
        }
    }

    WdmaReleaseMutex(pContext);
}

VOID
WdmaGrabMutex(
    PWDMACONTEXT pWdmaContext
)
{
//    KeWaitForMutexObject(&pWdmaContext->wdmaContextMutex, Executive, KernelMode, FALSE, NULL);
    //
    // Turn off the APCDisable flag in the thread structure before going for our
    // mutex.  This will prevent us from getting suspeneded while holding this
    // mutex.
    //
    KeEnterCriticalRegion();
    KeWaitForMutexObject(&wdmaMutex, Executive, KernelMode, FALSE, NULL);
}

VOID
WdmaReleaseMutex(
    PWDMACONTEXT pWdmaContext
)
{
//    KeReleaseMutex(&pWdmaContext->wdmaContextMutex, FALSE);
    KeReleaseMutex(&wdmaMutex, FALSE);
    KeLeaveCriticalRegion();
}

VOID WdmaContextCleanup(PWDMACONTEXT pWdmaContext)
{
    LONG DeviceType;
    LONG DeviceNumber;
    PDEVNODE_LIST_ITEM pDevNodeListItem = NULL;
    PLIST_ENTRY ple;

    DPF( DL_TRACE|FA_SYSAUDIO, ("%08x", pWdmaContext));

    for (DeviceType = 0; DeviceType < MAX_DEVICE_CLASS; DeviceType++)
    {
        for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
        {
            PCOMMONDEVICE pDevice;

            pDevice = pWdmaContext->apCommonDevice[DeviceType][DeviceNumber];

            ASSERT(pDevice);
            if (UNUSED_DEVICE != pDevice->Device)
            {
                LPWSTR DeviceInterface = NULL;
                NTSTATUS Status;

                ASSERT(pDevice->DeviceInterface);

                if (pDevice->DeviceInterface) {
                    Status = AudioAllocateMemory_Paged((wcslen(pDevice->DeviceInterface)+1)*sizeof(WCHAR),
                                                       TAG_AudD_DEVICEINFO,
                                                       DEFAULT_MEMORY,
                                                       &DeviceInterface);
                    if (NT_SUCCESS(Status))
                    {
                        wcscpy( DeviceInterface, pDevice->DeviceInterface );
                        RemoveDevNode(pWdmaContext, DeviceInterface, DeviceType);
                        AudioFreeMemory_Unknown(&DeviceInterface);
                    }
                }
            }
        }
    }

    //
    //  Cleanup any remaining devnode list items
    //
    while (!IsListEmpty(&pWdmaContext->DevNodeListHead))
    {
        ple = pWdmaContext->DevNodeListHead.Flink;
        pDevNodeListItem = CONTAINING_RECORD(ple, DEVNODE_LIST_ITEM, Next);
        DPF( DL_TRACE|FA_SYSAUDIO, ("Stray devnode list item = %08x", pDevNodeListItem));
        RemoveHeadList(&pWdmaContext->DevNodeListHead);
        pWdmaContext->DevNodeListCount--;
        AudioFreeMemory_Unknown(&pDevNodeListItem->DeviceInterface);
        AudioFreeMemory_Unknown(&pDevNodeListItem);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\wave.c ===
/****************************************************************************
 *
 *   wave.c
 *
 *   Wave routines for wdmaud.sys
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *                S.Mohanraj (MohanS)
 *                M.McLaughlin (MikeM)
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#include "wdmsys.h"

//
// This is just a scratch location that is never used for anything
// but a parameter to core functions.
//                
IO_STATUS_BLOCK gIoStatusBlock ;

VOID
SetVolumeDpc(
    IN PKDPC pDpc,
    IN PVOID DefferedContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
);

VOID
SetVolumeWorker(
    IN PWAVEDEVICE pDevice,
    IN PVOID pNotUsed
);

VOID
WaitForOutStandingIo(
    IN PWAVEDEVICE        pWaveDevice,
    IN PWAVE_PIN_INSTANCE pCurWavePin
    );

//
// Check whether the waveformat is supported by kmixer
// purpose of this is to decide whether to use WaveQueued
// OR Standard Streaming
//

BOOL 
PcmWaveFormat(
    LPWAVEFORMATEX lpFormat
)
{

    PWAVEFORMATEXTENSIBLE pWaveExtended;
    WORD wFormatTag;

    PAGED_CODE();
    if (lpFormat->wFormatTag == WAVE_FORMAT_PCM) {
        return (TRUE);
    }

    if (lpFormat->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
        return (TRUE);
    }

    if (lpFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
        pWaveExtended = (PWAVEFORMATEXTENSIBLE) lpFormat;
        if (IS_VALID_WAVEFORMATEX_GUID(&pWaveExtended->SubFormat)) {
            wFormatTag = EXTRACT_WAVEFORMATEX_ID(&pWaveExtended->SubFormat);
            if (wFormatTag == WAVE_FORMAT_PCM) {
                return (TRUE);
            }
            if (wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
                return (TRUE);
            }
        }
    }

    return (FALSE);
}

BOOL 
IsValidFormatTag(
    PKSDATARANGE_AUDIO  pDataRange,
    LPWAVEFORMATEX      lpFormat
)
{
    PAGED_CODE();
    //
    //  See if we have a majorformat and subformat that
    //  we want
    //
    if ( IsEqualGUID( &KSDATAFORMAT_TYPE_AUDIO,
                      &pDataRange->DataRange.MajorFormat) )
    {
        if (WAVE_FORMAT_EXTENSIBLE == lpFormat->wFormatTag)
        {
            PWAVEFORMATEXTENSIBLE lpFormatExtensible;

            lpFormatExtensible = (PWAVEFORMATEXTENSIBLE)lpFormat;
            if ( IsEqualGUID( &pDataRange->DataRange.SubFormat,
                              &lpFormatExtensible->SubFormat) )
            {
                return TRUE;
            }
        }
        else
        {
            if ( (EXTRACT_WAVEFORMATEX_ID(&pDataRange->DataRange.SubFormat) ==
                 lpFormat->wFormatTag) )
            {
                return TRUE;
            }
        }
    }

    DPF(DL_TRACE|FA_WAVE,("Invalid Format Tag") );
    return FALSE;
}

BOOL 
IsValidSampleFrequency(
    PKSDATARANGE_AUDIO  pDataRange,
    DWORD               nSamplesPerSec
)
{
    PAGED_CODE();
    //
    //  See if this datarange support the requested frequency
    //
    if (pDataRange->MinimumSampleFrequency <= nSamplesPerSec &&
        pDataRange->MaximumSampleFrequency >= nSamplesPerSec)
    {
        return TRUE;
    }
    else
    {
        DPF(DL_MAX|FA_WAVE,("Invalid Sample Frequency") );
        return FALSE;
    }
}

BOOL 
IsValidBitsPerSample(
    PKSDATARANGE_AUDIO  pDataRange,
    LPWAVEFORMATEX      lpFormat
)
{
    PAGED_CODE();
    //
    //  See if this datarange support the requested frequency
    //
    if (pDataRange->MinimumBitsPerSample <= lpFormat->wBitsPerSample &&
        pDataRange->MaximumBitsPerSample >= lpFormat->wBitsPerSample)
    {
        if ( (lpFormat->wFormatTag == WAVE_FORMAT_PCM) &&
             (lpFormat->wBitsPerSample > 32) )
        {
            DPF(DL_TRACE|FA_WAVE,("Invalid BitsPerSample") );
            return FALSE;
        }
        else if ( (lpFormat->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) &&
                  (lpFormat->wBitsPerSample != 32) )
        {
            DPF(DL_TRACE|FA_WAVE,("Invalid BitsPerSample") );
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        DPF(DL_TRACE|FA_WAVE,("Invalid BitsPerSample") );
        return FALSE;
    }
}

BOOL 
IsValidChannels(
    PKSDATARANGE_AUDIO  pDataRange,
    LPWAVEFORMATEX      lpFormat
)
{
    PAGED_CODE();
    //
    //  See if this datarange support the requested frequency
    //
    if (pDataRange->MaximumChannels >= lpFormat->nChannels)
    {
        if ( ( (lpFormat->wFormatTag == WAVE_FORMAT_PCM) ||
               (lpFormat->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) ) &&
             (lpFormat->nChannels > 2) )
        {
            DPF(DL_TRACE|FA_WAVE,("Invalid Channel") );
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        DPF(DL_TRACE|FA_WAVE,("Invalid Channel") );
        return FALSE;
    }
}

NTSTATUS 
OpenWavePin(
    PWDMACONTEXT        pWdmaContext,
    ULONG               DeviceNumber,
    LPWAVEFORMATEX      lpFormat,
    HANDLE32            DeviceHandle,
    DWORD               dwFlags,
    ULONG               DataFlow // DataFlow is either in or out.
)
{
    PWAVE_PIN_INSTANCE  pNewWavePin = NULL;
    PWAVE_PIN_INSTANCE  pCurWavePin;
    PKSPIN_CONNECT              pConnect = NULL;
    PKSDATAFORMAT_WAVEFORMATEX  pWaveDataFormat;
    ULONG                       RegionSize;
    PCONTROLS_LIST              pControlList = NULL;
    ULONG                       Device;
    ULONG                       PinId;
    NTSTATUS            Status = STATUS_INVALID_DEVICE_REQUEST;


    PAGED_CODE();
    //
    //  Let's do this quickly and get out of here
    //
    if (WAVE_FORMAT_QUERY & dwFlags)
    {
        PDATARANGES         AudioDataRanges;
        PKSDATARANGE_AUDIO  pDataRange;
        ULONG               d;

        //
        // WaveOut call?  If so, use waveout info
        //
        if( KSPIN_DATAFLOW_IN == DataFlow )
            AudioDataRanges = pWdmaContext->WaveOutDevs[DeviceNumber].AudioDataRanges;
        else 
            AudioDataRanges = pWdmaContext->WaveInDevs[DeviceNumber].AudioDataRanges;

        pDataRange = (PKSDATARANGE_AUDIO)&AudioDataRanges->aDataRanges[0];

        for(d = 0; d < AudioDataRanges->Count; d++)
        {
            if ( (IsValidFormatTag(pDataRange,lpFormat)) &&
                 (IsValidSampleFrequency(pDataRange,lpFormat->nSamplesPerSec)) &&
                 (IsValidBitsPerSample(pDataRange,lpFormat)) &&
                 (IsValidChannels(pDataRange,lpFormat)) )
            {
                //
                //  Found a good data range, successful query
                //
                Status = STATUS_SUCCESS;
                break;
            }

            // Get the pointer to the next data range
            (PUCHAR)pDataRange += ((pDataRange->DataRange.FormatSize +
              FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
        }

        goto exit;
    }

    //
    //  Need to allocate a pin instance for multiple wave
    //  opens on the same device
    //
    Status = AudioAllocateMemory_Fixed(sizeof(WAVE_PIN_INSTANCE),
                                       TAG_Audi_PIN,
                                       ZERO_FILL_MEMORY,
                                       &pNewWavePin);
    if(!NT_SUCCESS(Status))
    {
        goto exit;
    }

    //
    // Copy the application supplied waveformat so we can
    // use in the worker thread context. Don't need to zero
    // memory because we copy into the structure below.
    //
    Status = AudioAllocateMemory_Fixed((lpFormat->wFormatTag == WAVE_FORMAT_PCM) ?
                                          sizeof( PCMWAVEFORMAT ) :
                                          sizeof( WAVEFORMATEX ) + lpFormat->cbSize, 
                                       TAG_AudF_FORMAT,
                                       DEFAULT_MEMORY,
                                       &pNewWavePin->lpFormat);
    if(!NT_SUCCESS(Status))
    {
        AudioFreeMemory(sizeof(WAVE_PIN_INSTANCE),&pNewWavePin);
        goto exit;
    }

    RtlCopyMemory( pNewWavePin->lpFormat,
                   lpFormat,
                   (lpFormat->wFormatTag == WAVE_FORMAT_PCM) ?
                   sizeof( PCMWAVEFORMAT ) :
                   sizeof( WAVEFORMATEX ) + lpFormat->cbSize);

    pNewWavePin->DataFlow = DataFlow;
    pNewWavePin->dwFlags = dwFlags;
    pNewWavePin->DeviceNumber = DeviceNumber;
    pNewWavePin->WaveHandle = DeviceHandle;
    pNewWavePin->Next = NULL;
    pNewWavePin->NumPendingIos = 0;
    pNewWavePin->StoppingSource = FALSE;
    pNewWavePin->PausingSource = FALSE;
    pNewWavePin->dwSig = WAVE_PIN_INSTANCE_SIGNATURE;
    if( KSPIN_DATAFLOW_IN == DataFlow )
        pNewWavePin->pWaveDevice = &pWdmaContext->WaveOutDevs[DeviceNumber];
    else 
        pNewWavePin->pWaveDevice = &pWdmaContext->WaveInDevs[DeviceNumber];

    KeInitializeEvent ( &pNewWavePin->StopEvent,
                       SynchronizationEvent,
                       FALSE ) ;

    KeInitializeEvent ( &pNewWavePin->PauseEvent,
                       SynchronizationEvent,
                       FALSE ) ;

    KeInitializeSpinLock(&pNewWavePin->WavePinSpinLock);

    if( KSPIN_DATAFLOW_IN == DataFlow )
    {
        if (NULL == pWdmaContext->WaveOutDevs[DeviceNumber].pWavePin)
        {
            pWdmaContext->WaveOutDevs[DeviceNumber].pWavePin = pNewWavePin;

        } else {

            for (pCurWavePin = pWdmaContext->WaveOutDevs[DeviceNumber].pWavePin;
                 pCurWavePin->Next != NULL; )
            {
                 pCurWavePin = pCurWavePin->Next;
            }

            pCurWavePin->Next = pNewWavePin;

            DPF(DL_TRACE|FA_WAVE, ("Opening another waveout pin"));

        }
    } else {
        if (NULL == pWdmaContext->WaveInDevs[DeviceNumber].pWavePin)
        {
            pWdmaContext->WaveInDevs[DeviceNumber].pWavePin = pNewWavePin;

        } else {

            for (pCurWavePin = pWdmaContext->WaveInDevs[DeviceNumber].pWavePin;
                 pCurWavePin->Next != NULL; )
            {
                 pCurWavePin = pCurWavePin->Next;
            }

            pCurWavePin->Next = pNewWavePin;

            DPF(DL_TRACE|FA_WAVE, ("Opening another wavein pin"));
        }
    }

    //
    // We only support one client at a time.
    //
    ASSERT( !pNewWavePin->fGraphRunning );

    //
    //  We need to allocate enough memory to handle the
    //  extended waveformat structure
    //
    if (WAVE_FORMAT_PCM == lpFormat->wFormatTag)
    {
        RegionSize = sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT_WAVEFORMATEX);
    }
    else
    {
        RegionSize = sizeof(KSPIN_CONNECT) +
                     sizeof(KSDATAFORMAT_WAVEFORMATEX) +
                     lpFormat->cbSize;
    }

    Status = AudioAllocateMemory_Fixed(RegionSize, 
                                       TAG_Audt_CONNECT,
                                       ZERO_FILL_MEMORY,
                                       &pConnect);
    if(!NT_SUCCESS(Status))
    {
       DPF(DL_WARNING|FA_WAVE, ("pConnect not valid"));
       goto exit;
    }

    pWaveDataFormat = (PKSDATAFORMAT_WAVEFORMATEX)(pConnect + 1);

    //
    // Use WAVE_QUEUED for PCM waveOut and Standard Streaming for WaveIn
    // and non-PCM waveOut
    //
    if ( pNewWavePin->DataFlow == KSPIN_DATAFLOW_IN )
    {
       if (PcmWaveFormat(lpFormat)) { // if it is KMIXER supported waveformat
           pConnect->Interface.Set = KSINTERFACESETID_Media;
           pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
           pNewWavePin->fWaveQueued = TRUE;

       } else {

           pConnect->Interface.Set = KSINTERFACESETID_Standard;
           pConnect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
           pNewWavePin->fWaveQueued = FALSE;
       }
       pConnect->Interface.Flags = 0;
       PinId = pNewWavePin->pWaveDevice->PinId;
       Device = pNewWavePin->pWaveDevice->Device;

    } else {

       pConnect->Interface.Set = KSINTERFACESETID_Standard;
       pConnect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
       pConnect->Interface.Flags = 0;
       PinId = pNewWavePin->pWaveDevice->PinId;
       Device = pNewWavePin->pWaveDevice->Device;
    }
    pConnect->Medium.Set = KSMEDIUMSETID_Standard;
    pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
    pConnect->Medium.Flags = 0 ;
    pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    pConnect->Priority.PrioritySubClass = 1;

    pWaveDataFormat->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
    if (WAVE_FORMAT_EXTENSIBLE == lpFormat->wFormatTag)
    {
        PWAVEFORMATEXTENSIBLE lpFormatExtensible;

        lpFormatExtensible = (PWAVEFORMATEXTENSIBLE)lpFormat;
        pWaveDataFormat->DataFormat.SubFormat = lpFormatExtensible->SubFormat;
    }
    else
    {
        INIT_WAVEFORMATEX_GUID( &pWaveDataFormat->DataFormat.SubFormat,
                                lpFormat->wFormatTag );
    }
    pWaveDataFormat->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
    pWaveDataFormat->DataFormat.Flags = 0 ;
    pWaveDataFormat->DataFormat.FormatSize = RegionSize - sizeof(KSPIN_CONNECT);
    pWaveDataFormat->DataFormat.SampleSize = lpFormat->nBlockAlign ;
    pWaveDataFormat->DataFormat.Reserved = 0 ;

    //
    //  Copy over the whole waveformat structure
    //
    RtlCopyMemory( &pWaveDataFormat->WaveFormatEx,
                   lpFormat,
                   (lpFormat->wFormatTag == WAVE_FORMAT_PCM) ?
                   sizeof( PCMWAVEFORMAT ) :
                   sizeof( WAVEFORMATEX ) + lpFormat->cbSize);

    Status = AudioAllocateMemory_Fixed(( sizeof(CONTROLS_LIST)+
                                        ((MAX_WAVE_CONTROLS-1)*sizeof(CONTROL_NODE)) ),
                                       TAG_AudC_CONTROL,
                                       ZERO_FILL_MEMORY,
                                       &pControlList) ;
    if(!NT_SUCCESS(Status))
    {
       AudioFreeMemory_Unknown( &pConnect );
       DPF(DL_WARNING|FA_WAVE, ("Could not allocate ControlList"));
       goto exit;
    }

    pControlList->Count = MAX_WAVE_CONTROLS ;

    pControlList->Controls[WAVE_CONTROL_VOLUME].Control = KSNODETYPE_VOLUME ;
    pControlList->Controls[WAVE_CONTROL_RATE].Control = KSNODETYPE_SRC ;
    pControlList->Controls[WAVE_CONTROL_QUALITY].Control = KSNODETYPE_SRC ;
    pNewWavePin->pControlList = pControlList ;

    //
    // Open a pin
    //
    Status = OpenSysAudioPin(Device,
                             PinId,
                             pNewWavePin->DataFlow,
                             pConnect,
                             &pNewWavePin->pFileObject,
                             &pNewWavePin->pDeviceObject,
                             pNewWavePin->pControlList);

    AudioFreeMemory_Unknown( &pConnect );

    if(!NT_SUCCESS(Status))
    {
        CloseTheWavePin(pNewWavePin->pWaveDevice, pNewWavePin->WaveHandle);
        goto exit;
    }

    if ( pNewWavePin->DataFlow == KSPIN_DATAFLOW_IN ) {

        Status = AttachVirtualSource(pNewWavePin->pFileObject, pNewWavePin->pWaveDevice->pWdmaContext->VirtualWavePinId);

        if (!NT_SUCCESS(Status))
        {
            CloseTheWavePin(pNewWavePin->pWaveDevice, pNewWavePin->WaveHandle);
            goto exit;
        }
    }

    //
    // Now we've gotten through everything so we can mark this one as running.
    // We do it here because of the close path.  In that path fGraphRunning gets
    // decremented and the assert fires in the checked build.
    //
    pNewWavePin->fGraphRunning=TRUE;

    //
    // Why do we set this to KSSTATE_STOP and then change it to KSSTATE_PAUSE?  If
    // StatePin is able to successfully change the state to KSSTATE_PAUSE, the 
    // PinState will get updated to KSSTATE_PAUSE.
    //
    pNewWavePin->PinState = KSSTATE_STOP;
    StatePin(pNewWavePin->pFileObject, KSSTATE_PAUSE, &pNewWavePin->PinState);

exit:
    RETURN( Status ); 
}

void
CloseTheWavePin(
    PWAVEDEVICE pWaveDevice,
    HANDLE32    DeviceHandle
    )
{
    PWAVE_PIN_INSTANCE *ppCur;
    PWAVE_PIN_INSTANCE pCurFree;

    PAGED_CODE();
    //
    // Remove from device chain.  Notice that ppCur gets the address of the 
    // location of pWaveDevice->pWavePin.  Thus, the *ppCur = (*ppCur)->Next
    // assignment below updates the pWaveDevice->pWavePin location if we
    // close the first pin.
    //
    for (ppCur = &pWaveDevice->pWavePin;
         *ppCur != NULL;
         ppCur = &(*ppCur)->Next)
    {

        if ( NULL == DeviceHandle || (*ppCur)->WaveHandle == DeviceHandle )
        {
            //
            // Note that if there is outstanding Io we can not call CloseWavePin
            // until it's all come back.  Thus, we'll need to tell the device
            // to stop and then wait for the Io here.
            //
            if( (*ppCur)->pFileObject )
            {
                //
                // We will never have outstanding Io if we don't have a file object
                // to send it too.
                //
                WaitForOutStandingIo(pWaveDevice,*ppCur);
            }

            CloseWavePin ( *ppCur );

            pCurFree = *ppCur;
            *ppCur = (*ppCur)->Next;

            AudioFreeMemory( sizeof(WAVE_PIN_INSTANCE), &pCurFree );
            break;
        }
    }
}

//
// This routine can not fail!
//
VOID 
CloseWavePin(
    PWAVE_PIN_INSTANCE pWavePin
)
{
    ASSERT(pWavePin->NumPendingIos==0);

    PAGED_CODE();

    //
    // This routine can get called on the error path thus fGraphRunning may be FALSE.
    // In either case, we will need to close sysaudio and free memory.
    //
    pWavePin->fGraphRunning = FALSE;

    // Close the file object (pFileObject, if it exists)
    if(pWavePin->pFileObject)
    {
        CloseSysAudio(pWavePin->pWaveDevice->pWdmaContext, pWavePin->pFileObject);
        pWavePin->pFileObject = NULL;
    }

    //
    // AudioFreeMemory_Unknown NULLs out this location after freeing the memory.
    //
    AudioFreeMemory_Unknown ( &pWavePin->lpFormat );
    AudioFreeMemory_Unknown ( &pWavePin->pControlList ) ;
    //
    // Caller needs to free pWavePin if it wants to.
    //
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//
// This routine is used rather then an InterlockedIncrement and InterlockedDecrement
// because the routine that needs to determine what to do based on this information
// needs to perform multiple checks on different variables to determine exactly what
// to do.  Thus, we need a "critical section" for NumPendingIos.  Also, SpinLocks
// must be called from locked code.  :)
//
void
LockedWaveIoCount(
    PWAVE_PIN_INSTANCE  pCurWavePin,
    BOOL bIncrease
    )
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&pCurWavePin->WavePinSpinLock,&OldIrql);

    if( bIncrease )
        pCurWavePin->NumPendingIos++;
    else 
        pCurWavePin->NumPendingIos--;
    
    KeReleaseSpinLock(&pCurWavePin->WavePinSpinLock, OldIrql);
}

void
CompleteNumPendingIos(
    PWAVE_PIN_INSTANCE pCurWavePin
    )
{
    KIRQL                   OldIrql;

    if( pCurWavePin )
    {
        KeAcquireSpinLock(&pCurWavePin->WavePinSpinLock,&OldIrql);
        //
        // We always decrement NumPendingIos and then perform the comparisons.
        // If the count goes to zero, we're the last IRP so we need to check
        // to see if we need to signal any waiting thread.
        //
        if( ( --pCurWavePin->NumPendingIos == 0 ) && pCurWavePin->StoppingSource )
        {
            //
            // If this Io is the last one to come through, and we're currently
            // sitting waiting for the reset to finish, then we signal it here.
            //
            KeSetEvent ( &pCurWavePin->StopEvent, 0, FALSE ) ;
        }

        //
        // Upon leaving this spinlock, pCurWavePin can be freed by the close
        // routine if NumPendingIos went to zero!
        //
        KeReleaseSpinLock(&pCurWavePin->WavePinSpinLock, OldIrql);
    }
    //
    // Must not touch pCurWavePin after this!
    //
}


void
UnmapWriteContext(
    PWRITE_CONTEXT pWriteContext
    )
{
    wdmaudUnmapBuffer(pWriteContext->pBufferMdl);
    AudioFreeMemory_Unknown(&pWriteContext->pCapturedWaveHdr);
    AudioFreeMemory(sizeof(WRITE_CONTEXT),&pWriteContext);
}

void
FreeWriteContext(
    PWRITE_CONTEXT pWriteContext,
    NTSTATUS       IrpStatus
    )
{
    PIRP                    UserIrp;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

    //
    //  grab the parent IRP from the reserved field
    //
    UserIrp = (PIRP)pWriteContext->whInstance.wh.reserved;
    pPendingIrpContext = pWriteContext->pPendingIrpContext;

    UnmapWriteContext( pWriteContext );

    if( UserIrp )
        wdmaudUnprepareIrp( UserIrp,IrpStatus,0,pPendingIrpContext);
}

//
// This is the Irp completion routine.
//
NTSTATUS 
wqWriteWaveCallBack(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    IN PWAVEHDR     pWriteData
)
{
    PWAVE_PIN_INSTANCE      pCurWavePin;
    PMDL                    Mdl;
    PMDL                    nextMdl;
    PIRP                    UserIrp;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
    PWRITE_CONTEXT          pWriteContext = (PWRITE_CONTEXT)pWriteData;

    ASSERT(pWriteData);

    pCurWavePin = pWriteContext->whInstance.pWaveInstance;

    DPF(DL_TRACE|FA_WAVE, ("R%d: 0x%08x", pCurWavePin->NumPendingIos,pIrp));

    //
    // After we get our pCurWavePin, we don't need the write context any longer.
    //
    FreeWriteContext(pWriteContext, pIrp->IoStatus.Status);

    //
    // Consider putting this in a routine.
    //
    if (pIrp->MdlAddress != NULL)
    {
        //
        // Unlock any pages that may be described by MDLs.
        //
        Mdl = pIrp->MdlAddress;
        while (Mdl != NULL)
        {
            MmUnlockPages( Mdl );
            Mdl = Mdl->Next;
        }
    }

    if (pIrp->MdlAddress != NULL)
    {
        for (Mdl = pIrp->MdlAddress; Mdl != (PMDL) NULL; Mdl = nextMdl)
        {
            nextMdl = Mdl->Next;
            if (Mdl->MdlFlags & MDL_PARTIAL_HAS_BEEN_MAPPED)
            {
                ASSERT( Mdl->MdlFlags & MDL_PARTIAL );
                MmUnmapLockedPages( Mdl->MappedSystemVa, Mdl );
            }
            else if (!(Mdl->MdlFlags & MDL_PARTIAL))
            {
                ASSERT(!(Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA ));
            }
            AudioFreeMemory_Unknown( &Mdl );
        }
    }

    IoFreeIrp( pIrp );

    CompleteNumPendingIos( pCurWavePin );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

//
// Consider combining ssWriteWaveCallback and wqWriteWaveCallBack.  They look
// like the same routine!
//
NTSTATUS 
ssWriteWaveCallBack(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    IN PSTREAM_HEADER_EX pStreamHeader
)
{
    PWAVE_PIN_INSTANCE      pCurWavePin;
    PIRP                    UserIrp;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
    PWRITE_CONTEXT          pWriteContext = (PWRITE_CONTEXT)pStreamHeader->pWaveHdr;

    ASSERT(pWriteContext);

    pCurWavePin = pWriteContext->whInstance.pWaveInstance;

    DPF(DL_TRACE|FA_WAVE, ("R%d: 0x%08x", pCurWavePin->NumPendingIos,pIrp));

    FreeWriteContext( pWriteContext, pIrp->IoStatus.Status );

    CompleteNumPendingIos( pCurWavePin );

    return STATUS_SUCCESS;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//
// Walk the list and if we find a matching pin, write it back for the caller.
//
NTSTATUS
FindRunningPin(
    IN PWAVEDEVICE          pWaveDevice,
    IN HANDLE32             DeviceHandle,
    OUT PWAVE_PIN_INSTANCE* ppCurWavePin
    )
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    NTSTATUS           Status = STATUS_INVALID_DEVICE_REQUEST;

    //
    // Prepare for the error condition.
    //
    *ppCurWavePin = NULL;
    //
    //  find the right pin based off of the wave handle
    //
    for (pCurWavePin = pWaveDevice->pWavePin;
         pCurWavePin != NULL;
         pCurWavePin = pCurWavePin->Next)
    {
        if (pCurWavePin->WaveHandle == DeviceHandle)
        {
            if (pCurWavePin->fGraphRunning)
            {
                //
                // Write back the pointer and return success
                //
                *ppCurWavePin = pCurWavePin;
                Status = STATUS_SUCCESS;
            } else {
                DPF(DL_WARNING|FA_WAVE,("Invalid fGraphRunning") );
                Status = STATUS_DEVICE_NOT_READY;
            }
            return Status;
        }
    }
    return Status;
}

//
// WriteWaveOutPin walks the device list like the other routines.
//
// pUserIrp is the Irp on which this call from user mode was made.  It's
// always going to be valid.  We don't need to check it.
//
// This routine needs to set pCompletedIrp to either TRUE or FALSE.  If
// TRUE, the Irp was successfully marked STATUS_PENDING and it will get
// completed later.  If FALSE, there was some type of error that prevented
// us from submitting the Irp.  The caller to this routine will need to
// handle freeing the Irp.
//
//
// This routine should be the one storing the user's irp in the reserved field.
// Not the caller.
// pWriteContext->whInstance.wh.reserved = (DWORD_PTR)pIrp;  // store to complete later
//
NTSTATUS 
WriteWaveOutPin(
    PWAVEDEVICE       pWaveOutDevice,
    HANDLE32          DeviceHandle,
    LPWAVEHDR         pWriteData,
    PSTREAM_HEADER_EX pStreamHeader,
    PIRP              pUserIrp,
    PWDMACONTEXT      pContext,
    BOOL             *pCompletedIrp
)
{
    PWAVE_PIN_INSTANCE      pCurWavePin;
    PWRITE_CONTEXT          pWriteContext = (PWRITE_CONTEXT)pWriteData;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
    NTSTATUS                Status;

    PAGED_CODE();

    //
    // We assumee that pCompletedIrp is FALSE on entry.
    //
    ASSERT( *pCompletedIrp == FALSE );

    Status = FindRunningPin(pWaveOutDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        if (pCurWavePin->fWaveQueued) 
        {
            PIO_STACK_LOCATION      pIrpStack;
            LARGE_INTEGER           StartingOffset;
            PIRP                    pIrp = NULL;

            //
            //  Can't use KsStreamIo because these are not
            //  true stream headers.  Sending down headers
            //  using the WAVE_QUEUED interface
            //
            StartingOffset.QuadPart = 0;
            pIrp = IoBuildAsynchronousFsdRequest(IRP_MJ_WRITE,
                                                 pCurWavePin->pDeviceObject,
                                                 (PVOID)pWriteContext,
                                                 sizeof(WAVEHDR),
                                                 &StartingOffset,
                                                 &gIoStatusBlock);
            if( pIrp )
            {
                Status = wdmaudPrepareIrp( pUserIrp, 
                                           WaveOutDevice, 
                                           pContext, 
                                           &pPendingIrpContext );
                if( NT_SUCCESS(Status) )
                {
                    //
                    // The Irp was successfully marked STATUS_PENDING and put in
                    // our queue.  Now let's send it.
                    //

                    pWriteContext->whInstance.pWaveInstance = pCurWavePin;
                    pWriteContext->pPendingIrpContext = pPendingIrpContext;

                    pIrp->RequestorMode = KernelMode;
                    pIrp->Tail.Overlay.OriginalFileObject = pCurWavePin->pFileObject;

                    pIrpStack = IoGetNextIrpStackLocation(pIrp);
                    pIrpStack->FileObject = pCurWavePin->pFileObject;

                    IoSetCompletionRoutine(pIrp,
                                           wqWriteWaveCallBack,
                                           pWriteData,
                                           TRUE,TRUE,TRUE);

                    //
                    // one more IRP pending
                    //
                    LockedWaveIoCount(pCurWavePin,INCREASE);
                    DPF(DL_TRACE|FA_WAVE, ("A%d", pCurWavePin->NumPendingIos));

                    //
                    // We don't need to check the return code because the
                    // completion routine will ALWAYS be called.  See 
                    // IoSetCompletionRoutine(...TRUE,TRUE,TRUE).
                    //
                    IofCallDriver( pCurWavePin->pDeviceObject, pIrp );

                    //
                    // At this point, the Irp may have been completed and our 
                    // callback routine will have been called.  We can not touch
                    // the irp after this call.  The Callback routine Completes
                    // the Irp and unprepares the user's Irp.
                    //
                    *pCompletedIrp = TRUE;

                    //
                    // In wdmaudPrepareIrp we call IoCsqInsertIrp which calls
                    // IoMarkIrpPending, thus we must always return STATUS_PENDING.
                    //
                    return STATUS_PENDING;

                } else {
                    //
                    // We where not successful at putting the Irp in the queue.
                    // cleanup and indicated that we did not complete the Irp.
                    // The status will have been set by wdmaudPrepareIrp.

                    DPF(DL_WARNING|FA_WAVE,("wdmaudPrepareIrp failed Status=%X",Status) );
                }
            } else {
                //
                // Could not create a Irp to send down - error out!
                //
                DPF(DL_WARNING|FA_WAVE,("IoBuildAsynchronousFsdRequest failed") );
                Status = STATUS_UNSUCCESSFUL;

                //
                // We can't get an Irp to schedule.  Cleanup memory
                // and return.  The caller will complete the Irp.
                //
            }

        } else {

            //
            // If it's not wave queued we need to make sure that it's a PCM
            // looped call.
            //
            if ( (pWriteData->dwFlags & (WHDR_BEGINLOOP|WHDR_ENDLOOP)) ) 
            {
                //
                // Error out non-PCM looped calls
                //
                Status = STATUS_NOT_IMPLEMENTED;

            } else {

                //
                // The graph is running so we can use it.  Proceed.
                //
                Status = wdmaudPrepareIrp( pUserIrp, WaveOutDevice, pContext, &pPendingIrpContext );
                if( NT_SUCCESS(Status) )
                {
                    //
                    // The Irp was successfully marked STATUS_PENDING and put in
                    // our queue.  Now let's send it.
                    //

                    pWriteContext->whInstance.pWaveInstance = pCurWavePin;
                    pWriteContext->pPendingIrpContext = pPendingIrpContext;

                    //
                    // one more IRP pending
                    //
                    LockedWaveIoCount(pCurWavePin,INCREASE);
                    DPF(DL_TRACE|FA_WAVE, ("A%d", pCurWavePin->NumPendingIos));

                    pStreamHeader->pWavePin = pCurWavePin;
                    pStreamHeader->Header.FrameExtent       = pWriteData->dwBufferLength ;
                    pStreamHeader->Header.DataUsed          = pWriteData->dwBufferLength;
                    pStreamHeader->Header.OptionsFlags      = 0 ;
                    pStreamHeader->Header.Size              = sizeof( KSSTREAM_HEADER );
                    pStreamHeader->Header.TypeSpecificFlags = 0;
                    pStreamHeader->pWaveHdr = pWriteData;  // store so we can use later

                    Status = KsStreamIo(pCurWavePin->pFileObject,
                                        NULL,                   // Event
                                        NULL,                   // PortContext
                                        ssWriteWaveCallBack,
                                        pStreamHeader,              // CompletionContext
                                        KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
                                        &gIoStatusBlock,
                                        &pStreamHeader->Header,
                                        sizeof( KSSTREAM_HEADER ),
                                        KSSTREAM_WRITE,
                                        KernelMode );                    

                    //
                    // At this point, the Irp may have been completed and our 
                    // callback routine will have been called.  We can not touch
                    // the irp after this call.  The Callback routine Completes
                    // the Irp and unprepares the user's Irp.
                    //
                    *pCompletedIrp = TRUE;

                    //
                    // In wdmaudPrepareIrp we call IoCsqInsertIrp which calls
                    // IoMarkIrpPending, thus we must always return STATUS_PENDING.
                    // also, we don't want to clean up anything.... just return.
                    //
                    return STATUS_PENDING;

                    //
                    // Warning: If, for any reason, the completion routine is not called
                    // for this Irp, wdmaud.sys will hang.  It's been discovered that 
                    // KsStreamIo may error out in low memory conditions.  There is an
                    // outstanding bug to address this.
                    //


                } else {
                    //
                    // We where not successful at putting the Irp in the queue.
                    // cleanup and indicated that we did not complete the Irp.
                    // The Status was set by wdmaudPrepareIrp.

                    DPF(DL_WARNING|FA_WAVE,("wdmaudPrepareIrp failed Status=%X",Status) );
                }
            }
        }
    }
    //
    // All error paths end up here.  All error paths should cleanup the
    // memory so we don't leak.
    //

    UnmapWriteContext( pWriteContext );

    RETURN( Status );
}

//
// These next three routines all perform the same type of walk and checks.
// They should be combined into one walk routine and a callback.
//
NTSTATUS 
PosWavePin(
    PWAVEDEVICE     pWaveDevice,
    HANDLE32        DeviceHandle,
    PWAVEPOSITION   pWavePos
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    KSAUDIO_POSITION   AudioPosition;
    NTSTATUS           Status;

    PAGED_CODE();

    Status = FindRunningPin(pWaveDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        if ( pWavePos->Operation == KSPROPERTY_TYPE_SET )
        {
            AudioPosition.WriteOffset = pWavePos->BytePos;
        }

        Status = PinProperty(pCurWavePin->pFileObject,
                             &KSPROPSETID_Audio,
                             KSPROPERTY_AUDIO_POSITION,
                             pWavePos->Operation,
                             sizeof(AudioPosition),
                             &AudioPosition);

        if (NT_SUCCESS(Status))
        {
            pWavePos->BytePos = (DWORD)AudioPosition.PlayOffset;
        }
    }
    RETURN( Status );
}

NTSTATUS 
BreakLoopWaveOutPin(
    PWAVEDEVICE pWaveOutDevice,
    HANDLE32    DeviceHandle
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    NTSTATUS           Status;

    PAGED_CODE();

    Status = FindRunningPin(pWaveOutDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        if (pCurWavePin->fWaveQueued) {
            Status = PinMethod ( pCurWavePin->pFileObject,
                                 &KSMETHODSETID_Wave_Queued,
                                 KSMETHOD_WAVE_QUEUED_BREAKLOOP,
                                 KSMETHOD_TYPE_WRITE,    // TODO :: change to TYPE_NONE
                                 0,
                                 NULL ) ;
        }
        else {
            //
            // Error out non-pcm loop related commands
            //
            Status = STATUS_NOT_IMPLEMENTED;
        }
    }

    RETURN( Status );
}

NTSTATUS
ResetWaveOutPin(
    PWAVEDEVICE pWaveOutDevice,
    HANDLE32    DeviceHandle
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    NTSTATUS           Status;
    KSRESET            ResetValue ;

    PAGED_CODE();

    Status = FindRunningPin(pWaveOutDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status))
    {
        pCurWavePin->StoppingSource = TRUE ;

        ResetValue = KSRESET_BEGIN ;
        Status = ResetWavePin(pCurWavePin, &ResetValue) ;

        //
        // If the driver fails to reset will will not wait for the
        // Irps to complete.  But, that would be bad in the
        // CleanupWavePins case because we're going to free
        // the memory when we return from this call.  Thus,
        // will choose a hang over a bugcheck and wait for
        // the Irps to complete.
        //

        if ( pCurWavePin->NumPendingIos )
        {
            DPF(DL_TRACE|FA_WAVE, ("Start waiting for stop to complete"));
            KeWaitForSingleObject ( &pCurWavePin->StopEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL ) ;
        }
        DPF(DL_TRACE|FA_WAVE, ("Done waiting for stop to complete"));
        ResetValue = KSRESET_END ;
        ResetWavePin(pCurWavePin, &ResetValue) ;

        //
        // Why do we have this KeClearEvent ???
        //
        KeClearEvent ( &pCurWavePin->StopEvent );

        pCurWavePin->StoppingSource = FALSE ;
    }

    RETURN( Status );
}

//
// The only difference between this and StatePin is KSPROPERTY_CONNECTION_STATE
// and IOCTL_KS_RESET_STATE. Consider using StatePin if possible.
//
NTSTATUS 
ResetWavePin(
    PWAVE_PIN_INSTANCE pWavePin,
    KSRESET            *pResetValue
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesReturned ;

    PAGED_CODE();
    if (!pWavePin->fGraphRunning)
    {
        DPF(DL_WARNING|FA_WAVE,("Invalid fGraphRunning") );
        RETURN( STATUS_INVALID_DEVICE_REQUEST );
    }

    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_RESET_STATE pResetValue=%X",pResetValue) );

    Status = KsSynchronousIoControlDevice(pWavePin->pFileObject,
                                          KernelMode,
                                          IOCTL_KS_RESET_STATE,
                                          pResetValue,
                                          sizeof(KSRESET),
                                          NULL,
                                          0,
                                          &BytesReturned);

    DPF(DL_TRACE|FA_SYSAUDIO,("IOCTL_KS_RESET_STATE result=%X",Status) );

    RETURN( Status );
}

//
// Looks the same, different flavor.
//
NTSTATUS 
StateWavePin(
    PWAVEDEVICE pWaveInDevice,
    HANDLE32    DeviceHandle,
    KSSTATE     State
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    NTSTATUS           Status;

    PAGED_CODE();

    Status = FindRunningPin(pWaveInDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        if( pCurWavePin->DataFlow == KSPIN_DATAFLOW_OUT )
        {
            //
            // We have an In pin.
            //
            //
            //  On a waveInStop, one more buffer needs to make
            //  it up to the application before the device can
            //  stop.  The caveat is that if the buffer is
            //  large it might take awhile for the stop to happen.
            //
            //  Don't return let this extra buffer complete if the
            //  device is already in a paused state.
            //
            if( (KSSTATE_PAUSE == State) &&
                (KSSTATE_PAUSE != pCurWavePin->PinState) )
            {
                pCurWavePin->PausingSource = TRUE ;

                if ( pCurWavePin->NumPendingIos )
                {
                    DPF(DL_TRACE|FA_WAVE, ("Waiting for PauseEvent..."));
                    KeWaitForSingleObject ( &pCurWavePin->PauseEvent,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL ) ;
                    DPF(DL_TRACE|FA_WAVE, ("...Done waiting for PauseEvent"));
                }

                KeClearEvent ( &pCurWavePin->PauseEvent );

                pCurWavePin->PausingSource = FALSE ;
            }

            Status = StatePin ( pCurWavePin->pFileObject, State, &pCurWavePin->PinState ) ;

            if ( NT_SUCCESS(Status) )
            {
                ASSERT(pCurWavePin->PinState == State);

                if ( KSSTATE_STOP == State )
                {
                    Status = StatePin( pCurWavePin->pFileObject,KSSTATE_PAUSE,&pCurWavePin->PinState);
                }
            }
        } else {
            //
            // We have an out pin.
            //
            Status = StatePin ( pCurWavePin->pFileObject, State, &pCurWavePin->PinState ) ;
        }
    }

    RETURN( Status );
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

void
UnmapStreamHeader(
    PSTREAM_HEADER_EX pStreamHeader
    )
{
    wdmaudUnmapBuffer(pStreamHeader->pBufferMdl);
    wdmaudUnmapBuffer(pStreamHeader->pHeaderMdl);
    AudioFreeMemory_Unknown(&pStreamHeader->pWaveHdrAligned);
    AudioFreeMemory(sizeof(STREAM_HEADER_EX),&pStreamHeader);
}

void
FreeStreamHeader(
    PSTREAM_HEADER_EX pStreamHeader,
    NTSTATUS IrpStatus
    )
{
    PIRP                    UserIrp;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

    UserIrp = pStreamHeader->pIrp;

    ASSERT(UserIrp);

    pPendingIrpContext = pStreamHeader->pPendingIrpContext;

    UnmapStreamHeader( pStreamHeader );

    wdmaudUnprepareIrp( UserIrp,IrpStatus,sizeof(DEVICEINFO),pPendingIrpContext );
}


//
// This is the read Irp completion routine.
//
NTSTATUS 
ReadWaveCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
)
{
    // cast the reserved field to the parent IRP that we stored in here
    PWAVE_PIN_INSTANCE      pCurWavePin;
    NTSTATUS                Status;
    KIRQL                   OldIrql;

    //
    // Must get the current pin before we free the stream header structure.
    //
    pCurWavePin = pStreamHeader->pWavePin;

    //
    //  Get the dataused and fill the bytes recorded field
    //
    if (pIrp->IoStatus.Status == STATUS_CANCELLED)
        pStreamHeader->pWaveHdrAligned->dwBytesRecorded = 0L;
    else
        pStreamHeader->pWaveHdrAligned->dwBytesRecorded = pStreamHeader->Header.DataUsed;

    //
    //  Copy back the contents of the captured buffer
    //
    try
    {
        RtlCopyMemory( pStreamHeader->pdwBytesRecorded,
                       &pStreamHeader->pWaveHdrAligned->dwBytesRecorded,
                       sizeof(DWORD));
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        DPF(DL_WARNING|FA_WAVE, ("Couldn't copy waveheader (0x%08x)", GetExceptionCode()) );
    }

    FreeStreamHeader( pStreamHeader, pIrp->IoStatus.Status );

    if ( pCurWavePin )
    {
        //
        // Need to lock this code so we can decrement and check and set an event
        // with no preemption windows.
        //
        KeAcquireSpinLock(&pCurWavePin->WavePinSpinLock, &OldIrql);

        //
        // We always decrement NumPendingIos before doing any comparisons.  This
        // is so that we're consistant.
        //
        pCurWavePin->NumPendingIos--;

        if( pCurWavePin->PausingSource )
        {
            //
            //  Let this I/O squeeze out of the queue on a waveInStop
            //
            KeSetEvent ( &pCurWavePin->PauseEvent, 0, FALSE ) ;
        }

        //
        // If the count went to zero, we're the last IRP so we need to check
        // to see if we need to signal any waiting thread.
        //
        if( (pCurWavePin->NumPendingIos == 0) && pCurWavePin->StoppingSource )
        {
            //
            // Because we do not block (FALSE), we can call KeSetEvent in this 
            // Lock.
            //
            KeSetEvent ( &pCurWavePin->StopEvent, 0, FALSE ) ;
        }

        //
        // Upon leaving this spinlock, pCurWavePin can be freed by the close
        // routine if NumPendingIos went to zero!
        //
        KeReleaseSpinLock(&pCurWavePin->WavePinSpinLock, OldIrql);
    }

    return STATUS_SUCCESS;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//
// pUserIrp will always be valid when this call is made.  It is the Irp
// that we got for the user mode request.
//
// pStreamHeader is alway going to be valid.
//
NTSTATUS 
ReadWaveInPin(
    PWAVEDEVICE         pWaveInDevice,
    HANDLE32            DeviceHandle,
    PSTREAM_HEADER_EX   pStreamHeader,
    PIRP                pUserIrp,
    PWDMACONTEXT        pContext,
    BOOL               *pCompletedIrp
)
{
    PWAVE_PIN_INSTANCE      pCurWavePin;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
    NTSTATUS                Status;

    PAGED_CODE();

    //
    // We assumee that pCompletedIrp is FALSE on entry.
    //
    ASSERT( *pCompletedIrp == FALSE );

    Status = FindRunningPin(pWaveInDevice,DeviceHandle,&pCurWavePin);
    if( NT_SUCCESS(Status) )
    {
        Status = wdmaudPrepareIrp( pUserIrp, WaveInDevice, pContext, &pPendingIrpContext );
        if( NT_SUCCESS(Status) )
        {
            pStreamHeader->pWavePin = pCurWavePin;
            pStreamHeader->pPendingIrpContext = pPendingIrpContext;
            ASSERT(pPendingIrpContext);

            pStreamHeader->Header.OptionsFlags = 0 ;
            pStreamHeader->Header.Size = sizeof( KSSTREAM_HEADER );
            pStreamHeader->Header.TypeSpecificFlags = 0;

            LockedWaveIoCount(pCurWavePin,INCREASE);

            DPF(DL_TRACE|FA_WAVE, ("A%d: 0x%08x", pCurWavePin->NumPendingIos,
                                                          pStreamHeader));

            Status = KsStreamIo(pCurWavePin->pFileObject,
                                NULL,                   // Event
                                NULL,                   // PortContext
                                ReadWaveCallBack,
                                pStreamHeader,              // CompletionContext
                                KsInvokeOnSuccess | KsInvokeOnCancel | KsInvokeOnError,
                                &gIoStatusBlock,
                                &pStreamHeader->Header,
                                sizeof( KSSTREAM_HEADER ),
                                KSSTREAM_READ,
                                KernelMode );

            //
            // In wdmaudPrepareIrp we call IoCsqInsertIrp which calls
            // IoMarkIrpPending, thus we must always return STATUS_PENDING.
            // And we completed the Irp.
            //
            *pCompletedIrp = TRUE;

            return STATUS_PENDING;

            //
            // Warning: If, for any reason, the completion routine is not called
            // for this Irp, wdmaud.sys will hang.  It's been discovered that 
            // KsStreamIo may error out in low memory conditions.  There is an
            // outstanding bug to address this.
            //


        } else {
            //
            // wdmaudPrepareIrp would have set Status for this error path
            //
            DPF(DL_WARNING|FA_WAVE,("wdmaudPrepareIrp failed Status=%X",Status) );
        }
    }
    //
    // All error paths lead here.
    //
    UnmapStreamHeader( pStreamHeader );

    RETURN( Status );
}

NTSTATUS
FindVolumeControl(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface,
    IN DWORD DeviceType
)
{
    PCOMMONDEVICE *papCommonDevice;
    PWAVEDEVICE paWaveOutDevs;
    PMIDIDEVICE paMidiOutDevs;
    PAUXDEVICE paAuxDevs;
    ULONG DeviceNumber;
    ULONG MixerIndex;
    NTSTATUS Status;

    PAGED_CODE();
    papCommonDevice = &pWdmaContext->apCommonDevice[DeviceType][0];
    paWaveOutDevs = pWdmaContext->WaveOutDevs;
    paMidiOutDevs = pWdmaContext->MidiOutDevs;
    paAuxDevs = pWdmaContext->AuxDevs;

    for( DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++ ) {

        if(papCommonDevice[DeviceNumber]->Device == UNUSED_DEVICE) {
            continue;
        }

        if(MyWcsicmp(papCommonDevice[DeviceNumber]->DeviceInterface, DeviceInterface)) {
            continue;
        }

        MixerIndex = FindMixerForDevNode(pWdmaContext->MixerDevs, DeviceInterface);
        if ( (MixerIndex == UNUSED_DEVICE) || (pWdmaContext->MixerDevs[MixerIndex].pwstrName == NULL) ) {
            continue;
        }

        switch(DeviceType) {

            case WaveOutDevice:
                Status = IsVolumeControl(
                  pWdmaContext,
                  DeviceInterface,
                  MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT,
                  &paWaveOutDevs[ DeviceNumber ].dwVolumeID,
                  &paWaveOutDevs[ DeviceNumber ].cChannels);

                if(!NT_SUCCESS(Status)) {
                    break;
                }

                if( paWaveOutDevs[ DeviceNumber ].pTimer == NULL ) {
                    Status = AudioAllocateMemory_Fixed(sizeof(KTIMER),
                                                       TAG_AudT_TIMER,
                                                       ZERO_FILL_MEMORY,
                                                       &paWaveOutDevs[ DeviceNumber ].pTimer);

                    if(!NT_SUCCESS(Status)) {
                        return Status;
                    }

                    KeInitializeTimerEx( paWaveOutDevs[ DeviceNumber ].pTimer,
                                         NotificationTimer
                                         );
                }

                if( paWaveOutDevs[ DeviceNumber ].pDpc == NULL ) {
                    Status = AudioAllocateMemory_Fixed(sizeof(KDPC),
                                                       TAG_AudE_EVENT,
                                                       ZERO_FILL_MEMORY,
                                                       &paWaveOutDevs[ DeviceNumber ].pDpc);

                    if(!NT_SUCCESS(Status)) {
                        return Status;
                    }

                    KeInitializeDpc( paWaveOutDevs[ DeviceNumber ].pDpc,
                                     SetVolumeDpc,
                                     &paWaveOutDevs[ DeviceNumber ]
                                     );

                    // Initialize the left and right channels to goofy values.
                    // This signifies that the cache is invalid

                    paWaveOutDevs[ DeviceNumber ].LeftVolume = 0x4321;
                    paWaveOutDevs[ DeviceNumber ].RightVolume = 0x6789;
                    paWaveOutDevs[ DeviceNumber ].fNeedToSetVol = FALSE;
                }
                break;

            case MidiOutDevice:
                Status = IsVolumeControl(
                  pWdmaContext,
                  DeviceInterface,
                  MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER,
                  &paMidiOutDevs[ DeviceNumber ].dwVolumeID,
                  &paMidiOutDevs[ DeviceNumber ].cChannels);
                break;

            case AuxDevice:
                Status = IsVolumeControl(
                  pWdmaContext,
                  DeviceInterface,
                  MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC,
                  &paAuxDevs[ DeviceNumber ].dwVolumeID,
                  &paAuxDevs[ DeviceNumber ].cChannels);
                break;
        }

    } // while

    return( STATUS_SUCCESS );
}

NTSTATUS
IsVolumeControl(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface,
    IN DWORD dwComponentType,
    IN PDWORD pdwControlID,
    IN PDWORD pcChannels
)
{
    MIXERLINE         ml;
    MIXERLINECONTROLS mlc;
    MIXERCONTROL      mc;
    MMRESULT          mmr;

    PAGED_CODE();
    ml.dwComponentType = dwComponentType;
    ml.cbStruct = sizeof( MIXERLINE );

    mmr = kmxlGetLineInfo( pWdmaContext,
                           DeviceInterface,
                           &ml,
                           MIXER_GETLINEINFOF_COMPONENTTYPE
                         );
    if( mmr != MMSYSERR_NOERROR ) {
        DPF(DL_WARNING|FA_WAVE,("kmxlGetLineInfo failed mmr=%X",mmr) );
        RETURN( STATUS_UNSUCCESSFUL );
    }

    mlc.cbStruct      = sizeof( MIXERLINECONTROLS );
    mlc.dwLineID      = ml.dwLineID;
    mlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
    mlc.cControls     = 1;
    mlc.cbmxctrl      = sizeof( MIXERCONTROL );
    mlc.pamxctrl      = &mc;

    mmr = kmxlGetLineControls(
        pWdmaContext,
        DeviceInterface,
        &mlc,
        MIXER_GETLINECONTROLSF_ONEBYTYPE
        );
    if( mmr != MMSYSERR_NOERROR ) {
        DPF(DL_WARNING|FA_WAVE,( "kmxlGetLineControls failed mmr=%x!", mmr ) );
        return( STATUS_UNSUCCESSFUL );
    }
    *pdwControlID = mc.dwControlID;
    *pcChannels  = ml.cChannels;
    return( STATUS_SUCCESS );
}

#pragma LOCKED_CODE

NTSTATUS
MapMmSysError(
    IN MMRESULT mmr
)
{
    if ( (mmr == MMSYSERR_INVALPARAM) ||
         (mmr == MIXERR_INVALCONTROL) ) {
        return (STATUS_INVALID_PARAMETER);
    }

    if (mmr == MMSYSERR_NOTSUPPORTED) {
        return (STATUS_NOT_SUPPORTED);
    }

    if (mmr == MMSYSERR_NOMEM) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    if (mmr == MMSYSERR_NOERROR) {
        return(STATUS_SUCCESS);
    }

    return(STATUS_UNSUCCESSFUL);
}


NTSTATUS
SetVolume(
    PWDMACONTEXT pWdmaContext,
    IN DWORD DeviceNumber,
    IN DWORD DeviceType,
    IN DWORD LeftChannel,
    IN DWORD RightChannel
)
{
    MIXERCONTROLDETAILS          mcd;
    MIXERCONTROLDETAILS_UNSIGNED mcd_u[ 2 ];
    LARGE_INTEGER                li;

    if( DeviceNumber == (ULONG) -1 ) {
        RETURN( STATUS_INVALID_PARAMETER );
    }

    if( DeviceType == WaveOutDevice ) {
        PWAVEDEVICE paWaveOutDevs = pWdmaContext->WaveOutDevs;

        mcd_u[ 0 ].dwValue = LeftChannel;
        mcd_u[ 1 ].dwValue = RightChannel;

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = paWaveOutDevs[ DeviceNumber ].dwVolumeID;
        mcd.cChannels      = paWaveOutDevs[ DeviceNumber ].cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                                sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        return( MapMmSysError(kmxlSetControlDetails( pWdmaContext,
                                       paWaveOutDevs[ DeviceNumber ].DeviceInterface,
                                       &mcd,
                                       0
                                     ))
              );
    }

    if( DeviceType == MidiOutDevice ) {
        PMIDIDEVICE paMidiOutDevs = pWdmaContext->MidiOutDevs;

        //
        //  We don't support volume changes on a MIDIPORT
        //
        if ( paMidiOutDevs[ DeviceNumber ].MusicDataRanges ) {
            WORD wTechnology;

            wTechnology = GetMidiTechnology( (PKSDATARANGE_MUSIC)
              &paMidiOutDevs[ DeviceNumber ].MusicDataRanges->aDataRanges[0] );

            if (wTechnology == MOD_MIDIPORT) {
                RETURN( STATUS_INVALID_DEVICE_REQUEST );
            }
        }

        mcd_u[ 0 ].dwValue = LeftChannel;
        mcd_u[ 1 ].dwValue = RightChannel;

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = paMidiOutDevs[ DeviceNumber ].dwVolumeID;
        mcd.cChannels      = paMidiOutDevs[ DeviceNumber ].cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                                sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        return( MapMmSysError(kmxlSetControlDetails( pWdmaContext,
                                       paMidiOutDevs[ DeviceNumber ].DeviceInterface,
                                       &mcd,
                                       0
                                     ))
              );
    }

    if( DeviceType == AuxDevice ) {
        PAUXDEVICE paAuxDevs = pWdmaContext->AuxDevs;

        mcd_u[ 0 ].dwValue = LeftChannel;
        mcd_u[ 1 ].dwValue = RightChannel;

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = paAuxDevs[ DeviceNumber ].dwVolumeID;
        mcd.cChannels      = paAuxDevs[ DeviceNumber ].cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                                 sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        return( MapMmSysError(kmxlSetControlDetails( pWdmaContext,
                                       paAuxDevs[ DeviceNumber ].DeviceInterface,
                                       &mcd,
                                       0
                                     ))
              );
     }

     return( STATUS_SUCCESS );
}

VOID
SetVolumeDpc(
    IN PKDPC pDpc,
    IN PWAVEDEVICE pWaveDevice,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
)
{
    QueueWorkList(pWaveDevice->pWdmaContext, SetVolumeWorker, pWaveDevice, NULL ) ;
}

VOID
SetVolumeWorker(
    IN PWAVEDEVICE pDevice,
    IN PVOID pNotUsed
)
{
    MIXERCONTROLDETAILS          mcd;
    MIXERCONTROLDETAILS_UNSIGNED mcd_u[ 2 ];

    DPF(DL_TRACE|FA_WAVE,( "Left %X Right %X",
               pDevice->LeftVolume,
               pDevice->RightVolume ) );

    pDevice->fNeedToSetVol = FALSE;

    mcd_u[ 0 ].dwValue = pDevice->LeftVolume;
    mcd_u[ 1 ].dwValue = pDevice->RightVolume;

    mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
    mcd.dwControlID    = pDevice->dwVolumeID;
    mcd.cChannels      = pDevice->cChannels;
    mcd.cMultipleItems = 0;
    mcd.cbDetails      = mcd.cChannels * sizeof( MIXERCONTROLDETAILS_UNSIGNED );
    mcd.paDetails      = &mcd_u[0];

    kmxlSetControlDetails( pDevice->pWdmaContext,
                           pDevice->DeviceInterface,
                           &mcd,
                           0
                         );
}

#pragma PAGEABLE_CODE

NTSTATUS
GetVolume(
    IN  PWDMACONTEXT pWdmaContext,
    IN  DWORD DeviceNumber,
    IN  DWORD  DeviceType,
    OUT PDWORD LeftChannel,
    OUT PDWORD RightChannel
)
{
    MIXERCONTROLDETAILS          mcd;
    MIXERCONTROLDETAILS_UNSIGNED mcd_u[ 2 ];
    MMRESULT                     mmr;

    PAGED_CODE();
    if( DeviceType == WaveOutDevice ) {
        PWAVEDEVICE pWaveOutDevice = &pWdmaContext->WaveOutDevs[DeviceNumber];

         if( ( pWaveOutDevice->LeftVolume != 0x4321 ) &&
             ( pWaveOutDevice->RightVolume != 0x6789 ) ) {

              *LeftChannel = pWaveOutDevice->LeftVolume;
              *RightChannel = pWaveOutDevice->RightVolume;
              return( STATUS_SUCCESS );

         } else {

              mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
              mcd.dwControlID    = pWaveOutDevice->dwVolumeID;
              mcd.cChannels      = pWaveOutDevice->cChannels;
              mcd.cMultipleItems = 0;
              mcd.cbDetails      = mcd.cChannels *
                                    sizeof( MIXERCONTROLDETAILS_UNSIGNED );
              mcd.paDetails      = &mcd_u[0];

              mmr = kmxlGetControlDetails( pWdmaContext,
                                           pWaveOutDevice->DeviceInterface,
                                           &mcd,
                                           0 );

              if( mmr == MMSYSERR_NOERROR )
              {
                *LeftChannel  = mcd_u[ 0 ].dwValue;
                *RightChannel = mcd_u[ 1 ].dwValue;
              }

              return( MapMmSysError(mmr) );
         }

    }

    if( DeviceType == MidiOutDevice ) {
        PMIDIDEVICE pMidiOutDevice = &pWdmaContext->MidiOutDevs[DeviceNumber];

        //
        //  We don't support volume changes on a MIDIPORT
        //
        if ( pMidiOutDevice->MusicDataRanges ) {
            WORD wTechnology;

            wTechnology = GetMidiTechnology( (PKSDATARANGE_MUSIC)
              &pMidiOutDevice->MusicDataRanges->aDataRanges[0] );

            if (wTechnology == MOD_MIDIPORT) {
                RETURN( STATUS_INVALID_DEVICE_REQUEST );
            }
        }

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = pMidiOutDevice->dwVolumeID;
        mcd.cChannels      = pMidiOutDevice->cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                               sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        mmr = kmxlGetControlDetails( pWdmaContext,
                                     pMidiOutDevice->DeviceInterface,
                                     &mcd,
                                     0 );

        if( mmr == MMSYSERR_NOERROR )
        {
            *LeftChannel  = mcd_u[ 0 ].dwValue;
            *RightChannel = mcd_u[ 1 ].dwValue;
        }

        return( MapMmSysError(mmr) );
    }

    if( DeviceType == AuxDevice ) {
        PAUXDEVICE pAuxDevice = &pWdmaContext->AuxDevs[DeviceNumber];

        mcd.cbStruct       = sizeof( MIXERCONTROLDETAILS );
        mcd.dwControlID    = pAuxDevice->dwVolumeID;
        mcd.cChannels      = pAuxDevice->cChannels;
        mcd.cMultipleItems = 0;
        mcd.cbDetails      = mcd.cChannels *
                               sizeof( MIXERCONTROLDETAILS_UNSIGNED );
        mcd.paDetails      = &mcd_u[0];

        mmr = kmxlGetControlDetails( pWdmaContext,
                                     pAuxDevice->DeviceInterface,
                                     &mcd,
                                     0 );

        if( mmr == MMSYSERR_NOERROR )
        {
           *LeftChannel  = mcd_u[ 0 ].dwValue;
           *RightChannel = mcd_u[ 1 ].dwValue;
        }

        return( MapMmSysError(mmr) );
    }
    RETURN( STATUS_INVALID_PARAMETER );
}

//
// This routine waits for the Io to complete on the device after telling
// the device to stop.
//
VOID
WaitForOutStandingIo(
    IN PWAVEDEVICE        pWaveDevice,
    IN PWAVE_PIN_INSTANCE pCurWavePin
    )
{
    if( pCurWavePin->DataFlow == KSPIN_DATAFLOW_IN)
    {
        //
        // We have a wave out pin to close.  Force pending data
        // to come back on running pins.  Non-running pins are
        // ignored on this call.
        //
        ResetWaveOutPin( pWaveDevice, pCurWavePin->WaveHandle);


    } else {
        //
        // We have a wave in pin to close
        //
        pCurWavePin->StoppingSource = TRUE ;

        //
        // We can not fail on this path.  Doesn't look like we need to make sure
        // that we're running here.
        //
        StatePin ( pCurWavePin->pFileObject, KSSTATE_STOP, &pCurWavePin->PinState ) ;

        //
        // Regardless of the return code we're going to wait for all the 
        // irps to complete.  If the driver do not successfuly complete
        // the irps, we will hang waiting for them here.
        //

        if( pCurWavePin->NumPendingIos )
        {
            KeWaitForSingleObject ( &pCurWavePin->StopEvent,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL ) ;
        }

        //
        // Why do we have this KeClearEvent???
        //
        KeClearEvent ( &pCurWavePin->StopEvent );

        pCurWavePin->StoppingSource = FALSE ;
    }
}

//
// Replaces CleanupWaveOutPins and CleanupWaveInPins.
//
VOID 
CleanupWavePins(
    IN PWAVEDEVICE pWaveDevice
)
{
    PWAVE_PIN_INSTANCE pCurWavePin;
    PWAVE_PIN_INSTANCE pFreeWavePin;

    PAGED_CODE();

    while (pCurWavePin = pWaveDevice->pWavePin)
    {
        DPF(DL_TRACE|FA_WAVE, ("0x%08x", pCurWavePin));

        WaitForOutStandingIo(pWaveDevice,pCurWavePin);

        CloseWavePin( pCurWavePin );

        pFreeWavePin = pCurWavePin;
        pWaveDevice->pWavePin = pCurWavePin->Next;

        AudioFreeMemory( sizeof(WAVE_PIN_INSTANCE),&pFreeWavePin );
    }


}

VOID 
CleanupWaveDevices(
    IN  PWDMACONTEXT pWdmaContext
)
{
    DWORD              DeviceNumber;

    PAGED_CODE();
    for (DeviceNumber = 0; DeviceNumber < MAXNUMDEVS; DeviceNumber++)
    {
        //
        //  Handle waveout devices first...
        //
        if (pWdmaContext->apCommonDevice[WaveOutDevice][DeviceNumber]->Device != UNUSED_DEVICE)
        {
            if ( pWdmaContext->WaveOutDevs[DeviceNumber].pTimer != NULL)
                KeCancelTimer(pWdmaContext->WaveOutDevs[DeviceNumber].pTimer);

            CleanupWavePins(&pWdmaContext->WaveOutDevs[DeviceNumber]);

            //
            // Sense we have removed it from the list, the other routine that would do
            // the same thing (RemoveDevNode) will also attempt to remove it from the
            // the list because the value it non-null.  Thus, the only safe thing that
            // we can do here is free the memory.
            //
            // Note: This routine will only get called when the handle to the driver is
            // closed.
            //

            AudioFreeMemory_Unknown(&pWdmaContext->WaveOutDevs[DeviceNumber].pTimer);
        }

        //
        //  ...then handle wavein devices
        //
        if (pWdmaContext->apCommonDevice[WaveInDevice][DeviceNumber]->Device != UNUSED_DEVICE)
        {
            CleanupWavePins(&pWdmaContext->WaveInDevs[DeviceNumber]);
        }
    }
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

//
// --------------------------------------------------------------------------------
//
// The following routines are used by more then just wave.c
//
// --------------------------------------------------------------------------------
//

NTSTATUS 
wdmaudPrepareIrp(
    PIRP                     pIrp,
    ULONG                    IrpDeviceType,
    PWDMACONTEXT             pContext,
    PWDMAPENDINGIRP_CONTEXT *ppPendingIrpContext
)
{
    return AddIrpToPendingList( pIrp,
                                IrpDeviceType,
                                pContext,
                                ppPendingIrpContext );
}

NTSTATUS 
wdmaudUnprepareIrp(
    PIRP                    pIrp,
    NTSTATUS                IrpStatus,
    ULONG_PTR               Information,
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext
)
{
    NTSTATUS Status;

    // Note that the IrpContext may have been zero'ed out already because the cancel
    // routine has already been called.  The cancel safe queue API zeroes out the Irp
    // field in the context when it performs a cancel.
    Status = RemoveIrpFromPendingList( pPendingIrpContext );
    if (NT_SUCCESS(Status)) {

        pIrp->IoStatus.Status = IrpStatus;

        if (Information) {
            pIrp->IoStatus.Information = Information;
        }

        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    }

    RETURN( Status );
}


#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//
// StatePin - This is used by both Midi and Wave functionality.
//
// On success State will get updated to the new state.  Must make sure that
// fGraphRunning is TRUE before calling this routine.
//
// call like: 
// if( pWavePin->fGraphRunning )
//     StatePin(pWavePin->pFileObject, KSSTATE_PAUSE, &pWavePin->State);
//
NTSTATUS 
StatePin(
    IN PFILE_OBJECT pFileObject,
    IN KSSTATE      State,
    OUT PKSSTATE    pResultingState
)
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = PinProperty(pFileObject,
                         &KSPROPSETID_Connection,
                         KSPROPERTY_CONNECTION_STATE,
                         KSPROPERTY_TYPE_SET,
                         sizeof(State),
                         &State);
    if(NT_SUCCESS(Status))
    {
        *pResultingState = State;
    }
    RETURN( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\robust.h ===
//
// These are bit value flags
//
typedef enum AudioAllocateMemoryFlags {
    DEFAULT_MEMORY   = 0x00, // Standard ExAllocatePool call
    ZERO_FILL_MEMORY = 0x01, // Zero the memory
    QUOTA_MEMORY     = 0x02, // ExAllocatePoolWithQuota call
    LIMIT_MEMORY     = 0x04, // Never allocation more then 1/4 Meg
    FIXED_MEMORY     = 0x08, // Use locked memory
    PAGED_MEMORY     = 0x10  // use pageable memory
} AAMFLAGS;

/*
#define DEFAULT_MEMORY    0x00 // Standard ExAllocatePool call
#define ZERO_FILL_MEMORY  0x01 // Zero the memory
#define QUOTA_MEMORY      0x02 // ExAllocatePoolWithQuota call
#define LIMIT_MEMORY      0x04 // Never allocation more then 1/4 Meg
#define FIXED_MEMORY      0x08 // Use locked memory
#define PAGED_MEMORY      0x10 // use pageable memory
*/

#define AudioAllocateMemory_Fixed(b,t,f,p) AudioAllocateMemory(b,t,f|FIXED_MEMORY,p)
#define AudioAllocateMemory_Paged(b,t,f,p) AudioAllocateMemory(b,t,f|PAGED_MEMORY,p)

NTSTATUS
AudioAllocateMemory(
    IN SIZE_T   bytes,
    IN ULONG    tag,
    IN AAMFLAGS dwFlags,
    OUT PVOID  *pptr
    );

#define UNKNOWN_SIZE MAXULONG_PTR

#define AudioFreeMemory_Unknown(pMem) AudioFreeMemory(UNKNOWN_SIZE, pMem)

void
AudioFreeMemory(
    IN SIZE_T bytes,
    OUT PVOID *pptr
    );




//
// Validation routines
//
#define AUDIO_BUGCHECK_CODE 0x000000AD

#define AUDIO_NOT_AT_PASSIVE_LEVEL     0x00000000
#define AUDIO_NOT_BELOW_DISPATCH_LEVEL 0x00000001
#define AUDIO_INVALID_IRQL_LEVEL       0x00000002

//
// BugCheck AD
// Param1:     AUDIO_STRUCTURE_VALIDATION
// Param2:     ptr
// Param3:     ntstatus code
//
#define AUDIO_STRUCTURE_VALIDATION     0x00000003

//
// BugCheck AD
// Param1:     AUDIO_MEMORY_ALLOCATION_OVERWRITE
// Param2:     ptr
//
#define AUDIO_MEMORY_ALLOCATION_OVERWRITE 0x00000004

//
// BugCheck AD
// Param1:     AUDIO_NESTED_MUTEX_SITUATION
// Param2:     pkmutex
// Param3:     lMutexState
//
#define AUDIO_NESTED_MUTEX_SITUATION 0x00000005
     
//
// BugCheck AD
// Param1:     AUDIO_ABSURD_ALLOCATION_ATTEMPTED
// Param2:     
// Param3:     
//
#define AUDIO_ABSURD_ALLOCATION_ATTEMPTED 0x00000006
     
//
// Used to smoke out pre-emption issues on the checked build.
//
NTSYSAPI NTSTATUS NTAPI ZwYieldExecution (VOID);

void
PagedCode(
    void
    );

#define PagedData PagedCode

void
ValidatePassiveLevel(
    void
    );

void
AudioPerformYield(
    void
    );

#define AudioEnterMutex_Exclusive(pmutex) AudioEnterMutex(pmutex,TRUE)
#define AudioEnterMutex_Nestable(pmutex)  AudioEnterMutex(pmutex,FALSE)

NTSTATUS
AudioEnterMutex(
    IN PKMUTEX pmutex,
    IN BOOL    bExclusive
    );

void
AudioLeaveMutex(
    IN PKMUTEX pmutex
    );

void
AudioObDereferenceObject(
    IN PVOID pvObject
    );

void
AudioIoCompleteRequest(
    IN PIRP  pIrp, 
    IN CCHAR PriorityBoost
    );


#if 0
void
AudioEnterSpinLock(
    IN  PKSPIN_LOCK pSpinLock,
    OUT PKIRQL      pOldIrql
    );

void
AudioLeaveSpinLock(
    IN PKSPIN_LOCK pSpinLock,
    IN KIRQL       OldIrql
    );

NTSTATUS
AudioIoCallDriver ( 
    IN PDEVICE_OBJECT pDevice,
    IN PIRP pIrp
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wvmapper\wvinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  LIBINIT.ASM
;
; library stub to do local init for a Dynamic linked library
;
; Created: 06-27-89
; Author:  Todd Laney [ToddLa]
;
; Exported Functions:   none
;
; Public Functions:     none
;
; Public Data:		none
;
; General Description:
;
; Restrictions:
;
;   This must be the first object file in the LINK line, this assures
;   that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

	.386p
	.xlist
	include cmacros.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

ifndef WEPSEG
    WEPSEG equ <_WEP>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE
createSeg %WEPSEG, WepCodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;   external functions
;
        externFP    LocalInit           ; in KERNEL
        externFP    LibMain             ; C code to do DLL init

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
%out link me first!!
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

public	g_SegTEXT

globalW     g_SegTEXT,0

sEnd        Data

	extrn	gDeviceAddress:dword

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg
	extrn	WODCOMPLETEIO:FAR

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
	mov	ax, SEG _TEXT
	mov	g_SegTEXT, ax

        cCall   LibMain
cEnd

cProc	int1,<FAR,PUBLIC,NODATA>
cBegin
	int	1
cEnd
	public	DEVICECALLBACK, OPENPIN, WRITEPIN

DeviceCallBack	proc far
	push	bp
	mov	bp, sp

	push	ds
	push	si
	push	di

	push	ds
	push	si
	call	WODCOMPLETEIO

	pop	di
	pop	si
	pop	ds

	pop	bp
	ret
DEVICECALLBACK	endp

.386p
OpenPin proc far
	push	bp
	mov	bp, sp

	push	ds
	push	fs

	push	si
	push	di

	push	ds
	pop	fs

	assume	ds:nothing, fs:DGROUP
	mov	ax, 1					; OPEN_PIN
	mov	si, [bp].6
	mov	ds, [bp].8
	call	dword ptr fs:[gDeviceAddress]

	pop	di
	pop	si

	pop	fs
	pop	ds
	pop	bp
	ret	4
OpenPin endp

WritePin proc far
	push	bp
	mov	bp, sp

	push	ds
	push	fs

	push	si
	push	di

	push	ds
	pop	fs

	assume	es:nothing, ds:nothing, fs:DGROUP

	mov	ax, 3					; WRITE_PIN
	mov	si, [bp].6
	mov	ds, [bp].8
	push	cs
	pop	es
	mov	di, offset DeviceCallBack
	call	dword ptr fs:[gDeviceAddress]

	pop	di
	pop	si

	pop	fs
	pop	ds
	pop	bp
	ret	4
WritePin endp

sEnd    CodeSeg

;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is.
;   All WEP's need to be in fixed code segments.
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;	that may cause the LoadModule() code to be reentered.
;
;-----------------------------------------------------------------------;

sBegin  WepCodeSeg
        assumes cs,WepCodeSeg
        assumes ds,nothing
        assumes es,nothing


cProc   WEP,<FAR,PUBLIC,NODATA>,<>
        ParmW  WhyIsThisParamBogusDave?
cBegin
cEnd

sEnd    WepCodeSeg

        end     LibEntry

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wdmaud.sys\wdmsys.h ===
/****************************************************************************
 *
 *   wdmsys.h
 *
 *   Function declarations, etc. for WDMAUD.SYS
 *
 *   Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
 *
 *   History
 *      5-19-97 - Noel Cross (NoelC)
 *
 ***************************************************************************/

#ifndef _WDMSYS_H_INCLUDED_
#define _WDMSYS_H_INCLUDED_

#ifdef UNDER_NT
#if DBG
#define DEBUG
#endif
#endif

#include <ntddk.h>
#include <windef.h>
#include <winerror.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>
#include <math.h>

// Make sure we will get correct multimedia structures from mmsystem.
#ifdef UNDER_NT
#ifndef _WIN32
#pragma message( "WARNING: _WIN32 not defined.  Build not valid for NT." )
#endif
#ifndef UNICODE
#pragma message( "WARNING: UNICODE not defined.  Build not valid for NT." )
#endif
#else
#pragma message( "WARNING: UNDER_NT not defined.  Build not valid for NT." )
#endif

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#include <mmddk.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <swenum.h>
#include <ksdebug.h>
#include <midi.h>
#include <wdmaud.h>
#include "mixer.h"
#include "robust.h"

#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

/***************************************************************************

 Constants

 ***************************************************************************/

#define PROFILE   // turn on to help with debugging

#define WAVE_CONTROL_VOLUME     0
#define WAVE_CONTROL_RATE       1
#define WAVE_CONTROL_QUALITY    2

#define MAX_WAVE_CONTROLS       3

#define MIDI_CONTROL_VOLUME     0

#define MAX_MIDI_CONTROLS       1

#define WILD_CARD               0xfffffffe
#define INVALID_NODE            0xffffffff

#define MAXNUMDEVS              32
#define MAXDEVNODES             100

#define STR_MODULENAME  "wdmaud.sys: "

#define STR_DEVICENAME  TEXT("\\Device\\wdmaud")
#define STR_LINKNAME    TEXT("\\DosDevices\\wdmaud")

#define STR_PNAME       TEXT("%s (%d)")

#ifdef DEBUG
#define CONTEXT_SIGNATURE     'XNOC' // CONteXt structure
#define MIXERDEVICE_SIGNATURE 'DXIM' // MIXerDevice structure 
#define MIXEROBJECT_SIGNATURE 'OXIM' // MIXerObject structure
#define HWLINK_SIGNATURE      'KLWH' //HWLINK signature
#endif

#define LIVE_CONTROL ((PMXLCONTROL)(-1))

#define INCREASE TRUE
#define DECREASE FALSE

/***************************************************************************

 structure definitions

 ***************************************************************************/

typedef struct _WDMAPENDINGIRP_QUEUE {
    LIST_ENTRY  WdmaPendingIrpListHead;
    KSPIN_LOCK  WdmaPendingIrpListSpinLock;
    IO_CSQ      Csq;
} WDMAPENDINGIRP_QUEUE, *PWDMAPENDINGIRP_QUEUE;

extern WDMAPENDINGIRP_QUEUE wdmaPendingIrpQueue;

typedef struct _WDMAPENDINGIRP_CONTEXT {
    IO_CSQ_IRP_CONTEXT IrpContext;
    ULONG IrpDeviceType;
    struct tag_WDMACONTEXT *pContext;
} WDMAPENDINGIRP_CONTEXT, *PWDMAPENDINGIRP_CONTEXT;

typedef struct tag_ALLOCATED_MDL_LIST_ITEM
{
    LIST_ENTRY              Next;
    PMDL                    pMdl;
    struct tag_WDMACONTEXT *pContext;

} ALLOCATED_MDL_LIST_ITEM , *PALLOCATED_MDL_LIST_ITEM;

//typedef struct tag_IOCTL_HISTORY_LIST_ITEM
//{
//    LIST_ENTRY              Next;
//    PIRP                    pIrp;
//    ULONG                   IoCode;
//    NTSTATUS                IoStatus;
//    struct tag_WDMACONTEXT *pContext;
//} IOCTL_HISTORY_LIST_ITEM , *PIOCTL_HISTORY_LIST_ITEM;

typedef struct device_instance
{
    PVOID           pDeviceHeader;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct _CONTROL_NODE
{
   GUID    Control;
   ULONG   NodeId;
   ULONG   Reserved;
} CONTROL_NODE, *PCONTROL_NODE;

typedef struct _CONTROLS_LIST
{
   ULONG   Count;
   ULONG   Reserved;
   CONTROL_NODE Controls[1];
} CONTROLS_LIST, *PCONTROLS_LIST;

typedef struct _WAVEPOSITION {
    DWORD               Operation;                     // Get / Set
    DWORD               BytePos;
} WAVEPOSITION, *PWAVEPOSITION, FAR *LPWAVEPOSITION;

typedef struct _DEVICEVOLUME {
    DWORD               Operation;                     // Get / Set
    DWORD               Channel;
    DWORD               Level;
} DEVICEVOLUME, *PDEVICEVOLUME, FAR *LPDEVICEVOLUME;

#define WAVE_PIN_INSTANCE_SIGNATURE ((ULONG)'SIPW') //WPIS

//
// This macro can be used with NT_SUCCESS to branch.  Effectively returns an
// NTSTATUS code.
//
#define IsValidWavePinInstance(pwpi) ((pwpi->dwSig == WAVE_PIN_INSTANCE_SIGNATURE) ? \
                                      STATUS_SUCCESS:STATUS_UNSUCCESSFUL)

//
// The Wave pin instance structure and the midi pin instance structure need to
// use a common header so that the duplicate servicing functions can be
// removed.
//
typedef struct _WAVEPININSTANCE
{
   PFILE_OBJECT             pFileObject;
   PDEVICE_OBJECT           pDeviceObject;
   struct tag_WAVEDEVICE   *pWaveDevice;

   KSPIN_LOCK               WavePinSpinLock; // For State Changes

   BOOL                     fGraphRunning;

   KSSTATE                  PinState;
   KEVENT                   StopEvent;
   KEVENT                   PauseEvent;
   volatile ULONG           NumPendingIos;
   volatile BOOL            StoppingSource;  //  Flag which indicates
                                             //  that the pin is in the
                                             //  stopping process
   volatile BOOL            PausingSource;   //  Flag which indicates
                                             //  that the pin is in the
                                             //  pausing process
   ULONG                    DeviceNumber;
   ULONG                    DataFlow;
   BOOL                     fWaveQueued;
   LPWAVEFORMATEX           lpFormat;
   DWORD                    dwFlags;

   PCONTROLS_LIST           pControlList;

   HANDLE32                 WaveHandle;
   struct _WAVEPININSTANCE  *Next;

   DWORD                    dwSig;  //Used to validate structure.
} WAVE_PIN_INSTANCE, *PWAVE_PIN_INSTANCE;

typedef struct _midiinhdr
{
    LIST_ENTRY              Next;
    LPMIDIDATA              pMidiData;
    PIRP                    pIrp;
    PMDL                    pMdl;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;
} MIDIINHDR, *PMIDIINHDR;

#define MIDI_PIN_INSTANCE_SIGNATURE ((ULONG)'SIPM') //MPIS

//
// This macro can be used with NT_SUCCESS to branch.  Effectively returns a
// NTSTATUS code.
//
#define IsValidMidiPinInstance(pmpi) ((pmpi->dwSig == MIDI_PIN_INSTANCE_SIGNATURE) ? \
                                      STATUS_SUCCESS:STATUS_UNSUCCESSFUL)

typedef struct _MIDIPININSTANCE
{
   PFILE_OBJECT             pFileObject;
   PDEVICE_OBJECT           pDeviceObject;
   struct tag_MIDIDEVICE   *pMidiDevice;

   KSPIN_LOCK               MidiPinSpinLock; // For state changes

   BOOL                     fGraphRunning;

   KSSTATE                  PinState;
   KEVENT                   StopEvent;
   ULONG                    NumPendingIos;
   volatile BOOL            StoppingSource;  //  Flag which indicates
                                             //  that the pin is in the
                                             //  stopping process

   LIST_ENTRY               MidiInQueueListHead; // for midihdrs
   KSPIN_LOCK               MidiInQueueSpinLock;
   KSEVENT                  MidiInNotify;    // for notification of new midiin data
   WORK_QUEUE_ITEM          MidiInWorkItem;

   ULONG                    DeviceNumber;
   ULONG                    DataFlow;

   PCONTROLS_LIST           pControlList;

   ULONG                    LastTimeMs;
   ULONGLONG                LastTimeNs;

   BYTE                     bCurrentStatus;

   DWORD                    dwSig;  // Used to validate structure
} MIDI_PIN_INSTANCE, *PMIDI_PIN_INSTANCE;

#define STREAM_HEADER_EX_SIGNATURE ((ULONG)'XEHS') //SHEX

//
// This macro can be used with NT_SUCCESS to branch.  Effectively returns a
// NTSTATUS code.
//
#define IsValidStreamHeaderEx(pshex) ((pshex->dwSig == STREAM_HEADER_EX_SIGNATURE) ? \
                                      STATUS_SUCCESS:STATUS_UNSUCCESSFUL)

typedef struct _STREAM_HEADER_EX
{
    KSSTREAM_HEADER     Header;
    IO_STATUS_BLOCK     IoStatus;
    union
    {
        PDWORD          pdwBytesRecorded;
        PWAVEHDR        pWaveHdr;
        PMIDIHDR        pMidiHdr;
    };
    union
    {
        PWAVE_PIN_INSTANCE  pWavePin;
        PMIDI_PIN_INSTANCE  pMidiPin;
    };
    PIRP                    pIrp;
    PWAVEHDR                pWaveHdrAligned;
    PMDL                    pHeaderMdl;
    PMDL                    pBufferMdl;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

    DWORD                   dwSig; //Used To validate structure.
} STREAM_HEADER_EX, *PSTREAM_HEADER_EX;

//
// make sure that this structure doesn't exceed the size of
// the midihdr, otherwise the write_context defintion in
// vxd.asm needs to be updated.
//
typedef struct _wavehdrex
{
    WAVEHDR             wh;
    PWAVE_PIN_INSTANCE  pWaveInstance;
} WAVEINSTANCEHDR, *PWAVEINSTANCEHDR;

#define WRITE_CONTEXT_SIGNATURE ((ULONG)'GSCW') //WCSG

//
// This macro can be used with NT_SUCCESS to branch.  Effectively returns a
// NTSTATUS code.
//
#define IsValidWriteContext(pwc) ((pwc->dwSig == WRITE_CONTEXT_SIGNATURE) ? \
                                      STATUS_SUCCESS:STATUS_UNSUCCESSFUL)
typedef struct write_context
{
    union
    {
        WAVEINSTANCEHDR     whInstance;
        MIDIHDR             mh;
    };
    DWORD                   ClientContext;
    DWORD                   ClientContext2;
    WORD                    CallbackOffset;
    WORD                    CallbackSegment;
    DWORD                   ClientThread;
    union
    {
        LPWAVEHDR           WaveHeaderLinearAddress;
        LPMIDIHDR           MidiHeaderLinearAddress;
    };
    PVOID                   pCapturedWaveHdr;
    PMDL                    pBufferMdl;
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext;

    DWORD                   dwSig; // Used to validate structure.
} WRITE_CONTEXT, *PWRITE_CONTEXT;

typedef struct tag_IDENTIFIERS
{
    KSMULTIPLE_ITEM;
    KSIDENTIFIER aIdentifiers[1];       // Array of identifiers
} IDENTIFIERS, *PIDENTIFIERS;

typedef struct tag_DATARANGES
{
    KSMULTIPLE_ITEM;
    KSDATARANGE aDataRanges[1];
} DATARANGES, *PDATARANGES;

typedef struct tag_KSPROPERTYPLUS
{
    KSPROPERTY Property;
    ULONG      DeviceIndex;
} KSPROPERTYPLUS, *PKSPROPERTYPLUS;

//
// COMMONDEVICE
//      DeviceInterface - the buffer for this string is allocated for all
//              classes except mixer.  For mixer, it is a pointer to a buffer
//              allocated for one of the wave classes.
//
typedef struct tag_COMMONDEVICE
{
    ULONG                  Device;
    ULONG                  PinId;
    PWSTR                  DeviceInterface;
    PWSTR                  pwstrName;
    ULONG                  PreferredDevice;
    struct tag_WDMACONTEXT *pWdmaContext;
    PKSCOMPONENTID         ComponentId;
} COMMONDEVICE, *PCOMMONDEVICE;

typedef struct tag_WAVEDEVICE
{
    COMMONDEVICE;
    PDATARANGES         AudioDataRanges;
    PWAVE_PIN_INSTANCE  pWavePin;
    DWORD               LeftVolume;      // only used for output
    DWORD               RightVolume;     // only used for output
    DWORD               dwVolumeID;      // only used for output
    DWORD               cChannels;       // only used for output
    PKTIMER             pTimer;          // only used for output
    PKDPC               pDpc;            // only used for output
    BOOL                fNeedToSetVol;   // only used for output
} WAVEDEVICE, *PWAVEDEVICE;

typedef struct tag_MIDIDEVICE
{
    COMMONDEVICE;
    PDATARANGES         MusicDataRanges;
    PMIDI_PIN_INSTANCE  pMidiPin;
    DWORD               dwVolumeID;     // only used for output
    DWORD               cChannels;      // only used for output
} MIDIDEVICE, *PMIDIDEVICE;

typedef struct tag_MIXERDEVICE
{
    COMMONDEVICE;
    ULONG               cDestinations;  // The no. of destinations on device
    LINELIST            listLines;      // The list of all lines on the dev.
    KSTOPOLOGY          Topology;       // The topology
    ULONG               Mapping;        // Mapping algorithm for this device
    PFILE_OBJECT        pfo;            // used for talking to SysAudio
#ifdef DEBUG
    DWORD               dwSig;
#endif
} MIXERDEVICE, *PMIXERDEVICE;

typedef struct tag_AUXDEVICE
{
    COMMONDEVICE;
    DWORD               dwVolumeID;
    DWORD               cChannels;
} AUXDEVICE, *PAUXDEVICE;

typedef struct tag_DEVNODE_LIST_ITEM
{
    LIST_ENTRY Next;
    LONG cReference;                    // Number of device classes init'ed
    LPWSTR DeviceInterface;
    ULONG cDevices[MAX_DEVICE_CLASS];   // Count of devices for each class
    BOOLEAN fAdded[MAX_DEVICE_CLASS];
} DEVNODE_LIST_ITEM, *PDEVNODE_LIST_ITEM;

typedef struct tag_WORK_LIST_ITEM
{
    LIST_ENTRY Next;
    VOID (*Function)(
        PVOID Reference1,
        PVOID Reference2
    );
    PVOID Reference1;
    PVOID Reference2;
} WORK_LIST_ITEM, *PWORK_LIST_ITEM;


extern KMUTEX          wdmaMutex;


typedef struct tag_WDMACONTEXT
{
    LIST_ENTRY      Next;
    BOOL            fInList;

    BOOL            fInitializeSysaudio;
    KEVENT          InitializedSysaudioEvent;
    PFILE_OBJECT    pFileObjectSysaudio;
    KSEVENTDATA     EventData;

    ULONG VirtualWavePinId;
    ULONG VirtualMidiPinId;
    ULONG VirtualCDPinId;

    ULONG PreferredSysaudioWaveDevice;

    ULONG           DevNodeListCount;
    LIST_ENTRY      DevNodeListHead;
    PVOID           NotificationEntry;

    WORK_QUEUE_ITEM WorkListWorkItem;
    LIST_ENTRY      WorkListHead;
    KSPIN_LOCK      WorkListSpinLock;
    LONG            cPendingWorkList;

    WORK_QUEUE_ITEM SysaudioWorkItem;

    PKSWORKER       WorkListWorkerObject;
    PKSWORKER       SysaudioWorkerObject;

    WAVEDEVICE      WaveOutDevs[MAXNUMDEVS];
    WAVEDEVICE      WaveInDevs[MAXNUMDEVS];
    MIDIDEVICE      MidiOutDevs[MAXNUMDEVS];
    MIDIDEVICE      MidiInDevs[MAXNUMDEVS];
    MIXERDEVICE     MixerDevs[MAXNUMDEVS];
    AUXDEVICE       AuxDevs[MAXNUMDEVS];

    PCOMMONDEVICE   apCommonDevice[MAX_DEVICE_CLASS][MAXNUMDEVS];
#ifdef DEBUG
    DWORD           dwSig;
#endif

} WDMACONTEXT, *PWDMACONTEXT;

#ifdef WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

// This include needs to be here since it needs some of the declarations
// above

#include "kmxluser.h"

typedef WORD        VERSION;    /* major (high byte), minor (low byte) */

typedef struct waveoutcaps16_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    WORD    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS16, *PWAVEOUTCAPS16;

typedef struct waveincaps16_tag {
    WORD    wMid;                    /* manufacturer ID */
    WORD    wPid;                    /* product ID */
    WORD    vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    WORD    wChannels;               /* number of channels supported */
} WAVEINCAPS16, *PWAVEINCAPS16;

typedef struct midioutcaps16_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    WORD    wVoices;               /* # of voices (internal synth only) */
    WORD    wNotes;                /* max # of notes (internal synth only) */
    WORD    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS16, *PMIDIOUTCAPS16;

typedef struct midiincaps16_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
#if (WINVER >= 0x0400)
    DWORD   dwSupport;             /* functionality supported by driver */
#endif
} MIDIINCAPS16, *PMIDIINCAPS16;

typedef struct mixercaps16_tag {
    WORD    wMid;                  /* manufacturer id */
    WORD    wPid;                  /* product id */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name */
    DWORD   fdwSupport;            /* misc. support bits */
    DWORD   cDestinations;         /* count of destinations */
} MIXERCAPS16, *PMIXERCAPS16;

typedef struct auxcaps16_tag {
    WORD    wMid;                  /* manufacturer ID */
    WORD    wPid;                  /* product ID */
    WORD    vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    WORD    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS16, *PAUXCAPS16;

typedef struct wavehdr_tag32 {
    UINT32      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    UINT32      dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    UINT32      lpNext;                 /* reserved for driver */
    UINT32      reserved;               /* reserved for driver */
} WAVEHDR32, *PWAVEHDR32, NEAR *NPWAVEHDR32, FAR *LPWAVEHDR32;

/* MIDI data block header */
typedef struct midihdr_tag32 {
    UINT32      lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    UINT32      dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    UINT32      lpNext;               /* reserved for driver */
    UINT32      reserved;             /* reserved for driver */
#if (WINVER >= 0x0400)
    DWORD       dwOffset;             /* Callback offset into buffer */
    UINT32      dwReserved[8];        /* Reserved for MMSYSTEM */
#endif
} MIDIHDR32, *PMIDIHDR32, NEAR *NPMIDIHDR32, FAR *LPMIDIHDR32;

typedef struct tagMIXERLINEA32 {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    UINT32      dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    CHAR        szShortName[MIXER_SHORT_NAME_CHARS];
    CHAR        szName[MIXER_LONG_NAME_CHARS];
    struct {
        DWORD       dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
        DWORD       dwDeviceID;             /* target device ID of device type */
        WORD        wMid;                   /* of target device */
        WORD        wPid;                   /*      " */
        MMVERSION   vDriverVersion;         /*      " */
        CHAR        szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEA32, *PMIXERLINEA32, *LPMIXERLINEA32;
typedef struct tagMIXERLINEW32 {
    DWORD       cbStruct;               /* size of MIXERLINE structure */
    DWORD       dwDestination;          /* zero based destination index */
    DWORD       dwSource;               /* zero based source index (if source) */
    DWORD       dwLineID;               /* unique line id for mixer device */
    DWORD       fdwLine;                /* state/information about line */
    UINT32      dwUser;                 /* driver specific information */
    DWORD       dwComponentType;        /* component type line connects to */
    DWORD       cChannels;              /* number of channels line supports */
    DWORD       cConnections;           /* number of connections [possible] */
    DWORD       cControls;              /* number of controls at this line */
    WCHAR       szShortName[MIXER_SHORT_NAME_CHARS];
    WCHAR       szName[MIXER_LONG_NAME_CHARS];
    struct {
        DWORD       dwType;                 /* MIXERLINE_TARGETTYPE_xxxx */
        DWORD       dwDeviceID;             /* target device ID of device type */
        WORD        wMid;                   /* of target device */
        WORD        wPid;                   /*      " */
        MMVERSION   vDriverVersion;         /*      " */
        WCHAR       szPname[MAXPNAMELEN];   /*      " */
    } Target;
} MIXERLINEW32, *PMIXERLINEW32, *LPMIXERLINEW32;
#ifdef UNICODE
typedef MIXERLINEW32 MIXERLINE32;
typedef PMIXERLINEW32 PMIXERLINE32;
typedef LPMIXERLINEW32 LPMIXERLINE32;
#else
typedef MIXERLINEA32 MIXERLINE32;
typedef PMIXERLINEA32 PMIXERLINE32;
typedef LPMIXERLINEA32 LPMIXERLINE32;
#endif // UNICODE

typedef struct tagMIXERLINECONTROLSA32 {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
        DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
        DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    UINT32          pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSA32, *PMIXERLINECONTROLSA32, *LPMIXERLINECONTROLSA32;
typedef struct tagMIXERLINECONTROLSW32 {
    DWORD           cbStruct;       /* size in bytes of MIXERLINECONTROLS */
    DWORD           dwLineID;       /* line id (from MIXERLINE.dwLineID) */
    union {
        DWORD       dwControlID;    /* MIXER_GETLINECONTROLSF_ONEBYID */
        DWORD       dwControlType;  /* MIXER_GETLINECONTROLSF_ONEBYTYPE */
    };
    DWORD           cControls;      /* count of controls pmxctrl points to */
    DWORD           cbmxctrl;       /* size in bytes of _one_ MIXERCONTROL */
    UINT32          pamxctrl;       /* pointer to first MIXERCONTROL array */
} MIXERLINECONTROLSW32, *PMIXERLINECONTROLSW32, *LPMIXERLINECONTROLSW32;
#ifdef UNICODE
typedef MIXERLINECONTROLSW32 MIXERLINECONTROLS32;
typedef PMIXERLINECONTROLSW32 PMIXERLINECONTROLS32;
typedef LPMIXERLINECONTROLSW32 LPMIXERLINECONTROLS32;
#else
typedef MIXERLINECONTROLSA32 MIXERLINECONTROLS32;
typedef PMIXERLINECONTROLSA32 PMIXERLINECONTROLS32;
typedef LPMIXERLINECONTROLSA32 LPMIXERLINECONTROLS32;
#endif // UNICODE

typedef struct tMIXERCONTROLDETAILS32 {
    DWORD           cbStruct;       /* size in bytes of MIXERCONTROLDETAILS */
    DWORD           dwControlID;    /* control id to get/set details on */
    DWORD           cChannels;      /* number of channels in paDetails array */
    union {
        UINT32      hwndOwner;      /* for MIXER_SETCONTROLDETAILSF_CUSTOM */
        DWORD       cMultipleItems; /* if _MULTIPLE, the number of items per channel */
    };
    DWORD           cbDetails;      /* size of _one_ details_XX struct */
    UINT32          paDetails;      /* pointer to array of details_XX structs */
} MIXERCONTROLDETAILS32, *PMIXERCONTROLDETAILS32, FAR *LPMIXERCONTROLDETAILS32;

#ifdef WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above wavehdr_tag32 structure up with the wavehdr_tag structure in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the wavehdr_tag32 typedefs in the
// wdmaud.sys directory.

struct wave_header_structures_are_in_sync {
char x[(sizeof (WAVEHDR32) == sizeof (WAVEHDR)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above midihdr_tag32 structure up with the midihdr_tag structure in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the midihdr_tag32 typedefs in the
// wdmaud.sys directory.

struct midi_header_structures_are_in_sync {
char x[(sizeof (MIDIHDR32) == sizeof (MIDIHDR)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above two tagMIXERLINEX32 structures up with the tagMIXERLINEX structures in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the MIXERLINE32 typedefs in the
// wdmaud.sys directory.

struct mixer_line_structures_are_in_sync {
char x[(sizeof (MIXERLINE32) == sizeof (MIXERLINE)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above two tagMIXERLINECONTROLSX32 structures up with the tagMIXERLINECONTROLSX structures in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the MIXERLINECONTROLS32 typedefs in the
// wdmaud.sys directory.

struct mixer_line_control_structures_are_in_sync {
char x[(sizeof (MIXERLINECONTROLS32) == sizeof (MIXERLINECONTROLS)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif

#ifndef _WIN64
// WARNING WARNING WARNING!!!!
// If the below lines do not compile for 32 bit x86, you MUST sync the
// above tMIXERCONTROLDETAILS32 structure up with the tMIXERCONTROLDETAILS32 structure in
// mmsystem.w!  It doesn't compile because someone changed mmsystem.w
// without changing the above structure.
// Make SURE when you sync it up that you use UINT32 for all elements
// that are normally 64bits on win64.
// You MUST also update all places that thunk the above structure!
// Look for all occurances of any of the MIXERCONTROLDETAILS32 typedefs in the
// wdmaud.sys directory.

struct mixer_control_details_structures_are_in_sync {
char x[(sizeof (MIXERCONTROLDETAILS32) == sizeof (MIXERCONTROLDETAILS)) ? 1 : -1];
};

// WARNING WARNING WARNING!!!
// If above lines do not compile, see comment above and FIX!
// DO NOT COMMENT OUT THE LINES THAT DON'T COMPILE
#endif


/***************************************************************************

  Local prototypes

 ***************************************************************************/

//
//  Device.c
//
NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT       DriverObject,
    IN PUNICODE_STRING      usRegistryPathName
);

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
);

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
);

VOID
PnpDriverUnload(
    IN PDRIVER_OBJECT DriverObject
);

//
// Ioctl.c
//
#ifdef PROFILE
VOID WdmaInitProfile();
VOID WdmaCleanupProfile();


NTSTATUS 
AddMdlToList(
    PMDL            pMdl,
    PWDMACONTEXT    pWdmaContext
);

NTSTATUS 
RemoveMdlFromList(
    PMDL            pMdl
);

#else

#define WdmaInitProfile()
#define AddMdlToList(pMdl,pWdmaContext)
#define RemoveMdlFromList(pMdl)

#endif

extern LIST_ENTRY   WdmaPendingIrpListHead;
extern KSPIN_LOCK   WdmaPendingIrpListSpinLock;

VOID 
WdmaCsqInsertIrp(
    IN struct _IO_CSQ   *pCsq,
    IN PIRP              Irp
);

VOID 
WdmaCsqRemoveIrp(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
);

PIRP 
WdmaCsqPeekNextIrp(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
);

VOID 
WdmaCsqAcquireLock(
    IN  PIO_CSQ Csq,
    OUT PKIRQL  Irql
);

VOID 
WdmaCsqReleaseLock(
    IN PIO_CSQ Csq,
    IN KIRQL   Irql
);

VOID 
WdmaCsqCompleteCanceledIrp(
    IN  PIO_CSQ             pCsq,
    IN  PIRP                Irp
);

NTSTATUS 
AddIrpToPendingList(
    PIRP                    pIrp,
    ULONG                   IrpDeviceType,
    PWDMACONTEXT            pWdmaContext,
    PWDMAPENDINGIRP_CONTEXT *ppPendingIrpContext
);

NTSTATUS 
RemoveIrpFromPendingList(
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext
);

VOID 
wdmaudMapBuffer(
    PIRP            pIrp,
    PVOID           DataBuffer,
    DWORD           DataBufferSize,
    PVOID           *pMappedBuffer,
    PMDL            *ppMdl,
    PWDMACONTEXT    pContext,
    BOOL            bWrite
);

VOID 
wdmaudUnmapBuffer(
    PMDL            pMdl
);

NTSTATUS 
CaptureBufferToLocalPool(
    PVOID           DataBuffer,
    DWORD           DataBufferSize,
    PVOID           *ppMappedBuffer
#ifdef _WIN64
    ,DWORD          ThunkBufferSize
#endif
);

NTSTATUS 
CopyAndFreeCapturedBuffer(
    PVOID           DataBuffer,
    DWORD           DataBufferSize,
    PVOID           *ppMappedBuffer
);

NTSTATUS
SoundDispatchCreate(
   IN  PDEVICE_OBJECT pDO,
   IN  PIRP           pIrp
);

NTSTATUS
SoundDispatchClose(
   IN  PDEVICE_OBJECT pDO,
   IN  PIRP           pIrp
);

NTSTATUS
SoundDispatch(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP           pIrp
);

NTSTATUS
SoundDispatchCleanup(
    IN  PDEVICE_OBJECT pDO,
    IN  PIRP           pIrp
);

//
// wave.c
//
NTSTATUS 
OpenWavePin(
    PWDMACONTEXT        pWdmaContext,
    ULONG               DeviceNumber,
    LPWAVEFORMATEX      lpFormat,
    HANDLE32            DeviceHandle,
    DWORD               dwFlags,
    ULONG               DataFlow // DataFlow is either in or out.
);

VOID
CloseTheWavePin(
    PWAVEDEVICE pWaveDev,
    HANDLE32    DeviceHandle
);

VOID 
CloseWavePin(
   PWAVE_PIN_INSTANCE pWavePin
);

NTSTATUS 
wqWriteWaveCallBack(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    IN PWAVEHDR     pWriteData
);

NTSTATUS 
ssWriteWaveCallBack(
    PDEVICE_OBJECT       pDeviceObject,
    PIRP                 pIrp,
    IN PSTREAM_HEADER_EX pStreamHeaderEx
);

NTSTATUS 
WriteWaveOutPin(
    PWAVEDEVICE         pWaveOutDevice,
    HANDLE32            DeviceHandle,
    LPWAVEHDR           pWriteData,
    PSTREAM_HEADER_EX   pStreamHeader,
    PIRP                pUserIrp,
    PWDMACONTEXT        pContext,
    BOOL               *pCompletedIrp
);

NTSTATUS 
IoWavePin(
    PWAVE_PIN_INSTANCE  pWavePin,
    ULONG               Operation,
    PWRITE_CONTEXT      pWriteContext,
    ULONG               Size,
    PVOID               RefData,
    PVOID               CallBack
);

NTSTATUS 
PosWavePin(
    PWAVEDEVICE     pWaveDevice,
    HANDLE32        DeviceHandle,
    PWAVEPOSITION   pWavePos
);

NTSTATUS 
BreakLoopWaveOutPin(
    PWAVEDEVICE pWaveOutDevice,
    HANDLE32    DeviceHandle
);

NTSTATUS 
VolumeWaveOutPin(
    ULONG           DeviceNumber,
    HANDLE32        DeviceHandle,
    PDEVICEVOLUME   pWaveVolume
);

NTSTATUS 
VolumeWaveInPin(
    ULONG           DeviceNumber,
    PDEVICEVOLUME   pWaveVolume
);

NTSTATUS 
VolumeWavePin(
    PWAVE_PIN_INSTANCE    pWavePin,
    PDEVICEVOLUME         pWaveVolume
);
NTSTATUS 
ResetWaveOutPin(
    PWAVEDEVICE pWaveOutDevice,
    HANDLE32    DeviceHandle
);

NTSTATUS 
ResetWavePin(
    PWAVE_PIN_INSTANCE pWavePin,
    KSRESET            *pResetValue
);

NTSTATUS 
StateWavePin(
    PWAVEDEVICE pWaveInDevice,
    HANDLE32    DeviceHandle,
    KSSTATE     State
);


NTSTATUS 
ReadWaveCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
);

NTSTATUS 
ReadWaveInPin(
    PWAVEDEVICE         pWaveInDevice,
    HANDLE32            DeviceHandle,
    PSTREAM_HEADER_EX   pStreamHeader,
    PIRP                pUserIrp,
    PWDMACONTEXT        pContext,
    BOOL               *pCompletedIrp
);

ULONG
FindMixerForDevNode(
    IN PMIXERDEVICE paMixerDevice,
    IN PCWSTR DeviceInterface
);

NTSTATUS
FindVolumeControl(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface,
    IN DWORD DeviceType
);

NTSTATUS
IsVolumeControl(
    IN PWDMACONTEXT pWdmaContext,
    IN PCWSTR DeviceInterface,
    IN DWORD dwComponentType,
    IN PDWORD pdwControlID,
    IN PDWORD pcChannels
);

NTSTATUS
SetVolume(
    IN PWDMACONTEXT pWdmaContext,
    IN DWORD DeviceNumber,
    IN DWORD DeviceType,
    IN DWORD LeftChannel,
    IN DWORD RightChannel
);

NTSTATUS
GetVolume(
    IN  PWDMACONTEXT pWdmaContext,
    IN  DWORD  DeviceNumber,
    IN  DWORD  DeviceType,
    OUT PDWORD LeftChannel,
    OUT PDWORD RightChannel
);

VOID 
CleanupWavePins(
    IN PWAVEDEVICE pWaveDevice
);

VOID 
CleanupWaveDevices(
    PWDMACONTEXT pWdmaContext
);

NTSTATUS 
wdmaudPrepareIrp(
    PIRP                    pIrp,
    ULONG                   IrpDeviceType,
    PWDMACONTEXT            pWdmaContext,
    PWDMAPENDINGIRP_CONTEXT *ppPendingIrpContext
);

NTSTATUS 
wdmaudUnprepareIrp(
    PIRP                    pIrp,
    NTSTATUS                IrpStatus,
    ULONG_PTR               Information,
    PWDMAPENDINGIRP_CONTEXT pPendingIrpContext
);

//
// midi.c
//

NTSTATUS 
OpenMidiPin(
    PWDMACONTEXT        pWdmaContext,
    ULONG               DeviceNumber,
    ULONG               DataFlow      //DataFlow is either in or out.
);


VOID 
CloseMidiDevicePin(
    PMIDIDEVICE pMidiDevice
);


VOID 
CloseMidiPin(
    PMIDI_PIN_INSTANCE  pMidiPin
);

NTSTATUS 
WriteMidiEventCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
);

NTSTATUS 
WriteMidiEventPin(
    PMIDIDEVICE pMidiOutDevice,
    ULONG       ulEvent
);

NTSTATUS 
WriteMidiCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
);

NTSTATUS 
WriteMidiOutPin(
    LPMIDIHDR           pMidiHdr,
    PSTREAM_HEADER_EX   pStreamHeader,
    BOOL               *pCompletedIrp
);

ULONGLONG 
GetCurrentMidiTime(
    VOID
);


NTSTATUS 
ResetMidiInPin(
    PMIDI_PIN_INSTANCE pMidiPin
);

NTSTATUS 
StateMidiOutPin(
    PMIDI_PIN_INSTANCE pMidiPin,
    KSSTATE     State
);

NTSTATUS 
StateMidiInPin(
    PMIDI_PIN_INSTANCE pMidiPin,
    KSSTATE     State
);


NTSTATUS 
ReadMidiCallBack(
    PDEVICE_OBJECT          pDeviceObject,
    PIRP                    pIrp,
    IN PSTREAM_HEADER_EX    pStreamHeader
);

VOID 
ReadMidiEventWorkItem(
    PSTREAM_HEADER_EX   pStreamHeader,
    PVOID               NotUsed
);

NTSTATUS 
ReadMidiPin(
    PMIDI_PIN_INSTANCE  pMidiPin
);

NTSTATUS 
AddBufferToMidiInQueue(
    PMIDI_PIN_INSTANCE  pMidiPin,
    PMIDIINHDR          pNewMidiInHdr
);

VOID 
CleanupMidiDevices(
    PWDMACONTEXT pWdmaContext
    );


// from NTKERN
NTSYSAPI NTSTATUS NTAPI NtClose
(
    IN HANDLE Handle
);

//
// sysaudio.c
//
/*
NTSTATUS 
AllocMem(
    POOL_TYPE   PoolType,
    PVOID       *pp,
    ULONG       size,
    ULONG       ultag
);

VOID 
FreeMem(
    PVOID       *pp
);
*/
NTSTATUS 
OpenSysAudioPin(
    ULONG           Device,
    ULONG           PinId,
    KSPIN_DATAFLOW  DataFlowRequested,
    PKSPIN_CONNECT  pPinConnect,
    PFILE_OBJECT    *ppFileObjectPin,
    PDEVICE_OBJECT  *ppDeviceObjectPin,
    PCONTROLS_LIST  pControlList
);

VOID 
CloseSysAudio(
    PWDMACONTEXT pWdmaContext,
    PFILE_OBJECT pFileObjectPin
);

NTSTATUS 
OpenSysAudio(
    PHANDLE pHandle,
    PFILE_OBJECT *ppFileObject
);

NTSTATUS 
OpenDevice(
    IN PWSTR    pwstrDevice,
    OUT PHANDLE pHandle
);

NTSTATUS 
GetPinProperty(
    PFILE_OBJECT    pFileObject,
    ULONG           PropertyId,
    ULONG           PinId,
    ULONG           cbProperty,
    PVOID           pProperty
);

NTSTATUS 
GetPinPropertyEx(
    PFILE_OBJECT    pFileObject,
    ULONG           PropertyId,
    ULONG           PinId,
    PVOID           *ppProperty
);

VOID 
GetControlNodes(
   PFILE_OBJECT   pDeviceFileObject,
   PFILE_OBJECT   pPinFileObject,
   ULONG          PinId,
   PCONTROLS_LIST pControlList
);

ULONG 
ControlNodeFromGuid(
   PFILE_OBJECT  pDeviceFileObject,
   PFILE_OBJECT  pPinFileObject,
   ULONG         PinId,
   GUID*         NodeType
);

PVOID 
GetTopologyProperty(
   PFILE_OBJECT  pDeviceFileObject,
   ULONG         PropertyId
);

PKSTOPOLOGY_CONNECTION 
FindConnection(
   PKSTOPOLOGY_CONNECTION pConnections,
   ULONG                  NumConnections,
   ULONG                  FromNode,
   ULONG                  FromPin,
   ULONG                  ToNode,
   ULONG                  ToPin
);

ULONG 
GetFirstConnectionIndex(
   PFILE_OBJECT pPinFileObject
);

VOID 
UpdatePreferredDevice(
    PWDMACONTEXT pWdmaContext
);

NTSTATUS 
SetPreferredDevice(
    PWDMACONTEXT pContext,
    LPDEVICEINFO pDeviceInfo
);

NTSTATUS 
GetSysAudioProperty(
    PFILE_OBJECT pFileObject,
    ULONG        PropertyId,
    ULONG        DeviceIndex,
    ULONG        cbProperty,
    PVOID        pProperty
);

NTSTATUS 
SetSysAudioProperty(
    PFILE_OBJECT pFileObject,
    ULONG        PropertyId,
    ULONG        cbProperty,
    PVOID        pProperty
);

WORD 
GetMidiTechnology(
    PKSDATARANGE_MUSIC   MusicDataRange
);

DWORD 
GetFormats(
    PKSDATARANGE_AUDIO   AudioDataRange
);

NTSTATUS 
wdmaudGetDevCaps(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    DWORD        DeviceNumber,
    LPBYTE       lpCaps,
    DWORD        dwSize
);

NTSTATUS 
wdmaudGetNumDevs(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    LPCTSTR      DeviceInterface,
    LPDWORD      lpNumberOfDevices
);

BOOL 
IsEqualInterface(
    PKSPIN_INTERFACE    pInterface1,
    PKSPIN_INTERFACE    pInterface2
);

DWORD 
wdmaudTranslateDeviceNumber(
    PWDMACONTEXT pWdmaContext,
    DWORD        DeviceType,
    PCWSTR       DeviceInterface,
    DWORD        DeviceNumber
);

NTSTATUS 
AddDevice(
    PWDMACONTEXT    pWdmaContext,
    ULONG           Device,
    DWORD           DeviceType,
    PCWSTR          DeviceInterface,
    ULONG           PinId,
    PWSTR           pwstrName,
    BOOL            fUsePreferred,
    PDATARANGES     pDataRange,
    PKSCOMPONENTID  ComponentId
);

NTSTATUS 
PinProperty(
    PFILE_OBJECT        pFileObject,
    const GUID          *pPropertySet,
    ULONG               ulPropertyId,
    ULONG               ulFlags,
    ULONG               cbProperty,
    PVOID               pProperty
);

NTSTATUS 
PinMethod(
    PFILE_OBJECT        pFileObject,
    const GUID          *pMethodSet,
    ULONG               ulMethodId,
    ULONG               ulFlags,
    ULONG               cbMethod,
    PVOID               pMethod
);

VOID
CopyAnsiStringtoUnicodeString(
    LPWSTR lpwstr,
    LPCSTR lpstr,
    int len
);

VOID
CopyUnicodeStringtoAnsiString(
    LPSTR lpstr,
    LPCWSTR lpwstr,
    int len
);

NTSTATUS
AttachVirtualSource(
    PFILE_OBJECT pFileObject,
    ULONG ulPinId
);

NTSTATUS
SysAudioPnPNotification(
    IN PVOID NotificationStructure,
    IN PVOID Context
);

NTSTATUS
InitializeSysaudio(
    PVOID Reference1,
    PVOID Reference2
);

VOID
UninitializeSysaudio(
);

NTSTATUS
AddDevNode(
    PWDMACONTEXT pWdmaContext,
    PCWSTR       DeviceInterface,
    UINT         DeviceType
);

VOID
RemoveDevNode(
    PWDMACONTEXT pWdmaContext,
    PCWSTR       DeviceInterface,
    UINT         DeviceType
);

NTSTATUS
ProcessDevNodeListItem(
    PWDMACONTEXT pWdmaContext,
    PDEVNODE_LIST_ITEM pDevNodeListItem,
    ULONG DeviceType
);

VOID
SysaudioAddRemove(
    PWDMACONTEXT pWdmaContext
);

NTSTATUS
QueueWorkList(
    PWDMACONTEXT pWdmaContext,
    VOID (*Function)(
        PVOID Reference1,
        PVOID Reference2
    ),
    PVOID Reference1,
    PVOID Reference2
);

VOID
WorkListWorker(
    PVOID pReference
);

NTSTATUS 
AddFsContextToList(
    PWDMACONTEXT pWdmaContext
    );

NTSTATUS 
RemoveFsContextFromList(
    PWDMACONTEXT pWdmaContext
    );

typedef NTSTATUS (FNCONTEXTCALLBACK)(PWDMACONTEXT pContext,PVOID pvoidRefData,PVOID pvoidRefData2);

NTSTATUS
HasMixerBeenInitialized(
    PWDMACONTEXT pContext,
    PVOID pvoidRefData,
    PVOID pvoidRefData2
    );

NTSTATUS
EnumFsContext(
    FNCONTEXTCALLBACK fnCallback,
    PVOID pvoidRefData,
    PVOID pvoidRefData2
    );

VOID 
WdmaContextCleanup(
    PWDMACONTEXT pWdmaContext
    );

VOID
WdmaGrabMutex(
    PWDMACONTEXT pWdmaContext
);

VOID
WdmaReleaseMutex(
    PWDMACONTEXT pWdmaContext
);


int 
MyWcsicmp(
    const wchar_t *, 
    const wchar_t *
    );

void
LockedWaveIoCount(
    PWAVE_PIN_INSTANCE  pCurWavePin,
    BOOL bIncrease
    );

void
LockedMidiIoCount(
    PMIDI_PIN_INSTANCE  pCurMidiPin,
    BOOL bIncrease
    );

void
MidiCompleteIo(
    PMIDI_PIN_INSTANCE pMidiPin,
    BOOL Yield
    );

NTSTATUS 
StatePin(
    IN PFILE_OBJECT pFileObject,
    IN KSSTATE      State,
    OUT PKSSTATE    pResultingState
);

//==========================================================================
//
// In order to better track memory allocations, if you include the following
// all memory allocations will be tagged.  
//
//==========================================================================

//
// For memory allocation routines we need some memory tags.  Well, here they
// are.
//
#define TAG_AudD_DEVICEINFO ((ULONG)'DduA') 
#define TAG_AudC_CONTROL    ((ULONG)'CduA') 
#define TAG_AudE_EVENT      ((ULONG)'EduA')
#define TAG_AuDF_HARDWAREEVENT ((ULONG)'FDuA')
#define TAG_AudL_LINE       ((ULONG)'LduA')

#define TAG_AuDA_CHANNEL    ((ULONG)'ADuA')
#define TAG_AuDB_CHANNEL    ((ULONG)'BDuA')
#define TAG_AuDC_CHANNEL    ((ULONG)'CDuA')
#define TAG_AuDD_CHANNEL    ((ULONG)'DDuA')
#define TAG_AuDE_CHANNEL    ((ULONG)'EDuA')


#define TAG_AudS_SUPERMIX   ((ULONG)'SduA')
#define TAG_Audl_MIXLEVEL   ((ULONG)'lduA')
#define TAG_AudN_NODE       ((ULONG)'NduA')
#define TAG_Audn_PEERNODE   ((ULONG)'nduA')

//#define TAG_AudP_PROPERTY   ((ULONG)'PduA')
#define TAG_AudQ_PROPERTY    ((ULONG)'QduA')
#define TAG_Audq_PROPERTY    ((ULONG)'qduA')
#define TAG_AudV_PROPERTY    ((ULONG)'VduA')
#define TAG_Audv_PROPERTY    ((ULONG)'vduA')
#define TAG_AudU_PROPERTY    ((ULONG)'UduA')
#define TAG_Audu_PROPERTY    ((ULONG)'uduA')
#define TAG_Auda_PROPERTY    ((ULONG)'aduA')
#define TAG_AudA_PROPERTY    ((ULONG)'AduA')

#define TAG_Audp_NAME       ((ULONG)'pduA')
#define TAG_AudG_GETMUXLINE ((ULONG)'GduA')
#define TAG_AudI_INSTANCE   ((ULONG)'IduA')
#define TAG_Audd_DETAILS    ((ULONG)'dduA')
#define TAG_Audi_PIN        ((ULONG)'iduA')
#define TAG_Audt_CONNECT    ((ULONG)'tduA')
#define TAG_Audh_STREAMHEADER ((ULONG)'hduA')
#define TAG_Audm_MUSIC      ((ULONG)'mduA')
#define TAG_Audx_CONTEXT    ((ULONG)'xduA')
#define TAG_AudT_TIMER      ((ULONG)'TduA')
#define TAG_AudF_FORMAT     ((ULONG)'FduA')
#define TAG_AudM_MDL        ((ULONG)'MduA')
#define TAG_AudR_IRP        ((ULONG)'RduA')
#define TAG_AudB_BUFFER     ((ULONG)'BduA')
#define TAG_Aude_MIDIHEADER ((ULONG)'eduA')

#define TAG_AuDN_NOTIFICATION ((ULONG)'NDuA')
#define TAG_AuDL_LINK       ((ULONG)'LDuA')

/***************************************************************************

    DEBUGGING SUPPORT

 ***************************************************************************/

#ifdef DEBUG
//-----------------------------------------------------------------------------
//
// Debug support for wdmaud.sys on NT is found here.
//
// To start with, There will be four different levels or debugging information.
// With each level, there will be functional area.  Thus, you can turn on 
// debug output for just driver calls, api tracing or whatnot.
//
//-----------------------------------------------------------------------------

//
// 8 bits reserved for debug leves.
//                                        
#define DL_ERROR        0x00000000
#define DL_WARNING      0x00000001
#define DL_TRACE        0x00000002
#define DL_MAX          0x00000004
#define DL_PATHTRAP     0x00000080

#define DL_MASK         0x000000FF

//
// 20 bits reserved for functional areas.  If we find that this bit is set
// in the DebugLevel variable, we will display every message of this type.
//                          
#define FA_HARDWAREEVENT 0x80000000
#define FA_MIXER         0x40000000
#define FA_IOCTL         0x20000000
#define FA_SYSAUDIO      0x10000000
#define FA_PERSIST       0x08000000
#define FA_PROPERTY      0x04000000
#define FA_USER          0x02000000
#define FA_WAVE          0x01000000
#define FA_MIDI          0x00800000
#define FA_INSTANCE      0x00400000
#define FA_NOTE          0x00200000
#define FA_KS            0x00100000
#define FA_MASK          0xFFFFF000                             
#define FA_ASSERT        0x00002000
#define FA_ALL           0x00001000

//
// 4 bits reserved for return codes.  The 3 lower bits map directly to status 
// codes shifted right 22 bits.  One bit represents that fact that we have a
// return statement.
//
#define RT_ERROR         0x00000300 // 0xCxxxxxxx >> 22 == 0x0000003xx
#define RT_WARNING       0x00000200 // 0x8xxxxxxx >> 22 == 0x0000002xx
#define RT_INFO          0x00000100 // 0x4xxxxxxx >> 22 == 0x0000001xx
#define RT_MASK          0x00000300

#define RT_RETURN        0x00000800


//-----------------------------------------------------------------------------
// Macro might look like this.  
//
// Take the string that we want to output and add "WDMAUD.SYS" and ("Error" or
// "warning" or whatever) to the front of the string.  Next, follow that with
// the function name and line number in the file that the function is found in.
// Then display the error message and then close the message with a breakpoint 
// statement.
//
// The logic goes like this.  If the user wants to see these messages ok.  Else
// bail.  If so, wdmaudDbgPreCheckLevel will return TRUE and it will have
// formated the start of the string.  It will look like:
//
// WDMAUD.SYS Erorr OurFooFunction(456)
//
// Next, the message string with the variable arguements will be displayed, like:
//
// WDMAUD.SYS Warning OurFooFunction(456) Invalid Data Queue returning C0000109
//
// Then, wdmaudDbgPostCheckLevel will be called to post format the message and
// see if the user wanted to trap on this output.
//           
// WDMAUD.SYS Warning OutFooFunction(456) Invalid Data Queue returning C0000109 &DL=ff680123
//
// The internal version will append "See \\debugtips\wdmaud.sys\wdmaud.htm" to
// the end
//
// if( wdmaudDbgPreCheckLevel(TypeOfMessageInCode) )
// {
//     DbgPrintF( _x_ ); // output the actual string here.
//     if( wdmaudDbgPostCheckLevel(Variable) )
//         DbgBreakPoint();
// }
//
// DPF( DL_WARNING|DL_ALL, ("Invalid queue %X",Queue) );
//
//-----------------------------------------------------------------------------

extern VOID 
wdmaudDbgBreakPoint(
    );

extern UINT 
wdmaudDbgPreCheckLevel(
    UINT uiMsgLevel,
    char *pFunction,
    int iLine
    );

extern UINT 
wdmaudDbgPostCheckLevel(
    UINT uiMsgLevel
    );

extern char * 
wdmaudReturnString(
    ULONG ulMsg
    );


extern char szReturningErrorStr[];
extern UINT uiDebugLevel;


#define DPF(_x_,_y_) {if( wdmaudDbgPreCheckLevel(_x_,__FUNCTION__,__LINE__) ) { DbgPrint _y_; \
    wdmaudDbgPostCheckLevel( _x_ ); }}
    
//
// Writing macros are easy, it's figuring out when they are useful that is more
// difficult!  In this code, The RETURN macro replaces the return keyword in the
// debug builds when returning an NTSTATUS code.  Then, when tracking debug output
// the return debug line will be displayed based on the type of error the status
// value represents.  
//
// Notice that the error code is shifted 22 bits and ORed with RT_RETURN.  Thus 
// a value of "0xCxxxxxxx" will be seen as an error message, "0x8xxxxxxx" will
// be seen as a warning and "0x4xxxxxxx" will be seen as a message.
//
// Key, if uiDebugLevel is DL_ERROR or DL_WARNING all NTSTATUS Error message will be displayed
// if uiDebugLevel is DL_TRACE, all warning return codes and error return codes
// will be displayed and if uiDebugLevel is set to DL_MAX all return messages will
// displayed including success codes.
//
// RETURN(Status);
//
// WARNING: Do not rap functions in this macro! Notice that _status_ is used more 
// then once!  Thus, the function will get called more then once!  Don't do it.

#define RETURN(_status_) {DPF((RT_RETURN|DL_WARNING|((unsigned long)_status_>>22)),("%X:%s",_status_,wdmaudReturnString(_status_))); return (_status_);}
    
//
// _list_ is parameters for wdmaudExclusionList.  Like (_status_,STATUS_INVALID_PARAMETER,STATUS_NOT_FOUND,...).
// wdmaudExclusionList takes a variable number of parameters.  If the status value is
// found in the list of error codes supplied, the function returns TRUE.
//
extern int __cdecl 
wdmaudExclusionList( 
    int count, 
    unsigned long status,
    ... 
);
//
// Thus, this macro reads: We have a return code that we're going to return. Is
// it a special return code that we don't need to display?  NO - show the debug
// spew.  YES - just return it.
//
//  _status_ = The status in question
//  _y_ = Parameters to wdmaudExclusionList "( the status in question, exclution values, .... )"
//
#define DPFRETURN( _status_,_y_ )  {if( !wdmaudExclusionList _y_ ) {  \
    if( wdmaudDbgPreCheckLevel((RT_RETURN|DL_WARNING|(_status_>>22)),__FUNCTION__,__LINE__) ) { \
        DbgPrint ("%X:%s",_status_,wdmaudReturnString(_status_) ); \
        wdmaudDbgPostCheckLevel( (RT_RETURN|DL_WARNING|(_status_>>22)) ); \
    } } return (_status_);}


//
// It's bad form to put more then one expression in an assert macro.  Why? because
// you will not know exactly what expression failed the assert!
//
#define DPFASSERT(_exp_) {if( !(_exp_) ) {DPF(DL_ERROR|FA_ASSERT,("'%s'",#_exp_) );}} 

#ifdef WANT_TRAPS
//
// Branch trap.  This macro is used when testing code to make sure that you've
// hit all branches in the new code.  Every time you hit one validate that the
// code does the correct thing and then remove it from the source.  We should 
// ship with none of these lines left in the code!!!!!!
//
#define DPFBTRAP() DPF(DL_PATHTRAP,("Please report") )
#else
#define DPFBTRAP()
#endif


//
// There are a number of new routines in the checked build that validate structure
// types for us now.  These should be used inside the DPFASSERT() macro.  Thus,
// Under retail they don't have to be defined.
//
BOOL
IsValidDeviceInfo(
    IN LPDEVICEINFO pDeviceInfo
    );

BOOL
IsValidMixerObject(
    IN PMIXEROBJECT pmxobj
    );

BOOL
IsValidMixerDevice(
    IN PMIXERDEVICE pmxd
    );

BOOL
IsValidControl(
    IN PMXLCONTROL pControl
    );

BOOL
IsValidWdmaContext(
    IN PWDMACONTEXT pWdmaContext
    );

BOOL
IsValidLine(
    IN PMXLLINE pLine
    );

VOID 
GetuiDebugLevel(
    );

#else

#define DPF(_x_,_y_)
#define RETURN( _status_ ) return (_status_)
#define DPFRETURN( _status_,_y_ ) return (_status_)
#define DPFASSERT(_exp_)
#define DPFBTRAP() 


#endif

VOID
kmxlFindAddressInNoteList(
    IN PMXLCONTROL pControl 
    );

VOID
kmxlCleanupNoteList(
    );

NTSTATUS
kmxlDisableControlChangeNotifications(
    IN PMXLCONTROL pControl
    );

VOID
kmxlRemoveContextFromNoteList(
    PWDMACONTEXT pContext
    );

VOID
kmxlPersistHWControlWorker(
    PVOID pReference
    );

#endif // _WDMSYS_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wvmapper\wvmapper.h ===
/* WVMAPPER.H */
;
;

#define	OPEN_PIN		1
#define	CLOSE_PIN		2
#define	WRITE_PIN		3

#define	WVMAPPER_DEVICE_ID	0x77

#define	MIXER_CHANNELS	2
#define	MIXER_SAMPLE_SIZE	2
#define	MIXER_SAMPLE_RATE	44100

struct wod_tag {
	HWAVE		hWave ;
	DWORD		dwInstance ;
	DWORD		dwCallBack ;
	DWORD		dwFlags ;
} ;

LRESULT _loadds CALLBACK DriverProc
(
DWORD	dwId,
HDRVR	hDriver,
WORD	wMsg,
LPARAM	lParam1,
LPARAM	lParam2
) ;

DWORD FAR PASCAL _loadds wodMessage
(
UINT uDevId,
UINT uMsg,
DWORD dwUser,
DWORD dwParam1,
DWORD dwParam2
) ;
DWORD FAR PASCAL _loadds widMessage
(
UINT uDevId,
UINT uMsg,
DWORD dwUser,
DWORD dwParam1,
DWORD dwParam2
) ;

MMRESULT wodmGetDevCaps
(
LPWAVEOUTCAPS lpWaveOutCaps,
DWORD dwSize
) ;

MMRESULT wodmOpen
(
LPWAVEOPENDESC lpWaveOpenDesc,
DWORD Flags
) ;

MMRESULT wodmClose
(
VOID
) ;

MMRESULT wodmWrite
(
LPWAVEHDR lpWaveHdr,
DWORD dwSize
) ;

VOID wodCallBack
(
WORD msg,
DWORD dw1,
DWORD dw2
) ;

WORD OpenPin
(
LPWAVEFORMAT lpFormat
) ;

WORD ClosePin
(
WORD PinHandle
) ;

WORD WritePin
(
LPWAVEHDR lpWaveHdr
) ;

LRESULT OpenDevice
(
VOID
) ;

VOID PASCAL FAR _loadds WODCOMPLETEIO
(
LPWAVEHDR lpWaveHdr
) ;


VOID FAR PASCAL DeviceCallBack
(
VOID
) ;

extern		WORD	g_SegText ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\legacy\wvmapper\wvmapper.c ===
#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>

#include "wvmapper.h"

HINSTANCE g_hmodThis;
WORD		gwodOpenCount = 0 ;
struct wod_tag gwod ;
DWORD gDeviceAddress ;
WORD gPinHandle ;

LRESULT _loadds CALLBACK DriverProc (dwId, hDriver, wMsg, lParam1, lParam2 )
DWORD	dwId ;
HDRVR	hDriver ;
WORD	wMsg ;
LPARAM	lParam1 ;
LPARAM	lParam2 ;
{
	switch ( wMsg ) {
		case DRV_OPEN:
			OutputDebugString ( "WVMAPPER :: DRV_OPEN\n" ) ;
			return ( OpenDevice() ) ;
		case DRV_CLOSE:
			OutputDebugString ( "WVMAPPER :: DRV_CLOSE\n" ) ;
			break ;
		case DRV_CONFIGURE:
			OutputDebugString ( "WVMAPPER :: DRV_CONFIGURE\n" ) ;
			break ;
		case DRV_DISABLE:
			OutputDebugString ( "WVMAPPER :: DRV_DISABLE\n" ) ;
			break ;
		case DRV_ENABLE:
			OutputDebugString ( "WVMAPPER :: DRV_ENABLE\n" ) ;
			break ;
		case DRV_FREE:
			OutputDebugString ( "WVMAPPER :: DRV_FREE\n" ) ;
			break ;
		case DRV_INSTALL:
			OutputDebugString ( "WVMAPPER :: DRV_INSTALL\n" ) ;
			break ;
		case DRV_LOAD:
			OutputDebugString ( "WVMAPPER :: DRV_LOAD\n" ) ;
			break ;
		case DRV_POWER:
			OutputDebugString ( "WVMAPPER :: DRV_POWER\n" ) ;
			break ;
		case DRV_QUERYCONFIGURE:
			OutputDebugString ( "WVMAPPER :: DRV_QUERYCONFIGURE\n" ) ;
			break ;
		case DRV_REMOVE:
			OutputDebugString ( "WVMAPPER :: DRV_REMOVE\n" ) ;
			break ;
		default:
			OutputDebugString ( "WVMAPPER :: DRV_OTHERS\n" ) ;
	}
	return (1L) ;
}

DWORD FAR PASCAL _loadds wodMessage (uDevId, uMsg, dwUser, dwParam1, dwParam2)
UINT uDevId ;
UINT uMsg ;
DWORD dwUser ;
DWORD dwParam1 ;
DWORD dwParam2 ;
{
	switch (uMsg) {
		case WODM_BREAKLOOP:
			OutputDebugString ( "WVMAPPER :: WODM_BREAKLOOP\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WODM_CLOSE:
			OutputDebugString ( "WVMAPPER :: WODM_CLOSE\n" ) ;
			return (wodmClose()) ;

		case WODM_GETDEVCAPS:
			OutputDebugString ( "WVMAPPER :: WODM_GETDEVCAPS\n" ) ;
			return (wodmGetDevCaps ( (LPWAVEOUTCAPS) dwParam1, dwParam2 ) ) ;

		case WODM_GETNUMDEVS:
			OutputDebugString ( "WVMAPPER :: WODM_GETNUMDEVS\n" ) ;
			return ( 1 ) ;
		case WODM_GETPOS:
			OutputDebugString ( "WVMAPPER :: WODM_GETPOS\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WODM_OPEN:
			OutputDebugString ( "WVMAPPER :: WODM_OPEN\n" ) ;
			return wodmOpen ( (LPWAVEOPENDESC) dwParam1, dwParam2 ) ;
		case WODM_PAUSE:
			OutputDebugString ( "WVMAPPER :: WODM_PAUSE\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WODM_RESET:
			OutputDebugString ( "WVMAPPER :: WODM_RESET\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WODM_RESTART:
			OutputDebugString ( "WVMAPPER :: WODM_RESTART\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WODM_WRITE:
			OutputDebugString ( "WVMAPPER :: WODM_WRITE\n" ) ;
			return ( wodmWrite ( (LPWAVEHDR)dwParam1, dwParam2) ) ;
		default:
			OutputDebugString ( "WVMAPPER :: WODM_OTHERS\n" ) ;
			return ( MMSYSERR_NOTSUPPORTED ) ;
	}

return (TRUE) ;
}

DWORD FAR PASCAL _loadds widMessage (uDevId, uMsg, dwUser, dwParam1, dwParam2)
UINT uDevId ;
UINT uMsg ;
DWORD dwUser ;
DWORD dwParam1 ;
DWORD dwParam2 ;
{
	switch (uMsg) {
		case WIDM_CLOSE:
			OutputDebugString ( "WVMAPPER :: WIDM_CLOSE\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WIDM_GETDEVCAPS:
			OutputDebugString ( "WVMAPPER :: WIDM_GETDEVCAPS\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WIDM_GETNUMDEVS:
			OutputDebugString ( "WVMAPPER :: WIDM_GETNUMDEVS\n" ) ;
			return ( 1 ) ;
		case WIDM_GETPOS:
			OutputDebugString ( "WVMAPPER :: WIDM_GETPOS\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WIDM_OPEN:
			OutputDebugString ( "WVMAPPER :: WIDM_OPEN\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		case WIDM_RESET:
			OutputDebugString ( "WVMAPPER :: WIDM_RESET\n" ) ;
			return ( MMSYSERR_NOERROR ) ;
		default:
			OutputDebugString ( "WVMAPPER :: WIDM_OTHERS\n" ) ;
			return ( MMSYSERR_NOTSUPPORTED ) ;
	}

return (TRUE) ;
}

BOOL FAR PASCAL LibMain(HANDLE hInstance, WORD wHeapSize, LPSTR lpszCmdLine)
{

    g_hmodThis = hInstance;
    return(TRUE);
}

MMRESULT wodmGetDevCaps ( lpWaveOutCaps, dwSize )
LPWAVEOUTCAPS lpWaveOutCaps ;
DWORD dwSize ;
{
	char	*name = "WDM WaveOut Mapper" ;
	char far *tmp ;

	lpWaveOutCaps->wMid = 1 ;
	lpWaveOutCaps->wPid = 1 ;
	lpWaveOutCaps->vDriverVersion = 1 ;
	lpWaveOutCaps->dwFormats = WAVE_FORMAT_4S16 ;
	lpWaveOutCaps->wChannels = 2 ;
	lpWaveOutCaps->dwSupport = 0 ;
	tmp = &lpWaveOutCaps->szPname[0] ;
	while ( *name ) {
		*tmp++ = *name++ ;
	}
	*tmp = '\0' ;
	return ( MMSYSERR_NOERROR ) ;
}

MMRESULT wodmOpen ( lpWaveOpenDesc, Flags )
LPWAVEOPENDESC lpWaveOpenDesc ;
DWORD Flags ;
{
	LPWAVEFORMAT lpWaveFormat ;

	if ( Flags & WAVE_FORMAT_QUERY ) {
		lpWaveFormat = lpWaveOpenDesc->lpFormat ;
		if ( (lpWaveFormat->wFormatTag != WAVE_FORMAT_PCM) ||
		     (lpWaveFormat->nChannels != MIXER_CHANNELS) ||
		     (lpWaveFormat->nSamplesPerSec != MIXER_SAMPLE_RATE) ||
		     (lpWaveFormat->nBlockAlign != (MIXER_CHANNELS*MIXER_SAMPLE_SIZE)) )
			return ( WAVERR_BADFORMAT ) ;
		return ( MMSYSERR_NOERROR ) ;
	}

	if ( gwodOpenCount )
		return ( MMSYSERR_ALLOCATED ) ;
	gPinHandle = OpenPin((LPWAVEFORMAT)lpWaveOpenDesc->lpFormat) ;
	if ( !gPinHandle )
		return ( MMSYSERR_NOTENABLED ) ;
	gwodOpenCount++ ;
	gwod.hWave = lpWaveOpenDesc->hWave ;
	gwod.dwInstance = lpWaveOpenDesc->dwInstance ;
	gwod.dwCallBack = lpWaveOpenDesc->dwCallback ;
	gwod.dwFlags = Flags & (~WAVE_FORMAT_QUERY) ;
	wodCallBack ( WOM_OPEN, 0L, 0L ) ;
	return ( MMSYSERR_NOERROR) ;
}

MMRESULT wodmClose ()
{
	if ( (gwodOpenCount != 1) ) {
		OutputDebugString ( "Wierd waveout open count -- %d" ) ;
		_asm int 3 ;
	}
	ClosePin ( gPinHandle ) ;
	gwodOpenCount-- ;
	wodCallBack ( WOM_CLOSE, 0L, 0L ) ;
	return (MMSYSERR_NOERROR) ;
}

MMRESULT wodmWrite ( lpWaveHdr, dwSize )
LPWAVEHDR lpWaveHdr ;
DWORD dwSize ;
{
	lpWaveHdr->dwFlags |= WHDR_INQUEUE ;
	lpWaveHdr->dwFlags &= ~WHDR_DONE ;
	WritePin ( lpWaveHdr ) ;
	return ( MMSYSERR_NOERROR ) ;
}

VOID wodCallBack ( msg, dw1, dw2 )
WORD msg ;
DWORD dw1 ;
DWORD dw2 ;
{
	DriverCallback(
		gwod.dwCallBack,                     // user's callback DWORD
		HIWORD(gwod.dwFlags),                // callback flags
		gwod.hWave,                          // handle to the wave device
		msg,                                   // the message
		gwod.dwInstance,                     // user's instance data
		dw1,                                   // first DWORD
		dw2 ) ;                                 // second DWORD
}

WORD ClosePin ( PinHandle )
WORD PinHandle;
{
	WORD result ;
	_asm {
		mov	ax, CLOSE_PIN
		mov	bx, word ptr PinHandle
		call	dword ptr [gDeviceAddress]
		mov	result, ax
	}
	return (result) ;
}

LRESULT OpenDevice ()
{
	_asm {
		xor	ax, ax
		mov	es, ax
		mov	di, ax
		mov	ax, 1684h
		mov	bx, WVMAPPER_DEVICE_ID
		int	2fh
		mov	word ptr [gDeviceAddress], di
		mov	word ptr [gDeviceAddress+2], es
	}
	if ( gDeviceAddress )
		return ( 1L ) ;
	else
		return ( 0L ) ;
}

VOID PASCAL FAR _loadds WODCOMPLETEIO (lpWaveHdr)
LPWAVEHDR lpWaveHdr ;
{
	lpWaveHdr->dwFlags &= ~WHDR_INQUEUE ;
	lpWaveHdr->dwFlags |= WHDR_DONE ;
	wodCallBack ( WOM_DONE, (DWORD)lpWaveHdr, 0L) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\alloc.h ===
//---------------------------------------------------------------------------
//
//  Module:   alloc.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Data structures
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
AllocatorDispatchCreate(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
);

NTSTATUS
AllocatorDispatchCreateKP(
    PINSTANCE pInstance,
    PKSALLOCATOR_FRAMING pAllocatorFraming
);

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\ci.h ===
//---------------------------------------------------------------------------
//
//  Module:   		ci.h
//
//  Description:	Connect Info Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define	CI_FLAGS_CONNECT_TOP_DOWN	0x00000001
#define	CI_FLAGS_LIMIT_FORMAT		0x00000002
#define	CI_FLAGS_REUSE_FILTER_INSTANCE	0x00000004

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CConnectInfo : public CListDoubleItem
{
    friend class CConnectNode;
private:
    CConnectInfo(
	PCONNECT_NODE pConnectNode,
	PCONNECT_INFO pConnectInfoNext,
	PGRAPH_PIN_INFO pGraphPinInfo,
	PGRAPH_NODE pGraphNode
    );

    ~CConnectInfo(
    );

public:
    static NTSTATUS
    Create(
	PCONNECT_NODE pConnectNode,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PCONNECT_INFO pConnectInfoNext,
	PGRAPH_PIN_INFO pGraphPinInfo,
	ULONG ulFlagsCurrent,
	PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    VOID 
    AddRef(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ++cReference;
	}
    };

    PKSPIN_CINSTANCES
    GetPinInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->GetPinInstances());
    };

    BOOL
    IsPinInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->IsPinInstances());
    };

    VOID
    AddPinInstance(
    )
    {
	Assert(this);
	if(pPinInfoSink == pGraphPinInfo->GetPinInfo()) {
	    pGraphPinInfo->AddPinInstance();
	}
    };

    VOID
    RemovePinInstance(
    )
    {
	Assert(this);
	if(pPinInfoSink == pGraphPinInfo->GetPinInfo()) {
	    pGraphPinInfo->RemovePinInstance();
	}
    };

    NTSTATUS
    ReservePinInstance(
	PGRAPH_NODE pGraphNode
    )
    {
	Assert(this);
	ASSERT(pPinInfoSink == pGraphPinInfo->pPinInfo);

	pGraphPinInfo->ReservePinInstance();
	pGraphPinInfo->Destroy();

	return(CGraphPinInfo::Create(
	  &pGraphPinInfo,
	  pPinInfoSink,
	  GPI_FLAGS_RESERVE_PIN_INSTANCE,
	  pGraphNode));
    };

    PCONNECT_INFO
    GetNextConnectInfo(
    )
    {
	Assert(this);
	return(pConnectInfoNext);
    };

    BOOL
    IsSameGraph(
	PCONNECT_INFO pConnectInfo
    )
    {
	PCONNECT_INFO pConnectInfo1, pConnectInfo2;
	BOOL fSameGraph;

	for(pConnectInfo1 = this, pConnectInfo2 = pConnectInfo;

	   (fSameGraph = (pConnectInfo1 == pConnectInfo2)) && 
	    pConnectInfo1 != NULL && pConnectInfo2 != NULL;

	    pConnectInfo1 = pConnectInfo1->GetNextConnectInfo(),
	    pConnectInfo2 = pConnectInfo2->GetNextConnectInfo()) {

	    Assert(pConnectInfo1);
	    Assert(pConnectInfo2);
	}
	return(fSameGraph);
    };

    BOOL
    IsTopDown(
    )
    {
	Assert(this);
	return(ulFlags & CI_FLAGS_CONNECT_TOP_DOWN);
    };

    BOOL
    IsLimitFormat(
    )
    {
	Assert(this);
	return(ulFlags & CI_FLAGS_LIMIT_FORMAT);
    };

    BOOL
    IsReuseFilterInstance(
    )
    {
	Assert(this);
	return(ulFlags & CI_FLAGS_REUSE_FILTER_INSTANCE);
    };

    BOOL
    IsPinInstanceReserved(
    )
    {
	Assert(this);
	Assert(pGraphPinInfo);
	return(pGraphPinInfo->ulFlags & GPI_FLAGS_RESERVE_PIN_INSTANCE);
    };

#ifdef DEBUG
    ENUMFUNC
    Dump(
    );
#endif

private:
    LONG cReference;
    ULONG ulFlags;
    PCONNECT_INFO pConnectInfoNext;
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    PGRAPH_PIN_INFO pGraphPinInfo;
public:
    PPIN_INFO pPinInfoSource;
    PPIN_INFO pPinInfoSink;
    DefineSignature(0x20204943);				// CI

} CONNECT_INFO, *PCONNECT_INFO;

//---------------------------------------------------------------------------

typedef ListDouble<CONNECT_INFO> LIST_CONNECT_INFO;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\cinstanc.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   ins.cpp
//
//  Description:
//
//	KS Instance base class definitions
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSDISPATCH_TABLE(
    DispatchTable,
    CInstance::DispatchForwardIrp,		// Ioctl
    DispatchInvalidDeviceRequest,		// Read
    DispatchInvalidDeviceRequest,		// Write
    DispatchInvalidDeviceRequest,		// Flush
    CInstance::DispatchClose,			// Close
    DispatchInvalidDeviceRequest,		// QuerySecurity
    DispatchInvalidDeviceRequest,		// SetSeturity
    DispatchFastIoDeviceControlFailure,		// FastDeviceIoControl
    DispatchFastReadFailure,			// FastRead
    DispatchFastWriteFailure			// FastWrite
);

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CInstance::CInstance(
    IN PPARENT_INSTANCE pParentInstance
)
{
    Assert(pParentInstance);
    this->pParentInstance = pParentInstance;
    AddList(&pParentInstance->lstChildInstance);
}

CInstance::~CInstance(
)
{
    Assert(this);
    RemoveList();

    // IMPORTANT : Caller must acquire gmutex.
    //

    // "RemoveRef" from file object
    if(pNextFileObject != NULL) {
        ObDereferenceObject(pNextFileObject);
        pNextFileObject = NULL;
    }
    if(pObjectHeader != NULL) {
        KsFreeObjectHeader(pObjectHeader);
    }
    // "RemoveRef" from parent file object
    if(pParentFileObject != NULL) {
        ObDereferenceObject(pParentFileObject);
    }
    // Clean up pin mutex
    if(pMutex != NULL) {
        ExFreePool(pMutex);
    }
}

NTSTATUS
CInstance::DispatchCreate(
    IN PIRP pIrp,
    IN UTIL_PFN pfnDispatchCreate,
    IN OUT PVOID pReference,
    IN ULONG cCreateItems,
    IN PKSOBJECT_CREATE_ITEM pCreateItems OPTIONAL,
    IN const KSDISPATCH_TABLE *pDispatchTable OPTIONAL
)
{
    PIO_STACK_LOCATION pIrpStack;
    NTSTATUS Status;

    Assert(this);
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pParentFileObject = pIrpStack->FileObject->RelatedFileObject;
    ObReferenceObject(pParentFileObject);

    pMutex = (KMUTEX *)ExAllocatePoolWithTag(
      NonPagedPool,
      sizeof(KMUTEX),
      0x41535953);

    if(pMutex == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    KeInitializeMutex(pMutex, 0);

    Status = KsAllocateObjectHeader(
      &pObjectHeader,
      cCreateItems,
      pCreateItems,
      pIrp,
      pDispatchTable);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = pfnDispatchCreate(this, pReference);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pNextDeviceObject = IoGetRelatedDeviceObject(pNextFileObject);
    
    //
    // ISSUE: 05/10/02 ALPERS
    // Windows does not support dynamically adjusting StackSizes on the fly.
    // The only place we are supposed to change this is in AddDevice.
    // This must be fixed later.
    //
    
    // 
    // Never make the StackSize smaller. It can cause unexpected problems
    // if there are devices with deeper stacks.
    //
    if (pIrpStack->DeviceObject->StackSize < pNextDeviceObject->StackSize) {
        pIrpStack->DeviceObject->StackSize = pNextDeviceObject->StackSize;
    }
    pIrpStack->FileObject->FsContext = this;
exit:
    return(Status);
}

VOID 
CInstance::Invalidate(
)
{
    Assert(this);

    GrabMutex();

    DPF1(50, "CInstance::Invalidate %08x", this);

    // "RemoveRef" from file object
    if(pNextFileObject != NULL) {
        ObDereferenceObject(pNextFileObject);
    }
    pNextFileObject = NULL;

    ReleaseMutex();
}

VOID
CParentInstance::Invalidate(
)
{
    PINSTANCE pInstance;

    Assert(this);
    FOR_EACH_LIST_ITEM_DELETE(&lstChildInstance, pInstance) {
        pInstance->Invalidate();
    } END_EACH_LIST_ITEM
}

NTSTATUS
CInstance::DispatchClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;
    PINSTANCE pInstance;

    ::GrabMutex();

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pInstance = (PINSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pInstance);
    pIrpStack->FileObject->FsContext = NULL;
    delete pInstance;

    ::ReleaseMutex();

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS
CInstance::DispatchForwardIrp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;
    PFILE_OBJECT pNextFileObject;
    PINSTANCE pInstance;
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef DEBUG
    DumpIoctl(pIrp, "ForwardIrp");
#endif
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pInstance = (PINSTANCE)pIrpStack->FileObject->FsContext;

    // Use gMutex instead of instance mutex. The instance mutex
    // is not used in any of the dispatch handlers, therefore will
    // not synchronize DispatchForwardIrp with other DispatchHandlers in
    // CPinInstance.
    // Grab mutex for a very short time to check the validity of CInstance.
    // If it is valid, IoCallDriver is called. This does not need 
    // synchronization
    //

    ::GrabMutex();
    
    Assert(pInstance);
    pNextFileObject = pInstance->pNextFileObject;

    if(pNextFileObject == NULL) {
        DPF(60, "DispatchIoControl: pNextFileObject == NULL");
        Status = pIrp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    ::ReleaseMutex();

    if (NT_SUCCESS(Status)) {
        pIrpStack->FileObject = pNextFileObject;
        IoSkipCurrentIrpStackLocation(pIrp);
        AssertFileObject(pIrpStack->FileObject);
        Status = IoCallDriver(pInstance->pNextDeviceObject, pIrp);
    }
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\alloc.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   alloc.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
AllocatorDispatchCreate(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PKSALLOCATOR_FRAMING pAllocatorFraming;
    PINSTANCE pInstance = NULL;
    NTSTATUS Status;

    GrabMutex();

    Status = GetRelatedStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    Assert(pStartNodeInstance);

    Status = KsValidateAllocatorCreateRequest(
       pIrp,
       &pAllocatorFraming);

    if(!NT_SUCCESS(Status)) {
	DPF1(5, 
	  "AllocatorDispatchCreate: KsValidateAllocatorCreateReq FAILED %08x",
	  Status);
	goto exit;
    }

    // Allocate per allocator instance data
    pInstance = new INSTANCE(
      &pStartNodeInstance->pPinInstance->ParentInstance);

    if(pInstance == NULL) {
	Trap();
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }

    Status = pInstance->DispatchCreate(
      pIrp,
      (UTIL_PFN)AllocatorDispatchCreateKP,
      pAllocatorFraming);

    if(!NT_SUCCESS(Status)) {
	DPF1(5, "AllocatorDispatchCreateKP: FAILED %08x", Status);
	goto exit;
    }
exit:
    if(!NT_SUCCESS(Status) && (pInstance != NULL)) {
	delete pInstance;
    }
    ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return Status;
}

NTSTATUS
AllocatorDispatchCreateKP(
    PINSTANCE pInstance,
    PKSALLOCATOR_FRAMING pAllocatorFraming
)
{
    PPIN_INSTANCE pPinInstance;
    HANDLE hAllocator = NULL;
    NTSTATUS Status;

    Assert(pInstance);
    pPinInstance = pInstance->GetParentInstance();
    Assert(pPinInstance);
    Assert(pPinInstance->pStartNodeInstance);
    Assert(pPinInstance->pStartNodeInstance->pPinNodeInstance);
    ASSERT(pPinInstance->pStartNodeInstance->pPinNodeInstance->hPin != NULL);

    Status = KsCreateAllocator(
      pPinInstance->pStartNodeInstance->pPinNodeInstance->hPin,
      pAllocatorFraming,
      &hAllocator);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    Status = pInstance->SetNextFileObject(hAllocator);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    if(hAllocator != NULL) {
	ZwClose(hAllocator);
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\cinstanc.h ===
//---------------------------------------------------------------------------
//
//  Module:   		ins.h
//
//  Description:	KS Instance base class definition
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern "C" const KSDISPATCH_TABLE DispatchTable;

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CInstance
{
    friend class ListDoubleField<CInstance>;
public:
    CInstance(
	IN PPARENT_INSTANCE pParentInstance
    );

    ~CInstance(
    );

    static NTSTATUS
    DispatchClose(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

    static NTSTATUS
    DispatchForwardIrp(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

    VOID
    Invalidate(
    );

    PFILE_OBJECT 
    GetNextFileObject(
    )
    {
	return(pNextFileObject);
    };

    PPIN_INSTANCE
    GetParentInstance(			// inline body in pins.h
    );

    NTSTATUS
    SetNextFileObject(
	HANDLE handle
    )
    {
	return(ObReferenceObjectByHandle(
	  handle,
	  GENERIC_READ | GENERIC_WRITE,
	  NULL,
	  KernelMode,
	  (PVOID*)&pNextFileObject,
	  NULL));
    };

    NTSTATUS
    DispatchCreate(
	IN PIRP pIrp,
	IN UTIL_PFN pfnDispatchCreate,
	IN OUT PVOID pReference,
	IN ULONG cCreateItems = 0,
	IN PKSOBJECT_CREATE_ITEM pCreateItems = NULL,
	IN const KSDISPATCH_TABLE *pDispatchTable = &DispatchTable
    );

    VOID GrabMutex()
    {
	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	AssertStatus(
	  KeWaitForMutexObject(pMutex, Executive, KernelMode, FALSE, NULL));
    };

    VOID ReleaseMutex()
    {
	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	KeReleaseMutex(pMutex, FALSE);
    };

#ifdef DEBUG
    ENUMFUNC
    Dump(
    )
    {
	dprintf("CINS: %08x OH %08x PFO %08x NFO %08x NDO %08x PI %08x\n",
	  this,
	  pObjectHeader,
	  pParentFileObject,
	  pNextFileObject,
	  pNextDeviceObject,
	  pParentInstance);
	return (STATUS_CONTINUE);
    };

    ENUMFUNC
    DumpAddress(
    )
    {
	Assert(this);
	dprintf(" %08x", this);
	return(STATUS_CONTINUE);
    };
#endif

private:
    VOID
    AddList(
        CListDouble *pld
    )
    {
	ldiNext.AddList(pld);
    };

    VOID
    RemoveList(
    )
    {
	ldiNext.RemoveList();
    };
    //
    // This pointer to the dispatch table is used in the common
    // dispatch routines  to route the IRP to the appropriate
    // handlers.  This structure is referenced by the device driver
    // with IoGetCurrentIrpStackLocation( pIrp ) -> FsContext
    //
    PVOID pObjectHeader;
    PFILE_OBJECT pParentFileObject;
    PDEVICE_OBJECT pNextDeviceObject;
    PPARENT_INSTANCE pParentInstance;
    PFILE_OBJECT pNextFileObject;
    CLIST_DOUBLE_ITEM ldiNext;
    KMUTEX *pMutex;
public:
    DefineSignature(0x534e4943);			// CINS

} INSTANCE, *PINSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleField<INSTANCE> LIST_INSTANCE, *PLIST_INSTANCE;

//---------------------------------------------------------------------------

typedef class CParentInstance
{
    friend class CInstance;
public:
    VOID
    Invalidate(
    );

    BOOL
    IsChildInstance(
    )
    {
	return(lstChildInstance.IsLstEmpty());
    };
#ifdef DEBUG
    ENUMFUNC
    Dump()
    {
	lstChildInstance.Dump();
	return(STATUS_CONTINUE);
    };

    ENUMFUNC
    DumpAddress()
    {
	lstChildInstance.DumpAddress();
	return(STATUS_CONTINUE);
    };
#endif
    LIST_INSTANCE lstChildInstance;
    DefineSignature(0x52415043);			// CPAR

} PARENT_INSTANCE, *PPARENT_INSTANCE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\clist.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   clist.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
// CListSingle Class
//---------------------------------------------------------------------------

ENUMFUNC
CListSingle::EnumerateList(
    IN ENUMFUNC (CListSingleItem::*pfn)(
    )
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_SINGLE_ITEM plsi;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plsi, CLIST_SINGLE_ITEM) {
	Status = (plsi->*pfn)();
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
CListSingle::EnumerateList(
    IN ENUMFUNC (CListSingleItem::*pfn)(
	PVOID pReference
    ),
    PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_SINGLE_ITEM plsi;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plsi, CLIST_SINGLE_ITEM) {
	Status = (plsi->*pfn)(pReference);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

PCLIST_SINGLE_ITEM *
CListSingle::GetListEnd(
)
{
    PCLIST_SINGLE_ITEM *pplsi;

    for(pplsi = &m_plsiHead;
      !IsListEnd(*pplsi);
      pplsi = &(*pplsi)->m_plsiNext) {
        Assert(*pplsi);
    }
    return(pplsi);
}

void 
CListSingle::ReverseList(
)
{
    PCLIST_SINGLE_ITEM plsi = m_plsiHead;
    PCLIST_SINGLE_ITEM plsiNext;
    PCLIST_SINGLE_ITEM plsiTemp;

    if (NULL != plsi) {
        plsiNext = plsi->m_plsiNext;
        plsi->m_plsiNext = NULL;
        
        while (NULL != plsiNext) {
            plsiTemp = plsiNext->m_plsiNext;
            plsiNext->m_plsiNext = plsi;
            plsi = plsiNext;
            plsiNext = plsiTemp;
        }

        m_plsiHead = plsi;
    }
}

//---------------------------------------------------------------------------
// CListSingleItem Class
//---------------------------------------------------------------------------

VOID
CListSingleItem::RemoveList(
    IN PCLIST_SINGLE pls
)
{
    PCLIST_SINGLE_ITEM *pplsi;

    Assert(pls);
    Assert(this);

    for(pplsi = &pls->m_plsiHead;
      !pls->IsListEnd(*pplsi);
      pplsi = &(*pplsi)->m_plsiNext) {
	Assert(*pplsi);
	if(*pplsi == this) {
	    break;
	}
    }
    *pplsi = m_plsiNext;
}

//---------------------------------------------------------------------------
// CListDouble Class
//---------------------------------------------------------------------------

ULONG
CListDouble::CountList(
)
{
    PCLIST_DOUBLE_ITEM pldi;
    ULONG c = 0;

    Assert(this);
    FOR_EACH_CLIST_ITEM(this, pldi) {
	Assert(pldi);
	c++;
    } END_EACH_CLIST_ITEM
    return(c);
}

ENUMFUNC
CListDouble::EnumerateList(
    IN ENUMFUNC (CListDoubleItem::*pfn)(
    )
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_DOUBLE_ITEM plbi;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plbi, CLIST_DOUBLE_ITEM) {
	Status = (plbi->*pfn)();
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
CListDouble::EnumerateList(
    IN ENUMFUNC (CListDoubleItem::*pfn)(
	PVOID pReference
    ),
    PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_DOUBLE_ITEM plbi;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plbi, CLIST_DOUBLE_ITEM) {
	Status = (plbi->*pfn)(pReference);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

//---------------------------------------------------------------------------
// CListData Class
//---------------------------------------------------------------------------

VOID
CListData::DestroyList()
{
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, pldd, CLIST_DATA_DATA) {
	delete pldd;
    } END_EACH_CLIST_ITEM
    CListSingle::DestroyList();
}

ULONG
CListData::CountList(
)
{
    PCLIST_DATA_DATA pldd;
    ULONG c = 0;

    Assert(this);
    FOR_EACH_CLIST_ITEM(this, pldd) {
	Assert(pldd);
	c++;
    } END_EACH_CLIST_ITEM
    return(c);
}

ENUMFUNC
CListData::EnumerateList(
    IN ENUMFUNC (CListDataItem::*pfn)(
    )
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, pldd, CLIST_DATA_DATA) {
	Status = (GetListData(pldd)->*pfn)();
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
CListData::EnumerateList(
    IN ENUMFUNC (CListDataItem::*pfn)(
	PVOID pReference
    ),
    PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, pldd, CLIST_DATA_DATA) {
	Status = (GetListData(pldd)->*pfn)(pReference);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CListData::CreateUniqueList(
    OUT PCLIST_DATA pldOut,
    IN PVOID (*GetFunction)(
	IN PVOID pData
    ),
    IN BOOL (*CompareFunction)(
        IN PVOID pIn,
        IN PVOID pOut
    )
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCLIST_DATA_DATA plddIn, plddOut;
    PVOID pIn, pOut;
    BOOL fFoundMatch;

    FOR_EACH_CLIST_ITEM(this, plddIn) {

	pIn = (*GetFunction)((PVOID)GetListData(plddIn));
	if(pIn == NULL) {
	    continue;
	}
 	AssertAligned(pIn);
	fFoundMatch = FALSE;
	FOR_EACH_CLIST_ITEM(pldOut, plddOut) {

	    pOut = (PVOID)pldOut->GetListData(plddOut);
	    if((*CompareFunction)(pIn, pOut)) {
		fFoundMatch = TRUE;
		break;
	    }

	} END_EACH_CLIST_ITEM

	if(!fFoundMatch) {
	    Status = pldOut->AddListEnd(pIn);
	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	}

    } END_EACH_CLIST_ITEM
exit:
    if(!NT_SUCCESS(Status)) {
	pldOut->DestroyList();
    }
    return(Status);
}

BOOL
CListData::CheckDupList(
    PVOID p
)
{
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM(this, pldd) {
	if(GetListData(pldd) == p) {
	   return(TRUE);
	}
    } END_EACH_CLIST_ITEM
    return(FALSE);
}

NTSTATUS 
CListData::AddList(
    PVOID p
)
{
    Assert(this);
    if(CheckDupList(p)) {
	return(STATUS_SUCCESS);
    }
    return(AddListDup(p));
}

NTSTATUS 
CListData::AddListDup(
    PVOID p
)
{
    Assert(this);
    PCLIST_DATA_DATA pldd = new CLIST_DATA_DATA(p);
    if(pldd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    pldd->AddList(this);
    return(STATUS_SUCCESS);
}

NTSTATUS
CListData::AddListEnd(
    PVOID p
)
{
    ASSERT(!CheckDupList(p));

    PCLIST_DATA_DATA pldd = new CLIST_DATA_DATA(p);
    if(pldd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    *(GetListEnd()) = pldd;
    return(STATUS_SUCCESS);
}

NTSTATUS
CListData::AddListOrdered(
    PVOID p,
    LONG lFieldOffset
)
{
    PCLIST_DATA_DATA pldd, *ppldd;
    ULONG ulOrder;

    ASSERT(!CheckDupList(p));
    ulOrder = *((PULONG)(((PCHAR)p) + lFieldOffset));

    pldd = new CLIST_DATA_DATA(p);
    if(pldd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    for(ppldd = (PCLIST_DATA_DATA *)&m_plsiHead;
      !IsListEnd(*ppldd);
      ppldd = (PCLIST_DATA_DATA *)&(*ppldd)->m_plsiNext) {
	Assert(*ppldd);
	if(ulOrder < *((PULONG)(((PCHAR)GetListData(*ppldd)) + lFieldOffset))) {
	     break;
	}
    }
    pldd->m_plsiNext = *ppldd;
    *ppldd = pldd;
    return(STATUS_SUCCESS);
}

VOID 
CListData::RemoveList(
    PVOID p
)
{
    PCLIST_DATA_DATA pldd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, pldd, CLIST_DATA_DATA) {
	if(GetListData(pldd) == p) {
	    pldd->RemoveList(this);
	    delete pldd;
	}
    } END_EACH_CLIST_ITEM
}

VOID
CListData::JoinList(
    PCLIST_DATA pld
)
{
    *GetListEnd() = pld->GetListFirst();
    pld->CListSingle::DestroyList();
}

//---------------------------------------------------------------------------
// CListMulti Class
//---------------------------------------------------------------------------

VOID
CListMulti::DestroyList(
)
{
    PCLIST_MULTI_DATA plmd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plmd, CLIST_MULTI_DATA) {
	delete plmd;
    } END_EACH_CLIST_ITEM
    CListDouble::DestroyList();
}

ENUMFUNC
CListMulti::EnumerateList(
    ENUMFUNC (CListMultiItem::*pfn)(
    )
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_MULTI_DATA plmd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plmd, CLIST_MULTI_DATA) {
	Status = (GetListData(plmd)->*pfn)();
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
CListMulti::EnumerateList(
    ENUMFUNC (CListMultiItem::*pfn)(
	PVOID pReference
    ),
    PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE;
    PCLIST_MULTI_DATA plmd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plmd, CLIST_MULTI_DATA) {
	Status = (GetListData(plmd)->*pfn)(pReference);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    } END_EACH_CLIST_ITEM
exit:
    return(Status);
}

BOOL
CListMulti::CheckDupList(
    PVOID p
)
{
    PCLIST_MULTI_DATA plmd;

    FOR_EACH_CLIST_ITEM(this, plmd) {
	if(GetListData(plmd) == p) {
	   return(TRUE);
	}
    } END_EACH_CLIST_ITEM
    return(FALSE);
}

NTSTATUS 
CListMulti::AddList(
    PVOID p,
    CListMultiItem *plmi
)
{
    Assert(this);
    Assert(plmi);
    if(CheckDupList(p)) {
	return(STATUS_SUCCESS);
    }
    PCLIST_MULTI_DATA plmd = new CLIST_MULTI_DATA(p);
    if(plmd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    plmd->AddList(this);
    plmd->m_ldiItem.AddList(plmi);
    return(STATUS_SUCCESS);
}

NTSTATUS 
CListMulti::AddListEnd(
    PVOID p,
    CListMultiItem *plmi
)
{
    Assert(this);
    Assert(plmi);
    if(CheckDupList(p)) {
	return(STATUS_SUCCESS);
    }
    PCLIST_MULTI_DATA plmd = new CLIST_MULTI_DATA(p);
    if(plmd == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    plmd->AddListEnd(this);
    plmd->m_ldiItem.AddListEnd(plmi);
    return(STATUS_SUCCESS);
}

NTSTATUS 
CListMulti::AddListOrdered(
    PVOID p,
    CListMultiItem *plmi,
    LONG lFieldOffset
)
{
    PCLIST_MULTI_DATA plmd, plmdNew;
    ULONG ulOrder;

    ASSERT(!CheckDupList(p));
    ulOrder = *((PULONG)(((PCHAR)p) + lFieldOffset));

    plmdNew = new CLIST_MULTI_DATA(p);
    if(plmdNew == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }
    plmdNew->m_ldiItem.AddList(plmi);

    FOR_EACH_CLIST_ITEM(this, plmd) {
	if(ulOrder < *((PULONG)(((PCHAR)GetListData(plmd)) + lFieldOffset))) {
	    break;
	}
    } END_EACH_CLIST_ITEM

    InsertTailList(&plmd->m_le, &plmdNew->m_le);
    return(STATUS_SUCCESS);
}

VOID 
CListMulti::RemoveList(
    PVOID p
)
{
    PCLIST_MULTI_DATA plmd;

    Assert(this);
    FOR_EACH_CLIST_ITEM_DELETE(this, plmd, CLIST_MULTI_DATA) {
	if(GetListData(plmd) == p) {
	    delete plmd;
	}
    } END_EACH_CLIST_ITEM
}

VOID
CListMulti::JoinList(
    PCLIST_MULTI plm
)
{
    Assert(this);
    Assert(plm);
    ASSERT(this->m_leHead.Blink->Flink == &this->m_leHead);
    ASSERT(plm->m_leHead.Blink->Flink == &plm->m_leHead);
    ASSERT(this->m_leHead.Flink->Blink == &this->m_leHead);
    ASSERT(plm->m_leHead.Flink->Blink == &plm->m_leHead);

    if(!plm->IsLstEmpty()) {
	this->m_leHead.Blink->Flink = plm->m_leHead.Flink;
	plm->m_leHead.Flink->Blink = this->m_leHead.Blink;
	plm->m_leHead.Blink->Flink = &this->m_leHead;
	this->m_leHead.Blink = plm->m_leHead.Blink;
	InitializeListHead(&plm->m_leHead);
    }
}

//---------------------------------------------------------------------------
// CListMultiItem Class
//---------------------------------------------------------------------------

CListMultiItem::~CListMultiItem()
{
    PCLIST_MULTI_DATA plmd, plmdNext;

    for(plmd = CONTAINING_RECORD(GetListFirst(), CLIST_MULTI_DATA, m_ldiItem);
       !IsListEnd(&plmd->m_ldiItem);
        plmd = plmdNext) {

	Assert(plmd);
	plmdNext = CONTAINING_RECORD(
	  GetListNext(&plmd->m_ldiItem),
	  CLIST_MULTI_DATA,
	  m_ldiItem);

	delete plmd;
    }
}

//---------------------------------------------------------------------------
// end of clist.cpp
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\ci.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   ci.cpp
//
//  Description:
//
//	Connect Info Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CConnectInfo::Create(
    PCONNECT_NODE pConnectNode,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PCONNECT_INFO pConnectInfoNext,
    PGRAPH_PIN_INFO pGraphPinInfo,
    ULONG ulFlagsCurrent,
    PGRAPH_NODE pGraphNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCONNECT_INFO pConnectInfo;

    Assert(pGraphNode);
    Assert(pConnectNode);

    FOR_EACH_LIST_ITEM(&pGraphNode->lstConnectInfo, pConnectInfo) {

	if(pConnectInfo->pPinInfoSource ==
	   pConnectNode->pPinNodeSource->pPinInfo &&
	   pConnectInfo->pPinInfoSink ==
	   pConnectNode->pPinNodeSink->pPinInfo) {

	    if(pConnectInfo->pConnectInfoNext->IsSameGraph(pConnectInfoNext)) {
		pConnectInfo->AddRef();
		ASSERT(NT_SUCCESS(Status));
		goto exit;
	    }
	}

    } END_EACH_LIST_ITEM

    pConnectInfo = new CONNECT_INFO(
      pConnectNode,
      pConnectInfoNext,
      pGraphPinInfo,
      pGraphNode);

    if(pConnectInfo == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    if(ulFlagsCurrent & LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY) {
	BOOL fReserve = FALSE;

	if(pLogicalFilterNode->GetOrder() <= ORDER_MIXER) {
	    pConnectInfo->ulFlags |= CI_FLAGS_LIMIT_FORMAT;
	}
	else {
	    pConnectInfo->ulFlags |= CI_FLAGS_CONNECT_TOP_DOWN;
	}
	//
	// Reserve pins for the filters below the mixer or splitter (if one)
	//
	if(ulFlagsCurrent & LFN_FLAGS_CONNECT_CAPTURE) {
	    if(pLogicalFilterNode->GetOrder() <= ORDER_SPLITTER) {
		pConnectInfo->ulFlags |= CI_FLAGS_REUSE_FILTER_INSTANCE;
		if(gcSplitters > 0) {
		    fReserve = TRUE;
		}
	    }
	}
	if(ulFlagsCurrent & LFN_FLAGS_CONNECT_RENDER) {
	    if(pLogicalFilterNode->GetOrder() <= ORDER_MIXER) {
		pConnectInfo->ulFlags |= CI_FLAGS_REUSE_FILTER_INSTANCE;
		if(gcMixers > 0) {
		    fReserve = TRUE;
		}
	    }
	}
	if(fReserve) {
	    Status = pConnectInfo->ReservePinInstance(pGraphNode);
	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	}
    }
    DPF2(80, "CConnectInfo::Create %08x GN %08x", pConnectInfo, pGraphNode);
exit:
    pConnectNode->pConnectInfo = pConnectInfo;
    return(Status);
}

CConnectInfo::CConnectInfo(
    PCONNECT_NODE pConnectNode,
    PCONNECT_INFO pConnectInfoNext,
    PGRAPH_PIN_INFO pGraphPinInfo,
    PGRAPH_NODE pGraphNode
)
{
    Assert(pGraphNode);
    Assert(pConnectNode);

    this->pPinInfoSource = pConnectNode->pPinNodeSource->pPinInfo;
    this->pPinInfoSink = pConnectNode->pPinNodeSink->pPinInfo;
    this->pGraphPinInfo = pGraphPinInfo;
    pGraphPinInfo->AddRef();
    this->pConnectInfoNext = pConnectInfoNext;
    pConnectInfoNext->AddRef();
    AddList(&pGraphNode->lstConnectInfo);
    AddRef();
    DPF2(80, "CConnectInfo: %08x GN %08x", this, pGraphNode);
}

CConnectInfo::~CConnectInfo(
)
{
    DPF1(80, "~CConnectInfo: %08x", this);
    Assert(this);
    RemoveList();
    pGraphPinInfo->Destroy();
    pConnectInfoNext->Destroy();
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CConnectInfo::Dump(
)
{
    // .sgv or .so
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("CI: %08x cRef %08x CNI %08x%s%s%s%s\n",
	  this,
	  cReference,
	  pConnectNodeInstance,
	  IsTopDown() ? " TOP_DOWN" : "",
	  IsLimitFormat() ? " LIMIT" : "",
	  IsReuseFilterInstance() ? " REUSE" : "",
	  IsPinInstanceReserved() ? " RESERVED" : "");
    }
    // .sg
    else {
	dprintf("CI: %08x CNI %08x P%-2d C%-d%s%s%s%s\n",
	  this,
	  pConnectNodeInstance,
	  GetPinInstances()->PossibleCount,
	  GetPinInstances()->CurrentCount,
	  IsTopDown() ? " TOP_DOWN" : "",
	  IsLimitFormat() ? " LIMIT" : "",
	  IsReuseFilterInstance() ? " REUSE" : "",
	  IsPinInstanceReserved() ? " RESERVED" : "");
    }
    dprintf("    Source: %08x #%d %s\n",
      pPinInfoSource,
      pPinInfoSource->PinId,
      pPinInfoSource->pFilterNode->DumpName());
    dprintf("    Sink:   %08x #%d %s\n",
      pPinInfoSink,
      pPinInfoSink->PinId,
      pPinInfoSink->pFilterNode->DumpName());

    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	pGraphPinInfo->Dump();
    }
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\clist.h ===
//---------------------------------------------------------------------------
//
//  Module:   		clist.h
//
//  Description:	list classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Macros
//---------------------------------------------------------------------------

#define	FOR_EACH_LIST_ITEM(pl, p) { \
    PCLIST_ITEM pli; \
    for(pli = (pl)->GetListFirst(); \
      !(pl)->IsListEnd(pli);  \
      pli = (pl)->GetListNext(pli)) { \
	p = (pl)->GetListData(pli); \
	(pl)->AssertList(p);

#define	FOR_EACH_LIST_ITEM_DELETE(pl, p) { \
    PCLIST_ITEM pli, pliNext; \
    for(pli = (pl)->GetListFirst(); !(pl)->IsListEnd(pli); pli = pliNext) { \
	pliNext = (pl)->GetListNext(pli); \
	p = (pl)->GetListData(pli); \
	(pl)->AssertList(p);

#define DELETE_LIST_ITEM(pl) \
    pliNext = (pl)->GetListFirst();

#define	FOR_EACH_LIST_ITEM_BACKWARD(pl, p) { \
    PCLIST_ITEM pli; \
    for(pli = (pl)->GetListLast(); \
      !(pl)->IsListEnd(pli);  \
      pli = (pl)->GetListPrevious(pli)) { \
	p = (pl)->GetListData(pli); \
	(pl)->AssertList(p);

#define END_EACH_LIST_ITEM } }

//---------------------------------------------------------------------------

#define	FOR_EACH_CLIST_ITEM(pl, p) { \
    for(p = (pl)->GetListFirst(); \
      !(pl)->IsListEnd(p); \
      p = (pl)->GetListNext(p)) { \
	Assert(p);

#define	FOR_EACH_CLIST_ITEM_DELETE(pl, p, type) { \
    type *pNext; \
    for(p = (pl)->GetListFirst(); !(pl)->IsListEnd(p); p = pNext) { \
	Assert(p); \
	pNext = (pl)->GetListNext(p);

#define END_EACH_CLIST_ITEM } }

//---------------------------------------------------------------------------
// Abstract List Classes
//---------------------------------------------------------------------------

typedef class CList : public CObj
{
public:
} CLIST, *PCLIST;

typedef class CListItem : public CObj
{
public:
} CLIST_ITEM, *PCLIST_ITEM;

//---------------------------------------------------------------------------
// Singlely Linked List
//---------------------------------------------------------------------------

typedef class CListSingle : public CList
{
    friend class CListSingleItem;
public:
    CListSingle()
    {
        m_plsiHead = NULL;
    };
    VOID DestroyList()
    {
        m_plsiHead = NULL;
    };
    BOOL IsLstEmpty()
    {
        Assert(this);
        return(m_plsiHead == NULL);
    };
    CListSingleItem *GetListFirst()
    {
        Assert(this);
        return(m_plsiHead);
    };
    BOOL IsListEnd(CListSingleItem *plsi)
    {
        Assert(this);
        return(plsi == NULL);
    };
    CListSingleItem *GetListData(CListSingleItem *plsi)
    {
        return plsi;
    }
    CListSingleItem *GetListNext(CListSingleItem *plsi);
    CListSingleItem **GetListEnd();
    ENUMFUNC EnumerateList(
        IN ENUMFUNC (CListSingleItem::*pfn)(
        )
    );
    ENUMFUNC EnumerateList(
        IN ENUMFUNC (CListSingleItem::*pfn)(
            PVOID pReference
        ),
        PVOID pReference
    );
    void ReverseList();
protected:
    CListSingleItem *m_plsiHead;
public:
    DefineSignature(0x2048534C);		// LSH

} CLIST_SINGLE, *PCLIST_SINGLE;

//---------------------------------------------------------------------------

typedef class CListSingleItem : public CListItem
{
    friend class CListData;
    friend class CListSingle;
public:
    CListSingleItem()
    {
        m_plsiNext = NULL;
    };
    VOID AddList(CListSingle *pls)
    {
        Assert(pls);
        Assert(this);
        ASSERT(m_plsiNext == NULL);
        m_plsiNext = pls->m_plsiHead;
        pls->m_plsiHead = this;
    };
    VOID AddListEnd(CListSingle *pls)
    {
        Assert(pls);
        Assert(this);
        ASSERT(m_plsiNext == NULL);
        *(pls->GetListEnd()) = this;
    };
    VOID RemoveList(CListSingle *pls);
private:
    CListSingleItem *m_plsiNext;
public:
    DefineSignature(0x2049534C);		// LSI

} CLIST_SINGLE_ITEM, *PCLIST_SINGLE_ITEM;

inline CListSingleItem *
CListSingle::GetListNext(CListSingleItem *plsi)
{
    Assert(this);
    return plsi->m_plsiNext;
}

//---------------------------------------------------------------------------
// Doublely Linked List
//---------------------------------------------------------------------------

typedef class CListDouble : public CList
{
    friend class CListDoubleItem;
public:
    CListDouble()
    {
	InitializeListHead(&m_leHead);
    };
    VOID DestroyList()
    {
    };
    BOOL IsLstEmpty()
    {
	Assert(this);
	return IsListEmpty(&m_leHead);
    };
    ULONG CountList();
    CListDoubleItem *GetListFirst();
    CListDoubleItem *GetListLast();
    BOOL IsListEnd(CListDoubleItem *pldi);
    CListDoubleItem *GetListNext(CListDoubleItem *pldi);
    CListDoubleItem *GetListPrevious(CListDoubleItem *pldi);
    CListDoubleItem *GetListData(CListDoubleItem *pldi)
    {
	return pldi;
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (CListDoubleItem::*pfn)(
	)
    );
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (CListDoubleItem::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    );
protected:
    LIST_ENTRY m_leHead;
public:
    DefineSignature(0x2048424C);		// LBH

} CLIST_DOUBLE, *PCLIST_DOUBLE;

//---------------------------------------------------------------------------

typedef class CListDoubleItem : public CListItem
{
    friend class CListDouble;
public:
    VOID AddList(CListDouble *plb)
    {
	Assert(plb);
	Assert(this);
	ASSERT(m_le.Flink == NULL);
	ASSERT(m_le.Blink == NULL);
	InsertHeadList(&plb->m_leHead, &m_le);
    };
    VOID AddListEnd(CListDouble *plb)
    {
	Assert(plb);
	Assert(this);
	ASSERT(m_le.Flink == NULL);
	ASSERT(m_le.Blink == NULL);
	InsertTailList(&plb->m_leHead, &m_le);
    };
    VOID RemoveList()
    {
	Assert(this);
	ASSERT(m_le.Flink != NULL);
	ASSERT(m_le.Blink != NULL);
	RemoveEntryList(&m_le);
	m_le.Flink = NULL;
	m_le.Blink = NULL;
    };
    VOID RemoveListCheck()
    {
	Assert(this);
	if(m_le.Flink != NULL) {
	    RemoveList();
	}
    };
protected:
    LIST_ENTRY m_le;
public:
    DefineSignature(0x2049424C);		// LBI

} CLIST_DOUBLE_ITEM, *PCLIST_DOUBLE_ITEM;

inline CListDoubleItem *
CListDouble::GetListFirst()
{
    Assert(this);
    ASSERT(m_leHead.Flink != NULL);
    return CONTAINING_RECORD(m_leHead.Flink, CListDoubleItem, m_le);
}

inline CListDoubleItem *
CListDouble::GetListLast()
{
    Assert(this);
    ASSERT(m_leHead.Blink != NULL);
    return CONTAINING_RECORD(m_leHead.Blink, CListDoubleItem, m_le);
}

inline BOOL 
CListDouble::IsListEnd(CListDoubleItem *pldi)
{
    Assert(this);
    return(&pldi->m_le == &m_leHead);
}

inline CListDoubleItem *
CListDouble::GetListNext(CListDoubleItem *pldi)
{
    Assert(this);
    ASSERT(pldi->m_le.Flink != NULL);
    return CONTAINING_RECORD(pldi->m_le.Flink, CListDoubleItem, m_le);
}

inline CListDoubleItem *
CListDouble::GetListPrevious(CListDoubleItem *pldi)
{
    Assert(this);
    ASSERT(pldi->m_le.Blink != NULL);
    return CONTAINING_RECORD(pldi->m_le.Blink, CListDoubleItem, m_le);
}

//---------------------------------------------------------------------------
// Linked List of Data Pointers
//---------------------------------------------------------------------------

class CListDataItem;

typedef class CListDataData : public CListSingleItem
{
    friend class CListData;
public:
    CListDataData(
       CListDataItem *pldi
    )
    {
	m_pldiData = pldi;
    };
    CListDataData(
       PVOID p
    )
    {
	m_pldiData = (CListDataItem *)p;
    };
private:
    CListDataItem *m_pldiData;
public:
    DefineSignature(0x2044444C);		// LDD

} CLIST_DATA_DATA, *PCLIST_DATA_DATA;

//---------------------------------------------------------------------------

typedef class CListData : public CListSingle
{
public:
    ~CListData()
    {
	CListData::DestroyList();
    };
    VOID DestroyList();
    ULONG CountList();
    CListDataData *GetListFirst()
    {
	Assert(this);
	return (CListDataData *)CListSingle::GetListFirst();
    };
    CListDataData *GetListNext(CListDataData *pldd)
    {
	Assert(this);
	return (CListDataData *)CListSingle::GetListNext(pldd);
    };
    CListDataItem *GetListData(CListDataData *pldd)
    {
	Assert(this);
	return pldd->m_pldiData;
    };
    CListDataItem *GetListFirstData()
    {
	Assert(this);
	return GetListData(GetListFirst());
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (CListDataItem::*pfn)(
	)
    );
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (CListDataItem::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    );
    NTSTATUS CreateUniqueList(
	OUT CListData *pldOut,
	IN PVOID (*GetFunction)(
	    IN PVOID pData
	),
	IN BOOL (*CompareFunction)(
	    IN PVOID pIn,
	    IN PVOID pOut
	)
    );
    BOOL CheckDupList(
	PVOID p
    );
    NTSTATUS AddList(
	PVOID p
    );
    NTSTATUS AddListDup(
	PVOID p
    );
    NTSTATUS AddListEnd(
	PVOID p
    );
    NTSTATUS AddListOrdered(
	PVOID p,
	LONG lFieldOffset
    );
    VOID RemoveList(
	PVOID p
    );
    VOID JoinList(
	CListData *pld
    );
private:
    CListDataData **GetListEnd()
    {
       return((CListDataData **)CListSingle::GetListEnd());
    };
public:
    DefineSignature(0x2048444C);		// LDH

} CLIST_DATA, *PCLIST_DATA;

//---------------------------------------------------------------------------

typedef class CListDataItem : public CListItem
{
public: 
    ENUMFUNC Destroy()
    {
	delete this;
	return(STATUS_CONTINUE);
    };
    BOOL CheckDupList(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	return(pld->CheckDupList((PVOID)this));
    };
    NTSTATUS AddList(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	return(pld->AddList((PVOID)this));
    };
    NTSTATUS AddListDup(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	return(pld->AddListDup((PVOID)this));
    };
    NTSTATUS AddListEnd(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	return(pld->AddListEnd((PVOID)this));
    };
    VOID RemoveList(
	PCLIST_DATA pld
    )
    {
	Assert(this);
	pld->RemoveList((PVOID)this);
    };
    DefineSignature(0x2049444C);		// LDI

} CLIST_DATA_ITEM, *PCLIST_DATA_ITEM;

typedef PVOID (*UNIQUE_LIST_PFN)(PVOID);
typedef BOOL (*UNIQUE_LIST_PFN2)(PVOID, PVOID);

//---------------------------------------------------------------------------
// Multi-Headed Linked List
//---------------------------------------------------------------------------

typedef class CListMultiData : public CListDoubleItem
{
    friend class CListMulti;
    friend class CListMultiItem;
public:
    CListMultiData(
	PVOID p
    )
    {
	m_plmiData = (CListMultiItem *)p;
    };
    ~CListMultiData()
    {
	CListMultiData::RemoveList();
    };
    VOID RemoveList()
    {
	Assert(this);
	CListDoubleItem::RemoveList();
	m_ldiItem.RemoveList();
    };
private:
    CListDoubleItem m_ldiItem;
    CListMultiItem *m_plmiData;
public:
    DefineSignature(0x20444d4C);		// LMD

} CLIST_MULTI_DATA, *PCLIST_MULTI_DATA;

//---------------------------------------------------------------------------

typedef class CListMulti : public CListDouble
{
    friend class CListMultiItem;
public:
    ~CListMulti()
    {
	CListMulti::DestroyList();
    };
    VOID DestroyList();
    ENUMFUNC EnumerateList(
	ENUMFUNC (CListMultiItem::*pfn)(
	)
    );
    ENUMFUNC EnumerateList(
	ENUMFUNC (CListMultiItem::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    );
    CListMultiData *GetListFirst()
    {
	Assert(this);
	return (CListMultiData *)CListDouble::GetListFirst();
    };
    CListMultiData *GetListLast()
    {
	Assert(this);
	return (CListMultiData *)CListDouble::GetListLast();
    };
    BOOL IsListEnd(CListMultiData *plmd)
    {
	Assert(this);
	return CListDouble::IsListEnd(plmd);
    };
    CListMultiData *GetListNext(CListMultiData *plmd)
    {
	Assert(this);
	return (CListMultiData *)CListDouble::GetListNext(plmd);
    };
    CListMultiData *GetListPrevious(CListMultiData *plmd)
    {
	Assert(this);
	return (CListMultiData *)CListDouble::GetListPrevious(plmd);
    };
    CListMultiItem *GetListData(CListMultiData *plmd)
    { 
	Assert(this);
	return plmd->m_plmiData;
    };
    CListMultiItem *GetListFirstData()
    {
	Assert(this);
	return GetListData(GetListFirst());
    };
    BOOL CheckDupList(
	PVOID p
    );
    NTSTATUS AddList(
	PVOID p,
	CListMultiItem *plmi
    );
    NTSTATUS AddList(
	CListMultiItem *plmi
    )
    {
	Assert(this);
	return(AddList((PVOID)plmi, plmi));
    };
    NTSTATUS AddListEnd(
	PVOID p,
	CListMultiItem *plmi
    );
    NTSTATUS AddListEnd(
	CListMultiItem *plmi
    )
    {
	Assert(this);
	return(AddListEnd((PVOID)plmi, plmi));
    };
    NTSTATUS AddListOrdered(
	PVOID p,
	CListMultiItem *plmi,
	LONG lFieldOffset
    );
    NTSTATUS AddListOrdered(
	CListMultiItem *plmi,
	LONG lFieldOffset
    )
    {
	Assert(this);
	return(AddListOrdered((PVOID)plmi, plmi, lFieldOffset));
    };
    VOID RemoveList(
	PVOID p
    );
    VOID JoinList(
	CListMulti *plm
    );
    DefineSignature(0x20484D4C);		// LMH

} CLIST_MULTI, *PCLIST_MULTI;

//---------------------------------------------------------------------------

typedef class CListMultiItem : public CListDouble
{
public:
    ~CListMultiItem();
    BOOL CheckDupList(
	PCLIST_MULTI plm
    )
    {
	return(plm->CheckDupList((PVOID)this));
    };
    NTSTATUS AddList(
	PCLIST_MULTI plm
    )
    {
	Assert(plm);
	Assert(this);
	return(plm->AddList(this));
    };
    NTSTATUS AddListEnd(
	PCLIST_MULTI plm
    )
    {
	Assert(plm);
	Assert(this);
	return(plm->AddListEnd(this));
    };
    NTSTATUS AddListOrdered(
	PCLIST_MULTI plm,
	LONG lFieldOffset
    )
    {
	Assert(plm);
	Assert(this);
	return(plm->AddListOrdered(this, lFieldOffset));
    };
    VOID RemoveList(
	PCLIST_MULTI plm
    )
    {
	Assert(this);
	plm->RemoveList((PVOID)this);
    };
    DefineSignature(0x20494d4C);		// LMI

} CLIST_MULTI_ITEM, *PCLIST_MULTI_ITEM;

//---------------------------------------------------------------------------
//  Templates
//---------------------------------------------------------------------------

template<class TYPE>
class ListSingleDestroy : public CListSingle
{
public:
    ~ListSingleDestroy()
    {
	ListSingleDestroy::DestroyList();
    };
    VOID DestroyList()
    {
	ListSingleDestroy::EnumerateList(TYPE::Destroy);
	CListSingle::DestroyList();
    };
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (TYPE::*pfn)(
	)
    )
    {
	return CListSingle::EnumerateList(
	  (ENUMFUNC (CListSingleItem::*)())pfn);
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (TYPE::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    )
    {
	return CListSingle::EnumerateList(
	  (ENUMFUNC (CListSingleItem::*)(PVOID))pfn,
	  pReference);
    };
    PCLIST_ITEM GetListFirst()
    {
	return CListSingle::GetListFirst();
    };
    BOOL IsListEnd(PCLIST_ITEM pli)
    {
	return CListSingle::IsListEnd((CListSingleItem *)pli);
    };
    PCLIST_ITEM GetListNext(PCLIST_ITEM pli)
    {
	return CListSingle::GetListNext((CListSingleItem *)pli);
    };
    TYPE *GetListData(PCLIST_ITEM pli)
    {
	return (TYPE *)CListSingle::GetListData((CListSingleItem *)pli);
    };
    TYPE *GetListFirstData()
    {
	return (TYPE *)CListSingle::GetListData(CListSingle::GetListFirst());
    };
#ifdef DEBUG
    ENUMFUNC Dump()
    {
	return(ListSingleDestroy::EnumerateList(TYPE::Dump));
    };
    ENUMFUNC DumpAddress()
    {
	return(ListSingleDestroy::EnumerateList(TYPE::DumpAddress));
    };
#endif
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

template<class TYPE>
class ListDouble : public CListDouble
{
public:
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (TYPE::*pfn)()
    )
    {
	return CListDouble::EnumerateList(
	  (ENUMFUNC (CListDoubleItem::*)())pfn);
    };
    ENUMFUNC EnumerateList(
	IN ENUMFUNC (TYPE::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    )
    {
	return CListDouble::EnumerateList(
	  (ENUMFUNC (CListDoubleItem::*)(PVOID))pfn,
	  pReference);
    };
    PCLIST_ITEM GetListFirst()
    {
	return CListDouble::GetListFirst();
    };
    PCLIST_ITEM GetListLast()
    {
	return CListDouble::GetListLast();
    };
    BOOL IsListEnd(PCLIST_ITEM pli)
    {
	return CListDouble::IsListEnd((CListDoubleItem *)pli);
    };
    PCLIST_ITEM GetListNext(PCLIST_ITEM pli)
    {
	return CListDouble::GetListNext((CListDoubleItem *)pli);
    };
    PCLIST_ITEM GetListPrevious(PCLIST_ITEM pli)
    {
	return CListDouble::GetListPrevious((CListDoubleItem *)pli);
    };
    TYPE *GetListData(PCLIST_ITEM pli)
    {
	return (TYPE *)CListDouble::GetListData((CListDoubleItem *)pli);
    };
#ifdef NOT_WORKING
    TYPE *GetListFirstData()
    {
	return (TYPE *)CListDouble::GetListData(CListDouble::GetListFirst());
    };
#endif
#ifdef DEBUG
    ENUMFUNC Dump()
    {
	return(ListDouble::EnumerateList(TYPE::Dump));
    };
    ENUMFUNC DumpAddress()
    {
	return(ListDouble::EnumerateList(TYPE::DumpAddress));
    };
#endif
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListDoubleDestroy : public ListDouble<TYPE>
{
public:
    ~ListDoubleDestroy()
    {
	ListDoubleDestroy::DestroyList();
    };
    VOID DestroyList()
    {
	ListDoubleDestroy::EnumerateList(TYPE::Destroy);
	CListDouble::DestroyList();
    };
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListDoubleField : public CListDouble
{
public:
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    CListItem *GetListFirst()
    {
	return (CListItem *)CONTAINING_RECORD(
	  CListDouble::GetListFirst(), TYPE, ldiNext);
    };
    BOOL IsListEnd(CListItem *pli)
    {
	return CListDouble::IsListEnd(&((TYPE *)pli)->ldiNext);
    };
    CListItem *GetListNext(CListItem *pli)
    {
	return (CListItem *)CONTAINING_RECORD(
	  CListDouble::GetListNext(&((TYPE *)pli)->ldiNext), TYPE, ldiNext);
    };
    TYPE *GetListData(CListItem *pli)
    {
	return CONTAINING_RECORD(
	  CListDouble::GetListData(&((TYPE *)pli)->ldiNext), TYPE, ldiNext);
    };
#ifdef DEBUG
    ENUMFUNC Dump()
    {
	TYPE *p;
	FOR_EACH_LIST_ITEM(this, p) {
	    p->Dump();
	} END_EACH_LIST_ITEM
	return(STATUS_CONTINUE);
    };
    ENUMFUNC DumpAddress()
    {
	TYPE *p;
	FOR_EACH_LIST_ITEM(this, p) {
	    p->DumpAddress();
	} END_EACH_LIST_ITEM
	return(STATUS_CONTINUE);
    };
#endif
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

template<class TYPE>
class ListDataAssertLess : public CListData
{
public:
    VOID AssertList(TYPE *p)
    {
    };
    PCLIST_ITEM GetListFirst()
    {
	return CListData::GetListFirst();
    };
    BOOL IsListEnd(PCLIST_ITEM pli)
    {
	return CListData::IsListEnd((CListDataData *)pli);
    };
    PCLIST_ITEM GetListNext(PCLIST_ITEM pli)
    {
	return CListData::GetListNext((CListDataData *)pli);
    };
    TYPE *GetListData(PCLIST_ITEM pli)
    {
	return (TYPE *)CListData::GetListData((CListDataData *)pli);
    };
    TYPE *GetListFirstData()
    {
	return (TYPE *)CListData::GetListFirstData();
    };
    NTSTATUS AddList(
	TYPE *p
    )
    {
	return CListData::AddList((PVOID)p);
    };
    NTSTATUS AddListDup(
	TYPE *p
    )
    {
	return CListData::AddListDup((PVOID)p);
    };
    NTSTATUS AddListEnd(
	TYPE *p
    )
    {
	return CListData::AddListEnd((PVOID)p);
    };
    NTSTATUS AddListOrdered(
	TYPE *p,
	LONG lFieldOffset
    )
    {
	return CListData::AddListOrdered((PVOID)p, lFieldOffset);
    };
    VOID RemoveList(
	TYPE *p
    )
    {
	CListData::RemoveList((PVOID)p);
    };
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListData : public ListDataAssertLess<TYPE>
{
public:
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    ENUMFUNC EnumerateList(
	ENUMFUNC (TYPE::*pfn)()
    ) 
    {
	return CListData::EnumerateList((ENUMFUNC (CListDataItem::*)())pfn);
    };
    ENUMFUNC EnumerateList(
	ENUMFUNC (TYPE::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    ) 
    {
	return CListData::EnumerateList(
	  (ENUMFUNC (CListDataItem::*)(PVOID))pfn,
	  pReference);
    };
#ifdef DEBUG
    ENUMFUNC Dump()
    {
	return(ListData::EnumerateList(TYPE::Dump));
    };
    ENUMFUNC DumpAddress()
    {
	return(ListData::EnumerateList(TYPE::DumpAddress));
    };
#endif
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListDataDestroy : public ListData<TYPE>
{
public:
    ~ListDataDestroy()
    {
	ListDataDestroy::DestroyList();
    };
    VOID DestroyList()
    {
	ListDataDestroy::EnumerateList(TYPE::Destroy);
	CListData::DestroyList();
    };
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

template<class TYPE>
class ListMulti : public CListMulti
{
public:
    VOID AssertList(TYPE *p)
    {
	Assert(p);
    };
    PCLIST_ITEM GetListFirst()
    {
	return CListMulti::GetListFirst();
    };
    PCLIST_ITEM GetListLast()
    {
	return CListMulti::GetListLast();
    };
    BOOL IsListEnd(PCLIST_ITEM pli)
    {
	return CListMulti::IsListEnd((CListMultiData *)pli);
    };
    PCLIST_ITEM GetListNext(PCLIST_ITEM pli)
    {
	return CListMulti::GetListNext((CListMultiData *)pli);
    };
    PCLIST_ITEM GetListPrevious(PCLIST_ITEM pli)
    {
	return CListMulti::GetListPrevious((CListMultiData *)pli);
    };
    TYPE *GetListData(PCLIST_ITEM pli)
    {
	return (TYPE *)CListMulti::GetListData((CListMultiData *)pli);
    };
    TYPE *GetListFirstData()
    {
	return (TYPE *)CListMulti::GetListFirstData();
    };
    ENUMFUNC EnumerateList(
	ENUMFUNC (TYPE::*pfn)()
    ) 
    {
	return CListMulti::EnumerateList((ENUMFUNC (CListMultiItem::*)())pfn);
    };
    ENUMFUNC EnumerateList(
	ENUMFUNC (TYPE::*pfn)(
	    PVOID pReference
	),
	PVOID pReference
    ) 
    {
	return CListMulti::EnumerateList(
	  (ENUMFUNC (CListMultiItem::*)(PVOID))pfn,
	  pReference);
    };
#ifdef DEBUG
    ENUMFUNC Dump()
    {
	return(ListMulti::EnumerateList(TYPE::Dump));
    };
    ENUMFUNC DumpAddress()
    {
	return(ListMulti::EnumerateList(TYPE::DumpAddress));
    };
#endif
};

//---------------------------------------------------------------------------

template<class TYPE>
class ListMultiDestroy : public ListMulti<TYPE>
{
public:
    ~ListMultiDestroy()
    {
	ListMultiDestroy::DestroyList();
    };
    VOID DestroyList()
    {
	ListMultiDestroy::EnumerateList(TYPE::Destroy);
	CListMulti::DestroyList();
    };
};

//---------------------------------------------------------------------------
//  End of File: clist.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\cn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   cn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#ifdef DEBUG
PLIST_CONNECT_NODE gplstConnectNode = NULL;
#endif

//---------------------------------------------------------------------------

NTSTATUS
CConnectNode::Create(
    PCONNECT_NODE *ppConnectNode,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PCONNECT_NODE pConnectNodeNext,
    PGRAPH_PIN_INFO pGraphPinInfo,
    PPIN_NODE pPinNode1,
    PPIN_NODE pPinNode2,
    ULONG ulFlagsCurrent,
    PGRAPH_NODE pGraphNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCONNECT_NODE pConnectNode;

    Assert(pPinNode1);
    Assert(pPinNode2);

    pConnectNode = new CConnectNode(pConnectNodeNext);
    if(pConnectNode == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
#ifdef DEBUG
    Status = gplstConnectNode->AddList(pConnectNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
#endif
    switch(pPinNode1->pPinInfo->Communication) {
	case KSPIN_COMMUNICATION_BOTH:
	    switch(pPinNode2->pPinInfo->Communication) {
		case KSPIN_COMMUNICATION_SINK:
		    pConnectNode->pPinNodeSource = pPinNode1;
		    pConnectNode->pPinNodeSink = pPinNode2;
		    break;
		case KSPIN_COMMUNICATION_BOTH:
		case KSPIN_COMMUNICATION_SOURCE:
		    pConnectNode->pPinNodeSource = pPinNode2;
		    pConnectNode->pPinNodeSink = pPinNode1;
		    break;
		default:
		    ASSERT(FALSE);
		    Status = STATUS_INVALID_PARAMETER;
		    goto exit;
	    }
	    break;
	case KSPIN_COMMUNICATION_SINK:
	    pConnectNode->pPinNodeSink = pPinNode1;
	    pConnectNode->pPinNodeSource = pPinNode2;
	    ASSERT(
	      pPinNode2->pPinInfo->Communication == KSPIN_COMMUNICATION_BOTH ||
	      pPinNode2->pPinInfo->Communication == KSPIN_COMMUNICATION_SOURCE);
	    break;
	case KSPIN_COMMUNICATION_SOURCE:
	    pConnectNode->pPinNodeSink = pPinNode2;
	    pConnectNode->pPinNodeSource = pPinNode1;
	    ASSERT(
	      pPinNode2->pPinInfo->Communication == KSPIN_COMMUNICATION_SINK ||
	      pPinNode2->pPinInfo->Communication == KSPIN_COMMUNICATION_BOTH);
	    break;
	default:
	    ASSERT(FALSE);
	    Status = STATUS_INVALID_PARAMETER;
	    goto exit;
    }
    Status = CConnectInfo::Create(
      pConnectNode, 
      pLogicalFilterNode,
      pConnectNodeNext->GetConnectInfo(),
      pGraphPinInfo,
      ulFlagsCurrent,
      pGraphNode);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    if(pLogicalFilterNode->GetFlags() & LFN_FLAGS_NO_BYPASS) {
	Status = pGraphNode->lstLogicalFilterNodeNoBypass.AddList(
          pLogicalFilterNode,
	  pConnectNode);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
    DPF3(80, "CConnectNode::Create %08x PN %08x %08x",
      pConnectNode,
      pConnectNode->pPinNodeSink,
      pConnectNode->pPinNodeSource);
exit:
    if(!NT_SUCCESS(Status)) {
        if (pConnectNode) {
	    pConnectNode->Destroy();
        }
	pConnectNode = NULL;
    }
    *ppConnectNode = pConnectNode;
    return(Status);
}

CConnectNode::CConnectNode(
    PCONNECT_NODE pConnectNodeNext
)
{
    this->pConnectNodeNext = pConnectNodeNext;
    pConnectNodeNext->AddRef();
    AddRef();
    DPF1(80, "CConnectNode:%08x PN:%08x %08x", this);
}

CConnectNode::~CConnectNode(
)
{
    Assert(this);
    DPF1(80, "~CConnectNode: %08x", this);
    pConnectInfo->Destroy();
    pConnectNodeNext->Destroy();
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CConnectNode::Dump(
)
{
    Assert(this);
    dprintf("CN: %08x cRef %08x CI %08x N %08x\n",
      this,
      cReference,
      pConnectInfo,
      pConnectNodeNext);
    dprintf("    Source:  %08x #%d %s\n",
      pPinNodeSource,
      pPinNodeSource->pPinInfo->PinId,
      pPinNodeSource->pPinInfo->pFilterNode->DumpName());
    dprintf("    Sink:    %08x #%d %s\n",
      pPinNodeSink,
      pPinNodeSink->pPinInfo->PinId,
      pPinNodeSink->pPinInfo->pFilterNode->DumpName());
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\cn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		cn.h
//
//  Description:	connect node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CConnectNode : public CListMultiItem
{
    friend class CConnectInfo;
private:
    CConnectNode(
	PCONNECT_NODE pConnectNodeNext
    );

    ~CConnectNode(
    );

public:
    static NTSTATUS
    Create(
	PCONNECT_NODE *ppConnectNode,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PCONNECT_NODE pConnectNodeNext,
	PGRAPH_PIN_INFO pGraphPinInfo,
	PPIN_NODE pPinNode1,
	PPIN_NODE pPinNode2,
	ULONG ulFlagsCurrent,
	PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    VOID
    AddRef(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ++cReference;
	}
    };

    VOID
    AddPinInstance(
    )
    {
	Assert(this);
	pConnectInfo->AddPinInstance();
    };

    VOID
    RemovePinInstance(
    )
    {
	Assert(this);
	pConnectInfo->RemovePinInstance();
    };

    BOOL
    IsPinInstances(
    )
    {
	Assert(this);
	return(pConnectInfo->IsPinInstances());
    };

    BOOL
    IsTopDown(
    )
    {
	Assert(this);
	return(pConnectInfo->IsTopDown());
    };

    BOOL
    IsLimitFormat(
    )
    {
	Assert(this);
	return(pConnectInfo->IsLimitFormat());
    };

    BOOL
    IsReuseFilterInstance(
    )
    {
	Assert(this);
	return(pConnectInfo->IsReuseFilterInstance());
    };

    BOOL
    IsPinInstanceReserved(
    )
    {
	Assert(this);
	return(pConnectInfo->IsPinInstanceReserved());
    };

    PCONNECT_NODE
    GetNextConnectNode(
    )
    {
	Assert(this);
	return(pConnectNodeNext);
    };

    PCONNECT_NODE_INSTANCE
    GetConnectNodeInstance(
    )
    {
	Assert(this);
	return(pConnectInfo->pConnectNodeInstance);
    };

    VOID
    SetConnectNodeInstance(
	PCONNECT_NODE_INSTANCE pConnectNodeInstance
    )
    {
	Assert(this);
	pConnectInfo->pConnectNodeInstance = pConnectNodeInstance;
    };

    PCONNECT_INFO
    GetConnectInfo(
    )
    {
        return(this == NULL ? NULL : this->pConnectInfo);
    };

#ifdef DEBUG
    ENUMFUNC Dump();
#endif

private:
    LONG cReference;
    PCONNECT_INFO pConnectInfo;
    PCONNECT_NODE pConnectNodeNext;
public:
    PPIN_NODE pPinNodeSource;
    PPIN_NODE pPinNodeSink;
    DefineSignature(0x20204e43);			// CN

} CONNECT_NODE, *PCONNECT_NODE;

//---------------------------------------------------------------------------

#ifdef DEBUG
typedef ListMulti<CONNECT_NODE> LIST_CONNECT_NODE, *PLIST_CONNECT_NODE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PLIST_CONNECT_NODE gplstConnectNode;
#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\cni.h ===
//---------------------------------------------------------------------------
//
//  Module:   		cni.h
//
//  Description:	Connect Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CConnectNodeInstance : public CListMultiItem
{
    friend class CStartNodeInstance;
private:
    CConnectNodeInstance(
        IN PCONNECT_NODE pConnectNode
    );

    ~CConnectNodeInstance(
    );

public:
    static NTSTATUS 
    Create(
        PSTART_NODE_INSTANCE pStartNodeInstance,
        PDEVICE_NODE pDeviceNode
    );

    VOID
    AddRef(
    )
    {
        Assert(this);
        ++cReference;
    };

    NTSTATUS
    AddListEnd(
        PCLIST_MULTI plm
    );

    ENUMFUNC
    Destroy(
    );

    BOOL
    IsTopDown(
    )
    {
        Assert(this);
        return(pConnectNode->IsTopDown());
    };

    NTSTATUS
    Connect(
        IN PWAVEFORMATEX pWaveFormatEx,
        IN PKSPIN_CONNECT pPinConnectDirect
    );

    NTSTATUS
    SetStateTopDown(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

    NTSTATUS 
    SetStateBottomUp(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

#ifdef DEBUG
    ENUMFUNC Dump();
    PKSPIN_CONNECT pPinConnect;
#endif

private:
    NTSTATUS
    AddList(			// don't use these list functions
        PCLIST_MULTI plm
    )
    {
        return(STATUS_NOT_IMPLEMENTED);
    };

    NTSTATUS 
    AddListOrdered(
        PCLIST_MULTI plm,
        LONG lFieldOffset
    )
    {
        return(STATUS_NOT_IMPLEMENTED);
    };

    VOID 
    RemoveList(
        PCLIST_MULTI plm
    )
    {
    };

    BOOL fRender;
    LONG cReference;
    PCONNECT_NODE pConnectNode;
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSource;
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSink;
    PPIN_NODE_INSTANCE pPinNodeInstanceSource;
    PPIN_NODE_INSTANCE pPinNodeInstanceSink;
public:
    DefineSignature(0x20494E43);		// CNI

} CONNECT_NODE_INSTANCE, *PCONNECT_NODE_INSTANCE;

//---------------------------------------------------------------------------

typedef ListMultiDestroy<CONNECT_NODE_INSTANCE> LIST_CONNECT_NODE_INSTANCE;
typedef LIST_CONNECT_NODE_INSTANCE *PLIST_CONNECT_NODE_INSTANCE;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
CreatePinConnect(
    PKSPIN_CONNECT *ppPinConnect,
    PCONNECT_NODE pConnectNode,
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSink,
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSource,
    PWAVEFORMATEX pWaveFormatExLimit
);

NTSTATUS
CreatePinIntersection(
    PKSPIN_CONNECT *ppPinConnect,
    PPIN_NODE pPinNode1,
    PPIN_NODE pPinNode2,
    PFILTER_NODE_INSTANCE pFilterNodeInstance1,
    PFILTER_NODE_INSTANCE pFilterNodeInstance2
);

NTSTATUS
CreateWaveFormatEx(
    PKSPIN_CONNECT *ppPinConnect,
    PCONNECT_NODE pConnectNode,
    PWAVEFORMATEX pWaveFormatExLimit
);

VOID 
WaveFormatFromAudioRange(
    PKSDATARANGE_AUDIO pDataRangeAudio,
    WAVEFORMATEX *pWavFormatEx
);

BOOL
LimitAudioRangeToWave(
    PWAVEFORMATEX pWaveFormatEx,
    PKSDATARANGE_AUDIO pDataRangeAudio
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\cobj.h ===
//---------------------------------------------------------------------------
//
//  Module:   		cobj.h
//
//  Description:	Base class definition
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//

//---------------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------------

#define ENUMFUNC 		NTSTATUS
#define STATUS_CONTINUE 	((NTSTATUS)-2)

//---------------------------------------------------------------------------
// Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Forward Reference Typedefs
//---------------------------------------------------------------------------

typedef class CShingleInstance *PSHINGLE_INSTANCE;
typedef class CFilterNode *PFILTER_NODE;
typedef class CDeviceNode *PDEVICE_NODE;
typedef class CLogicalFilterNode *PLOGICAL_FILTER_NODE;
typedef class CGraphNode *PGRAPH_NODE;
typedef class CGraphPinInfo *PGRAPH_PIN_INFO;
typedef class CStartInfo *PSTART_INFO;
typedef class CStartNode *PSTART_NODE;
typedef class CConnectInfo *PCONNECT_INFO;
typedef class CConnectNode *PCONNECT_NODE;
typedef class CPinInfo *PPIN_INFO;
typedef class CPinNode *PPIN_NODE;
typedef class CTopologyConnection *PTOPOLOGY_CONNECTION;
typedef class CTopologyNode *PTOPOLOGY_NODE;
typedef class CTopologyPin *PTOPOLOGY_PIN;
typedef class CGraphNodeInstance *PGRAPH_NODE_INSTANCE;
typedef class CStartNodeInstance *PSTART_NODE_INSTANCE;
typedef class CConnectNodeInstance *PCONNECT_NODE_INSTANCE;
typedef class CFilterNodeInstance *PFILTER_NODE_INSTANCE;
typedef class CPinNodeInstance *PPIN_NODE_INSTANCE;
typedef class CVirtualNodeData *PVIRTUAL_NODE_DATA;
typedef class CVirtualSourceData *PVIRTUAL_SOURCE_DATA;
typedef class CVirtualSourceLine *PVIRTUAL_SOURCE_LINE;
typedef class CClockInstance *PCLOCK_INSTANCE;
typedef class CParentInstance *PPARENT_INSTANCE;
typedef class CFilterInstance *PFILTER_INSTANCE;
typedef class CPinInstance *PPIN_INSTANCE;
typedef class CInstance *PINSTANCE;
typedef class CQueueWorkListData *PQUEUE_WORK_LIST_DATA;

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CObj
{
public:
#ifdef DEBUG
    virtual ENUMFUNC Dump() 
    {
	dprintf(" %08x", this);
	return(STATUS_CONTINUE);
    };
    virtual ENUMFUNC DumpAddress()
    {
	dprintf(" %08x", this);
	return(STATUS_CONTINUE);
    };
#endif
private:
} COBJ, *PCOBJ;

//---------------------------------------------------------------------------
//  End of File: cobj.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\clock.h ===
//
//  Module:   clock.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CClockInstance : public CInstance
{
public:
    CClockInstance(
	IN PPARENT_INSTANCE pParentInstance
    );

    static NTSTATUS
    ClockDispatchCreate(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

    static NTSTATUS
    ClockDispatchCreateKP(
	PCLOCK_INSTANCE pClockInstance,
	PKSCLOCK_CREATE pClockCreate
    );

    static NTSTATUS
    ClockDispatchIoControl(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp
    );

    static NTSTATUS
    ClockGetFunctionTable(
	IN PIRP pIrp,
	IN PKSPROPERTY pProperty,
	IN OUT PKSCLOCK_FUNCTIONTABLE pFunctionTable
    );

    static LONGLONG FASTCALL
    ClockGetTime(
	IN PFILE_OBJECT FileObject
    );

    static LONGLONG FASTCALL
    ClockGetPhysicalTime(
	IN PFILE_OBJECT FileObject
    );

    static LONGLONG FASTCALL
    ClockGetCorrelatedTime(
	IN PFILE_OBJECT FileObject,
	OUT PLONGLONG Time
    );

    static LONGLONG FASTCALL
    ClockGetCorrelatedPhysicalTime(
	IN PFILE_OBJECT FileObject,
	OUT PLONGLONG Time
    );
private:
    KSCLOCK_FUNCTIONTABLE FunctionTable;
    DefineSignature(0x494b4c43);			// CLKI

} CLOCK_INSTANCE, *PCLOCK_INSTANCE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\cni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   cni.cpp
//
//  Description:
//
//  Connect Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//  To Do:     Date   Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CConnectNodeInstance::CConnectNodeInstance(
    IN PCONNECT_NODE pConnectNode
)
{
    Assert(this);
    pConnectNode->AddPinInstance();
    pConnectNode->SetConnectNodeInstance(this);
    this->pConnectNode = pConnectNode;
}

CConnectNodeInstance::~CConnectNodeInstance(
)
{
    Assert(this);
    DPF1(95, "~CConnectNodeInstance: %08x", this);
    if(pConnectNode != NULL) {
        Assert(pConnectNode);
        pConnectNode->RemovePinInstance();
        if(pConnectNode->GetConnectNodeInstance() == this) {
            pConnectNode->SetConnectNodeInstance(NULL);
        }
    }
#ifdef DEBUG
    delete pPinConnect;
#endif
    pPinNodeInstanceSource->Destroy();
    pPinNodeInstanceSink->Destroy();
    pFilterNodeInstanceSource->Destroy();
    pFilterNodeInstanceSink->Destroy();
}

NTSTATUS
CConnectNodeInstance::Create(
    PSTART_NODE_INSTANCE pStartNodeInstance,
    PDEVICE_NODE pDeviceNode
)
{
    PFILTER_NODE_INSTANCE *ppFilterNodeInstancePrevious;
    PCONNECT_NODE_INSTANCE pConnectNodeInstance = NULL;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fReuseFilterInstance = TRUE;
    PCONNECT_NODE pConnectNode;

    pLogicalFilterNode =
      pStartNodeInstance->pStartNode->pPinNode->pLogicalFilterNode;
    ppFilterNodeInstancePrevious = &pStartNodeInstance->pFilterNodeInstance;

    for(pConnectNode = pStartNodeInstance->pStartNode->GetFirstConnectNode();
    pConnectNode != NULL;
    pConnectNode = pConnectNode->GetNextConnectNode()) {

    Assert(pLogicalFilterNode);
    Assert(pConnectNode);

    // Get existing connect node instance
    fReuseFilterInstance = pConnectNode->IsReuseFilterInstance();
    pConnectNodeInstance = pConnectNode->GetConnectNodeInstance();

    if(fReuseFilterInstance && pConnectNodeInstance != NULL) {
        Assert(pConnectNodeInstance);
        DPF4(100, "Existing CNI: %08x %d FNI Source: %08x FNI Sink %08x",
          pConnectNodeInstance,
          pConnectNodeInstance->cReference,
          pConnectNodeInstance->pFilterNodeInstanceSource,
          pConnectNodeInstance->pFilterNodeInstanceSink);
    }
    else {
        if(!pConnectNode->IsPinInstances()) {
        DPF1(90, "CCNI::Create: no instances CN %08x", pConnectNode);
        Status = STATUS_DEVICE_BUSY;
        goto exit;
        }
        pConnectNodeInstance = new CONNECT_NODE_INSTANCE(pConnectNode);
        if(pConnectNodeInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
        }

            pConnectNodeInstance->fRender = pStartNodeInstance->IsRender();
        Status = CFilterNodeInstance::Create(
          &pConnectNodeInstance->pFilterNodeInstanceSource,
          pLogicalFilterNode,
          pDeviceNode,
          fReuseFilterInstance);

        if(!NT_SUCCESS(Status)) {
        delete pConnectNodeInstance;
        goto exit;
        }
        Assert(pConnectNodeInstance->pFilterNodeInstanceSource);

        DPF4(100, "New CNI: %08x %d FNI Source: %08x FNI Sink %08x",
          pConnectNodeInstance,
          pConnectNodeInstance->cReference,
          pConnectNodeInstance->pFilterNodeInstanceSource,
          pConnectNodeInstance->pFilterNodeInstanceSink);
    }
    Status = pConnectNodeInstance->AddListEnd(
      &pStartNodeInstance->lstConnectNodeInstance);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    if(*ppFilterNodeInstancePrevious == NULL) {

        *ppFilterNodeInstancePrevious =
          pConnectNodeInstance->pFilterNodeInstanceSource;

        pConnectNodeInstance->pFilterNodeInstanceSource->AddRef();
    }
    ppFilterNodeInstancePrevious =
      &pConnectNodeInstance->pFilterNodeInstanceSink;

    pLogicalFilterNode = pConnectNode->pPinNodeSink->pLogicalFilterNode;
    }

    if(*ppFilterNodeInstancePrevious == NULL) {

    Assert(pLogicalFilterNode);
    Status = CFilterNodeInstance::Create(
      ppFilterNodeInstancePrevious,
      pLogicalFilterNode,
      pDeviceNode,
      fReuseFilterInstance);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(*ppFilterNodeInstancePrevious);
    }
exit:
    return(Status);
}

NTSTATUS
CConnectNodeInstance::AddListEnd(
    PCLIST_MULTI plm
)
{
    NTSTATUS Status;

    Status = CListMultiItem::AddListEnd(plm);
    if(NT_SUCCESS(Status)) {
        AddRef();
    }
    return(Status);
}

ENUMFUNC
CConnectNodeInstance::Destroy(
)
{
    if(this != NULL) {
        Assert(this);
        DPF1(95, "CConnectNodeInstance::Destroy: %08x", this);
        ASSERT(cReference > 0);

        if(--cReference == 0) {
            delete this;
        }
    }
    return(STATUS_CONTINUE);
}

NTSTATUS
CConnectNodeInstance::Connect(
    IN PWAVEFORMATEX pWaveFormatEx,
    IN PKSPIN_CONNECT pPinConnectDirect
)
{
    PKSPIN_CONNECT pPinConnect = NULL;
    BOOL fDeletePinConnect;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    Assert(pConnectNode);
    Assert(pFilterNodeInstanceSource);
    Assert(pFilterNodeInstanceSink);
    ASSERT(pFilterNodeInstanceSource->pFilterNode ==
      pConnectNode->pPinNodeSource->pPinInfo->pFilterNode);
    ASSERT(pFilterNodeInstanceSink->pFilterNode ==
      pConnectNode->pPinNodeSink->pPinInfo->pFilterNode);

    DPF3(90, "CCNI::Connect: CN  %08x #%d Source %s",
      pConnectNode,
      pConnectNode->pPinNodeSource->pPinInfo->PinId,
      pFilterNodeInstanceSource->pFilterNode->DumpName());

    DPF3(90, "CCNI::Connect: CNI %08x #%d Sink   %s",
      this,
      pConnectNode->pPinNodeSink->pPinInfo->PinId,
      pFilterNodeInstanceSink->pFilterNode->DumpName());

    // If the Connect is supplied to this function,
    // we should not delete it.
    //
    pPinConnect = pPinConnectDirect;
    fDeletePinConnect = (NULL == pPinConnect);

    if(pPinNodeInstanceSink != NULL || pPinNodeInstanceSource != NULL) {
        ASSERT(NT_SUCCESS(Status));
        goto exit;
    }
    ASSERT(pPinNodeInstanceSink == NULL && pPinNodeInstanceSource == NULL);

    if (NULL == pPinConnect) {
        Status = CreatePinConnect(
          &pPinConnect,
          pConnectNode,
          pFilterNodeInstanceSink,
          pFilterNodeInstanceSource,
          pWaveFormatEx);
    }
    else {
        pPinConnect->Medium = *(pConnectNode->pPinNodeSink->pMedium);
        pPinConnect->Interface = *(pConnectNode->pPinNodeSink->pInterface);
        pPinConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
        pPinConnect->Priority.PrioritySubClass = 1;
        pPinConnect->PinToHandle = NULL;
    }

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = CPinNodeInstance::Create(
      &pPinNodeInstanceSink,
      pFilterNodeInstanceSink,
      pConnectNode->pPinNodeSink,
      pPinConnect,
      fRender
#ifdef FIX_SOUND_LEAK
     ,FALSE
#endif
      );

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    // Get the pin handle for the pin connecting to this pin
    pPinConnect->PinToHandle = pPinNodeInstanceSink->hPin;

    Status = CPinNodeInstance::Create(
      &pPinNodeInstanceSource,
      pFilterNodeInstanceSource,
      pConnectNode->pPinNodeSource,
      pPinConnect,
      fRender
#ifdef FIX_SOUND_LEAK
     ,FALSE
#endif
      );

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF2(90, "CCNI::Connect: SUCCESS PNI Source %08x PNI Sink %08x",
      pPinNodeInstanceSource,
      pPinNodeInstanceSink);
exit:
    if(!NT_SUCCESS(Status)) {
        DPF1(90, "CCNI::Connect: FAIL %08x", Status);
        pPinNodeInstanceSink->Destroy();
        pPinNodeInstanceSink = NULL;
        pPinNodeInstanceSource->Destroy();
        pPinNodeInstanceSource = NULL;
    }

    if (fDeletePinConnect) {
        delete pPinConnect;
    }

    return(Status);
}

NTSTATUS
CConnectNodeInstance::SetStateTopDown(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(this != NULL) {
    Assert(this);

    if(ulFlags & SETSTATE_FLAG_SOURCE) {
        Status = pPinNodeInstanceSource->SetState(
          NewState,
          PreviousState,
          ulFlags);

        if(!NT_SUCCESS(Status)) {
        goto exit;
        }
    }
    if(ulFlags & SETSTATE_FLAG_SINK) {
        Status = pPinNodeInstanceSink->SetState(
          NewState,
          PreviousState,
          ulFlags);

        if(!NT_SUCCESS(Status)) {
        goto exit;
        }
    }
    }
exit:
    return(Status);
}

NTSTATUS
CConnectNodeInstance::SetStateBottomUp(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(this != NULL) {
    Assert(this);

    if(ulFlags & SETSTATE_FLAG_SINK) {
        Status = pPinNodeInstanceSink->SetState(
          NewState,
          PreviousState,
          ulFlags);

        if(!NT_SUCCESS(Status)) {
        goto exit;
        }
    }
    if(ulFlags & SETSTATE_FLAG_SOURCE) {
        Status = pPinNodeInstanceSource->SetState(
          NewState,
          PreviousState,
          ulFlags);

        if(!NT_SUCCESS(Status)) {
        goto exit;
        }
    }
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CreatePinConnect(
    PKSPIN_CONNECT *ppPinConnect,
    PCONNECT_NODE pConnectNode,
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSink,
    PFILTER_NODE_INSTANCE pFilterNodeInstanceSource,
    PWAVEFORMATEX pWaveFormatExLimit
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pConnectNode);
    Assert(pFilterNodeInstanceSink);
    Assert(pFilterNodeInstanceSource);

    if(pWaveFormatExLimit == NULL) {
        if(pConnectNode->IsTopDown()) {
            Status = CreatePinIntersection(
              ppPinConnect,
              pConnectNode->pPinNodeSource,
              pConnectNode->pPinNodeSink,
              pFilterNodeInstanceSource,
              pFilterNodeInstanceSink);
        }
        else {
            Status = CreatePinIntersection(
              ppPinConnect,
              pConnectNode->pPinNodeSink,
              pConnectNode->pPinNodeSource,
              pFilterNodeInstanceSink,
              pFilterNodeInstanceSource);
        }
    }
    else {
        Status = CreateWaveFormatEx(
          ppPinConnect,
          pConnectNode,
          pWaveFormatExLimit);
    }

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    //
    // For all the normal fields in the PinConnect we could either the
    // source or sink pinnode, they are same.
    //
    ASSERT(pConnectNode->pPinNodeSink->pMedium != NULL);
    ASSERT(pConnectNode->pPinNodeSink->pInterface != NULL);
    ASSERT(pConnectNode->pPinNodeSink->pDataRange != NULL);

    (*ppPinConnect)->Medium = *(pConnectNode->pPinNodeSink->pMedium);
    (*ppPinConnect)->Interface = *(pConnectNode->pPinNodeSink->pInterface);

    (*ppPinConnect)->Priority.PriorityClass = KSPRIORITY_NORMAL;
    (*ppPinConnect)->Priority.PrioritySubClass = 1;
    (*ppPinConnect)->PinToHandle = NULL;

    DPF2(100, "CreatePinConnect: Source #%d %s",
      pConnectNode->pPinNodeSource->pPinInfo->PinId,
      pFilterNodeInstanceSource->pFilterNode->DumpName());
    DPF2(100, "CreatePinConnect: Sink   #%d %s",
      pConnectNode->pPinNodeSink->pPinInfo->PinId,
      pFilterNodeInstanceSink->pFilterNode->DumpName());
exit:
    return(Status);
}

NTSTATUS
CreatePinIntersection(
    PKSPIN_CONNECT *ppPinConnect,
    PPIN_NODE pPinNode1,
    PPIN_NODE pPinNode2,
    PFILTER_NODE_INSTANCE pFilterNodeInstance1,
    PFILTER_NODE_INSTANCE pFilterNodeInstance2
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDATARANGES pDataRangesIn = NULL;
    PKSDATARANGE pDataFormatOut = NULL;

    Assert(pPinNode1);
    Assert(pPinNode2);
    Assert(pFilterNodeInstance1);
    Assert(pFilterNodeInstance2);

    Status = GetPinPropertyEx(
      pFilterNodeInstance2->pFileObject,
      KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
      pPinNode2->pPinInfo->PinId,
      (PVOID*)&pDataRangesIn);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    if(pDataRangesIn == NULL) {
        Status = GetPinPropertyEx(
          pFilterNodeInstance2->pFileObject,
          KSPROPERTY_PIN_DATARANGES,
          pPinNode2->pPinInfo->PinId,
          (PVOID*)&pDataRangesIn);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }

    if(pDataRangesIn == NULL ||
       pDataRangesIn->MultipleItem.Count == 0 ||
       pDataRangesIn->MultipleItem.Size < sizeof(KSDATARANGE)) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Status = GetPinProperty2(
      pFilterNodeInstance1->pFileObject,
      KSPROPERTY_PIN_DATAINTERSECTION,
      pPinNode1->pPinInfo->PinId,
      pDataRangesIn->MultipleItem.Size,
      pDataRangesIn,
      (PVOID*)&pDataFormatOut);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    if(pDataFormatOut == NULL) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    *ppPinConnect = (PKSPIN_CONNECT)
      new BYTE[sizeof(KSPIN_CONNECT) + pDataFormatOut->FormatSize];

    if(*ppPinConnect == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    if(pDataFormatOut->SampleSize == 0) {
        if(IsEqualGUID(
          &pDataFormatOut->Specifier,
          &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
            pDataFormatOut->SampleSize =
              ((PKSDATAFORMAT_WAVEFORMATEX)pDataFormatOut)->
                WaveFormatEx.nBlockAlign;
        }
        if(IsEqualGUID(
          &pDataFormatOut->Specifier,
          &KSDATAFORMAT_SPECIFIER_DSOUND)) {
            pDataFormatOut->SampleSize =
              ((PKSDATAFORMAT_DSOUND)pDataFormatOut)->
                BufferDesc.WaveFormatEx.nBlockAlign;
        }
    }
    memcpy((*ppPinConnect) + 1, pDataFormatOut, pDataFormatOut->FormatSize);

    DPF2(90, "CreatePinIntersection SUCCESS: 1 #%d %s",
      pPinNode1->pPinInfo->PinId,
      pFilterNodeInstance1->pFilterNode->DumpName());

    DPF2(90, "CreatePinIntersection: 2 #%d %s",
      pPinNode2->pPinInfo->PinId,
      pFilterNodeInstance2->pFilterNode->DumpName());
exit:
    delete pDataRangesIn;
    delete pDataFormatOut;
    if(!NT_SUCCESS(Status)) {
        DPF3(90, "CreatePinIntersection FAIL %08x: 1 #%d %s",
          Status,
          pPinNode1->pPinInfo->PinId,
          pFilterNodeInstance1->pFilterNode->DumpName());

        DPF2(90, "CreatePinIntersection: 2 #%d %s",
          pPinNode2->pPinInfo->PinId,
          pFilterNodeInstance2->pFilterNode->DumpName());
    }
    return(Status);
}

NTSTATUS
CreateWaveFormatEx(
    PKSPIN_CONNECT *ppPinConnect,
    PCONNECT_NODE pConnectNode,
    PWAVEFORMATEX pWaveFormatExLimit
)
{
    KSDATARANGE_AUDIO DataRangeAudioIntersection;
    PKSDATARANGE_AUDIO pDataRangeAudioSource;
    PKSDATARANGE_AUDIO pDataRangeAudioSink;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pConnectNode);
    Assert(pConnectNode->pPinNodeSource);
    Assert(pConnectNode->pPinNodeSink);
    ASSERT(*ppPinConnect == NULL);

    //
    // For the WaveFormatEx specifier both source and sink pinnode's
    // DataRanges need to be used to generated the PinConnect structure
    //
    pDataRangeAudioSource =
      (PKSDATARANGE_AUDIO)pConnectNode->pPinNodeSource->pDataRange;

    pDataRangeAudioSink =
      (PKSDATARANGE_AUDIO)pConnectNode->pPinNodeSink->pDataRange;

    if(!DataIntersectionRange(
      &pDataRangeAudioSink->DataRange,
      &pDataRangeAudioSource->DataRange,
      &DataRangeAudioIntersection.DataRange) ||
       !DataIntersectionAudio(
      pDataRangeAudioSink,
      pDataRangeAudioSource,
      &DataRangeAudioIntersection)) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    //
    // Limit the playback/record format
    //
    if(pConnectNode->IsLimitFormat()) {

        if(!LimitAudioRangeToWave(
          pWaveFormatExLimit,
          &DataRangeAudioIntersection)) {
            DPF(20, "CreateWaveFormatEx: LimitAudioRangeToWave FAILED");
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
        DPF6(20,"CreateWaveFormatEx: SR %d CH %d BPS %d | SR %d CH %d BPS %d",
          pWaveFormatExLimit->nSamplesPerSec,
          pWaveFormatExLimit->nChannels,
          pWaveFormatExLimit->wBitsPerSample,
          DataRangeAudioIntersection.MaximumSampleFrequency,
          DataRangeAudioIntersection.MaximumChannels,
          DataRangeAudioIntersection.MaximumBitsPerSample);
    }

    if(IsEqualGUID(
      &DataRangeAudioIntersection.DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        PKSDATAFORMAT_WAVEFORMATEX pDataFormatWaveFormatEx;
        ULONG RegionAllocSize;

        if (pWaveFormatExLimit->wFormatTag == WAVE_FORMAT_PCM) {
            RegionAllocSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }
        else {
            RegionAllocSize = sizeof(KSDATAFORMAT_WAVEFORMATEX) + pWaveFormatExLimit->cbSize;
        }

        *ppPinConnect = (PKSPIN_CONNECT)
            new BYTE[sizeof(KSPIN_CONNECT) + RegionAllocSize];

        if(*ppPinConnect == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        pDataFormatWaveFormatEx =
          (PKSDATAFORMAT_WAVEFORMATEX)((*ppPinConnect) + 1);

        WaveFormatFromAudioRange(
          &DataRangeAudioIntersection,
          &pDataFormatWaveFormatEx->WaveFormatEx);

        if (pWaveFormatExLimit) {
            //
            // If we are trying the Client's data Format
            //
            if (pWaveFormatExLimit->wFormatTag != WAVE_FORMAT_PCM) {
                ULONG CopySize;
                //
                // and if it is extensible format
                //   Set the Extensible related fields in the WaveformatEx
                //   structure we are building as part of PinConnect
                //

                //
                // cast both pointers to Waveformat extensible equivalents
                //
                pDataFormatWaveFormatEx =
                    (PKSDATAFORMAT_WAVEFORMATEX)((*ppPinConnect) + 1);

                pDataFormatWaveFormatEx->WaveFormatEx.wFormatTag = pWaveFormatExLimit->wFormatTag;
                pDataFormatWaveFormatEx->WaveFormatEx.cbSize = pWaveFormatExLimit->cbSize;
                CopySize = pWaveFormatExLimit->cbSize;

                if (CopySize) {
                    PWAVEFORMATEX pWaveFormatExDest;
                    pWaveFormatExDest = &pDataFormatWaveFormatEx->WaveFormatEx;
                    RtlCopyMemory((pWaveFormatExDest+1),
                                  (pWaveFormatExLimit+1),
                                  CopySize);
                }
            }
        }
        pDataFormatWaveFormatEx->DataFormat =
          DataRangeAudioIntersection.DataRange;

        pDataFormatWaveFormatEx->DataFormat.FormatSize =
            sizeof(KSDATAFORMAT_WAVEFORMATEX);

        //
        // If we are dealing extensible format - set the FormatSize to the extensible equivalent
        //
        if (pWaveFormatExLimit) {
            pDataFormatWaveFormatEx->DataFormat.FormatSize = RegionAllocSize;
        }

        pDataFormatWaveFormatEx->DataFormat.SampleSize =
          pDataFormatWaveFormatEx->WaveFormatEx.nBlockAlign;

        DPF3(90, "CreateWaveFormatEx SUCCESS SR %d CH %d BPS %d",
          pDataFormatWaveFormatEx->WaveFormatEx.nSamplesPerSec,
          pDataFormatWaveFormatEx->WaveFormatEx.nChannels,
          pDataFormatWaveFormatEx->WaveFormatEx.wBitsPerSample);
    }
    else {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
        delete *ppPinConnect;
        *ppPinConnect = NULL;

        DPF4(90, "CreateWaveFormatEx FAILED %08x SR %d CH %d BPS %d",
          Status,
          pWaveFormatExLimit->nSamplesPerSec,
          pWaveFormatExLimit->nChannels,
          pWaveFormatExLimit->wBitsPerSample);
    }
    return(Status);
}

VOID
WaveFormatFromAudioRange(
    PKSDATARANGE_AUDIO pDataRangeAudio,
    WAVEFORMATEX *pWaveFormatEx
)
{
    if(IS_VALID_WAVEFORMATEX_GUID(&pDataRangeAudio->DataRange.SubFormat)) {
    pWaveFormatEx->wFormatTag =
      EXTRACT_WAVEFORMATEX_ID(&pDataRangeAudio->DataRange.SubFormat);
    }
    else {
    pWaveFormatEx->wFormatTag = WAVE_FORMAT_UNKNOWN;
    }
    pWaveFormatEx->nChannels = (WORD)pDataRangeAudio->MaximumChannels;
    pWaveFormatEx->nSamplesPerSec = pDataRangeAudio->MaximumSampleFrequency;
    pWaveFormatEx->wBitsPerSample = (WORD)pDataRangeAudio->MaximumBitsPerSample;
    pWaveFormatEx->nBlockAlign =
      (pWaveFormatEx->nChannels * pWaveFormatEx->wBitsPerSample)/8;
    pWaveFormatEx->nAvgBytesPerSec =
      pWaveFormatEx->nSamplesPerSec * pWaveFormatEx->nBlockAlign;
    pWaveFormatEx->cbSize = 0;
}

BOOL
LimitAudioRangeToWave(
    PWAVEFORMATEX pWaveFormatEx,
    PKSDATARANGE_AUDIO pDataRangeAudio
)
{
    PWAVEFORMATEXTENSIBLE pWaveFormatExtensible;

    DPF5(20, "LimitAudioRangeToWave: SR: %d %d CH: %d BPS %d %d",
      pDataRangeAudio->MinimumSampleFrequency,
      pDataRangeAudio->MaximumSampleFrequency,
      pDataRangeAudio->MaximumChannels,
      pDataRangeAudio->MinimumBitsPerSample,
      pDataRangeAudio->MaximumBitsPerSample);

    if(pWaveFormatEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
        pWaveFormatExtensible = (PWAVEFORMATEXTENSIBLE)pWaveFormatEx;
        if (!IsEqualGUID(&pWaveFormatExtensible->SubFormat, &pDataRangeAudio->DataRange.SubFormat)) {
            return(FALSE);
        }
    }
    else { // not WAVE_FORMAT_EXTENSIBLE
        if(IS_VALID_WAVEFORMATEX_GUID(&pDataRangeAudio->DataRange.SubFormat)) {
            if (pWaveFormatEx->wFormatTag !=
                EXTRACT_WAVEFORMATEX_ID(&pDataRangeAudio->DataRange.SubFormat) ) {
            return(FALSE);
            }
        }
    }
    if(pDataRangeAudio->MinimumSampleFrequency <=
       pWaveFormatEx->nSamplesPerSec &&
       pDataRangeAudio->MaximumSampleFrequency >=
       pWaveFormatEx->nSamplesPerSec) {
    pDataRangeAudio->MaximumSampleFrequency = pWaveFormatEx->nSamplesPerSec;
    }
    else {
    return(FALSE);
    }
    if(pDataRangeAudio->MinimumBitsPerSample <=
       pWaveFormatEx->wBitsPerSample &&
       pDataRangeAudio->MaximumBitsPerSample >=
       pWaveFormatEx->wBitsPerSample) {
    pDataRangeAudio->MaximumBitsPerSample = pWaveFormatEx->wBitsPerSample;
    }
    else {
    return(FALSE);
    }
    // Because there is no minimum channel in the data range,
    // take the maximum channel to be what the requestor wants.
    // i.e. don't limit the number of channels.
    if(pDataRangeAudio->MaximumChannels >= pWaveFormatEx->nChannels) {
    pDataRangeAudio->MaximumChannels = pWaveFormatEx->nChannels;
    }
    else {
    return(FALSE);
    }
    return(TRUE);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CConnectNodeInstance::Dump(
)
{
    if(this == NULL) {
    return(STATUS_CONTINUE);
    }
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
    dprintf("CNI: %08x cRef %08x CN %08x FNISource %08x FNISink %08x\n",
      this,
      cReference,
      pConnectNode,
      pFilterNodeInstanceSource,
      pFilterNodeInstanceSink);
    dprintf("     pPNISource: %08x pPNISink %08x\n",
      pPinNodeInstanceSource,
      pPinNodeInstanceSink);
    if(ulDebugFlags & DEBUG_FLAGS_INSTANCE) {
        if(pPinNodeInstanceSource != NULL) {
        pPinNodeInstanceSource->Dump();
        }
        if(pPinNodeInstanceSink != NULL) {
        pPinNodeInstanceSink->Dump();
        }
    }
    if(pPinConnect != NULL) {
        DumpPinConnect(MAXULONG, pPinConnect);
    }
    }
    else {
    dprintf("   Fr: ");
    if(pPinNodeInstanceSource != NULL) {
        pPinNodeInstanceSource->Dump();
    }
    else {
        dprintf("NULL\n");
    }
    dprintf("   To: ");
    if(pPinNodeInstanceSink != NULL) {
        pPinNodeInstanceSink->Dump();
    }
    else {
        dprintf("NULL\n");
    }
    }
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\clock.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   clock.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

DEFINE_KSDISPATCH_TABLE(
    ClockDispatchTable,
    CClockInstance::ClockDispatchIoControl,	// Ioctl
    DispatchInvalidDeviceRequest,		// Read
    DispatchInvalidDeviceRequest,		// Write
    DispatchInvalidDeviceRequest,		// Flush
    CInstance::DispatchClose,			// Close
    DispatchInvalidDeviceRequest,		// QuerySecurity
    DispatchInvalidDeviceRequest,		// SetSeturity
    DispatchFastIoDeviceControlFailure,		// FastDeviceIoControl
    DispatchFastReadFailure,			// FastRead
    DispatchFastWriteFailure			// FastWrite
);

DEFINE_KSPROPERTY_TABLE(ClockPropertyItems)
{
    DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(
	CClockInstance::ClockGetFunctionTable
    )
};

DEFINE_KSPROPERTY_SET_TABLE(ClockPropertySets)
{
    DEFINE_KSPROPERTY_SET(
      &KSPROPSETID_Clock,
      SIZEOF_ARRAY(ClockPropertyItems),
      ClockPropertyItems,
      0,
      NULL
    )
};

KSCLOCK_FUNCTIONTABLE ClockFunctionTable = {
    CClockInstance::ClockGetTime,
    CClockInstance::ClockGetPhysicalTime,
    CClockInstance::ClockGetCorrelatedTime,
    CClockInstance::ClockGetCorrelatedPhysicalTime,
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CClockInstance::CClockInstance(
    IN PPARENT_INSTANCE pParentInstance
) : CInstance(pParentInstance)
{
}

NTSTATUS
CClockInstance::ClockDispatchCreate(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PCLOCK_INSTANCE pClockInstance = NULL;
    PKSCLOCK_CREATE pClockCreate;
    KSPROPERTY Property;
    ULONG BytesReturned;
    NTSTATUS Status;

    ::GrabMutex();

    Status = GetRelatedStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    Assert(pStartNodeInstance);

    Status = KsValidateClockCreateRequest(
       pIrp,
       &pClockCreate);

    if(!NT_SUCCESS(Status)) {
	DPF1(5, 
	  "ClockDispatchCreate: KsValidateClockCreateRequest FAILED %08x",
	  Status);
	goto exit;
    }

    // Allocate per clock instance data
    pClockInstance = new CLOCK_INSTANCE(
      &pStartNodeInstance->pPinInstance->ParentInstance);

    if(pClockInstance == NULL) {
	Trap();
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }

    Status = pClockInstance->DispatchCreate(
      pIrp,
      (UTIL_PFN)ClockDispatchCreateKP,
      pClockCreate,
      0,
      NULL,
      &ClockDispatchTable);

    if(!NT_SUCCESS(Status)) {
	DPF1(5, "ClockDispatchCreateKP: FAILED %08x", Status);
	goto exit;
    }

    //
    // Issue the ioctl to get the function table of the master clock.
    //

    Property.Set = KSPROPSETID_Clock;
    Property.Id = KSPROPERTY_CLOCK_FUNCTIONTABLE;
    Property.Flags = KSPROPERTY_TYPE_GET;

    AssertFileObject(pClockInstance->GetNextFileObject());
    Status = KsSynchronousIoControlDevice(
      pClockInstance->GetNextFileObject(),
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Property,
      sizeof(KSPROPERTY),
      &pClockInstance->FunctionTable,
      sizeof(KSCLOCK_FUNCTIONTABLE),
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
	delete pClockInstance;
    }
    ::ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return Status;
}

NTSTATUS
CClockInstance::ClockDispatchCreateKP(
    PCLOCK_INSTANCE pClockInstance,
    PKSCLOCK_CREATE pClockCreate
)
{
    PPIN_INSTANCE pPinInstance;
    HANDLE hClock = NULL;
    NTSTATUS Status;

    Assert(pClockInstance);
    pPinInstance = pClockInstance->GetParentInstance();
    Assert(pPinInstance);
    Assert(pPinInstance->pStartNodeInstance);
    Assert(pPinInstance->pStartNodeInstance->pPinNodeInstance);
    ASSERT(pPinInstance->pStartNodeInstance->pPinNodeInstance->hPin != NULL);

    Status = KsCreateClock(
      pPinInstance->pStartNodeInstance->pPinNodeInstance->hPin,
      pClockCreate,
      &hClock);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    Status = pClockInstance->SetNextFileObject(hClock);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    if(hClock != NULL) {
	ZwClose(hClock);
    }
    return(Status);
}

NTSTATUS
CClockInstance::ClockDispatchIoControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;
    NTSTATUS Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
	case IOCTL_KS_PROPERTY:
	    Status = KsPropertyHandler(
	      pIrp,
	      SIZEOF_ARRAY(ClockPropertySets),
	      (PKSPROPERTY_SET)&ClockPropertySets);

	    if(Status == STATUS_NOT_FOUND ||
	       Status == STATUS_PROPSET_NOT_FOUND) {
		break;
	    }
	    pIrp->IoStatus.Status = Status;
	    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	    return(Status);
    }
    return(DispatchForwardIrp(pDeviceObject, pIrp));
}

//---------------------------------------------------------------------------

NTSTATUS
CClockInstance::ClockGetFunctionTable(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PKSCLOCK_FUNCTIONTABLE pFunctionTable
)
{
    *pFunctionTable = ClockFunctionTable;
    pIrp->IoStatus.Information = sizeof(KSCLOCK_FUNCTIONTABLE);
    return(STATUS_SUCCESS);
}

LONGLONG
FASTCALL
CClockInstance::ClockGetTime(
    IN PFILE_OBJECT pFileObject
)
{
    PCLOCK_INSTANCE pClockInstance;

    pClockInstance = (PCLOCK_INSTANCE)pFileObject->FsContext;
    Assert(pClockInstance);

    return(pClockInstance->FunctionTable.GetTime(
      pClockInstance->GetNextFileObject()));
}

LONGLONG
FASTCALL
CClockInstance::ClockGetPhysicalTime(
    IN PFILE_OBJECT pFileObject
)
{
    PCLOCK_INSTANCE pClockInstance;

    pClockInstance = (PCLOCK_INSTANCE)pFileObject->FsContext;
    Assert(pClockInstance);

    return(pClockInstance->FunctionTable.GetPhysicalTime(
      pClockInstance->GetNextFileObject()));
}

LONGLONG
FASTCALL
CClockInstance::ClockGetCorrelatedTime(
    IN PFILE_OBJECT pFileObject,
    OUT PLONGLONG Time
)
{
    PCLOCK_INSTANCE pClockInstance;

    pClockInstance = (PCLOCK_INSTANCE)pFileObject->FsContext;
    Assert(pClockInstance);

    return(pClockInstance->FunctionTable.GetCorrelatedTime(
      pClockInstance->GetNextFileObject(),
      Time));
}

LONGLONG
FASTCALL
CClockInstance::ClockGetCorrelatedPhysicalTime(
    IN PFILE_OBJECT pFileObject,
    OUT PLONGLONG Time
)
{
    PCLOCK_INSTANCE pClockInstance;

    pClockInstance = (PCLOCK_INSTANCE)pFileObject->FsContext;
    Assert(pClockInstance);

    return(pClockInstance->FunctionTable.GetCorrelatedPhysicalTime(
      pClockInstance->GetNextFileObject(),
      Time));
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\common.h ===
//---------------------------------------------------------------------------
//
//  Module:   common.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#if DBG

#ifndef DEBUG
#define DEBUG
#endif

#define dprintf DbgPrint

#endif

#ifdef USE_ZONES
#pragma message("USE_ZONES")
#endif

#ifdef DEBUG
#pragma message("DEBUG")
#endif

#if DBG
#pragma message("DBG")
#endif

#include <wchar.h>

extern "C" {

#ifdef USE_ZONES
#include <ntddk.h>
#else
#include <wdm.h>
#endif
#include <windef.h>
#include <winerror.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>
#include <string.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <wdmguid.h>
#include <swenum.h>

} // extern "C"

#include "debug.h"
#include "cobj.h"
#include "clist.h"
#include "util.h"

#include "cinstanc.h"

#include "device.h"
#include "clock.h"
#include "alloc.h"
#include "pins.h"
#include "filter.h"
#include "property.h"
#include "registry.h"

#include "tc.h"
#include "tp.h"
#include "tn.h"

#include "pn.h"
#include "pi.h"
#include "fni.h"
#include "lfn.h"

#include "gpi.h"
#include "ci.h"
#include "si.h"
#include "cn.h"
#include "sn.h"

#include "pni.h"
#include "cni.h"
#include "sni.h"
#include "gni.h"
#include "gn.h"

#include "shi.h"
#include "fn.h"
#include "dn.h"

#include "vsl.h"
#include "vnd.h"
#include "vsd.h"

#include "notify.h"
#include "topology.h"
#include "virtual.h"

//---------------------------------------------------------------------------

#define INIT_CODE   	code_seg("INIT", "CODE")
#define INIT_DATA   	data_seg("INITDATA", "DATA")
#define LOCKED_CODE 	code_seg(".text", "CODE")
#define LOCKED_DATA 	data_seg(".data", "DATA")
#define LOCKED_BSS 	bss_seg(".data", "DATA")
#define PAGEABLE_CODE	code_seg("PAGE", "CODE")
#define PAGEABLE_DATA	data_seg("PAGEDATA", "DATA")
#define PAGEABLE_BSS	bss_seg("PAGEDATA", "DATA")

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//---------------------------------------------------------------------------
//  End of File: common.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\device.h ===
//---------------------------------------------------------------------------
//
//  Module:   		device.h
//
//  Description:	Device Initialization code
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define STR_LINKNAME	TEXT("\\DosDevices\\sysaudio")
#define STR_DEVICENAME	TEXT("\\Device\\sysaudio")

//---------------------------------------------------------------------------
// Data Structures
//---------------------------------------------------------------------------

typedef struct device_instance
{
    PVOID pDeviceHeader;
    PDEVICE_OBJECT pPhysicalDeviceObject;
    PDEVICE_OBJECT pFunctionalDeviceObject;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PDEVICE_INSTANCE gpDeviceInstance;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT	    DriverObject,
    IN PUNICODE_STRING	    usRegistryPathName
);

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT	pDeviceObject,
    IN PIRP		pIrp
);

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
);

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
);

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\debug.h ===
//---------------------------------------------------------------------------
//
//  Module:   debug.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#ifdef DEBUG
#define STR_MODULENAME "sysaudio: "
#endif

#if defined(DEBUG) && defined(_X86_)
#define Trap()	{_asm {_emit 0xcc}}
#else
#define Trap()
#endif

#define AssertAligned(p)	ASSERT((PtrToUlong(p) & 7) == 0)

#ifdef DEBUG

typedef struct _OBJECT_HEADER {
    union {
        struct {
            LONG PointerCount;
            LONG HandleCount;
        };
        LIST_ENTRY Entry;
    };
    POBJECT_TYPE Type;
    UCHAR NameInfoOffset;
    UCHAR HandleInfoOffset;
    UCHAR QuotaInfoOffset;
    UCHAR Flags;

    union {
        //POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

#define OBJECT_TO_OBJECT_HEADER( o ) \
    CONTAINING_RECORD( (o), OBJECT_HEADER, Body )

extern "C" PEPROCESS KernelProcess;
extern "C" int SYSAUDIOTraceLevel;

#define DPF(n,sz) (n == MAXULONG ? dprintf(sz "\n") : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n") : 0))
#define DPF1(n,sz,a) (n == MAXULONG ? dprintf(sz "\n", a) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a) : 0))
#define DPF2(n,sz,a,b) (n == MAXULONG ? dprintf(sz "\n", a,b) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b) : 0))
#define DPF3(n,sz,a,b,c) (n == MAXULONG ? dprintf(sz "\n", a,b,c) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c) : 0))
#define DPF4(n,sz,a,b,c,d) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n",a,b,c,d) : 0))
#define DPF5(n,sz,a,b,c,d,e) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c,d,e) : 0))
#define DPF6(n,sz,a,b,c,d,e,f) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e,f) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c,d,e,f) : 0))
#define DPF7(n,sz,a,b,c,d,e,f,g) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e,f,g) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c,d,e,f,g) : 0))
#define DPF8(n,sz,a,b,c,d,e,f,g,h) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e,f,g,h) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n", a,b,c,d,e,f,g,h) : 0))
#define DPF9(n,sz,a,b,c,d,e,f,g,h,i) (n == MAXULONG ? dprintf(sz "\n", a,b,c,d,e,f,g,h,i) : (n <= SYSAUDIOTraceLevel ? DbgPrint(STR_MODULENAME sz "\n",a,b,c,d,e,f,g,h,i) : 0))

#define AssertStatus(f)		ASSERT(f == STATUS_SUCCESS)

#define AssertFileObject(pfo) \
	    ASSERT((pfo)->FsContext != NULL); \
	    ASSERT(OBJECT_TO_OBJECT_HEADER(pfo)->PointerCount > 0);

// Debug Levels
//
#define DBG_STATE           20

#else 

#define DPF(n,sz)
#define DPF1(n,sz,a)
#define DPF2(n,sz,a,b)
#define DPF3(n,sz,a,b,c)
#define DPF4(n,sz,a,b,c,d)
#define DPF5(n,sz,a,b,c,d,e)
#define DPF6(n,sz,a,b,c,d,e,f)
#define DPF7(n,sz,a,b,c,d,e,f,g)
#define DPF8(n,sz,a,b,c,d,e,f,g,h)
#define DPF9(n,sz,a,b,c,d,e,f,g,h,i)

#define	AssertKernelProcess

#define AssertStatus(f)		f

#define AssertFileObject(pfo)

#endif

#ifdef DEBUG
#define Assert(p) \
    (p)->m_Signature.DebugAssert()

#define DefineSignature(s) \
    class CSignature \
    { \
    public: \
	CSignature() \
	{ \
	   m_dwSignature = s; \
	}; \
	~CSignature() \
	{ \
	   m_dwSignature = 0x44414544; \
	}; \
	BOOL IsAssert() \
	{ \
	    return(m_dwSignature == s); \
	} \
	VOID DebugAssert() \
	{ \
	    ASSERT(IsAssert()); \
	}; \
    private: \
	ULONG m_dwSignature; \
    } m_Signature;

#define DestroySignature() \
    m_Signature.~CSignature()

#else
#define Assert(p)
#define DefineSignature(s)
#define DestroySignature()
#endif

#ifdef DEBUG

#ifndef _X86_

#define dprintf DbgPrint

#endif // _X86_

#endif // DEBUG

//---------------------------------------------------------------------------
//  End of File: debug.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\dn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   dn.cpp
//
//  Description:
//
//	DeviceNode Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

PLIST_DEVICE_NODE gplstDeviceNode = NULL;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma INIT_CODE
#pragma INIT_DATA

NTSTATUS
InitializeDeviceNode(
)
{
    if(gplstDeviceNode == NULL) {
	gplstDeviceNode = new LIST_DEVICE_NODE;
	if(gplstDeviceNode == NULL) {
	    return(STATUS_INSUFFICIENT_RESOURCES);
	}
    }
#ifdef DEBUG
    if(gplstConnectNode == NULL) {
	gplstConnectNode = new LIST_CONNECT_NODE;
	if(gplstConnectNode == NULL) {
	    return(STATUS_INSUFFICIENT_RESOURCES);
	}
    }
    if(gplstPinNodeInstance == NULL) {
	gplstPinNodeInstance = new LIST_PIN_NODE_INSTANCE;
	if(gplstPinNodeInstance == NULL) {
	    return(STATUS_INSUFFICIENT_RESOURCES);
	}
    }
    if(gplstFilterInstance == NULL) {
	gplstFilterInstance = new LIST_DATA_FILTER_INSTANCE;
	if(gplstFilterInstance == NULL) {
	    return(STATUS_INSUFFICIENT_RESOURCES);
	}
    }
#endif
    return(STATUS_SUCCESS);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID
UninitializeDeviceNode(
)
{
    delete gplstDeviceNode;
    gplstDeviceNode = NULL;
#ifdef DEBUG
    ASSERT(gplstConnectNode->IsLstEmpty());
    delete gplstConnectNode;
    gplstConnectNode = NULL;
    ASSERT(gplstPinNodeInstance->IsLstEmpty());
    delete gplstPinNodeInstance;
    gplstPinNodeInstance = NULL;
    delete gplstFilterInstance;
    gplstFilterInstance = NULL;
#endif
}

//---------------------------------------------------------------------------

CDeviceNode::CDeviceNode(
)
{
    ASSERT(gplstDeviceNode != NULL);
    AddListEnd(gplstDeviceNode);
    DPF1(50, "CDeviceNode: %08x", this);
}

CDeviceNode::~CDeviceNode(
)
{
    PFILTER_INSTANCE pFilterInstance;
    ULONG i;

    Assert(this);
    RemoveList();
    if (pFilterNode) {
        pFilterNode->pDeviceNode = NULL;
    }

    delete pShingleInstance;

    FOR_EACH_LIST_ITEM_DELETE(&lstFilterInstance, pFilterInstance) {
        ASSERT(pFilterInstance->GetDeviceNode() == this);
        pFilterInstance->SetDeviceNode(NULL);
    } END_EACH_LIST_ITEM

    if(papVirtualSourceData != NULL) {
	for(i = 0; i < cVirtualSourceData; i++) {
	    delete papVirtualSourceData[i];
	}
	delete papVirtualSourceData;
    }
    for(i = 0; i < MAX_SYSAUDIO_DEFAULT_TYPE; i++) {
	if(apShingleInstance[i] != NULL) {
	    if(apShingleInstance[i]->GetDeviceNode() == this) {
		apShingleInstance[i]->SetDeviceNode(NULL);
	    }
	}
    }
    delete pFilterNodeVirtual;
    DPF1(50, "~CFilterNode: %08x", this);
}

NTSTATUS
CDeviceNode::Create(
    PFILTER_NODE pFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    Assert(pFilterNode);
    this->pFilterNode = pFilterNode;

    Status = Update();
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    pShingleInstance = new SHINGLE_INSTANCE(FLAGS_COMBINE_PINS);
    if(pShingleInstance == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    Status = pShingleInstance->Create(this, (LPGUID)&KSCATEGORY_AUDIO_DEVICE);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
CDeviceNode::Update(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNodeNext;
    ULONG i;

    Assert(this);
    Assert(pFilterNode);
    DPF2(50, "CDeviceNode::Update DN %08x %s", this, DumpName());

    lstGraphNode.DestroyList();
    lstLogicalFilterNode.DestroyList();
    delete pFilterNodeVirtual;
    pFilterNodeVirtual = NULL;

    if(papVirtualSourceData != NULL) {
	for(i = 0; i < cVirtualSourceData; i++) {
	    delete papVirtualSourceData[i];
	}
	delete papVirtualSourceData;
	papVirtualSourceData = NULL;
    }

    if(gcVirtualSources != 0) {
	papVirtualSourceData = new PVIRTUAL_SOURCE_DATA[gcVirtualSources];
	if(papVirtualSourceData == NULL) {
	    Trap();
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}
	for(i = 0; i < gcVirtualSources; i++) {
	    papVirtualSourceData[i] = new VIRTUAL_SOURCE_DATA(this);
	    if(papVirtualSourceData[i] == NULL) {
		Trap();
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto exit;
	    }
	}
    }
    cVirtualSourceData = gcVirtualSources;

    Status = AddLogicalFilterNode(pFilterNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    FOR_EACH_LIST_ITEM(&pFilterNode->lstConnectedFilterNode, pFilterNodeNext) {

	Status = AddLogicalFilterNode(pFilterNodeNext);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    Status = CreateVirtualMixer(this);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(pShingleInstance != NULL) {
	Status = pShingleInstance->SetDeviceNode(this);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
exit:
    return(Status);
}

NTSTATUS
CDeviceNode::AddLogicalFilterNode(
    PFILTER_NODE pFilterNode
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = VirtualizeTopology(this, pFilterNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    FOR_EACH_LIST_ITEM(
      &pFilterNode->lstLogicalFilterNode,
      pLogicalFilterNode) {

	DPF2(60, "AddLogicalFilterNode: %08x, DN: %08x",
	  pLogicalFilterNode,
	  this);

        Status = pLogicalFilterNode->AddList(&lstLogicalFilterNode);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	pLogicalFilterNode->RemoveList(gplstLogicalFilterNode);

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CDeviceNode::CreateGraphNodes(
)
{
    PGRAPH_NODE pGraphNode, pGraphNodeMixer;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    if(lstGraphNode.IsLstEmpty()) {

	pGraphNode = new GRAPH_NODE(this, 0);
	if(pGraphNode == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    Trap();
	    goto exit;
	}
	Status = pGraphNode->Create();
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	//
	// Create a special GraphNode that points to the same renderer or 
	// capturer, but is marked with the "mixer topology" flag so the
	// pins and topology created for this GraphNode is the virtual mixer
	// topology for the mixer driver.
	//
	pGraphNodeMixer = new GRAPH_NODE(this, FLAGS_MIXER_TOPOLOGY);
	if(pGraphNodeMixer == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    Trap();
	    goto exit;
	}
	Status = pGraphNodeMixer->Create();
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
exit:
    if(!NT_SUCCESS(Status)) {
	Trap();
	lstGraphNode.DestroyList();
    }
    return(Status);
}

NTSTATUS
CDeviceNode::GetIndexByDevice(
    OUT PULONG pIndex
)
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    PDEVICE_NODE pDeviceNode;
    UINT iDevice;

    if(this == NULL) {
	ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
	goto exit;
    }

    iDevice = 0;
    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

	if(pDeviceNode == this) {  // This is the one!
	    *pIndex = iDevice;
	    Status = STATUS_SUCCESS;
	    goto exit;
	}
	iDevice++;

    } END_EACH_LIST_ITEM

    ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
exit:
    return(Status);
}

VOID
CDeviceNode::SetPreferredStatus(
    KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType,
    BOOL Enable
)
{
    PFILTER_NODE_INSTANCE    pFilterNodeInstance=NULL;
    KSAUDIO_PREFERRED_STATUS PreferredStatus;
    PFILE_OBJECT             pFileObject;
    KSPROPERTY               PreferredStatusProperty;
    NTSTATUS                 Status;
    ULONG                    BytesReturned;

    Status = CFilterNodeInstance::Create(&pFilterNodeInstance, this->pFilterNode);
    if (!NT_SUCCESS(Status)) {
        DPF1(0, "SetPreferredStatus : Create filterinstance failed with status = 0x%08x", Status);
        goto exit;
    }
    pFileObject = pFilterNodeInstance->pFileObject;

    ASSERT(pFileObject);

    //
    // Form the IOCTL packet & send it down
    //
    PreferredStatusProperty.Set = KSPROPSETID_Audio;
    PreferredStatusProperty.Id = KSPROPERTY_AUDIO_PREFERRED_STATUS;
    PreferredStatusProperty.Flags = KSPROPERTY_TYPE_SET;

    PreferredStatus.Enable = Enable;
    PreferredStatus.DeviceType = DeviceType;
    PreferredStatus.Flags = 0;
    PreferredStatus.Reserved = 0;

    DPF(60,"Sending preferred Status to:");
    DPF1(60," FriendlyName = %s", DbgUnicode2Sz(this->pFilterNode->GetFriendlyName()));
    DPF1(60," DI = %s", DbgUnicode2Sz(this->pFilterNode->GetDeviceInterface()));
    DPF1(60," Enable = 0x%08x", Enable);
    DPF1(60," DeviceType = 0x%08x", DeviceType);

    //
    // We actually throw away the status we got back from the device.
    // Even if this failed we will still continue setting the device to be the
    // preferred device
    //
    Status = KsSynchronousIoControlDevice(pFileObject,
                                          KernelMode,
                                          IOCTL_KS_PROPERTY,
                                          &PreferredStatusProperty,
                                          sizeof(PreferredStatusProperty),
                                          &PreferredStatus,
                                          sizeof(PreferredStatus),
                                          &BytesReturned);


exit:
    if (pFilterNodeInstance) {
        pFilterNodeInstance->Destroy();
    }
}


NTSTATUS
GetDeviceByIndex(
    IN  UINT Index,
    OUT PDEVICE_NODE *ppDeviceNode
)
{
    PDEVICE_NODE pDeviceNode;
    NTSTATUS Status;
    UINT iDevice;

    iDevice = 0;
    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

	if(iDevice++ == Index) {	// This is the one!
	    *ppDeviceNode = pDeviceNode;
	    Status = STATUS_SUCCESS;
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    Status = STATUS_INVALID_DEVICE_REQUEST;
exit:
    return(Status);
}

//---------------------------------------------------------------------------

VOID
DestroyAllGraphs(
)
{
    PDEVICE_NODE pDeviceNode;

    DPF(50, "DestroyAllGraphs");

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {
	pDeviceNode->lstGraphNode.DestroyList();
    } END_EACH_LIST_ITEM

#ifdef DEBUG
    ASSERT(gplstConnectNode->IsLstEmpty());
    ASSERT(gplstPinNodeInstance->IsLstEmpty());
#endif
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ULONG nDevice = 0;

ENUMFUNC 
CDeviceNode::Dump()
{
    // .sd .si .sg
    if(ulDebugFlags & 
      (DEBUG_FLAGS_DEVICE | 
       DEBUG_FLAGS_INSTANCE |
       DEBUG_FLAGS_GRAPH | 
       DEBUG_FLAGS_OBJECT)) {
	if(ulDebugNumber == MAXULONG || ulDebugNumber == nDevice) {
	    if(ulDebugFlags & DEBUG_FLAGS_ADDRESS) {
		dprintf("%d: %08x %s\n", nDevice, this, DumpName());
	    }
	    else {
		dprintf("%d: %s\n", nDevice, DumpName());
	    }
	    if(ulDebugFlags & (DEBUG_FLAGS_DEVICE | DEBUG_FLAGS_OBJECT)) {
		// .sdv
		if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
		    dprintf("DN: %08x FN %08x SHI %08x FNV %08x\n",
		      this,
		      pFilterNode,
		      pShingleInstance,
		      pFilterNodeVirtual);
		    dprintf("    %s\n", DumpDeviceInterface());
		    // .sdv no l
		    if((ulDebugFlags & DEBUG_FLAGS_LOGICAL_FILTER) == 0) {
			dprintf("    lstLFN:");
			lstLogicalFilterNode.DumpAddress();
			dprintf("\n");
		    }
		    // .sdv no g
		    if((ulDebugFlags & DEBUG_FLAGS_GRAPH) == 0) {
			dprintf("     lstGN:");
			lstGraphNode.DumpAddress();
			dprintf("\n");
		    }
		    // .sdv no i
		    if((ulDebugFlags & DEBUG_FLAGS_INSTANCE) == 0) {
			dprintf("     lstFI:");
			lstFilterInstance.DumpAddress();
			dprintf("\n");
		    }
		    dprintf("    papVSD: ");
		    // .sdvx
		    if(ulDebugFlags & DEBUG_FLAGS_DETAILS) {
			dprintf("\n");
			for(ULONG i = 0; i < cVirtualSourceData; i++) {
			    papVirtualSourceData[i]->Dump();
			}
		    }
		    else {
			for(ULONG i = 0; i < cVirtualSourceData; i++) {
			    dprintf("%08x ", papVirtualSourceData[i]);
			}
			dprintf("\n");
		    }
		}
		// .sdl
		if(ulDebugFlags & DEBUG_FLAGS_LOGICAL_FILTER) {
		    lstLogicalFilterNode.Dump();
		}
	    }
	    // .sg
	    if(ulDebugFlags & DEBUG_FLAGS_GRAPH) {
		lstGraphNode.Dump();
	    }
	    // .si
	    if(ulDebugFlags & DEBUG_FLAGS_INSTANCE) {
		lstFilterInstance.Dump();
	    }
	    if(ulDebugFlags &
	      (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_PIN | DEBUG_FLAGS_TOPOLOGY)) {
		dprintf("\n");
	    }
	}
	nDevice++;
    }
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\dn.h ===
//---------------------------------------------------------------------------
//
//  Module:         dn.h
//
//  Description:    Device Node Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CDeviceNode: public CListDoubleItem
{
public:
    CDeviceNode(
    );

    ~CDeviceNode(
    );

    NTSTATUS
    Create(
    PFILTER_NODE pFilterNode
    );

    NTSTATUS
    Update(
    );

    NTSTATUS
    CreateGraphNodes(
    );

    ENUMFUNC
    Destroy()
    {
    Assert(this);
    delete this;
    return(STATUS_CONTINUE);
    };

    NTSTATUS
    GetIndexByDevice(
    OUT PULONG pIndex
    );

    PKSCOMPONENTID
    GetComponentId(
    )
    {
    if (pFilterNode) {
        return(pFilterNode->GetComponentId());
    }
    else {
        return(NULL);
    }
    };

    PWSTR
    GetFriendlyName(
    )
    {
    if (pFilterNode) {
        return(pFilterNode->GetFriendlyName());
    }
    else {
        return(NULL);
    }
    };

    PWSTR
    GetDeviceInterface(
    )
    {
    if (pFilterNode) {
        return(pFilterNode->GetDeviceInterface());
    }
    else {
        return(NULL);
    }
    };

    VOID
    SetPreferredStatus(
        KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType,
        BOOL Enable
    );

#ifdef DEBUG
    ENUMFUNC
    Dump(
    );

    PSZ
    DumpName(
    )
    {
    return(DbgUnicode2Sz(GetFriendlyName()));
    };

    PSZ
    DumpDeviceInterface(
    )
    {
    return(DbgUnicode2Sz(GetDeviceInterface()));
    };
#endif
private:
    NTSTATUS
    AddLogicalFilterNode(
    PFILTER_NODE pFilterNode
    );
public:
    PFILTER_NODE pFilterNode;
    LIST_GRAPH_NODE lstGraphNode;
    PSHINGLE_INSTANCE pShingleInstance;
    LIST_FILTER_INSTANCE lstFilterInstance;
    LIST_MULTI_LOGICAL_FILTER_NODE lstLogicalFilterNode;
    PFILTER_NODE pFilterNodeVirtual;

    // Index by virtual source index
    PVIRTUAL_SOURCE_DATA *papVirtualSourceData;
    ULONG cVirtualSourceData;
    DefineSignature(0x20204E4e);        // DN

} DEVICE_NODE, *PDEVICE_NODE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<DEVICE_NODE> LIST_DEVICE_NODE, *PLIST_DEVICE_NODE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PLIST_DEVICE_NODE gplstDeviceNode;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
InitializeDeviceNode(
);

VOID
UninitializeDeviceNode(
);

NTSTATUS
GetDeviceByIndex(
    IN  UINT Index,
    OUT PDEVICE_NODE *ppDeviceNode
);

VOID
DestroyAllGraphs(
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\device.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define IRPMJFUNCDESC
//#define TIME_BOMB

#include "common.h"
#ifdef TIME_BOMB
#include <ksdebug.h>
#include "..\timebomb\timebomb.c"
#endif


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

PDEVICE_INSTANCE gpDeviceInstance = NULL;

DEFINE_KSCREATE_DISPATCH_TABLE(DeviceCreateItems)
{
    DEFINE_KSCREATE_ITEMNULL(
      CFilterInstance::FilterDispatchCreate,
      NULL),
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma INIT_CODE
#pragma INIT_DATA

NTSTATUS
DriverEntry
(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING usRegistryPathName
)
{
    NTSTATUS Status = STATUS_SUCCESS;

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

    KeInitializeMutex(&gMutex, 0);
    GrabMutex();

    DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverUnload = DriverUnload;
    DriverObject->DriverExtension->AddDevice = AddDevice;

    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_WRITE);

    Status = InitializeUtil();
    if(!NT_SUCCESS(Status)) {
	Trap();
        goto exit;
    }
    Status = InitializeFilterNode();
    if(!NT_SUCCESS(Status)) {
	Trap();
        goto exit;
    }
    Status = InitializeDeviceNode();
    if(!NT_SUCCESS(Status)) {
	Trap();
        goto exit;
    }
    Status = InitializeVirtualSourceLine();
    if(!NT_SUCCESS(Status)) {
	Trap();
        goto exit;
    }
    InitializeListHead(&gEventQueue);
    KeInitializeSpinLock(&gEventLock);
exit:
    ReleaseMutex();
    return(Status);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT	pDeviceObject,
    IN PIRP		pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;
    UNICODE_STRING usLinkName;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    switch(pIrpStack->MinorFunction) {

	case IRP_MN_QUERY_PNP_DEVICE_STATE:
	    //
	    // Mark the device as not disableable.
	    //
	    pIrp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
	    break;

        case IRP_MN_REMOVE_DEVICE:
	    //
	    // We need to unregister the notifications first before killing the
	    // worker threads
	    //
	    UnregisterForPlugPlayNotifications();

	    //
	    // Needs to be outside the mutex because KsUnregisterWorker blocks
	    // until all worker threads are done
	    //
	    UninitializeUtil();

	    GrabMutex();

	    CShingleInstance::UninitializeShingle();
	    UninitializeFilterNode();
	    UninitializeDeviceNode();
	    UninitializeVirtualSourceLine();
	    RtlInitUnicodeString(&usLinkName, STR_LINKNAME);
	    IoDeleteSymbolicLink(&usLinkName);
	    gpDeviceInstance = NULL;
	    UninitializeMemory();

	    ReleaseMutex();
	    break;
    }
    return(KsDefaultDispatchPnp(pDeviceObject, pIrp));
}

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
)
{
#ifdef DEBUG
#ifndef UNDER_NT
#ifdef _X86_
    UninitializeDebug();
#endif
#endif
#endif
}

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
)
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    UNICODE_STRING	usDeviceName;
    UNICODE_STRING	usLinkName;
    PDEVICE_OBJECT      FunctionalDeviceObject = NULL;
    NTSTATUS            Status;
    int i;

    GrabMutex();

    RtlInitUnicodeString(&usDeviceName, STR_DEVICENAME);

    Status = IoCreateDevice(
      DriverObject,
      sizeof(DEVICE_INSTANCE),
      &usDeviceName,
      FILE_DEVICE_KS,
      0,
      FALSE,
      &FunctionalDeviceObject);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    gpDeviceInstance =
      (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    gpDeviceInstance->pPhysicalDeviceObject = PhysicalDeviceObject;
    gpDeviceInstance->pFunctionalDeviceObject = FunctionalDeviceObject;

    RtlInitUnicodeString(&usLinkName, STR_LINKNAME);

    Status = IoCreateSymbolicLink(&usLinkName, &usDeviceName);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = KsAllocateDeviceHeader(
      &gpDeviceInstance->pDeviceHeader,
      SIZEOF_ARRAY(DeviceCreateItems),
      (PKSOBJECT_CREATE_ITEM)DeviceCreateItems);
    
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    
    KsSetDevicePnpAndBaseObject(
      gpDeviceInstance->pDeviceHeader,
      IoAttachDeviceToDeviceStack(FunctionalDeviceObject, PhysicalDeviceObject),
      FunctionalDeviceObject);

    //
    // ISSUE: 05/13/2002 ALPERS
    // StackSize Problem
    // Note that we may still have StackSize problems with deeper objects.
    // The problem will be caught by IO verifier.
    // However in real world, we do not expect any problems because usbaudio
    // driver will never passes-down requests from Sysaudio. In other words,
    // even if DeviceStackSize is deeper than Sysaudio, the IRP will never go
    // down-level from Usbaudio.
    // 

    //
    // Set the StackSize for deeper device stacks.
    // Sysaudio StackSize is normally 2. 
    //      SYSAUDIO - FDO
    //      SWENUM   - PDO
    // 
    // Sysaudio forwards the IRPs to other device stacks which might
    // be deeper than 2. In that case IoVerifier will bugcheck.
    // An example of this is an upper UsbAudio filter driver forwarding
    // IRPs to UsbAudio. 
    // 
    // Setting FDO StackSize to DEFAULT_LARGE_IRP_LOCATIONS 8 (iomgr.h) 
    // guarantees that the IRP comes from large IRP lookaside list in kernel.
    // Thus no memory is wasted. The system has a list of IRPs that it recycles.
    //
    // StackSize 7 will almost guarantee that sysaudio will be deep enough 
    // for any DeviceStack, even with IoVerifier turned on.
    //
    if (FunctionalDeviceObject->StackSize < 7) {
        FunctionalDeviceObject->StackSize = 7;
    }

    Status = RegisterForPlugPlayNotifications();
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = CShingleInstance::InitializeShingle();
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    DeviceCreateItems[0].Context = 
      apShingleInstance[KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT];


    FunctionalDeviceObject->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;
    FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
exit:
    ReleaseMutex();
    return(Status);
}

//---------------------------------------------------------------------------
//  End of File: device.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\filter.h ===
//---------------------------------------------------------------------------
//
//  Module:   		filter.h
//
//  Description:	KS Filter Instance
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

// These flags are used in various classes (FI, SHI, GN, GNI, etc)

#define FLAGS_MIXER_TOPOLOGY			0x80000000
#define FLAGS_COMBINE_PINS	        	0x40000000

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern LONG glPendingAddDelete;
extern LIST_ENTRY gEventQueue;
extern KSPIN_LOCK gEventLock;
extern KSPROPERTY_VALUES PropertyValuesVolume;

//---------------------------------------------------------------------------
// Structures
//---------------------------------------------------------------------------

typedef class CFilterInstance
{
public:
    ~CFilterInstance();

    static NTSTATUS
    FilterDispatchCreate(
	IN PDEVICE_OBJECT pdo,
	IN PIRP pIrp
    );

    static NTSTATUS
    FilterDispatchClose(
	IN PDEVICE_OBJECT pdo,
	IN PIRP	pIrp
    );

    static NTSTATUS
    FilterDispatchIoControl(
	IN PDEVICE_OBJECT pdo,
	IN PIRP	pIrp
    );

    static NTSTATUS 
    FilterPinInstances(
	IN PIRP	pIrp,
	IN PKSP_PIN pPin,
	OUT PKSPIN_CINSTANCES pCInstances
    );

    static NTSTATUS
    FilterPinPropertyHandler(
	IN PIRP pIrp,
	IN PKSPROPERTY pProperty,
	IN OUT PVOID pvData
    );

    static NTSTATUS
    FilterPinNecessaryInstances(
	IN PIRP pIrp,
	IN PKSP_PIN pPin,
	OUT PULONG pulInstances
    );

    static NTSTATUS
    FilterTopologyHandler(
	IN PIRP Irp,
	IN PKSPROPERTY Property,
	IN OUT PVOID Data
    );

    static NTSTATUS
    FilterPinIntersection(
	IN PIRP     Irp,
	IN PKSP_PIN Pin,
	OUT PVOID   Data
    );

    VOID 
    AddList(CListDouble *pld)
    {
	ldiNext.AddList(pld);
    };

    VOID
    RemoveListCheck()
    {
	ldiNext.RemoveListCheck();
    };

    NTSTATUS
    SetShingleInstance(
	PSHINGLE_INSTANCE pShingleInstance
    );

    NTSTATUS
    SetDeviceNode(
	PDEVICE_NODE pDeviceNode
    );

    PDEVICE_NODE
    GetDeviceNode(
    )
    {
	return(pDeviceNode);
    };

    BOOL
    IsChildInstance(
    )
    {
	return(ParentInstance.IsChildInstance());
    };

    NTSTATUS
    CreateGraph(
    );

    NTSTATUS
    GetGraphNodeInstance(
	OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
    );

#ifdef DEBUG
    ENUMFUNC 
    Dump(
    );

    ENUMFUNC 
    DumpAddress(
    );
#endif
private:
    //
    // This pointer to the dispatch table is used in the common
    // dispatch routines  to route the IRP to the appropriate
    // handlers.  This structure is referenced by the device driver
    // with IoGetCurrentIrpStackLocation( pIrp ) -> FsContext
    //
    PVOID pObjectHeader;
    PDEVICE_NODE pDeviceNode;
public:
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PARENT_INSTANCE ParentInstance;
    CLIST_DOUBLE_ITEM ldiNext;
    ULONG ulFlags;
    DefineSignature(0x494C4946);			// FILI

} FILTER_INSTANCE, *PFILTER_INSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleField<FILTER_INSTANCE> LIST_FILTER_INSTANCE;

//---------------------------------------------------------------------------

typedef ListData<FILTER_INSTANCE> LIST_DATA_FILTER_INSTANCE;
typedef LIST_DATA_FILTER_INSTANCE *PLIST_DATA_FILTER_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

#ifdef DEBUG
extern PLIST_DATA_FILTER_INSTANCE gplstFilterInstance;
#endif

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
AddRemoveEventHandler(
    IN PIRP Irp,
    IN PKSEVENTDATA pEventData,
    IN PKSEVENT_ENTRY pEventEntry
);

} // extern "C"

NTSTATUS
GetRelatedGraphNodeInstance(
    IN PIRP pIrp,
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
);

NTSTATUS
GetGraphNodeInstance(
    IN PIRP pIrp,
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
);

//---------------------------------------------------------------------------

extern "C" {

#ifdef DEBUG

VOID
DumpIoctl(
   PIRP pIrp,
   PSZ pszType
);

#endif

} // extern "C"

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\filter.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   filter.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma LOCKED_DATA

LIST_ENTRY gEventQueue;
KSPIN_LOCK gEventLock;
LONG glPendingAddDelete = 0;
BOOL gfFirstEvent = TRUE;

#pragma PAGEABLE_DATA

#ifdef DEBUG
PLIST_DATA_FILTER_INSTANCE gplstFilterInstance;
#endif

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

static const WCHAR PinTypeName[] = KSSTRING_Pin ;

DEFINE_KSCREATE_DISPATCH_TABLE(FilterCreateItems)
{
    DEFINE_KSCREATE_ITEM(CPinInstance::PinDispatchCreate, PinTypeName, 0),
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSDISPATCH_TABLE(
    FilterDispatchTable,
    CFilterInstance::FilterDispatchIoControl,   // Ioctl
    DispatchInvalidDeviceRequest,           // Read
    DispatchInvalidDeviceRequest,       // Write
    DispatchInvalidDeviceRequest,           // Flush
    CFilterInstance::FilterDispatchClose,   // Close
    DispatchInvalidDeviceRequest,           // QuerySecurity
    DispatchInvalidDeviceRequest,           // SetSecurity
    DispatchFastIoDeviceControlFailure,     // FastDeviceIoControl
    DispatchFastReadFailure,            // FastRead
    DispatchFastWriteFailure            // FastWrite
);

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(FilterPropertyHandlers) {
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(CFilterInstance::FilterPinInstances),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(CFilterInstance::FilterPinIntersection),
    DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(CFilterInstance::FilterPinNecessaryInstances),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(CFilterInstance::FilterPinPropertyHandler),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(CFilterInstance::FilterPinPropertyHandler),
};

DEFINE_KSPROPERTY_TOPOLOGYSET(
    TopologyPropertyHandlers,
    CFilterInstance::FilterTopologyHandler
);

DEFINE_KSPROPERTY_TABLE (SysaudioPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_COUNT,
        GetDeviceCount,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        NULL,
        NULL,
    0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
        GetFriendlyNameProperty,
        sizeof(KSPROPERTY) + sizeof(ULONG),
        0,
        NULL,
        NULL,
    0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
        GetInstanceDevice,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        SetInstanceDevice,
        NULL,
        0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT,
        NULL,
        sizeof(KSPROPERTY),
        sizeof(ULONG),
        SetDeviceDefault,
        NULL,
        0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
        GetDeviceInterfaceName,
        sizeof(KSPROPERTY) + sizeof(ULONG),
        0,
        NULL,
        NULL,
    0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_SELECT_GRAPH,
        NULL,
        sizeof(SYSAUDIO_SELECT_GRAPH),
        0,
        SelectGraph,
        NULL,
    0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE,
        CreateVirtualSource,
        sizeof(SYSAUDIO_CREATE_VIRTUAL_SOURCE),
        sizeof(ULONG),
        NULL,
        NULL,
    0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY,
        CreateVirtualSource,
        sizeof(SYSAUDIO_CREATE_VIRTUAL_SOURCE),
        sizeof(ULONG),
        NULL,
        NULL,
    0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_INSTANCE_INFO,
        NULL,
        sizeof(SYSAUDIO_INSTANCE_INFO),
        0,
        SetInstanceInfo,
        NULL,
        0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE,
        NULL,
        sizeof(SYSAUDIO_PREFERRED_DEVICE),
        sizeof(ULONG),
        SetPreferredDevice,
        NULL,
        0,
    NULL,
    NULL,
    0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_COMPONENT_ID,
        GetComponentIdProperty,
        sizeof(KSPROPERTY) + sizeof(ULONG),
        sizeof(KSCOMPONENTID),
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
    	KSPROPERTY_SYSAUDIO_ADDREMOVE_GFX,
    	NULL,
        sizeof(KSPROPERTY),
    	sizeof(SYSAUDIO_GFX),
    	AddRemoveGfx,
    	NULL,
        0,
	NULL,
	NULL,
	0
    )
};

KSPROPERTY_STEPPING_LONG SteppingLongVolume[] = {
    (65536/2),                  // SteppingDelta
    0,                      // Reserved
    {                       // Bounds
    (-96 * 65536),                         // SignedMinimum
    0                      // SignedMaximum
    }
};

KSPROPERTY_MEMBERSLIST MemberListVolume = {
    {                       // MembersHeader
    KSPROPERTY_MEMBER_STEPPEDRANGES,        // MembersFlags
    sizeof(KSPROPERTY_STEPPING_LONG),       // MembersSize
    SIZEOF_ARRAY(SteppingLongVolume),           // MembersCount
    0                               // Flags
    },
    SteppingLongVolume              // Members
};

KSPROPERTY_VALUES PropertyValuesVolume = {
    {                       // PropTypeSet
    STATIC_KSPROPTYPESETID_General,
        VT_I4,
        0
    },
    1,                      // MembersListCount
    &MemberListVolume               // MembersList
};

DEFINE_KSPROPERTY_TABLE (AudioPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        FilterVirtualPropertyHandler,
        sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
        sizeof(LONG),
        FilterVirtualPropertyHandler,
        &PropertyValuesVolume,
        0,
        NULL,
        (PFNKSHANDLER)FilterVirtualPropertySupportHandler,
        0
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_MUTE,
        FilterVirtualPropertyHandler,
        sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
        sizeof(LONG),
        FilterVirtualPropertyHandler,
        NULL,
        0,
        NULL,
        (PFNKSHANDLER)FilterVirtualPropertySupportHandler,
        0
    )
};

DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySet)
{
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Pin,                                // Set
       SIZEOF_ARRAY(FilterPropertyHandlers),            // PropertiesCount
       FilterPropertyHandlers,                          // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Topology,                           // Set
       SIZEOF_ARRAY(TopologyPropertyHandlers),          // PropertiesCount
       TopologyPropertyHandlers,                        // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Sysaudio,                           // Set
       SIZEOF_ARRAY(SysaudioPropertyHandlers),          // PropertiesCount
       SysaudioPropertyHandlers,                        // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Audio,                              // Set
       SIZEOF_ARRAY(AudioPropertyHandlers),             // PropertiesCount
       AudioPropertyHandlers,                           // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    )
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DEFINE_KSEVENT_TABLE(SysaudioEventHandlers)
{
    DEFINE_KSEVENT_ITEM(
    KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE,
    sizeof(KSEVENTDATA),
    sizeof(ULONG),
    AddRemoveEventHandler,
    NULL,
    NULL )
};

DEFINE_KSEVENT_SET_TABLE(FilterEvents)
{
    DEFINE_KSEVENT_SET(
    &KSEVENTSETID_Sysaudio,
    SIZEOF_ARRAY(SysaudioEventHandlers),
    SysaudioEventHandlers)
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CFilterInstance::FilterDispatchCreate(
    IN PDEVICE_OBJECT pdo,
    IN PIRP pIrp
)
{
    PFILTER_INSTANCE pFilterInstance = NULL;
    PSHINGLE_INSTANCE pShingleInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;

    pShingleInstance = (PSHINGLE_INSTANCE)
      KSCREATE_ITEM_IRP_STORAGE(pIrp)->Context;
    Assert(pShingleInstance);
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    Status = KsReferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
    if(!NT_SUCCESS(Status)) {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return(Status);
    }

    GrabMutex();

    pFilterInstance = new FILTER_INSTANCE;
    if(pFilterInstance == NULL) {
        KsDereferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
#ifdef DEBUG
    gplstFilterInstance->AddList(pFilterInstance);
#endif
    DPF2(100, "FilterDispatchCreate: pFilterInstance: %08x PS %08x",
      pFilterInstance,
      PsGetCurrentProcess());

    Status = KsAllocateObjectHeader(
      &pFilterInstance->pObjectHeader,
      SIZEOF_ARRAY(FilterCreateItems),
      FilterCreateItems,
      pIrp,
      (PKSDISPATCH_TABLE)&FilterDispatchTable);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pIrpStack->FileObject->FsContext = pFilterInstance; // pointer to instance

    Status = pFilterInstance->SetShingleInstance(pShingleInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
        delete pFilterInstance;
    }
    ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return(Status);
}

NTSTATUS
CFilterInstance::FilterDispatchClose(
   IN PDEVICE_OBJECT pdo,
   IN PIRP pIrp
)
{
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;

    GrabMutex();

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    pIrpStack->FileObject->FsContext = NULL;
    delete pFilterInstance;

    ReleaseMutex();

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

CFilterInstance::~CFilterInstance(
)
{
    Assert(this);
    RemoveListCheck();
    delete pGraphNodeInstance;
    if(pObjectHeader != NULL) {
        KsFreeObjectHeader(pObjectHeader);
    }
    KsDereferenceSoftwareBusObject(gpDeviceInstance->pDeviceHeader);
#ifdef DEBUG
    gplstFilterInstance->RemoveList(this);
#endif
    ASSERT(IsChildInstance());
    DPF2(100, "~CFilterInstance: pFilterInstance: %08x PS %08x",
      this,
      PsGetCurrentProcess());
}

NTSTATUS
CFilterInstance::SetShingleInstance(
    PSHINGLE_INSTANCE pShingleInstance
)
{
    PDEVICE_NODE pDeviceNode;
    NTSTATUS Status;

    Assert(this);
    Assert(pShingleInstance);

    ulFlags &= ~(FLAGS_MIXER_TOPOLOGY | FLAGS_COMBINE_PINS);
    ulFlags |=
      pShingleInstance->ulFlags & (FLAGS_MIXER_TOPOLOGY | FLAGS_COMBINE_PINS);

    pDeviceNode = pShingleInstance->GetDeviceNode();

    //
    // Note that all the following routines are ready to handle
    // pDeviceNode == NULL case.
    //

    Status = SetDeviceNode(pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
CFilterInstance::SetDeviceNode(
    PDEVICE_NODE pDeviceNode
)
{
    RemoveListCheck();
    this->pDeviceNode = pDeviceNode;
    if(pDeviceNode != NULL) {
        AddList(&pDeviceNode->lstFilterInstance);
    }
    delete pGraphNodeInstance;
    ASSERT(pGraphNodeInstance == NULL);
    return(CreateGraph());
}

NTSTATUS
CFilterInstance::CreateGraph(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PGRAPH_NODE pGraphNode;

    ASSERT(pGraphNodeInstance == NULL);
    if(pDeviceNode == NULL) {
        DPF(100, "CFilterInstance::CreateGraph: pDeviceNode == NULL");
        ASSERT(NT_SUCCESS(Status));
        goto exit;
    }
    Status = pDeviceNode->CreateGraphNodes();
    if(!NT_SUCCESS(Status)) {
        DPF(10, "CFilterInstance::CreateGraph: CreateGraphNodes FAILED");
        goto exit;
    }
    FOR_EACH_LIST_ITEM(&pDeviceNode->lstGraphNode, pGraphNode) {

        if(((pGraphNode->ulFlags ^ ulFlags) & FLAGS_MIXER_TOPOLOGY) == 0) {

            pGraphNodeInstance = new GRAPH_NODE_INSTANCE(pGraphNode, this);
            if(pGraphNodeInstance == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }

            Status = pGraphNodeInstance->Create();
            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
            break;
        }

    } END_EACH_LIST_ITEM
exit:
    if(!NT_SUCCESS(Status)) {
       delete pGraphNodeInstance;
       pGraphNodeInstance = NULL;
    }
    return(Status);
}

NTSTATUS
CFilterInstance::FilterDispatchIoControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PKSPROPERTY pProperty = NULL;
    BOOL fProperty = FALSE;
    ULONG ulFlags = 0;

    GrabMutex();
#ifdef DEBUG
    DumpIoctl(pIrp, "Filter");
#endif

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    if(pFilterInstance == NULL) {
        DPF(5, "FilterDispatchIoControl: FAILED pFilterInstance == NULL");
        Trap();
        Status = STATUS_NO_SUCH_DEVICE;
        goto exit;
    }
    Assert(pFilterInstance);

    switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_KS_PROPERTY:
            fProperty = TRUE;
            break;

        case IOCTL_KS_ENABLE_EVENT:
        case IOCTL_KS_DISABLE_EVENT:
        case IOCTL_KS_METHOD:
            break;

        default:
            DPF(10, "FilterDispatchIoControl: default");
            ReleaseMutex();
            return KsDefaultDeviceIoCompletion(pDeviceObject, pIrp);
    }

    if( pIrpStack->Parameters.DeviceIoControl.InputBufferLength >= sizeof(KSPROPERTY) &&
        pIrpStack->Parameters.DeviceIoControl.IoControlCode != IOCTL_KS_DISABLE_EVENT ) {

        __try {
            if(pIrp->AssociatedIrp.SystemBuffer == NULL) {
                pProperty = (PKSPROPERTY)
                  (pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer);

                // Validate the pointers if the client is not trusted.
                if(pIrp->RequestorMode != KernelMode) {
                    ProbeForWrite(
                        pProperty,
                        pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
                        sizeof(BYTE));
                }
            }
            else {
                pProperty =
                    (PKSPROPERTY)((PUCHAR)pIrp->AssociatedIrp.SystemBuffer +
            ((pIrpStack->Parameters.DeviceIoControl.OutputBufferLength +
            FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT));
            }
            ulFlags = pProperty->Flags;

        } 
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            DPF1(5, "FilterDispatchIoControl: Exception %08x", Status);
            goto exit;
        }

        //
        // This check allows the actual node or filter return the set's
        // supported, etc. instead of always return only the sets sysaudio
        // supports.
        //
        if(ulFlags & KSPROPERTY_TYPE_TOPOLOGY) {
            if(fProperty) {
                if((ulFlags & (KSPROPERTY_TYPE_GET |
                               KSPROPERTY_TYPE_SET |
                               KSPROPERTY_TYPE_BASICSUPPORT)) == 0) {

                    // NOTE: ForwardIrpNode releases gMutex
            return(ForwardIrpNode(
              pIrp,
                      pProperty,
              pFilterInstance,
              NULL));
        }
    }

            else {
                // NOTE: ForwardIrpNode releases gMutex
                return(ForwardIrpNode(
                  pIrp,
                  pProperty,
                  pFilterInstance,
                  NULL));
            }
        }
    }

    switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_KS_PROPERTY:

            Status = KsPropertyHandler(
              pIrp,
              SIZEOF_ARRAY(FilterPropertySet),
              (PKSPROPERTY_SET)FilterPropertySet);

            if(Status != STATUS_NOT_FOUND &&
               Status != STATUS_PROPSET_NOT_FOUND) {
                break;
            }

            // NOTE: ForwardIrpNode releases gMutex
            return(ForwardIrpNode(
              pIrp,
              NULL,
              pFilterInstance,
              NULL));

        case IOCTL_KS_ENABLE_EVENT:

            Status = KsEnableEvent(
              pIrp,
              SIZEOF_ARRAY(FilterEvents),
              (PKSEVENT_SET)FilterEvents,
              &gEventQueue,
              KSEVENTS_SPINLOCK,
              &gEventLock);

            if(Status != STATUS_NOT_FOUND &&
               Status != STATUS_PROPSET_NOT_FOUND) {
                break;
            }

            // NOTE: ForwardIrpNode releases gMutex
            return(ForwardIrpNode(
              pIrp,
              NULL,
              pFilterInstance,
              NULL));

        case IOCTL_KS_DISABLE_EVENT:

            Status = KsDisableEvent(
              pIrp,
              &gEventQueue,
              KSEVENTS_SPINLOCK,
              &gEventLock);

            if(NT_SUCCESS(Status)) {
                break;
            }
            // Fall through to ForwardIrpNode

        case IOCTL_KS_METHOD:
            // NOTE: ForwardIrpNode releases gMutex
            return(ForwardIrpNode(
              pIrp,
              NULL,
              pFilterInstance,
              NULL));

        default:
            ASSERT(FALSE);  // no way to get here
    }
exit:
    ReleaseMutex();

    if(!NT_SUCCESS(Status)) {
        DPF1(100, "FilterDispatchIoControl: Status %08x", Status);
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return(Status);
}

NTSTATUS
EnableEventWorker(
    PVOID pReference1,
    PVOID pReference2
)
{
    DecrementAddRemoveCount();
    return(STATUS_SUCCESS);
}

NTSTATUS
AddRemoveEventHandler(
    IN PIRP Irp,
    IN PKSEVENTDATA pEventData,
    IN PKSEVENT_ENTRY pEventEntry
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    ExInterlockedInsertTailList(
      &gEventQueue,
      &pEventEntry->ListEntry,
      &gEventLock);

    if(InterlockedExchange((PLONG)&gfFirstEvent, FALSE)) {
        InterlockedIncrement(&glPendingAddDelete);
        Status = QueueWorkList(EnableEventWorker, NULL, NULL);
    }

    return(Status);
}

NTSTATUS
CFilterInstance::FilterPinPropertyHandler(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(pProperty->Id == KSPROPERTY_PIN_NAME) {
        PKSP_PIN pPinProperty = (PKSP_PIN)pProperty;

        if(pPinProperty->PinId >= pGraphNodeInstance->cPins) {
            DPF(5, "FilterPinPropertyHandler: PinId >= cPins");
            Status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        // The only time this isn't going to be NULL is for a virtual source pin
        if(pGraphNodeInstance->paPinDescriptors[pPinProperty->PinId].Name ==
          NULL) {
            PSTART_NODE pStartNode;

            FOR_EACH_LIST_ITEM(
              pGraphNodeInstance->aplstStartNode[pPinProperty->PinId],
              pStartNode) {
                PWSTR pwstrName;

                Assert(pStartNode);
                Assert(pStartNode->pPinNode);
                Assert(pStartNode->pPinNode->pPinInfo);
                pwstrName = pStartNode->pPinNode->pPinInfo->pwstrName;
                if(pwstrName == NULL) {
                    continue;
                }
                Status = PropertyReturnString(
                  pIrp,
                  pwstrName,
                  (wcslen(pwstrName) * sizeof(WCHAR)) + sizeof(UNICODE_NULL),
                  pData);
                goto exit;

            } END_EACH_LIST_ITEM
        }
    }
    Status = KsPinPropertyHandler(
      pIrp,
      pProperty,
      pData,
      pGraphNodeInstance->cPins,
      pGraphNodeInstance->paPinDescriptors);

exit:
    return(Status);
}

NTSTATUS
CFilterInstance::FilterPinInstances(
    IN PIRP pIrp,
    IN PKSP_PIN pPin,
    OUT PKSPIN_CINSTANCES pcInstances
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    
    Assert(pGraphNodeInstance);
    ASSERT(pGraphNodeInstance->pacPinInstances != NULL);

    if(pPin->PinId >= pGraphNodeInstance->cPins) {
        DPF(5, "FilterPinInstances: FAILED PinId invalid");
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    
    Status = pGraphNodeInstance->GetPinInstances(
        pIrp,
        pPin, 
        pcInstances);

exit:
    return(Status);
}

NTSTATUS
CFilterInstance::FilterPinNecessaryInstances(
    IN PIRP pIrp,
    IN PKSP_PIN pPin,
    OUT PULONG pulInstances
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(pPin->PinId >= pGraphNodeInstance->cPins) {
        DPF(5, "FilterPinNecessaryInstances: FAILED PinId invalid");
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    *pulInstances = 0;
    pIrp->IoStatus.Information = sizeof( ULONG );
exit:
    return(Status);
}

NTSTATUS
CFilterInstance::FilterTopologyHandler(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(pProperty->Id == KSPROPERTY_TOPOLOGY_NAME) {
        PKSP_NODE pNode = (PKSP_NODE)pProperty;

        if(pNode->NodeId >= pGraphNodeInstance->Topology.TopologyNodesCount) {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
        if(pGraphNodeInstance->papTopologyNode[pNode->NodeId]->
          ulRealNodeNumber != MAXULONG) {

            pProperty->Flags |= KSPROPERTY_TYPE_TOPOLOGY;
            Status = STATUS_NOT_FOUND;
            goto exit;
        }
    }

    Status = KsTopologyPropertyHandler(
      pIrp,
      pProperty,
      pData,
      &pGraphNodeInstance->Topology);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
CFilterInstance::FilterPinIntersection(
    IN PIRP     pIrp,
    IN PKSP_PIN pPin,
    OUT PVOID   pData
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property
    set.  Returns the first acceptable data format given a list of data ranges
    for a specified Pin factory. Actually just calls the Intersection
    Enumeration helper, which then calls the IntersectHandler callback with
    each data range.

Arguments:

    pIrp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed
    by a KSMULTIPLE_ITEM structure. This is followed by zero or more data
    range structures.

    Data -
        The place in which to return the data format selected as the first
    intersection between the list of data ranges passed, and the acceptable
    formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
            STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    LIST_DATA_FILTER_NODE lstFilterNode;
    PIO_STACK_LOCATION pIrpStack;
    ULONG BytesReturned, PinId;
    PSTART_NODE pStartNode;
    PVOID pBuffer = NULL;
    NTSTATUS Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(pPin->PinId >= pGraphNodeInstance->cPins) {
        DPF(5, "FilterPinIntersection: FAILED PinId invalid");
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    PinId = pPin->PinId;

    FOR_EACH_LIST_ITEM(pGraphNodeInstance->aplstStartNode[PinId], pStartNode) {
        PFILTER_NODE pFilterNode;
        PPIN_INFO pPinInfo;

        Assert(pStartNode);
        Assert(pStartNode->pPinNode);

        pPinInfo = pStartNode->pPinNode->pPinInfo;
        Assert(pPinInfo);
        Assert(pPinInfo->pFilterNode);

        if(pPinInfo->pFilterNode->GetType() & FILTER_TYPE_VIRTUAL) {
            continue;
        }

        FOR_EACH_LIST_ITEM(&lstFilterNode, pFilterNode) {
            Assert(pFilterNode);
            if(pFilterNode == pPinInfo->pFilterNode) {
                goto next;
            }
        } END_EACH_LIST_ITEM

        DPF2(100, "FilterPinIntersection: FN %08x %s",
          pPinInfo->pFilterNode,
          pPinInfo->pFilterNode->DumpName());

        Status = lstFilterNode.AddList(pPinInfo->pFilterNode);
        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }

        Status = CFilterNodeInstance::Create(
          &pFilterNodeInstance,
          pPinInfo->pFilterNode);

        if(!NT_SUCCESS(Status)) {
            DPF2(10, "FilterPinIntersection CFNI:Create FAILS %08x %s",
              Status,
              pPinInfo->pFilterNode->DumpName());
            goto next;
        }
        pPin->PinId = pPinInfo->PinId;

        AssertFileObject(pFilterNodeInstance->pFileObject);
        Status = KsSynchronousIoControlDevice(
          pFilterNodeInstance->pFileObject,
          KernelMode,
          IOCTL_KS_PROPERTY,
          pPin,
          pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
          pData,
          pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
          &BytesReturned);

        if(NT_SUCCESS(Status)) {
            #ifdef DEBUG
            ULONG i;
            DPF(95, "FilterPinIntersection enter with:");
            for(i = 0; i < ((PKSMULTIPLE_ITEM)(pPin + 1))->Count; i++) {
                DumpDataRange(
                  95,
                  &(((PKSDATARANGE_AUDIO)
                   (((PKSMULTIPLE_ITEM)(pPin + 1)) + 1))[i]));
            }
            DPF(95, "FilterPinIntersection SUCCESS returns:");
            DumpDataFormat(95, (PKSDATAFORMAT)pData);
            #endif
            pIrp->IoStatus.Information = BytesReturned;
            goto exit;
        }

        if(Status == STATUS_BUFFER_OVERFLOW) {
            pBuffer = new BYTE[BytesReturned];
            if(pBuffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            AssertFileObject(pFilterNodeInstance->pFileObject);
            Status = KsSynchronousIoControlDevice(
              pFilterNodeInstance->pFileObject,
              KernelMode,
              IOCTL_KS_PROPERTY,
              pPin,
              pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
              pBuffer,
              BytesReturned,
              &BytesReturned);

            if(NT_SUCCESS(Status)) {
                Status = STATUS_BUFFER_OVERFLOW;
                pIrp->IoStatus.Information = BytesReturned;
                DPF1(100, "FilterPinIntersection: STATUS_BUFFER_OVERFLOW %d",
                  BytesReturned);
                goto exit;
            }
            ASSERT(Status != STATUS_BUFFER_OVERFLOW);
            DPF2(100, "FilterPinIntersection: %08x %d", Status, BytesReturned);
            delete [] pBuffer;
            pBuffer = NULL;
        }

next:
        pFilterNodeInstance->Destroy();
        pFilterNodeInstance = NULL;

    } END_EACH_LIST_ITEM

    DPF(100, "FilterPinIntersection: NOT FOUND");
    Status = STATUS_NOT_FOUND;
exit:
    delete [] pBuffer;
    if (pFilterNodeInstance) {
        pFilterNodeInstance->Destroy();
    }
    return(Status);
}

NTSTATUS
GetRelatedGraphNodeInstance(
    IN PIRP pIrp,
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
)
{
    return(((PFILTER_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->FileObject->
      RelatedFileObject->FsContext)->GetGraphNodeInstance(ppGraphNodeInstance));
}

NTSTATUS
GetGraphNodeInstance(
    IN PIRP pIrp,
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
)
{
    return(((PFILTER_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->FileObject->
      FsContext)->GetGraphNodeInstance(ppGraphNodeInstance));
}

NTSTATUS
CFilterInstance::GetGraphNodeInstance(
    OUT PGRAPH_NODE_INSTANCE *ppGraphNodeInstance
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    if(pGraphNodeInstance == NULL) {
        Status = CreateGraph();
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        if(pGraphNodeInstance == NULL) {
            DPF(10, "GetGraphNodeInstance: FAILED pGraphNodeInstance == NULL");
            Status = STATUS_NO_SUCH_DEVICE;
            goto exit;
        }
    }
    
    Assert(pGraphNodeInstance);
    *ppGraphNodeInstance = pGraphNodeInstance;
exit:
    return(Status);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CFilterInstance::Dump(
)
{
    Assert(this);
    // .siv
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
    dprintf("FI: %08x DN %08x ulFlags %08x ",
      this,
      pDeviceNode,
      ulFlags);
    if(ulFlags & FLAGS_COMBINE_PINS) {
        dprintf("COMBINE_PINS ");
    }
    if(ulFlags & FLAGS_MIXER_TOPOLOGY) {
        dprintf("MIXER_TOPOLOGY");
    }
    dprintf("\n");
    }
    // .si
    if(ulDebugFlags & DEBUG_FLAGS_INSTANCE) {
    PINSTANCE pInstance;

    if(pGraphNodeInstance != NULL) {
        pGraphNodeInstance->Dump();
    }
    FOR_EACH_LIST_ITEM(&ParentInstance.lstChildInstance, pInstance) {
        PPIN_INSTANCE(pInstance)->Dump();
    } END_EACH_LIST_ITEM
    }
    if(ulDebugFlags &
      (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_PIN | DEBUG_FLAGS_TOPOLOGY)) {
    dprintf("\n");
    }
    return(STATUS_CONTINUE);
}

ENUMFUNC
CFilterInstance::DumpAddress()
{
    Assert(this);
    dprintf(" %08x", this);
    return(STATUS_CONTINUE);
}

VOID
DumpIoctl(
   PIRP pIrp,
   PSZ pszType
)
{
    PIO_STACK_LOCATION pIrpStack;
    PKSPROPERTY pProperty;
    PSZ pszIoctl;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_KS_PROPERTY:
        pszIoctl = "PROPERTY";
        break;
        case IOCTL_KS_ENABLE_EVENT:
        pszIoctl = "ENABLE_EVENT";
        break;
        case IOCTL_KS_DISABLE_EVENT:
        pszIoctl = "DISABLE_EVENT";
        DPF2(105, "%s %s", pszIoctl, pszType);
        return;
        case IOCTL_KS_METHOD:
        pszIoctl = "METHOD";
        break;
    case IOCTL_KS_WRITE_STREAM:
        pszIoctl = "WRITE_STREAM";
        DPF2(105, "%s %s", pszIoctl, pszType);
        return;
    case IOCTL_KS_READ_STREAM:
        pszIoctl = "READ_STREAM";
        DPF2(105, "%s %s", pszIoctl, pszType);
        return;
    case IOCTL_KS_RESET_STATE:
        pszIoctl = "RESET_STATE";
        DPF2(105, "%s %s", pszIoctl, pszType);
        return;
    default:
        DPF2(105, "Unknown Ioctl: %s %08x",
          pszType,
          pIrpStack->Parameters.DeviceIoControl.IoControlCode);
        return;
    }
    if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength <
      sizeof(KSPROPERTY)) {
    DPF3(105, "InputBufferLength too small: %s %s %08x",
      pszType,
      pszIoctl,
      pIrpStack->Parameters.DeviceIoControl.InputBufferLength);
    return;
    }
    __try {
    if(pIrp->AssociatedIrp.SystemBuffer == NULL) {
        pProperty = (PKSPROPERTY)
          pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

        // Validate the pointers if the client is not trusted.
        if(pIrp->RequestorMode != KernelMode) {
        ProbeForRead(
          pProperty,
          pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
          sizeof(BYTE));
        }
    }
    else {
        pProperty =
          (PKSPROPERTY)((PUCHAR)pIrp->AssociatedIrp.SystemBuffer +
          ((pIrpStack->Parameters.DeviceIoControl.OutputBufferLength +
          FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT));
    }
    if(pProperty->Flags & KSPROPERTY_TYPE_TOPOLOGY) {
        if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
          sizeof(KSNODEPROPERTY)) {
        DPF5(105, "%s %s %s Flags %08x N: %d",
          pszType,
          pszIoctl,
          DbgIdentifier2Sz((PKSIDENTIFIER)pProperty),
          pProperty->Flags,
          ((PKSNODEPROPERTY)pProperty)->NodeId);
        }
    }
    else {
        DPF4(105, "%s %s %s Flags %08x",
          pszType,
          pszIoctl,
          DbgIdentifier2Sz((PKSIDENTIFIER)pProperty),
          pProperty->Flags);
    }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }
}

#endif

//---------------------------------------------------------------------------
//  End of File: filter.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\fni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   fni.cpp
//
//  Description:
//
//	Filter Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CFilterNodeInstance::~CFilterNodeInstance(
)
{
    Assert(this);
    DPF1(95, "~CFilterNodeInstance: %08x", this);
    RemoveListCheck();
    UnregisterTargetDeviceChangeNotification();
    //
    // if hFilter == NULL && pFileObject != NULL
    //   it means that this filter instance is for a GFX
    //   do not try to dereference the file object in that case
    //
    if( (hFilter != NULL) && (pFileObject != NULL) ) {
	AssertFileObject(pFileObject);
	ObDereferenceObject(pFileObject);
    }
    if(hFilter != NULL) {
	AssertStatus(ZwClose(hFilter));
    }
}

NTSTATUS
CFilterNodeInstance::Create(
    PFILTER_NODE_INSTANCE *ppFilterNodeInstance,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PDEVICE_NODE pDeviceNode,
    BOOL fReuseInstance
)
{
    PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;
    PLOGICAL_FILTER_NODE pLogicalFilterNode2;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pLogicalFilterNode);
    Assert(pLogicalFilterNode->pFilterNode);

    if(pLogicalFilterNode->GetType() & FILTER_TYPE_AEC) {
	FOR_EACH_LIST_ITEM(
	  &pLogicalFilterNode->pFilterNode->lstLogicalFilterNode,
	  pLogicalFilterNode2) {

	    FOR_EACH_LIST_ITEM(
	      &pLogicalFilterNode2->lstFilterNodeInstance,
	      pFilterNodeInstance) {

		pFilterNodeInstance->AddRef();
		ASSERT(NT_SUCCESS(Status));
		goto exit;

	    } END_EACH_LIST_ITEM

	} END_EACH_LIST_ITEM
    }
    else {
	if(fReuseInstance) {
	    FOR_EACH_LIST_ITEM(
	      &pLogicalFilterNode->lstFilterNodeInstance,
	      pFilterNodeInstance) {

		if(pDeviceNode == NULL || 
		   pDeviceNode == pFilterNodeInstance->pDeviceNode) {
		    pFilterNodeInstance->AddRef();
		    ASSERT(NT_SUCCESS(Status));
		    goto exit;
		}

	    } END_EACH_LIST_ITEM
	}
    }
    Status = Create(&pFilterNodeInstance, pLogicalFilterNode->pFilterNode);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    pFilterNodeInstance->pDeviceNode = pDeviceNode;
    pFilterNodeInstance->AddList(&pLogicalFilterNode->lstFilterNodeInstance);
exit:
    *ppFilterNodeInstance = pFilterNodeInstance;
    return(Status);
}

NTSTATUS
CFilterNodeInstance::Create(
    PFILTER_NODE_INSTANCE *ppFilterNodeInstance,
    PFILTER_NODE pFilterNode
)
{
    PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pFilterNode);
    pFilterNodeInstance = new FILTER_NODE_INSTANCE;
    if(pFilterNodeInstance == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    pFilterNodeInstance->pFilterNode = pFilterNode;
    pFilterNodeInstance->AddRef();


    if(pFilterNode->GetType() & FILTER_TYPE_GFX) {
        //
        // if it is a GFX do not try to open the device, just re-use
        // the file object which we cached during AddGfx
        //
        pFilterNodeInstance->pFileObject = pFilterNode->GetFileObject();
        pFilterNodeInstance->hFilter = NULL;
        Status = STATUS_SUCCESS;
    }
    else {
        //
        // if it is not a GFX go ahead and open the device.
        //
        Status = pFilterNode->OpenDevice(&pFilterNodeInstance->hFilter);
    }
    if(!NT_SUCCESS(Status)) {
	DPF2(10, "CFilterNodeInstance::Create OpenDevice Failed: %08x FN: %08x",
	  Status,
	  pFilterNode);
	pFilterNodeInstance->hFilter = NULL;
	goto exit;
    }

    if (pFilterNodeInstance->hFilter) {
        Status = ObReferenceObjectByHandle(
          pFilterNodeInstance->hFilter,
          GENERIC_READ | GENERIC_WRITE,
          NULL,
          KernelMode,
          (PVOID*)&pFilterNodeInstance->pFileObject,
          NULL);
    }

    if(!NT_SUCCESS(Status)) {
	Trap();
        pFilterNodeInstance->pFileObject = NULL;
	goto exit;
    }

    AssertFileObject(pFilterNodeInstance->pFileObject);
    Status = pFilterNodeInstance->RegisterTargetDeviceChangeNotification();
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    DPF2(95, "CFilterNodeInstance::Create %08x FN: %08x",
      pFilterNodeInstance,
      pFilterNode);
exit:
    if(!NT_SUCCESS(Status)) {
        if (pFilterNodeInstance) {
	    pFilterNodeInstance->Destroy();
        }
	pFilterNodeInstance = NULL;
    }
    *ppFilterNodeInstance = pFilterNodeInstance;
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CFilterNodeInstance::RegisterTargetDeviceChangeNotification(
)
{
    NTSTATUS Status;

    ASSERT(gpDeviceInstance != NULL);
    ASSERT(gpDeviceInstance->pPhysicalDeviceObject != NULL);
    ASSERT(pNotificationHandle == NULL);

    Status = IoRegisterPlugPlayNotification(
      EventCategoryTargetDeviceChange,
      0,
      pFileObject,
      gpDeviceInstance->pPhysicalDeviceObject->DriverObject,
      (NTSTATUS (*)(PVOID, PVOID))
	CFilterNodeInstance::TargetDeviceChangeNotification,
      this,
      &pNotificationHandle);

    if(!NT_SUCCESS(Status)) {
	if(Status != STATUS_NOT_IMPLEMENTED) {
	    goto exit;
	}
	Status = STATUS_SUCCESS;
    }
    DPF2(100, "RegisterTargetDeviceChangeNotification: FNI: %08x PFO: %08x", 
      this,
      this->pFileObject);
exit:
    return(Status);
}

VOID
CFilterNodeInstance::UnregisterTargetDeviceChangeNotification(
)
{
    HANDLE hNotification;

    DPF1(100, "UnregisterTargetDeviceChangeNotification: FNI: %08x", this);
    hNotification = pNotificationHandle;
    if(hNotification != NULL) {
	pNotificationHandle = NULL;
	IoUnregisterPlugPlayNotification(hNotification);
    }
}

NTSTATUS
CFilterNodeInstance::DeviceQueryRemove(
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PDEVICE_NODE pDeviceNode;
    PGRAPH_NODE pGraphNode;

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

	FOR_EACH_LIST_ITEM(&pDeviceNode->lstGraphNode, pGraphNode) {

	    FOR_EACH_LIST_ITEM(
	      &pGraphNode->lstGraphNodeInstance,
	      pGraphNodeInstance) {

	       for(ULONG n = 0;
		 n < pGraphNodeInstance->Topology.TopologyNodesCount;
		 n++) {
		    pGraphNodeInstance->
		      papFilterNodeInstanceTopologyTable[n]->Destroy();

		    pGraphNodeInstance->
		      papFilterNodeInstanceTopologyTable[n] = NULL;
	       }

	    } END_EACH_LIST_ITEM

	} END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM

    return(STATUS_SUCCESS);
}

NTSTATUS
CFilterNodeInstance::TargetDeviceChangeNotification(
    IN PTARGET_DEVICE_REMOVAL_NOTIFICATION pNotification,
    IN PFILTER_NODE_INSTANCE pFilterNodeInstance
)
{
    DPF3(5, "TargetDeviceChangeNotification: FNI: %08x PFO: %08x %s", 
      pFilterNodeInstance,
      pNotification->FileObject,
      DbgGuid2Sz(&pNotification->Event));

    if(IsEqualGUID(
      &pNotification->Event,
      &GUID_TARGET_DEVICE_REMOVE_COMPLETE) ||
      IsEqualGUID(
      &pNotification->Event,
      &GUID_TARGET_DEVICE_QUERY_REMOVE)) {
	NTSTATUS Status = STATUS_SUCCESS;
	LARGE_INTEGER li = {0, 10000};	// wait for 1 ms

	Status = KeWaitForMutexObject(
	  &gMutex,
	  Executive,
	  KernelMode,
	  FALSE,
	  &li);

	if(Status != STATUS_TIMEOUT) {

	    DeviceQueryRemove();
	    ReleaseMutex();
	}
	else {
	    DPF1(5, "TargetDeviceChangeNotification: FAILED %08x", Status);
	}
    }
    return(STATUS_SUCCESS);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CFilterNodeInstance::Dump(
)
{
    if(this == NULL) {
	return(STATUS_CONTINUE);
    }
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("FNI: %08x cRef %02x FO %08x H %08x DN %08x FN %08x NH %08x\n",
	  this,
	  cReference,
	  pFileObject,
	  hFilter,
	  pDeviceNode,
	  pFilterNode,
	  pNotificationHandle);
	dprintf("     %s\n", pFilterNode->DumpName());
    }
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\fn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   fn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//  To Do:     Date   Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

EXTERN_C VOID KeAttachProcess(PVOID);
EXTERN_C VOID KeDetachProcess(VOID);

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

PLIST_FILTER_NODE gplstFilterNode = NULL;
PLIST_MULTI_LOGICAL_FILTER_NODE gplstLogicalFilterNode = NULL;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
InitializeFilterNode()
{
    if(gplstFilterNode == NULL) {
    gplstFilterNode = new LIST_FILTER_NODE;
    if(gplstFilterNode == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    }
    if(gplstLogicalFilterNode == NULL) {
    gplstLogicalFilterNode = new LIST_MULTI_LOGICAL_FILTER_NODE;
    if(gplstLogicalFilterNode == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    }
    return(STATUS_SUCCESS);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID
UninitializeFilterNode()
{
    PFILTER_NODE pFilterNode;

    FOR_EACH_LIST_ITEM_DELETE(gplstFilterNode, pFilterNode) {
        if (pFilterNode->pDeviceNode) {
            pFilterNode->pDeviceNode->pFilterNode=NULL;
        }
        delete pFilterNode;
    DELETE_LIST_ITEM(gplstFilterNode);
    } END_EACH_LIST_ITEM

    delete gplstFilterNode;
    gplstFilterNode = NULL;
    delete gplstLogicalFilterNode;
    gplstLogicalFilterNode = NULL;
}

//---------------------------------------------------------------------------

CFilterNode::CFilterNode(
    ULONG fulType
)
{
    ASSERT(gplstFilterNode != NULL);
    SetType(fulType);
    AddListEnd(gplstFilterNode);
    DPF2(60, "CFilterNode: %08x %s", this, DumpName());
}

CFilterNode::~CFilterNode(
)
{
    PFILTER_NODE pFilterNode;

    Assert(this);
    DPF2(60, "~CFilterNode: %08x %s", this, DumpName());
    RemoveListCheck();
    if (pDeviceNode) {
        pDeviceNode->pFilterNode = NULL;
    }
    if (pFileObject) {
        ::ObDereferenceObject(pFileObject);
        pFileObject = NULL;
    }
    delete pDeviceNode;

    FOR_EACH_LIST_ITEM(gplstFilterNode, pFilterNode) {
    pFilterNode->lstConnectedFilterNode.RemoveList(this);
    } END_EACH_LIST_ITEM

    // Free all other memory
    lstFreeMem.EnumerateList(CListDataItem::Destroy);
}

NTSTATUS
CFilterNode::Create(
    PWSTR pwstrDeviceInterface
)
{
    PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hkeyDeviceClass = NULL;
    HANDLE hkeySysaudio = NULL;
    UNICODE_STRING ustrFilterName;
    KSPROPERTY PropertyComponentId;
    KSCOMPONENTID ComponentId;
    ULONG BytesReturned;
    PFILE_OBJECT pFileObject;


    this->pwstrDeviceInterface = new WCHAR[wcslen(pwstrDeviceInterface) + 1];
    if(this->pwstrDeviceInterface == NULL) {
    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto exit;
    }
    wcscpy(this->pwstrDeviceInterface, pwstrDeviceInterface);

    Status = lstFreeMem.AddList(this->pwstrDeviceInterface);
    if(!NT_SUCCESS(Status)) {
    Trap();
    delete this->pwstrDeviceInterface;
    goto exit;
    }

    Status = CFilterNodeInstance::Create(&pFilterNodeInstance, this);
    if(!NT_SUCCESS(Status)) {
    goto exit;
    }
    pFileObject = pFilterNodeInstance->pFileObject;

    // Get the filter's friendly name
    RtlInitUnicodeString(&ustrFilterName, this->pwstrDeviceInterface);

    Status = IoOpenDeviceInterfaceRegistryKey(
      &ustrFilterName,
      KEY_READ,
      &hkeyDeviceClass);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = OpenRegistryKey(L"Sysaudio", &hkeySysaudio, hkeyDeviceClass);
    if(NT_SUCCESS(Status)) {
    Status = QueryRegistryValue(hkeySysaudio, L"Disabled", &pkvfi);
    if(NT_SUCCESS(Status)) {
        if(pkvfi->Type == REG_DWORD) {
        if(*((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset))) {
            Status = STATUS_SERVER_DISABLED;
            delete pkvfi;
            goto exit;
        }
        }
        delete pkvfi;
    }
    Status = QueryRegistryValue(hkeySysaudio, L"Device", &pkvfi);
    if(NT_SUCCESS(Status)) {
        if(pkvfi->Type == REG_SZ && pkvfi->DataLength > 0) {
        Status = lstFreeMem.AddList(pkvfi);
        if(!NT_SUCCESS(Status)) {
            Trap();
            delete pkvfi;
            goto exit;
        }
        Status = AddDeviceInterfaceMatch(
          (PWSTR)(((PUCHAR)pkvfi) + pkvfi->DataOffset));

        if(!NT_SUCCESS(Status)) {
            Trap();
            delete pkvfi;
            goto exit;
        }
        }
        else {
        delete pkvfi;
        }
    }

    Status = QueryRegistryValue(hkeySysaudio, L"Order", &pkvfi);
    if(NT_SUCCESS(Status)) {
        if(pkvfi->Type == REG_DWORD) {
        ulOrder = *((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset));
        }
        delete pkvfi;
    }

    Status = QueryRegistryValue(hkeySysaudio, L"Capture", &pkvfi);
    if(NT_SUCCESS(Status)) {
        if(pkvfi->Type == REG_DWORD) {
        if(*((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset))) {
            ulFlags |= FN_FLAGS_CAPTURE;
        }
        else {
            ulFlags |= FN_FLAGS_NO_CAPTURE;
        }
        }
        delete pkvfi;
    }

    Status = QueryRegistryValue(hkeySysaudio, L"Render", &pkvfi);
    if(NT_SUCCESS(Status)) {
        if(pkvfi->Type == REG_DWORD) {
        if(*((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset))) {
            ulFlags |= FN_FLAGS_RENDER;
        }
        else {
            ulFlags |= FN_FLAGS_NO_RENDER;
        }
        }
        delete pkvfi;
    }
    }

    Status = QueryRegistryValue(hkeyDeviceClass, L"FriendlyName", &pkvfi);
    if(NT_SUCCESS(Status)) {
    if(pkvfi->Type == REG_SZ && pkvfi->DataLength > 0) {
        Status = lstFreeMem.AddList(pkvfi);
        if(!NT_SUCCESS(Status)) {
        Trap();
        delete pkvfi;
        goto exit;
        }
        pwstrFriendlyName = (PWSTR)(((PUCHAR)pkvfi) + pkvfi->DataOffset);
    }
    else {
        delete pkvfi;
    }
    }

    // Get the component Id of the filter
    PropertyComponentId.Set = KSPROPSETID_General;
    PropertyComponentId.Id = KSPROPERTY_GENERAL_COMPONENTID;
    PropertyComponentId.Flags = KSPROPERTY_TYPE_GET;

    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &PropertyComponentId,
      sizeof(PropertyComponentId),
      &ComponentId,
      sizeof(ComponentId),
      &BytesReturned);

    // Store the component Id
    if (NT_SUCCESS(Status)) {

        ASSERT(BytesReturned >= sizeof(ComponentId));

        this->ComponentId = new KSCOMPONENTID;
        if (this->ComponentId) {

            RtlCopyMemory(this->ComponentId,
                          &ComponentId,
                          sizeof(KSCOMPONENTID));

            Status = lstFreeMem.AddList(this->ComponentId);
            if(!NT_SUCCESS(Status)) {
                delete this->ComponentId;
                this->ComponentId = NULL;
            }
        }
    }
    else {
        this->ComponentId = NULL;
    }

    Status = this->ProfileFilter(pFileObject);
exit:
    if(hkeySysaudio != NULL) {
        ZwClose(hkeySysaudio);
    }
    if(hkeyDeviceClass != NULL) {
        ZwClose(hkeyDeviceClass);
    }
    if (pFilterNodeInstance) {
        pFilterNodeInstance->Destroy();
    }
    return(Status);
}

NTSTATUS
CFilterNode::ProfileFilter(
    PFILE_OBJECT pFileObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSMULTIPLE_ITEM pCategories = NULL;
    PKSMULTIPLE_ITEM pConnections = NULL;
    PKSMULTIPLE_ITEM pNodes = NULL;
    ULONG PinId;
    PPIN_INFO pPinInfo;
    ULONG i;
    KSTOPOLOGY Topology;

    RtlZeroMemory(&Topology, sizeof(Topology));

    // Get the number of pins
    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_CTYPES,
      0,			// doesn't matter for ctypes
      sizeof(cPins),
      (PVOID)&cPins);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    // Get the topology of the filter
    Status = GetProperty(
      pFileObject,
      &KSPROPSETID_Topology,
      KSPROPERTY_TOPOLOGY_CATEGORIES,
      0,
      NULL,
      (PVOID*)&pCategories);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(pCategories != NULL) {
	Topology.CategoriesCount = pCategories->Count;
	Topology.Categories = (GUID*)(pCategories + 1);

	ULONG fulType = 0;
	for(i = 0; i < pCategories->Count; i++) {
	    GetFilterTypeFromGuid((LPGUID)&Topology.Categories[i], &fulType);
	}
	SetType(fulType);
    }

    Status = GetProperty(
      pFileObject,
      &KSPROPSETID_Topology,
      KSPROPERTY_TOPOLOGY_NODES,
      0,
      NULL,
      (PVOID*)&pNodes);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(pNodes != NULL) {
	Status = lstFreeMem.AddList(pNodes);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    delete pNodes;
	    goto exit;
	}
	Topology.TopologyNodesCount = pNodes->Count;
	Topology.TopologyNodes = (GUID*)(pNodes + 1);
    }

    Status = GetProperty(
      pFileObject,
      &KSPROPSETID_Topology,
      KSPROPERTY_TOPOLOGY_CONNECTIONS,
      0,
      NULL,
      (PVOID*)&pConnections);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(pConnections != NULL) {
	Topology.TopologyConnectionsCount = pConnections->Count;
	Topology.TopologyConnections = 
	  (PKSTOPOLOGY_CONNECTION)(pConnections + 1);
    }

    // Each pin loop
    for(PinId = 0; PinId < cPins; PinId++) {
	pPinInfo = new PIN_INFO(this, PinId);
	if(pPinInfo == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    Trap();
	    goto exit;
	}
	Status = pPinInfo->Create(pFileObject);
	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}
    }

    Status = CreateTopology(this, &Topology);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    Status = lstPinInfo.EnumerateList(CPinInfo::CreatePhysicalConnection);
    if(Status == STATUS_CONTINUE) {
	Status = STATUS_SUCCESS;
    }
    else if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    Status = CLogicalFilterNode::CreateAll(this);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
exit:
    delete pCategories;
    delete pConnections;
    return(Status);
}

NTSTATUS
CFilterNode::DuplicateForCapture(
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNode = NULL;

    if(GetType() & FILTER_TYPE_DUP_FOR_CAPTURE) {

    FOR_EACH_LIST_ITEM(&lstLogicalFilterNode, pLogicalFilterNode) {

        if(!pLogicalFilterNode->IsRenderAndCapture()) {
            ASSERT(NT_SUCCESS(Status));
            goto exit;
        }

    } END_EACH_LIST_ITEM

    pFilterNode = new FILTER_NODE(GetType());
    if(pFilterNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        Trap();
        goto exit;
    }
    Status = pFilterNode->Create(GetDeviceInterface());
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    SetRenderOnly();
    pFilterNode->SetCaptureOnly();
    }
exit:
    if(!NT_SUCCESS(Status)) {
    Trap();
    delete pFilterNode;
    }
    return(Status);
}

BOOL
CFilterNode::IsDeviceInterfaceMatch(
    PDEVICE_NODE pDeviceNode
)
{
    PWSTR pwstr, pwstrDeviceInterface;
    UNICODE_STRING String1, String2;

    Assert(this);
    if(lstwstrDeviceInterfaceMatch.IsLstEmpty()) {
    return(TRUE);
    }
    //
    // The +4 for both the strings is to eliminate the \\.\ differences in
    // user mode device interface names & kernel mode device interface names
    //
    pwstrDeviceInterface = pDeviceNode->GetDeviceInterface()+4;
    RtlInitUnicodeString(&String2, pwstrDeviceInterface);
    FOR_EACH_LIST_ITEM(&lstwstrDeviceInterfaceMatch, pwstr) {
        RtlInitUnicodeString(&String1, (pwstr+4));
        if (RtlEqualUnicodeString(&String1, &String2, TRUE)) {
            return(TRUE);
        }
    } END_EACH_LIST_ITEM

    return(FALSE);
}

VOID
CFilterNode::SetType(
    ULONG fulType
)
{
    this->fulType |= fulType;
    //
    // This is because of left overs (type bridge) in the registry
    // that look like aliases.
    //
    if(this->fulType & FILTER_TYPE_TOPOLOGY) {
    this->fulType = (FILTER_TYPE_AUDIO | FILTER_TYPE_TOPOLOGY);
    }
    GetDefaultOrder(this->fulType, &ulOrder);
}

NTSTATUS
CFilterNode::CreatePin(
    PKSPIN_CONNECT pPinConnect,
    ACCESS_MASK Access,
    PHANDLE pHandle
)
{
    NTSTATUS Status;

    ::KeAttachProcess(this->pProcess);
    Status = KsCreatePin(this->hFileHandle,
                         pPinConnect,
                         Access,
                         pHandle);
    ::KeDetachProcess();
    return(Status);
}

BOOL
CFilterNode::DoesGfxMatch(
    HANDLE hGfx,
    PWSTR pwstrDeviceName,
    ULONG GfxOrder
)
{
    ULONG DeviceCount;
    UNICODE_STRING usInDevice, usfnDevice;
    PWSTR pwstr;


    RtlInitUnicodeString(&usInDevice, (pwstrDeviceName+4));

    //
    // Skip if it is not a GFX
    //
    DPF1(90, "DoesGfxMatch::         fultype=%x", this->fulType);
    if (!(this->fulType & FILTER_TYPE_GFX)) {
        return(FALSE);
    }

    //
    // If it is a valid handle value, check whether the handle matches
    //
    if (hGfx) {
        if (this->hFileHandle != hGfx) {
            return(FALSE);
        }
    }
    //
    // Skip if the order does not match
    //
    DPF1(90, "DoesGfxMatch::         order=%x", this->ulOrder);
    if (GfxOrder != this->ulOrder) {
        return(FALSE);
    }
    //
    // Skip if the match device list is empty :: should not happen with GFX
    //
    if(lstwstrDeviceInterfaceMatch.IsLstEmpty()) {
        ASSERT(!"GFX with no device to attach to!\n");
        return(FALSE);
    }
    //
    // Check if any of the Match device strings matches the device interface
    // passed in. (In case of GFX we should have only one string though)
    //
    DeviceCount = 0;
    FOR_EACH_LIST_ITEM(&lstwstrDeviceInterfaceMatch, pwstr) {
        ASSERT(DeviceCount == 0);
        RtlInitUnicodeString(&usfnDevice, (pwstr+4));
        DPF1(95, "DoesGfxMatch:: new di = %s)", DbgUnicode2Sz(pwstrDeviceName));
        DPF1(95, "DoesGfxMatch:: old di = %s)", DbgUnicode2Sz(pwstr));
        if (RtlEqualUnicodeString(&usInDevice, &usfnDevice, TRUE)) {
            DPF1(90, "Found a duplicate GFX, pFilterNode = %x", this);
            return(TRUE);
        }
        DeviceCount++;
    } END_EACH_LIST_ITEM
    return (FALSE);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ULONG nFilter = 0;

VOID
DumpSysAudio(
)
{
    if(gplstFilterNode != NULL) {
    gplstFilterNode->Dump();
    }
    if(gplstDeviceNode != NULL) {
    gplstDeviceNode->Dump();
    }
    if(gplstLogicalFilterNode != NULL &&
      (ulDebugFlags & (DEBUG_FLAGS_FILTER |
              DEBUG_FLAGS_DEVICE |
              DEBUG_FLAGS_LOGICAL_FILTER)) ==
              DEBUG_FLAGS_LOGICAL_FILTER) {
    gplstLogicalFilterNode->Dump();
    }
}

ENUMFUNC
CFilterNode::Dump(
)
{
    Assert(this);
    // .sf
    if(ulDebugFlags & (DEBUG_FLAGS_FILTER | DEBUG_FLAGS_OBJECT)) {
    if(ulDebugNumber == MAXULONG || ulDebugNumber == nFilter) {
        if(ulDebugFlags & DEBUG_FLAGS_ADDRESS) {
        dprintf("%d: %08x %s\n", nFilter, this, DumpName());
        }
        else {
        dprintf("%d: %s\n", nFilter, DumpName());
        }
        // .sfv
        if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
        dprintf("FN: %08x DN %08x cPins %08x ulOrder %08x\n",
          this,
          pDeviceNode,
          cPins,
          ulOrder);
        dprintf("    fulType: %08x ", fulType);
        DumpfulType(fulType);
        dprintf("\n    ulFlags: %08x ", ulFlags);
        if(ulFlags & FN_FLAGS_RENDER) {
            dprintf("RENDER ");
        }
        if(ulFlags & FN_FLAGS_NO_RENDER) {
            dprintf("NO_RENDER ");
        }
        if(ulFlags & FN_FLAGS_CAPTURE) {
            dprintf("CAPTURE ");
        }
        if(ulFlags & FN_FLAGS_NO_CAPTURE) {
            dprintf("NO_CAPTURE ");
        }
        dprintf("\n");
        if(pwstrDeviceInterface != NULL) {
            dprintf("    %s\n", DumpDeviceInterface());
        }
        PWSTR pwstr;

        FOR_EACH_LIST_ITEM(&lstwstrDeviceInterfaceMatch, pwstr) {
            dprintf("    pwstrDevice:\n    %s\n", DbgUnicode2Sz(pwstr));
        } END_EACH_LIST_ITEM

        dprintf("    lstLFN: ");
        lstLogicalFilterNode.DumpAddress();
        dprintf("\n    lstConnFN:");
        lstConnectedFilterNode.DumpAddress();
        dprintf("\n");
        }
        // .sfp
        if(ulDebugFlags & DEBUG_FLAGS_PIN) {
        lstPinInfo.Dump();
        }
        // .sft
        if(ulDebugFlags & DEBUG_FLAGS_TOPOLOGY) {
        lstTopologyNode.Dump();
        // .sftx
        if(ulDebugFlags & DEBUG_FLAGS_DETAILS) {
            lstTopologyConnection.Dump();
        }
        }
        // .sfl
        if(ulDebugFlags & DEBUG_FLAGS_LOGICAL_FILTER) {
        lstLogicalFilterNode.Dump();
        }
        if(ulDebugFlags &
          (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_PIN | DEBUG_FLAGS_TOPOLOGY)) {
        dprintf("\n");
        }
    }
    nFilter++;
    }
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\fni.h ===
//---------------------------------------------------------------------------
//
//  Module:   		fni.h
//
//  Description:	Filter Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CFilterNodeInstance : public CListDoubleItem
{
public:
    ~CFilterNodeInstance(
    );

    static NTSTATUS
    Create(
	PFILTER_NODE_INSTANCE *ppFilterNodeInstance,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PDEVICE_NODE pDeviceNode,
	BOOL fReuseInstance
    );

    static NTSTATUS
    Create(
	PFILTER_NODE_INSTANCE *ppFilterNodeInstance,
	PFILTER_NODE pFilterNode
    );

    VOID 
    AddRef(
    )
    {
	Assert(this);
	++cReference;
    };

    ENUMFUNC 
    Destroy()
    {
	if(this != NULL) {
	    Assert(this);
	    DPF1(95, "CFilterNodeInstance::Destroy: %08x", this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    NTSTATUS
    RegisterTargetDeviceChangeNotification(
    );

    VOID
    UnregisterTargetDeviceChangeNotification(
    );

    static NTSTATUS
    CFilterNodeInstance::DeviceQueryRemove(
    );

    static NTSTATUS
    TargetDeviceChangeNotification(
	IN PTARGET_DEVICE_REMOVAL_NOTIFICATION pNotification,
	IN PFILTER_NODE_INSTANCE pFilterNodeInstance
    );

#ifdef DEBUG
    ENUMFUNC Dump();
#endif

private:
    LONG cReference;
public:
    PFILTER_NODE pFilterNode;
    PDEVICE_NODE pDeviceNode;
    PFILE_OBJECT pFileObject;
    HANDLE hFilter;
    HANDLE pNotificationHandle;
    DefineSignature(0x20494E46);			// FNI

} FILTER_NODE_INSTANCE, *PFILTER_NODE_INSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<FILTER_NODE_INSTANCE> LIST_FILTER_NODE_INSTANCE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\fn.h ===
//---------------------------------------------------------------------------
//
//  Module:         fn.h
//
//  Description:    filter node classes
//
//      Filter nodes represent the physical ks filter and along with PinInfo,
//  PinNodes, TopologyNodes, TopologyPins, TopologyConnections objects
//  represent the whole filter.  These objects are built when sysaudio
//  is notified via audio class device interfaces arrivals.
//
//  There is some info read from the registry for each filter.  Various
//  defaults can be overriden:
//
//  Device Parameters/Sysaudio/Disabled     DWORD
//
//      If !0, the filter isn't profiled or used in any graph.
//
//  Device Parameters/Sysaudio/Capture  DWORD
//
//      If !0, puts the filters in the capture side of the graph.  See
//      the FILTER_TYPE_CAPTURE define for the particular default of
//      a filter type.
//
//  Device Parameters/Sysaudio/Render   DWORD
//
//      If !0, puts the filters in the render side of the graph.  See
//      the FILTER_TYPE_RENDER define for the particular default of
//      a filter type.
//
//  Device Parameters/Sysaudio/Order    DWORD
//
//      Overrides the default order in the graph.  See the ORDER_XXXX
//      defines below for the default.
//
//  Device Parameters/Sysaudio/Device   STRING
//
//      The device interface (in the KSCATEGORY_AUDIO class) of the
//      renderer and/or capturer device graph to put this filter.  The
//      default is to put the filter in all device graphs.
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define OVERHEAD_NONE               0
#define OVERHEAD_LOWEST             1
#define OVERHEAD_LOW                0x00001000
#define OVERHEAD_HARDWARE           0x00010000
#define OVERHEAD_MEDIUM             0x00100000
#define OVERHEAD_SOFTWARE           0x01000000
#define OVERHEAD_HIGH               0x10000000
#define OVERHEAD_HIGHEST            MAXULONG

//---------------------------------------------------------------------------

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// MAKE SURE THAT NO FILTER ORDER IS ADDED BETWEEN GFX_FIRST & GFX_LAST
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#define ORDER_NONE                  0
#define ORDER_LOWEST                1
#define ORDER_ENDPOINT              1
#define ORDER_VIRTUAL               0x10000000
#define ORDER_MIC_ARRAY_PROCESSOR   0x15000000
#define ORDER_AEC                   0x40000000
#define ORDER_GFX                   0x50000000
#define ORDER_SPLITTER              0x20000000
#define ORDER_MIXER                 0xA0000000
#define ORDER_SYNTHESIZER           0xB0000000
#define ORDER_DATA_TRANSFORM        0xB0000000
#define ORDER_DRM_DESCRAMBLE        0xB0000000
#define ORDER_INTERFACE_TRANSFORM   0xC0000000
#define ORDER_HIGHEST               MAXULONG

#define ORDER_CAPTURE_GFX_LAST      (ORDER_SPLITTER-1)
#define ORDER_CAPTURE_GFX_FIRST     0x10000001

#define ORDER_RENDER_GFX_LAST       ORDER_GFX
#define ORDER_RENDER_GFX_FIRST      (ORDER_AEC+1)

//---------------------------------------------------------------------------

#define FILTER_TYPE_AUDIO           0x00000001
#define FILTER_TYPE_TOPOLOGY            0x00000002
#define FILTER_TYPE_BRIDGE          0x00000004
#define FILTER_TYPE_RENDERER            0x00000008
#define FILTER_TYPE_CAPTURER            0x00000010
#define FILTER_TYPE_MIXER           0x00000020
#define FILTER_TYPE_GFX             0x00000040
#define FILTER_TYPE_AEC             0x00000080
#define FILTER_TYPE_DATA_TRANSFORM      0x00000100
#define FILTER_TYPE_COMMUNICATION_TRANSFORM 0x00000200
#define FILTER_TYPE_INTERFACE_TRANSFORM     0x00000400
#define FILTER_TYPE_MEDIUM_TRANSFORM        0x00000800
#define FILTER_TYPE_SPLITTER            0x00001000
#define FILTER_TYPE_SYNTHESIZER         0x00002000
#define FILTER_TYPE_DRM_DESCRAMBLE      0x00004000
#define FILTER_TYPE_MIC_ARRAY_PROCESSOR     0x00008000
#define FILTER_TYPE_VIRTUAL         0x00010000

#define FILTER_TYPE_ENDPOINT        (FILTER_TYPE_BRIDGE | \
                     FILTER_TYPE_RENDERER | \
                     FILTER_TYPE_CAPTURER)

#define FILTER_TYPE_LOGICAL_FILTER  (FILTER_TYPE_MIXER | \
                     FILTER_TYPE_GFX | \
                     FILTER_TYPE_AEC | \
                     FILTER_TYPE_DATA_TRANSFORM | \
                     FILTER_TYPE_INTERFACE_TRANSFORM | \
                     FILTER_TYPE_SPLITTER | \
                     FILTER_TYPE_SYNTHESIZER | \
                     FILTER_TYPE_DRM_DESCRAMBLE | \
                         FILTER_TYPE_MIC_ARRAY_PROCESSOR | \
                     FILTER_TYPE_VIRTUAL)

#define FILTER_TYPE_RENDER      (FILTER_TYPE_INTERFACE_TRANSFORM | \
                     FILTER_TYPE_GFX | \
                         FILTER_TYPE_AEC |  \
                     FILTER_TYPE_MIXER | \
                     FILTER_TYPE_SYNTHESIZER | \
                     FILTER_TYPE_DRM_DESCRAMBLE | \
                     FILTER_TYPE_VIRTUAL)

#define FILTER_TYPE_CAPTURE     (FILTER_TYPE_AEC | \
                         FILTER_TYPE_MIC_ARRAY_PROCESSOR | \
                     FILTER_TYPE_MIXER | \
                     FILTER_TYPE_SPLITTER)

#define FILTER_TYPE_PRE_MIXER       (FILTER_TYPE_SYNTHESIZER | \
                     FILTER_TYPE_DRM_DESCRAMBLE | \
                     FILTER_TYPE_INTERFACE_TRANSFORM )

#define FILTER_TYPE_NORMAL_TOPOLOGY (FILTER_TYPE_INTERFACE_TRANSFORM | \
                     FILTER_TYPE_GFX | \
                     FILTER_TYPE_ENDPOINT | \
                         FILTER_TYPE_AEC | \
                         FILTER_TYPE_MIC_ARRAY_PROCESSOR | \
                     FILTER_TYPE_SYNTHESIZER | \
                     FILTER_TYPE_DRM_DESCRAMBLE | \
                     FILTER_TYPE_MIXER | \
                     FILTER_TYPE_SPLITTER)

#define FILTER_TYPE_MIXER_TOPOLOGY  (FILTER_TYPE_VIRTUAL)

#define FILTER_TYPE_NO_BYPASS       (FILTER_TYPE_GFX)

#define FILTER_TYPE_NOT_SELECT      (FILTER_TYPE_AEC | \
                         FILTER_TYPE_MIC_ARRAY_PROCESSOR)

#define FILTER_TYPE_GLOBAL_SELECT   (FILTER_TYPE_AEC)

#define FILTER_TYPE_DUP_FOR_CAPTURE (FILTER_TYPE_MIXER)

//---------------------------------------------------------------------------

#define FN_FLAGS_RENDER         0x00000001
#define FN_FLAGS_NO_RENDER      0x00000002
#define FN_FLAGS_CAPTURE        0x00000004
#define FN_FLAGS_NO_CAPTURE     0x00000008

//---------------------------------------------------------------------------
// Class List Definitions
//---------------------------------------------------------------------------

typedef ListDoubleDestroy<CFilterNode> LIST_FILTER_NODE, *PLIST_FILTER_NODE;

//---------------------------------------------------------------------------

typedef ListData<CFilterNode> LIST_DATA_FILTER_NODE, *PLIST_DATA_FILTER_NODE;

//---------------------------------------------------------------------------

typedef ListDataAssertLess<WCHAR> LIST_WSTR;

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CFilterNode : public CListDoubleItem
{
public:
    CFilterNode(
        ULONG fulType
    );

    ~CFilterNode(
    );

    NTSTATUS
    Create(
    PWSTR pwstrDeviceInterface
    );

    NTSTATUS
    ProfileFilter(
	PFILE_OBJECT pFileObject
    );

    NTSTATUS
    DuplicateForCapture(
    );

    ENUMFUNC
    Destroy(
    )
    {
    Assert(this);
    delete this;
    return(STATUS_CONTINUE);
    };

    NTSTATUS
    OpenDevice(
    OUT PHANDLE pHandle
    )
    {
    ASSERT(pwstrDeviceInterface != NULL);
    return(::OpenDevice(pwstrDeviceInterface, pHandle));
    };

    BOOL
    IsDeviceInterfaceMatch(
    PDEVICE_NODE pDeviceNode
    );

    NTSTATUS
    AddDeviceInterfaceMatch(
    PWSTR pwstr
    )
    {
    return(lstwstrDeviceInterfaceMatch.AddList(pwstr));
    };

    ULONG
    GetFlags(
    )
    {
    return(ulFlags);
    };

    VOID
    SetRenderOnly(
    )
    {
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    FOR_EACH_LIST_ITEM(&lstLogicalFilterNode, pLogicalFilterNode) {
        pLogicalFilterNode->SetRenderOnly();
    } END_EACH_LIST_ITEM
    };

    VOID
    SetCaptureOnly(
    )
    {
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    FOR_EACH_LIST_ITEM(&lstLogicalFilterNode, pLogicalFilterNode) {
        pLogicalFilterNode->SetCaptureOnly();
    } END_EACH_LIST_ITEM
    };

    ULONG
    GetOrder(
    )
    {
    return(ulOrder);
    };

    VOID
    SetOrder(
    ULONG ulOrder
    )
    {
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    FOR_EACH_LIST_ITEM(&lstLogicalFilterNode, pLogicalFilterNode) {
        pLogicalFilterNode->SetOrder(ulOrder);
    } END_EACH_LIST_ITEM
    this->ulOrder = ulOrder;
    };

    ULONG
    GetType(
    )
    {
    return(fulType);
    };

    VOID
    SetType(
    ULONG fulType
    );

    VOID
    SetRenderCaptureFlags(
    ULONG fulFlags
    )
    {
        //
        // 1 & 2 should be changed to use public header files
        //
        if (fulFlags == 1) {
            ulFlags |= FN_FLAGS_RENDER | FN_FLAGS_NO_CAPTURE;
        } else if (fulFlags == 2) {
            ulFlags |= FN_FLAGS_CAPTURE | FN_FLAGS_NO_RENDER;
        }
        else {
            Trap();
        }
    }

    PFILE_OBJECT
    GetFileObject(
    )
    {
        return(pFileObject);
    }

    VOID
    SetFileDetails(
    HANDLE Handle,
    PFILE_OBJECT pFileObject,
    PEPROCESS pProcess
    )
    {
        this->hFileHandle = Handle;
        this->pFileObject = pFileObject;
        this->pProcess = pProcess;
    }

    NTSTATUS
    ClearFileDetails(
    )
    {
        NTSTATUS Status;

        ::ObDereferenceObject(this->pFileObject);
        this->pFileObject = NULL;
        this->hFileHandle = 0;
        this->pProcess = NULL;
        return(STATUS_SUCCESS);
    }

    BOOL
    CFilterNode::DoesGfxMatch(
    HANDLE hGfx,
    PWSTR pwstrDeviceName,
    ULONG GfxOrder
    );

    NTSTATUS
    CreatePin(
    PKSPIN_CONNECT pPinConnect,
    ACCESS_MASK Access,
    PHANDLE pHandle
    );

    PKSCOMPONENTID
    GetComponentId(
    )
    {
        return(ComponentId);
    };

    PWSTR
    GetFriendlyName(
    )
    {
    return(pwstrFriendlyName);
    };

    VOID
    SetFriendlyName(
    PWSTR pwstr
    )
    {
    pwstrFriendlyName = pwstr;
    };

    PWSTR
    GetDeviceInterface(
    )
    {
    return(pwstrDeviceInterface);
    };

#ifdef DEBUG
    ENUMFUNC Dump();
    PSZ DumpName()
    {
    return(DbgUnicode2Sz(pwstrFriendlyName));
    };
    PSZ DumpDeviceInterface()
    {
    return(DbgUnicode2Sz(pwstrDeviceInterface));
    };
#endif
    PDEVICE_NODE pDeviceNode;
    LIST_PIN_INFO lstPinInfo;
    LIST_TOPOLOGY_NODE lstTopologyNode;
    LIST_DESTROY_TOPOLOGY_CONNECTION lstTopologyConnection;
    LIST_DESTROY_LOGICAL_FILTER_NODE lstLogicalFilterNode;
    LIST_DATA_FILTER_NODE lstConnectedFilterNode;
    CLIST_DATA lstFreeMem;          // list of blocks to free
private:
    LIST_WSTR lstwstrDeviceInterfaceMatch;
    PWSTR pwstrDeviceInterface;
    PWSTR pwstrFriendlyName;
    ULONG ulFlags;
    ULONG fulType;
    ULONG ulOrder;
    PKSCOMPONENTID ComponentId;
    PFILE_OBJECT pFileObject;
    HANDLE hFileHandle;
    PEPROCESS pProcess;
public:
    ULONG cPins;
    DefineSignature(0x20204E46);        // FN

} FILTER_NODE, *PFILTER_NODE;

//---------------------------------------------------------------------------
// Inline functions
//---------------------------------------------------------------------------

inline ULONG
CLogicalFilterNode::GetType(
)
{
    return(pFilterNode->GetType());
}

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PLIST_FILTER_NODE gplstFilterNode;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
InitializeFilterNode(
);

VOID
UninitializeFilterNode(
);

#ifdef DEBUG

VOID
DumpSysAudio(
);

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\gn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		gn.h
//
//  Description:	graph node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define GN_FLAGS_PLAYBACK			0x00000001
#define GN_FLAGS_RECORD				0x00000002
#define GN_FLAGS_MIDI			        0x00000004

#ifdef REGISTRY_PREFERRED_DEVICE
#define GN_FLAGS_PREFERRED_MASK			(GN_FLAGS_PLAYBACK | \
						 GN_FLAGS_RECORD | \
						 GN_FLAGS_MIDI)
#endif

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CGraphNode : public CListDoubleItem
{
public:
    CGraphNode(
        PDEVICE_NODE pDeviceNode,
        ULONG ulFlags
    );

    ~CGraphNode(
    );

    NTSTATUS
    Create(
    );

    ENUMFUNC
    Destroy(
    )
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

#ifdef DEBUG
    ENUMFUNC
    Dump(
    );
#endif

private:
    NTSTATUS
    Create(
	PLOGICAL_FILTER_NODE pLogicalFilterNode
    );

    NTSTATUS 
    CreateGraph(
	PPIN_NODE pPinNode,
	PCONNECT_NODE pConnectNodePrevious,
	PLOGICAL_FILTER_NODE pLogicalFilterNodePrevious,
	PGRAPH_PIN_INFO pGraphPinInfoPrevious,
	ULONG ulFlagsCurrent,
	ULONG ulOverhead
    );

    NTSTATUS
    CreateGraphToPin(
	PPIN_NODE pPinNode,
	PCONNECT_NODE pConnectNodePrevious,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PGRAPH_PIN_INFO pGraphPinInfo,
	ULONG ulFlagsCurrent,
	ULONG ulOverhead
    );

    NTSTATUS
    CreateGraphFromPin(
	PPIN_NODE pPinNode,
	PPIN_NODE pPinNodeTo,
	PCONNECT_NODE pConnectNode,
	PLOGICAL_FILTER_NODE pLogicalFilterNode,
	PGRAPH_PIN_INFO pGraphPinInfo,
	ULONG ulFlagsCurrent,
	ULONG ulOverhead
    );
public:
    PDEVICE_NODE pDeviceNode;
    LIST_PIN_NODE lstPinNode;
    LIST_START_NODE lstStartNode;
    LIST_START_INFO lstStartInfo;
    LIST_CONNECT_INFO lstConnectInfo;
    LIST_GRAPH_PIN_INFO lstGraphPinInfo;
    LIST_GRAPH_NODE_INSTANCE lstGraphNodeInstance;
    LIST_DESTROY_TOPOLOGY_CONNECTION lstTopologyConnection;
    LIST_MULTI_LOGICAL_FILTER_NODE lstLogicalFilterNode;
    LIST_MULTI_LOGICAL_FILTER_NODE lstLogicalFilterNodeNoBypass;
    ULONG ulFlags;
    DefineSignature(0x20204E47);				// GN

} GRAPH_NODE, *PGRAPH_NODE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<GRAPH_NODE> LIST_GRAPH_NODE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\gn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   gn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

ULONG gcGraphRecursion = 0;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CGraphNode::CGraphNode(
    PDEVICE_NODE pDeviceNode,
    ULONG ulFlags
)
{
    Assert(pDeviceNode);
    this->pDeviceNode = pDeviceNode;
    this->ulFlags = ulFlags;
    AddList(&pDeviceNode->lstGraphNode);
    DPF2(80, "CGraphNode %08x, DN: %08x", this, pDeviceNode);
}

CGraphNode::~CGraphNode(
)
{
    DPF1(80, "~CGraphNode: %08x", this);
    Assert(this);
    RemoveList();
}

NTSTATUS
CGraphNode::Create(
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;		
    NTSTATUS Status = STATUS_SUCCESS;

    DPF3(80, "CGraphNode::Create: GN %08x F %08x %s",
      this,
      this->ulFlags,
      pDeviceNode->DumpName());

    FOR_EACH_LIST_ITEM(&pDeviceNode->lstLogicalFilterNode, pLogicalFilterNode) {

	Status = Create(pLogicalFilterNode);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    if(!lstLogicalFilterNodeNoBypass.IsLstEmpty()) {
	lstStartNode.EnumerateList(CStartNode::RemoveBypassPaths, this);
    }
    if(this->ulFlags & FLAGS_MIXER_TOPOLOGY) {
	lstStartNode.EnumerateList(CStartNode::RemoveConnectedStartNode, this);
    }
    lstStartInfo.EnumerateList(CStartInfo::CreatePinInfoConnection, this);

    pGraphNodeInstance = new GRAPH_NODE_INSTANCE(this);
    if(pGraphNodeInstance == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    Status = pGraphNodeInstance->Create();
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    //
    // The "ulSysaudioNodeNumber" field in the topology node isn't
    // valid until CGraphNodeInstance::Create and they are only valid
    // for this pGraphNode.
    //
    lstStartInfo.EnumerateList(CStartInfo::EnumStartInfo);
    delete pGraphNodeInstance;
exit:
    return(Status);
}

NTSTATUS
CGraphNode::Create(
    PLOGICAL_FILTER_NODE pLogicalFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulFlagsCurrent;
    PPIN_NODE pPinNode;

    DPF2(80, "CGraphNode::Create: LFN %08x %s",
      pLogicalFilterNode,
      pLogicalFilterNode->pFilterNode->DumpName());

    Assert(pLogicalFilterNode);
    FOR_EACH_LIST_ITEM(&pLogicalFilterNode->lstPinNode, pPinNode) {

	Assert(pPinNode);
	Assert(pPinNode->pPinInfo);
	ASSERT(
	  (pLogicalFilterNode->GetFlags() & LFN_FLAGS_REFLECT_DATARANGE) == 0);
	gcGraphRecursion = 0;
	ulFlagsCurrent = 0;

	// Determine whether it is an input stream or output stream
	if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN) {
	    ulFlagsCurrent |= LFN_FLAGS_CONNECT_RENDER;
	}
	if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {
	    ulFlagsCurrent |= LFN_FLAGS_CONNECT_CAPTURE;
	}

	// Determine the kind of graph to build
	if(this->ulFlags & FLAGS_MIXER_TOPOLOGY) {
	    ulFlagsCurrent |= LFN_FLAGS_CONNECT_MIXER_TOPOLOGY;
	}
	else {
	    ulFlagsCurrent |= LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY;
	}

	Status = CreateGraph(
	  pPinNode,
	  NULL,
	  pLogicalFilterNode,
	  NULL,
	  ulFlagsCurrent,
	  pPinNode->GetOverhead() + pLogicalFilterNode->GetOverhead());

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CGraphNode::CreateGraph(
    PPIN_NODE pPinNode,
    PCONNECT_NODE pConnectNodePrevious,
    PLOGICAL_FILTER_NODE pLogicalFilterNodePrevious,
    PGRAPH_PIN_INFO pGraphPinInfoPrevious,
    ULONG ulFlagsCurrent,
    ULONG ulOverhead
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PGRAPH_PIN_INFO pGraphPinInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    Assert(pPinNode);
    Assert(pPinNode->pPinInfo);
    Assert(pLogicalFilterNodePrevious);
    if(pConnectNodePrevious != NULL) {
	Assert(pConnectNodePrevious);
    }
    ASSERT(pPinNode->pLogicalFilterNode == pLogicalFilterNodePrevious);

    //
    // Don't allow unlimited nesting, allow graphs number of LFNs deep
    //
    if(gcGraphRecursion++ > (gcLogicalFilterNodes + 8)) {
	DPF(10, "CreateGraph: recursion too deep");
	Status = STATUS_STACK_OVERFLOW;
	goto exit;
    }

    if(pGraphPinInfoPrevious == NULL) {
	Status = CGraphPinInfo::Create(
	  &pGraphPinInfo,
	  pPinNode->pPinInfo,
	  0,
	  this);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	pGraphPinInfoPrevious = pGraphPinInfo;
    }

    FOR_EACH_LIST_ITEM(gplstLogicalFilterNode, pLogicalFilterNode) {
	ULONG ulFlagsDiff;

	ASSERT(pLogicalFilterNode->GetOverhead() != OVERHEAD_NONE);
	//ASSERT(pLogicalFilterNode->GetOrder() != ORDER_NONE);

	DPF5(100, "CreateGraph: %s F %x LFN %08x F %x T %x",
	  pLogicalFilterNode->pFilterNode->DumpName(),
	  ulFlagsCurrent,
	  pLogicalFilterNode,
	  pLogicalFilterNode->GetFlags(),
	  pLogicalFilterNode->GetType());

	//
	// Rule: don't allow the same filter be connected twice
	//
	if(pLogicalFilterNode == pLogicalFilterNodePrevious) {
	    DPF1(100, "CreateGraph: same LFN: %08x", pLogicalFilterNode);
	    continue;
	}
	ulFlagsDiff = ~(ulFlagsCurrent ^ pLogicalFilterNode->GetFlags());

	if((ulFlagsDiff &
	  (LFN_FLAGS_CONNECT_CAPTURE | 
	   LFN_FLAGS_CONNECT_RENDER)) == 0) {
	    DPF1(100, "CreateGraph: i/o no match: LFN %08x", 
	      pLogicalFilterNode);
	    continue;
	}
	if((ulFlagsDiff & LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY) == 0) {
	    DPF1(100, "CreateGraph: norm no match: LFN %08x",
	      pLogicalFilterNode);
	    continue;
	}
	if((ulFlagsDiff & LFN_FLAGS_CONNECT_MIXER_TOPOLOGY) == 0) {
	    DPF1(100, "CreateGraph: mixer no match: LFN %08x",
	      pLogicalFilterNode);
	    continue;
	}
	if(pLogicalFilterNode->GetOrder() < 
	   pLogicalFilterNodePrevious->GetOrder()) {
	    DPF2(100, "CreateGraph: ulOrder(%x) < Previous Order (%x)",
	      pLogicalFilterNode->GetOrder(),
	      pLogicalFilterNodePrevious->GetOrder());
	    continue;
	}
    #ifndef CONNECT_DIRECT_TO_HW
	if(pLogicalFilterNode->GetType() & FILTER_TYPE_PRE_MIXER) {
	    if(pLogicalFilterNodePrevious->GetOrder() < ORDER_MIXER) {
		if(gcMixers > 0) {
		    // 100
		    DPF2(50, 
		      "CreateGraph: previous order (%x) < ORDER_MIXER LFN %08x",
		      pLogicalFilterNodePrevious->GetOrder(),
		      pLogicalFilterNode);
		    continue;
		}
	    }
	}
    #endif
	if(!pLogicalFilterNode->pFilterNode->IsDeviceInterfaceMatch(
	  pDeviceNode)) {
	    DPF1(100, "CreateGraph: no dev interface match DN %08x",
	      pDeviceNode);
	    continue;
	}
	//
	// Enumerate each "To" pin on the LFN to see if it matchs the input pin
	//
	Status = CreateGraphToPin(
	  pPinNode,
	  pConnectNodePrevious,
	  pLogicalFilterNode,
	  pGraphPinInfoPrevious,
	  ulFlagsCurrent,
	  ulOverhead);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM	// end each LFN

    Status = CStartNode::Create(
      pPinNode,
      pConnectNodePrevious,
      pGraphPinInfoPrevious,
      ulFlagsCurrent,
      ulOverhead,
      this);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    //
    // Remove the GPI if it doesn't have any other references from SIs or CIs
    //
    if (pGraphPinInfo) {
        pGraphPinInfo->Destroy();
    }
    gcGraphRecursion--;
    return(Status);
}

NTSTATUS
CGraphNode::CreateGraphToPin(
    PPIN_NODE pPinNode,
    PCONNECT_NODE pConnectNodePrevious,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PGRAPH_PIN_INFO pGraphPinInfo,
    ULONG ulFlagsCurrent,
    ULONG ulOverhead
)
{
    PCONNECT_NODE pConnectNode = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_NODE pPinNodeTo;

    Assert(this);
    Assert(pPinNode);
    Assert(pPinNode->pPinInfo);
    Assert(pLogicalFilterNode);

    FOR_EACH_LIST_ITEM(&pLogicalFilterNode->lstPinNode, pPinNodeTo) {
	Assert(pPinNodeTo);
	Assert(pPinNodeTo->pPinInfo);
	ASSERT(pPinNodeTo->pLogicalFilterNode == pLogicalFilterNode);
	//
	// The dataflow, communication, interface, medium and data 
	// formats must be compatible.
	//
	if(!pPinNode->ComparePins(pPinNodeTo)) {
	    DPF2(100, "CreateGraph: pins mis: PN %08x PNTo %08x",
	      pPinNode,
	      pPinNodeTo);
	    continue;
	}
	Status = CConnectNode::Create(
	  &pConnectNode,
	  pLogicalFilterNode,
	  pConnectNodePrevious,
	  pGraphPinInfo,
	  pPinNode,
	  pPinNodeTo,
	  ulFlagsCurrent,
	  this);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	//
	// Enumerate each "from" pin on the LFN and recurse building the graph
	//
	Status = CreateGraphFromPin(
	  pPinNode,
	  pPinNodeTo,
	  pConnectNode,
	  pLogicalFilterNode,
	  pConnectNode->IsPinInstanceReserved() ? NULL : pGraphPinInfo,
	  ulFlagsCurrent,
	  ulOverhead);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	//
	// Remove CN if it doesn't have any other refs from other CNs or SNs.
	//
	pConnectNode->Destroy();
	pConnectNode = NULL;

    } END_EACH_LIST_ITEM	// end each LFN node "to" pin node
exit:
    if(!NT_SUCCESS(Status)) {
	//
	// Clean up the last CN created if error
	//
	Trap();
	pConnectNode->Destroy();
    }
    return(Status);
}

NTSTATUS
CGraphNode::CreateGraphFromPin(
    PPIN_NODE pPinNode,
    PPIN_NODE pPinNodeTo,
    PCONNECT_NODE pConnectNode,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PGRAPH_PIN_INFO pGraphPinInfo,
    ULONG ulFlagsCurrent,
    ULONG ulOverhead
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_NODE pPinNodeFrom;

    Assert(this);
    Assert(pPinNode);
    Assert(pPinNodeTo);
    Assert(pPinNodeTo->pPinInfo);
    Assert(pLogicalFilterNode);

    FOR_EACH_LIST_ITEM(&pLogicalFilterNode->lstPinNode, pPinNodeFrom) {
	ASSERT(pPinNodeFrom->pLogicalFilterNode == pLogicalFilterNode);

	if(pPinNodeTo->pPinInfo == pPinNodeFrom->pPinInfo) {
	    continue;
	}
	if(pLogicalFilterNode->GetFlags() & LFN_FLAGS_REFLECT_DATARANGE) {

	    pPinNodeFrom = new PIN_NODE(this, pPinNodeFrom);
	    if(pPinNodeFrom == NULL) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
		Trap();
		goto exit;
	    }
	    pPinNodeFrom->pDataRange = pPinNode->pDataRange;
	}
	//
	// Recurse building the graph
	//
	Status = CreateGraph(
	  pPinNodeFrom,
	  pConnectNode,
	  pLogicalFilterNode,
	  pGraphPinInfo,
	  ulFlagsCurrent,
	  ulOverhead +
	    pPinNodeFrom->GetOverhead() +
	    pLogicalFilterNode->GetOverhead());

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM	// end each LFN "from" pin node
exit:
    return(Status);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CGraphNode::Dump(
)
{
    Assert(this);
    dprintf("GN: %08x DN %08x ulFlags: %08x ",
      this,
      pDeviceNode,
      ulFlags);
    if(ulFlags & FLAGS_MIXER_TOPOLOGY) {
	dprintf("MIXER_TOPOLOGY ");
    }
    if(ulFlags & FLAGS_COMBINE_PINS) {
	dprintf("COMBINE_PINS ");
    }
    if(ulFlags & GN_FLAGS_PLAYBACK) {
	dprintf("PLAYBACK ");
    }
    if(ulFlags & GN_FLAGS_RECORD) {
	dprintf("RECORD ");
    }
    if(ulFlags & GN_FLAGS_MIDI) {
	dprintf("MIDI ");
    }
    dprintf("\n");

    // .sgv
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("    lstLFN:");
	lstLogicalFilterNode.DumpAddress();
	dprintf("\n    lstGNI:");
	lstGraphNodeInstance.DumpAddress();
	dprintf("\n    lstPN: ");
	lstPinNode.DumpAddress();
	dprintf("\n    lstTC: ");
	lstTopologyConnection.DumpAddress();
	dprintf("\n    lstGPI:");
	lstGraphPinInfo.DumpAddress();
	dprintf("\n    lstSI: ");
	lstStartInfo.DumpAddress();
	dprintf("\n    lstCI: ");
	lstConnectInfo.DumpAddress();
	dprintf("\n    lstLfnNoBypass:");
	lstLogicalFilterNodeNoBypass.DumpAddress();
	dprintf("\n");
    }
    // .sg[x]
    else {
	if((ulDebugFlags & ~DEBUG_FLAGS_DETAILS) == DEBUG_FLAGS_GRAPH) {
	    if(ulDebugFlags & DEBUG_FLAGS_DETAILS) {
		lstStartNode.Dump();
	    }
	    else {
		lstStartInfo.Dump();
	    }
	}
    }
    // .sgl[p][t]
    if(ulDebugFlags & DEBUG_FLAGS_LOGICAL_FILTER) {
	lstLogicalFilterNode.Dump();
    }
    // .sgt
    if(ulDebugFlags & DEBUG_FLAGS_TOPOLOGY) {
	lstTopologyConnection.Dump();
    }
    // .sgi[p][t]
    if(ulDebugFlags & DEBUG_FLAGS_INSTANCE) {
	lstGraphNodeInstance.Dump();
    }
    dprintf("\n");
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\gni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   gni.cpp
//
//  Description:
//
//	Graph Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

GUID aguidSysAudioCategories[] = {
    STATICGUIDOF(KSCATEGORY_SYSAUDIO)
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CGraphNodeInstance::CGraphNodeInstance(
    PGRAPH_NODE pGraphNode,
    PFILTER_INSTANCE pFilterInstance
)
{
    Assert(pGraphNode);
    Assert(pFilterInstance);
    this->pFilterInstance = pFilterInstance;
    this->ulFlags = pFilterInstance->ulFlags;
    this->pGraphNode = pGraphNode;
    AddList(&pGraphNode->lstGraphNodeInstance);
}

CGraphNodeInstance::CGraphNodeInstance(
    PGRAPH_NODE pGraphNode
)
{
    Assert(pGraphNode);
    this->ulFlags = pGraphNode->ulFlags;
    this->pGraphNode = pGraphNode;
    AddList(&pGraphNode->lstGraphNodeInstance);
}

CGraphNodeInstance::~CGraphNodeInstance(
)
{
    Assert(this);
    RemoveList();
    if(pFilterInstance != NULL) {
	Assert(pFilterInstance);
	pFilterInstance->pGraphNodeInstance = NULL;
	pFilterInstance->ParentInstance.Invalidate();
    }
    DestroyPinDescriptors();
    DestroySysAudioTopology();
    delete[] paulNodeNumber;
}

NTSTATUS 
CGraphNodeInstance::Create(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i, n;

    if(this == NULL) {
	Status = STATUS_NO_SUCH_DEVICE;
	goto exit;
    }
    Assert(this);
    Assert(pGraphNode);

    Status = CreatePinDescriptors();
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    Status = CreateSysAudioTopology();
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    if(gcVirtualSources != 0) {
	paulNodeNumber = new ULONG[gcVirtualSources];
	if(paulNodeNumber == NULL) {
	    Trap();
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}
	for(i = 0; i < gcVirtualSources; i++) {
	    for(n = 0; n < cTopologyNodes; n++) {
		if(pGraphNode->pDeviceNode->papVirtualSourceData[i]->
		   pTopologyNode == papTopologyNode[n]) {
		    paulNodeNumber[i] = n;
		    break;
		}
	    }
	}
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CGraphNodeInstance::GetTopologyNodeFileObject(
    OUT PFILE_OBJECT *ppFileObject,
    IN ULONG NodeId
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(this == NULL) {
	Status = STATUS_NO_SUCH_DEVICE;
	goto exit;
    }
    Assert(this);

    if(NodeId >= cTopologyNodes) {
	DPF2(100, 
	  "GetTopologyNodeFileObject: NodeId(%d) >= cTopologyNodes(%d)",
	  NodeId,
	  cTopologyNodes);
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }

    // If virtual topology node, return error
    if(papTopologyNode[NodeId]->ulRealNodeNumber == MAXULONG) {
	DPF(100, "GetTopologyNodeFileObject: ulRealNodeNumber == MAXULONG");
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }

    if(papFilterNodeInstanceTopologyTable == NULL) {
	Trap();
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }

    if(papFilterNodeInstanceTopologyTable[NodeId] == NULL) {
	Status = CFilterNodeInstance::Create(
	  &papFilterNodeInstanceTopologyTable[NodeId],
	  papTopologyNode[NodeId]->lstLogicalFilterNode.GetListFirstData(),
	  pGraphNode->pDeviceNode,
	  TRUE);				// Reuse an instance

	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}
    }
    Assert(papFilterNodeInstanceTopologyTable[NodeId]);
    *ppFileObject = papFilterNodeInstanceTopologyTable[NodeId]->pFileObject;

    DPF1(110,
      "GetToplogyNodeFileObject: using filter for node: %d\n",
      NodeId);
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CGraphNodeInstance::CreateSysAudioTopology(
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(this);
    ASSERT(Topology.TopologyNodes == NULL);
    ASSERT(Topology.TopologyConnections == NULL);
    ASSERT(papFilterNodeInstanceTopologyTable == NULL);

    Topology.CategoriesCount = SIZEOF_ARRAY(aguidSysAudioCategories);
    Topology.Categories = aguidSysAudioCategories;

    CreateTopologyTables();

    if(cTopologyNodes != 0) {

	Topology.TopologyNodes = new GUID[cTopologyNodes];
	if(Topology.TopologyNodes == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}

	papFilterNodeInstanceTopologyTable = 
	  new PFILTER_NODE_INSTANCE[cTopologyNodes];

	if(papFilterNodeInstanceTopologyTable == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}

	papTopologyNode = new PTOPOLOGY_NODE[cTopologyNodes];
	if(papTopologyNode == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}
    }
    if(cTopologyConnections != 0) {

	Topology.TopologyConnections = 
	  new KSTOPOLOGY_CONNECTION[cTopologyConnections];

	if(Topology.TopologyConnections == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}
    }
    CreateTopologyTables();
exit:
    if(!NT_SUCCESS(Status)) {
        DestroySysAudioTopology();
    }
    return(Status);
}

VOID
CGraphNodeInstance::DestroySysAudioTopology(
)
{
    ULONG n;

    delete[] (PVOID)Topology.TopologyNodes;
    Topology.TopologyNodes = NULL;
    delete[] (PVOID)Topology.TopologyConnections;
    Topology.TopologyConnections = NULL;
    delete[] papTopologyNode;
    papTopologyNode = NULL;

    if(papFilterNodeInstanceTopologyTable != NULL) {
	for(n = 0; n < cTopologyNodes; n++) {
	    papFilterNodeInstanceTopologyTable[n]->Destroy();
	}
	delete[] papFilterNodeInstanceTopologyTable;
	papFilterNodeInstanceTopologyTable = NULL;
    }
}

typedef ENUMFUNC (CTopologyNode::*CLIST_TN_PFN2)(PVOID, PVOID);

VOID
CGraphNodeInstance::CreateTopologyTables(
)
{
    Assert(this);
    Assert(pGraphNode);

    cTopologyNodes = 0;
    cTopologyConnections = 0;

    // Initialize the "ulSysaudioNodeNumber" field in the TopologyNodes first
    ProcessLogicalFilterNodeTopologyNode(
      &pGraphNode->pDeviceNode->lstLogicalFilterNode,
      CTopologyNode::InitializeTopologyNode);

    ProcessLogicalFilterNodeTopologyNode(
      &pGraphNode->lstLogicalFilterNode,
      CTopologyNode::InitializeTopologyNode);

    // All the nodes need to be processed first so the ulSysaudioNodeNumber in
    // the TopologyNode is correct before any connections are processed.
    ProcessLogicalFilterNodeTopologyNode(
      &pGraphNode->pDeviceNode->lstLogicalFilterNode,
      CTopologyNode::AddTopologyNode);

    ProcessLogicalFilterNodeTopologyNode(
      &pGraphNode->lstLogicalFilterNode,
      CTopologyNode::AddTopologyNode);

    // Now process all the topology connection lists
    ProcessLogicalFilterNodeTopologyConnection(
      &pGraphNode->pDeviceNode->lstLogicalFilterNode,
      CTopologyConnection::ProcessTopologyConnection);

    ProcessLogicalFilterNodeTopologyConnection(
      &pGraphNode->lstLogicalFilterNode,
      CTopologyConnection::ProcessTopologyConnection);

    pGraphNode->lstTopologyConnection.EnumerateList(
      CTopologyConnection::ProcessTopologyConnection,
      (PVOID)this);
}

VOID
CGraphNodeInstance::ProcessLogicalFilterNodeTopologyNode(
    PLIST_MULTI_LOGICAL_FILTER_NODE plstLogicalFilterNode,
    NTSTATUS (CTopologyNode::*Function)(
	PVOID pGraphNodeInstance
    )
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;

    FOR_EACH_LIST_ITEM(
      plstLogicalFilterNode,
      pLogicalFilterNode) {
	Assert(pLogicalFilterNode);
	pLogicalFilterNode->lstTopologyNode.EnumerateList(Function, this);
    } END_EACH_LIST_ITEM
}

VOID
CGraphNodeInstance::ProcessLogicalFilterNodeTopologyConnection(
    PLIST_MULTI_LOGICAL_FILTER_NODE plstLogicalFilterNode,
    NTSTATUS (CTopologyConnection::*Function)(
	PVOID pGraphNodeInstance
    )
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;

    FOR_EACH_LIST_ITEM(
      plstLogicalFilterNode,
      pLogicalFilterNode) {
	Assert(pLogicalFilterNode);
	pLogicalFilterNode->lstTopologyConnection.EnumerateList(Function, this);
    } END_EACH_LIST_ITEM
}

ENUMFUNC
CTopologyConnection::ProcessTopologyConnection(
    PVOID pReference
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance = (PGRAPH_NODE_INSTANCE)pReference;
    PSTART_NODE pStartNode;
    ULONG ulFromPin;
    ULONG ulFromNode;
    ULONG ulToPin;
    ULONG ulToNode;
    ULONG PinId;

    Assert(this);
    Assert(pGraphNodeInstance);

    ulFromPin = MAXULONG;
    ulToPin = MAXULONG;
#ifdef DEBUG
    ulFromNode = MAXULONG;
    ulToNode = MAXULONG;
#endif

    // If the connection doesn't connect LFNs on this GraphNode, skip connection
    if(!IsTopologyConnectionOnGraphNode(pGraphNodeInstance->pGraphNode)) {
	DPF3(100, "ProcessTC: %s TC %08x GN %08x - skip TC",
	  pGraphNodeInstance->pGraphNode->pDeviceNode->DumpName(),
	  this,
	  pGraphNodeInstance->pGraphNode);
	goto exit;
    }

    if(pTopologyPinFrom != NULL) {
	ulFromNode = pTopologyPinFrom->pTopologyNode->ulSysaudioNodeNumber;
	ulFromPin = pTopologyPinFrom->ulPinNumber;

	ASSERT(pPinInfoFrom == NULL);
	ASSERT(ulFromNode != MAXULONG);
	ASSERT(ulFromPin != MAXULONG);
    }

    if(pTopologyPinTo != NULL) {
	ulToNode = pTopologyPinTo->pTopologyNode->ulSysaudioNodeNumber;
	ulToPin = pTopologyPinTo->ulPinNumber;

	ASSERT(pPinInfoTo == NULL);
	ASSERT(ulToNode != MAXULONG);
	ASSERT(ulToPin != MAXULONG);
    }

    if(pGraphNodeInstance->aplstStartNode != NULL) {

	for(PinId = 0; PinId < pGraphNodeInstance->cPins; PinId++) {

	    FOR_EACH_LIST_ITEM(
	      pGraphNodeInstance->aplstStartNode[PinId],
	      pStartNode) {

		Assert(pStartNode);
		if(pPinInfoFrom != NULL) {
		    ASSERT(pTopologyPinFrom == NULL);

		    if(pStartNode->pPinNode->pPinInfo == pPinInfoFrom) {
			// This code assumes that a filter's pininfo will show
			// up in one SAD pin. If a filter exposes more than one
			// major format on the same pin, that pininfo show on 
			// two different SAD pins.
			ASSERT(ulFromNode == KSFILTER_NODE);
			ASSERT(ulFromPin == MAXULONG || ulFromPin == PinId);

			pStartNode->GetStartInfo()->
			  ulTopologyConnectionTableIndex =
			    pGraphNodeInstance->cTopologyConnections;

			ulFromNode = KSFILTER_NODE;
			ulFromPin = PinId;
		    }
		}

		if(pPinInfoTo != NULL) {
		    ASSERT(pTopologyPinTo == NULL);

		    if(pStartNode->pPinNode->pPinInfo == pPinInfoTo) {
			// See above.
			ASSERT(ulToNode == KSFILTER_NODE);
			ASSERT(ulToPin == MAXULONG || ulToPin == PinId);

			pStartNode->GetStartInfo()->
			  ulTopologyConnectionTableIndex =
			    pGraphNodeInstance->cTopologyConnections;

			ulToNode = KSFILTER_NODE;
			ulToPin = PinId;
		    }
		}

	    } END_EACH_LIST_ITEM
	}
    }
    if(ulFromPin != MAXULONG && ulToPin != MAXULONG) {
	pGraphNodeInstance->AddTopologyConnection(
	  ulFromNode,
	  ulFromPin,
	  ulToNode,
	  ulToPin);
    }
exit:
    return(STATUS_CONTINUE);
}

ENUMFUNC
CTopologyNode::InitializeTopologyNode(
    PVOID pReference
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance = (PGRAPH_NODE_INSTANCE)pReference;

    Assert(this);
    Assert(pGraphNodeInstance);
    ulSysaudioNodeNumber = MAXULONG;
    return(STATUS_CONTINUE);
}

ENUMFUNC
CTopologyNode::AddTopologyNode(
    PVOID pReference
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance = (PGRAPH_NODE_INSTANCE)pReference;

    Assert(this);
    Assert(pGraphNodeInstance);

    // Skip duplicate TopologyNodes
    if(ulSysaudioNodeNumber != MAXULONG) {
	DPF1(100, "AddTopologyNode: dup TN: %08x", this);
	goto exit;
    }
    ulSysaudioNodeNumber = pGraphNodeInstance->cTopologyNodes;

    if(pGraphNodeInstance->papTopologyNode != NULL) {
	pGraphNodeInstance->papTopologyNode[
	  pGraphNodeInstance->cTopologyNodes] = this;
    }
    if(pGraphNodeInstance->Topology.TopologyNodes != NULL) {
	((GUID *)(pGraphNodeInstance->Topology.TopologyNodes))[
	  pGraphNodeInstance->cTopologyNodes] = *pguidType;
    }
    DPF3(115, "AddTopologyNode: %02x GNI: %08x TN: %08x",
      pGraphNodeInstance->cTopologyNodes,
      pGraphNodeInstance,
      this);

    ++pGraphNodeInstance->cTopologyNodes;
exit:
    return(STATUS_CONTINUE);
}

VOID
CGraphNodeInstance::AddTopologyConnection(
    ULONG ulFromNode,
    ULONG ulFromPin,
    ULONG ulToNode,
    ULONG ulToPin
)
{
    Assert(this);
    if(Topology.TopologyConnections != NULL) {
	PKSTOPOLOGY_CONNECTION pKSTopologyConnection =
	  (PKSTOPOLOGY_CONNECTION)&Topology.TopologyConnections[
	     cTopologyConnections];

	pKSTopologyConnection->FromNode = ulFromNode;
	pKSTopologyConnection->FromNodePin = ulFromPin;
	pKSTopologyConnection->ToNode = ulToNode;
	pKSTopologyConnection->ToNodePin = ulToPin;
    }
    ++cTopologyConnections;

    DPF4(115, "AddTopologyConnection: FN:%02x FNP:%02x TN:%02x TNP:%02x",
      ulFromNode,
      ulFromPin,
      ulToNode,
      ulToPin);
}

//---------------------------------------------------------------------------

NTSTATUS
CGraphNodeInstance::CreatePinDescriptors(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ListDataAssertLess<LIST_DATA_START_NODE> lstStartNodeLists;
    ListDataAssertLess<KSDATARANGE> lstDataRange;
    PLIST_DATA_START_NODE plstStartNodeOrdered;
    PSTART_NODE pStartNodeSorted;
    PSTART_NODE pStartNode;
    BOOL fSorted;
    ULONG PinId;

    Assert(this);
    Assert(pGraphNode);
    ASSERT(paPinDescriptors == NULL);
    ASSERT(aplstStartNode == NULL);
    ASSERT(palstTopologyNodeSelect == NULL);
    ASSERT(palstTopologyNodeNotSelect == NULL);
    ASSERT(pacPinInstances == NULL);
    ASSERT(pulPinFlags == NULL);
    ASSERT(cPins == 0);

#ifdef REGISTRY_PREFERRED_DEVICE
    // Clear the graph node preferred device type bits
    pGraphNode->ulFlags &= ~GN_FLAGS_PREFERRED_MASK;
#endif
    // Sort StartNodes by Communication, DataFlow and Major Format GUID
    FOR_EACH_LIST_ITEM(&pGraphNode->lstStartNode, pStartNode) {
	Assert(pStartNode->pPinNode);
	Assert(pStartNode->pPinNode->pPinInfo);

	// Skip any start nodes with no data range
	if(pStartNode->pPinNode->pDataRange == NULL) {
	    Trap();
	    continue;
	}
	// Skip any start nodes with no instances left on the pin
        if(ulFlags & FLAGS_COMBINE_PINS) {
	    if(pStartNode->pPinNode->pPinInfo->Communication == 
	       KSPIN_COMMUNICATION_SINK ||
	       pStartNode->pPinNode->pPinInfo->Communication == 
	       KSPIN_COMMUNICATION_SOURCE ||
	       pStartNode->pPinNode->pPinInfo->Communication == 
	       KSPIN_COMMUNICATION_BOTH) {

		if(!pStartNode->IsPossibleInstances()) {
		    continue;
		}
	    }
	}
	fSorted = FALSE;
	FOR_EACH_LIST_ITEM(&lstStartNodeLists, plstStartNodeOrdered) {

	    FOR_EACH_LIST_ITEM(plstStartNodeOrdered, pStartNodeSorted) {
		Assert(pStartNodeSorted);
		Assert(pStartNodeSorted->pPinNode);
		Assert(pStartNodeSorted->pPinNode->pPinInfo);

		// If the same actual pin, combine the pin nodes
		if((pStartNode->pPinNode->pPinInfo ==
		    pStartNodeSorted->pPinNode->pPinInfo) ||

		   // Combine only if client wants it that way
		   (ulFlags & FLAGS_COMBINE_PINS) &&

		   // Combine only AUDIO major formats
		   IsEqualGUID(
		     &pStartNode->pPinNode->pDataRange->MajorFormat,
		     &KSDATAFORMAT_TYPE_AUDIO) &&

		   // Only combine SINK, SOURCE, BOTH StartNodes; keep
		   // NONE and BRIDGE as separate SAD pins
		   ((pStartNode->pPinNode->pPinInfo->Communication ==
		     KSPIN_COMMUNICATION_SINK) ||
		   (pStartNode->pPinNode->pPinInfo->Communication ==
		     KSPIN_COMMUNICATION_SOURCE) ||
		   (pStartNode->pPinNode->pPinInfo->Communication ==
		     KSPIN_COMMUNICATION_BOTH)) &&

		   // Combine if same data flow
		   (pStartNode->pPinNode->pPinInfo->DataFlow ==
		    pStartNodeSorted->pPinNode->pPinInfo->DataFlow) &&

		   // Combine if same communication type OR
		   ((pStartNode->pPinNode->pPinInfo->Communication ==
		     pStartNodeSorted->pPinNode->pPinInfo->Communication) ||

		    // Combine a SINK and a BOTH
		    ((pStartNode->pPinNode->pPinInfo->Communication ==
		       KSPIN_COMMUNICATION_SINK) &&
		     (pStartNodeSorted->pPinNode->pPinInfo->Communication ==
		       KSPIN_COMMUNICATION_BOTH)) ||

		    // Combine a BOTH and a SINK
		    ((pStartNode->pPinNode->pPinInfo->Communication ==
		       KSPIN_COMMUNICATION_BOTH) &&
		     (pStartNodeSorted->pPinNode->pPinInfo->Communication ==
		       KSPIN_COMMUNICATION_SINK)) ||

		    // Combine a SOURCE and a BOTH
		    ((pStartNode->pPinNode->pPinInfo->Communication ==
		       KSPIN_COMMUNICATION_SOURCE) &&
		     (pStartNodeSorted->pPinNode->pPinInfo->Communication ==
		       KSPIN_COMMUNICATION_BOTH)) ||

		    // Combine a BOTH and a SOURCE
		    ((pStartNode->pPinNode->pPinInfo->Communication ==
		       KSPIN_COMMUNICATION_BOTH) &&
		     (pStartNodeSorted->pPinNode->pPinInfo->Communication ==
		       KSPIN_COMMUNICATION_SOURCE))) &&

		   // Combine if major format is the same
		   IsEqualGUID(
		     &pStartNode->pPinNode->pDataRange->MajorFormat,
		     &pStartNodeSorted->pPinNode->pDataRange->MajorFormat)) {

		    Status = plstStartNodeOrdered->AddListOrdered(
		      pStartNode,
		      FIELD_OFFSET(START_NODE, ulOverhead));

		    if(!NT_SUCCESS(Status)) {
			goto exit;
		    }
		    fSorted = TRUE;
		    break;
	        }

	    } END_EACH_LIST_ITEM

	    if(fSorted) {
	       break;
	    }

	} END_EACH_LIST_ITEM

	if(!fSorted) {
	    plstStartNodeOrdered = new LIST_DATA_START_NODE;
	    if(plstStartNodeOrdered == NULL) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto exit;
	    }
	    Status = plstStartNodeOrdered->AddListOrdered(
	      pStartNode,
	      FIELD_OFFSET(START_NODE, ulOverhead));

	    if(!NT_SUCCESS(Status)) {
		goto exit;
	    }
	    Status = lstStartNodeLists.AddList(plstStartNodeOrdered);
	    if(!NT_SUCCESS(Status)) {
		goto exit;
	    }
	}

    } END_EACH_LIST_ITEM

    // Allocate the pin descriptors, pin instance and start node arrays
    cPins = lstStartNodeLists.CountList();

    // if there are no pins, exit
    if(cPins == 0) {
        goto exit;
    }

    paPinDescriptors = new KSPIN_DESCRIPTOR[cPins];
    if(paPinDescriptors == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }

    aplstStartNode = new PLIST_DATA_START_NODE[cPins];
    if(aplstStartNode == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    DPF1(100, "CreatePinDescriptors: cPins %d", cPins);

    // For each pin, create a list of interfaces, mediums and dataranges
    PinId = 0;
    FOR_EACH_LIST_ITEM(&lstStartNodeLists, plstStartNodeOrdered) {
	PKSDATARANGE pDataRange, *apDataRanges;
	BOOL fBoth = TRUE;

	ASSERT(PinId < cPins);
	ASSERT(!plstStartNodeOrdered->IsLstEmpty());
	aplstStartNode[PinId] = plstStartNodeOrdered;

	FOR_EACH_LIST_ITEM(plstStartNodeOrdered, pStartNode) {
	    Assert(pStartNode);
	    Assert(pStartNode->pPinNode);
	    Assert(pStartNode->pPinNode->pPinInfo);

	    paPinDescriptors[PinId].DataFlow = 
	      pStartNode->pPinNode->pPinInfo->DataFlow;

	    if(pStartNode->pPinNode->pPinInfo->Communication !=
	      KSPIN_COMMUNICATION_BOTH) {
		fBoth = FALSE;
		paPinDescriptors[PinId].Communication =
		  pStartNode->pPinNode->pPinInfo->Communication;
	    }

	    if(paPinDescriptors[PinId].Category == NULL ||
	      IsEqualGUID(
	       paPinDescriptors[PinId].Category, 
	       &GUID_NULL)) {

		paPinDescriptors[PinId].Category =
		  pStartNode->pPinNode->pPinInfo->pguidCategory;

		paPinDescriptors[PinId].Name =
		  pStartNode->pPinNode->pPinInfo->pguidName;
	    }

	} END_EACH_LIST_ITEM

	if(fBoth) {
	    paPinDescriptors[PinId].Communication = KSPIN_COMMUNICATION_SINK;
	}

	// Make a list of all the DataRanges this pin will support
	Status = plstStartNodeOrdered->CreateUniqueList(
	  &lstDataRange,
	  (UNIQUE_LIST_PFN)GetStartNodeDataRange,
	  (UNIQUE_LIST_PFN2)CompareDataRangeExact);

	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}

	// Put the number of data ranges into the pin descriptor
	paPinDescriptors[PinId].DataRangesCount = lstDataRange.CountList();
	if(paPinDescriptors[PinId].DataRangesCount != 0) {

	    // Allocate the array of ptrs to DataRanges; put it into the desc
	    paPinDescriptors[PinId].DataRanges = new PKSDATARANGE[
	      paPinDescriptors[PinId].DataRangesCount];

	    if(paPinDescriptors[PinId].DataRanges == NULL) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto exit;
	    }

	    // Put each data range pointer into the array
	    apDataRanges = (PKSDATARANGE *)paPinDescriptors[PinId].DataRanges;

	    FOR_EACH_LIST_ITEM(&lstDataRange, pDataRange) {

	    #ifdef REGISTRY_PREFERRED_DEVICE
		if(IsEqualGUID(
		  &pDataRange->MajorFormat,
		  &KSDATAFORMAT_TYPE_AUDIO) &&
		   IsEqualGUID(
		  &pDataRange->SubFormat,
		  &KSDATAFORMAT_SUBTYPE_PCM)) {

		    if(paPinDescriptors[PinId].DataFlow == KSPIN_DATAFLOW_IN) {
			pGraphNode->ulFlags |= GN_FLAGS_PLAYBACK;
		    }
		    else {
			pGraphNode->ulFlags |= GN_FLAGS_RECORD;
		    }
		}

		if(IsEqualGUID(
		  &pDataRange->MajorFormat,
		  &KSDATAFORMAT_TYPE_MUSIC) &&
		   IsEqualGUID(
		  &pDataRange->SubFormat,
		  &KSDATAFORMAT_SUBTYPE_MIDI)) {

		    if(paPinDescriptors[PinId].DataFlow == KSPIN_DATAFLOW_IN) {
			pGraphNode->ulFlags |= GN_FLAGS_MIDI;
		    }
		}
	    #endif

		*apDataRanges = pDataRange;
		apDataRanges++;
	    } END_EACH_LIST_ITEM
	}

	// Destroy the data range list
	lstDataRange.DestroyList();

	// Create the interface array for the pin descriptor
	Status = CreateIdentifierArray(
	  plstStartNodeOrdered,
	  &paPinDescriptors[PinId].InterfacesCount,
	  (PKSIDENTIFIER *)&paPinDescriptors[PinId].Interfaces,
	  GetStartNodeInterface);

	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}

	// Create the medium array for the pin descriptor
	Status = CreateIdentifierArray(
	  plstStartNodeOrdered,
	  &paPinDescriptors[PinId].MediumsCount,
	  (PKSIDENTIFIER *)&paPinDescriptors[PinId].Mediums,
	  GetStartNodeMedium);

	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}
	DPF6(100, "PinId %d DataFlow %d cD %d cI %d cM %d cSN %d",
	  PinId,
          paPinDescriptors[PinId].DataFlow,
	  paPinDescriptors[PinId].DataRangesCount,
	  paPinDescriptors[PinId].InterfacesCount,
	  paPinDescriptors[PinId].MediumsCount,
	  aplstStartNode[PinId]->CountList());

	// Next pin number
	PinId++;

    } END_EACH_LIST_ITEM

    if((ulFlags & FLAGS_MIXER_TOPOLOGY) == 0) {
	palstTopologyNodeSelect = new LIST_DATA_TOPOLOGY_NODE[cPins];
	if(palstTopologyNodeSelect == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}

	palstTopologyNodeNotSelect = new LIST_DATA_TOPOLOGY_NODE[cPins];
	if(palstTopologyNodeNotSelect == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}
	PLOGICAL_FILTER_NODE pLogicalFilterNode;
	PTOPOLOGY_NODE pTopologyNode;

	FOR_EACH_LIST_ITEM(
	  &pGraphNode->lstLogicalFilterNode,
	  pLogicalFilterNode) {

	   if(pLogicalFilterNode->GetFlags() & LFN_FLAGS_NOT_SELECT) {

	       FOR_EACH_LIST_ITEM(
		 &pLogicalFilterNode->lstTopologyNode,
		 pTopologyNode) {

		    for(PinId = 0; PinId < cPins; PinId++) {
			Status = palstTopologyNodeNotSelect[PinId].AddList(
			  pTopologyNode);

			if(!NT_SUCCESS(Status)) {
			    goto exit;
			}
		    }

	       } END_EACH_LIST_ITEM
	   }

	} END_EACH_LIST_ITEM
    }

    pacPinInstances = new KSPIN_CINSTANCES[cPins];
    if(pacPinInstances == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    pulPinFlags = new ULONG[cPins];
    if (NULL == pulPinFlags) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    for(PinId = 0; PinId < cPins; PinId++) {
        LIST_DATA_GRAPH_PIN_INFO lstGraphPinInfo;
        PSTART_NODE pStartNode2;
        PPIN_INFO pPinInfo;
        BOOL fHWRender = TRUE;

        FOR_EACH_LIST_ITEM(aplstStartNode[PinId], pStartNode2) {
            PGRAPH_PIN_INFO pGraphPinInfo;

            pGraphPinInfo = pStartNode2->GetGraphPinInfo();
            Assert(pGraphPinInfo);

            // 
            // Set pin type. 
            // If all startnodes are connected directly to renderer.
            //
            pPinInfo = pGraphPinInfo->GetPinInfo();

            ASSERT(pPinInfo);
            if ((!(pPinInfo->pFilterNode->GetType() & FILTER_TYPE_RENDERER)) ||
                (KSPIN_DATAFLOW_IN != pPinInfo->DataFlow) ||
                (KSPIN_COMMUNICATION_SINK != pPinInfo->Communication)) {
                fHWRender = FALSE;
            }

            if(lstGraphPinInfo.CheckDupList(pGraphPinInfo)) {
                continue;
            }

            Status = lstGraphPinInfo.AddList(pGraphPinInfo);
            if(!NT_SUCCESS(Status)) {
                goto exit;
            }

            //
            // Set cinstances.
            //
            if(pGraphPinInfo->IsPinReserved()) {
                pacPinInstances[PinId].CurrentCount = 1;
            }
            if(pGraphPinInfo->GetPinInstances()->PossibleCount == MAXULONG) {
                pacPinInstances[PinId].PossibleCount = MAXULONG;
                break;
            }
            pacPinInstances[PinId].PossibleCount +=
              pGraphPinInfo->GetPinInstances()->PossibleCount;

            if (fHWRender) {
                fHWRender = (1 < pGraphPinInfo->GetPinInstances()->PossibleCount);
            }

        } END_EACH_LIST_ITEM

        pulPinFlags[PinId] = fHWRender;

        lstGraphPinInfo.DestroyList();
    }
    
exit:
    if(!NT_SUCCESS(Status)) {
        DestroyPinDescriptors();
    }
    return(Status);
}

VOID
CGraphNodeInstance::DestroyPinDescriptors(
)
{
    ULONG PinId;

    Assert(this);
    for(PinId = 0; PinId < cPins; PinId++) {
	if(paPinDescriptors != NULL) {
	    delete (PVOID)paPinDescriptors[PinId].DataRanges;
	    if(paPinDescriptors[PinId].InterfacesCount > 1) {
		delete (PVOID)paPinDescriptors[PinId].Interfaces;
	    }
	    if(paPinDescriptors[PinId].MediumsCount > 1) {
		delete (PVOID)paPinDescriptors[PinId].Mediums;
	    }
	}
	if(aplstStartNode != NULL) {
	    delete aplstStartNode[PinId];
	}
    }
    delete[cPins] aplstStartNode;
    aplstStartNode = NULL;
    delete[cPins] paPinDescriptors;
    paPinDescriptors = NULL;
    delete[cPins] palstTopologyNodeSelect;
    palstTopologyNodeSelect = NULL;
    delete[cPins] palstTopologyNodeNotSelect;
    palstTopologyNodeNotSelect = NULL;
    delete[cPins] pacPinInstances;
    pacPinInstances = NULL;
    delete[cPins] pulPinFlags;
    pulPinFlags = NULL;
}

NTSTATUS
CreateIdentifierArray(
    PLIST_DATA_START_NODE plstStartNode,
    PULONG pulCount,
    PKSIDENTIFIER *ppIdentifier,
    PKSIDENTIFIER (*GetFunction)(
	PSTART_NODE pStartNode
    )
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    KSIDENTIFIER *pIdentifier1, *pIdentifier2;
    ListDataAssertLess<KSIDENTIFIER> lstIdentifier;

    Status = plstStartNode->CreateUniqueList(
      &lstIdentifier,
      (UNIQUE_LIST_PFN)GetFunction,
      (UNIQUE_LIST_PFN2)CompareIdentifier);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    if((*pulCount = lstIdentifier.CountList()) == 0) {
	*ppIdentifier = NULL;
    }
    else {
	if(*pulCount == 1) {
	    *ppIdentifier = lstIdentifier.GetListFirstData();
	}
	else {
	    *ppIdentifier = new KSIDENTIFIER[*pulCount];
	    if(*ppIdentifier == NULL) {
		Status = STATUS_INSUFFICIENT_RESOURCES;
		goto exit;
	    }
	    pIdentifier1 = *ppIdentifier;
 	    AssertAligned(pIdentifier1);
	    FOR_EACH_LIST_ITEM(&lstIdentifier, pIdentifier2) {
 		AssertAligned(pIdentifier1);
 		AssertAligned(pIdentifier2);
		RtlCopyMemory(pIdentifier1, pIdentifier2, sizeof(KSIDENTIFIER));
		pIdentifier1++;
	    } END_EACH_LIST_ITEM
	}
    }
exit:
    return(Status);
}

PKSDATARANGE
GetStartNodeDataRange(
    PSTART_NODE pStartNode
)
{
    return(pStartNode->pPinNode->pDataRange);
}

PKSIDENTIFIER
GetStartNodeInterface(
    PSTART_NODE pStartNode
)
{
    return(pStartNode->pPinNode->pInterface);
}

PKSIDENTIFIER
GetStartNodeMedium(
    PSTART_NODE pStartNode
)
{
    return(pStartNode->pPinNode->pMedium);
}

//---------------------------------------------------------------------------

ENUMFUNC
FindTopologyNode(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN PTOPOLOGY_NODE pTopologyNode
)
{
    Assert(pTopologyConnection);

    if(IS_CONNECTION_TYPE(pTopologyConnection, GRAPH)) {
	return(STATUS_DEAD_END);
    }
    if(fToDirection) {
	if(pTopologyConnection->pTopologyPinTo != NULL) {
	    if(pTopologyNode == 
	       pTopologyConnection->pTopologyPinTo->pTopologyNode) {
		return(STATUS_SUCCESS);
	    }
	}
    }
    else {
	if(pTopologyConnection->pTopologyPinFrom != NULL) {
	    if(pTopologyNode == 
	       pTopologyConnection->pTopologyPinFrom->pTopologyNode) {
		return(STATUS_SUCCESS);
	    }
	}
    }
    return(STATUS_CONTINUE);
}

BOOL
CGraphNodeInstance::IsGraphValid(
    PSTART_NODE pStartNode,
    ULONG PinId
)
{
    PFILTER_INSTANCE pFilterInstance;
    PTOPOLOGY_NODE pTopologyNode;
    BOOL fCheck;

    Assert(this);
    Assert(pGraphNode);
    Assert(pStartNode);
    Assert(pStartNode->pPinNode);
    Assert(pStartNode->pPinNode->pPinInfo);
    Assert(pGraphNode->pDeviceNode);
    ASSERT(PinId < cPins);

    if(pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN) {

        FOR_EACH_LIST_ITEM(
          &pGraphNode->pDeviceNode->lstFilterInstance,
          pFilterInstance) {

            if(pFilterInstance->pGraphNodeInstance == NULL) {
                continue;
            }
            Assert(pFilterInstance->pGraphNodeInstance);

            FOR_EACH_LIST_ITEM(
              &pFilterInstance->pGraphNodeInstance->lstTopologyNodeGlobalSelect,
              pTopologyNode) {

                if(EnumerateGraphTopology(
                  pStartNode->GetStartInfo(),
                  (TOP_PFN)FindTopologyNode,
                  pTopologyNode) == STATUS_CONTINUE) {

                    DPF2(80,
                      "IsGraphValid: TN %08x SN %08x not found Global",
                      pTopologyNode,
                      pStartNode);

                    return(FALSE);
                }

            } END_EACH_LIST_ITEM

        } END_EACH_LIST_ITEM
    }

    if (palstTopologyNodeSelect) {
        FOR_EACH_LIST_ITEM(&palstTopologyNodeSelect[PinId], pTopologyNode) {

            if(EnumerateGraphTopology(
              pStartNode->GetStartInfo(),
              (TOP_PFN)FindTopologyNode,
              pTopologyNode) == STATUS_CONTINUE) {

                DPF2(80, "IsGraphValid: TN %08x SN %08x not found Select",
                  pTopologyNode,
                  pStartNode);

                return(FALSE);
            }

        } END_EACH_LIST_ITEM
    }
    
    // If a NotSelectNode is in the GlobalSelectList of another FilterInstance,
    // don't consider this as an invalid Graph.
    // This behaves like an implicit SelectGraph.
    //
    if (palstTopologyNodeNotSelect) {
        FOR_EACH_LIST_ITEM(&palstTopologyNodeNotSelect[PinId], pTopologyNode) {

            fCheck = TRUE;
            if(pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN) {

                FOR_EACH_LIST_ITEM(
                  &pGraphNode->pDeviceNode->lstFilterInstance,
                  pFilterInstance) {

                    if(pFilterInstance->pGraphNodeInstance == NULL) {
                        continue;
                    }
                    Assert(pFilterInstance->pGraphNodeInstance);

                    // Is this NotSelectNode in the GlobalSelectList of 
                    // another FilterInstance.
                    // Remove it from NotSelectList and add it to 
                    // GlobalSelectList for this filter as well.
                    //
                    if(pFilterInstance->pGraphNodeInstance->
                      lstTopologyNodeGlobalSelect.EnumerateList(
                        CTopologyNode::MatchTopologyNode,
                        pTopologyNode) == STATUS_SUCCESS) {

                        if (NT_SUCCESS(lstTopologyNodeGlobalSelect.
                          AddListDup(pTopologyNode))) {

                            palstTopologyNodeNotSelect[PinId].
                                RemoveList(pTopologyNode);

                            DPF2(50, "Removing TN %X %s", 
                                pTopologyNode, 
                                pTopologyNode->pFilterNode->DumpName());
                        }
                        else {
                            DPF2(4, "Failed to add TN %X to GNI %X GlobalSelectList", 
                                pTopologyNode,
                                this);
                            Trap();
                        }

                        fCheck = FALSE;
                        break;
                    }

                } END_EACH_LIST_ITEM
            }

            if(fCheck) {
                if(EnumerateGraphTopology(
                  pStartNode->GetStartInfo(),
                  (TOP_PFN)FindTopologyNode,
                  pTopologyNode) == STATUS_SUCCESS) {

                    DPF2(80, "IsGraphValid: TN %08x SN %08x found NotSelect",
                      pTopologyNode,
                      pStartNode);

                    return(FALSE);
                }
            }

        } END_EACH_LIST_ITEM
    }
    
    return(TRUE);
}

NTSTATUS 
CGraphNodeInstance::GetPinInstances(
    PIRP pIrp,
    PKSP_PIN pPin,
    PKSPIN_CINSTANCES pcInstances    
)
{
    NTSTATUS Status;
    ULONG ulPinId = pPin->PinId;

    // 
    // For HW Accelerated pins, send the request to HW filter.
    //
    if (pulPinFlags[ulPinId]) {
        PSTART_NODE pStartNode;
        PPIN_INFO pPinInfo;
        ULONG BytesReturned;
        PIO_STACK_LOCATION pIrpStack;        
        PFILTER_NODE_INSTANCE pFilterNodeInstance = NULL;

        pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

        pStartNode = aplstStartNode[ulPinId]->GetListFirstData();

        pPinInfo = pStartNode->pPinNode->pPinInfo;

        Status = CFilterNodeInstance::Create(
          &pFilterNodeInstance,
          pStartNode->pPinNode->pLogicalFilterNode,
          pGraphNode->pDeviceNode,
          TRUE);        

        if(NT_SUCCESS(Status)) {
            pPin->PinId = pPinInfo->PinId;
            pPin->Property.Id = KSPROPERTY_PIN_CINSTANCES;

            AssertFileObject(pFilterNodeInstance->pFileObject);
            Status = KsSynchronousIoControlDevice(
              pFilterNodeInstance->pFileObject,
              KernelMode,
              IOCTL_KS_PROPERTY,
              pPin,
              pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
              pcInstances,
              pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
              &BytesReturned);

            if(NT_SUCCESS(Status)) {
                pIrp->IoStatus.Information = BytesReturned;
            }

            if (pFilterNodeInstance) {
                pFilterNodeInstance->Destroy();
            }        
        }
        else {
            DPF2(10, "GetPinInstances FAILS %08x %s",
              Status,
              pPinInfo->pFilterNode->DumpName());
        }
    }
    //
    // For other pins use the cached instances
    //
    else {
        Status = STATUS_SUCCESS;
        *pcInstances = pacPinInstances[ulPinId];
    }

    return Status;
} // GetPinInstances


BOOL
CGraphNodeInstance::IsPinInstances(
    ULONG ulPinId)
{
    //
    // For HW Accelerated pins, always allow further operations.
    //
    if (pulPinFlags[ulPinId]) {
        return TRUE;
    }
    //
    // For other pins check cached instances.
    //
    else
    {
        if(pacPinInstances[ulPinId].CurrentCount >=
           pacPinInstances[ulPinId].PossibleCount) {
           return FALSE;
        }
    }

    return TRUE;
} // IsPinInstances

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC 
CGraphNodeInstance::Dump()
{
    // .siv
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("GNI: %08x GN %08x FI %08x cPins %u cTN %u cTC %u paulNN ",
	  this,
	  pGraphNode,
	  pFilterInstance,
	  cPins,
	  cTopologyNodes,
	  cTopologyConnections);
	for(ULONG i = 0; i < gcVirtualSources; i++) {
	    dprintf("%02x ", paulNodeNumber[i]);
	}
	dprintf("\n     paPinDesc: %08x papTN  %08x ulFlags %08x ",
	  paPinDescriptors,
	  papTopologyNode,
	  ulFlags);
	if(ulFlags & FLAGS_COMBINE_PINS) {
	    dprintf("COMBINE_PINS ");
	}
	if(ulFlags & FLAGS_MIXER_TOPOLOGY) {
	    dprintf("MIXER_TOPOLOGY ");
	}
	dprintf("\n     aplstSN:   %08x papFNI %08x palstTN %08x !%08x\n",
	  aplstStartNode,
	  papFilterNodeInstanceTopologyTable,
	  palstTopologyNodeSelect,
	  palstTopologyNodeNotSelect);

	dprintf("     pacPI: %08x ", pacPinInstances);
	for(ULONG p = 0; p < cPins; p++) {
	    dprintf("[C%dP%d]", 
	      pacPinInstances[p].CurrentCount,
	      pacPinInstances[p].PossibleCount);
	}
	dprintf("\n     lstTNGlobalSelect:");
        lstTopologyNodeGlobalSelect.DumpAddress();

	dprintf("\n     lstSNI:");
	// .sivx
	if(ulDebugFlags & DEBUG_FLAGS_DETAILS) {
	    dprintf("\n");
	    lstStartNodeInstance.Dump();
	}
	else {
	    lstStartNodeInstance.DumpAddress();
	    dprintf("\n");
	}
    }
    // .sit
    if(ulDebugFlags & DEBUG_FLAGS_TOPOLOGY) {
	dprintf("GNI: %08x\n", this);
	for(ULONG i = 0; i < cTopologyNodes; i++) {
	    if(papFilterNodeInstanceTopologyTable[i] != NULL) {
	    dprintf("     %02x FNI %08x %s\n",
		  i,
		  papFilterNodeInstanceTopologyTable[i],
		  papTopologyNode[i]->pFilterNode->DumpName());
	    }
	}
    }
    // .sip
    if(ulDebugFlags & DEBUG_FLAGS_PIN) {
	dprintf("GNI: %08x\n", this);
	DumpPinDescriptors();
    }
    return(STATUS_CONTINUE);
}

extern PSZ apszDataFlow[];
extern PSZ apszCommunication[];

VOID
CGraphNodeInstance::DumpPinDescriptors(
)
{
    ULONG p, i, m, d;

    Assert(this);
    for(p = 0; p < cPins; p++) {
	dprintf(
	  "PinId: %d DataFlow %08x %s Comm %08x %s cPossible %d cCurrent %d\n",
	  p,
	  paPinDescriptors[p].DataFlow,
	  apszDataFlow[paPinDescriptors[p].DataFlow],
	  paPinDescriptors[p].Communication,
	  apszCommunication[paPinDescriptors[p].Communication],
	  pacPinInstances[p].CurrentCount,
	  pacPinInstances[p].PossibleCount);
        dprintf("    Category: %s\n", 
	  DbgGuid2Sz((GUID*)paPinDescriptors[p].Category));
	dprintf("    Name:     %s\n", 
	  DbgGuid2Sz((GUID*)paPinDescriptors[p].Name));
	dprintf("    palstTNSelect:");
	palstTopologyNodeSelect[p].DumpAddress();
	dprintf("\n");
	dprintf("    palstTNNot:");
	palstTopologyNodeNotSelect[p].DumpAddress();
	dprintf("\n");
	// .sipv
	if(ulDebugFlags & DEBUG_FLAGS_VERBOSE) {
	    for(i = 0;
		i < paPinDescriptors[p].InterfacesCount;
		i++) {

		dprintf("    Interface %u: %s\n", 
		  i,
		  DbgIdentifier2Sz((PKSIDENTIFIER)
		    &paPinDescriptors[p].Interfaces[i]));
	    }
	    for(m = 0; m < paPinDescriptors[p].MediumsCount; m++) {

		dprintf("    Medium %u:    %s\n",
		  m,
		  DbgIdentifier2Sz((PKSIDENTIFIER)
		    &paPinDescriptors[p].Mediums[m]));
	    }
	    for(d = 0; d < paPinDescriptors[p].DataRangesCount; d++) {

		dprintf("    DataRange %u:\n", d);
		dprintf("      MajorFormat: %s\n",
		  DbgGuid2Sz(&paPinDescriptors[p].DataRanges[d]->MajorFormat));

		dprintf("      SubFormat:   %s\n",
		  DbgGuid2Sz(&paPinDescriptors[p].DataRanges[d]->SubFormat));

		dprintf("      Specifier:   %s\n",
		  DbgGuid2Sz(&paPinDescriptors[p].DataRanges[d]->Specifier));

		dprintf("  ");
		DumpDataRangeAudio((PKSDATARANGE_AUDIO)
		  paPinDescriptors[p].DataRanges[d]);
	    }
	}
	// .sipx
	if(ulDebugFlags & DEBUG_FLAGS_DETAILS) {
	    if(ulDebugFlags & DEBUG_FLAGS_VERBOSE) {
		dprintf("    aplstSN:\n");
	    }
	    aplstStartNode[p]->Dump();
	}
	dprintf("\n");
    }
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\gpi.h ===
//---------------------------------------------------------------------------
//
//  Module:   		gni.h
//
//  Description:	Graph Pin Info Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define GPI_FLAGS_RESERVE_PIN_INSTANCE		0x00000001
#define GPI_FLAGS_PIN_INSTANCE_RESERVED		0x00000002

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CGraphPinInfo : public CListDoubleItem
{
    friend class CConnectInfo;
private:
    CGraphPinInfo(
	PPIN_INFO pPinInfo,
	ULONG ulFlags,
	PGRAPH_NODE pGraphNode
    );

    ~CGraphPinInfo(
    );

public:
    static NTSTATUS
    Create(
	PGRAPH_PIN_INFO *ppGraphPinInfo,
	PPIN_INFO pPinInfo,
	ULONG ulFlags,
	PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    VOID 
    AddRef(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ++cReference;
	}
    };

    PPIN_INFO
    GetPinInfo(
    )
    {
	Assert(this);
	return(pPinInfo);
    };

    PKSPIN_CINSTANCES
    GetPinInstances(
    )
    {
	Assert(this);
	return(&cPinInstances);
    };

    VOID
    AddPinInstance(
    )
    {
	Assert(this);
	cPinInstances.CurrentCount++;
    };

    VOID
    RemovePinInstance(
    )
    {
	Assert(this);
	cPinInstances.CurrentCount--;
    };

    BOOL
    IsPinInstances(
    )
    {
	Assert(this);
	return(cPinInstances.CurrentCount < cPinInstances.PossibleCount);
    };

    BOOL
    IsPinReserved(
    )
    {
	return(ulFlags & GPI_FLAGS_PIN_INSTANCE_RESERVED);
    };

    BOOL
    IsPossibleInstances(
    )
    {
	if(IsPinReserved()) {
	    return(cPinInstances.PossibleCount > 1);
	}
	return(cPinInstances.PossibleCount > 0);
    };

    VOID
    ReservePinInstance(
    )
    {
	Assert(this);
	ulFlags |= GPI_FLAGS_PIN_INSTANCE_RESERVED;
	cPinInstances.CurrentCount = 1;
    };

#ifdef DEBUG
    ENUMFUNC
    Dump(
    );
#endif

private:
    LONG cReference;
    ULONG ulFlags;
    PPIN_INFO pPinInfo;
    KSPIN_CINSTANCES cPinInstances;
public:
    DefineSignature(0x20495047);				// GPI

} GRAPH_PIN_INFO, *PGRAPH_PIN_INFO;

//---------------------------------------------------------------------------

typedef ListDouble<GRAPH_PIN_INFO> LIST_GRAPH_PIN_INFO;

//---------------------------------------------------------------------------

typedef ListData<GRAPH_PIN_INFO> LIST_DATA_GRAPH_PIN_INFO;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\gpi.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   gpi.cpp
//
//  Description:
//
//	Graph Pin Info Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CGraphPinInfo::Create(
    PGRAPH_PIN_INFO *ppGraphPinInfo,
    PPIN_INFO pPinInfo,
    ULONG ulFlags,
    PGRAPH_NODE pGraphNode
)
{
    PGRAPH_PIN_INFO pGraphPinInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pPinInfo);
    Assert(pGraphNode);

    FOR_EACH_LIST_ITEM(&pGraphNode->lstGraphPinInfo, pGraphPinInfo) {

	if(pGraphPinInfo->pPinInfo == pPinInfo &&
         ((pGraphPinInfo->ulFlags ^ ulFlags) & 
	    GPI_FLAGS_RESERVE_PIN_INSTANCE) == 0) {

	    pGraphPinInfo->AddRef();
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    pGraphPinInfo = new GRAPH_PIN_INFO(pPinInfo, ulFlags, pGraphNode);
    if(pGraphPinInfo == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    DPF2(80, "CGraphPinInfo::Create %08x GN %08x", pGraphPinInfo, pGraphNode);
exit:
    *ppGraphPinInfo = pGraphPinInfo;
    return(Status);
}

CGraphPinInfo::CGraphPinInfo(
    PPIN_INFO pPinInfo,
    ULONG ulFlags,
    PGRAPH_NODE pGraphNode
)
{
    Assert(pPinInfo);
    Assert(pGraphNode);

    this->pPinInfo = pPinInfo;
    this->ulFlags = ulFlags;
    if(ulFlags & GPI_FLAGS_RESERVE_PIN_INSTANCE) {
	this->cPinInstances.PossibleCount = 1;
	this->cPinInstances.CurrentCount = 0;
    }
    else {
	this->cPinInstances = pPinInfo->cPinInstances;
    }
    AddRef();
    AddList(&pGraphNode->lstGraphPinInfo);
    DPF2(80, "CGraphPinInfo: %08x GN %08x", this, pGraphNode);
}

CGraphPinInfo::~CGraphPinInfo(
)
{
    DPF1(80, "~CGraphPinInfo: %08x", this);
    Assert(this);
    RemoveList();
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC 
CGraphPinInfo::Dump(
)
{
    dprintf("GPI: %08x cRef %08x PI %08x F %08x P%-2d C%-1d #%d %s\n",
      this,
      cReference,
      GetPinInfo(),
      ulFlags,
      GetPinInstances()->PossibleCount,
      GetPinInstances()->CurrentCount,
      GetPinInfo()->PinId,
      GetPinInfo()->pFilterNode->DumpName());
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\lfn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   lfn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

ULONG gcMixers = 0;
ULONG gcSplitters = 0;
ULONG gcLogicalFilterNodes = 0;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CLogicalFilterNode::Create(
    OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode,
    IN PFILTER_NODE pFilterNode
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status;

    pLogicalFilterNode = new LOGICAL_FILTER_NODE(pFilterNode);
    if(pLogicalFilterNode == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    Status = pLogicalFilterNode->AddList(&pFilterNode->lstLogicalFilterNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    if(pLogicalFilterNode->GetType() & FILTER_TYPE_LOGICAL_FILTER) {
	Status = pLogicalFilterNode->AddListOrdered(
	  gplstLogicalFilterNode,
	  FIELD_OFFSET(LOGICAL_FILTER_NODE, ulOrder));

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
exit:
    *ppLogicalFilterNode = pLogicalFilterNode;
    return(Status);
}

CLogicalFilterNode::CLogicalFilterNode(
    PFILTER_NODE pFilterNode
)
{
    Assert(pFilterNode);
    this->pFilterNode = pFilterNode;

    // The type/order is the same as filter node
    SetType(pFilterNode->GetType());

    // Determine the overhead here, default to software (higher)
    ulOverhead = OVERHEAD_SOFTWARE;
    if(GetType() & FILTER_TYPE_ENDPOINT) {
	ulOverhead = OVERHEAD_HARDWARE;
    }

    // Count the mixers, splitters and lfns
    if(GetType() & FILTER_TYPE_MIXER) {
	++gcMixers;
    }
    if(GetType() & FILTER_TYPE_SPLITTER) {
	++gcSplitters;
    }
    ++gcLogicalFilterNodes;

    DPF3(60, "CLogicalFilterNode: %08x FN: %08x %s",
      this,
      pFilterNode,
      pFilterNode->DumpName());
}

CLogicalFilterNode::~CLogicalFilterNode(
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PDEVICE_NODE pDeviceNode;
    PGRAPH_NODE pGraphNode;
    PPIN_NODE pPinNode;
    BOOL fDestroy;

    Assert(this);
    DPF2(60, "~CLogicalFilterNode: %08x %s", this, pFilterNode->DumpName());
    //
    // Need to NULL the pPinNode's LFN field because it is used in AddPinNodes
    // to indicate that this PN hasn't been assigned a LFN yet.
    //
    FOR_EACH_LIST_ITEM(&lstPinNode, pPinNode) {

	Assert(pPinNode);
	if(pPinNode->pLogicalFilterNode == this) {
	    pPinNode->pLogicalFilterNode = NULL;
	}

    } END_EACH_LIST_ITEM

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

	fDestroy = FALSE;

	FOR_EACH_LIST_ITEM(
	  &pDeviceNode->lstLogicalFilterNode,
	  pLogicalFilterNode) {

	    if(pLogicalFilterNode == this) {
		DPF2(50, "~CLogicalFilterNode: %08x GN %08x Destroy",
		  pLogicalFilterNode,
		  pGraphNode);
		fDestroy = TRUE;
		break;
	    }

	} END_EACH_LIST_ITEM

	if(!fDestroy) {
	    FOR_EACH_LIST_ITEM(&pDeviceNode->lstGraphNode, pGraphNode) {

		FOR_EACH_LIST_ITEM(
		  &pGraphNode->lstLogicalFilterNode,
		  pLogicalFilterNode) {

		    if(pLogicalFilterNode == this) {
			DPF2(50, "~CLogicalFilterNode: %08x GN %08x Destroy",
			  pLogicalFilterNode,
			  pGraphNode);
			fDestroy = TRUE;
			break;
		    }

		} END_EACH_LIST_ITEM

	    } END_EACH_LIST_ITEM
	}

	if(fDestroy) {
	    pDeviceNode->lstGraphNode.DestroyList();
	}

    } END_EACH_LIST_ITEM

    if(GetType() & FILTER_TYPE_MIXER) {
	--gcMixers;
    }
    if(GetType() & FILTER_TYPE_SPLITTER) {
	--gcSplitters;
    }
    --gcLogicalFilterNodes;
}

VOID 
CLogicalFilterNode::SetType(
    ULONG fulType
)
{
    pFilterNode->SetType(fulType);
    SetOrder(pFilterNode->GetOrder());

    ulFlags = 0;
    if(GetType() & FILTER_TYPE_RENDER) {
	ulFlags |= LFN_FLAGS_CONNECT_RENDER;
    }
    if(GetType() & FILTER_TYPE_CAPTURE) {
	ulFlags |= LFN_FLAGS_CONNECT_CAPTURE;
    }
    if(GetType() & FILTER_TYPE_NORMAL_TOPOLOGY) {
	ulFlags |= LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY;
    }
    if(GetType() & FILTER_TYPE_MIXER_TOPOLOGY) {
	ulFlags |= LFN_FLAGS_CONNECT_MIXER_TOPOLOGY;
    }
    if(GetType() & FILTER_TYPE_NO_BYPASS) {
	ulFlags |= LFN_FLAGS_NO_BYPASS;
    }
    if(GetType() & FILTER_TYPE_NOT_SELECT) {
	ulFlags |= LFN_FLAGS_NOT_SELECT;
    }
    if(pFilterNode->GetFlags() & FN_FLAGS_RENDER) {
	ulFlags |= LFN_FLAGS_CONNECT_RENDER;
    }
    if(pFilterNode->GetFlags() & FN_FLAGS_NO_RENDER) {
	ulFlags &= ~LFN_FLAGS_CONNECT_RENDER;
    }
    if(pFilterNode->GetFlags() & FN_FLAGS_CAPTURE) {
	ulFlags |= LFN_FLAGS_CONNECT_CAPTURE;
    }
    if(pFilterNode->GetFlags() & FN_FLAGS_NO_CAPTURE) {
	ulFlags &= ~LFN_FLAGS_CONNECT_CAPTURE;
    }
}

NTSTATUS
SwitchLogicalFilterNodes(
    IN PLOGICAL_FILTER_NODE pLogicalFilterNode,
    IN OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_NODE pTopologyNode;
    PPIN_NODE pPinNode;

    Assert(pLogicalFilterNode);
    Assert(*ppLogicalFilterNode);
    if(pLogicalFilterNode != *ppLogicalFilterNode) {

	FOR_EACH_LIST_ITEM(&(*ppLogicalFilterNode)->lstPinNode, pPinNode) {
	    Assert(pPinNode);
	    pPinNode->pLogicalFilterNode = pLogicalFilterNode;
	} END_EACH_LIST_ITEM

	pLogicalFilterNode->lstPinNode.JoinList(
	  &(*ppLogicalFilterNode)->lstPinNode);

	FOR_EACH_LIST_ITEM(
	  &(*ppLogicalFilterNode)->lstTopologyNode,
	  pTopologyNode) {
	    Assert(pTopologyNode);

	    (*ppLogicalFilterNode)->RemoveList(
	      &pTopologyNode->lstLogicalFilterNode);

	    Status = pLogicalFilterNode->AddList(
	      &pTopologyNode->lstLogicalFilterNode);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	    Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNode);
	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }

	} END_EACH_LIST_ITEM

	pLogicalFilterNode->lstTopologyConnection.JoinList(
	  &(*ppLogicalFilterNode)->lstTopologyConnection);

	delete *ppLogicalFilterNode;
	*ppLogicalFilterNode = pLogicalFilterNode;
    }
exit:
    return(Status);
}

NTSTATUS
AddPinNodes(
    IN PPIN_INFO pPinInfo,
    IN OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_NODE pPinNode;

    Assert(pPinInfo);
    Assert(*ppLogicalFilterNode);

    FOR_EACH_LIST_ITEM(&pPinInfo->lstPinNode, pPinNode) {

	if(pPinNode->pLogicalFilterNode == NULL) {
	    pPinNode->pLogicalFilterNode = *ppLogicalFilterNode;
	}
	else {
	    Status = SwitchLogicalFilterNodes(
	      pPinNode->pLogicalFilterNode,
	      ppLogicalFilterNode);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	}
	Status = (*ppLogicalFilterNode)->lstPinNode.AddList(pPinNode);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	DPF2(100, "AddPinNodes: add PN %08x LFN %08x",
	  pPinNode,
	  *ppLogicalFilterNode);

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CLogicalFilterNode::EnumerateFilterTopology(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode
)
{
    PTOPOLOGY_NODE pTopologyNode;
    NTSTATUS Status;

    Assert(pTopologyConnection);
    DPF5(100, "EFT: PIF %08x PIT %08x TPF %08x TPT %08x f %x",
      pTopologyConnection->pPinInfoFrom,
      pTopologyConnection->pPinInfoTo,
      pTopologyConnection->pTopologyPinFrom,
      pTopologyConnection->pTopologyPinTo,
      fToDirection);

    if(!fToDirection) {
	Status = STATUS_DEAD_END;
	goto exit;
    }
    if(IS_CONNECTION_TYPE(pTopologyConnection, FILTER)) {

	if(pTopologyConnection->pPinInfoFrom != NULL) {
	    Assert(pTopologyConnection->pPinInfoFrom);

	    if(*ppLogicalFilterNode == NULL) {

		Status = CLogicalFilterNode::Create(
		  ppLogicalFilterNode,
		  pTopologyConnection->pPinInfoFrom->pFilterNode);

		if(!NT_SUCCESS(Status)) {
		    Trap();
		    goto exit;
		}
	    }

	    Status = AddPinNodes(
	      pTopologyConnection->pPinInfoFrom,
	      ppLogicalFilterNode);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	    DPF2(100, "EFT: add from PI %08x LFN %08x",
	      pTopologyConnection->pPinInfoFrom,
	      *ppLogicalFilterNode);
	}
	ASSERT(*ppLogicalFilterNode != NULL);
	Assert(*ppLogicalFilterNode);

	if(pTopologyConnection->pPinInfoTo != NULL) {

	    Status = AddPinNodes(
	      pTopologyConnection->pPinInfoTo,
	      ppLogicalFilterNode);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	    DPF2(100, "EFT: add to PI %08x LFN %08x",
	      pTopologyConnection->pPinInfoTo,
	      *ppLogicalFilterNode);
	}

	if(pTopologyConnection->pTopologyPinTo != NULL) {
	    Assert(pTopologyConnection->pTopologyPinTo);
	    pTopologyNode = pTopologyConnection->pTopologyPinTo->pTopologyNode;
	    Assert(pTopologyNode);

	    Status = (*ppLogicalFilterNode)->lstTopologyNode.AddList(
	      pTopologyNode);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }

	    if(IsEqualGUID(
	      &KSNODETYPE_ACOUSTIC_ECHO_CANCEL,
	      pTopologyNode->pguidType)) {

		Assert(*ppLogicalFilterNode);
		(*ppLogicalFilterNode)->SetType(FILTER_TYPE_AEC);
		if(pTopologyConnection->pTopologyPinTo->ulPinNumber ==
		   KSNODEPIN_AEC_RENDER_IN) {
		    (*ppLogicalFilterNode)->SetRenderOnly();
		}
		else {
		    ASSERT(
		     pTopologyConnection->pTopologyPinTo->ulPinNumber ==
		     KSNODEPIN_AEC_CAPTURE_IN);
		    (*ppLogicalFilterNode)->SetCaptureOnly();
		}
		Status = (*ppLogicalFilterNode)->AddList(
		  &pTopologyNode->lstLogicalFilterNode);

		if(!NT_SUCCESS(Status)) {
		    Trap();
		    goto exit;
		}
	    }
	    else {
	        if(pTopologyNode->lstLogicalFilterNode.IsLstEmpty()) {
		    Assert(*ppLogicalFilterNode);

		    Status = (*ppLogicalFilterNode)->AddList(
		      &pTopologyNode->lstLogicalFilterNode);

		    if(!NT_SUCCESS(Status)) {
			Trap();
			goto exit;
		    }
		}
		else {
		    Status = SwitchLogicalFilterNodes(
		      (PLOGICAL_FILTER_NODE)
		        pTopologyNode->lstLogicalFilterNode.GetListFirstData(),
		      ppLogicalFilterNode);

		    if(!NT_SUCCESS(Status)) {
			Trap();
			goto exit;
		    }
		}
	    }
	    DPF2(100, "EFT: add to PI %08x LFN %08x",
	      pTopologyConnection->pPinInfoTo,
	      *ppLogicalFilterNode);
	}
    }
    Status = pTopologyConnection->AddList(
      &(*ppLogicalFilterNode)->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(IS_CONNECTION_TYPE(pTopologyConnection, FILTER)) {
	Status = STATUS_CONTINUE;
    }
    else {
	Status = STATUS_DEAD_END;
    }
exit:
    return(Status);
}

NTSTATUS
CLogicalFilterNode::CreateAll(
    PFILTER_NODE pFilterNode
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_INFO pPinInfo;
    PPIN_NODE pPinNode;

    DPF2(100, "CLFN::CreateAll: FN %08x %s",
      pFilterNode,
      pFilterNode->DumpName());

    //
    // Split up the filter into logical filter nodes. 
    //
    FOR_EACH_LIST_ITEM(&pFilterNode->lstPinInfo, pPinInfo) {

	pLogicalFilterNode = NULL;
	Status = EnumerateTopology(
	  pPinInfo,
	  (TOP_PFN)EnumerateFilterTopology,
	  &pLogicalFilterNode);

	if(Status == STATUS_CONTINUE) {
	    Status = STATUS_SUCCESS;
	}
	else {
	    if(!NT_SUCCESS(Status)) {
		goto exit;
	    }
	}

    } END_EACH_LIST_ITEM

    //
    // Look at the pins of each LFN and determine if it could possibly
    // be a capture or render filter (or both).
    //
    FOR_EACH_LIST_ITEM(
      &pFilterNode->lstLogicalFilterNode,
      pLogicalFilterNode) {
	ULONG ulPossibleFlags;

	ulPossibleFlags = 0;
	pLogicalFilterNode->ulFlags |= LFN_FLAGS_REFLECT_DATARANGE;
	FOR_EACH_LIST_ITEM(&pLogicalFilterNode->lstPinNode, pPinNode) {

	    // Don't care about the major format
	    if(!IsEqualGUID(
	      &pPinNode->pDataRange->SubFormat,
	      &KSDATAFORMAT_SUBTYPE_WILDCARD) ||

	       !IsEqualGUID(
	      &pPinNode->pDataRange->Specifier,
	      &KSDATAFORMAT_SPECIFIER_WILDCARD)) {
		pLogicalFilterNode->ulFlags &= ~LFN_FLAGS_REFLECT_DATARANGE;
	    }

	    switch(pPinNode->pPinInfo->Communication) {
		case KSPIN_COMMUNICATION_BOTH:
		    ulPossibleFlags |=
		      LFN_FLAGS_CONNECT_CAPTURE | LFN_FLAGS_CONNECT_RENDER;
		    break;
		case KSPIN_COMMUNICATION_SOURCE:
		    switch(pPinNode->pPinInfo->DataFlow) {
			case KSPIN_DATAFLOW_IN:
			    ulPossibleFlags |= LFN_FLAGS_CONNECT_CAPTURE;
			    break;
			case KSPIN_DATAFLOW_OUT:
			    ulPossibleFlags |= LFN_FLAGS_CONNECT_RENDER;
			    break;
		    }
		    break;
		case KSPIN_COMMUNICATION_SINK:
		    switch(pPinNode->pPinInfo->DataFlow) {
			case KSPIN_DATAFLOW_IN:
			    ulPossibleFlags |= LFN_FLAGS_CONNECT_RENDER;
			    break;
			case KSPIN_DATAFLOW_OUT:
			    ulPossibleFlags |= LFN_FLAGS_CONNECT_CAPTURE;
			    break;
		    }
		    break;
	    }
	    if(ulPossibleFlags ==
	      (LFN_FLAGS_CONNECT_CAPTURE | LFN_FLAGS_CONNECT_RENDER)) {
		break;
	    }

	} END_EACH_LIST_ITEM

	pLogicalFilterNode->ulFlags =
	  (ulPossibleFlags & pLogicalFilterNode->GetFlags()) |
	  (pLogicalFilterNode->GetFlags() & 
	    ~(LFN_FLAGS_CONNECT_CAPTURE | LFN_FLAGS_CONNECT_RENDER));

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ULONG nLogicalFilter = 0;

ENUMFUNC
CLogicalFilterNode::Dump(
)
{
    Assert(this);
    // .slv
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("LFN: %08x FN %08x fulType %08x ulOrder %08x ulOverhead %08x\n",
	  this,
	  pFilterNode,
	  pFilterNode->GetType(),
	  ulOrder,
	  ulOverhead);
	dprintf("     %s\n", pFilterNode->DumpName());
	dprintf("     fulType: ");
	DumpfulType(GetType());
	dprintf("\n     ulFlags: ");
	if(ulFlags & LFN_FLAGS_CONNECT_CAPTURE) {
	    dprintf("CAPTURE ");
	}
	if(ulFlags & LFN_FLAGS_CONNECT_RENDER) {
	    dprintf("RENDER ");
	}
	if(ulFlags & LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY) {
	    dprintf("NORMAL_TOPOLOGY ");
	}
	if(ulFlags & LFN_FLAGS_CONNECT_MIXER_TOPOLOGY) {
	    dprintf("MIXER_TOPOLOGY ");
	}
	if(ulFlags & LFN_FLAGS_TOP_DOWN) {
	    dprintf("TOP_DOWN ");
	}
	if(ulFlags & LFN_FLAGS_NO_BYPASS) {
	    dprintf("NO_BYPASS ");
	}
	if(ulFlags & LFN_FLAGS_NOT_SELECT) {
	    dprintf("NOT_SELECT ");
	}
	if(ulFlags & LFN_FLAGS_REFLECT_DATARANGE) {
	    dprintf("REFLECT_DATARANGE ");
	}
	dprintf("\n");
	// .slvx
	if(ulDebugFlags & DEBUG_FLAGS_DETAILS) {
	    dprintf("     lstPN:  ");
	    lstPinNode.DumpAddress();
	    dprintf("\n     lstTN:  ");
	    lstTopologyNode.DumpAddress();
	    dprintf("\n     lstTC:  ");
	    lstTopologyConnection.DumpAddress();
	    dprintf("\n     lstFNI: ");
	    lstFilterNodeInstance.DumpAddress();
	    dprintf("\n");
	}
    }
    // .slp
    if(ulDebugFlags & DEBUG_FLAGS_PIN) {
	lstPinNode.Dump();
    }
    // .slt
    if(ulDebugFlags & DEBUG_FLAGS_TOPOLOGY) {
	lstTopologyNode.Dump();
	// .sltx
	if(ulDebugFlags & DEBUG_FLAGS_DETAILS) {
	    lstTopologyConnection.Dump();
	}
    }
    if(ulDebugFlags &
      (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_PIN | DEBUG_FLAGS_TOPOLOGY)) {
	dprintf("\n");
    }
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\lfn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		lfn.h
//
//  Description:	logical filter node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define	LFN_FLAGS_CONNECT_CAPTURE		0x00000001
#define	LFN_FLAGS_CONNECT_RENDER		0x00000002
#define	LFN_FLAGS_CONNECT_NORMAL_TOPOLOGY	0x00000004
#define	LFN_FLAGS_CONNECT_MIXER_TOPOLOGY	0x00000008
#define	LFN_FLAGS_TOP_DOWN			0x00000010
#define	LFN_FLAGS_NO_BYPASS			0x00000020
#define	LFN_FLAGS_NOT_SELECT			0x00000040
#define	LFN_FLAGS_REFLECT_DATARANGE		0x00000080

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CLogicalFilterNode : public CListMultiItem
{
private:
    CLogicalFilterNode(
        PFILTER_NODE pFilterNode
    );

public:
    ~CLogicalFilterNode(
    );

    static NTSTATUS
    Create(
	PLOGICAL_FILTER_NODE *ppLogicalFilterNode,
        PFILTER_NODE pFilterNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    static NTSTATUS
    CreateAll(
	PFILTER_NODE pFilterNode
    );

    static NTSTATUS
    EnumerateFilterTopology(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PLOGICAL_FILTER_NODE *ppLogicalFilterNode
    );

    ULONG 
    GetFlags(
    )
    {
	return(ulFlags);
    };

    BOOL
    IsRenderAndCapture(
    )
    {
	return(
	  (GetFlags() & LFN_FLAGS_CONNECT_CAPTURE) && 
	  (GetFlags() & LFN_FLAGS_CONNECT_RENDER));
    };

    VOID
    SetRenderOnly(
    )
    {
	ulFlags |= LFN_FLAGS_CONNECT_RENDER;
	ulFlags &= ~LFN_FLAGS_CONNECT_CAPTURE;
    };

    VOID
    SetCaptureOnly(
    )
    {
	ulFlags |= LFN_FLAGS_CONNECT_CAPTURE;
	ulFlags &= ~LFN_FLAGS_CONNECT_RENDER;
    };

    ULONG
    GetOverhead(
    )
    {
	return(ulOverhead);
    };

    ULONG
    GetOrder(
    )
    {
	return(ulOrder);
    };

    VOID
    SetOrder(
	ULONG ulOrder
    )
    {
	this->ulOrder = ulOrder;
    };

    ULONG 
    GetType(				// see fn.h
    );

    VOID
    SetType(
	ULONG fulType
    );

#ifdef DEBUG
    ENUMFUNC
    Dump(
    );
#endif

    PFILTER_NODE pFilterNode;
    LIST_DATA_PIN_NODE lstPinNode;
    LIST_DATA_TOPOLOGY_NODE lstTopologyNode;
    LIST_MULTI_TOPOLOGY_CONNECTION lstTopologyConnection;
    LIST_FILTER_NODE_INSTANCE lstFilterNodeInstance;
private:
    ULONG ulOverhead;
    ULONG ulFlags;
    ULONG ulOrder;
public:
    DefineSignature(0x204e464c);				// LFN

} LOGICAL_FILTER_NODE, *PLOGICAL_FILTER_NODE;

//---------------------------------------------------------------------------

typedef ListMultiDestroy<LOGICAL_FILTER_NODE> LIST_DESTROY_LOGICAL_FILTER_NODE;

//---------------------------------------------------------------------------

typedef ListMulti<CLogicalFilterNode> LIST_MULTI_LOGICAL_FILTER_NODE;
typedef LIST_MULTI_LOGICAL_FILTER_NODE *PLIST_MULTI_LOGICAL_FILTER_NODE;

//---------------------------------------------------------------------------
// Inline functions
//---------------------------------------------------------------------------

inline ULONG 
CPinNode::GetType(
)
{
    return(pLogicalFilterNode->GetType());
}

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern ULONG gcMixers;
extern ULONG gcSplitters;
extern ULONG gcLogicalFilterNodes;
extern PLIST_MULTI_LOGICAL_FILTER_NODE gplstLogicalFilterNode;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pch.c ===
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\gni.h ===
//---------------------------------------------------------------------------
//
//  Module:   		gni.h
//
//  Description:	Graph Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define	cTopologyNodes		Topology.TopologyNodesCount
#define	cTopologyConnections	Topology.TopologyConnectionsCount

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CGraphNodeInstance : public CListDoubleItem
{
public:
    CGraphNodeInstance(
        PGRAPH_NODE pGraphNode,
        PFILTER_INSTANCE pFilterInstance
    );
    CGraphNodeInstance(
        PGRAPH_NODE pGraphNode
    );
    ~CGraphNodeInstance();
    NTSTATUS Create();
    ENUMFUNC Destroy()
    {
        Assert(this);
        delete this;
        return(STATUS_CONTINUE);
    };
    NTSTATUS GetTopologyNodeFileObject(
        OUT PFILE_OBJECT *ppFileObject,
        IN ULONG NodeId
    );
    BOOL IsGraphValid(
        PSTART_NODE pStartNode,
        ULONG PinId
    );
    VOID AddTopologyConnection(
        ULONG ulFromNode,
        ULONG ulFromPin,
        ULONG ulToNode,
        ULONG ulToPin
    );
    NTSTATUS GetPinInstances(
        PIRP pIrp,
        PKSP_PIN pPin,
        PKSPIN_CINSTANCES pcInstances    
    );
    BOOL IsPinInstances(
        ULONG ulPinId
    );
private:
    NTSTATUS CreatePinDescriptors();
    VOID DestroyPinDescriptors();
    NTSTATUS CreateSysAudioTopology();
    VOID DestroySysAudioTopology();
    VOID CreateTopologyTables();
    VOID ProcessLogicalFilterNodeTopologyNode(
        PLIST_MULTI_LOGICAL_FILTER_NODE plstLogicalFilterNode,
        NTSTATUS (CTopologyNode::*Function)(
            PVOID pGraphNodeInstance
        )
    );
    VOID ProcessLogicalFilterNodeTopologyConnection(
        PLIST_MULTI_LOGICAL_FILTER_NODE plstLogicalFilterNode,
        NTSTATUS (CTopologyConnection::*Function)(
            PVOID pGraphNodeInstance
        )
    );
public:
#ifdef DEBUG
    ENUMFUNC Dump();
    VOID DumpPinDescriptors();
#endif
    LIST_DATA_TOPOLOGY_NODE lstTopologyNodeGlobalSelect;
    LIST_START_NODE_INSTANCE lstStartNodeInstance;
    PFILTER_INSTANCE pFilterInstance;
    PGRAPH_NODE pGraphNode;
    KSTOPOLOGY Topology;
    ULONG cPins;

    // Index by pin number
    PKSPIN_CINSTANCES pacPinInstances;
    PULONG            pulPinFlags;
    PKSPIN_DESCRIPTOR paPinDescriptors;
    PLIST_DATA_START_NODE *aplstStartNode;
    PLIST_DATA_TOPOLOGY_NODE palstTopologyNodeSelect;
    PLIST_DATA_TOPOLOGY_NODE palstTopologyNodeNotSelect;

    // Index by node number
    PTOPOLOGY_NODE *papTopologyNode;
    PFILTER_NODE_INSTANCE *papFilterNodeInstanceTopologyTable;

    // Index by virtual source index
    ULONG *paulNodeNumber;
private:
    ULONG ulFlags;
public:
    DefineSignature(0x20494E47);		// GNI

} GRAPH_NODE_INSTANCE, *PGRAPH_NODE_INSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<GRAPH_NODE_INSTANCE> LIST_GRAPH_NODE_INSTANCE;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
CreateIdentifierArray(
    PLIST_DATA_START_NODE pldhStartNode,
    PULONG pulCount,
    PKSIDENTIFIER *ppIdentifier,
    PKSIDENTIFIER (*GetFunction)(
        PSTART_NODE pStartNode
    )
);

PKSDATARANGE
GetStartNodeDataRange(
    PSTART_NODE pStartNode
);

PKSIDENTIFIER
GetStartNodeInterface(
    PSTART_NODE pStartNode
);

PKSIDENTIFIER
GetStartNodeMedium(
    PSTART_NODE pStartNode
);

ENUMFUNC
FindTopologyNode(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN PTOPOLOGY_NODE pTopologyNode
);

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\notify.h ===
//---------------------------------------------------------------------------
//
//  Module:   notify.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
RegisterForPlugPlayNotifications(
);

VOID
UnregisterForPlugPlayNotifications(
);

VOID
DecrementAddRemoveCount(
);

NTSTATUS
AudioDeviceInterfaceNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION pNotification,
    IN PVOID Context
);

NTSTATUS
AddFilter(
    PWSTR pwstrDeviceInterface,
    PFILTER_NODE *ppFilterNode
);

NTSTATUS
DeleteFilter(
    PWSTR pwstrDeviceInterface
);

NTSTATUS AddGfx(
    PSYSAUDIO_GFX pSysaudioGfx
);

NTSTATUS RemoveGfx(
    PSYSAUDIO_GFX pSysaudioGfx
);

PFILTER_NODE
FindGfx(
    PFILTER_NODE pnewFilterNode,
    HANDLE hGfx,
    PWSTR pwstrDeviceName,
    ULONG GfxOrder
);

NTSTATUS
SafeCopyStringFromOffset(
    PVOID pBasePointer,
    ULONG Offset,
    PWSTR *String
);

NTSTATUS
GetFilterTypeFromGuid(
    IN LPGUID Guid,
    OUT PULONG pFilterType
);

} // extern "C"

//---------------------------------------------------------------------------
//  End of File: nodes.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\notify.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   notify.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CONST GUID *apguidCategories[] = {
    &KSCATEGORY_AUDIO,
    &KSCATEGORY_AUDIO_GFX,
    &KSCATEGORY_TOPOLOGY,
    &KSCATEGORY_BRIDGE,
    &KSCATEGORY_RENDER,
    &KSCATEGORY_CAPTURE,
    &KSCATEGORY_MIXER,
    &KSCATEGORY_DATATRANSFORM,
    &KSCATEGORY_ACOUSTIC_ECHO_CANCEL,
    &KSCATEGORY_INTERFACETRANSFORM,
    &KSCATEGORY_MEDIUMTRANSFORM,
    &KSCATEGORY_DATACOMPRESSOR,
    &KSCATEGORY_DATADECOMPRESSOR,
    &KSCATEGORY_COMMUNICATIONSTRANSFORM,
    &KSCATEGORY_SPLITTER,
    &KSCATEGORY_AUDIO_SPLITTER,
    &KSCATEGORY_SYNTHESIZER,
#ifdef KSCATEGORY_DRM_DESCRAMBLE
    &KSCATEGORY_DRM_DESCRAMBLE,
#endif
#ifdef KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
    &KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR,
#endif
};

ULONG aulFilterType[] = {
    FILTER_TYPE_AUDIO,
    FILTER_TYPE_GFX,
    FILTER_TYPE_TOPOLOGY,
    FILTER_TYPE_BRIDGE,
    FILTER_TYPE_RENDERER,
    FILTER_TYPE_CAPTURER,
    FILTER_TYPE_MIXER,
    FILTER_TYPE_DATA_TRANSFORM,
    FILTER_TYPE_AEC,
    FILTER_TYPE_INTERFACE_TRANSFORM,
    FILTER_TYPE_MEDIUM_TRANSFORM,
    FILTER_TYPE_DATA_TRANSFORM,
    FILTER_TYPE_DATA_TRANSFORM,
    FILTER_TYPE_COMMUNICATION_TRANSFORM,
    FILTER_TYPE_SPLITTER,
    FILTER_TYPE_SPLITTER,
    FILTER_TYPE_SYNTHESIZER,
#ifdef KSCATEGORY_DRM_DESCRAMBLE
    FILTER_TYPE_DRM_DESCRAMBLE,
#endif
#ifdef KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
    FILTER_TYPE_MIC_ARRAY_PROCESSOR,
#endif
};

PVOID pNotificationHandle = NULL;
PVOID pNotificationHandle2 = NULL;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
RegisterForPlugPlayNotifications(
)
{
    NTSTATUS Status;

    DPF(50, "RegisterForPlugPlayNotifications");
    ASSERT(gpDeviceInstance != NULL);
    ASSERT(gpDeviceInstance->pPhysicalDeviceObject != NULL);

    Status = IoRegisterPlugPlayNotification(
      EventCategoryDeviceInterfaceChange,
      PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
      (LPGUID)&KSCATEGORY_AUDIO,
      gpDeviceInstance->pPhysicalDeviceObject->DriverObject,
      (NTSTATUS (*)(PVOID, PVOID))AudioDeviceInterfaceNotification,
      NULL,
      &pNotificationHandle);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    //
    // For compatibility with Intel AEC which isn't registered in the AUDIO
    // category, sysaudio needs to hook the AEC category.
    //
    Status = IoRegisterPlugPlayNotification(
      EventCategoryDeviceInterfaceChange,
      PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
      (LPGUID)&KSCATEGORY_ACOUSTIC_ECHO_CANCEL,
      gpDeviceInstance->pPhysicalDeviceObject->DriverObject,
      (NTSTATUS (*)(PVOID, PVOID))AudioDeviceInterfaceNotification,
      NULL,
      &pNotificationHandle2);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
exit:
    return(Status);
}

VOID
UnregisterForPlugPlayNotifications(
)
{
    if(pNotificationHandle != NULL) {
        IoUnregisterPlugPlayNotification(pNotificationHandle);
    }
    if(pNotificationHandle2 != NULL) {
        IoUnregisterPlugPlayNotification(pNotificationHandle2);
    }
}

VOID
DecrementAddRemoveCount(
)
{
    if(InterlockedDecrement(&glPendingAddDelete) == 0) {
        DPF(50, "DecrementAddRemoveCount: sending event");
        KsGenerateEventList(
          NULL,
          KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE,
          &gEventQueue,
          KSEVENTS_SPINLOCK,
          &gEventLock);
    }
}

NTSTATUS
AddFilterWorker(
    PWSTR pwstrDeviceInterface,
    PVOID pReference
)
{
    AddFilter(pwstrDeviceInterface, NULL);
    ExFreePool(pwstrDeviceInterface);
    DecrementAddRemoveCount();

    // Dereference sysaudio FDO.
    ObDereferenceObject(gpDeviceInstance->pFunctionalDeviceObject);

    return(STATUS_SUCCESS);
}

NTSTATUS
DeleteFilterWorker(
    PWSTR pwstrDeviceInterface,
    PVOID pReference
)
{
    DeleteFilter(pwstrDeviceInterface);
    ExFreePool(pwstrDeviceInterface);
    DecrementAddRemoveCount();

    // Dereference sysaudio FDO.
    ObDereferenceObject(gpDeviceInstance->pFunctionalDeviceObject);
    
    return(STATUS_SUCCESS);
}

NTSTATUS
AudioDeviceInterfaceNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION pNotification,
    IN PVOID Context
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR pwstrDeviceInterface;

    DPF1(50, "AudioDeviceInterfaceNotification: (%s)",
      DbgUnicode2Sz(pNotification->SymbolicLinkName->Buffer));

    //
    // SECURITY NOTE:
    // We trust the Buffer, because it is passed to us as part of notification
    // from PnP subsystem.
    //
    pwstrDeviceInterface = (PWSTR)
        ExAllocatePoolWithTag(
            PagedPool,
            (wcslen(pNotification->SymbolicLinkName->Buffer) + 1) * sizeof(WCHAR),
            'ASYS');

    if(pwstrDeviceInterface == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    // The notification sends null terminated unicode strings
    wcscpy(pwstrDeviceInterface, pNotification->SymbolicLinkName->Buffer);

    if(IsEqualGUID(&pNotification->Event, &GUID_DEVICE_INTERFACE_ARRIVAL)) {
        //
        // Keep a reference so that PnP does not REMOVE the device
        // when the Worker thread is running.
        // If the thread is scheduled successfully, it will remove the reference
        // when exiting.
        //
        ObReferenceObject(gpDeviceInstance->pFunctionalDeviceObject);

        InterlockedIncrement(&glPendingAddDelete);
        Status = QueueWorkList(
          (UTIL_PFN)AddFilterWorker,
          pwstrDeviceInterface,
          NULL);
        if (!NT_SUCCESS(Status)) {
            ObDereferenceObject(gpDeviceInstance->pFunctionalDeviceObject);
        }
    }
    else if(IsEqualGUID(&pNotification->Event, &GUID_DEVICE_INTERFACE_REMOVAL)) {
        //
        // Keep a reference so that PnP does not REMOVE the device
        // when the Worker thread is running.
        // If the thread is scheduled successfully, it will remove the reference
        // when exiting.
        //
        ObReferenceObject(gpDeviceInstance->pFunctionalDeviceObject);

        InterlockedIncrement(&glPendingAddDelete);
        Status = QueueWorkList(
          (UTIL_PFN)DeleteFilterWorker,
          pwstrDeviceInterface,
          NULL);
        if (!NT_SUCCESS(Status)) {
            ObDereferenceObject(gpDeviceInstance->pFunctionalDeviceObject);
        }
    }
    else {
        //
        // SECURITY NOTE:
        // Sysaudio is registering only for EventCategoryDeviceInterfaceChange.
        // This should send ARRIVAL and REMOVAL.
        // If anything else comes up, we will return SUCCESS.
        // However we are making sure that pwstrDeviceInterface is not leaked.
        //
        ExFreePool(pwstrDeviceInterface);
    }

exit:
    if (!NT_SUCCESS(Status))
    {
        ExFreePool(pwstrDeviceInterface);
    }
    
    return(Status);
}


NTSTATUS
AddFilter(
    PWSTR pwstrDeviceInterface,
    PFILTER_NODE *ppFilterNode	// if !NULL, physical connection addfilter
)
{
    PFILTER_NODE pFilterNodeDuplicate = NULL;
    PFILTER_NODE pFilterNode = NULL;
    UNICODE_STRING ustrFilterName;
    UNICODE_STRING ustrAliasName;
    UNICODE_STRING ustrName;
    NTSTATUS Status;
    ULONG fulType;
    int i;

    DPF1(50, "AddFilter: (%s)", DbgUnicode2Sz(pwstrDeviceInterface));

    fulType = 0;
    RtlInitUnicodeString(&ustrFilterName, pwstrDeviceInterface);
    
    //
    // For each Interface in apguidCategories, get interface alias of 
    // the new device. Check for duplicate interfaces.
    //
    for(i = 0; i < SIZEOF_ARRAY(apguidCategories); i++) {
        Status = IoGetDeviceInterfaceAlias(
          &ustrFilterName,
          apguidCategories[i],
          &ustrAliasName);

        if(NT_SUCCESS(Status)) {
            HANDLE hAlias;

            Status = OpenDevice(ustrAliasName.Buffer, &hAlias); 

            if(NT_SUCCESS(Status)) {
                DPF2(100, "AddFilter: alias (%s) aulFilterType %08x",
                  DbgUnicode2Sz(ustrAliasName.Buffer),
                  aulFilterType[i]);

                fulType |= aulFilterType[i];
                ZwClose(hAlias);

                if(pFilterNodeDuplicate == NULL) {
                    FOR_EACH_LIST_ITEM(gplstFilterNode, pFilterNode) {
                        if(pFilterNode->GetDeviceInterface() == NULL) {
                            continue;
                        }
                        RtlInitUnicodeString(
                          &ustrName,
                          pFilterNode->GetDeviceInterface());

                        if(RtlEqualUnicodeString(
                          &ustrAliasName,
                          &ustrName,
                          TRUE)) {
                            DPF(50, "AddFilter: dup");
                            pFilterNodeDuplicate = pFilterNode;
                            break;
                        }
                    } END_EACH_LIST_ITEM
                }
            }
            else {
                DPF1(10, "AddFilter: OpenDevice FAILED on alias (%s)",
                  DbgUnicode2Sz(ustrAliasName.Buffer));
            }
            RtlFreeUnicodeString(&ustrAliasName);
        }
    }
    
    pFilterNode = pFilterNodeDuplicate;
    Status = STATUS_SUCCESS;

    //
    // Create a new Filter_Node if this is not a duplicate.
    //
    if(pFilterNodeDuplicate == NULL) {
        pFilterNode = new FILTER_NODE(fulType);
        if(pFilterNode == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            Trap();
            goto exit;
        }
        Status = pFilterNode->Create(pwstrDeviceInterface);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        Status = pFilterNode->DuplicateForCapture();
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
        DPF1(50, "AddFilter: new CFilterNode fulType %08x", fulType);
    }

    //
    // If this is called from Interface Notification Callback,
    // create a new DeviceNode for the new FilterNode.
    //
    if(ppFilterNode == NULL) {
        if(pFilterNode->GetType() & FILTER_TYPE_ENDPOINT) {

            //
            // Check if a  DeviceNode has already been created for 
            // this FilterNode. 
            //
            if (NULL != pFilterNodeDuplicate && 
                NULL != pFilterNodeDuplicate->pDeviceNode) {
                DPF1(5, "Duplicate FilterNode %X. Skip DeviceNode Create", 
                    pFilterNode);
            }
            else {
                pFilterNode->pDeviceNode = new DEVICE_NODE;
                if(pFilterNode->pDeviceNode == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    Trap();
                    goto exit;
                }
                
                Status = pFilterNode->pDeviceNode->Create(pFilterNode);
                if(!NT_SUCCESS(Status)) {
                    goto exit;
                }
            }
        }
        else {
            DPF(50, "AddFilter: DestroyAllGraphs");
            DestroyAllGraphs();
        }
    }
    
exit:
    if(!NT_SUCCESS(Status)) {
        DPF2(5, "AddFilter: FAILED (%s) %08x",
          DbgUnicode2Sz(pwstrDeviceInterface),
          Status);

        if(pFilterNode != NULL && pFilterNodeDuplicate == NULL) {
            delete pFilterNode;
            pFilterNode = NULL;
        }
    }
    if(ppFilterNode != NULL) {
        *ppFilterNode = pFilterNode;
    }
    return(Status);
}

NTSTATUS
DeleteFilter(
    PWSTR pwstrDeviceInterface
)
{
    UNICODE_STRING ustrFilterName;
    UNICODE_STRING ustrAliasName;
    UNICODE_STRING ustrName;
    PFILTER_NODE pFilterNode;
    NTSTATUS Status;
    int i;

    DPF1(50, "DeleteFilter: (%s)", DbgUnicode2Sz(pwstrDeviceInterface));

    RtlInitUnicodeString(&ustrFilterName, pwstrDeviceInterface);

    //
    // First delete all filter nodes which have the device interface which is
    // going away
    //
    FOR_EACH_LIST_ITEM_DELETE(gplstFilterNode, pFilterNode) {
        if(pFilterNode->GetDeviceInterface() == NULL) {
            continue;
        }
        RtlInitUnicodeString(
          &ustrName,
          pFilterNode->GetDeviceInterface());

        if(RtlEqualUnicodeString(
          &ustrFilterName,
          &ustrName,
          TRUE)) {
            delete pFilterNode;
            DELETE_LIST_ITEM(gplstFilterNode);
        }
    } END_EACH_LIST_ITEM

    for(i = 0; i < SIZEOF_ARRAY(apguidCategories); i++) {

        //
        // According to PnP group, it is perfectly safe to ask for aliases 
        // during removal. The interface itself will be enabled or disabled. But
        // we will still get the correct aliases.
        //
        Status = IoGetDeviceInterfaceAlias(
          &ustrFilterName,
          apguidCategories[i],
          &ustrAliasName);

        if(NT_SUCCESS(Status)) {
            FOR_EACH_LIST_ITEM_DELETE(gplstFilterNode, pFilterNode) {

                if(pFilterNode->GetDeviceInterface() == NULL) {
                    continue;
                }
                RtlInitUnicodeString(
                  &ustrName,
                  pFilterNode->GetDeviceInterface());

                if(RtlEqualUnicodeString(
                  &ustrAliasName,
                  &ustrName,
                  TRUE)) {
                    delete pFilterNode;
                    DELETE_LIST_ITEM(gplstFilterNode);
                }

            } END_EACH_LIST_ITEM

            RtlFreeUnicodeString(&ustrAliasName);
        }
    }
    
    return(STATUS_SUCCESS);
}

#define GFX_VERBOSE_LEVEL 50

NTSTATUS AddGfx(
    PSYSAUDIO_GFX pSysaudioGfx
)
{
    NTSTATUS Status;
    PFILE_OBJECT pFileObject;
    PFILTER_NODE pFilterNode;
    ULONG Flags;
    PWSTR pwstrDeviceName;
    ULONG Length;
    ULONG GfxOrderBase, GfxOrderCeiling;

    pFileObject = NULL;
    pwstrDeviceName = NULL;
    pFilterNode = NULL;
    GfxOrderBase = GfxOrderCeiling = 0;

    DPF1(GFX_VERBOSE_LEVEL, "AddGfx :: Request to add Gfx %x", pSysaudioGfx);
    DPF1(GFX_VERBOSE_LEVEL, "          hGfx    = %x", pSysaudioGfx->hGfx);
    DPF1(GFX_VERBOSE_LEVEL, "          ulOrder = %x", pSysaudioGfx->ulOrder);
    DPF1(GFX_VERBOSE_LEVEL, "          ulType  = %x", pSysaudioGfx->ulType);
    DPF1(GFX_VERBOSE_LEVEL, "          Flags   = %x", pSysaudioGfx->ulFlags);

    //
    // validate type to be Capture or Render (use public include file!!!)
    //
    if ((pSysaudioGfx->ulType != GFX_DEVICETYPE_RENDER) && (pSysaudioGfx->ulType != GFX_DEVICETYPE_CAPTURE)) { 
        Trap();
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Setup GFX Order's base & ceiling for future usage
    //
    if (pSysaudioGfx->ulType == GFX_DEVICETYPE_RENDER) {
        GfxOrderBase = ORDER_RENDER_GFX_FIRST;
        GfxOrderCeiling = ORDER_RENDER_GFX_LAST;
    }

    if (pSysaudioGfx->ulType == GFX_DEVICETYPE_CAPTURE) {
        GfxOrderBase = ORDER_CAPTURE_GFX_FIRST;
        GfxOrderCeiling = ORDER_CAPTURE_GFX_LAST;
    }

    ASSERT(GfxOrderBase);
    ASSERT(GfxOrderCeiling);

    //
    // validate that order is within range
    //
    if (pSysaudioGfx->ulOrder >= (GfxOrderCeiling - GfxOrderBase)) {
        Status = STATUS_INVALID_PARAMETER;
        Trap();
        goto exit;
    }

    //
    // Allocate a Filter Node for the new GFX
    //
    pFilterNode = new FILTER_NODE(FILTER_TYPE_GFX);
    if(pFilterNode == NULL) {
        Trap();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    
    pFilterNode->SetRenderCaptureFlags(pSysaudioGfx->ulType);
    
    //
    // Copy the Device Name (on which the gfx needs to be attached) into a local copy for our own use
    //
    Status = SafeCopyStringFromOffset(pSysaudioGfx, pSysaudioGfx->ulDeviceNameOffset, &pwstrDeviceName);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    DPF1(GFX_VERBOSE_LEVEL, "          On DI   = %s", DbgUnicode2Sz(pwstrDeviceName));

    //
    // Make sure that there are no other GFXes with the same order on this device
    //
    
    if ((FindGfx(pFilterNode,
                 0, // wild card for handle
                 pwstrDeviceName,
                 pSysaudioGfx->ulOrder+GfxOrderBase))) {
        delete pwstrDeviceName;
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Get the FileObject of the GFX for future use
    //
    Status = ObReferenceObjectByHandle(
      pSysaudioGfx->hGfx,
      GENERIC_READ | GENERIC_WRITE,
      NULL,
      KernelMode,
      (PVOID*)&pFileObject,
      NULL);

    if (!NT_SUCCESS(Status)) {
        delete pwstrDeviceName;
        goto exit;
    }

    //
    // Add the device name string to global memory to be freed
    //
    Status = pFilterNode->lstFreeMem.AddList(pwstrDeviceName);
    if(!NT_SUCCESS(Status)) {
        Trap();
        delete pwstrDeviceName;
        goto exit;
    }

    //
    // Indicate that this Gfx needs be loaded only on the device pointed to be pwstrDeviceName
    //
    Status = pFilterNode->AddDeviceInterfaceMatch(pwstrDeviceName);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Set the Gfx order in the filter node
    //
    pFilterNode->SetOrder(pSysaudioGfx->ulOrder+GfxOrderBase);

    //
    // Profile the GFX and create pin infos, logical filter nodes etc
    //
    Status = pFilterNode->ProfileFilter(pFileObject);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    //
    // Fix the GFX glitching problem. Send the property blindly to GFX
    // filter. KS will handle the property.
    // Failures are not important, ignore them.
    //
    SetKsFrameHolding(pFileObject);    

exit:
    if(!NT_SUCCESS(Status)) {
        DPF1(GFX_VERBOSE_LEVEL, "AddGfx :: Failed, Status = %x", Status);
	if(pFilterNode != NULL) {
	    delete pFilterNode;
	    pFilterNode = NULL;
	}
        if(pFileObject != NULL) {
            ObDereferenceObject(pFileObject);
        }
    }
    else {

        DPF1(GFX_VERBOSE_LEVEL, "AddGfx :: Added GFX FilterNode %x", pFilterNode);
        DPF1(GFX_VERBOSE_LEVEL, "            order = %x", pFilterNode->GetOrder());
        DPF1(GFX_VERBOSE_LEVEL, "            type  = %x", pFilterNode->GetType());
        DPF1(GFX_VERBOSE_LEVEL, "            flags = %x", pFilterNode->GetFlags());

        //
        // Setup file handle details for later use of
        // the user mode handle passed in
        //
        pFilterNode->SetFileDetails(pSysaudioGfx->hGfx,
                                    pFileObject,
                                    PsGetCurrentProcess());
        //
        // Force a rebuild of graph nodes
        //
        DestroyAllGraphs();
    }
    return(Status);
}

NTSTATUS RemoveGfx(
    PSYSAUDIO_GFX pSysaudioGfx
)
{
    NTSTATUS Status;
    PFILE_OBJECT pFileObject=NULL;
    PFILTER_NODE pFilterNode;
    ULONG Flags;
    PWSTR pwstrDeviceName;
    ULONG Length;
    ULONG GfxOrderBase, GfxOrderCeiling;

    GfxOrderBase = GfxOrderCeiling = 0;
    pwstrDeviceName = NULL;

    DPF1(GFX_VERBOSE_LEVEL, "RemoveGfx :: Request to remove Gfx %x", pSysaudioGfx);
    DPF1(GFX_VERBOSE_LEVEL, "          hGfx    = %x", pSysaudioGfx->hGfx);
    DPF1(GFX_VERBOSE_LEVEL, "          ulOrder = %x", pSysaudioGfx->ulOrder);
    DPF1(GFX_VERBOSE_LEVEL, "          ulType  = %x", pSysaudioGfx->ulType);
    DPF1(GFX_VERBOSE_LEVEL, "          Flags   = %x", pSysaudioGfx->ulFlags);

    //
    // validate type to be Capture or Render (use public include file!!!)
    //
    if ((pSysaudioGfx->ulType != GFX_DEVICETYPE_RENDER) && (pSysaudioGfx->ulType != GFX_DEVICETYPE_CAPTURE)) {
        Trap();
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Setup GFX Order's base & ceiling for future usage
    //
    if (pSysaudioGfx->ulType == GFX_DEVICETYPE_RENDER) {
        GfxOrderBase = ORDER_RENDER_GFX_FIRST;
        GfxOrderCeiling = ORDER_RENDER_GFX_LAST;
    }

    if (pSysaudioGfx->ulType == GFX_DEVICETYPE_CAPTURE ) {
        GfxOrderBase = ORDER_CAPTURE_GFX_FIRST;
        GfxOrderCeiling = ORDER_CAPTURE_GFX_LAST;
    }

    ASSERT(GfxOrderBase);
    ASSERT(GfxOrderCeiling);

    //
    // Copy the Device Name (on which the gfx needs to be attached) into a local copy for our own use
    //
    Status = SafeCopyStringFromOffset(pSysaudioGfx, pSysaudioGfx->ulDeviceNameOffset, &pwstrDeviceName);

    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    DPF1(GFX_VERBOSE_LEVEL, "          On DI   = %s", DbgUnicode2Sz(pwstrDeviceName));

    //
    // Find the FilterNode for the Gfx
    //
    
    if ((pFilterNode = FindGfx(NULL,
                               pSysaudioGfx->hGfx,
                               pwstrDeviceName,
                               pSysaudioGfx->ulOrder+GfxOrderBase)) == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Should we validate the FileHandle Value?
    //

    //
    // Dereference the file object
    //
    Status = pFilterNode->ClearFileDetails();
exit:
    if(!NT_SUCCESS(Status)) {
        DPF1(GFX_VERBOSE_LEVEL, "RemoveGfx :: Failed, Status = %x", Status);
        Trap();
    }
    else {
        delete pFilterNode;
    }
    delete pwstrDeviceName;
    return(Status);
}

PFILTER_NODE
FindGfx(
    PFILTER_NODE pnewFilterNode,
    HANDLE hGfx,
    PWSTR pwstrDeviceName,
    ULONG GfxOrder
)
{
    PFILTER_NODE pFilterNode;
    ULONG DeviceCount;
    UNICODE_STRING usInDevice, usfnDevice;
    PWSTR pwstr;


    DPF2(90, "FindGfx::   Looking for GFX with order = %x attached to %s)", GfxOrder, DbgUnicode2Sz(pwstrDeviceName));

    FOR_EACH_LIST_ITEM(gplstFilterNode, pFilterNode) {

        //
        // Skip the one we just added
        //
        if (pFilterNode == pnewFilterNode) {
            continue;
        }

        //
        // Check whether this pFilterNode matches the Gfx we are looking for
        //
        if (pFilterNode->DoesGfxMatch(hGfx, pwstrDeviceName, GfxOrder)) {
            return (pFilterNode);
        }

    } END_EACH_LIST_ITEM

    return(NULL);
}

NTSTATUS
SafeCopyStringFromOffset(
    PVOID pBasePointer,
    ULONG Offset,
    PWSTR *String
)
{
    ULONG Length;
    PWSTR pwstrString = NULL;

    *String = NULL;

    __try {
        Length = wcslen( (PWSTR)(((CHAR *)pBasePointer)+Offset)) + 1;
        pwstrString = new(WCHAR[Length]) ;

        if(pwstrString == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        wcscpy(pwstrString,(PWSTR)(((CHAR *)pBasePointer)+Offset));
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Trap();
        delete [] pwstrString;
        return(STATUS_INVALID_PARAMETER);
    }
    *String = pwstrString;
    return(STATUS_SUCCESS);
}

NTSTATUS
GetFilterTypeFromGuid(
    IN LPGUID pguid,
    OUT PULONG pfulType
)
{
    int i;
    for(i = 0; i < SIZEOF_ARRAY(apguidCategories); i++) {
	if (memcmp (apguidCategories[i], pguid, sizeof(GUID)) == 0) {
	    *pfulType |= aulFilterType[i];
	    return(STATUS_SUCCESS);
	}
    }
    return(STATUS_INVALID_DEVICE_REQUEST);
}

//---------------------------------------------------------------------------
//  End of File: notify.cpp
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pi.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pi.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

DATARANGES DataRangesNull = {
    {
        sizeof(KSMULTIPLE_ITEM) + sizeof(KSDATARANGE),
        1
    },
    {
	sizeof(KSDATARANGE),
	0,
	STATICGUIDOF(GUID_NULL),
	STATICGUIDOF(GUID_NULL),
	STATICGUIDOF(GUID_NULL),
    }
};

IDENTIFIERS IdentifiersNull = {
    {
        sizeof(KSMULTIPLE_ITEM) + sizeof(KSIDENTIFIER),
        1
    },
    {
	STATICGUIDOF(GUID_NULL),
	0,
	0
    }
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CPinInfo::CPinInfo(
    PFILTER_NODE pFilterNode,
    ULONG PinId
)
{
    Assert(pFilterNode);
    this->pFilterNode = pFilterNode;
    this->PinId = PinId;
    AddList(&pFilterNode->lstPinInfo);
}

CPinInfo::~CPinInfo()
{
    Assert(this);

    // Free physical connection data
    delete pPhysicalConnection;
    delete pwstrName;

}

ENUMFUNC
CPinInfo::CreatePhysicalConnection(
)
{
    NTSTATUS Status;

    Assert(this);
    if(pPhysicalConnection != NULL) {
	PFILTER_NODE pFilterNodeConnect;
	PPIN_INFO pPinInfoConnect;

	ASSERT(pPhysicalConnection->Size != 0);
	Status = AddFilter(
	  pPhysicalConnection->SymbolicLinkName,
	  &pFilterNodeConnect);

	if(!NT_SUCCESS(Status)) {
	    DPF1(10,
	      "CreatePhysicalConnection: AddFilter FAILED: %08x", Status);
	    goto exit;
	}
	Assert(pFilterNodeConnect);

	FOR_EACH_LIST_ITEM(&pFilterNodeConnect->lstPinInfo, pPinInfoConnect) {

	    if(pPhysicalConnection->Pin == pPinInfoConnect->PinId) {

		DPF2(50, "CreatePhysicalConnection: From %d %s",
		  PinId,
		  pFilterNode->DumpName());

		DPF2(50, "CreatePhysicalConnection: To %d %s",
		  pPinInfoConnect->PinId,
		  pPinInfoConnect->pFilterNode->DumpName());

		if(DataFlow == KSPIN_DATAFLOW_OUT &&
		   pPinInfoConnect->DataFlow == KSPIN_DATAFLOW_IN) {
		    PTOPOLOGY_CONNECTION pTopologyConnection;

		    Status = CreatePinInfoConnection(
		       &pTopologyConnection,
		       pFilterNode,
		       NULL,
		       this,
		       pPinInfoConnect);

		    if(!NT_SUCCESS(Status)) {
		       Trap();
		       goto exit;
		    }
		}
		else {
		    DPF(50, "CreatePhysicalConnection: rejected");
		}
		break;
	    }

	} END_EACH_LIST_ITEM

#ifndef DEBUG	// Only free the name in retail; allows .s to display name
	delete pPhysicalConnection;
	pPhysicalConnection = NULL;
#endif
    }
    Status = STATUS_CONTINUE;
exit:
    return(Status);
}

NTSTATUS CPinInfo::GetPinInstances(
    PFILE_OBJECT pFileObject,
    PKSPIN_CINSTANCES pcInstances
)
{
    NTSTATUS Status;

    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_CINSTANCES,
      PinId,
      sizeof(KSPIN_CINSTANCES),
      (PVOID) pcInstances);

    return Status;
} // GetPinInstances

NTSTATUS
CPinInfo::Create(
    PFILE_OBJECT pFileObject
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDATARANGES pDataRanges;
    PIDENTIFIERS pInterfaces;
    PIDENTIFIERS pMediums;

    Assert(this);
    Assert(pFilterNode);

    Status = GetPinInstances(pFileObject, &cPinInstances);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_DATAFLOW,
      PinId,
      sizeof(KSPIN_DATAFLOW),
      (PVOID)&DataFlow);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_COMMUNICATION,
      PinId,
      sizeof(KSPIN_COMMUNICATION),
      (PVOID)&Communication);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    pguidCategory = new GUID;
    if(pguidCategory == NULL) {
	Trap();
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    Status = GetPinProperty(
      pFileObject,
      KSPROPERTY_PIN_CATEGORY,
      PinId,
      sizeof(GUID),
      (PVOID)pguidCategory);

    if(NT_SUCCESS(Status)) {
	Status = pFilterNode->lstFreeMem.AddList(pguidCategory);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    delete pguidCategory;
	    pguidCategory = NULL;
	    goto exit;
	}
    }
    else {
	delete pguidCategory;
	pguidCategory = NULL;
	if(Status != STATUS_NOT_FOUND) {
	    Trap();
	    goto exit;
	}
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_NAME,
      PinId,
      (PVOID*)&pwstrName);

    if(!NT_SUCCESS(Status) && Status != STATUS_OBJECT_NAME_NOT_FOUND) {
	Trap();
	goto exit;
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_PHYSICALCONNECTION,
      PinId,
      (PVOID*)&pPhysicalConnection);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_INTERFACES,
      PinId,
      (PVOID*)&pInterfaces);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(pInterfaces == NULL || pInterfaces->MultipleItem.Count == 0) {
	delete pInterfaces;
	pInterfaces = &IdentifiersNull;
    }
    else {
	Status = pFilterNode->lstFreeMem.AddList(pInterfaces);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    delete pInterfaces;
	    goto exit;
	}
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_MEDIUMS,
      PinId,
      (PVOID*)&pMediums);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(pMediums == NULL || pMediums->MultipleItem.Count == 0) {
	delete pMediums;
	pMediums = &IdentifiersNull;
    }
    else {
	Status = pFilterNode->lstFreeMem.AddList(pMediums);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    delete pMediums;
	    goto exit;
	}
    }

    Status = GetPinPropertyEx(
      pFileObject,
      KSPROPERTY_PIN_DATARANGES,
      PinId,
      (PVOID*)&pDataRanges);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    if(pDataRanges == NULL || pDataRanges->MultipleItem.Count == 0) {
	Trap();
	delete pDataRanges;
	pDataRanges = &DataRangesNull;
    }
    else {
	Status = pFilterNode->lstFreeMem.AddList(pDataRanges);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    delete pDataRanges;
	    goto exit;
	}
    }

    Status = CPinNode::CreateAll(
      this,
      pDataRanges,
      pInterfaces,
      pMediums);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    // ISSUE-2001/05/15-alpers    
    // This is a temporary low risk solution to reverse DataRange problem.
    // This needs to be implemented properly in the future.
    //

    if (pFilterNode->GetType() & FILTER_TYPE_AEC) {
        DPF(10, "AEC Filter Pin : Reversing Data Ranges");
        lstPinNode.ReverseList();
    }

    if (pFilterNode->GetType() & FILTER_TYPE_GFX) {
        DPF(10, "GFX Filter Pin : Reversing Data Ranges");
        lstPinNode.ReverseList();
    }

exit:
    return(Status);
}

#ifdef DEBUG

PSZ apszDataFlow[] = { "??", "IN", "OUT" };
PSZ apszCommunication[] = { "NONE", "SINK", "SOURCE", "BOTH", "BRIDGE" };

ENUMFUNC
CPinInfo::Dump(
)
{
    Assert(this);
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("PI: %08x FN %08x PinId %d DataFlow %08x %s Comm %08x %s\n",
	  this,
	  pFilterNode,
	  PinId,
	  DataFlow,
	  apszDataFlow[DataFlow],
	  Communication,
	  apszCommunication[Communication]);
	dprintf("    cPossible %d cCurrent %d %s\n",
	  cPinInstances.PossibleCount,
	  cPinInstances.CurrentCount,
	  pFilterNode->DumpName());
	dprintf("    guidCategory: %s\n", DbgGuid2Sz(pguidCategory));
	dprintf("    guidName:     %s\n", DbgGuid2Sz(pguidName));
	if(pwstrName != NULL) {
	    dprintf("    pwstrName:    %s\n", DbgUnicode2Sz(pwstrName));
	}
	if(pPhysicalConnection != NULL) {
	    dprintf("    pPhysicalConnection: PinId %d\n    %s\n",
	      pPhysicalConnection->Pin,
	      DbgUnicode2Sz(pPhysicalConnection->SymbolicLinkName));
	}
	dprintf("    lstTopologyConnection:");
	lstTopologyConnection.DumpAddress();
	dprintf("\n");
	if(ulDebugFlags & DEBUG_FLAGS_DETAILS) {
	    dprintf("    lshPinNode:\n");
	    lstPinNode.Dump();
	}
    }
    else {
	dprintf("PI: %08x FN %08x #%-2d %-3s %-6s\n",
	  this,
	  pFilterNode,
	  PinId,
	  apszDataFlow[DataFlow],
	  apszCommunication[Communication]);
    }
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pi.h ===
//---------------------------------------------------------------------------
//
//  Module:   		pi.h
//
//  Description:	pin info classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CPinInfo : public CListSingleItem
{
public:
    CPinInfo(
	PFILTER_NODE pFilterNode,
	ULONG PinId = MAXULONG
    );
    ~CPinInfo();
    NTSTATUS Create(
	PFILE_OBJECT pFileObject
    );
    ENUMFUNC Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };
    ENUMFUNC CreatePhysicalConnection();
#ifdef DEBUG
    ENUMFUNC Dump();
#endif
    PFILTER_NODE pFilterNode;
    KSPIN_DATAFLOW DataFlow;
    KSPIN_COMMUNICATION Communication;
    KSPIN_CINSTANCES cPinInstances;
    GUID *pguidCategory;
    GUID *pguidName;
    PWSTR pwstrName;
    LIST_DESTROY_TOPOLOGY_CONNECTION lstTopologyConnection;
    LIST_PIN_NODE lstPinNode;
    ULONG PinId;

    NTSTATUS GetPinInstances(
        PFILE_OBJECT pFileObject,
        PKSPIN_CINSTANCES pcInstances);
       
private:
    PKSPIN_PHYSICALCONNECTION pPhysicalConnection;
public:
    DefineSignature(0x20204950);		// PI

} PIN_INFO, *PPIN_INFO;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<PIN_INFO> LIST_PIN_INFO;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern DATARANGES DataRangesNull;
extern IDENTIFIERS IdentifiersNull;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pins.h ===
//---------------------------------------------------------------------------
//
//  Module:   		pins.h
//
//  Description:	KS Pin Instance
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CPinInstance : public CInstance
{
public:
    CPinInstance(
	IN PPARENT_INSTANCE pParentInstance
    );
    ~CPinInstance(
    );

    static NTSTATUS
    PinDispatchCreate(
	IN PDEVICE_OBJECT pdo,
	IN PIRP	pIrp
    );

    static NTSTATUS
    PinDispatchCreateKP(
	IN OUT PPIN_INSTANCE pPinInstance,
	IN PKSPIN_CONNECT pPinConnect
    );

    static NTSTATUS
    PinDispatchClose(
	IN PDEVICE_OBJECT pdo,
	IN PIRP	pIrp
    );

    static NTSTATUS
    PinDispatchIoControl(
	IN PDEVICE_OBJECT pdo,
	IN PIRP	pIrp
    );

    static NTSTATUS 
    PinStateHandler(
	IN PIRP pIrp,
	IN PKSPROPERTY pProperty,
	IN OUT PKSSTATE pState
    );

    NTSTATUS 
    GetStartNodeInstance(
	OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
    );
#ifdef DEBUG
    ENUMFUNC 
    Dump(
    );

    ENUMFUNC
    DumpAddress(
    );
#endif
    PARENT_INSTANCE ParentInstance;
    PFILTER_INSTANCE pFilterInstance;
    PSTART_NODE_INSTANCE pStartNodeInstance;
    ULONG ulVolumeNodeNumber;
    ULONG PinId;
    DefineSignature(0x494E4950);			// PINI

} PIN_INSTANCE, *PPIN_INSTANCE;

//---------------------------------------------------------------------------
// Inlines
//---------------------------------------------------------------------------

inline PPIN_INSTANCE
CInstance::GetParentInstance(
)
{
    return(CONTAINING_RECORD(
      pParentInstance,
      PIN_INSTANCE,
      ParentInstance));
}

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
ForwardIrpNode(
    IN PIRP pIrp,
    IN OPTIONAL PKSPROPERTY pProperty,		// already validated or NULL
    IN PFILTER_INSTANCE pFilterInstance,
    IN OPTIONAL PPIN_INSTANCE pPinInstance
);

NTSTATUS
GetRelatedStartNodeInstance(
    IN PIRP pIrp,
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
);

NTSTATUS
GetStartNodeInstance(
    IN PIRP pIrp,
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		pn.h
//
//  Description:	pin node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CPinNode : public CListSingleItem
{
public:
    CPinNode(
        PPIN_INFO pPinInfo
    );

    CPinNode(
        PGRAPH_NODE pGraphNode,
        PPIN_NODE pPinNode
    );

    static NTSTATUS
    CreateAll(
	PPIN_INFO pPinInfo,
	PDATARANGES pDataRanges,
	PIDENTIFIERS pInterfaces,
	PIDENTIFIERS pMediums
    );

    ENUMFUNC
    Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    BOOL
    ComparePins(
	PPIN_NODE pPinNode
    );

    ULONG
    GetOverhead(
    )
    {
	return(ulOverhead);
    };

    ULONG
    GetType(				// see lfn.h
    );

#ifdef DEBUG
    ENUMFUNC
    Dump(
    );
#endif
private:
    ULONG ulOverhead;
public:
    PPIN_INFO pPinInfo;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PKSDATARANGE pDataRange;
    PKSPIN_MEDIUM pMedium;
    PKSPIN_INTERFACE pInterface;
    DefineSignature(0x20204e50);		// PN

} PIN_NODE, *PPIN_NODE;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<PIN_NODE> LIST_PIN_NODE;

//---------------------------------------------------------------------------

typedef ListData<PIN_NODE> LIST_DATA_PIN_NODE;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CPinNode::CPinNode(
    PPIN_INFO pPinInfo
)
{
    Assert(pPinInfo);
    this->pPinInfo = pPinInfo;
    AddList(&pPinInfo->lstPinNode);
}

CPinNode::CPinNode(
    PGRAPH_NODE pGraphNode,
    PPIN_NODE pPinNode
)
{
    this->pPinInfo = pPinNode->pPinInfo;
    this->ulOverhead = pPinNode->GetOverhead();
    this->pDataRange = pPinNode->pDataRange;
    this->pInterface = pPinNode->pInterface;
    this->pMedium = pPinNode->pMedium;
    this->pLogicalFilterNode = pPinNode->pLogicalFilterNode;
    AddList(&pGraphNode->lstPinNode);
}

NTSTATUS
CPinNode::CreateAll(
    PPIN_INFO pPinInfo,
    PDATARANGES pDataRanges,
    PIDENTIFIERS pInterfaces,
    PIDENTIFIERS pMediums
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSDATARANGE pDataRange;
    PPIN_NODE pPinNode;
    ULONG d, i, m;

    Assert(pPinInfo);

    // Data Ranges loop
    pDataRange = &pDataRanges->aDataRanges[0];

    for(d = 0; d < pDataRanges->MultipleItem.Count; d++) {

	if(IsEqualGUID(
	  &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
	  &pDataRange->Specifier) ||
	   IsEqualGUID(
	  &KSDATAFORMAT_SPECIFIER_DSOUND,
	  &pDataRange->Specifier)) {
	    //
	    // Reject KSDATARANGE_AUDIO's that have the wrong size
	    //
	    if(pDataRange->FormatSize < sizeof(KSDATARANGE_AUDIO)) {
		DPF(5, "CPinNode::Create: KSDATARANGE_AUDIO wrong size");
		continue;
	    }
	}

	// Interfaces loop
	for(i = 0; i < pInterfaces->MultipleItem.Count; i++) {

	    // Mediums loop
	    for(m = 0; m < pMediums->MultipleItem.Count; m++) {

		pPinNode = new PIN_NODE(pPinInfo);
		if(pPinNode == NULL) {
		    Status = STATUS_INSUFFICIENT_RESOURCES;
		    Trap();
		    goto exit;
		}
		if(pDataRanges != &DataRangesNull) {
		    pPinNode->pDataRange = pDataRange;
		    AssertAligned(pPinNode->pDataRange);
		} else Trap();
		if(pInterfaces != &IdentifiersNull) {
		    pPinNode->pInterface = &pInterfaces->aIdentifiers[i];
		    AssertAligned(pPinNode->pInterface);
		}
		if(pMediums != &IdentifiersNull) {
		    pPinNode->pMedium = &pMediums->aIdentifiers[m];
		    AssertAligned(pPinNode->pMedium);
		} else Trap();

		if(IsEqualGUID(
		  &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
		  &pDataRange->Specifier) ||
		   IsEqualGUID(
		  &KSDATAFORMAT_SPECIFIER_DSOUND,
		  &pDataRange->Specifier)) {
		    //
		    // Puts in order based on SR, BPS and CHs, 
		    // scaled down to 0 - 256
		    //
		    pPinNode->ulOverhead = 256 -
		      (( (((PKSDATARANGE_AUDIO)pDataRange)->
			MaximumChannels > 6 ? 6 :
		      ((PKSDATARANGE_AUDIO)pDataRange)->
			MaximumChannels) *
		      ((PKSDATARANGE_AUDIO)pDataRange)->
			MaximumSampleFrequency *
		      ((PKSDATARANGE_AUDIO)pDataRange)->
			MaximumBitsPerSample) / ((96000 * 32 * 6)/256));
		    //
		    // Try the WaveFormatEx format first, then DSOUND
		    //
		    if(IsEqualGUID(
		      &KSDATAFORMAT_SPECIFIER_DSOUND,
		      &pDataRange->Specifier)) {
			pPinNode->ulOverhead += 1;
		    }
		}
		else {
		    // Put in order that the filter had the data ranges
		    pPinNode->ulOverhead = d;
		}
		// Put in order that the filter had the interface/mediums
		pPinNode->ulOverhead += (m << 16) + (i << 8);
	    }
	}
	// Get the pointer to the next data range
	*((PUCHAR*)&pDataRange) += ((pDataRange->FormatSize + 
	  FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
    }
exit:
    return(Status);
}

BOOL
CPinNode::ComparePins(
    PPIN_NODE pPinNode2
)
{
    PPIN_NODE pPinNode1 = this;

    // Check if dataflow is compatible
    switch(pPinNode1->pPinInfo->DataFlow) {

        case KSPIN_DATAFLOW_IN:
            switch(pPinNode2->pPinInfo->DataFlow) {
		case KSPIN_DATAFLOW_OUT:
		   break;

		default:
		    DPF(100, "ComparePins: dataflow mismatch");
		    return(FALSE);
	    }
	    break;

	case KSPIN_DATAFLOW_OUT:
            switch(pPinNode2->pPinInfo->DataFlow) {
		case KSPIN_DATAFLOW_IN:
		   break;

		default:
		    DPF(100, "ComparePins: dataflow mismatch");
		    return(FALSE);
	    }
	    break;

	default:
	    Trap();
	    DPF(100, "ComparePins: dataflow mismatch");
	    return(FALSE);
    }

    // Check if communication type is compatible
    switch(pPinNode1->pPinInfo->Communication) {
        case KSPIN_COMMUNICATION_BOTH:
            switch(pPinNode2->pPinInfo->Communication) {
		case KSPIN_COMMUNICATION_BOTH:
		case KSPIN_COMMUNICATION_SINK:
		case KSPIN_COMMUNICATION_SOURCE:
		   break;

		default:
		    DPF(100, "ComparePins: comm mismatch");
		    return(FALSE);
	    }
	    break;

        case KSPIN_COMMUNICATION_SOURCE:
            switch(pPinNode2->pPinInfo->Communication) {
		case KSPIN_COMMUNICATION_BOTH:
		case KSPIN_COMMUNICATION_SINK:
		   break;

		default:
		    DPF(100, "ComparePins: comm mismatch");
		    return(FALSE);
	    }
	    break;

	case KSPIN_COMMUNICATION_SINK:
            switch(pPinNode2->pPinInfo->Communication) {
		case KSPIN_COMMUNICATION_BOTH:
		case KSPIN_COMMUNICATION_SOURCE:
		   break;

		default:
		    DPF(100, "ComparePins: comm mismatch");
		    return(FALSE);
	    }
	    break;

	default:
	    DPF(100, "ComparePins: comm mismatch");
	    return(FALSE);
    }

    // Check if interface is the same
    if(!CompareIdentifier(pPinNode1->pInterface, pPinNode2->pInterface)) {
	DPF(100, "ComparePins: interface mismatch");
	return(FALSE);
    }

    // Check if medium is the same
    if(!CompareIdentifier(pPinNode1->pMedium, pPinNode2->pMedium)) {
	Trap();
	DPF(100, "ComparePins: medium mismatch");
	return(FALSE);
    }

    // Check if data range is the same
    if(!CompareDataRange(pPinNode1->pDataRange, pPinNode2->pDataRange)) {
	DPF(100, "ComparePins: datarange mismatch");
	return(FALSE);
    }
    return(TRUE);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CPinNode::Dump(
)
{
    Assert(this);
    dprintf("PN: %08x PI %08x LFN %08x ulOverhead %08x #%d\n",
      this,
      pPinInfo,
      pLogicalFilterNode,
      ulOverhead,
      pPinInfo->PinId);
    dprintf("    Interface: %s\n", DbgIdentifier2Sz(pInterface));
    dprintf("    Medium:    %s\n", DbgIdentifier2Sz(pMedium));
    if(pDataRange != NULL) {
	dprintf("    MajorFormat: %s\n", DbgGuid2Sz(&pDataRange->MajorFormat));
	dprintf("    SubFormat:   %s\n", DbgGuid2Sz(&pDataRange->SubFormat));
	dprintf("    Specifier:   %s\n", DbgGuid2Sz(&pDataRange->Specifier));
	DumpDataRangeAudio((PKSDATARANGE_AUDIO)pDataRange);
    }
    if(ulDebugFlags == DEBUG_FLAGS_OBJECT ||
       ulDebugFlags & DEBUG_FLAGS_LOGICAL_FILTER) {
	pPinInfo->Dump();
    }
    dprintf("\n");
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pni.cpp
//
//  Description:
//
//  Pin Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//  To Do:     Date   Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#ifdef DEBUG
PLIST_PIN_NODE_INSTANCE gplstPinNodeInstance = NULL;
#endif

//---------------------------------------------------------------------------

CPinNodeInstance::~CPinNodeInstance(
)
{
    DPF1(90, "~CPinNodeInstance: %08x", this);
    Assert(this);

    if(pFileObject != NULL) {
        AssertFileObject(pFileObject);
        ObDereferenceObject(pFileObject);
    }
    if(hPin != NULL) {
        AssertStatus(ZwClose(hPin));
    }
    pFilterNodeInstance->Destroy();
}

NTSTATUS
CPinNodeInstance::Create(
    PPIN_NODE_INSTANCE *ppPinNodeInstance,
    PFILTER_NODE_INSTANCE pFilterNodeInstance,
    PPIN_NODE pPinNode,
    PKSPIN_CONNECT pPinConnect,
    BOOL fRender
#ifdef FIX_SOUND_LEAK
   ,BOOL fDirectConnection
#endif
)
{
    PPIN_NODE_INSTANCE pPinNodeInstance = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pPinNode);
    Assert(pPinNode->pPinInfo);
    Assert(pFilterNodeInstance);

    pPinConnect->PinId = pPinNode->pPinInfo->PinId;
    pPinNodeInstance = new PIN_NODE_INSTANCE();
    if(pPinNodeInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    pPinNodeInstance->pPinNode = pPinNode;
    pPinNodeInstance->pFilterNodeInstance = pFilterNodeInstance;
    ASSERT(pPinNodeInstance->CurrentState == KSSTATE_STOP);
    pFilterNodeInstance->AddRef();
    pPinNodeInstance->fRender  = fRender;
#ifdef FIX_SOUND_LEAK
    pPinNodeInstance->fDirectConnection = fDirectConnection;
    pPinNodeInstance->ForceRun = FALSE;
#endif
#ifdef DEBUG
    DPF3(90, "CPNI::Create PN %08x #%d %s",
      pPinNode,
      pPinNode->pPinInfo->PinId,
      pPinNode->pPinInfo->pFilterNode->DumpName());
    DumpPinConnect(90, pPinConnect);
#endif
    if (pFilterNodeInstance->hFilter == NULL) {
        //
        // If it is a GFX we have to attach to the AddGfx() context to create the pin
        //
        Status = pFilterNodeInstance->pFilterNode->CreatePin(pPinConnect,
                                                    GENERIC_WRITE | OBJ_KERNEL_HANDLE,
                                                    &pPinNodeInstance->hPin);
    }
    else {
        Status = KsCreatePin(
          pFilterNodeInstance->hFilter,
          pPinConnect,
          GENERIC_WRITE | OBJ_KERNEL_HANDLE,
          &pPinNodeInstance->hPin);
    }

    if(!NT_SUCCESS(Status)) {
#ifdef DEBUG
        DPF4(90, "CPNI::Create PN %08x #%d %s KsCreatePin FAILED: %08x",
          pPinNode,
          pPinNode->pPinInfo->PinId,
          pPinNode->pPinInfo->pFilterNode->DumpName(),
          Status);
#endif
        pPinNodeInstance->hPin = NULL;
        goto exit;
    }
    Status = ObReferenceObjectByHandle(
      pPinNodeInstance->hPin,
      GENERIC_READ | GENERIC_WRITE,
      NULL,
      KernelMode,
      (PVOID*)&pPinNodeInstance->pFileObject,
      NULL);

    if(!NT_SUCCESS(Status)) {
        pPinNodeInstance->pFileObject = NULL;
        goto exit;
    }
    AssertFileObject(pPinNodeInstance->pFileObject);
#ifdef DEBUG
    Status = gplstPinNodeInstance->AddList(pPinNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
#endif
    DPF2(90, "CPNI::Create SUCCESS %08x PN %08x", pPinNodeInstance, pPinNode);
exit:
    if(!NT_SUCCESS(Status)) {
        if (pPinNodeInstance) {
            pPinNodeInstance->Destroy();
        }
        pPinNodeInstance = NULL;
    }

    *ppPinNodeInstance = pPinNodeInstance;
    return(Status);
}

#ifdef DEBUG
PSZ apszStates[] = { "STOP", "ACQUIRE", "PAUSE", "RUN" };
#endif

NTSTATUS
CPinNodeInstance::SetState(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG State;

    if(this == NULL) {
        goto exit;
    }
    Assert(this);

    DPF9(DBG_STATE, "SetState %s to %s cR %d cP %d cA %d cS %d P# %d %s %s",
      apszStates[PreviousState],
      apszStates[NewState],
      cState[KSSTATE_RUN],
      cState[KSSTATE_PAUSE],
      cState[KSSTATE_ACQUIRE],
      cState[KSSTATE_STOP],
      pPinNode->pPinInfo->PinId,
      apszStates[CurrentState],
      pPinNode->pPinInfo->pFilterNode->DumpName());

    cState[PreviousState]--;
    cState[NewState]++;

    for(State = KSSTATE_RUN; State > KSSTATE_STOP; State--) {
        if(cState[State] > 0) {
            break;
        }
    }

    // ISSUE-2001/04/09-alpers
    // The proper fix would be to propagate the reset to the entire audio stack.
    // But it is considered as being to risky for now (after Beta2 of Windows XP).
    // This should be one of the first things we should address in Blackcomb.
    //

#ifdef FIX_SOUND_LEAK
    // FIX_SOUND_LEAK is to prevent the audio stack from play/recording the last
    // portion of data when a new stream is started.
    // This temporary fix keeps the pins below splitter/kmixer sink pin in
    // RUNNING state.
    //
    if (fRender)
    {
        // For render pins
        //  The criteria for keeping the pin in RUN state:
        //  If the pin is going to PAUSE from RUN.
        //  If the filter is below kmixer.
        //  If the pin is not kmixer sink pin.
        //
        if ( (!fDirectConnection) &&
             (State == KSSTATE_PAUSE) &&
             (PreviousState == KSSTATE_RUN) &&
             (pFilterNodeInstance->pFilterNode->GetOrder() <= ORDER_MIXER) &&
             !(pFilterNodeInstance->pFilterNode->GetOrder() == ORDER_MIXER &&
              pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_SINK) )
        {
                ForceRun = TRUE;
        }
    }
    else
    {
        // For capture pins
        //  The criteria for keeping the pin in RUN state:
        //  If the pin is going to PAUSE from RUN.
        //  There are more than one pins in PAUSE.
        //
        if ( (State == KSSTATE_PAUSE) &&
             (PreviousState == KSSTATE_RUN) &&
             (cState[KSSTATE_PAUSE] > 1) )
        {
            DPF(DBG_STATE, "SetState: CAPTURE forcing KSSTATE_RUN");
            State = KSSTATE_RUN;
        }
    }

    if (ForceRun)
    {
        DPF(DBG_STATE, "SetState: RENDER IN FORCE KSSTATE_RUN state");
        State = KSSTATE_RUN;
    }

#else
    for(State = KSSTATE_RUN; cState[State] <= 0; State--) {
        if(State == KSSTATE_STOP) {
            break;
        }
    }
#endif

#ifdef FIX_SOUND_LEAK
    // If the pin is forced to be in RUN state, we should go back to
    // regular state scheme, if and only if there are no pins in RUN state.
    // To prevent RUN-ACQUIRE first go to PAUSE.
    //
    if (ForceRun &&
        (0 == cState[KSSTATE_PAUSE]) &&
        (0 == cState[KSSTATE_RUN]))
    {
        KSSTATE TempState = KSSTATE_PAUSE;

        DPF(DBG_STATE, "SetState: Exiting FORCE KSSTATE_RUN state");
        DPF1(DBG_STATE, "SetState: PinConnectionProperty(%s)", apszStates[TempState]);

        Status = PinConnectionProperty(
          pFileObject,
          KSPROPERTY_CONNECTION_STATE,
          KSPROPERTY_TYPE_SET,
          sizeof(TempState),
          &TempState);
        if (!NT_SUCCESS(Status))
        {
            if(ulFlags & SETSTATE_FLAG_IGNORE_ERROR) {
                Status = STATUS_SUCCESS;
            }
            else {
                //
                // Go back to previous state if failure
                //
                cState[PreviousState]++;
                cState[NewState]--;
                goto exit;
            }
        }

        // Exiting the FORCE_RUN state.
        //
        CurrentState = KSSTATE_PAUSE;
        State = KSSTATE_ACQUIRE;
        ForceRun = FALSE;
    }
#endif

    if(CurrentState != State) {
        DPF1(DBG_STATE, "SetState: PinConnectionProperty(%s)", apszStates[State]);
        ASSERT(State == CurrentState + 1 || State == CurrentState - 1);

        Status = PinConnectionProperty(
          pFileObject,
          KSPROPERTY_CONNECTION_STATE,
          KSPROPERTY_TYPE_SET,
          sizeof(State),
          &State);

        if(!NT_SUCCESS(Status)) {
            DPF1(5, "SetState: PinConnectionProperty FAILED %08x", Status);

            if(ulFlags & SETSTATE_FLAG_IGNORE_ERROR) {
                Status = STATUS_SUCCESS;
            }
            else {
                //
                // Go back to previous state if failure
                //
                cState[PreviousState]++;
                cState[NewState]--;
                goto exit;
            }
        }

        CurrentState = (KSSTATE)State;
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CPinNodeInstance::Dump(
)
{
    if(this == NULL) {
    return(STATUS_CONTINUE);
    }
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
    dprintf("PNI: %08x PN %08x P# %d FNI %08x FO %08x H %08x\n",
      this,
      pPinNode,
      pPinNode->pPinInfo->PinId,
      pFilterNodeInstance,
      pFileObject,
      hPin);
    dprintf("     State: %08x %s cState: cR %d cP %d cA %d cS %d\n",
      CurrentState,
      apszStates[CurrentState],
      cState[KSSTATE_RUN],
      cState[KSSTATE_PAUSE],
      cState[KSSTATE_ACQUIRE],
      cState[KSSTATE_STOP]);
    }
    else {
    dprintf("%s\n", pPinNode->pPinInfo->pFilterNode->DumpName());
    dprintf("       PinId: %d State: %s cState: cR %d cP %d cA %d cS %d\n",
      pPinNode->pPinInfo->PinId,
      apszStates[CurrentState],
      cState[KSSTATE_RUN],
      cState[KSSTATE_PAUSE],
      cState[KSSTATE_ACQUIRE],
      cState[KSSTATE_STOP]);
    }
    if(ulDebugFlags & DEBUG_FLAGS_INSTANCE) {
    pFilterNodeInstance->Dump();
    }
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pins.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   pins.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------


#include "common.h"


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;
static const WCHAR ClockTypeName[] = KSSTRING_Clock;

DEFINE_KSCREATE_DISPATCH_TABLE(PinCreateItems)
{
    DEFINE_KSCREATE_ITEM(AllocatorDispatchCreate, AllocatorTypeName, 0),
    DEFINE_KSCREATE_ITEM(CClockInstance::ClockDispatchCreate, ClockTypeName, 0),
};

DEFINE_KSDISPATCH_TABLE(
    PinDispatchTable,
    CPinInstance::PinDispatchIoControl,		// Ioctl
    DispatchInvalidDeviceRequest,		// Read
    CInstance::DispatchForwardIrp,		// Write
    DispatchInvalidDeviceRequest,		// Flush
    CPinInstance::PinDispatchClose,		// Close
    DispatchInvalidDeviceRequest,		// QuerySecurity
    DispatchInvalidDeviceRequest,		// SetSeturity
    DispatchFastIoDeviceControlFailure,		// FastDeviceIoControl
    DispatchFastReadFailure,			// FastRead
    DispatchFastWriteFailure			// FastWrite
);

DEFINE_KSPROPERTY_TABLE(SysaudioPinPropertyHandlers) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX,	// idProperty
        GetTopologyConnectionIndex,			// pfnGetHandler
        sizeof(KSPROPERTY),				// cbMinGetPropertyInput
        sizeof(ULONG),					// cbMinGetDataInput
        NULL,						// pfnSetHandler
        NULL,						// Values
        0,						// RelationsCount
        NULL,						// Relations
        NULL,						// SupportHandler
        0						// SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE,	// idProperty
        NULL,				                // pfnGetHandler
        sizeof(SYSAUDIO_ATTACH_VIRTUAL_SOURCE),		// cbMinGetPropertyInput
        0,						// cbMinGetDataInput
        AttachVirtualSource,				// pfnSetHandler
        NULL,						// Values
        0,						// RelationsCount
        NULL,						// Relations
        NULL,						// SupportHandler
        0						// SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE,		// idProperty
        GetPinVolumeNode,				// pfnGetHandler
        sizeof(KSPROPERTY),				// cbMinGetPropertyInput
        sizeof(ULONG),					// cbMinGetDataInput
        NULL,						// pfnSetHandler
        NULL,						// Values
        0,						// RelationsCount
        NULL,						// Relations
        NULL,						// SupportHandler
        0						// SerializedSize
    ),
};

DEFINE_KSPROPERTY_TABLE(PinConnectionHandlers) {
    DEFINE_KSPROPERTY_ITEM(
	KSPROPERTY_CONNECTION_STATE,			// idProperty
        CPinInstance::PinStateHandler,			// pfnGetHandler
        sizeof(KSPROPERTY),				// cbMinGetPropertyInput
        sizeof(ULONG),					// cbMinGetDataInput
        CPinInstance::PinStateHandler,			// pfnSetHandler
        NULL,						// Values
        0,						// RelationsCount
        NULL,						// Relations
        NULL,						// SupportHandler
        0						// SerializedSize
    )
};

DEFINE_KSPROPERTY_TABLE (AudioPinPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
    	KSPROPERTY_AUDIO_VOLUMELEVEL,
    	PinVirtualPropertyHandler,
    	sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
    	sizeof(LONG),
    	PinVirtualPropertyHandler,
    	&PropertyValuesVolume,
	0,
	NULL,
	(PFNKSHANDLER)PinVirtualPropertySupportHandler,
	0
    )
};

DEFINE_KSPROPERTY_SET_TABLE(PinPropertySet)
{
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Connection,				// Set
       SIZEOF_ARRAY(PinConnectionHandlers),		// PropertiesCount
       PinConnectionHandlers,				// PropertyItem
       0,						// FastIoCount
       NULL						// FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Sysaudio_Pin,			// Set
       SIZEOF_ARRAY(SysaudioPinPropertyHandlers),	// PropertiesCount
       SysaudioPinPropertyHandlers,			// PropertyItem
       0,						// FastIoCount
       NULL						// FastIoTable
    ),
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Audio,                              // Set
       SIZEOF_ARRAY(AudioPinPropertyHandlers),          // PropertiesCount
       AudioPinPropertyHandlers,                        // PropertyItem
       0,                                               // FastIoCount
       NULL                                             // FastIoTable
    )
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CPinInstance::CPinInstance(
    IN PPARENT_INSTANCE pParentInstance
) : CInstance(pParentInstance)
{
}

CPinInstance::~CPinInstance(
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;

    Assert(this);
    Assert(pFilterInstance);
    DPF1(100, "~CPinInstance: %08x", this);
    if(pStartNodeInstance != NULL) {
        pGraphNodeInstance = pFilterInstance->pGraphNodeInstance;
        if(pGraphNodeInstance != NULL) {
            Assert(pGraphNodeInstance);
            ASSERT(PinId < pGraphNodeInstance->cPins);
            ASSERT(pGraphNodeInstance->pacPinInstances != NULL);
            ASSERT(pGraphNodeInstance->pacPinInstances[PinId].CurrentCount > 0);

            pGraphNodeInstance->pacPinInstances[PinId].CurrentCount--;
        }
        else {
            DPF2(10, "~CPinInstance PI %08x FI %08x no GNI",
              this,
              pFilterInstance);
        }
        pStartNodeInstance->Destroy();
    }
    else {
        DPF2(10, "~CPinInstance PI %08x FI %08x no SNI",
          this,
          pFilterInstance);
    }
}

NTSTATUS
CPinInstance::PinDispatchCreate(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PPIN_INSTANCE pPinInstance = NULL;
    PKSPIN_CONNECT pPinConnect = NULL;
    NTSTATUS Status;

    ::GrabMutex();

    Status = GetRelatedGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);
    ASSERT(pGraphNodeInstance->pacPinInstances != NULL);
    ASSERT(pGraphNodeInstance->paPinDescriptors != NULL);

    //
    // Get the PinConnect structure from KS.
    // This function will copy creation parameters to pPinConnect.
    // Also do a basic connectibility testing by comparing KSDATAFORMAT of 
    // pin descriptors and the request.
    //
    Status = KsValidateConnectRequest(
      pIrp,
      pGraphNodeInstance->cPins,
      pGraphNodeInstance->paPinDescriptors,
      &pPinConnect);

    if(!NT_SUCCESS(Status)) {
#ifdef DEBUG
        DPF1(60, "PinDispatchCreate: KsValidateConnectReq FAILED %08x", Status);
        if(pPinConnect != NULL) {
            DumpPinConnect(60, pPinConnect);
        }
#endif
        goto exit;
    }
    ASSERT(pPinConnect->PinId < pGraphNodeInstance->cPins);

#ifdef DEBUG
    DPF(60, "PinDispatchCreate:");
    DumpPinConnect(60, pPinConnect);
#endif
    // Check the pin instance count
    if(!pGraphNodeInstance->IsPinInstances(pPinConnect->PinId)) {
        DPF4(60, "PinDispatchCreate: not enough ins GNI %08x #%d C %d P %d",
         pGraphNodeInstance,
         pPinConnect->PinId,
         pGraphNodeInstance->pacPinInstances[pPinConnect->PinId].CurrentCount,
         pGraphNodeInstance->pacPinInstances[pPinConnect->PinId].PossibleCount);
        Status = STATUS_DEVICE_BUSY;
        goto exit;
    }

    // Allocate per pin instance data
    pPinInstance = new PIN_INSTANCE(
      &pGraphNodeInstance->pFilterInstance->ParentInstance);
    if(pPinInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    // Setup the pin's instance data
    pPinInstance->ulVolumeNodeNumber = MAXULONG;
    pPinInstance->pFilterInstance = pGraphNodeInstance->pFilterInstance;
    pPinInstance->PinId = pPinConnect->PinId;

    Status = pPinInstance->DispatchCreate(
      pIrp,
      (UTIL_PFN)PinDispatchCreateKP,
      pPinConnect,
      SIZEOF_ARRAY(PinCreateItems),
      PinCreateItems,
      &PinDispatchTable);

    pPinConnect->PinId = pPinInstance->PinId;
    if(!NT_SUCCESS(Status)) {
#ifdef DEBUG
        DPF1(60, "PinDispatchCreate: FAILED: %08x ", Status);
        DumpPinConnect(60, pPinConnect);
#endif
        goto exit;
    }
    // Increment the reference count on this pin
    ASSERT(pPinInstance->pStartNodeInstance != NULL);
    ASSERT(pGraphNodeInstance->pacPinInstances != NULL);
    pGraphNodeInstance->pacPinInstances[pPinInstance->PinId].CurrentCount++;
exit:
    if(!NT_SUCCESS(Status)) {
        delete pPinInstance;
    }
    ::ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return Status;
}

NTSTATUS
CPinInstance::PinDispatchCreateKP(
    PPIN_INSTANCE pPinInstance,
    PKSPIN_CONNECT pPinConnect
)
{
    PWAVEFORMATEX pWaveFormatExRequested = NULL;
    PFILTER_INSTANCE pFilterInstance;
    PSTART_NODE pStartNode;
    NTSTATUS Status;

    Assert(pPinInstance);
    pFilterInstance = pPinInstance->pFilterInstance;
    Assert(pFilterInstance);
    ASSERT(pPinInstance->PinId < pFilterInstance->pGraphNodeInstance->cPins);
    ASSERT(pPinConnect->PinId < pFilterInstance->pGraphNodeInstance->cPins);


    if(IsEqualGUID(
      &PKSDATAFORMAT(pPinConnect + 1)->Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        pWaveFormatExRequested =
          &PKSDATAFORMAT_WAVEFORMATEX(pPinConnect + 1)->WaveFormatEx;
    }
    else if(IsEqualGUID(
      &PKSDATAFORMAT(pPinConnect + 1)->Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND)) {
        pWaveFormatExRequested =
          &PKSDATAFORMAT_DSOUND(pPinConnect + 1)->BufferDesc.WaveFormatEx;
    }
    
    if(pWaveFormatExRequested != NULL) {
        // Fix SampleSize if zero
        if(PKSDATAFORMAT(pPinConnect + 1)->SampleSize == 0) {
            PKSDATAFORMAT(pPinConnect + 1)->SampleSize = 
              pWaveFormatExRequested->nBlockAlign;
        }
    }

    //
    // Try each start node until success
    //
    Status = STATUS_INVALID_DEVICE_REQUEST;

    //
    // First loop through all the start nodes which are not marked SECONDPASS
    // and try to create a StartNodeInstance
    //
    FOR_EACH_LIST_ITEM(
      pFilterInstance->pGraphNodeInstance->aplstStartNode[pPinInstance->PinId],
      pStartNode) {

	Assert(pStartNode);
	Assert(pFilterInstance);

        if(pStartNode->ulFlags & STARTNODE_FLAGS_SECONDPASS) {
            continue;
        }

	if(pFilterInstance->pGraphNodeInstance->IsGraphValid(
	  pStartNode,
	  pPinInstance->PinId)) {

	    Status = CStartNodeInstance::Create(
	      pPinInstance,
	      pStartNode,
	      pPinConnect,
	      pWaveFormatExRequested,
	      NULL);
	    if(NT_SUCCESS(Status)) {
		break;
	    }
	}

    } END_EACH_LIST_ITEM

    if(!NT_SUCCESS(Status)) {
        //
        // If first pass failed to create an instance try all the second pass
        // StartNodes in the list. This is being done for creating paths with no GFX
        // because we created a path with AEC and no GFX earlier.
        //
        FOR_EACH_LIST_ITEM(
          pFilterInstance->pGraphNodeInstance->aplstStartNode[pPinInstance->PinId],
          pStartNode) {

	    Assert(pStartNode);
	    Assert(pFilterInstance);

            if((pStartNode->ulFlags & STARTNODE_FLAGS_SECONDPASS) == 0) {
                continue;
            }

	    if(pFilterInstance->pGraphNodeInstance->IsGraphValid(
	      pStartNode,
	      pPinInstance->PinId)) {

	        Status = CStartNodeInstance::Create(
	          pPinInstance,
	          pStartNode,
	          pPinConnect,
	          pWaveFormatExRequested,
	          NULL);

	        if(NT_SUCCESS(Status)) {
		    break;
	        }
	    }

        } END_EACH_LIST_ITEM

        if(!NT_SUCCESS(Status)) {
	    goto exit;
        }
    }
    Status = pPinInstance->SetNextFileObject(
      pPinInstance->pStartNodeInstance->pPinNodeInstance->hPin);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }

exit:
    return(Status);
}

NTSTATUS
CPinInstance::PinDispatchClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;
    PPIN_INSTANCE pPinInstance;

    ::GrabMutex();

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pPinInstance = (PPIN_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pPinInstance);
    pIrpStack->FileObject->FsContext = NULL;
    delete pPinInstance;

    ::ReleaseMutex();

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
CPinInstance::PinDispatchIoControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PIO_STACK_LOCATION pIrpStack;
    PKSPROPERTY pProperty = NULL;
    PPIN_INSTANCE pPinInstance;
    BOOL fProperty = FALSE;
    ULONG ulFlags = 0;

#ifdef DEBUG
    DumpIoctl(pIrp, "Pin");
#endif

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_KS_PROPERTY:
            fProperty = TRUE;
            break;

        case IOCTL_KS_ENABLE_EVENT:
        case IOCTL_KS_DISABLE_EVENT:
        case IOCTL_KS_METHOD:
            break;

        default:
            return(DispatchForwardIrp(pDeviceObject, pIrp));
    }
    
    ::GrabMutex();

    pPinInstance = (PPIN_INSTANCE)pIrpStack->FileObject->FsContext;
    Status = pPinInstance->GetStartNodeInstance(&pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pPinInstance->pFilterInstance);
    Assert(pPinInstance->pFilterInstance->pGraphNodeInstance);

    if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength >= 
      sizeof(KSPROPERTY)) {

        __try {
            if(pIrp->AssociatedIrp.SystemBuffer == NULL) {
                pProperty = (PKSPROPERTY)
                  (pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer);

                // Validate the pointers if the client is not trusted.
                if(pIrp->RequestorMode != KernelMode) {
                    ProbeForWrite(
                      pProperty, 
                      pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
                      sizeof(BYTE));
                }
            }
            else {
                pProperty =
                  (PKSPROPERTY)((PUCHAR)pIrp->AssociatedIrp.SystemBuffer +
                  ((pIrpStack->Parameters.DeviceIoControl.OutputBufferLength +
                  FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT));
            }
            ulFlags = pProperty->Flags;

        } 
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Trap();
            Status = GetExceptionCode();
            DPF1(5, "PinDispatchIoControl: Exception %08x", Status);
            goto exit;
        }

        //
        // This check allows the actual node or filter return the set's
        // supported, etc. instead of always return only the sets sysaudio
        // supports.
        //
        if(ulFlags & KSPROPERTY_TYPE_TOPOLOGY) {
            if(fProperty) {
                if((ulFlags & (KSPROPERTY_TYPE_GET |
                               KSPROPERTY_TYPE_SET |
                               KSPROPERTY_TYPE_BASICSUPPORT)) == 0) {

                    // NOTE: ForwardIrpNode releases gMutex
            return(ForwardIrpNode(
              pIrp,
                      pProperty,
              pPinInstance->pFilterInstance,
              pPinInstance));
                }
            }
            else {
                // NOTE: ForwardIrpNode releases gMutex
                return(ForwardIrpNode(
                  pIrp,
                  pProperty,
                  pPinInstance->pFilterInstance,
                  pPinInstance));
            }
        }
    }

    switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_KS_PROPERTY:

            Status = KsPropertyHandler(
              pIrp,
              SIZEOF_ARRAY(PinPropertySet),
              (PKSPROPERTY_SET)PinPropertySet);

            if(Status != STATUS_NOT_FOUND &&
               Status != STATUS_PROPSET_NOT_FOUND) {
                break;
            }
            // Fall through if property not found

        case IOCTL_KS_ENABLE_EVENT:
        case IOCTL_KS_DISABLE_EVENT:
        case IOCTL_KS_METHOD:

        // NOTE: ForwardIrpNode releases gMutex
            return(ForwardIrpNode(
              pIrp,
              NULL,
              pPinInstance->pFilterInstance,
              pPinInstance));

        default:
            ASSERT(FALSE);	// Can't happen because of above switch
    }
exit:
    ::ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return(Status);
}

NTSTATUS 
CPinInstance::PinStateHandler
(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PKSSTATE pState
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;
#ifdef DEBUG
    extern PSZ apszStates[];
#endif
    Status = ::GetStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    if(pProperty->Flags & KSPROPERTY_TYPE_GET) {
	*pState = pStartNodeInstance->CurrentState;
	pIrp->IoStatus.Information = sizeof(KSSTATE);
        if(*pState == KSSTATE_PAUSE) {
            if(pStartNodeInstance->pPinNodeInstance->
	       pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {
                Status = STATUS_NO_DATA_DETECTED;
            }
        }
    }
    else {
	ASSERT(pProperty->Flags & KSPROPERTY_TYPE_SET);

	DPF3(90, "PinStateHandler from %s to %s - SNI: %08x",
	  apszStates[pStartNodeInstance->CurrentState],
	  apszStates[*pState],
	  pStartNodeInstance);

	Status = pStartNodeInstance->SetState(*pState, 0);
	if(!NT_SUCCESS(Status)) {
	    DPF1(90, "PinStateHandler FAILED: %08x", Status);
	    goto exit;
	}

    }
exit:
    return(Status);
}

NTSTATUS
GetRelatedStartNodeInstance(
    IN PIRP pIrp,
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
)
{
    return(((PPIN_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->FileObject->
      RelatedFileObject->FsContext)->GetStartNodeInstance(ppStartNodeInstance));
}

NTSTATUS
GetStartNodeInstance(
    IN PIRP pIrp,
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
)
{
    return(((PPIN_INSTANCE)IoGetCurrentIrpStackLocation(pIrp)->FileObject->
      FsContext)->GetStartNodeInstance(ppStartNodeInstance));
}

NTSTATUS
CPinInstance::GetStartNodeInstance(
    OUT PSTART_NODE_INSTANCE *ppStartNodeInstance
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(this == NULL || pStartNodeInstance == NULL) {
	DPF(60, "GetStartNodeInstance: pStartNodeInstance == NULL");
	Status = STATUS_NO_SUCH_DEVICE;
	goto exit;
    }
    Assert(this);
    *ppStartNodeInstance = pStartNodeInstance;
exit:
    return(Status);
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

// NOTE: ForwardIrpNode releases gMutex

NTSTATUS
ForwardIrpNode(
    IN PIRP pIrp,
    IN OPTIONAL PKSPROPERTY pProperty, // already validated or NULL
    IN PFILTER_INSTANCE pFilterInstance,
    IN OPTIONAL PPIN_INSTANCE pPinInstance
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PFILE_OBJECT pFileObject = NULL;
    PIO_STACK_LOCATION pIrpStack;
    PKSEVENTDATA pEventData;
    ULONG OriginalNodeId;
    NTSTATUS Status;

    Assert(pFilterInstance);
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    Status = pFilterInstance->GetGraphNodeInstance(&pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(pPinInstance != NULL) {
        pFileObject = pPinInstance->GetNextFileObject();
    }
    
    __try {
    if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength >= sizeof(KSNODEPROPERTY) &&
       pIrpStack->Parameters.DeviceIoControl.IoControlCode != IOCTL_KS_DISABLE_EVENT) {

        if(pProperty == NULL) {
            if(pIrp->AssociatedIrp.SystemBuffer == NULL) {
                Trap();
                pProperty = (PKSPROPERTY)
                  (pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer);

                // Validate the pointers if the client is not trusted.
                if(pIrp->RequestorMode != KernelMode) {
                    ProbeForWrite(
                      pProperty,
                      pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
                      sizeof(BYTE));
                }
            }
            else {
                pProperty = (PKSPROPERTY)
                  ((PUCHAR)pIrp->AssociatedIrp.SystemBuffer +
                  ((pIrpStack->Parameters.DeviceIoControl.OutputBufferLength +
                  FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT));
            }
        }

        ASSERT(!IsEqualGUID(&pProperty->Set, &KSPROPSETID_Sysaudio));
        ASSERT(!IsEqualGUID(&pProperty->Set, &KSEVENTSETID_Sysaudio));

        if(pProperty->Flags & KSPROPERTY_TYPE_TOPOLOGY) {

            OriginalNodeId = ((PKSNODEPROPERTY)pProperty)->NodeId;

            if(pPinInstance == NULL) {
                Status = pGraphNodeInstance->
                  GetTopologyNodeFileObject(
                    &pFileObject,
                    OriginalNodeId);
            }
            else {
                Status = pPinInstance->pStartNodeInstance->
                  GetTopologyNodeFileObject(
                    &pFileObject,
                OriginalNodeId);
            }
            if(!NT_SUCCESS(Status)) {
                DPF1(100, 
                  "ForwardIrpNode: GetTopologyNodeFileObject FAILED %08x",
                  Status);
                goto exit;
            }

            // Put real node number in input buffer
            ((PKSNODEPROPERTY)pProperty)->NodeId = pGraphNodeInstance->
                papTopologyNode[OriginalNodeId]->ulRealNodeNumber;
        }
    }
    else {
    //
    // If it is DisableEvent && if it is of type DPC. We look into the
    // Reserved field of KSEVENTDATA to extract the original node on
    // which the event was enabled (The high bit is set if we ever
    // stashed a NodeId in there).
    //
        if(pIrpStack->Parameters.DeviceIoControl.IoControlCode ==
          IOCTL_KS_DISABLE_EVENT) {

            if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
              sizeof(KSEVENTDATA)) {
                pEventData = (PKSEVENTDATA)
                  pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

                if(pIrp->RequestorMode != KernelMode) {
                    ProbeForWrite(
                        pEventData,
                        pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
                        sizeof (BYTE));
                }

                OriginalNodeId = ULONG(pEventData->Dpc.Reserved);

                if((pEventData->NotificationType == KSEVENTF_DPC) &&
                  (OriginalNodeId & 0x80000000)) {

                    OriginalNodeId = OriginalNodeId & 0x7fffffff;

                    if(pPinInstance == NULL) {
                        Status = pGraphNodeInstance->
                          GetTopologyNodeFileObject(
                            &pFileObject,
                            OriginalNodeId);
                    }
                    else {
                        Status = pPinInstance->pStartNodeInstance->
                          GetTopologyNodeFileObject(
                            &pFileObject,
                            OriginalNodeId);
                    }

                    if(!NT_SUCCESS(Status)) {
                        DPF1(100, 
                          "ForwardIrpNode: GetTopologyNodeFileObject FAILED %08x",
                          Status);
                        goto exit;
                    }
                }
            }
        }
    }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Trap();
        Status = GetExceptionCode();
        DPF1(5, "ForwardIrpNode: Exception %08x", Status);
            goto exit;
    }
    
    if(pFileObject == NULL) {
        Status = STATUS_NOT_FOUND;
        DPF1(100, "ForwardIrpNode: Property not forwarded: %08x", pProperty);
        goto exit;
    }
    pIrpStack->FileObject = pFileObject;

    //
    // If it was EnableEvent we stash away pointer to KSEVENTDATA, so that we
    // can stash the NodeID into it after we call the next driver on the stack
    //
    KPROCESSOR_MODE RequestorMode;
    
    if((pProperty != NULL) &&
      (pIrpStack->Parameters.DeviceIoControl.IoControlCode == 
      IOCTL_KS_ENABLE_EVENT) &&
     !(pProperty->Flags & KSEVENT_TYPE_BASICSUPPORT) &&
      (pProperty->Flags & KSPROPERTY_TYPE_TOPOLOGY) &&
      (pProperty->Flags & KSEVENT_TYPE_ENABLE)) {
        pEventData = (PKSEVENTDATA) pIrp->UserBuffer;
        RequestorMode = pIrp->RequestorMode;
    }
    else {
        pEventData = NULL;
    }

    IoSkipCurrentIrpStackLocation(pIrp);
    AssertFileObject(pIrpStack->FileObject);
    Status = IoCallDriver(IoGetRelatedDeviceObject(pFileObject), pIrp);

    //
    // Stash away the Node id in EventData
    //
    __try {
        if (pEventData != NULL) {
            if (RequestorMode == UserMode) {
                ProbeForWrite(pEventData, sizeof(KSEVENTDATA), sizeof(BYTE));
            }

            if (pEventData->NotificationType == KSEVENTF_DPC) {
                pEventData->Dpc.Reserved = OriginalNodeId | 0x80000000;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Trap();
        Status = GetExceptionCode();
        DPF1(5, "ForwardIrpNode: Exception %08x", Status);
    }

    if(!NT_SUCCESS(Status)) {
        DPF1(100, "ForwardIrpNode: Status %08x", Status);
    }

    ::ReleaseMutex();
    return(Status);

exit:
    ::ReleaseMutex();

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return(Status);
}


//---------------------------------------------------------------------------

#ifdef DEBUG

extern PSZ apszStates[];

ENUMFUNC
CPinInstance::Dump(
)
{
    Assert(this);
    // .siv
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("PI: %08x FI %08x SNI %08x ulVNN %08x PinId %d\n",
	  this,
	  pFilterInstance,
	  pStartNodeInstance,
	  ulVolumeNodeNumber,
	  PinId);
	CInstance::Dump();
	ParentInstance.Dump();
    }
    else {
	dprintf("   Fr: Sysaudio\n       PinId: %d\n", PinId);
    }
    if(ulDebugFlags & DEBUG_FLAGS_INSTANCE) {
	if(pStartNodeInstance != NULL) {
	    pStartNodeInstance->Dump();
	}
    }
    return(STATUS_CONTINUE);
}

ENUMFUNC
CPinInstance::DumpAddress(
)
{
    if(this != NULL) {
	Assert(this);
	dprintf(" %08x", this);
    }
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
//  End of File: pins.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\pni.h ===
//---------------------------------------------------------------------------
//
//  Module:         pni.h
//
//  Description:    Pin Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define SETSTATE_FLAG_IGNORE_ERROR  0x00000001
#define SETSTATE_FLAG_SINK          0x00000002
#define SETSTATE_FLAG_SOURCE        0x00000004

#define MAX_STATES                  (KSSTATE_RUN+1)

// Enable temp fix for LEAKING the last portion of previous sound.
#define FIX_SOUND_LEAK 1


//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

#ifdef DEBUG
typedef class CPinNodeInstance : public CListMultiItem
#else
typedef class CPinNodeInstance : public CObj
#endif
{
private:
    ~CPinNodeInstance(
    );

public:
    static NTSTATUS
    Create(
        PPIN_NODE_INSTANCE *ppPinNodeInstance,
        PFILTER_NODE_INSTANCE pFilterNodeInstance,
        PPIN_NODE pPinNode,
        PKSPIN_CONNECT pPinConnect,
        BOOL fRender
#ifdef FIX_SOUND_LEAK
       ,BOOL fDirectConnection
#endif
    );

    VOID
    Destroy(
    )
    {
        if(this != NULL) {
            Assert(this);
            delete this;
        }
    };

    NTSTATUS
    SetState(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

#ifdef DEBUG
    ENUMFUNC Dump();
#endif

    PPIN_NODE pPinNode;
    PFILE_OBJECT pFileObject;
    HANDLE hPin;
private:
    KSSTATE CurrentState;
    int     cState[MAX_STATES];
    PFILTER_NODE_INSTANCE pFilterNodeInstance;
    BOOL    fRender;

#ifdef FIX_SOUND_LEAK
    BOOL    fDirectConnection;
    BOOL    ForceRun;
#endif

public:
    DefineSignature(0x20494E50);        // PNI

} PIN_NODE_INSTANCE, *PPIN_NODE_INSTANCE;

//---------------------------------------------------------------------------

#ifdef DEBUG
typedef ListMulti<PIN_NODE_INSTANCE> LIST_PIN_NODE_INSTANCE;
typedef LIST_PIN_NODE_INSTANCE *PLIST_PIN_NODE_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PLIST_PIN_NODE_INSTANCE gplstPinNodeInstance;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\property.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   property.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Andy Nicholson
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
PropertyReturnString(
    IN PIRP pIrp,
    IN PWSTR pwstrString,
    IN ULONG cbString,
    OUT PVOID pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;
    ULONG cbNameBuffer;
    ULONG cbToCopy;

    pIrp->IoStatus.Information = 0;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    cbNameBuffer = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    cbNameBuffer &= ~(sizeof(WCHAR) - 1);  // round down to whole wchar's

    // If the size of the passed buffer is 0, then the
    // requestor wants to know the length of the string.
    if(cbNameBuffer == 0) {
        pIrp->IoStatus.Information = cbString;
    Status = STATUS_BUFFER_OVERFLOW;
    }
    // If the size of the passed buffer is a ULONG, then infer the
    // requestor wants to know the length of the string.
    else if(cbNameBuffer == sizeof(ULONG)) {
        *((PULONG)pData) = cbString;
        pIrp->IoStatus.Information = sizeof(ULONG);
    ASSERT(NT_SUCCESS(Status));
    }
    else {
        // Note that we don't check for zero-length buffer because ks handler
        // function should have done that already.
        // Even though we are getting back the length of the string (as though
        // it were a unicode string) it is being handed up as a double-byte
        // string, so this code assumes there is a null at the end.  There
        // will be a bug here if there is no null.

        cbToCopy = min(cbString, cbNameBuffer);
        RtlCopyMemory(pData, pwstrString, cbToCopy);

        // Ensure there is a null at the end

        ((PWCHAR)pData)[cbToCopy/sizeof(WCHAR) - 1] = (WCHAR)0;
        pIrp->IoStatus.Information =  cbToCopy;
    ASSERT(NT_SUCCESS(Status));
    }
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
SetPreferredDevice(
    IN PIRP pIrp,
    IN PSYSAUDIO_PREFERRED_DEVICE pPreferred,
    IN PULONG pulDevice
)
{
    PFILTER_INSTANCE pFilterInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode,OldDeviceNode;
    ULONG PinId = MAXULONG;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(pPreferred->Flags & ~SYSAUDIO_FLAGS_CLEAR_PREFERRED) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    if(pPreferred->Index >= MAX_SYSAUDIO_DEFAULT_TYPE) {
        Trap();
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    if(pPreferred->Flags & SYSAUDIO_FLAGS_CLEAR_PREFERRED) {
        OldDeviceNode = apShingleInstance[pPreferred->Index]->GetDeviceNode();
        if (OldDeviceNode) {
            OldDeviceNode->SetPreferredStatus((KSPROPERTY_SYSAUDIO_DEFAULT_TYPE)pPreferred->Index, FALSE);
        }
        apShingleInstance[pPreferred->Index]->SetDeviceNode(NULL);
        DPF1(60, "SetPreferredDevice: CLEAR %d", pPreferred->Index);
    }
    else {
        if(*pulDevice == MAXULONG) {
            pDeviceNode = pFilterInstance->GetDeviceNode();
            if(pDeviceNode == NULL) {
                Trap();
                Status = STATUS_INVALID_DEVICE_REQUEST;
                goto exit;
            }
        }
        else {
            Status = GetDeviceByIndex(
              *pulDevice,
              &pDeviceNode);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
        Assert(pDeviceNode);
        if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength ==
          (sizeof(ULONG) * 2)) {
             PinId = pulDevice[1];
        }
        OldDeviceNode = apShingleInstance[pPreferred->Index]->GetDeviceNode();
        if (OldDeviceNode) {
            OldDeviceNode->SetPreferredStatus((KSPROPERTY_SYSAUDIO_DEFAULT_TYPE)pPreferred->Index, FALSE);
        }
        apShingleInstance[pPreferred->Index]->SetDeviceNode(pDeviceNode);
        pDeviceNode->SetPreferredStatus((KSPROPERTY_SYSAUDIO_DEFAULT_TYPE)pPreferred->Index, TRUE);

        DPF4(60, "SetPreferredDevice: %d SAD %d #%d %s",
          pPreferred->Index,
          *pulDevice,
          PinId,
          pDeviceNode->DumpName());
    }
exit:
    return(Status);
}

NTSTATUS
GetComponentIdProperty(
    IN PIRP pIrp,
    IN PKSPROPERTY pRequest,
    IN OUT PVOID pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(*(PULONG)(pRequest + 1) == MAXULONG) {
        pDeviceNode = pFilterInstance->GetDeviceNode();
        if(pDeviceNode == NULL) {
            Trap();
            Status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
    }
    else {
        Status = GetDeviceByIndex(
          *(PULONG)(pRequest + 1),
          &pDeviceNode);

        if(!NT_SUCCESS(Status)) {
            goto exit;
        }
    }
    Assert(pDeviceNode);

    if(pDeviceNode->GetComponentId() == NULL) {
        Status = STATUS_INVALID_DEVICE_REQUEST; // This should be STATUS_NOT_FOUND but
        goto exit;                              // returning this causes FilterDispatchIoControl
                                                // call ForwardIrpNode which asserts that this is
                                                // not a KSPROPSETID_Sysaudio property.
    }

    RtlCopyMemory(
        pData,
        pDeviceNode->GetComponentId(),
        sizeof(KSCOMPONENTID));
    Status = STATUS_SUCCESS;

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
GetFriendlyNameProperty(
    IN PIRP pIrp,
    IN PKSPROPERTY pRequest,
    IN OUT PVOID pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(*(PULONG)(pRequest + 1) == MAXULONG) {
    pDeviceNode = pFilterInstance->GetDeviceNode();
    if(pDeviceNode == NULL) {
        Trap();
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    }
    else {
    Status = GetDeviceByIndex(
      *(PULONG)(pRequest + 1),
      &pDeviceNode);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    }
    Assert(pDeviceNode);

    if(pDeviceNode->GetFriendlyName() == NULL) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Status = PropertyReturnString(
      pIrp,
      pDeviceNode->GetFriendlyName(),
      (wcslen(pDeviceNode->GetFriendlyName()) *
        sizeof(WCHAR)) + sizeof(UNICODE_NULL),
      pData);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
GetDeviceCount(
    IN PIRP     pIrp,
    IN PKSPROPERTY  pRequest,
    IN OUT PVOID    pData
)
{
    if(gplstDeviceNode == NULL) {
    *(PULONG)pData = 0;
    }
    else {
    *(PULONG)pData = gplstDeviceNode->CountList();
    }
    pIrp->IoStatus.Information = sizeof(ULONG);
    return(STATUS_SUCCESS);
}

NTSTATUS
GetInstanceDevice(
    IN PIRP     pIrp,
    IN PKSPROPERTY  pRequest,
    IN OUT PVOID    pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpStack;
    PFILTER_INSTANCE pFilterInstance;
    ULONG Index;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    Status = pFilterInstance->GetDeviceNode()->GetIndexByDevice(&Index);
    if(NT_SUCCESS(Status)) {
        *(PULONG)pData = Index;
        pIrp->IoStatus.Information = sizeof(ULONG);
    }
    return(Status);
}

NTSTATUS
SetInstanceDevice(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(!pFilterInstance->IsChildInstance()) {
    DPF(5, "SetInstanceDevice: FAILED - open pin instances");
    Status = STATUS_INVALID_DEVICE_REQUEST;
    goto exit;
    }
    Status = GetDeviceByIndex(*(PULONG)Data, &pDeviceNode);
    if(NT_SUCCESS(Status)) {
    Status = pFilterInstance->SetDeviceNode(pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    }
exit:
    return(Status);
}

NTSTATUS
SetInstanceInfo(
    IN PIRP     Irp,
    IN PSYSAUDIO_INSTANCE_INFO pInstanceInfo,
    IN OUT PVOID    Data
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(pInstanceInfo->Flags & ~SYSAUDIO_FLAGS_DONT_COMBINE_PINS) {
    Status = STATUS_INVALID_PARAMETER;
    goto exit;
    }

    if(!pFilterInstance->IsChildInstance()) {
    Trap();
    DPF(5, "SetInstanceInfo: FAILED - open pin instances");
    Status = STATUS_INVALID_DEVICE_REQUEST;
    goto exit;
    }

    Status = GetDeviceByIndex(pInstanceInfo->DeviceNumber, &pDeviceNode);
    if(!NT_SUCCESS(Status)) {
    goto exit;
    }
    Assert(pDeviceNode);

    pFilterInstance->ulFlags |= FLAGS_COMBINE_PINS;
    if(pInstanceInfo->Flags & SYSAUDIO_FLAGS_DONT_COMBINE_PINS) {
    pFilterInstance->ulFlags &= ~FLAGS_COMBINE_PINS;
    }
    Status = pFilterInstance->SetDeviceNode(pDeviceNode);
    if(!NT_SUCCESS(Status)) {
    goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
SetDeviceDefault(
    IN PIRP     pIrp,
    IN PKSPROPERTY  pRequest,
    IN OUT PULONG   pData
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(*pData >= MAX_SYSAUDIO_DEFAULT_TYPE) {
    Status = STATUS_INVALID_DEVICE_REQUEST;
    goto exit;
    }
    if(!pFilterInstance->IsChildInstance()) {
    Trap();
    DPF(5, "SetDeviceDefault: FAILED - open pin instances");
    Status = STATUS_INVALID_DEVICE_REQUEST;
    goto exit;
    }
    Status = pFilterInstance->SetShingleInstance(apShingleInstance[*pData]);
    if(!NT_SUCCESS(Status)) {
    goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
GetDeviceInterfaceName(
    IN PIRP pIrp,
    IN PKSPROPERTY pRequest,
    IN OUT PVOID pData
)
{
    PIO_STACK_LOCATION pIrpStack;
    PFILTER_INSTANCE pFilterInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_NODE pDeviceNode;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(*(PULONG)(pRequest + 1) == MAXULONG) {
    pDeviceNode = pFilterInstance->GetDeviceNode();
    if(pDeviceNode == NULL) {
        Trap();
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    }
    else {
    Status = GetDeviceByIndex(*(PULONG)(pRequest + 1), &pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    }
    Assert(pDeviceNode);

    if(pDeviceNode->GetDeviceInterface() == NULL) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Status = PropertyReturnString(
      pIrp,
      pDeviceNode->GetDeviceInterface(),
      (wcslen(pDeviceNode->GetDeviceInterface()) *
        sizeof(WCHAR)) + sizeof(UNICODE_NULL),
      pData);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
SelectGraph(
    IN PIRP pIrp,
    PSYSAUDIO_SELECT_GRAPH pSelectGraph,
    IN OUT PVOID pData
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PTOPOLOGY_NODE pTopologyNode2;
    PTOPOLOGY_NODE pTopologyNode;
    PSTART_NODE pStartNode;
    NTSTATUS Status;

    Status = ::GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit2;
    }
    Assert(pGraphNodeInstance);

    if(pGraphNodeInstance->palstTopologyNodeSelect == NULL ||
      pGraphNodeInstance->palstTopologyNodeNotSelect == NULL) {
        DPF(5, "SelectGraph: palstTopologyNodeSelect == NULL");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit2;
    }
    
    if(pSelectGraph->Flags != 0 || pSelectGraph->Reserved != 0) {
        DPF(5, "SelectGraph: invalid flags or reserved field");
        Status = STATUS_INVALID_PARAMETER;
        goto exit2;
    }
    
    if(pSelectGraph->PinId >= pGraphNodeInstance->cPins) {
        DPF(5, "SelectGraph: invalid pin id");
        Status = STATUS_INVALID_PARAMETER;
        goto exit2;
    }
    
    if(pSelectGraph->NodeId >=
      pGraphNodeInstance->Topology.TopologyNodesCount) {
        DPF(5, "SelectGraph: invalid node id");
        Status = STATUS_INVALID_PARAMETER;
        goto exit2;
    }
#ifdef BREAKS_INTEL
    if(!pGraphNodeInstance->pFilterInstance->IsChildInstance()) {
        Trap();
        DPF(5, "SelectGraph: open pin instances");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit2;
    }
#endif
    pTopologyNode = pGraphNodeInstance->papTopologyNode[pSelectGraph->NodeId];
    Assert(pTopologyNode);
    Assert(pGraphNodeInstance->pGraphNode);
    Assert(pGraphNodeInstance->pGraphNode->pDeviceNode);

    DPF2(90, "SelectGraph GNI %08X TN %08X", pGraphNodeInstance, pTopologyNode);

    if(pTopologyNode->pFilterNode->GetType() & FILTER_TYPE_GLOBAL_SELECT &&
       pGraphNodeInstance->paPinDescriptors[pSelectGraph->PinId].DataFlow ==
       KSPIN_DATAFLOW_IN) {

        PSTART_NODE_INSTANCE pStartNodeInstance;
        PFILTER_INSTANCE pFilterInstance;

        FOR_EACH_LIST_ITEM(
          &pGraphNodeInstance->pGraphNode->pDeviceNode->lstFilterInstance,
          pFilterInstance) {

            if(pFilterInstance->pGraphNodeInstance == NULL) {
                continue;
            }
            Assert(pFilterInstance->pGraphNodeInstance);

            FOR_EACH_LIST_ITEM(
              &pFilterInstance->pGraphNodeInstance->lstStartNodeInstance,
              pStartNodeInstance) {

                if(EnumerateGraphTopology(
                  pStartNodeInstance->pStartNode->GetStartInfo(),
                  (TOP_PFN)FindTopologyNode,
                  pTopologyNode) == STATUS_CONTINUE) {

                    DPF2(5, "SelectGraph: TN %08x not found on SNI %08x",
                        pTopologyNode,
                        pStartNodeInstance);

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    goto exit;
                }
            } END_EACH_LIST_ITEM
        } END_EACH_LIST_ITEM

        Status = pGraphNodeInstance->
            lstTopologyNodeGlobalSelect.AddListDup(pTopologyNode);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }
    else {
        Status = pGraphNodeInstance->
            palstTopologyNodeSelect[pSelectGraph->PinId].AddList(pTopologyNode);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
    }

    //
    // If this is a "not select" type filter like AEC or Mic Array, then all
    // the nodes in the filter have to be remove from the not select list,
    // otherwise IsGraphValid will never find a valid graph.
    //
    if(pTopologyNode->pFilterNode->GetType() & FILTER_TYPE_NOT_SELECT) {

        FOR_EACH_LIST_ITEM(
          &pTopologyNode->pFilterNode->lstTopologyNode,
          pTopologyNode2) {

            pGraphNodeInstance->palstTopologyNodeNotSelect[
                pSelectGraph->PinId].RemoveList(pTopologyNode2);

            DPF2(50, "   Removing %s NodeId %d",\
                pTopologyNode2->pFilterNode->DumpName(),
                pTopologyNode2->ulSysaudioNodeNumber);

        } END_EACH_LIST_ITEM
    }

    //
    // Validate that there is a valid path though the graph after updating
    // the various global, select and not select lists.
    //
    DPF(90, "SelectGraph: Validating Graph");
    FOR_EACH_LIST_ITEM(
      pGraphNodeInstance->aplstStartNode[pSelectGraph->PinId],
      pStartNode) {

        DPF2(90, "   SN: %X %s", 
            pStartNode,
            pStartNode->GetStartInfo()->GetPinInfo()->pFilterNode->DumpName());

        Assert(pStartNode);
        if(pGraphNodeInstance->IsGraphValid(
          pStartNode,
          pSelectGraph->PinId)) {
            Status = STATUS_SUCCESS;
            goto exit;
        }
        else {
            DPF(90, "      IsGraphValid failed");
        }

    } END_EACH_LIST_ITEM
    
    //
    // The select graph failed so restore the not select list back to normal
    //
    if(pTopologyNode->pFilterNode->GetType() & FILTER_TYPE_NOT_SELECT) {

        FOR_EACH_LIST_ITEM(
          &pTopologyNode->pFilterNode->lstTopologyNode,
          pTopologyNode2) {

            pGraphNodeInstance->palstTopologyNodeNotSelect[
                pSelectGraph->PinId].AddList(pTopologyNode2);

        } END_EACH_LIST_ITEM
    }
    
    Status = STATUS_INVALID_DEVICE_REQUEST;
    
exit:
    if(!NT_SUCCESS(Status)) {
        pGraphNodeInstance->
            palstTopologyNodeSelect[pSelectGraph->PinId].RemoveList(pTopologyNode);

        pGraphNodeInstance->
        lstTopologyNodeGlobalSelect.RemoveList(pTopologyNode);
    }
    
exit2:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
GetTopologyConnectionIndex(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PULONG pulIndex
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = ::GetStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
    Trap();
    goto exit;
    }
    Assert(pStartNodeInstance);
    Assert(pStartNodeInstance->pStartNode);
    Assert(pStartNodeInstance->pStartNode->GetStartInfo());
    *pulIndex = pStartNodeInstance->pStartNode->GetStartInfo()->
      ulTopologyConnectionTableIndex;
    pIrp->IoStatus.Information = sizeof(ULONG);
exit:
    return(Status);
}

NTSTATUS
GetPinVolumeNode(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PULONG pulNode
)
{
    PIO_STACK_LOCATION pIrpStack;
    PPIN_INSTANCE pPinInstance;
    NTSTATUS Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pPinInstance = (PPIN_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pPinInstance);

    Status = GetVolumeNodeNumber(pPinInstance, NULL);
    if(!NT_SUCCESS(Status)) {
    Trap();
    goto exit;
    }
    if(pPinInstance->ulVolumeNodeNumber == MAXULONG) {
    DPF(5, "GetPinVolumeNode: no volume node found");
    Status = STATUS_INVALID_DEVICE_REQUEST;
    goto exit;
    }
    *pulNode = pPinInstance->ulVolumeNodeNumber;
    pIrp->IoStatus.Information = sizeof(ULONG);
exit:
    return(Status);
}

NTSTATUS
AddRemoveGfx(
    IN PIRP,
    IN PKSPROPERTY pProperty,
    IN PSYSAUDIO_GFX pSysaudioGfx
)
{
    NTSTATUS Status;

    if(pSysaudioGfx->Enable) {
        Status = AddGfx(pSysaudioGfx);
    }
    else {
        Status = RemoveGfx(pSysaudioGfx);
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\property.h ===
//---------------------------------------------------------------------------
//
//  Module:         property.h
//
//  Description:    Sysaudio Property Definations
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date   Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
SetPreferredDevice(
    IN PIRP pIrp,
    IN PSYSAUDIO_PREFERRED_DEVICE pPreferred,
    IN PULONG pulDevice
);

NTSTATUS
PropertyReturnString(
    IN PIRP pIrp,
    IN PWSTR pwstrString,
    IN ULONG cbString,
    OUT PVOID pData
);

NTSTATUS
GetDeviceCount(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
GetComponentIdProperty(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
GetFriendlyNameProperty(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
GetInstanceDevice(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
SetInstanceDevice(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
SetDeviceDefault(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PULONG   pData
);

NTSTATUS
SetInstanceInfo(
    IN PIRP     Irp,
    IN PSYSAUDIO_INSTANCE_INFO pInstanceInfo,
    IN OUT PVOID    Data
);

NTSTATUS
GetDeviceInterfaceName(
    IN PIRP     Irp,
    IN PKSPROPERTY  Request,
    IN OUT PVOID    Data
);

NTSTATUS
SelectGraph(
    IN PIRP pIrp,
    IN PSYSAUDIO_SELECT_GRAPH pSelectGraph,
    IN OUT PVOID pData
);

NTSTATUS
GetTopologyConnectionIndex(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PULONG pulIndex
);

NTSTATUS
GetPinVolumeNode(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PULONG pulNode
);

NTSTATUS
AddRemoveGfx(
    IN PIRP,
    IN PKSPROPERTY pProperty,
    IN PSYSAUDIO_GFX pSysaudioGfx
);

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\registry.h ===
//---------------------------------------------------------------------------
//
//  Module:   util.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#ifdef UNDER_NT
#define HKEY_CURRENT_USER_ROOT
#else
#define HKEY_CURRENT_USER_ROOT	L"\\Registry\\User\\"
#endif

#define HKEY_LOCAL_MACHINE_ROOT	L"\\Registry\\Machine\\"

#define REGSTR_PATH_MULTIMEDIA \
	HKEY_CURRENT_USER_ROOT \
	L"Software\\Microsoft\\Windows\\CurrentVersion\\Multimedia"

#define REGSTR_PATH_MULTIMEDIA_AUDIO \
	HKEY_CURRENT_USER_ROOT \
	L"Software\\Microsoft\\Multimedia\\Audio"

#define REGSTR_PATH_MULTIMEDIA_AUDIO_FORMATS \
	HKEY_CURRENT_USER_ROOT \
	L"Software\\Microsoft\\Multimedia\\Audio\\WaveFormats"

#define REGSTR_VAL_DEFAULT_PLAYBACK_FORMAT	L"DefaultPlaybackFormat"
#define REGSTR_VAL_DEFAULT_RECORD_FORMAT	L"DefaultFormat"

#define REGSTR_PATH_MULTIMEDIA_AUDIO_DEFAULT_DEVICE \
	HKEY_CURRENT_USER_ROOT \
	L"Software\\Microsoft\\Multimedia\\Sound Mapper"

#define	REGSTR_PATH_MULTIMEDIA_MIDI_DEFAULT_DEVICE \
	HKEY_CURRENT_USER_ROOT \
	L"Software\\Microsoft\\Windows\\CurrentVersion\\Multimedia\\MIDIMap"

#define REGSTR_PATH_MEDIARESOURCES_MIDI \
	HKEY_LOCAL_MACHINE_ROOT \
	L"SYSTEM\\CurrentControlSet\\Control\\MediaResources\\MIDI\\"

#define REGSTR_VAL_DEFAULT_PLAYBACK_DEVICE	L"Playback"
#define REGSTR_VAL_DEFAULT_RECORD_DEVICE	L"Record"
#define REGSTR_VAL_DEFAULT_MIDI_DEVICE		L"CurrentInstrument"

//---------------------------------------------------------------------------
// Global Data
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Data structures
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
GetRegistryDefault(
    PSHINGLE_INSTANCE pShingleInstance,
    PDEVICE_NODE *ppDeviceNode
);

#ifdef REGISTRY_PREFERRED_DEVICE   // this registry code doesn't work under NT

ENUMFUNC
FindFriendlyName(
    PSHINGLE_INSTANCE pShingleInstance,
    PDEVICE_NODE *ppDeviceNode,
    PGRAPH_NODE pGraphNode,
    PWSTR pwstr
);

#endif

#ifndef UNDER_NT		   // this registry code doesn't work under NT

NTSTATUS
GetRegistryPlaybackRecordFormat(
    PWAVEFORMATEX pWaveFormatEx,
    BOOL fPlayback
);

#endif

NTSTATUS
OpenRegistryKey(
    PCWSTR pcwstr,
    PHANDLE pHandle,
    HANDLE hRootDir = NULL
);


NTSTATUS
QueryRegistryValue(
    HANDLE hkey,
    PCWSTR pcwstrValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi
);

//---------------------------------------------------------------------------
//  End of File: registry.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\shi.h ===
//---------------------------------------------------------------------------
//
//  Module:   		shi.h
//
//  Description:	Shingle Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define MAX_SYSAUDIO_DEFAULT_TYPE	(KSPROPERTY_SYSAUDIO_MIXER_DEFAULT+1)

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CShingleInstance : public CObj
{
public:
    CShingleInstance(
	ULONG ulFlags = 0,
	PCWSTR pcwstrRegistryPath = NULL,
	PCWSTR pcwstrRegistryValue = NULL
    );

    ~CShingleInstance();

    static NTSTATUS 
    InitializeShingle(
    );

    static VOID 
    UninitializeShingle(
    );

    static NTSTATUS
    InitializeShingleWorker(
	PVOID pReference1,
	PVOID pReference2
    );

    NTSTATUS 
    Create(
	IN PDEVICE_NODE pDeviceNode,
	IN LPGUID pguidClass
    );

    NTSTATUS
    SetDeviceNode(
	IN PDEVICE_NODE pDeviceNode
    );

    PDEVICE_NODE
    GetDeviceNode(
    )
    {
	return(pDeviceNode);
    };
#ifdef DEBUG
    ENUMFUNC
    Dump(
    );
#endif
private:
    NTSTATUS
    CreateCreateItem(
	IN PCWSTR pcwstrReference
    );

    ENUMFUNC
    DestroyCreateItem(
	IN PKSOBJECT_CREATE_ITEM pCreateItem
    );

    NTSTATUS
    CreateDeviceInterface(
	IN LPGUID pguidClass,
	IN PCWSTR pcwstrReference
    );

    NTSTATUS
    EnableDeviceInterface(
    );

    VOID
    DisableDeviceInterface(
    );

    VOID
    DestroyDeviceInterface(
    );

    ListDataAssertLess<KSOBJECT_CREATE_ITEM> lstCreateItem;
    UNICODE_STRING ustrSymbolicLinkName;
    WCHAR wstrReference[10];
    PDEVICE_NODE pDeviceNode;

public:
    ULONG ulFlags;
    PCWSTR pcwstrRegistryPath;
    PCWSTR pcwstrRegistryValue;
    DefineSignature(0x20494853);		// SHI

} SHINGLE_INSTANCE, *PSHINGLE_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PSHINGLE_INSTANCE apShingleInstance[];

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\registry.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   registry.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//===========================================================================
//===========================================================================

NTSTATUS
GetRegistryDefault(
    PSHINGLE_INSTANCE pShingleInstance,
    PDEVICE_NODE *ppDeviceNode
)
{
#ifdef REGISTRY_PREFERRED_DEVICE
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    PDEVICE_NODE pDeviceNode;
    PGRAPH_NODE pGraphNode;
    PWSTR pwstrString = NULL;
    PWSTR pwstrPath = NULL;
    HANDLE hkey = NULL;
    NTSTATUS Status;

    if(pShingleInstance->pcwstrRegistryPath == NULL ||
       pShingleInstance->pcwstrRegistryValue == NULL) {
	goto exit;
    } 

    Status = OpenRegistryKey(pShingleInstance->pcwstrRegistryPath, &hkey);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    Status = QueryRegistryValue(
      hkey,
      pShingleInstance->pcwstrRegistryValue,
      &pkvfi);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    if(pkvfi->Type != REG_SZ) {
	Trap();
	goto exit;
    }

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

	Status = pDeviceNode->CreateGraphNodes();
	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}

	FOR_EACH_LIST_ITEM(&pDeviceNode->lstGraphNode, pGraphNode) {

	    if((pGraphNode->ulFlags ^ 
	      pShingleInstance->ulFlags) &
	      FLAGS_MIXER_TOPOLOGY) {
		continue;
	    }

	    Status = FindFriendlyName(
	       pShingleInstance,
	       ppDeviceNode,
	       pGraphNode,
	       (PWSTR)(((PUCHAR)pkvfi) + pkvfi->DataOffset));

	    if(Status != STATUS_CONTINUE) {
		goto exit;
	    }

	} END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    delete pkvfi;
    delete pwstrPath;
    delete pwstrString;
    if(hkey != NULL) {
    	ZwClose(hkey);
    }
#endif
    return(STATUS_SUCCESS);
}

#ifdef REGISTRY_PREFERRED_DEVICE   // this registry code doesn't work under NT
				   // and isn't needed any more
ENUMFUNC
FindFriendlyName(
    PSHINGLE_INSTANCE pShingleInstance,
    PDEVICE_NODE *ppDeviceNode,
    PGRAPH_NODE pGraphNode,
    PWSTR pwstr
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSTART_NODE pStartNode;
    ULONG c;

    // if "Use any available device" (registry key == empty string)
    if(wcslen(pwstr) == 0) {
	if((pGraphNode->ulFlags & 
	  pShingleInstance->ulFlags &
	  GN_FLAGS_PREFERRED_MASK) == 0) {
	    Status = STATUS_CONTINUE;
	    goto exit;
	}
	*ppDeviceNode = pGraphNode->pDeviceNode;
	ASSERT(NT_SUCCESS(Status));
	goto exit;
    }
    c = wcslen(pGraphNode->pDeviceNode->GetFriendlyName());

    DPF2(100, "FindFriendlyName: %s c: %d", 
      pGraphNode->pDeviceNode->DumpName(),
      c);

    //
    // The device name from the registry needs to be limited to 32 characters
    // (include NULL) because "pwstr" has been trunicated to this by 
    // wdmaud.sys (the getcap structure passed back to winmm has this limit).  
    //

    if(c >= MAXPNAMELEN) {
	c = MAXPNAMELEN - 1;	// c doesn't include the NULL
    }

    if(wcsncmp(pwstr, pGraphNode->pDeviceNode->GetFriendlyName(), c) == 0) {
	*ppDeviceNode = pGraphNode->pDeviceNode;
	ASSERT(NT_SUCCESS(Status));
	goto exit;
    }

    if(pShingleInstance == 
      apShingleInstance[KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT]) {
	Status = STATUS_CONTINUE;
	goto exit;
    }

    FOR_EACH_LIST_ITEM(&pGraphNode->lstStartNode, pStartNode) {
	PPIN_INFO pPinInfo;

	Assert(pStartNode);
	Assert(pStartNode->pPinNode);
	pPinInfo = pStartNode->pPinNode->pPinInfo;
	Assert(pPinInfo);

	if(pPinInfo->pwstrName == NULL) {
	    continue;
	}
	if(pPinInfo->pguidName != NULL) {
	    Trap();
	    continue;
	}
	if(pPinInfo->pguidCategory == NULL) {
	    Trap();
	    continue;
	}
	if(!IsEqualGUID(
	  &KSCATEGORY_WDMAUD_USE_PIN_NAME,
	  pPinInfo->pguidCategory)) {
	    continue;
	}
	if(wcsncmp(
	  pwstr,
	  pPinInfo->pwstrName,
	  wcslen(pPinInfo->pwstrName)) == 0) {
	    Status = GetRegistryDefault(
	      apShingleInstance[KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT],
	      ppDeviceNode);
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    Status = STATUS_CONTINUE;
exit:
    return(Status);
}

#endif

#ifndef UNDER_NT

NTSTATUS
GetRegistryPlaybackRecordFormat(
    PWAVEFORMATEX pWaveFormatEx,
    BOOL fPlayback
)
{
    PKEY_VALUE_FULL_INFORMATION pkvfiFormatName = NULL;
    PKEY_VALUE_FULL_INFORMATION pkvfiFormat = NULL;
    HANDLE hkeyAudio = NULL;
    HANDLE hkeyFormats = NULL;
    NTSTATUS Status;

    Status = OpenRegistryKey(
      REGSTR_PATH_MULTIMEDIA_AUDIO,
      &hkeyAudio);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    Status = QueryRegistryValue(
      hkeyAudio,
      fPlayback ? 
	REGSTR_VAL_DEFAULT_PLAYBACK_FORMAT : 
	REGSTR_VAL_DEFAULT_RECORD_FORMAT,
      &pkvfiFormatName);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    if(pkvfiFormatName->Type != REG_SZ) {
	Trap();
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }
    Status = OpenRegistryKey(
      REGSTR_PATH_MULTIMEDIA_AUDIO_FORMATS,
      &hkeyFormats);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    Status = QueryRegistryValue(
      hkeyFormats,
      (PCWSTR)(((PUCHAR)pkvfiFormatName) + pkvfiFormatName->DataOffset),
      &pkvfiFormat);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    if(pkvfiFormat->Type != REG_BINARY) {
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }
    RtlCopyMemory(
      pWaveFormatEx,
      ((PUCHAR)pkvfiFormat) + pkvfiFormat->DataOffset,
      min(pkvfiFormat->DataLength, sizeof(WAVEFORMATEX)));

    DPF3(90, "GetRegistryPlayBackRecordFormat: SR: %d CH: %d BPS %d",
      pWaveFormatEx->nSamplesPerSec,
      pWaveFormatEx->nChannels,
      pWaveFormatEx->wBitsPerSample);
exit:
    if(hkeyAudio != NULL) {
	ZwClose(hkeyAudio);
    }
    if(hkeyFormats != NULL) {
	ZwClose(hkeyFormats);
    }
    delete pkvfiFormatName;
    delete pkvfiFormat;
    return(Status);
}

#endif

NTSTATUS
OpenRegistryKey(
    PCWSTR pcwstr,
    PHANDLE pHandle,
    HANDLE hRootDir
)
{
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeDeviceString, pcwstr);

    InitializeObjectAttributes(
      &ObjectAttributes, 
      &UnicodeDeviceString,
      OBJ_CASE_INSENSITIVE,
      hRootDir,
      NULL);

    return(ZwOpenKey(
      pHandle,
      KEY_READ | KEY_NOTIFY | KEY_WRITE,
      &ObjectAttributes));
}

NTSTATUS
QueryRegistryValue(
    HANDLE hkey,
    PCWSTR pcwstrValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi
)
{
    UNICODE_STRING ustrValueName;
    NTSTATUS Status;
    ULONG cbValue;

    *ppkvfi = NULL;
    RtlInitUnicodeString(&ustrValueName, pcwstrValueName);
    Status = ZwQueryValueKey(
      hkey,
      &ustrValueName,
      KeyValueFullInformation,
      NULL,
      0,
      &cbValue);

    if(Status != STATUS_BUFFER_OVERFLOW &&
       Status != STATUS_BUFFER_TOO_SMALL) {
	goto exit;
    }

    *ppkvfi = (PKEY_VALUE_FULL_INFORMATION)new BYTE[cbValue];
    if(*ppkvfi == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }

    Status = ZwQueryValueKey(
      hkey,
      &ustrValueName,
      KeyValueFullInformation,
      *ppkvfi,
      cbValue,
      &cbValue);

    if(!NT_SUCCESS(Status)) {
	delete *ppkvfi;
	*ppkvfi = NULL;
	goto exit;
    }
exit:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\si.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   si.cpp
//
//  Description:
//
//	Start Info Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CStartInfo::Create(
    PSTART_NODE pStartNode,
    PCONNECT_INFO pConnectInfo,
    PGRAPH_PIN_INFO pGraphPinInfo,
    PGRAPH_NODE pGraphNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSTART_INFO pStartInfo;

    Assert(pGraphNode);
    Assert(pStartNode);

    FOR_EACH_LIST_ITEM(&pGraphNode->lstStartInfo, pStartInfo) {

	if(pStartInfo->GetPinInfo() == pStartNode->pPinNode->pPinInfo &&
	   pStartInfo->pConnectInfoHead == pConnectInfo) {

	    ASSERT(pStartInfo->pConnectInfoHead->IsSameGraph(pConnectInfo));
	    pStartInfo->AddRef();
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    pStartInfo = new START_INFO(
      pStartNode->pPinNode->pPinInfo,
      pConnectInfo,
      pGraphPinInfo,
      pGraphNode);

    if(pStartInfo == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    DPF2(80, "CStartInfo::Create %08x GN %08x", pStartInfo, pGraphNode);
exit:
    pStartNode->pStartInfo = pStartInfo;
    return(Status);
}

CStartInfo::CStartInfo(
    PPIN_INFO pPinInfo,
    PCONNECT_INFO pConnectInfo,
    PGRAPH_PIN_INFO pGraphPinInfo,
    PGRAPH_NODE pGraphNode
)
{
    Assert(pGraphPinInfo);
    Assert(pGraphNode);

    this->pPinInfo = pPinInfo;
    this->ulTopologyConnectionTableIndex = MAXULONG;
    this->ulVolumeNodeNumberPre = MAXULONG;
    this->ulVolumeNodeNumberSuperMix = MAXULONG;
    this->ulVolumeNodeNumberPost = MAXULONG;
    this->pGraphPinInfo = pGraphPinInfo;
    pGraphPinInfo->AddRef();
    this->pConnectInfoHead = pConnectInfo;
    pConnectInfo->AddRef();
    AddList(&pGraphNode->lstStartInfo);
    AddRef();
    DPF2(80, "CStartInfo: %08x GN %08x", this, pGraphNode);
}

CStartInfo::~CStartInfo(
)
{
    DPF1(80, "~CStartInfo: %08x", this);
    Assert(this);
    RemoveList();
    pGraphPinInfo->Destroy();
    pConnectInfoHead->Destroy();
}

ENUMFUNC
CStartInfo::CreatePinInfoConnection(
    PVOID pReference
)
{
    PGRAPH_NODE pGraphNode = PGRAPH_NODE(pReference);
    PTOPOLOGY_CONNECTION pTopologyConnection = NULL;
    PCONNECT_INFO pConnectInfo;
    NTSTATUS Status;

    Assert(this);
    Assert(pGraphNode);

    for(pConnectInfo = GetFirstConnectInfo();
	pConnectInfo != NULL;
	pConnectInfo = pConnectInfo->GetNextConnectInfo()) {

	Assert(pConnectInfo);
	Status = ::CreatePinInfoConnection(
	  &pTopologyConnection,
	  NULL,
	  pGraphNode,
	  pConnectInfo->pPinInfoSource,
	  pConnectInfo->pPinInfoSink);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
    Status = STATUS_CONTINUE;
exit:
    return(Status);
}

ENUMFUNC
FindVolumeNode(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN PSTART_INFO pStartInfo
)
{
    PTOPOLOGY_PIN pTopologyPin;

    Assert(pTopologyConnection);

    // Need this check when called from EnumerateGraphTopology
    if(IS_CONNECTION_TYPE(pTopologyConnection, GRAPH)) {
	return(STATUS_DEAD_END);
    }

    if(fToDirection) {
       pTopologyPin = pTopologyConnection->pTopologyPinTo;
    }
    else {
       pTopologyPin = pTopologyConnection->pTopologyPinFrom;
    }

    if(pTopologyPin == NULL) {
	return(STATUS_CONTINUE);
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, &KSNODETYPE_SUM)) {
	return(STATUS_DEAD_END);
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, &KSNODETYPE_MUX)) {
	return(STATUS_DEAD_END);
    }

    if(IsEqualGUID(
      pTopologyPin->pTopologyNode->pguidType, 
      &KSNODETYPE_SUPERMIX)) {

	Assert(pStartInfo);
	pStartInfo->ulVolumeNodeNumberSuperMix =
	  pTopologyPin->pTopologyNode->ulSysaudioNodeNumber;

	DPF1(100, "FindVolumeNode: found supermix node: %02x",
	  pStartInfo->ulVolumeNodeNumberSuperMix);

	return(STATUS_CONTINUE);
    }

    if(IsEqualGUID(
      pTopologyPin->pTopologyNode->pguidType,
      &KSNODETYPE_VOLUME)) {

	Assert(pStartInfo);
	if(pStartInfo->ulVolumeNodeNumberSuperMix != MAXULONG) {

	    // Found a volume node after a super mix
	    pStartInfo->ulVolumeNodeNumberPost =
	      pTopologyPin->pTopologyNode->ulSysaudioNodeNumber;

	    DPF1(100, "FindVolumeNode: found post node: %02x",
	      pStartInfo->ulVolumeNodeNumberPost);

	    return(STATUS_SUCCESS);
	}

	if(pStartInfo->ulVolumeNodeNumberPre == MAXULONG) {

	    // Found first volume node
	    pStartInfo->ulVolumeNodeNumberPre =
	      pTopologyPin->pTopologyNode->ulSysaudioNodeNumber;

	    DPF1(100, "FindVolumeNode: found pre node: %02x",
	      pStartInfo->ulVolumeNodeNumberPre);
	}
    }
    return(STATUS_CONTINUE);
}

ENUMFUNC
CStartInfo::EnumStartInfo(
)
{
    Assert(this);

    DPF3(100, "EnumStartInfo: %08x %d %s", 
      this,
      GetPinInfo()->PinId,
      GetPinInfo()->pFilterNode->DumpName());

    EnumerateGraphTopology(
      this,
      (TOP_PFN)FindVolumeNode,
      this);

    return(STATUS_CONTINUE);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC 
CStartInfo::Dump(
)
{
    PCONNECT_INFO pConnectInfo;

    Assert(this);
    // .sgv or .so
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("SI: %08x cRef %08x PI %08x #%d %s\n",
	  this,
	  cReference,
	  GetPinInfo(),
	  GetPinInfo()->PinId,
	  GetPinInfo()->pFilterNode->DumpName());

	dprintf("    ulTopConnecTableIndex: %08x ulVolumeNodeNumberPre  %08x\n",
	  ulTopologyConnectionTableIndex,
	  ulVolumeNodeNumberPre);

        dprintf("    ulVolumeNodeNumberSup: %08x ulVolumeNodeNumberPost %08x\n",
	  ulVolumeNodeNumberSuperMix,
	  ulVolumeNodeNumberPost);

	pGraphPinInfo->Dump();
    }
    // .sg
    else {
	dprintf("SI: %08x PI %08x P%-2d C%-1d #%d %s\n",
	  this,
	  GetPinInfo(),
	  GetPinInstances()->PossibleCount,
	  GetPinInstances()->CurrentCount,
	  GetPinInfo()->PinId,
	  GetPinInfo()->pFilterNode->DumpName());
    }
    if(ulDebugFlags & DEBUG_FLAGS_GRAPH) {
	for(pConnectInfo = GetFirstConnectInfo();
	    pConnectInfo != NULL;
	    pConnectInfo = pConnectInfo->GetNextConnectInfo()) {

	    pConnectInfo->Dump();
	}
    }
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\shi.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   shi.cpp
//
//  Description:
//
//	Shingle Instance Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

const WCHAR cwstrDefaultDevicePath[] = 
  REGSTR_PATH_MULTIMEDIA_AUDIO_DEFAULT_DEVICE;
const WCHAR cwstrDefaultMidiDevicePath[] = 
  REGSTR_PATH_MULTIMEDIA_MIDI_DEFAULT_DEVICE;

const WCHAR cwstrPlayback[] = REGSTR_VAL_DEFAULT_PLAYBACK_DEVICE;
const WCHAR cwstrRecord[] = REGSTR_VAL_DEFAULT_RECORD_DEVICE;
const WCHAR cwstrMidi[] = REGSTR_VAL_DEFAULT_MIDI_DEVICE;

const WCHAR cwstrFilterTypeName[] = KSSTRING_Filter;
const WCHAR cwstrPlaybackShingleName[] = L"PLAYBACK";
const WCHAR cwstrRecordShingleName[] = L"RECORD";
const WCHAR cwstrMidiShingleName[] = L"MIDI";
const WCHAR cwstrMixerShingleName[] = L"MIXER";
#ifdef DEBUG
const WCHAR cwstrPinsShingleName[] = L"PINS";
#endif

PSHINGLE_INSTANCE apShingleInstance[] = {
    NULL,		// KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT
    NULL,		// KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT
    NULL,		// KSPROPERTY_SYSAUDIO_RECORD_DEFAULT
    NULL,		// KSPROPERTY_SYSAUDIO_MIDI_DEFAULT
    NULL,		// KSPROPERTY_SYSAUDIO_MIXER_DEFAULT
#ifdef DEBUG
    NULL,
#endif
};

ULONG aulFlags[] = {
    FLAGS_COMBINE_PINS | GN_FLAGS_PLAYBACK | GN_FLAGS_RECORD | GN_FLAGS_MIDI,
    FLAGS_COMBINE_PINS | GN_FLAGS_PLAYBACK,
    FLAGS_COMBINE_PINS | GN_FLAGS_RECORD,
    FLAGS_COMBINE_PINS | GN_FLAGS_MIDI,
    FLAGS_MIXER_TOPOLOGY | GN_FLAGS_PLAYBACK | GN_FLAGS_RECORD | GN_FLAGS_MIDI,
#ifdef DEBUG
    GN_FLAGS_PLAYBACK,
#endif
};

PCWSTR apcwstrRegistryPath[] = {
    NULL,
    cwstrDefaultDevicePath,
    cwstrDefaultDevicePath,
    cwstrDefaultMidiDevicePath,
    NULL,
#ifdef DEBUG
    cwstrDefaultDevicePath,
#endif
};

PCWSTR apcwstrRegistryValue[] = {
    NULL,
    cwstrPlayback,
    cwstrRecord,
    cwstrMidi,
    NULL,
#ifdef DEBUG
    cwstrPlayback,
#endif
};

PCWSTR apcwstrReference[] = {
    cwstrFilterTypeName,
    cwstrPlaybackShingleName,
    cwstrRecordShingleName,
    cwstrMidiShingleName,
    cwstrMixerShingleName,
#ifdef DEBUG
    cwstrPinsShingleName,
#endif
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CShingleInstance::InitializeShingle(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    int i;

    for(i = 0; i < SIZEOF_ARRAY(apShingleInstance); i++) {
	apShingleInstance[i] = new SHINGLE_INSTANCE(
	  aulFlags[i],
	  apcwstrRegistryPath[i],
	  apcwstrRegistryValue[i]);

	if(apShingleInstance[i] == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}

	Status = apShingleInstance[i]->CreateCreateItem(apcwstrReference[i]);
	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}
    }
    Status = QueueWorkList(
      CShingleInstance::InitializeShingleWorker,
      NULL,
      NULL);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
	UninitializeShingle();
    }
    return(Status);
}

VOID
CShingleInstance::UninitializeShingle(
)
{
    int i;

    for(i = 0; i < SIZEOF_ARRAY(apShingleInstance); i++) {
	delete apShingleInstance[i];
	apShingleInstance[i] = NULL;
    }
}

NTSTATUS
CShingleInstance::InitializeShingleWorker(
    PVOID pReference1,
    PVOID pReference2
)
{
    NTSTATUS Status;

    Status = apShingleInstance[KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT]->Create(
      NULL,
      (LPGUID)&KSCATEGORY_PREFERRED_WAVEOUT_DEVICE);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = apShingleInstance[KSPROPERTY_SYSAUDIO_RECORD_DEFAULT]->Create(
      NULL,
      (LPGUID)&KSCATEGORY_PREFERRED_WAVEIN_DEVICE);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = apShingleInstance[KSPROPERTY_SYSAUDIO_MIDI_DEFAULT]->Create(
      NULL,
      (LPGUID)&KSCATEGORY_PREFERRED_MIDIOUT_DEVICE);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

CShingleInstance::CShingleInstance(
    ULONG ulFlags,
    PCWSTR pcwstrRegistryPath,
    PCWSTR pcwstrRegistryValue
)
{
    this->ulFlags = ulFlags;
    this->pcwstrRegistryPath = pcwstrRegistryPath;
    this->pcwstrRegistryValue = pcwstrRegistryValue;
}

CShingleInstance::~CShingleInstance(
)
{
    PKSOBJECT_CREATE_ITEM pCreateItem;

    DPF1(60, "~CShingleInstance: %08x", this);
    ASSERT(this != NULL);
    Assert(this);

    DestroyDeviceInterface();
    FOR_EACH_LIST_ITEM(&lstCreateItem, pCreateItem) {
	DestroyCreateItem(pCreateItem);
    } END_EACH_LIST_ITEM
}

NTSTATUS
CShingleInstance::Create(
    IN PDEVICE_NODE pDeviceNode,
    IN LPGUID pguidClass
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    static ULONG cShingles = 0;

    this->pDeviceNode = pDeviceNode;
    swprintf(wstrReference, L"SAD%d", cShingles++);

    Status = CreateCreateItem(wstrReference);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    Status = CreateDeviceInterface(pguidClass, wstrReference);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF2(60, "CShingleInstance::Create: %08x DN: %08x", this, pDeviceNode);
exit:
    return(Status);
}

NTSTATUS
CShingleInstance::SetDeviceNode(
    IN PDEVICE_NODE pDeviceNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DisableDeviceInterface();
    this->pDeviceNode = pDeviceNode;
    Status = EnableDeviceInterface();
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF2(60, "CShingleInstance::SetDeviceNode: %08x DN: %08x",
      this,
      pDeviceNode);
exit:
    return(Status);
}

NTSTATUS
CShingleInstance::CreateCreateItem(
    IN PCWSTR pcwstrReference
)
{
    PKSOBJECT_CREATE_ITEM pCreateItem = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    pCreateItem = new KSOBJECT_CREATE_ITEM;
    if(pCreateItem == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    pCreateItem->Create = CFilterInstance::FilterDispatchCreate;
    pCreateItem->Context = this;

    RtlInitUnicodeString(&pCreateItem->ObjectClass, pcwstrReference);

    Status = KsAllocateObjectCreateItem(
      gpDeviceInstance->pDeviceHeader,
      pCreateItem,
      FALSE,
      NULL);

    if(!NT_SUCCESS(Status)) {
        pCreateItem->ObjectClass.Buffer = NULL;
        goto exit;
    }
    Status = lstCreateItem.AddList(pCreateItem);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    DPF3(60, "CSHI::CreateItem SHI %08x CI %08x %s", 
      this,
      pCreateItem,
      DbgUnicode2Sz((PWSTR)pcwstrReference));
exit:
    if(!NT_SUCCESS(Status)) {
	DestroyCreateItem(pCreateItem);
    }
    return(Status);
}

ENUMFUNC
CShingleInstance::DestroyCreateItem(
    IN PKSOBJECT_CREATE_ITEM pCreateItem
)
{
    if(pCreateItem != NULL) {
	if(pCreateItem->ObjectClass.Buffer != NULL) {

	    KsFreeObjectCreateItem(
	      gpDeviceInstance->pDeviceHeader,
	      &pCreateItem->ObjectClass);
	}
	delete pCreateItem;
    }
    return(STATUS_CONTINUE);
}

NTSTATUS
CShingleInstance::CreateDeviceInterface(
    IN LPGUID pguidClass,
    IN PCWSTR pcwstrReference
)
{
    UNICODE_STRING ustrReference;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(gpDeviceInstance != NULL);
    ASSERT(gpDeviceInstance->pPhysicalDeviceObject != NULL);
    ASSERT(gpDeviceInstance->pDeviceHeader != NULL);
    ASSERT(this->ustrSymbolicLinkName.Buffer == NULL);

    RtlInitUnicodeString(&ustrReference, pcwstrReference);

    Status = IoRegisterDeviceInterface(
       gpDeviceInstance->pPhysicalDeviceObject,
       pguidClass,
       &ustrReference,
       &this->ustrSymbolicLinkName);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = EnableDeviceInterface();
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    DPF3(60, "CSHI::CreateDeviceInterface: %08x %s %s",
      this,
      DbgGuid2Sz(pguidClass),
      DbgUnicode2Sz(this->ustrSymbolicLinkName.Buffer));
exit:
    return(Status);
}

NTSTATUS
CShingleInstance::EnableDeviceInterface(
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR pwstrFriendlyName = L"";
    UNICODE_STRING ustrValueName;
    UNICODE_STRING ustrValue;
    HANDLE hkey = NULL;

    if(this->ustrSymbolicLinkName.Buffer == NULL) {
	ASSERT(NT_SUCCESS(Status));
        goto exit;
    }

    //
    // Put the proxy's CLSID in the new device interface
    //

    Status = IoOpenDeviceInterfaceRegistryKey(
       &this->ustrSymbolicLinkName,
       STANDARD_RIGHTS_ALL,
       &hkey);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    RtlInitUnicodeString(&ustrValueName, L"CLSID");
    RtlInitUnicodeString(&ustrValue, L"{17CCA71B-ECD7-11D0-B908-00A0C9223196}");

    Status = ZwSetValueKey(
      hkey,
      &ustrValueName,
      0, 
      REG_SZ,
      ustrValue.Buffer,
      ustrValue.Length);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    //
    // Set the friendly name into the new device interface
    //

    if(pDeviceNode != NULL) {
	Assert(pDeviceNode);
	if(pDeviceNode->GetFriendlyName() != NULL) {
	    pwstrFriendlyName = pDeviceNode->GetFriendlyName();
	}
	else {
	    DPF(5, "CSHI::EnableDeviceInterface no friendly name");
	}
    }

    RtlInitUnicodeString(&ustrValueName, L"FriendlyName");

    Status = ZwSetValueKey(
      hkey,
      &ustrValueName,
      0, 
      REG_SZ,
      pwstrFriendlyName,
      (wcslen(pwstrFriendlyName) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    Status = IoSetDeviceInterfaceState(&this->ustrSymbolicLinkName, TRUE);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    DPF2(60, "CSHI::EnableDeviceInterface: %08x %s",
      this,
      DbgUnicode2Sz(this->ustrSymbolicLinkName.Buffer));
exit:
    if(hkey != NULL) {
	ZwClose(hkey);
    }
    return(Status);
}

VOID
CShingleInstance::DisableDeviceInterface(
)
{
    Assert(this);
    DPF1(60, "CSHI::DisableDeviceInterface %08x", this);
    if(this->ustrSymbolicLinkName.Buffer != NULL) {
	DPF1(60, "CSHI::DisableDeviceInterface %s", 
	  DbgUnicode2Sz(this->ustrSymbolicLinkName.Buffer));
	IoSetDeviceInterfaceState(&this->ustrSymbolicLinkName, FALSE);
    }
}

VOID
CShingleInstance::DestroyDeviceInterface(
)
{
    DisableDeviceInterface();
    RtlFreeUnicodeString(&this->ustrSymbolicLinkName);
    this->ustrSymbolicLinkName.Buffer = NULL;
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CShingleInstance::Dump()
{
    PKSOBJECT_CREATE_ITEM pCreateItem;

    dprintf("SHI: %08x DN %08x ulFlags %08x\n", this, pDeviceNode, ulFlags);
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("     lstCreateItem:");
	FOR_EACH_LIST_ITEM(&lstCreateItem, pCreateItem) {
	    dprintf(" %08x", pCreateItem);
	} END_EACH_LIST_ITEM
	dprintf("\n");
	dprintf("     %s\n", DbgUnicode2Sz(ustrSymbolicLinkName.Buffer));
	dprintf("     %s\n", DbgUnicode2Sz((PWSTR)pcwstrRegistryPath));
	dprintf("     %s\n", DbgUnicode2Sz((PWSTR)pcwstrRegistryValue));
    }
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\si.h ===
//---------------------------------------------------------------------------
//
//  Module:   		si.h
//
//  Description:	Start Info Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Class
//---------------------------------------------------------------------------

typedef class CStartInfo : public CListDoubleItem
{
private:
    CStartInfo(
	PPIN_INFO pPinInfo,
	PCONNECT_INFO pConnectInfo,
	PGRAPH_PIN_INFO pGraphPinInfo,
	PGRAPH_NODE pGraphNode
    );

    ~CStartInfo(
    );

public:
    static NTSTATUS
    Create(
	PSTART_NODE pStartNode,
	PCONNECT_INFO pConnectInfo,
	PGRAPH_PIN_INFO pGraphPinInfo,
	PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ASSERT(cReference > 0);

	    if(--cReference == 0) {
		delete this;
	    }
	}
	return(STATUS_CONTINUE);
    };

    VOID 
    AddRef(
    )
    {
	if(this != NULL) {
	    Assert(this);
	    ++cReference;
	}
    };

    PPIN_INFO
    GetPinInfo(
    )
    {
	Assert(this);
	return(pPinInfo);
    };

    PGRAPH_PIN_INFO
    GetGraphPinInfo(
    )
    {
	Assert(this);
	return(pGraphPinInfo);
    };

    PKSPIN_CINSTANCES
    GetPinInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->GetPinInstances());
    };

    VOID
    AddPinInstance(
    )
    {
	Assert(this);
	if(pPinInfo == pGraphPinInfo->GetPinInfo()) {
	    pGraphPinInfo->AddPinInstance();
	}
    };

    VOID
    RemovePinInstance(
    )
    {
	Assert(this);
	if(pPinInfo == pGraphPinInfo->GetPinInfo()) {
	    pGraphPinInfo->RemovePinInstance();
	}
    };

    BOOL
    IsPinInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->IsPinInstances());
    };

    BOOL
    IsPossibleInstances(
    )
    {
	Assert(this);
	return(pGraphPinInfo->IsPossibleInstances());
    };

    PCONNECT_INFO
    GetFirstConnectInfo(
    )
    {
	return(pConnectInfoHead);
    };

    ENUMFUNC
    CreatePinInfoConnection(
	PVOID pGraphNode
    );

    ENUMFUNC
    EnumStartInfo(
    );

#ifdef DEBUG
    ENUMFUNC
    Dump(
    );
#endif

private:
    LONG cReference;
    PPIN_INFO pPinInfo;
    PCONNECT_INFO pConnectInfoHead;
    PGRAPH_PIN_INFO pGraphPinInfo;
public:
    ULONG ulTopologyConnectionTableIndex;
    ULONG ulVolumeNodeNumberPre;
    ULONG ulVolumeNodeNumberSuperMix;
    ULONG ulVolumeNodeNumberPost;
    DefineSignature(0x20204953);				// SI

} START_INFO, *PSTART_INFO;

//---------------------------------------------------------------------------

typedef ListDouble<START_INFO> LIST_START_INFO;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\sn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		sn.h
//
//  Description:	start node classes
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

#define STARTNODE_FLAGS_SECONDPASS    0x01

#define STARTNODE_SPECIALFLAG_NONE    0

// StartNode must connect with the same format bottom up.
// Use this information to optimize graph building.
#define STARTNODE_SPECIALFLAG_STRICT  0x00000001 

// StartNode contains Aec filter.
#define STARTNODE_SPECIALFLAG_AEC     0x00000002

typedef class CStartNode : public CListDoubleItem
{
    friend class CStartInfo;
private:
    CStartNode(
        PPIN_NODE pPinNode,
        PCONNECT_NODE pConnectNode,
        ULONG ulOverhead,
        PGRAPH_NODE pGraphNode
    );

    ~CStartNode(
    );

public:
    static NTSTATUS
    Create(
        PPIN_NODE pPinNode,
        PCONNECT_NODE pConnectNode,
        PGRAPH_PIN_INFO pGraphPinInfo,
        ULONG ulFlagsCurrent,
        ULONG ulOverhead,
        PGRAPH_NODE pGraphNode
    );

    ENUMFUNC
    Destroy()
    {
        Assert(this);
        delete this;
        return(STATUS_CONTINUE);
    };

    PGRAPH_PIN_INFO
    GetGraphPinInfo(
    )
    {
        Assert(this);
        return(pStartInfo->GetGraphPinInfo());
    };

    ENUMFUNC
    RemoveBypassPaths(
        PVOID pGraphNode
    );

    ENUMFUNC
    RemoveConnectedStartNode(
        PVOID pReference
    );

    PKSPIN_CINSTANCES
    GetPinInstances(
    )
    {
        Assert(this);
        return(pStartInfo->GetPinInstances());
    };

    VOID
    AddPinInstance(
    )
    {
        Assert(this);
        pStartInfo->AddPinInstance();
    };

    VOID
    RemovePinInstance(
    )
    {
        Assert(this);
        pStartInfo->RemovePinInstance();
    };

    BOOL
    IsPinInstances(
    )
    {
        Assert(this);
        return(pStartInfo->IsPinInstances());
    };

    BOOL
    IsPossibleInstances(
    )
    {
        Assert(this);
        return(pStartInfo->IsPossibleInstances());
    };

    PCONNECT_NODE
    GetFirstConnectNode(
    )
    {
        return(pConnectNodeHead);
    };

    PSTART_INFO
    GetStartInfo(
    )
    {
        Assert(this);
        return(pStartInfo);
    };

    BOOL
    IsCaptureFormatStrict(
    )
    {
        return ulSpecialFlags & STARTNODE_SPECIALFLAG_STRICT;
    };

    BOOL
    IsAecIncluded(
    )
    {
        return ulSpecialFlags & STARTNODE_SPECIALFLAG_AEC;
    };

#ifdef DEBUG
    VOID
    DumpFilters(
    );

    ENUMFUNC Dump();
#endif

private:
    void 
    SetSpecialFlags();

private:
    PSTART_INFO pStartInfo;
    PCONNECT_NODE pConnectNodeHead;
    ULONG ulSpecialFlags;    
public:
    BOOL fRender;
    ULONG ulOverhead;
    ULONG ulFlags;
    PPIN_NODE pPinNode;
    DefineSignature(0x20204e53);			// SN

} START_NODE, *PSTART_NODE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<START_NODE> LIST_START_NODE;

//---------------------------------------------------------------------------

typedef ListData<START_NODE> LIST_DATA_START_NODE, *PLIST_DATA_START_NODE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\sni.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   sni.cpp
//
//  Description:
//
//	Start Node Instance
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

WAVEFORMATEX aWaveFormatEx[] = {
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       44100,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       44100,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       44100,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       44100,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       48000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       48000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       48000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       48000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       32000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       32000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       32000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       32000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       22050,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       22050,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       22050,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       22050,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       16000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       16000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       16000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       16000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       11025,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       11025,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       11025,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       11025,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       8000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       8000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       16,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       2,						// nChannels
       8000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
   {
       WAVE_FORMAT_PCM,					// wFormatTag
       1,						// nChannels
       8000,						// nSamplesPerSec
       0,						// nAvgBytesPerSec
       0,						// nBlockAlign
       8,						// wBitsPerSample
       0,						// cbSize
   },
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CStartNodeInstance::Create(
    PPIN_INSTANCE pPinInstance,
    PSTART_NODE pStartNode,
    PKSPIN_CONNECT pPinConnect,
    PWAVEFORMATEX pWaveFormatExRequested,
    PWAVEFORMATEX pWaveFormatExRegistry
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance = NULL;
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    Assert(pPinInstance);
    Assert(pStartNode);
    Assert(pStartNode->pPinNode);

    DPF3(90, "CSNI::Create SN %08x #%d %s", 
      pStartNode,
      pStartNode->pPinNode->pPinInfo->PinId,
      pStartNode->pPinNode->pPinInfo->pFilterNode->DumpName());

#ifdef DEBUG
    DumpDataRange(95, (PKSDATARANGE_AUDIO)pStartNode->pPinNode->pDataRange);
#endif

    if(!CompareIdentifier(
      pStartNode->pPinNode->pMedium,
      &pPinConnect->Medium)) {
        Trap();
        DPF1(90, "CSNI::Create: Medium %08X", pStartNode);
        ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
        goto exit;
    }

    if(!CompareIdentifier(
      pStartNode->pPinNode->pInterface,
      &pPinConnect->Interface)) {
        DPF1(90, "CSNI::Create: Interface %08X", pStartNode);
        ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
        goto exit;
    }

    if(!CompareDataRangeGuids(
      pStartNode->pPinNode->pDataRange,
      (PKSDATARANGE)(pPinConnect + 1))) {
        DPF1(90, "CSNI::Create: DataRange GUID %08X", pStartNode);
        ASSERT(Status == STATUS_INVALID_DEVICE_REQUEST);
        goto exit;
    }

    //
    // VOICE MANAGEMENT and HW ACCELARATION
    // For HW accelarated pins we are not relying on local sysaudio 
    // instance counts. PinCreate request will be sent down to the driver.
    // It is upto the driver to reject the request based on its capabilities.
    //
    if ((pStartNode->pPinNode->pPinInfo->pFilterNode->GetType() & FILTER_TYPE_RENDERER) &&
        (KSPIN_DATAFLOW_IN == pStartNode->pPinNode->pPinInfo->DataFlow) &&
        (KSPIN_COMMUNICATION_SINK == pStartNode->pPinNode->pPinInfo->Communication)) {

        DPF(20,"StartInfo::IsPinInstances return TRUE for HW");
    } 
    else {
        if(!pStartNode->IsPinInstances()) {
            DPF1(90, "CSNI::Create: no instances SN %08X", pStartNode);
            Status = STATUS_DEVICE_BUSY;
            goto exit;
        }
    }
 
    pStartNodeInstance = new START_NODE_INSTANCE(pPinInstance, pStartNode);
    if(pStartNodeInstance == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

#ifndef UNDER_NT
    //
    // Try the format from the registry
    //

    if(pWaveFormatExRegistry != NULL) {
        DPF3(90, "CSNI::Create: Registry SR %d CH %d BPS %d",
          pWaveFormatExRegistry->nSamplesPerSec,
          pWaveFormatExRegistry->nChannels,
          pWaveFormatExRegistry->wBitsPerSample);

        Status = pStartNodeInstance->Connect(
          pPinInstance->pFilterInstance->GetDeviceNode(),
          pPinConnect,
          pWaveFormatExRegistry,
          NULL);
    }
#endif

    //
    // If capture pin, try some intelligent variations of requested format
    //

    if(!NT_SUCCESS(Status) &&
        pWaveFormatExRequested != NULL &&
        pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {

        DPF(90, "CSNI::Create: IntelligentConnect");

        Status = pStartNodeInstance->IntelligentConnect(
                    pPinInstance->pFilterInstance->GetDeviceNode(),
                    pPinConnect,
                    pWaveFormatExRequested);

        //
        // If the graph contains only splitter and capturer, only the 
        // requested format can succeed.
        // So exit here.
        //
        if (pStartNodeInstance->pStartNode->IsCaptureFormatStrict()) {
            DPF1(50, "CSNI::Create: CaptureFormatStrict Bailing Out: Status %X", Status);
            goto exit;           
        }
    }

    //
    // If capture pin and if aec is included, negotiate format between
    // aec and capture device.
    //
    if(!NT_SUCCESS(Status) &&
        pStartNode->IsAecIncluded() &&
        pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {

        PKSPIN_CONNECT pPinConnectDirect = NULL;

        DPF(90, "CSNI::Create: AecConnection");

        Status = pStartNodeInstance->AecConnectionFormat(
                    pPinInstance->pFilterInstance->GetDeviceNode(),
                    &pPinConnectDirect);

        //
        // Try mono/stereo formats first.
        //
        if (NT_SUCCESS(Status)) {
            for (WORD i = 1; i <= 2; i++) {
                ModifyPinConnect(pPinConnectDirect, i);

                Status = pStartNodeInstance->Connect(
                  pPinInstance->pFilterInstance->GetDeviceNode(),
                  pPinConnect,
                  NULL,
                  pPinConnectDirect);
                if (NT_SUCCESS(Status)) {
                    break;
                }
            }
        }

        if (pPinConnectDirect) {
            delete pPinConnectDirect;
        }
    }

    
    //
    // Try pin data intersection
    //

    if(!NT_SUCCESS(Status)) {
        DPF(90, "CSNI::Create: Data Intersection");

        Status = pStartNodeInstance->Connect(
          pPinInstance->pFilterInstance->GetDeviceNode(),
          pPinConnect,
          NULL,
          NULL);
    }

    if(!NT_SUCCESS(Status)) {
        int i;

        //
        // Try each waveformatex limit until success
        //

        for(i = 0; i < SIZEOF_ARRAY(aWaveFormatEx); i++) {

            DPF3(90, "CSNI::Create: Array SR %d CH %d BPS %d",
              aWaveFormatEx[i].nSamplesPerSec,
              aWaveFormatEx[i].nChannels,
              aWaveFormatEx[i].wBitsPerSample);

            Status = pStartNodeInstance->Connect(
              pPinInstance->pFilterInstance->GetDeviceNode(),
              pPinConnect,
              &aWaveFormatEx[i],
              NULL);

            if(NT_SUCCESS(Status)) {
                break;
            }
        }
    }

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = pStartNodeInstance->CreateTopologyTable(
      pPinInstance->pFilterInstance->pGraphNodeInstance);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    ASSERT(pStartNodeInstance->CurrentState == KSSTATE_STOP);
#ifdef DEBUG
    pStartNodeInstance->pPinConnect = (PKSPIN_CONNECT)
      new BYTE[sizeof(KSPIN_CONNECT) +
        ((PKSDATARANGE)(pPinConnect + 1))->FormatSize];

    if(pStartNodeInstance->pPinConnect != NULL) {
        memcpy(
            pStartNodeInstance->pPinConnect,
            pPinConnect,
            sizeof(KSPIN_CONNECT) +
            ((PKSDATARANGE)(pPinConnect + 1))->FormatSize);
    }
#endif
    DPF1(90, "CSNI::Create: SUCCESS %08x", pStartNodeInstance);
exit:
    if(!NT_SUCCESS(Status)) {
        DPF1(90, "CSNI::Create: FAIL %08x", Status);
        delete pStartNodeInstance;
    }
    return(Status);
}

CStartNodeInstance::CStartNodeInstance(
    PPIN_INSTANCE pPinInstance,
    PSTART_NODE pStartNode
)
{
    this->pStartNode = pStartNode;
    pStartNode->AddPinInstance();
    this->pPinInstance = pPinInstance;
    pPinInstance->pStartNodeInstance = this;
    AddList(
      &pPinInstance->pFilterInstance->pGraphNodeInstance->lstStartNodeInstance);
}

CStartNodeInstance::~CStartNodeInstance(
)
{
    PINSTANCE pInstance;

    ASSERT(this != NULL);
    Assert(this);
    Assert(pPinInstance);
    DPF1(95, "~CSNI: %08x", this);
    RemoveList();

    SetState(KSSTATE_STOP, SETSTATE_FLAG_IGNORE_ERROR);
    pStartNode->RemovePinInstance();

    pPinNodeInstance->Destroy();	// also see CSNI::CleanUp
    pFilterNodeInstance->Destroy();	//

    delete papFileObjectTopologyTable;
    delete pVirtualNodeData;
#ifdef DEBUG
    delete pPinConnect;
#endif
    pPinInstance->pStartNodeInstance = NULL;
    pPinInstance->ParentInstance.Invalidate();
}

VOID
CStartNodeInstance::CleanUp(
)
{
    Assert(this);
    ASSERT(papFileObjectTopologyTable == NULL);
    ASSERT(pVirtualNodeData == NULL);
    ASSERT(CurrentState == KSSTATE_STOP);

    pPinNodeInstance->Destroy();
    pPinNodeInstance = NULL;
    pFilterNodeInstance->Destroy();
    pFilterNodeInstance = NULL;
    lstConnectNodeInstance.DestroyList();
}

NTSTATUS
CStartNodeInstance::IntelligentConnect(
    PDEVICE_NODE pDeviceNode,
    PKSPIN_CONNECT pPinConnect,
    PWAVEFORMATEX pWaveFormatEx
)
{
    PWAVEFORMATEXTENSIBLE pWaveFormatExtensible;
    NTSTATUS        Status;
    BOOL            Continue;
    WORD            NumChannels, BitWidth;
    PBYTE           pWaveFormat = NULL;
    ULONG           RegionAllocSize, RegionCopySize;
    BOOL            IsFloat = FALSE;
    WORD            MaxBitWidth, MinBitWidth, MaxChannels, MinChannels;

    //
    // First copy the user requested format into a local structure
    //  (because we will tamper it later for different params)
    //
    if (pWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM) {
        RegionAllocSize = sizeof(WAVEFORMATEX);
        RegionCopySize = sizeof(PCMWAVEFORMAT);
    }
    else {
        RegionAllocSize = sizeof(WAVEFORMATEX) + pWaveFormatEx->cbSize;
        RegionCopySize = RegionAllocSize;
    }

    pWaveFormat = new(BYTE[RegionAllocSize]);
    if (!pWaveFormat) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlCopyMemory(pWaveFormat, pWaveFormatEx, RegionCopySize);

    //
    // cast for convenient access
    //
    pWaveFormatExtensible = (PWAVEFORMATEXTENSIBLE) pWaveFormat;
    if (pWaveFormatExtensible->Format.wFormatTag == WAVE_FORMAT_PCM) {
        pWaveFormatExtensible->Format.cbSize = 0;
    }

    DPF3(90, "CSNI::Create: Client SR %d CH %d BPS %d",
             pWaveFormatExtensible->Format.nSamplesPerSec,
             pWaveFormatExtensible->Format.nChannels,
             pWaveFormatExtensible->Format.wBitsPerSample);

    //
    // and try the requested format first
    //
    Status = this->Connect(
        pDeviceNode, 
        pPinConnect, 
        (PWAVEFORMATEX)pWaveFormatEx, 
        NULL);

    //
    // If the graph contains only splitter and capturer, only the 
    // requested format can succeed.
    // So exit here.
    //
    if (pStartNode->IsCaptureFormatStrict()) {
        goto exit;           
    }
    

    if (pWaveFormatExtensible->Format.wFormatTag == WAVE_FORMAT_IEEE_FLOAT) {
        IsFloat = TRUE;
    }

    if (pWaveFormatExtensible->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
        if (IsEqualGUID(&pWaveFormatExtensible->SubFormat,&KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)) {
            IsFloat = TRUE;
        }
    }

    if (IsFloat == FALSE) {
        if (pWaveFormatExtensible->Format.wFormatTag != WAVE_FORMAT_PCM) {
            if (pWaveFormatExtensible->Format.wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
                goto exit;
            }
            else {
                if (!IsEqualGUID(&pWaveFormatExtensible->SubFormat,&KSDATAFORMAT_SUBTYPE_PCM)) {
                    goto exit;
                }
            }
        }
        MaxBitWidth = (pWaveFormatExtensible->Format.wBitsPerSample>16)?pWaveFormatExtensible->Format.wBitsPerSample:16;
        MinBitWidth = 8;
    }
    else {
        MaxBitWidth = MinBitWidth = pWaveFormatEx->wBitsPerSample;
    }

    //
    // MaxChannels = (pWaveFormatExtensible->nChannels > 2) ? pWaveFormatExtensible->nChannels:2;
    // We can do this, what would be the channle mask for WaveFormatExtensible?
    //
    MaxChannels = 2;
    MinChannels = 1;

    //
    // If that failed with the same sample rate try different
    // combinations of numchannels & bitwidth
    //
    // Tries 4 combinations of STEREO/MONO & 8/16 bits
    // More intelligence can be built based upon device capability
    // (also does not check whether we tried a combination earlier)
    //
    if (!NT_SUCCESS(Status)) {
        Continue = TRUE;
        for (NumChannels = MaxChannels; (NumChannels >= MinChannels) && Continue; NumChannels--) {
            for (BitWidth = MaxBitWidth;
                 (BitWidth >= MinBitWidth) && Continue;
                 BitWidth=(BitWidth%8)?((BitWidth/8)*8):(BitWidth-8)) {

                pWaveFormatExtensible->Format.nChannels = NumChannels;
                pWaveFormatExtensible->Format.wBitsPerSample = BitWidth;
                pWaveFormatExtensible->Format.nBlockAlign = (NumChannels * BitWidth)/8;

                pWaveFormatExtensible->Format.nAvgBytesPerSec = pWaveFormatExtensible->Format.nSamplesPerSec *
                                                                pWaveFormatExtensible->Format.nBlockAlign;
                if (pWaveFormatExtensible->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
                    pWaveFormatExtensible->Samples.wValidBitsPerSample = BitWidth;
                    if (NumChannels == 1) {
                        pWaveFormatExtensible->dwChannelMask = SPEAKER_FRONT_CENTER;
                    }
                    else {
                        pWaveFormatExtensible->dwChannelMask = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
                    }
                }

                DPF3(90, "CSNI::Create: Client SR %d CH %d BPS %d",
                         pWaveFormatExtensible->Format.nSamplesPerSec,
                         pWaveFormatExtensible->Format.nChannels,
                         pWaveFormatExtensible->Format.wBitsPerSample);

                Status = this->Connect(pDeviceNode,
                                       pPinConnect,
                                       (PWAVEFORMATEX)pWaveFormatExtensible,
                                       NULL);
                if (NT_SUCCESS(Status)) {
                    Continue = FALSE;
                }
            }
        }
    }
exit:
    delete [] pWaveFormat;
    return(Status);
}

NTSTATUS
CStartNodeInstance::AecConnectionFormat(
    PDEVICE_NODE pDeviceNode,
    PKSPIN_CONNECT *ppPinConnect)
{
    PCLIST_ITEM            pListItem;
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    PCONNECT_NODE_INSTANCE pBottomConnection;
    PCONNECT_NODE_INSTANCE pAecConnection = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    *ppPinConnect = NULL;
    
    Status = CConnectNodeInstance::Create(this, pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Get Aec Source and Capture Sink pins.
    //

    pListItem = lstConnectNodeInstance.GetListLast();
    pBottomConnection = lstConnectNodeInstance.GetListData(pListItem);
    
    FOR_EACH_LIST_ITEM_BACKWARD(&lstConnectNodeInstance, pConnectNodeInstance) {
        if (pConnectNodeInstance->pConnectNode->pPinNodeSource->
            pPinInfo->pFilterNode->GetType() & FILTER_TYPE_AEC) {
                
            pAecConnection = pConnectNodeInstance;
            break;
        }
    } END_EACH_LIST_ITEM

    if (NULL == pAecConnection || NULL == pBottomConnection) {
        DPF(5, "CSNI::AecConnectionFormat: Cannot find Aec or Capture");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    DPF3(20, "Aec : %X %d %s",
        pAecConnection,
        pAecConnection->pConnectNode->pPinNodeSource->pPinInfo->PinId,
        pAecConnection->pConnectNode->pPinNodeSource->pPinInfo->pFilterNode->DumpName());

    DPF3(20, "Capture : %X %d %s",
        pBottomConnection,
        pBottomConnection->pConnectNode->pPinNodeSink->pPinInfo->PinId,
        pBottomConnection->pConnectNode->pPinNodeSink->pPinInfo->pFilterNode->DumpName());

    //
    // Find the intersection between kmixer source and capture sink.
    //
    Status = CreatePinIntersection(
        ppPinConnect,
        pBottomConnection->pConnectNode->pPinNodeSink,
        pAecConnection->pConnectNode->pPinNodeSource,
        pBottomConnection->pFilterNodeInstanceSink,
        pAecConnection->pFilterNodeInstanceSource);

    if(!NT_SUCCESS(Status)) {
        DPF(5, "CSNI::AecConnectionFormat: No intersection found");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

#ifdef DEBUG
    DumpDataFormat(20, (PKSDATAFORMAT) (*ppPinConnect + 1));
#endif

exit:
    if(!NT_SUCCESS(Status)) {
        DPF2(90, "CSNI::AecConnectionFormat: %08x FAIL %08x", this, Status);

        if (*ppPinConnect) {
            ExFreePool(*ppPinConnect);
            *ppPinConnect = NULL;
        }
    }

    CleanUp();
    return(Status);    
} // AecConnectionFormat


NTSTATUS
CStartNodeInstance::Connect(
    PDEVICE_NODE pDeviceNode,
    PKSPIN_CONNECT pPinConnect,
    PWAVEFORMATEX pWaveFormatEx,
    PKSPIN_CONNECT pPinConnectDirect
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = CConnectNodeInstance::Create(this, pDeviceNode);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Do all the bottom up connecting
    //

    FOR_EACH_LIST_ITEM_BACKWARD(&lstConnectNodeInstance, pConnectNodeInstance) {

        if(!pConnectNodeInstance->IsTopDown()) {

            //
            // For Aec sink pin do intersection, no matter what the format is.
            //
            if (pConnectNodeInstance->pFilterNodeInstanceSink->
                pFilterNode->GetType() & FILTER_TYPE_AEC) {
                
                Status = pConnectNodeInstance->Connect(NULL, NULL);
            }
            else {
                Status = pConnectNodeInstance->Connect(
                    pWaveFormatEx,
                    pPinConnectDirect);
            }

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }
    } END_EACH_LIST_ITEM

    pPinConnect->PinToHandle = NULL;

    Status = CPinNodeInstance::Create(
      &pPinNodeInstance,
      pFilterNodeInstance,
      pStartNode->pPinNode,
      pPinConnect,
      (pStartNode->fRender)
#ifdef FIX_SOUND_LEAK
     ,lstConnectNodeInstance.IsLstEmpty()
#endif
      );

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // Do all the top down connecting
    //

    FOR_EACH_LIST_ITEM(&lstConnectNodeInstance, pConnectNodeInstance) {

        if(pConnectNodeInstance->IsTopDown()) {
            //
            // Rely on DataIntersection for all Topdown connections
            //
            Status = pConnectNodeInstance->Connect(NULL, NULL);
            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
        }

    } END_EACH_LIST_ITEM

    DPF1(90, "CSNI::Connect: %08x SUCCESS", this);
exit:
    if(!NT_SUCCESS(Status)) {
        DPF2(90, "CSNI::Connect: %08x FAIL %08x", this, Status);
        CleanUp();
    }
    return(Status);
}

NTSTATUS
CStartNodeInstance::CreateTopologyTable(
    PGRAPH_NODE_INSTANCE pGraphNodeInstance
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNode = NULL;
    ULONG n;

    Assert(this);
    Assert(pGraphNodeInstance);

    if(pGraphNodeInstance->Topology.TopologyNodesCount != 0) {

	ASSERT(papFileObjectTopologyTable == NULL);

	papFileObjectTopologyTable =
	   new PFILE_OBJECT[pGraphNodeInstance->Topology.TopologyNodesCount];

	if(papFileObjectTopologyTable == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}
    }
    for(n = 0; n < pGraphNodeInstance->Topology.TopologyNodesCount; n++) {

	// if filter node is the same as last time, no need to search
        if(pFilterNode == pGraphNodeInstance->papTopologyNode[n]->pFilterNode) {
	    ASSERT(n != 0);
	    ASSERT(pFilterNode != NULL);
	    papFileObjectTopologyTable[n] = papFileObjectTopologyTable[n - 1];
	    continue;
	}
        pFilterNode = pGraphNodeInstance->papTopologyNode[n]->pFilterNode;
	Assert(pFilterNode);
	//
	// Now find a filter instance and a pin instance in this graph
	// instance for this filter node.
	//
	Assert(pPinNodeInstance);

	if(pPinNodeInstance->pPinNode->pPinInfo->pFilterNode == pFilterNode) {
	    papFileObjectTopologyTable[n] = pPinNodeInstance->pFileObject;
	    continue;
	}

	FOR_EACH_LIST_ITEM_BACKWARD(		// Top Down
	  &lstConnectNodeInstance,
	  pConnectNodeInstance) {

	    Assert(pConnectNodeInstance);
	    Assert(pConnectNodeInstance->pPinNodeInstanceSink);
	    Assert(pConnectNodeInstance->pPinNodeInstanceSink->pPinNode);
	    Assert(
	      pConnectNodeInstance->pPinNodeInstanceSink->pPinNode->pPinInfo);

	    //
	    // Use the sink pin handle for now. This should be fine until 
	    // Sysaudio supports a spliter.
	    //

	    if(pConnectNodeInstance->pPinNodeInstanceSink->
	      pPinNode->pPinInfo->pFilterNode == pFilterNode) {
	        papFileObjectTopologyTable[n] = 
		  pConnectNodeInstance->pPinNodeInstanceSink->pFileObject;
		break;
	    }

	} END_EACH_LIST_ITEM
    }
    DPF1(90, "CreatePinInstanceTopologyTable PI: %08x",
      papFileObjectTopologyTable);
exit:
    return(Status);
}

NTSTATUS
CStartNodeInstance::GetTopologyNodeFileObject(
    OUT PFILE_OBJECT *ppFileObject,
    IN ULONG NodeId
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    if(this == NULL) {
	Status = STATUS_NO_SUCH_DEVICE;
	goto exit;
    }
    Assert(this);
    ASSERT(pPinInstance != NULL);

    Status = pPinInstance->pFilterInstance->GetGraphNodeInstance(
      &pGraphNodeInstance);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    Assert(pGraphNodeInstance);

    if(NodeId >= pGraphNodeInstance->cTopologyNodes) {
	Trap();
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }

    if(papFileObjectTopologyTable == NULL ||
       papFileObjectTopologyTable[NodeId] == NULL) {

	Status = pGraphNodeInstance->GetTopologyNodeFileObject(
	  ppFileObject,
          NodeId);

	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}
    }
    else {
	*ppFileObject = papFileObjectTopologyTable[NodeId];
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CStartNodeInstance::SetState(
    KSSTATE NewState,
    ULONG ulFlags
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG State;

    Assert(this);

    if(NewState < KSSTATE_STOP || NewState >= MAX_STATES) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if(CurrentState == NewState) {
        ASSERT(NT_SUCCESS(Status));
        goto exit;
    }
    if(CurrentState < NewState) {
        for(State = CurrentState + 1; State <= NewState; State++) {

            Status = SetStateTopDown(
              (KSSTATE)State,
              CurrentState,
              ulFlags | SETSTATE_FLAG_SINK | SETSTATE_FLAG_SOURCE);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
            CurrentState = (KSSTATE)State;
        }
    }
    else {
        for(State = CurrentState - 1; State >= NewState; State--) {

            Status = SetStateBottomUp(
              (KSSTATE)State,
              CurrentState,
              ulFlags | SETSTATE_FLAG_SINK | SETSTATE_FLAG_SOURCE);

            if(!NT_SUCCESS(Status)) {
                goto exit;
            }
            CurrentState = (KSSTATE)State;
        }
    }
    ASSERT(CurrentState == NewState);
exit:
    return(Status);
}

NTSTATUS
CStartNodeInstance::SetStateTopDown(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    if(this != NULL) {
	Assert(this);

	if(ulFlags & SETSTATE_FLAG_SINK) {
	    Status = pPinNodeInstance->SetState(
	      NewState,
	      PreviousState,
	      ulFlags);

	    if(!NT_SUCCESS(Status)) {
		goto exit;
	    }
	}
	FOR_EACH_LIST_ITEM(
	  &lstConnectNodeInstance,
	  pConnectNodeInstance) {

	    Status = pConnectNodeInstance->SetStateTopDown(
	      NewState,
	      PreviousState,
	      ulFlags);

	    if(!NT_SUCCESS(Status)) {
		goto exit;
	    }

	} END_EACH_LIST_ITEM
    }
exit:
    return(Status);
}

NTSTATUS
CStartNodeInstance::SetStateBottomUp(
    KSSTATE NewState,
    KSSTATE PreviousState,
    ULONG ulFlags
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    NTSTATUS Status = STATUS_SUCCESS;

    if(this != NULL) {
	Assert(this);

	FOR_EACH_LIST_ITEM_BACKWARD(
	  &lstConnectNodeInstance,
	  pConnectNodeInstance) {

	    Status = pConnectNodeInstance->SetStateBottomUp(
	      NewState,
	      PreviousState,
	      ulFlags);

	    if(!NT_SUCCESS(Status)) {
		goto exit;
	    }

	} END_EACH_LIST_ITEM

	if(ulFlags & SETSTATE_FLAG_SINK) {
	    Status = pPinNodeInstance->SetState(
	      NewState,
	      PreviousState,
	      ulFlags);

	    if(!NT_SUCCESS(Status)) {
		goto exit;
	    }
	}
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CStartNodeInstance::Dump(
)
{
    PCONNECT_NODE_INSTANCE pConnectNodeInstance;
    extern PSZ apszStates[];

    if(this == NULL) {
	return(STATUS_CONTINUE);
    }
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("SNI: %08x SN %08x PI %08x FNI %08x VND %08x papFO %08x\n",
	  this,
	  pStartNode,
	  pPinInstance,
	  pFilterNodeInstance,
	  pVirtualNodeData,
	  papFileObjectTopologyTable);
	dprintf("     State: %08x %s\n",
	  CurrentState,
	  apszStates[CurrentState]);
	if(ulDebugFlags & DEBUG_FLAGS_INSTANCE) {
	    if(pPinNodeInstance != NULL) {
		pPinNodeInstance->Dump();
	    }
	}
	if(pPinConnect != NULL) {
	    DumpPinConnect(MAXULONG, pPinConnect);
	}
    }
    else {
	dprintf("   To: ");
	if(pPinNodeInstance != NULL) {
	    pPinNodeInstance->Dump();
	}
	else {
	    dprintf("NULL\n");
	}
    }
    if(ulDebugFlags & DEBUG_FLAGS_TOPOLOGY) {
	PGRAPH_NODE_INSTANCE pGraphNodeInstance;
	pGraphNodeInstance = pPinInstance->pFilterInstance->pGraphNodeInstance;
	if(pGraphNodeInstance != NULL) {
	    Assert(pGraphNodeInstance);
	    for(ULONG i = 0; 
	      i < pGraphNodeInstance->Topology.TopologyNodesCount;
	      i++) {
		if(papFileObjectTopologyTable[i] != NULL) {
		    dprintf("     %02x FO %08x %s\n",
		      i,
		      papFileObjectTopologyTable[i],
		      pGraphNodeInstance->papTopologyNode[i]->pFilterNode->
			DumpName());
		}
	    }
	}
    }
    if(ulDebugFlags & DEBUG_FLAGS_INSTANCE) {
	FOR_EACH_LIST_ITEM(&lstConnectNodeInstance, pConnectNodeInstance) {
	    pConnectNodeInstance->Dump();
	} END_EACH_LIST_ITEM
    }
    dprintf("\n");
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\sn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   sn.cpp
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CStartNode::Create(
    PPIN_NODE pPinNode,
    PCONNECT_NODE pConnectNode,
    PGRAPH_PIN_INFO pGraphPinInfo,
    ULONG ulFlagsCurrent,
    ULONG ulOverhead,
    PGRAPH_NODE pGraphNode
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    NTSTATUS Status = STATUS_SUCCESS;
    PSTART_NODE pStartNode = NULL;

    Assert(pPinNode);
    Assert(pGraphNode);

    if((pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_SOURCE)) {
        ASSERT(NT_SUCCESS(Status));
        ASSERT(pStartNode == NULL);
        goto exit;
    }

    if(pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_SINK ||
       pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_BOTH) {

        // Don't create a sysaudio pin if OUT/RENDER or IN/CAPTURER
        if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT &&
          ulFlagsCurrent & LFN_FLAGS_CONNECT_RENDER) {
            DPF1(50, "CStartNode::Create PN %08x - out/render", pPinNode);
            ASSERT(NT_SUCCESS(Status));
            ASSERT(pStartNode == NULL);
            goto exit;
        }
        
        if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN &&
          ulFlagsCurrent & LFN_FLAGS_CONNECT_CAPTURE) {
            DPF1(50, "CStartNode::Create PN %08x - in/capturer", pPinNode);
            ASSERT(NT_SUCCESS(Status));
            ASSERT(pStartNode == NULL);
            goto exit;
        }
    }

    FOR_EACH_LIST_ITEM(
      &pPinNode->pPinInfo->lstTopologyConnection,
      pTopologyConnection) {

        // Only check physical connections
        if(!IS_CONNECTION_TYPE(pTopologyConnection, PHYSICAL)) {
            continue;
        }

        // If there is one connection that is valid for this GraphNode
        if(pTopologyConnection->IsTopologyConnectionOnGraphNode(pGraphNode)) {

            // Don't create a sysaudio pin
            DPF4(80, "CStartNode::Create %s PN %08x TC %08x GN %08x connected",
              pPinNode->pPinInfo->pFilterNode->DumpName(),
              pPinNode,
              pTopologyConnection,
              pGraphNode);

            ASSERT(NT_SUCCESS(Status));
            ASSERT(pStartNode == NULL);
            goto exit;
        }
    } END_EACH_LIST_ITEM

    pStartNode = new START_NODE(
      pPinNode,
      pConnectNode,
      ulOverhead,
      pGraphNode);

    if(pStartNode == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    Status = CStartInfo::Create(
      pStartNode,
      pConnectNode->GetConnectInfo(),
      pGraphPinInfo,
      pGraphNode);

    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    DPF3(80, "CStartNode::Create %08x PN %08x O %08x",
      pStartNode,
      pPinNode,
      pStartNode->ulOverhead);

    //
    // For capture graphs only.
    //
    if (pStartNode->pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT) {
        pStartNode->SetSpecialFlags();
    }
exit:
    if(!NT_SUCCESS(Status)) {
        if (pStartNode) {
            pStartNode->Destroy();
        }
    }
    return(Status);
}

CStartNode::CStartNode(
    PPIN_NODE pPinNode,
    PCONNECT_NODE pConnectNode,
    ULONG ulOverhead,
    PGRAPH_NODE pGraphNode
)
{
    Assert(pPinNode);
    Assert(pGraphNode);
    this->pPinNode = pPinNode;
    this->ulOverhead = ulOverhead + pPinNode->GetOverhead();
    this->pConnectNodeHead = pConnectNode;
    this->ulFlags = 0;
    this->fRender = (pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN);
    this->ulSpecialFlags = STARTNODE_SPECIALFLAG_NONE;
    pConnectNode->AddRef();
    if(pPinNode->GetType() & FILTER_TYPE_VIRTUAL) {
        AddListEnd(&pGraphNode->lstStartNode);
    }
    else {
        AddList(&pGraphNode->lstStartNode);
    }
    DPF3(80, "CStartNode: %08x PN %08x O %08x", this, pPinNode, ulOverhead);
}

CStartNode::~CStartNode(
)
{
    DPF1(80, "~CStartNode: %08x", this);
    Assert(this);
    RemoveList();
    pStartInfo->Destroy();
    pConnectNodeHead->Destroy();
}

void
CStartNode::SetSpecialFlags()
{
    //
    // STARTNODE_SPECIALFLAG_STRICT
    // Get the last ConnectNode in connection list and check if the
    // source pin is splitter.
    // Also the first pin should be splitter pin.
    //

    //
    // STARTNODE_SPECIALFLAG_AEC
    // If the StartNode contains Aec mark the StartNode with this flag.
    //
    
    // 
    // ISSUE-2001/03/09-alpers
    // In the future two splitters in the graph will not work
    // with this logic.
    // We need a way of knowing if a filter does SRC upfront.
    //

    if (pConnectNodeHead)
    {
        PCONNECT_NODE pConnectNode;

        for(pConnectNode = pConnectNodeHead;
            pConnectNode->GetNextConnectNode() != NULL;
            pConnectNode = pConnectNode->GetNextConnectNode()) {

            if (pConnectNode->pPinNodeSource->pLogicalFilterNode->
                pFilterNode->GetType() & FILTER_TYPE_AEC) {

                ulSpecialFlags |= STARTNODE_SPECIALFLAG_AEC;
            }
        }

        ulSpecialFlags |= 
            (pConnectNode->pPinNodeSource->pPinInfo->
             pFilterNode->GetType() & FILTER_TYPE_SPLITTER) &&
            (pPinNode->pPinInfo->pFilterNode->GetType() & FILTER_TYPE_SPLITTER) ?
            STARTNODE_SPECIALFLAG_STRICT :
            STARTNODE_SPECIALFLAG_NONE;
    }

    DPF3(50, "CStartNode: %08x %s SpecialFlags %X", this, 
        DbgUnicode2Sz(pPinNode->pPinInfo->pFilterNode->GetFriendlyName()),
        ulSpecialFlags);
    
}

ENUMFUNC
CStartNode::RemoveBypassPaths(
    PVOID pReference
)
{
    PGRAPH_NODE pGraphNode = PGRAPH_NODE(pReference);
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PCONNECT_NODE pConnectNode;
    ULONG cLfnNoBypassTotal = 0;
    ULONG cLfnNoBypass = 0;
    ULONG ulFlags;
    ULONG cAecFilterCount = 0;
    BOOL  fDestroy;

    Assert(this);
    Assert(pGraphNode);

    if(pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_NONE ||
       pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_BRIDGE ||
       pPinNode->pPinInfo->Communication == KSPIN_COMMUNICATION_SOURCE) {
	return(STATUS_CONTINUE);
    }

    if(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_IN) {
	ulFlags = LFN_FLAGS_CONNECT_RENDER;
        DPF(60,"RBP - for Render");
    }
    else {
	ASSERT(pPinNode->pPinInfo->DataFlow == KSPIN_DATAFLOW_OUT);
	ulFlags = LFN_FLAGS_CONNECT_CAPTURE;
        DPF(60,"RBP - for Capture");
    }

    FOR_EACH_LIST_ITEM(
      &pGraphNode->lstLogicalFilterNodeNoBypass,
      pLogicalFilterNode) {

	if(pLogicalFilterNode->GetFlags() & ulFlags) {
	    ++cLfnNoBypassTotal;
	}

    } END_EACH_LIST_ITEM

    DPF1(60,"RBP:NoBypassTotal = %08x", cLfnNoBypassTotal);

    for(pConnectNode = GetFirstConnectNode();
	pConnectNode != NULL;
	pConnectNode = pConnectNode->GetNextConnectNode()) {

	Assert(pConnectNode);
	FOR_EACH_LIST_ITEM(
	  &pGraphNode->lstLogicalFilterNodeNoBypass,
	  pLogicalFilterNode) {

	    if(pLogicalFilterNode->GetFlags() & ulFlags) {
		Assert(pConnectNode->pPinNodeSource);
		Assert(pConnectNode->pPinNodeSource->pLogicalFilterNode);
		if(pConnectNode->pPinNodeSource->pLogicalFilterNode == 
		   pLogicalFilterNode) {
		     cLfnNoBypass++;
		}
	    }

	} END_EACH_LIST_ITEM

        DPF1(60,"RBP:FilterInPath = %s",
              DbgUnicode2Sz(pConnectNode->pPinNodeSource->pLogicalFilterNode->pFilterNode->GetFriendlyName()));

        //
        // In capture paths count AEC filters to avoid conflict with GFXes
        //
        if((ulFlags & LFN_FLAGS_CONNECT_CAPTURE) &&
           (pConnectNode->pPinNodeSource->pLogicalFilterNode->pFilterNode->GetType() & FILTER_TYPE_AEC)) {
                ++cAecFilterCount;
        }
    }

    ASSERT(cAecFilterCount < 2);

    DPF2(60,"RBP:NBPCount=%08x, AECCount=%08x", cLfnNoBypass, cAecFilterCount);

    //
    // Mark all the paths with NO Gfx as second pass candidates
    // We do this to support the following sequence of capture pin creations
    //   1. Client installs GFX(es) on a capture device
    //   2. Client creates a pin with AEC
    //      This would result in creating a Capture->Splitter->AEC path
    //   3. Client tries to create a regular capture pin (with GFX)
    //      In this case we want to create a regular path (but since no GFX
    //      hooked up between capture and splitter. We create a capture->splitter->[kmixer] path
    //      These special paths are marked as secondpass. And we try these paths
    //      only if all the primary start nodes failed to instantiate a pin.
    //      (look in pins.cpp - PinDispatchCreateKP()
    //
    if(cLfnNoBypassTotal != 0) {
        if(cLfnNoBypass == 0) {
            this->ulFlags |= STARTNODE_FLAGS_SECONDPASS;
        }
    }

    //
    // Assume that this path is going to be OK
    //
    fDestroy = FALSE;


    if (cAecFilterCount == 0) {
        //
        // There is no AEC in this path
        // We have to make sure that we have all the necessary
        // GFXs loaded in this path. (Else destroy the path)
        //
        if(cLfnNoBypass != cLfnNoBypassTotal) {
            fDestroy = TRUE;
        }
    }
    else {
        //
        // There is an AEC in this path
        // No GFXs should be there in this path. If there is even one GFX
        // destroy the path
        //
        if ((cLfnNoBypass != 0) || (cAecFilterCount > 1)) {
            fDestroy = TRUE;
        }
    }

    if ((fDestroy) && ((this->ulFlags & STARTNODE_FLAGS_SECONDPASS) == 0)) {
        Destroy();
        DPF(60,"RBP:PathDestroyed");
    }

    DPF(60,"RBP:Done");
    return(STATUS_CONTINUE);
}

#ifdef DEBUG

//
// Handy debug routine to dump filters in the path for this StartNode
//
VOID
CStartNode::DumpFilters(
)

{
    PCONNECT_NODE pConnectNode;

    for(pConnectNode = GetFirstConnectNode();
	pConnectNode != NULL;
	pConnectNode = pConnectNode->GetNextConnectNode()) {

	Assert(pConnectNode);
        DPF1(0,"DF:FilterInPath = %s",
             DbgUnicode2Sz(pConnectNode->pPinNodeSource->pLogicalFilterNode->pFilterNode->GetFriendlyName()));
    }
}
#endif

ENUMFUNC
CStartNode::RemoveConnectedStartNode(
    PVOID pReference
)
{
    PGRAPH_NODE pGraphNode = PGRAPH_NODE(pReference);
    PCONNECT_NODE pConnectNode;
    PSTART_NODE pStartNode;

    Assert(this);
    Assert(pGraphNode);

    FOR_EACH_LIST_ITEM(&pGraphNode->lstStartNode, pStartNode) {

	if(this == pStartNode) {
	    continue;
	}
	for(pConnectNode = pStartNode->GetFirstConnectNode();
	    pConnectNode != NULL;
	    pConnectNode = pConnectNode->GetNextConnectNode()) {

	    if(this->pPinNode == pConnectNode->pPinNodeSink) {
		DPF3(50, "CStartNode::RemoveConnectedSN %08x GN %08x %s",
		  this,
		  pGraphNode,
		  pPinNode->pPinInfo->pFilterNode->DumpName());

		Destroy();
		return(STATUS_CONTINUE);
	    }
	}

    } END_EACH_LIST_ITEM

    return(STATUS_CONTINUE);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CStartNode::Dump(
)
{
    PCONNECT_NODE pConnectNode;

    Assert(this);
    dprintf("SN: %08x PN %08x SI %08x O %08x #%d %s\n",
      this,
      pPinNode,
      pStartInfo,
      ulOverhead,
      pPinNode->pPinInfo->PinId,
      pPinNode->pPinInfo->pFilterNode->DumpName());

    if(ulDebugFlags & DEBUG_FLAGS_GRAPH) {
	for(pConnectNode = GetFirstConnectNode();
	    pConnectNode != NULL;
	    pConnectNode = pConnectNode->GetNextConnectNode()) {

	    pConnectNode->Dump();
	}
    }
    return(STATUS_CONTINUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\sni.h ===
//---------------------------------------------------------------------------
//
//  Module:   		sni.h
//
//  Description:	Start Node Instance Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CStartNodeInstance : public CListDoubleItem
{
private:
    CStartNodeInstance(
        PPIN_INSTANCE pPinInstance,
        PSTART_NODE pStartNode
    );

    ~CStartNodeInstance();

    VOID
    CleanUp(
    );

public:
    static NTSTATUS
    Create(
        PPIN_INSTANCE pPinInstance,
        PSTART_NODE pStartNode,
        PKSPIN_CONNECT pPinConnect,
        PWAVEFORMATEX pWaveFormatExRequested,
        PWAVEFORMATEX pWaveFormatExRegistry
    );

    ENUMFUNC
    Destroy(
    )
    {
        if(this != NULL) {
            Assert(this);
            delete this;
        }
        return(STATUS_CONTINUE);
    };

    NTSTATUS
    IntelligentConnect(
        PDEVICE_NODE pDeviceNode,
        PKSPIN_CONNECT pPinConnect,
        PWAVEFORMATEX pWaveFormatEx
    );

    NTSTATUS
    Connect(
        PDEVICE_NODE pDeviceNode,
        PKSPIN_CONNECT pPinConnect,
        PWAVEFORMATEX pWaveFormatEx,
        PKSPIN_CONNECT pPinConnectDirect
    );

    NTSTATUS
    AecConnectionFormat(
        PDEVICE_NODE pDeviceNode,
        PKSPIN_CONNECT *ppPinConnect);

    NTSTATUS
    CreateTopologyTable(
        PGRAPH_NODE_INSTANCE pGraphNodeInstance 
    );

    NTSTATUS
    GetTopologyNodeFileObject(
        OUT PFILE_OBJECT *ppFileObject,
        IN ULONG NodeId
    );

    BOOL
    IsRender()
    {
        return pStartNode->fRender;
    };

    NTSTATUS
    SetState(
        KSSTATE NewState,
        ULONG ulFlags
    );

    NTSTATUS
    SetStateTopDown(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

    NTSTATUS
    SetStateBottomUp(
        KSSTATE NewState,
        KSSTATE PreviousState,
        ULONG ulFlags
    );

#ifdef DEBUG
    ENUMFUNC Dump();
    PKSPIN_CONNECT pPinConnect;
#endif

    KSSTATE CurrentState;
    PSTART_NODE pStartNode;
    PPIN_INSTANCE pPinInstance;
    PVIRTUAL_NODE_DATA pVirtualNodeData;
    PFILE_OBJECT *papFileObjectTopologyTable;
    LIST_CONNECT_NODE_INSTANCE lstConnectNodeInstance;
    PFILTER_NODE_INSTANCE pFilterNodeInstance;
    PPIN_NODE_INSTANCE pPinNodeInstance;
public:
    DefineSignature(0x20494E53);		// SNI

} START_NODE_INSTANCE, *PSTART_NODE_INSTANCE;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<START_NODE_INSTANCE> LIST_START_NODE_INSTANCE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern WAVEFORMATEX aWaveFormatEx[];

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\tc.h ===
//---------------------------------------------------------------------------
//
//  Module:   		tc.h
//
//  Description:	Topology Connection Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define TOPC_FLAGS_FILTER_CONNECTION_TYPE	0x00000000
#define TOPC_FLAGS_PHYSICAL_CONNECTION_TYPE	0x00000001
#define TOPC_FLAGS_GRAPH_CONNECTION_TYPE	0x00000002
#define TOPC_FLAGS_CONNECTION_TYPE		0x00000003

#define	IS_CONNECTION_TYPE(pTopologyConnection, Type) \
	(((pTopologyConnection)->ulFlags & TOPC_FLAGS_CONNECTION_TYPE) ==\
	TOPC_FLAGS_##Type##_CONNECTION_TYPE)

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CTopologyConnection : public CListMultiItem
{
private:
    CTopologyConnection(
	PTOPOLOGY_PIN pTopologyPinFrom,
	PTOPOLOGY_PIN pTopologyPinTo,
	PPIN_INFO pPinInfoFrom,
	PPIN_INFO pPinInfoTo
    );

    ~CTopologyConnection(
    );

public:
    static NTSTATUS
    Create(
	PTOPOLOGY_CONNECTION *ppTopologyConnection,
	PFILTER_NODE pFilterNode,
	PGRAPH_NODE pGraphNode,
	PTOPOLOGY_PIN pTopologyPinFrom,
	PTOPOLOGY_PIN pTopologyPinTo,
	PPIN_INFO pPinInfoFrom,
	PPIN_INFO pPinInfoTo
    );

    ENUMFUNC
    Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    ENUMFUNC
    CheckDuplicate(
	PVOID ppTopologyConnection
    );

    ENUMFUNC
    ProcessTopologyConnection(
	PVOID pGraphNodeInstance
    );

    BOOL
    IsTopologyConnectionOnGraphNode(
	PGRAPH_NODE pGraphNode
    );
#ifdef DEBUG
    ENUMFUNC Dump();
#endif
    ULONG ulFlags;
    PTOPOLOGY_PIN pTopologyPinFrom;
    PTOPOLOGY_PIN pTopologyPinTo;
    PPIN_INFO pPinInfoFrom;
    PPIN_INFO pPinInfoTo;
    DefineSignature(0x20204354);		// TC

} TOPOLOGY_CONNECTION, *PTOPOLOGY_CONNECTION;

//---------------------------------------------------------------------------

typedef ListMultiDestroy<TOPOLOGY_CONNECTION> LIST_DESTROY_TOPOLOGY_CONNECTION;
typedef LIST_DESTROY_TOPOLOGY_CONNECTION *PLIST_DESTROY_TOPOLOGY_CONNECTION;

//---------------------------------------------------------------------------

typedef ListMulti<TOPOLOGY_CONNECTION> LIST_MULTI_TOPOLOGY_CONNECTION;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern ULONG gcTopologyConnections;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
CreatePinInfoConnection(
    IN PTOPOLOGY_CONNECTION *ppTopologyConnection,
    IN PFILTER_NODE pFilterNode,
    IN PGRAPH_NODE pGraphNode,
    IN PPIN_INFO pPinInfoSource,
    IN PPIN_INFO pPinInfoSink
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\tn.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   tn.cpp
//
//  Description:
//
//	Topology Node Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CTopologyNode::Create(
    PTOPOLOGY_NODE *ppTopologyNode,
    PFILTER_NODE pFilterNode,
    ULONG ulNodeNumber,
    GUID *pguidType
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_NODE pTopologyNode;

    pTopologyNode = new TOPOLOGY_NODE(pFilterNode, ulNodeNumber, pguidType);
    if(pTopologyNode == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    DPF2(70, "CTopologyNode::Create: %08x, FN: %08x",
      pTopologyNode,
      pFilterNode);
exit:
    *ppTopologyNode = pTopologyNode;
    return(Status);
}

CTopologyNode::CTopologyNode(
    PFILTER_NODE pFilterNode,
    ULONG ulNodeNumber,
    GUID *pguidType
)
{
    Assert(pFilterNode);
    this->pFilterNode = pFilterNode;
    this->ulRealNodeNumber = ulNodeNumber;
    this->ulSysaudioNodeNumber = MAXULONG;
    this->iVirtualSource = MAXULONG;
    this->pguidType = pguidType;
    AddList(&pFilterNode->lstTopologyNode);
    DPF2(70, "CTopologyNode: %08x, FN: %08x", this, pFilterNode);
}

CTopologyNode::~CTopologyNode(
)
{
    DPF1(70, "~CTopologyNode: %08x", this);
    Assert(this);
}

NTSTATUS
CreateTopology(
    PFILTER_NODE pFilterNode,
    PKSTOPOLOGY pTopology
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_CONNECTION pTopologyConnection;
    PTOPOLOGY_NODE *papTopologyNode = NULL;
    PTOPOLOGY_NODE pTopologyNodeFrom;
    PTOPOLOGY_NODE pTopologyNodeTo;
    PTOPOLOGY_PIN pTopologyPinFrom;
    PTOPOLOGY_PIN pTopologyPinTo;
    PPIN_INFO pPinInfoFrom;
    PPIN_INFO pPinInfoTo;
    PPIN_INFO pPinInfo;
    ULONG ulTopologyPinNumberFrom;
    ULONG ulTopologyPinNumberTo;
    ULONG n, c;

    // If no topology, return error
    if(pTopology->TopologyNodesCount == 0) {
	if(pTopology->TopologyConnectionsCount == 0) {
	    DPF2(5,
	      "CreateTopology: FAILED, %s has no topology FN: %08x",
	      pFilterNode->DumpName(),
	      pFilterNode);
	    Status = STATUS_INVALID_PARAMETER;
	    goto exit;
	}
    }
    else {
	papTopologyNode = new PTOPOLOGY_NODE[pTopology->TopologyNodesCount];
	if(papTopologyNode == NULL) {
	    Status = STATUS_INSUFFICIENT_RESOURCES;
	    goto exit;
	}
	for(n = 0; n < pTopology->TopologyNodesCount; n++) {

	    Status = CTopologyNode::Create(
	      &papTopologyNode[n],
	      pFilterNode,
	      n,
	      (GUID *)&pTopology->TopologyNodes[n]);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	}
    }

    for(c = 0; c < pTopology->TopologyConnectionsCount; c++) {

	pTopologyNodeFrom = pTopologyNodeTo = NULL;
	pTopologyPinFrom = pTopologyPinTo = NULL;
	pPinInfoFrom = pPinInfoTo = NULL;

	if(pTopology->TopologyConnections[c].FromNode != KSFILTER_NODE) {
	    if(pTopology->TopologyConnections[c].FromNode >=
	       pTopology->TopologyNodesCount) {
		DPF2(5,
		  "CreateTopology: FAILED, %s invalid 'from' node # %08x",
		  pFilterNode->DumpName(),
		  pTopology->TopologyConnections[c].FromNode);
		Trap();
		Status = STATUS_INVALID_PARAMETER;
		goto exit;
	    }
	    pTopologyNodeFrom =
	      papTopologyNode[pTopology->TopologyConnections[c].FromNode];

	    ulTopologyPinNumberFrom =
	      pTopology->TopologyConnections[c].FromNodePin;
	}

	if(pTopology->TopologyConnections[c].ToNode != KSFILTER_NODE) {
	    if(pTopology->TopologyConnections[c].ToNode >=
	       pTopology->TopologyNodesCount) {
		DPF2(5,
		  "CreateTopology: FAILED, %s invalid 'to' node # %08x",
		  pFilterNode->DumpName(),
	          pTopology->TopologyConnections[c].ToNode);
		Trap();
		Status = STATUS_INVALID_PARAMETER;
		goto exit;
	    }
	    pTopologyNodeTo = 
	      papTopologyNode[pTopology->TopologyConnections[c].ToNode];

	    ulTopologyPinNumberTo =
	      pTopology->TopologyConnections[c].ToNodePin;
	}

	if(pTopologyNodeFrom == NULL) {

	    FOR_EACH_LIST_ITEM(&pFilterNode->lstPinInfo, pPinInfo) {

		if(pPinInfo->PinId == 
		  pTopology->TopologyConnections[c].FromNodePin) {
		    pPinInfoFrom = pPinInfo;
		    break;
	        }

	    } END_EACH_LIST_ITEM

	    if(pPinInfoFrom == NULL) {
		DPF2(5,
		  "CreateTopology: FAILED, %s invalid 'from' node pin # %08x",
	          pFilterNode->DumpName(),
		  pTopology->TopologyConnections[c].FromNodePin);
		Trap();
		Status = STATUS_INVALID_PARAMETER;
		goto exit;
	    }
	}
	else {
	    Status = CTopologyPin::Create(
	      &pTopologyPinFrom,
	      ulTopologyPinNumberFrom,
	      pTopologyNodeFrom);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	}

	if(pTopologyNodeTo == NULL) {

	    FOR_EACH_LIST_ITEM(&pFilterNode->lstPinInfo, pPinInfo) {

		if(pPinInfo->PinId == 
		  pTopology->TopologyConnections[c].ToNodePin) {
		    pPinInfoTo = pPinInfo;
		    break;
	        }

	    } END_EACH_LIST_ITEM

	    if(pPinInfoTo == NULL) {
		DPF2(5,
		  "CreateTopology: FAILED, %s invalid 'to' node pin # %08x",
	          pFilterNode->DumpName(),
		  pTopology->TopologyConnections[c].ToNodePin);
		Trap();
		Status = STATUS_INVALID_PARAMETER;
		goto exit;
	    }
	}
	else {
	    Status = CTopologyPin::Create(
	      &pTopologyPinTo,
	      ulTopologyPinNumberTo,
	      pTopologyNodeTo);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	}
	Status = CTopologyConnection::Create(
	  &pTopologyConnection,
	  pFilterNode,
	  NULL,
	  pTopologyPinFrom,
	  pTopologyPinTo,
	  pPinInfoFrom,
	  pPinInfoTo);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	ASSERT(IS_CONNECTION_TYPE(pTopologyConnection, FILTER));
    }
exit:
    delete [] papTopologyNode;
    return(Status);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CTopologyNode::Dump(
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode;

    Assert(this);
    dprintf("TN: %08x FN %08x R#%-2d S#%-2d I%-2d %s %s\n",
      this,
      pFilterNode,
      ulRealNodeNumber,
      ulSysaudioNodeNumber,
      iVirtualSource,
      DbgGuid2Sz(pguidType),
      ulFlags & TN_FLAGS_DONT_FORWARD ? "DONT_FORWARD" : "");

    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("    ulFlags: %08x ", ulFlags);
	if(ulFlags & TN_FLAGS_DONT_FORWARD) {
	    dprintf("DONT_FORWARD");
	}
	dprintf("\n    lstLFN: ");
	lstLogicalFilterNode.DumpAddress();
	dprintf("\n");
    }
    lstTopologyPin.Dump();
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\tn.h ===
//---------------------------------------------------------------------------
//
//  Module:   		tn.h
//
//  Description:	Topology Node Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define TN_FLAGS_DONT_FORWARD			0x00000001

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef ListMulti<CLogicalFilterNode> LIST_MULTI_LOGICAL_FILTER_NODE;

//---------------------------------------------------------------------------

typedef class CTopologyNode : public CListSingleItem
{
public:
    CTopologyNode(
	PFILTER_NODE pFilterNode,
	ULONG ulNodeNumber,
	GUID *pguidType
    );

    ~CTopologyNode(
    );

    static NTSTATUS
    Create(
	PTOPOLOGY_NODE *ppTopologyNode,
	PFILTER_NODE pFilterNode,
	ULONG ulNodeNumber,
	GUID *pguidType
    );

    ENUMFUNC
    Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };

    ENUMFUNC
    InitializeTopologyNode(
	PVOID pGraphNodeInstance
    );

    ENUMFUNC 
    AddTopologyNode(
	PVOID pGraphNodeInstance
    );

    ENUMFUNC
    MatchTopologyNode(
	PVOID pReference
    )
    {
	if(this == PTOPOLOGY_NODE(pReference)) {
	    return(STATUS_SUCCESS);
	}
	return(STATUS_CONTINUE);
    };

#ifdef DEBUG
    ENUMFUNC 
    Dump(
    );
#endif
    PFILTER_NODE pFilterNode;
    GUID *pguidType;
    ULONG ulFlags;
    ULONG ulRealNodeNumber;
    ULONG ulSysaudioNodeNumber;
    ULONG iVirtualSource;
    LIST_TOPOLOGY_PIN lstTopologyPin;
    LIST_MULTI_LOGICAL_FILTER_NODE lstLogicalFilterNode;
    DefineSignature(0x20204E54);		// TN

} TOPOLOGY_NODE, *PTOPOLOGY_NODE;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<TOPOLOGY_NODE> LIST_TOPOLOGY_NODE;

//---------------------------------------------------------------------------

typedef ListData<TOPOLOGY_NODE> LIST_DATA_TOPOLOGY_NODE, *PLIST_DATA_TOPOLOGY_NODE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
CreateTopology(
    PFILTER_NODE pFilterNode,
    PKSTOPOLOGY pTopology
);

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\tc.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   tc.cpp
//
//  Description:
//
//	Topology Connection Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

ULONG gcTopologyConnections = 0;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CTopologyConnection::CTopologyConnection(
    PTOPOLOGY_PIN pTopologyPinFrom,
    PTOPOLOGY_PIN pTopologyPinTo,
    PPIN_INFO pPinInfoFrom,
    PPIN_INFO pPinInfoTo
)
{
#ifdef DEBUG
    DPF4(110,
      "CTopologyConnection: PIF: %08x PIT: %08x TPF: %08x TPT: %08x",
      pPinInfoFrom,
      pPinInfoTo,
      pTopologyPinFrom,
      pTopologyPinTo);
#endif
    this->pTopologyPinFrom = pTopologyPinFrom;
    this->pTopologyPinTo = pTopologyPinTo;
    this->pPinInfoFrom = pPinInfoFrom;
    this->pPinInfoTo = pPinInfoTo;
    ASSERT(TOPC_FLAGS_FILTER_CONNECTION_TYPE == 0);
    ++gcTopologyConnections;
    DPF1(70, "CTopologyConnection: %08x", this);
}

CTopologyConnection::~CTopologyConnection(
)
{
    Assert(this);
    DPF1(70, "~CTopologyConnection: %08x", this);
    --gcTopologyConnections;
}

NTSTATUS
CTopologyConnection::Create(
    PTOPOLOGY_CONNECTION *ppTopologyConnection,
    PFILTER_NODE pFilterNode,
    PGRAPH_NODE pGraphNode,
    PTOPOLOGY_PIN pTopologyPinFrom,
    PTOPOLOGY_PIN pTopologyPinTo,
    PPIN_INFO pPinInfoFrom,
    PPIN_INFO pPinInfoTo
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_CONNECTION pTopologyConnection;
    PLIST_DESTROY_TOPOLOGY_CONNECTION plstTopologyConnection;

    PFILTER_NODE pFilterNodeNext;
#ifdef DEBUG
    DPF4(110,
      "CTopologyConnection::Create: PIF: %08x PIT: %08x TPF: %08x TPT: %08x",
      pPinInfoFrom,
      pPinInfoTo,
      pTopologyPinFrom,
      pTopologyPinTo);
#endif
    ASSERT(pFilterNode != NULL || pGraphNode != NULL);

    pTopologyConnection = new TOPOLOGY_CONNECTION(
	pTopologyPinFrom,
	pTopologyPinTo,
	pPinInfoFrom,
	pPinInfoTo
    );
    if(pTopologyConnection == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    *ppTopologyConnection = pTopologyConnection;

    if(pFilterNode != NULL) {
	Assert(pFilterNode);
	ASSERT(pGraphNode == NULL);

	// Adding connection to filter connection list
	plstTopologyConnection = &pFilterNode->lstTopologyConnection;

	// Check if duplicate connection on filter list
	FOR_EACH_LIST_ITEM(
          &pFilterNode->lstConnectedFilterNode,
	  pFilterNodeNext) {

	    if(pFilterNodeNext->lstTopologyConnection.EnumerateList(
	      CTopologyConnection::CheckDuplicate,
	      ppTopologyConnection) == STATUS_SUCCESS) {

		ASSERT(NT_SUCCESS(Status));
		DPF(70, "CTopologyConnection::Create: Duplicate 1");
		delete pTopologyConnection;
		goto exit;
	    }

	} END_EACH_LIST_ITEM

    }
    if(pGraphNode != NULL) {
	PLOGICAL_FILTER_NODE pLogicalFilterNode;
        Assert(pGraphNode);
	ASSERT(pFilterNode == NULL);

	// Adding connection to GraphNode connection list
	plstTopologyConnection = &pGraphNode->lstTopologyConnection;

	// Check if duplicate on GraphNode's logical filter list
	FOR_EACH_LIST_ITEM(
	  &pGraphNode->pDeviceNode->lstLogicalFilterNode,
	  pLogicalFilterNode) {

	    if(pLogicalFilterNode->lstTopologyConnection.EnumerateList(
	      CTopologyConnection::CheckDuplicate,
	      ppTopologyConnection) == STATUS_SUCCESS) {

		ASSERT(NT_SUCCESS(Status));
		DPF(70, "CTopologyConnection::Create: Duplicate 2");
		delete pTopologyConnection;
		goto exit;
	    }

	} END_EACH_LIST_ITEM

	// Check if duplicate on GraphNode's connected filter list
	FOR_EACH_LIST_ITEM(
	  &pGraphNode->lstLogicalFilterNode,
	  pLogicalFilterNode) {

	    if(pLogicalFilterNode->lstTopologyConnection.EnumerateList(
	      CTopologyConnection::CheckDuplicate,
	      ppTopologyConnection) == STATUS_SUCCESS) {

		ASSERT(NT_SUCCESS(Status));
		DPF(70, "CTopologyConnection::Create: Duplicate 3");
		delete pTopologyConnection;
		goto exit;
	    }

	} END_EACH_LIST_ITEM

	pTopologyConnection->ulFlags = TOPC_FLAGS_GRAPH_CONNECTION_TYPE;
    }

    // Check for duplicate topology connections
    if(plstTopologyConnection->EnumerateList(
      CTopologyConnection::CheckDuplicate,
      ppTopologyConnection) == STATUS_SUCCESS) {

	DPF(70, "CTopologyConnection::Create: Duplicate 4");
	ASSERT(NT_SUCCESS(Status));
	delete pTopologyConnection;
	goto exit;
    }

    if(pTopologyPinFrom != NULL) {
	Assert(pTopologyConnection);

	Status = pTopologyConnection->AddListEnd(
	  &pTopologyPinFrom->lstTopologyConnection);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
    if(pTopologyPinTo != NULL) {
	Assert(pTopologyConnection);

	Status = pTopologyConnection->AddListEnd(
	  &pTopologyPinTo->lstTopologyConnection);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
    if(pPinInfoFrom != NULL) {
	Assert(pTopologyConnection);

	Status = pTopologyConnection->AddListEnd(
	  &pPinInfoFrom->lstTopologyConnection);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
    if(pPinInfoTo != NULL) {
	Assert(pTopologyConnection);

	Status = pTopologyConnection->AddListEnd(
	  &pPinInfoTo->lstTopologyConnection);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
    Status = pTopologyConnection->AddListEnd(plstTopologyConnection);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    DPF3(70, "CTopologyConnection::Create: %08x, FN: %08x GN: %08x", 
      *ppTopologyConnection,
      pFilterNode,
      pGraphNode);
    return(Status);
}

ENUMFUNC
CTopologyConnection::CheckDuplicate(
    PVOID pReference
)
{
    PTOPOLOGY_CONNECTION *ppTopologyConnection = 
      (PTOPOLOGY_CONNECTION*)pReference;

    if((this->pTopologyPinFrom == (*ppTopologyConnection)->pTopologyPinFrom) &&
       (this->pTopologyPinTo == (*ppTopologyConnection)->pTopologyPinTo) &&
       (this->pPinInfoFrom == (*ppTopologyConnection)->pPinInfoFrom) &&
       (this->pPinInfoTo == (*ppTopologyConnection)->pPinInfoTo)) {
	*ppTopologyConnection = this;
	return(STATUS_SUCCESS);
    }
    return(STATUS_CONTINUE);
}

BOOL
CTopologyConnection::IsTopologyConnectionOnGraphNode(
    PGRAPH_NODE pGraphNode
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNodeFrom;
    PLOGICAL_FILTER_NODE pLogicalFilterNodeTo;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    BOOL fStatusFrom = FALSE;
    BOOL fStatusTo = FALSE;

    Assert(pGraphNode);
    if(pPinInfoFrom != NULL || pPinInfoTo != NULL) {
	  return(TRUE);
    }
    if(pTopologyPinFrom == NULL || pTopologyPinTo == NULL) {
	  return(FALSE);
    }
    Assert(pTopologyPinFrom);
    Assert(pTopologyPinTo);

    FOR_EACH_LIST_ITEM(
      &pTopologyPinFrom->pTopologyNode->lstLogicalFilterNode,
      pLogicalFilterNodeFrom) {

	Assert(pLogicalFilterNodeFrom);
	FOR_EACH_LIST_ITEM(
	  &pTopologyPinTo->pTopologyNode->lstLogicalFilterNode,
	  pLogicalFilterNodeTo) {

	    FOR_EACH_LIST_ITEM(
	      &pGraphNode->pDeviceNode->lstLogicalFilterNode,
	      pLogicalFilterNode) {

		Assert(pLogicalFilterNode);
		if(pLogicalFilterNode == pLogicalFilterNodeFrom) {
		    fStatusFrom = TRUE;
		}
		if(pLogicalFilterNode == pLogicalFilterNodeTo) {
		    fStatusTo = TRUE;
		}

	    } END_EACH_LIST_ITEM

	    if(fStatusFrom && fStatusTo) {
 		goto exit;
	    }

	    FOR_EACH_LIST_ITEM(
	      &pGraphNode->lstLogicalFilterNode,
	      pLogicalFilterNode) {

		Assert(pLogicalFilterNode);
		if(pLogicalFilterNode == pLogicalFilterNodeFrom) {
		    fStatusFrom = TRUE;
		}
		if(pLogicalFilterNode == pLogicalFilterNodeTo) {
		    fStatusTo = TRUE;
		}

	    } END_EACH_LIST_ITEM

	    if(fStatusFrom && fStatusTo) {
 		goto exit;
	    }

	} END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    return(fStatusFrom && fStatusTo);
}

NTSTATUS
AddPinToFilterNode(
    PTOPOLOGY_PIN pTopologyPin,
    PFILTER_NODE pFilterNode
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNodeNext;

    Assert(pFilterNode);
    Assert(pTopologyPin);
    Assert(pTopologyPin->pTopologyNode->pFilterNode);
    //
    // Add to filter node to connected filter node list
    //
    if(pFilterNode != pTopologyPin->pTopologyNode->pFilterNode) {

        Status = pFilterNode->lstConnectedFilterNode.AddList(
          pTopologyPin->pTopologyNode->pFilterNode);

        if(!NT_SUCCESS(Status)) {
            Trap();
            goto exit;
        }
        // Hack for ds1wdm dmus synth topology (adds dmus to wave FN lst)
        if((pFilterNode->GetType() & FILTER_TYPE_ENDPOINT) == 0) {

            DPF2(50, "AddPinToFilterNode: (from) FN: %08x %s",
              pFilterNode,
              pFilterNode->DumpName());

            FOR_EACH_LIST_ITEM(
              &pTopologyPin->pTopologyNode->pFilterNode->lstConnectedFilterNode,
              pFilterNodeNext) {

                if(pFilterNodeNext == pFilterNode ||
                  pFilterNodeNext == pTopologyPin->pTopologyNode->pFilterNode) {
                    continue;
                }
                DPF2(50, "AddPinToFilterNode: (to) FN: %08x %s",
                  pFilterNodeNext,
                  pFilterNodeNext->DumpName());

                Status = pFilterNodeNext->lstConnectedFilterNode.AddList(
                  pFilterNode);

                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }

            } END_EACH_LIST_ITEM
        }

        //
        // This fixes the bug with capture only devices. The topology for 
        // capture only devices was not built properly, due to the missing 
        // link between wave filter and topology filter.
        // Add the topology filter to wave filter ConnectedFilterNode list.
        // The AddList function does not allow duplicate entries.
        //
        if ((pFilterNode->GetType() & FILTER_TYPE_TOPOLOGY) &&
            (pTopologyPin->pTopologyNode->pFilterNode->GetType() & (FILTER_TYPE_CAPTURER))) {
            
            Status = pTopologyPin->pTopologyNode->pFilterNode->lstConnectedFilterNode.AddList(
              pFilterNode);

            DPF3(20, "AddPinToFilterNode: (CAPTURE ONLY) FN: %08x FN: %08x %s",
              pTopologyPin->pTopologyNode->pFilterNode,
              pFilterNode,
              pFilterNode->DumpName());
        }
    }
exit:
    return(Status);
}

NTSTATUS
AddPinToGraphNode(
    PTOPOLOGY_PIN pTopologyPin,
    PGRAPH_NODE pGraphNode,
    PTOPOLOGY_CONNECTION pTopologyConnection
)
{
    PLOGICAL_FILTER_NODE pLogicalFilterNode2;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PTOPOLOGY_CONNECTION pTopologyConnection2;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fAddLogicalFilterNode;

    Assert(pTopologyPin);
    Assert(pTopologyPin->pTopologyNode);
    Assert(pGraphNode);

    FOR_EACH_LIST_ITEM(
      &pTopologyPin->pTopologyNode->lstLogicalFilterNode,
      pLogicalFilterNode) {
        fAddLogicalFilterNode = FALSE;

	FOR_EACH_LIST_ITEM(
	  &pLogicalFilterNode->lstTopologyConnection,
	  pTopologyConnection2) {

	    Assert(pTopologyConnection2);
	    if(pTopologyPin == pTopologyConnection2->pTopologyPinFrom ||
	       pTopologyPin == pTopologyConnection2->pTopologyPinTo) {
		 fAddLogicalFilterNode = TRUE;
		 break;
	    }

	} END_EACH_LIST_ITEM

	if(fAddLogicalFilterNode) {
	    FOR_EACH_LIST_ITEM(
	      &pGraphNode->pDeviceNode->lstLogicalFilterNode,
	      pLogicalFilterNode2) {

		Assert(pLogicalFilterNode2);
		if(pLogicalFilterNode == pLogicalFilterNode2) {
		    fAddLogicalFilterNode = FALSE;
		    break;
		}

	    } END_EACH_LIST_ITEM
	}

	if(fAddLogicalFilterNode) {

	    Status = pGraphNode->lstLogicalFilterNode.AddList(
	      pLogicalFilterNode,
	      pTopologyConnection);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }
	}

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

NTSTATUS
CreatePinInfoConnection(
    PTOPOLOGY_CONNECTION *ppTopologyConnection,
    PFILTER_NODE pFilterNode,
    PGRAPH_NODE pGraphNode,
    PPIN_INFO pPinInfoSource,
    PPIN_INFO pPinInfoSink
)
{
    PTOPOLOGY_CONNECTION pTopologyConnectionSource;
    PTOPOLOGY_CONNECTION pTopologyConnectionSink;
    PTOPOLOGY_PIN pTopologyPinFrom;
    PTOPOLOGY_PIN pTopologyPinTo;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pPinInfoSource);
    Assert(pPinInfoSink);
    ASSERT(pPinInfoSource != pPinInfoSink);

    FOR_EACH_LIST_ITEM(
      &pPinInfoSource->lstTopologyConnection,
      pTopologyConnectionSource) {

	Assert(pTopologyConnectionSource);
	if(!IS_CONNECTION_TYPE(pTopologyConnectionSource, FILTER)) {
	    continue;
	}
	pTopologyPinFrom = NULL;
	pTopologyPinTo = NULL;

	if(pTopologyConnectionSource->pTopologyPinFrom != NULL) {
	    ASSERT(pTopologyConnectionSource->pPinInfoTo == pPinInfoSource);
	    ASSERT(pTopologyConnectionSource->pPinInfoFrom == NULL);
	    ASSERT(pTopologyConnectionSource->pTopologyPinTo == NULL);
	    pTopologyPinFrom = pTopologyConnectionSource->pTopologyPinFrom;
	}

	if(pTopologyConnectionSource->pTopologyPinTo != NULL) {
	    ASSERT(pTopologyConnectionSource->pPinInfoFrom == pPinInfoSource);
	    ASSERT(pTopologyConnectionSource->pPinInfoTo == NULL);
	    ASSERT(pTopologyConnectionSource->pTopologyPinFrom == NULL);
	    pTopologyPinTo = pTopologyConnectionSource->pTopologyPinTo;
	}

	FOR_EACH_LIST_ITEM(
	  &pPinInfoSink->lstTopologyConnection,
	  pTopologyConnectionSink) {

	    Assert(pTopologyConnectionSink);
	    if(!IS_CONNECTION_TYPE(pTopologyConnectionSink, FILTER)) {
		continue;
	    }
	    if(pTopologyConnectionSink->pTopologyPinFrom != NULL) {
		ASSERT(pTopologyConnectionSink->pPinInfoTo == pPinInfoSink);
		ASSERT(pTopologyConnectionSink->pPinInfoFrom == NULL);
		ASSERT(pTopologyConnectionSink->pTopologyPinTo == NULL);
		pTopologyPinFrom = pTopologyConnectionSink->pTopologyPinFrom;
	    }

	    if(pTopologyConnectionSink->pTopologyPinTo != NULL) {
		ASSERT(pTopologyConnectionSink->pPinInfoFrom == pPinInfoSink);
		ASSERT(pTopologyConnectionSink->pPinInfoTo == NULL);
		ASSERT(pTopologyConnectionSink->pTopologyPinFrom == NULL);
		pTopologyPinTo = pTopologyConnectionSink->pTopologyPinTo;
	    }

	    ASSERT(pTopologyPinFrom != NULL);
	    ASSERT(pTopologyPinTo != NULL);

	    Status = CTopologyConnection::Create(
	      ppTopologyConnection,
	      pFilterNode,
	      pGraphNode,
	      pTopologyPinFrom,			// DataFlow == OUT, Pin #0
	      pTopologyPinTo,			// DataFlow == IN, Pin #1 - n
	      NULL,
	      NULL);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }

	    // Add the connections to the PinInfos
	    Assert(*ppTopologyConnection);

	    Status = (*ppTopologyConnection)->AddListEnd(
	      &pPinInfoSource->lstTopologyConnection);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }

	    Status = (*ppTopologyConnection)->AddListEnd(
	      &pPinInfoSink->lstTopologyConnection);

	    if(!NT_SUCCESS(Status)) {
		Trap();
		goto exit;
	    }

	    if(pFilterNode != NULL) {
		Assert(pFilterNode);
		Status = AddPinToFilterNode(pTopologyPinFrom, pFilterNode);
		if(!NT_SUCCESS(Status)) {
		    Trap();
		    goto exit;
		}
		Status = AddPinToFilterNode(pTopologyPinTo, pFilterNode);
		if(!NT_SUCCESS(Status)) {
		    Trap();
		    goto exit;
		}
		// Change the connection type to physical
		(*ppTopologyConnection)->ulFlags =
		  TOPC_FLAGS_PHYSICAL_CONNECTION_TYPE;
	    }

	    if(pGraphNode != NULL) {
		Assert(pGraphNode);
		Status = AddPinToGraphNode(
		  pTopologyPinFrom,
		  pGraphNode,
		  *ppTopologyConnection);

		if(!NT_SUCCESS(Status)) {
		    Trap();
		    goto exit;
		}
		Status = AddPinToGraphNode(
		  pTopologyPinTo,
		  pGraphNode,
		  *ppTopologyConnection);

		if(!NT_SUCCESS(Status)) {
		    Trap();
		    goto exit;
		}
		ASSERT(IS_CONNECTION_TYPE(*ppTopologyConnection, GRAPH));
	    }

	} END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CTopologyConnection::Dump(
)
{
    PWSTR pwstrNameFrom = L"";
    PWSTR pwstrNameTo = L"";
    ULONG ulFromNode = MAXULONG;
    ULONG ulToNode = MAXULONG;
    ULONG ulFromPin = MAXULONG;
    ULONG ulToPin = MAXULONG;

    Assert(this);
    if(pTopologyPinFrom != NULL && pTopologyPinTo != NULL &&
       pTopologyPinFrom->pTopologyNode->pFilterNode !=
       pTopologyPinTo->pTopologyNode->pFilterNode) {

	pwstrNameFrom = pTopologyPinFrom->pTopologyNode->
	  pFilterNode->GetFriendlyName(); 
	pwstrNameTo = pTopologyPinTo->pTopologyNode->
	  pFilterNode->GetFriendlyName(); 
    }
    if(ulDebugFlags & (DEBUG_FLAGS_VERBOSE | DEBUG_FLAGS_OBJECT)) {
	dprintf("TC: %08x ulFlags %08x ", this, ulFlags);
	if(IS_CONNECTION_TYPE(this, FILTER)) {
	   dprintf("FILTER");
	}
	if(IS_CONNECTION_TYPE(this, PHYSICAL)) {
	   dprintf("PHYSICAL");
	}
	if(IS_CONNECTION_TYPE(this, GRAPH)) {
	   dprintf("GRAPH");
	}
	dprintf("\n");
	if(pTopologyPinFrom != NULL) {
	    dprintf("    TPFrom: %08x TN %08x #%02x Pin # %d %s\n",
	     pTopologyPinFrom,
	     pTopologyPinFrom->pTopologyNode,
	     pTopologyPinFrom->pTopologyNode->ulRealNodeNumber,
	     pTopologyPinFrom->ulPinNumber,
	     DbgUnicode2Sz(pwstrNameFrom));
	}
	if(pPinInfoFrom != NULL) {
	    dprintf("    PIFrom: %08x Pin # %d\n",
	      pPinInfoFrom,
	      pPinInfoFrom->PinId);
	}
	if(pTopologyPinTo != NULL) {
	    dprintf("    TPTo:   %08x TN %08x #%02x Pin # %d %s\n",
	      pTopologyPinTo,
	      pTopologyPinTo->pTopologyNode,
	      pTopologyPinTo->pTopologyNode->ulRealNodeNumber,
	      pTopologyPinTo->ulPinNumber,
	      DbgUnicode2Sz(pwstrNameTo));
	}
	if(pPinInfoTo != NULL) {
	    dprintf("    PITo:   %08x Pin # %d\n",
	      pPinInfoTo,
	      pPinInfoTo->PinId);
	}
	dprintf("\n");
    }
    else {
	if(pTopologyPinFrom != NULL) {
	    ulFromNode = pTopologyPinFrom->pTopologyNode->ulRealNodeNumber;
	    ulFromPin = pTopologyPinFrom->ulPinNumber;
	}
	if(pTopologyPinTo != NULL) {
	    ulToNode = pTopologyPinTo->pTopologyNode->ulRealNodeNumber;
	    ulToPin = pTopologyPinTo->ulPinNumber;
	}
	if(pPinInfoFrom != NULL) {
	    ulFromPin = pPinInfoFrom->PinId;
	}
	if(pPinInfoTo != NULL) {
	    ulToPin = pPinInfoTo->PinId;
	}
	if(ulFromNode == KSFILTER_NODE) {
	    dprintf("TC: %08x From: Filter P#%-2d %s\n",
	      this,
	      ulFromPin,
	      DbgUnicode2Sz(pwstrNameFrom));
	}
	else {
	    dprintf("TC: %08x From: N#%-2d   P#%-2d %s\n",
	      this,
	      ulFromNode,
	      ulFromPin,
	      DbgUnicode2Sz(pwstrNameFrom));
	}
	if(ulToNode == KSFILTER_NODE) {
	    dprintf("             To:   Filter P#%-2d %s\n",
	      ulToPin,
	      DbgUnicode2Sz(pwstrNameTo));
	}
	else {
	    dprintf("             To:   N#%-2d   P#%-2d %s\n",
	      ulToNode,
	      ulToPin,
	      DbgUnicode2Sz(pwstrNameTo));
	}
    }
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\tp.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   tp.cpp
//
//  Description:
//
//	Topology Pin Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
CTopologyPin::Create(
    PTOPOLOGY_PIN *ppTopologyPin,
    ULONG ulPinNumber,
    PTOPOLOGY_NODE pTopologyNode
)
{
    PTOPOLOGY_PIN pTopologyPin = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Assert(pTopologyNode);
    FOR_EACH_LIST_ITEM(&pTopologyNode->lstTopologyPin, pTopologyPin) {

	if(pTopologyPin->ulPinNumber == ulPinNumber) {
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    pTopologyPin = new TOPOLOGY_PIN(ulPinNumber, pTopologyNode);
    if(pTopologyPin == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    DPF2(70, "CTopologyPin::Create: %08x, TN: %08x",
      pTopologyPin,
      pTopologyNode);
exit:
    *ppTopologyPin = pTopologyPin;
    return(Status);
}

CTopologyPin::CTopologyPin(
    ULONG ulPinNumber,
    PTOPOLOGY_NODE pTopologyNode
)
{
    Assert(this);
    this->ulPinNumber = ulPinNumber;
    this->pTopologyNode = pTopologyNode;
    AddList(&pTopologyNode->lstTopologyPin);
    DPF2(70, "CTopologyPin: %08x, TN: %08x", this, pTopologyNode);
}

CTopologyPin::~CTopologyPin(
)
{
    DPF1(70, "~CTopologyPin: %08x", this);
    Assert(this);
}

//---------------------------------------------------------------------------

#ifdef DEBUG

ENUMFUNC
CTopologyPin::Dump(
)
{
    Assert(this);
    dprintf("TP: %08x TN %08x #%-2d\n",
      this,
      pTopologyNode,
      ulPinNumber);
    lstTopologyConnection.Dump();
    return(STATUS_CONTINUE);
}

#endif

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\tp.h ===
//---------------------------------------------------------------------------
//
//  Module:   		tp.h
//
//  Description:	Topology Pin Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CTopologyPin : public CListSingleItem
{
public:
    CTopologyPin(
	ULONG ulPinNumber,
	PTOPOLOGY_NODE pTopologyNode
    );
    ~CTopologyPin();

    static NTSTATUS
    Create(
	PTOPOLOGY_PIN *ppTopologyPin,
	ULONG ulPinNumber,
	PTOPOLOGY_NODE pTopologyNode
    );

    ENUMFUNC
    Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };
#ifdef DEBUG
    ENUMFUNC Dump();
#endif
    PTOPOLOGY_NODE pTopologyNode;
    ULONG ulPinNumber;
    LIST_DESTROY_TOPOLOGY_CONNECTION lstTopologyConnection;
    DefineSignature(0x20205054);		// TP

} TOPOLOGY_PIN, *PTOPOLOGY_PIN;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<TOPOLOGY_PIN> LIST_TOPOLOGY_PIN;

//---------------------------------------------------------------------------

typedef ListData<TOPOLOGY_PIN> LIST_DATA_TOPOLOGY_PIN;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\util.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   util.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

#define SMALL_BLOCK_SIZE        32

extern KSDATARANGE DataRangeWildCard;
extern KSDATARANGE VirtualPinDataRange;

//===========================================================================
//===========================================================================

#pragma LOCKED_DATA

#ifdef DEBUG
//#define MEMORY_LIST
ULONG ulDebugFlags = 0;
ULONG ulDebugNumber = MAXULONG;
#ifdef UNDER_NT
int SYSAUDIOTraceLevel = 5;
#else
int SYSAUDIOTraceLevel = 50;
#endif
ULONG cAllocMem = 0;
ULONG cAllocMemSmall = 0;
ULONG cAllocMem64 = 0;
ULONG cAllocMem128 = 0;
ULONG cbMemoryUsage = 0;
#endif

//===========================================================================
//===========================================================================

LIST_ENTRY glehQueueWorkList;
KSPIN_LOCK gSpinLockQueueWorkList;
WORK_QUEUE_ITEM gWorkItem;
LONG gcQueueWorkList = 0;
KMUTEX gMutex;
PKSWORKER gWorkerObject = NULL;
PKSWORKER gCriticalWorkerObject = NULL;
#ifdef USE_ZONES
ZONE_HEADER gZone;
#endif
#ifdef MEMORY_LIST
LIST_ENTRY gleMemoryHead;
KSPIN_LOCK gSpinLockMemoryHead;
#endif

#pragma PAGEABLE_DATA

//===========================================================================
//===========================================================================

#pragma INIT_CODE
#pragma INIT_DATA

NTSTATUS
InitializeUtil()
{
    NTSTATUS Status = STATUS_SUCCESS;
#ifdef USE_ZONES
    PVOID pInitial = NULL;

    pInitial = ExAllocatePoolWithTag(PagedPool, 4096, 0x41535953);
    if(pInitial == NULL) {
        Trap();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    Status = ExInitializeZone(&gZone, SMALL_BLOCK_SIZE, pInitial, 4096);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
#endif

#ifdef MEMORY_LIST
    InitializeListHead(&gleMemoryHead);
    KeInitializeSpinLock(&gSpinLockMemoryHead);
#endif

#ifdef DEBUG
#ifndef UNDER_NT
#ifdef _X86_
    InitializeDebug();
#endif
#endif
#endif
    KeInitializeSpinLock(&gSpinLockQueueWorkList);
    InitializeListHead(&glehQueueWorkList);
    ExInitializeWorkItem(
      &gWorkItem,
      CQueueWorkListData::AsyncWorker,
      NULL);
    //
    // Note... if we fail during preparation, the DriverUnload() routine
    // calls the DeinitializeUtil() function which handles the clean up.
    //
    Status = KsRegisterWorker(DelayedWorkQueue, &gWorkerObject);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
    Status = KsRegisterWorker(CriticalWorkQueue, &gCriticalWorkerObject);
    if(!NT_SUCCESS(Status)) {
        Trap();
        goto exit;
    }
exit:
#ifdef USE_ZONES
    if(!NT_SUCCESS(Status)) {
	if(pInitial != NULL) {
	    //
	    // Make sure UninitializeMemory doesn't also try to free this.
	    //
	    gZone.SegmentList.Next = NULL;
	    //
	    // Free initial zone page if failure
	    //
	    ExFreePool(pInitial);
	}
    }
#endif
    return(Status);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID
UninitializeUtil()
{
    if(gWorkerObject != NULL) {
        KsUnregisterWorker(gWorkerObject);
        gWorkerObject = NULL;
    }
    if(gCriticalWorkerObject != NULL) {
        KsUnregisterWorker(gCriticalWorkerObject);
        gCriticalWorkerObject = NULL;
    }
}

VOID
UninitializeMemory()
{
#ifdef USE_ZONES
    PSINGLE_LIST_ENTRY psle, psleNext;

    psle = gZone.SegmentList.Next;
    while(psle != NULL) {
        psleNext = psle->Next;
        ExFreePool(psle);
        psle = psleNext;
    }
#endif
    ASSERT(cbMemoryUsage == 0);
}

NTSTATUS
DispatchInvalidDeviceRequest(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
)
{
    return KsDispatchInvalidDeviceRequest(pdo,pIrp);
}

BOOLEAN
DispatchFastIoDeviceControlFailure(
   IN PFILE_OBJECT FileObject,
   IN BOOLEAN Wait,
   IN PVOID InputBuffer OPTIONAL,
   IN ULONG InputBufferLength,
   OUT PVOID OutputBuffer OPTIONAL,
   IN ULONG OutputBufferLength,
   IN ULONG IoControlCode,
   OUT PIO_STATUS_BLOCK IoStatus,
   IN PDEVICE_OBJECT DeviceObject
)
{
    return KsDispatchFastIoDeviceControlFailure(
      FileObject,
      Wait,
      InputBuffer,
      InputBufferLength,
      OutputBuffer,
      OutputBufferLength,
      IoControlCode,
      IoStatus,
      DeviceObject);
}

BOOLEAN
DispatchFastReadFailure(
   IN PFILE_OBJECT FileObject,
   IN PLARGE_INTEGER FileOffset,
   IN ULONG Length,
   IN BOOLEAN Wait,
   IN ULONG LockKey,
   OUT PVOID Buffer,
   OUT PIO_STATUS_BLOCK IoStatus,
   IN PDEVICE_OBJECT DeviceObject
)
{
    return KsDispatchFastReadFailure(
      FileObject,
      FileOffset,
      Length,
      Wait,
      LockKey,
      Buffer,
      IoStatus,
      DeviceObject);
}

BOOL
CompareDataRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
)
{
    KSDATARANGE_AUDIO DataRangeAudioIntersection;

    if(CompareDataRangeGuids(pDataRange1, pDataRange2)) {

        //
        // See if there is a valid intersection
        //
	if(DataIntersectionAudio(
          (PKSDATARANGE_AUDIO)pDataRange1,
          (PKSDATARANGE_AUDIO)pDataRange2,
          &DataRangeAudioIntersection)) {
	    return(TRUE);
        }
        if(pDataRange1 == &DataRangeWildCard ||
           pDataRange2 == &DataRangeWildCard ||
           pDataRange1 == &VirtualPinDataRange ||
           pDataRange2 == &VirtualPinDataRange) {
            return(TRUE);
        }
        return(FALSE);
    }
    return(FALSE);
}

BOOL DataIntersectionRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2,
    PKSDATARANGE pDataRangeIntersection
)
{
    // Pick up pDataRange1 values by default.
    *pDataRangeIntersection = *pDataRange1;

    if(IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) ||
       IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->MajorFormat = pDataRange2->MajorFormat;
    }
    else if(!IsEqualGUID(
      &pDataRange2->MajorFormat,
      &KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) ||
       IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD)) {
        pDataRangeIntersection->SubFormat = pDataRange2->SubFormat;
    }
    else if(!IsEqualGUID(
      &pDataRange2->SubFormat,
      &KSDATAFORMAT_SUBTYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) ||
       IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        pDataRangeIntersection->Specifier = pDataRange2->Specifier;
    }
    else if(!IsEqualGUID(
      &pDataRange2->Specifier,
      &KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        return FALSE;
    }
    pDataRangeIntersection->Reserved = 0; // Must be zero
    return(TRUE);
}

BOOL
DataIntersectionAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio1,
    PKSDATARANGE_AUDIO pDataRangeAudio2,
    PKSDATARANGE_AUDIO pDataRangeAudioIntersection
)
{
    if((IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
       IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND)) &&
       IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WILDCARD)) {

        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio1->MaximumChannels;
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio1->MaximumSampleFrequency;
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio1->MinimumSampleFrequency;
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio1->MaximumBitsPerSample;
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio1->MinimumBitsPerSample;
        return(TRUE);
    }
    if(IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WILDCARD) &&
      (IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
       IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND))) {

        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio2->MaximumChannels;
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio2->MaximumSampleFrequency;
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio2->MinimumSampleFrequency;
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio2->MaximumBitsPerSample;
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio2->MinimumBitsPerSample;
        return(TRUE);
    }
    if((IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
       IsEqualGUID(
      &pDataRangeAudio1->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND)) &&
      (IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
       IsEqualGUID(
      &pDataRangeAudio2->DataRange.Specifier,
      &KSDATAFORMAT_SPECIFIER_DSOUND))) {

	if(pDataRangeAudio1->MaximumChannels <
	   pDataRangeAudio2->MaximumChannels) {
	    pDataRangeAudioIntersection->MaximumChannels =
	      pDataRangeAudio1->MaximumChannels;
	}
	else {
	    pDataRangeAudioIntersection->MaximumChannels =
	      pDataRangeAudio2->MaximumChannels;
	}

	if(pDataRangeAudio1->MaximumSampleFrequency <
	   pDataRangeAudio2->MaximumSampleFrequency) {
	    pDataRangeAudioIntersection->MaximumSampleFrequency =
	      pDataRangeAudio1->MaximumSampleFrequency;
	}
	else {
	    pDataRangeAudioIntersection->MaximumSampleFrequency =
	      pDataRangeAudio2->MaximumSampleFrequency;
	}
	if(pDataRangeAudio1->MinimumSampleFrequency >
	   pDataRangeAudio2->MinimumSampleFrequency) {
	    pDataRangeAudioIntersection->MinimumSampleFrequency =
	      pDataRangeAudio1->MinimumSampleFrequency;
	}
	else {
	    pDataRangeAudioIntersection->MinimumSampleFrequency =
	      pDataRangeAudio2->MinimumSampleFrequency;
	}
	if(pDataRangeAudioIntersection->MaximumSampleFrequency <
	   pDataRangeAudioIntersection->MinimumSampleFrequency ) {
	    DPF2(110, "DataIntersectionAudio: SR %08x %08x",
	      pDataRangeAudio1,
	      pDataRangeAudio2);
	    return(FALSE);
	}

	if(pDataRangeAudio1->MaximumBitsPerSample <
	   pDataRangeAudio2->MaximumBitsPerSample) {
	    pDataRangeAudioIntersection->MaximumBitsPerSample =
	      pDataRangeAudio1->MaximumBitsPerSample;
	}
	else {
	    pDataRangeAudioIntersection->MaximumBitsPerSample =
	      pDataRangeAudio2->MaximumBitsPerSample;
	}
	if(pDataRangeAudio1->MinimumBitsPerSample >
	   pDataRangeAudio2->MinimumBitsPerSample) {
	    pDataRangeAudioIntersection->MinimumBitsPerSample =
	      pDataRangeAudio1->MinimumBitsPerSample;
	}
	else {
	    pDataRangeAudioIntersection->MinimumBitsPerSample =
	      pDataRangeAudio2->MinimumBitsPerSample;
	}
	if(pDataRangeAudioIntersection->MaximumBitsPerSample <
	   pDataRangeAudioIntersection->MinimumBitsPerSample ) {
	    DPF2(110, "DataIntersectionAudio: BPS %08x %08x",
	      pDataRangeAudio1,
	      pDataRangeAudio2);
	    return(FALSE);
	}
	return(TRUE);
    }
    return(FALSE);
}

BOOL
CompareDataRangeExact(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
)
{
    if(pDataRange1 == NULL || pDataRange2 == NULL) {
        Trap();
        return(FALSE);
    }
    ASSERT(pDataRange1->Reserved == pDataRange2->Reserved);
    if(pDataRange1->FormatSize == pDataRange2->FormatSize) {
        return(!memcmp(pDataRange1, pDataRange2, pDataRange1->FormatSize));
    }
    return(FALSE);
}

BOOL
CompareDataRangeGuids(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
)
{
    if(pDataRange1 == NULL || pDataRange2 == NULL) {
        Trap();
        return(FALSE);
    }
    if((IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) ||
      IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
      IsEqualGUID(&pDataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) &&

     (IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) ||
      IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
      IsEqualGUID(&pDataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD)) &&

     (IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) ||
      IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
      IsEqualGUID(&pDataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD))) {
        return(TRUE);
    }
    return(FALSE);
}

BOOL
CompareIdentifier(
    PKSIDENTIFIER pIdentifier1,
    PKSIDENTIFIER pIdentifier2
)
{
    if(pIdentifier1 == NULL || pIdentifier2 == NULL) {
        Trap();
        return(FALSE);
    }
    if(pIdentifier1 == INTERNAL_WILDCARD ||
       pIdentifier2 == INTERNAL_WILDCARD) {
        return(TRUE);
    }
    if(IsEqualGUID(&pIdentifier1->Set, &pIdentifier2->Set) &&
      (pIdentifier1->Id == pIdentifier2->Id)) {
        return(TRUE);
    }
    return(FALSE);
}

PWAVEFORMATEXTENSIBLE 
GetWaveFormatExtensible(
    PKSPIN_CONNECT pPinConnect
)
{
    ASSERT(pPinConnect);

    PWAVEFORMATEXTENSIBLE pWaveFormatExt = NULL;
    PKSDATAFORMAT pDataFormat = (PKSDATAFORMAT) (pPinConnect + 1);

    if(IsEqualGUID(&pDataFormat->Specifier, &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        pWaveFormatExt = (PWAVEFORMATEXTENSIBLE)
          &PKSDATAFORMAT_WAVEFORMATEX(pDataFormat)->WaveFormatEx;
    }
    else if(IsEqualGUID(&pDataFormat->Specifier, &KSDATAFORMAT_SPECIFIER_DSOUND)) {
        pWaveFormatExt = (PWAVEFORMATEXTENSIBLE)
          &PKSDATAFORMAT_DSOUND(pDataFormat)->BufferDesc.WaveFormatEx;
    }
    else {
        DPF(5, "Unknown format specifier");
    }

    return pWaveFormatExt;
} // GetWaveFormatExtensible

void
ModifyPinConnect(
    PKSPIN_CONNECT pPinConnect,
    WORD  nChannels
)
{
    ASSERT(pPinConnect);

    PKSDATAFORMAT           pDataFormat = (PKSDATAFORMAT) (pPinConnect + 1);
    PWAVEFORMATEXTENSIBLE   pWaveFormatExt = NULL;

    pWaveFormatExt = GetWaveFormatExtensible(pPinConnect);
    if (NULL != pWaveFormatExt) {
        if (IsEqualGUID(&pDataFormat->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM)) {
            
            pWaveFormatExt->Format.nChannels = nChannels;
            pWaveFormatExt->Format.nBlockAlign = 
                (pWaveFormatExt->Format.wBitsPerSample / 8) * 
                pWaveFormatExt->Format.nChannels;
            pWaveFormatExt->Format.nAvgBytesPerSec =
                pWaveFormatExt->Format.nSamplesPerSec *
                pWaveFormatExt->Format.nBlockAlign;

            if (WAVE_FORMAT_EXTENSIBLE == pWaveFormatExt->Format.wFormatTag) {
                if (1 == nChannels) {
                    pWaveFormatExt->dwChannelMask = SPEAKER_FRONT_CENTER;
                }
                else if (2 == nChannels) {
                    pWaveFormatExt->dwChannelMask = 
                        SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
                }
            }
        }
        else {
            DPF(5, "ModifyPinConnect : Not touching NON-PCM formats.");            
        }
    }
} // ModifyPinConnect

NTSTATUS
OpenDevice(
    PWSTR pwstrDevice,
    PHANDLE pHandle
)
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeDeviceString, pwstrDevice);

    InitializeObjectAttributes(
      &ObjectAttributes,
      &UnicodeDeviceString,
      OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
      NULL,
      NULL);

    return(ZwCreateFile(pHandle,
      GENERIC_READ | GENERIC_WRITE,
      &ObjectAttributes,
      &IoStatusBlock,
      NULL,
      FILE_ATTRIBUTE_NORMAL,
      0,
      FILE_OPEN,
      0,
      NULL,
      0));
}

NTSTATUS
GetPinProperty(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    ULONG cbProperty,
    PVOID pProperty
)
{
    ULONG BytesReturned;
    KSP_PIN Pin;
    NTSTATUS Status;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = PropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinId;
    Pin.Reserved = 0;

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Pin,
      sizeof(Pin),
      pProperty,
      cbProperty,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF2(10,
	  "GetPinProperty: id %d p %d KsSynchronousIoControlDevice FAILED",
	  PropertyId,
	  PinId);
        goto exit;
    }
    ASSERT(BytesReturned == cbProperty);
exit:
    return(Status);
}

NTSTATUS
PinConnectionProperty(
    PFILE_OBJECT pFileObject,
    ULONG ulPropertyId,
    ULONG ulFlags,
    ULONG cbProperty,
    PVOID pProperty
)
{
    KSIDENTIFIER Property;
    ULONG BytesReturned;
    NTSTATUS Status;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = ulPropertyId;
    Property.Flags = ulFlags;

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Property,
      sizeof(Property),
      pProperty,
      cbProperty,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF(10, "SetPinConnectionProperty: KsSynchronousIoControlDevice Failed");
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
GetPinPropertyEx(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    PVOID *ppProperty
)
{
    ULONG BytesReturned;
    NTSTATUS Status;
    KSP_PIN Pin;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = PropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinId;
    Pin.Reserved = 0;

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Pin,
      sizeof(KSP_PIN),
      NULL,
      0,
      &BytesReturned);

    ASSERT(!NT_SUCCESS(Status));
    if(Status != STATUS_BUFFER_OVERFLOW) {
        goto exit;
    }
    if(BytesReturned == 0) {
        *ppProperty = NULL;
        Status = STATUS_SUCCESS;
        goto exit;
    }

    *ppProperty = new BYTE[BytesReturned];
    if(*ppProperty == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &Pin,
      sizeof(KSP_PIN),
      *ppProperty,
      BytesReturned,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        Trap();
        delete *ppProperty;
        *ppProperty = NULL;
        goto exit;
    }
exit:
    if(Status == STATUS_PROPSET_NOT_FOUND ||
       Status == STATUS_NOT_FOUND) {
        Status = STATUS_SUCCESS;
        *ppProperty = NULL;
    }
    return(Status);
}

NTSTATUS
GetPinProperty2(
    PFILE_OBJECT pFileObject,
    ULONG ulPropertyId,
    ULONG ulPinId,
    ULONG cbInput,
    PVOID pInputData,
    PVOID *ppPropertyOutput
)
{
    ULONG cbPropertyInput = sizeof(KSP_PIN);
    ULONG BytesReturned;
    NTSTATUS Status;
    PKSP_PIN pPin;

    cbPropertyInput += cbInput;
    pPin = (PKSP_PIN)new BYTE[cbPropertyInput];
    if(pPin == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    pPin->Property.Set = KSPROPSETID_Pin;
    pPin->Property.Id = ulPropertyId;
    pPin->Property.Flags = KSPROPERTY_TYPE_GET;
    pPin->PinId = ulPinId;
    pPin->Reserved = 0;

    if(pInputData != NULL) {
        memcpy(pPin + 1, pInputData, cbInput);
    }

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pPin,
      cbPropertyInput,
      NULL,
      0,
      &BytesReturned);

    ASSERT(!NT_SUCCESS(Status));
    if(Status != STATUS_BUFFER_OVERFLOW) {
        DPF(10, "GetPinProperty2: KsSynchronousIoControlDevice 1 Failed");
        goto exit;
    }

    if(BytesReturned == 0) {
        *ppPropertyOutput = NULL;
        Status = STATUS_SUCCESS;
        goto exit;
    }
    *ppPropertyOutput = new BYTE[BytesReturned];
    if(*ppPropertyOutput == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pPin,
      cbPropertyInput,
      *ppPropertyOutput,
      BytesReturned,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF(10, "GetPinProperty2: KsSynchronousIoControlDevice 2 Failed");
        delete *ppPropertyOutput;
        goto exit;
    }
exit:
    delete [] pPin;
    if(!NT_SUCCESS(Status)) {
        *ppPropertyOutput = NULL;
        if(Status == STATUS_PROPSET_NOT_FOUND ||
           Status == STATUS_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
    }
    return(Status);
}

NTSTATUS
GetProperty(
    PFILE_OBJECT pFileObject,
    CONST GUID *pguidPropertySet,
    ULONG ulPropertyId,
    ULONG cbInput,
    PVOID pInputData,
    PVOID *ppPropertyOutput
)
{
    ULONG BytesReturned;
    ULONG cbPropertyInput = sizeof(KSPROPERTY);
    PKSPROPERTY pPropertyInput;
    NTSTATUS Status;

    cbPropertyInput += cbInput;

    pPropertyInput = (PKSPROPERTY)new BYTE[cbPropertyInput];
    if(pPropertyInput == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }
    pPropertyInput->Set = *pguidPropertySet;
    pPropertyInput->Id = ulPropertyId;
    pPropertyInput->Flags = KSPROPERTY_TYPE_GET;

    if(pInputData != NULL) {
        Trap();
        memcpy(pPropertyInput + 1, pInputData, cbInput);
    }

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pPropertyInput,
      cbPropertyInput,
      NULL,
      0,
      &BytesReturned);

    ASSERT(!NT_SUCCESS(Status));
    if(Status != STATUS_BUFFER_OVERFLOW) {
        DPF(10, "GetProperty: KsSynchronousIoControlDevice 1 Failed");
        goto exit;
    }

    if(BytesReturned == 0) {
        *ppPropertyOutput = NULL;
        Status = STATUS_SUCCESS;
        goto exit;
    }
    *ppPropertyOutput = new BYTE[BytesReturned];
    if(*ppPropertyOutput == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      pPropertyInput,
      cbPropertyInput,
      *ppPropertyOutput,
      BytesReturned,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
        DPF(10, "GetProperty: KsSynchronousIoControlDevice 2 Failed");
        delete *ppPropertyOutput;
        goto exit;
    }
exit:
    delete [] pPropertyInput;
    if(!NT_SUCCESS(Status)) {
        *ppPropertyOutput = NULL;
        if(Status == STATUS_PROPSET_NOT_FOUND ||
           Status == STATUS_NOT_FOUND) {
            Status = STATUS_SUCCESS;
        }
    }
    return(Status);
}

CQueueWorkListData::CQueueWorkListData(
    NTSTATUS (*Function)(PVOID Reference1, PVOID Reference2),
    PVOID Reference1,
    PVOID Reference2
)
{
    this->Function = Function;
    this->Reference1 = Reference1;
    this->Reference2 = Reference2;
}

NTSTATUS
CQueueWorkListData::QueueAsyncList(
)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ExInterlockedInsertTailList(
      &glehQueueWorkList,
      &leNext,
      &gSpinLockQueueWorkList);

    // Schedule the workitem, if it is not already running.
    // 
    if(InterlockedIncrement(&gcQueueWorkList) == 1) {
        ntStatus = KsQueueWorkItem(gWorkerObject, &gWorkItem);
    }

    return ntStatus;
}

VOID
CQueueWorkListData::AsyncWorker(
    IN OUT PVOID pReference
)
{
    PQUEUE_WORK_LIST_DATA pQueueWorkListData;
    PLIST_ENTRY ple;

    ::GrabMutex();

    while(
      (ple = ExInterlockedRemoveHeadList(
      &glehQueueWorkList,
      &gSpinLockQueueWorkList)) != NULL) {
        pQueueWorkListData =
          CONTAINING_RECORD(ple, QUEUE_WORK_LIST_DATA, leNext);

        Assert(pQueueWorkListData);
        (*pQueueWorkListData->Function)
          (pQueueWorkListData->Reference1,
           pQueueWorkListData->Reference2);

        delete pQueueWorkListData;

        if(InterlockedDecrement(&gcQueueWorkList) == 0) {
            break;
        }
    }
    ::ReleaseMutex();
}

NTSTATUS
QueueWorkList(
    NTSTATUS (*Function)(PVOID Reference1, PVOID Reference2),
    PVOID Reference1,
    PVOID Reference2
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PQUEUE_WORK_LIST_DATA pQueueWorkListData = NULL;

    pQueueWorkListData = new QUEUE_WORK_LIST_DATA(
       Function,
       Reference1,
       Reference2);

    if(pQueueWorkListData == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    Status = pQueueWorkListData->QueueAsyncList();
    
exit:
    return(Status);
}

VOID 
GetDefaultOrder(
    ULONG fulType,
    PULONG pulOrder
)
{
    if(fulType != 0) {
	if(*pulOrder == ORDER_NONE) {
	    if(fulType & FILTER_TYPE_ENDPOINT) {
		*pulOrder = ORDER_ENDPOINT;
		return;
	    }
	    if(fulType & FILTER_TYPE_VIRTUAL) {
		*pulOrder = ORDER_VIRTUAL;
		return;
	    }
	    if(fulType & FILTER_TYPE_GFX) {
		*pulOrder = ORDER_GFX;
		return;
	    }
	    if(fulType & FILTER_TYPE_INTERFACE_TRANSFORM) {
		*pulOrder = ORDER_INTERFACE_TRANSFORM;
		return;
	    }
	    if(fulType & FILTER_TYPE_AEC) {
		*pulOrder = ORDER_AEC;
		return;
	    }
	    if(fulType & FILTER_TYPE_MIC_ARRAY_PROCESSOR) {
		*pulOrder = ORDER_MIC_ARRAY_PROCESSOR;
		return;
	    }
	    if(fulType & FILTER_TYPE_SPLITTER) {
		*pulOrder = ORDER_SPLITTER;
		return;
	    }
	    if(fulType & FILTER_TYPE_MIXER) {
		*pulOrder = ORDER_MIXER;
		return;
	    }
	    if(fulType & FILTER_TYPE_SYNTHESIZER) {
		*pulOrder = ORDER_SYNTHESIZER;
		return;
	    }
	    if(fulType & FILTER_TYPE_DRM_DESCRAMBLE) {
		*pulOrder = ORDER_DRM_DESCRAMBLE;
		return;
	    }
	    if(fulType & FILTER_TYPE_DATA_TRANSFORM) {
		*pulOrder = ORDER_DATA_TRANSFORM;
		return;
	    }
	}
    }
}

//===========================================================================
// ISSUE-2001/03/06-alpers
// This is a temporary solution for GFX glitching problem.
// In BlackComb time-frame after the right fix is implemented, we should delete
// this definition and references to it.
// 
#define STATIC_KSPROPSETID_Frame\
    0xA60D8368L, 0x5324, 0x4893, 0xB0, 0x20, 0xC4, 0x31, 0xA5, 0x0B, 0xCB, 0xE3
DEFINE_GUIDSTRUCT("A60D8368-5324-4893-B020-C431A50BCBE3", KSPROPSETID_Frame);
#define KSPROPSETID_Frame DEFINE_GUIDNAMED(KSPROPSETID_Frame)

typedef enum {
    KSPROPERTY_FRAME_HOLDING
} KSPROPERTY_FRAME;
//===========================================================================

NTSTATUS
SetKsFrameHolding(
    PFILE_OBJECT pFileObject
)
{
    KSPROPERTY      Property;
    NTSTATUS        ntStatus;
    ULONG           ulBytesReturned;
    BOOL            fFrameEnable = TRUE;

    ASSERT(pFileObject);

    //
    // Form the IOCTL packet & send it down
    //
    Property.Set    = KSPROPSETID_Frame;
    Property.Id     = KSPROPERTY_FRAME_HOLDING;
    Property.Flags  = KSPROPERTY_TYPE_SET;

    DPF(60,"Sending KSPROPERTY_FRAME_HOLDING");

    //
    // We actually throw away the status we got back from the device.
    //
    ntStatus = KsSynchronousIoControlDevice(pFileObject,
                                            KernelMode,
                                            IOCTL_KS_PROPERTY,
                                            &Property,
                                            sizeof(Property),
                                            &fFrameEnable,
                                            sizeof(fFrameEnable),
                                            &ulBytesReturned);
    DPF1(60,"KSPROPERTY_FRAME_HOLDING %s", 
        (NT_SUCCESS(ntStatus)) ? "Succeeded" : "Failed");

    return ntStatus;
} // SetKsFrameHolding

//---------------------------------------------------------------------------

#pragma LOCKED_CODE

//
//  Zero initializes the block.
//

void * __cdecl operator new( size_t size )
{
    PVOID p;
    ASSERT(size != 0);
    ASSERT(size < 0x10000);

#if defined(USE_ZONES) || defined(DEBUG)
    size += sizeof(ULONGLONG);
#endif

#ifdef MEMORY_LIST
    size += sizeof(LIST_ENTRY);
#endif

#ifdef USE_ZONES
    if(size <= SMALL_BLOCK_SIZE) {
        if(ExIsFullZone(&gZone)) {
            p = ExAllocatePoolWithTag(PagedPool, 4096, 0x41535953);     // SYSA
            if(p != NULL) {
                if(!NT_SUCCESS(ExExtendZone(&gZone, p, 4096))) {
                    Trap();
		    ExFreePool(p);
                    DPF(5, "ExExtendZone FAILED");
		    return(NULL);
                }
            }
        }
        p = ExAllocateFromZone(&gZone);
    }
    else {
        p = ExAllocatePoolWithTag(PagedPool, size, 0x41535953);		// SYSA
    }
#else
    p = ExAllocatePoolWithTag(PagedPool, size, 0x41535953);		// SYSA
#endif
    if(p != NULL) {
	RtlZeroMemory(p, size);

    #if defined(USE_ZONES) || defined(DEBUG)
	*((PULONG)p) = size;
	p = ((PULONGLONG)p) + 1;
    #endif

    #ifdef MEMORY_LIST
	ExInterlockedInsertTailList(
	  &gleMemoryHead,
	  ((PLIST_ENTRY)p),
	  &gSpinLockMemoryHead);
	p = ((PLIST_ENTRY)p) + 1;
    #endif

    #ifdef DEBUG
	cbMemoryUsage += size;
	++cAllocMem;
	if(size <= SMALL_BLOCK_SIZE) {
	    ++cAllocMemSmall;
	}
	else if(size <= 64) {
	    ++cAllocMem64;
	}
	else if(size <= 128) {
	    ++cAllocMem128;
	}
    #endif
    }
    AssertAligned(p);
    return(p);
}

//
// Frees memory
//

void __cdecl operator delete( void *p )
{
    if(p != NULL) {

        #ifdef MEMORY_LIST
        KIRQL OldIrql;
        p = ((PLIST_ENTRY)p) - 1;
        KeAcquireSpinLock(&gSpinLockMemoryHead, &OldIrql);
        RemoveEntryList((PLIST_ENTRY)p);
        KeReleaseSpinLock(&gSpinLockMemoryHead, OldIrql);
        #endif

        #if defined(USE_ZONES) || defined(DEBUG)
        ULONG size;
        AssertAligned(p);
        p = ((PULONGLONG)p) - 1;
        size = *((PULONG)p);
        #endif

        #ifdef DEBUG
        cbMemoryUsage -= size;
        --cAllocMem;
        if(size <= SMALL_BLOCK_SIZE) {
            --cAllocMemSmall;
        }
        else if(size <= 64) {
            --cAllocMem64;
        }
        else if(size <= 128) {
            --cAllocMem128;
        }
        #endif

        #ifdef USE_ZONES
        if(size <= SMALL_BLOCK_SIZE) {
            ExFreeToZone(&gZone, p);
        }
        else {
            ExFreePool(p);
        }
        #else
        ExFreePool(p);
        #endif
    }
}

#pragma PAGEABLE_CODE

//---------------------------------------------------------------------------

#ifdef DEBUG

VOID
DumpPinConnect(
    LONG Level,
    PKSPIN_CONNECT pPinConnect
)
{
    DPF1(Level, "    PinId: %d", pPinConnect->PinId);
    DPF1(Level, "Interface: %s", DbgIdentifier2Sz(&pPinConnect->Interface));
    DPF1(Level, "   Medium: %s", DbgIdentifier2Sz(&pPinConnect->Medium));
    DumpDataFormat(Level, ((PKSDATAFORMAT)(pPinConnect + 1)));
}

VOID
DumpDataFormat(
    LONG Level,
    PKSDATAFORMAT pDataFormat
)
{
    DPF2(Level, 
      " FormatSize: %02x Flags: %08x", 
      pDataFormat->FormatSize,
      pDataFormat->Flags);
    DPF2(Level, 
      " SampleSize: %02x Reserved: %08x", 
      pDataFormat->SampleSize,
      pDataFormat->Reserved);
    DPF1(Level, "MajorFormat: %s", DbgGuid2Sz(&pDataFormat->MajorFormat));
    DPF1(Level, "  SubFormat: %s", DbgGuid2Sz(&pDataFormat->SubFormat));
    DPF1(Level, "  Specifier: %s", DbgGuid2Sz(&pDataFormat->Specifier));

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      &pDataFormat->Specifier)) {

        DumpWaveFormatEx(
	  Level,
	  "WaveFmtEx",
          &((PKSDATAFORMAT_WAVEFORMATEX)pDataFormat)->WaveFormatEx);
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      &pDataFormat->Specifier)) {

        DumpWaveFormatEx(
	  Level,
	  "DSOUND",
	  &((PKSDATAFORMAT_DSOUND)pDataFormat)->BufferDesc.WaveFormatEx);
    }
}

VOID
DumpWaveFormatEx(
    LONG Level,
    PSZ pszSpecifier,
    WAVEFORMATEX *pWaveFormatEx
)
{
    DPF8(Level, "%s T %u SR %u CH %u BPS %u ABPS %u BA %u cb %u",
      pszSpecifier,
      pWaveFormatEx->wFormatTag,
      pWaveFormatEx->nSamplesPerSec,
      pWaveFormatEx->nChannels,
      pWaveFormatEx->wBitsPerSample,
      pWaveFormatEx->nAvgBytesPerSec,
      pWaveFormatEx->nBlockAlign,
      pWaveFormatEx->cbSize);

    if(pWaveFormatEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
	DPF3(Level, "VBPS %u CHMASK %08x %s",
	  ((PWAVEFORMATEXTENSIBLE)pWaveFormatEx)->Samples.wValidBitsPerSample,
	  ((PWAVEFORMATEXTENSIBLE)pWaveFormatEx)->dwChannelMask,
	  DbgGuid2Sz(&((PWAVEFORMATEXTENSIBLE)pWaveFormatEx)->SubFormat));
    }
}

VOID
DumpDataRange(
    LONG Level,
    PKSDATARANGE_AUDIO pDataRangeAudio
)
{
    DPF2(Level,
      " FormatSize: %02x Flags: %08x", 
      pDataRangeAudio->DataRange.FormatSize,
      pDataRangeAudio->DataRange.Flags);
    DPF2(Level,
      " SampleSize: %02x Reserved: %08x", 
      pDataRangeAudio->DataRange.SampleSize,
      pDataRangeAudio->DataRange.Reserved);
    DPF1(Level, "MajorFormat: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.MajorFormat));
    DPF1(Level, "  SubFormat: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.SubFormat));
    DPF1(Level, "  Specifier: %s",
      DbgGuid2Sz(&pDataRangeAudio->DataRange.Specifier));

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      &pDataRangeAudio->DataRange.Specifier)) {

	DPF5(Level, "WaveFmtEx: MaxCH %d MaxSR %u MinSR %u MaxBPS %u MinBPS %u",
          pDataRangeAudio->MaximumChannels,
          pDataRangeAudio->MinimumSampleFrequency,
          pDataRangeAudio->MaximumSampleFrequency,
          pDataRangeAudio->MinimumBitsPerSample,
          pDataRangeAudio->MaximumBitsPerSample);
    }

    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      &pDataRangeAudio->DataRange.Specifier)) {

	DPF5(Level, "DSOUND:    MaxCH %d MaxSR %u MinSR %u MaxBPS %u MinBPS %u",
          pDataRangeAudio->MaximumChannels,
          pDataRangeAudio->MinimumSampleFrequency,
          pDataRangeAudio->MaximumSampleFrequency,
          pDataRangeAudio->MinimumBitsPerSample,
          pDataRangeAudio->MaximumBitsPerSample);

    }
}

VOID
DumpDataRangeAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio
)
{
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      &pDataRangeAudio->DataRange.Specifier) ||
       IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      &pDataRangeAudio->DataRange.Specifier)) {
	dprintf("    MaxCH %d MaxSR %u MinSR %u MaxBPS %u MinBPS %u\n",
	  pDataRangeAudio->MaximumChannels,
	  pDataRangeAudio->MaximumSampleFrequency,
	  pDataRangeAudio->MinimumSampleFrequency,
	  pDataRangeAudio->MaximumBitsPerSample,
	  pDataRangeAudio->MinimumBitsPerSample);
    }
}

VOID
DumpfulType(
    ULONG fulType
)
{
    if(fulType & FILTER_TYPE_AUDIO) {
	dprintf("AUDIO ");
    }
    if(fulType & FILTER_TYPE_GFX) {
	dprintf("GFX ");
    }
    if(fulType & FILTER_TYPE_TOPOLOGY) {
	dprintf("TOPOLOGY ");
    }
    if(fulType & FILTER_TYPE_BRIDGE) {
	dprintf("BRIDGE ");
    }
    if(fulType & FILTER_TYPE_RENDERER) {
	dprintf("RENDERER ");
    }
    if(fulType & FILTER_TYPE_CAPTURER) {
	dprintf("CAPTURER ");
    }
    if(fulType & FILTER_TYPE_MIXER) {
	dprintf("MIXER ");
    }
    if(fulType & FILTER_TYPE_SPLITTER) {
	dprintf("SPLITTER ");
    }
    if(fulType & FILTER_TYPE_SYNTHESIZER) {
	dprintf("SYNTHESIZER ");
    }
    if(fulType & FILTER_TYPE_DRM_DESCRAMBLE) {
	dprintf("DRM_DESCRAMBLE ");
    }
    if(fulType & FILTER_TYPE_DATA_TRANSFORM) {
	dprintf("DATA_TRANSFORM ");
    }
    if(fulType & FILTER_TYPE_AEC) {
	dprintf("AEC ");
    }
    if(fulType & FILTER_TYPE_MIC_ARRAY_PROCESSOR) {
	dprintf("MIC_ARRAY_PROCESSOR ");
    }
    if(fulType & FILTER_TYPE_COMMUNICATION_TRANSFORM) {
	dprintf("COMMUNICATION_TRANSFORM ");
    }
    if(fulType & FILTER_TYPE_INTERFACE_TRANSFORM) {
	dprintf("INTERFACE_TRANSFORM ");
    }
    if(fulType & FILTER_TYPE_MEDIUM_TRANSFORM) {
	dprintf("MEDIUM_TRANSFORM ");
    }
    if(fulType & FILTER_TYPE_VIRTUAL) {
	dprintf("VIRTUAL ");
    }
}

ENUMFUNC
DumpListData(
    PVOID pData
)
{
    dprintf(" %08x", pData);
    return(STATUS_CONTINUE);
}

PSZ
DbgUnicode2Sz(
    PWSTR pwstr
)
{
    static char sz[256];
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    sz[0] = '\0';
    if(pwstr != NULL) {
        RtlInitUnicodeString(&UnicodeString, pwstr);
        RtlInitAnsiString(&AnsiString, sz);
        AnsiString.MaximumLength = sizeof(sz);
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    }
    return(sz);
}

PSZ
DbgIdentifier2Sz(
    PKSIDENTIFIER pIdentifier
)
{
    static char sz[256];

    sz[0] = '\0';
    if(pIdentifier != NULL && pIdentifier != INTERNAL_WILDCARD) {
        if(IsEqualGUID(
          &KSMEDIUMSETID_Standard,
          &pIdentifier->Set) &&
          (pIdentifier->Id == KSMEDIUM_STANDARD_DEVIO)) {
            return("KSMEDIUM_STANDARD_DEVIO");
        }
        if(IsEqualGUID(
          &KSINTERFACESETID_Standard,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSINTERFACE_STANDARD_STREAMING:
                    return("KSINTERFACE_STANDARD_STREAMING");
                case KSINTERFACE_STANDARD_LOOPED_STREAMING:
                    return("KSINTERFACE_STANDARD_LOOPED_STREAMING");
                case KSINTERFACE_STANDARD_CONTROL:
                    return("KSINTERFACE_STANDARD_CONTROL");
            }
        }
        if(IsEqualGUID(
          &KSINTERFACESETID_Media,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSINTERFACE_MEDIA_MUSIC:
                    return("KSINTERFACE_MEDIA_MUSIC");
                case KSINTERFACE_MEDIA_WAVE_BUFFERED:
                    return("KSINTERFACE_MEDIA_WAVE_BUFFERED");
                case KSINTERFACE_MEDIA_WAVE_QUEUED:
                    return("KSINTERFACE_MEDIA_WAVE_QUEUED");
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Pin,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_PIN_CINSTANCES:
                    return("KSPROPERTY_PIN_CINSTANCES");
                case KSPROPERTY_PIN_CTYPES:
                    return("KSPROPERTY_PIN_CTYPES");
                case KSPROPERTY_PIN_DATAFLOW:
                    return("KSPROPERTY_PIN_DATAFLOW");
                case KSPROPERTY_PIN_DATARANGES:
                    return("KSPROPERTY_PIN_DATARANGES");
                case KSPROPERTY_PIN_DATAINTERSECTION:
                    return("KSPROPERTY_PIN_DATAINTERSECTION");
                case KSPROPERTY_PIN_INTERFACES:
                    return("KSPROPERTY_PIN_INTERFACES");
                case KSPROPERTY_PIN_MEDIUMS:
                    return("KSPROPERTY_PIN_MEDIUMS");
                case KSPROPERTY_PIN_COMMUNICATION:
                    return("KSPROPERTY_PIN_COMMUNICATION");
                case KSPROPERTY_PIN_GLOBALCINSTANCES:
                    return("KSPROPERTY_PIN_GLOBALCINSTANCES");
                case KSPROPERTY_PIN_NECESSARYINSTANCES:
                    return("KSPROPERTY_PIN_NECESSARYINSTANCES");
                case KSPROPERTY_PIN_PHYSICALCONNECTION:
                    return("KSPROPERTY_PIN_PHYSICALCONNECTION");
                case KSPROPERTY_PIN_CATEGORY:
                    return("KSPROPERTY_PIN_CATEGORY");
                case KSPROPERTY_PIN_NAME:
                    return("KSPROPERTY_PIN_NAME");
                case KSPROPERTY_PIN_CONSTRAINEDDATARANGES:
                    return("KSPROPERTY_PIN_CONSTRAINEDDATARANGES");
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Connection,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_CONNECTION_STATE:
                    return("KSPROPERTY_CONNECTION_STATE");
                case KSPROPERTY_CONNECTION_PRIORITY:
                    return("KSPROPERTY_CONNECTION_PRIORITY");
                case KSPROPERTY_CONNECTION_DATAFORMAT:
                    return("KSPROPERTY_CONNECTION_DATAFORMAT");
                case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
                    return("KSPROPERTY_CONNECTION_ALLOCATORFRAMING");
                case KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT:
                    return("KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT");
                case KSPROPERTY_CONNECTION_ACQUIREORDERING:
                    return("KSPROPERTY_CONNECTION_ACQUIREORDERING");
                case KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX:
                    return("KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX");
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Stream,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_STREAM_ALLOCATOR:
                    return("KSPROPERTY_STREAM_ALLOCATOR");
                case KSPROPERTY_STREAM_MASTERCLOCK:
                    return("KSPROPERTY_STREAM_MASTERCLOCK");
            }
            sprintf(sz, "KSPROPSETID_Stream Id: %02x", pIdentifier->Id);
            return(sz);
        }
        if(IsEqualGUID(
          &KSPROPSETID_Clock,
          &pIdentifier->Set)) {
            sprintf(sz, "KSPROPSETID_Clock Id: %02x", pIdentifier->Id);
            return(sz);
        }
        if(IsEqualGUID(
          &KSPROPSETID_StreamAllocator,
          &pIdentifier->Set)) {
            sprintf(sz, "KSPROPSETID_StreamAllocator Id: %02x",
              pIdentifier->Id);
            return(sz);
        }
        if(IsEqualGUID(
          &KSPROPSETID_StreamInterface,
          &pIdentifier->Set)) {
            sprintf(sz, "KSPROPSETID_StreamInterface Id: %02x",
              pIdentifier->Id);
            return(sz);
        }
        if(IsEqualGUID(
          &KSPROPSETID_Topology,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_TOPOLOGY_CATEGORIES:
                    return("KSPROPERTY_TOPOLOGY_CATEGORIES");
                case KSPROPERTY_TOPOLOGY_NODES:
                    return("KSPROPERTY_TOPOLOGY_NODES");
                case KSPROPERTY_TOPOLOGY_CONNECTIONS:
                    return("KSPROPERTY_TOPOLOGY_CONNECTIONS");
                case KSPROPERTY_TOPOLOGY_NAME:
                    return("KSPROPERTY_TOPOLOGY_NAME");
                default:
                    sprintf(sz, "KSPROPSETID_Topology Id: %02x",
                      pIdentifier->Id);
                    return(sz);
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Audio,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_AUDIO_VOLUMELEVEL:
                    return("KSPROPERTY_AUDIO_VOLUMELEVEL");
                case KSPROPERTY_AUDIO_MUTE:
                    return("KSPROPERTY_AUDIO_MUTE");
                case KSPROPERTY_AUDIO_MIX_LEVEL_TABLE:
                    return("KSPROPERTY_AUDIO_MIX_LEVEL_TABLE");
                case KSPROPERTY_AUDIO_MIX_LEVEL_CAPS:
                    return("KSPROPERTY_AUDIO_MIX_LEVEL_CAPS");
                case KSPROPERTY_AUDIO_MUX_SOURCE:
                    return("KSPROPERTY_AUDIO_MUX_SOURCE");
                case KSPROPERTY_AUDIO_BASS:
                    return("KSPROPERTY_AUDIO_BASS");
                case KSPROPERTY_AUDIO_MID:
                    return("KSPROPERTY_AUDIO_MID");
                case KSPROPERTY_AUDIO_TREBLE:
                    return("KSPROPERTY_AUDIO_TREBLE");
                case KSPROPERTY_AUDIO_BASS_BOOST:
                    return("KSPROPERTY_AUDIO_BASS_BOOST");
                case KSPROPERTY_AUDIO_AGC:
                    return("KSPROPERTY_AUDIO_AGC");
                default:
                    sprintf(sz, "KSPROPSETID_Audio Id: %02x", pIdentifier->Id);
                    return(sz);
            }
        }
        if(IsEqualGUID(
          &KSPROPSETID_Sysaudio,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSPROPERTY_SYSAUDIO_DEVICE_COUNT:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_COUNT");
                case KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME");
                case KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE");
                case KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME");
                case KSPROPERTY_SYSAUDIO_SELECT_GRAPH:
                    return("KSPROPERTY_SYSAUDIO_SELECT_GRAPH");
                case KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE:
                    return("KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE");
                case KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT:
                    return("KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT");
                case KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE:
                    return("KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE");
                case KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK:
                    return("KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK");
                case KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK:
                    return("KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK");
                case KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES:
                    return("KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES");
                case KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX:
                    return("KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX");
                default:
                    sprintf(sz, "KSPROPSETID_Sysaudio Id: %02x",
                      pIdentifier->Id);
                    return(sz);
            }
        }
        if(IsEqualGUID(
          &KSEVENTSETID_Connection,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSEVENT_CONNECTION_POSITIONUPDATE:
                    return("KSEVENT_CONNECTION_POSITIONUPDATE");
                case KSEVENT_CONNECTION_DATADISCONTINUITY:
                    return("KSEVENT_CONNECTION_DATADISCONTINUITY");
                case KSEVENT_CONNECTION_TIMEDISCONTINUITY:
                    return("KSEVENT_CONNECTION_TIMEDISCONTINUITY");
                case KSEVENT_CONNECTION_PRIORITY:
                    return("KSEVENT_CONNECTION_PRIORITY");
                case KSEVENT_CONNECTION_ENDOFSTREAM:
                    return("KSEVENT_CONNECTION_ENDOFSTREAM");
            }
        }
        if(IsEqualGUID(
          &KSEVENTSETID_Clock,
          &pIdentifier->Set)) {
            switch(pIdentifier->Id) {
                case KSEVENT_CLOCK_INTERVAL_MARK:
                    return("KSEVENT_CLOCK_INTERVAL_MARK");
                case KSEVENT_CLOCK_POSITION_MARK:
                    return("KSEVENT_CLOCK_POSITION_MARK");
            }
        }
        if(IsEqualGUID(
          &GUID_NULL,
          &pIdentifier->Set)) {
            sprintf(sz, "GUID_NULL Id: %02x", pIdentifier->Id);
            return(sz);
        }
        sprintf(sz, "Set: %s Id: %02x",
          DbgGuid2Sz(&pIdentifier->Set),
          pIdentifier->Id);
    }
    else {
        sprintf(sz, "%08x", (ULONG_PTR)pIdentifier);
    }
    return(sz);
}

PSZ
DbgGuid2Sz(
    GUID *pGuid
)
{
    static char sz[256];
    if(pGuid == NULL) {
        return("NO GUID");
    }
    if(IsEqualGUID(
      &GUID_NULL,
      pGuid)) {
        return("GUID_NULL");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_TYPE_AUDIO,
      pGuid)) {
        return("KSDATAFORMAT_TYPE_AUDIO");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_ANALOG,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_ANALOG");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_PCM,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_PCM");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_IEEE_FLOAT");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_TYPE_MUSIC,
      pGuid)) {
        return("KSDATAFORMAT_TYPE_MUSIC");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_MIDI,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_MIDI");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SUBTYPE_MIDI_BUS,
      pGuid)) {
        return("KSDATAFORMAT_SUBTYPE_MIDI_BUS");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_DSOUND,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_DSOUND");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_WAVEFORMATEX");
    }
    if(IsEqualGUID(
      &KSDATAFORMAT_SPECIFIER_NONE,
      pGuid)) {
        return("KSDATAFORMAT_SPECIFIER_NONE");
    }
    if(IsEqualGUID(
      &KSCATEGORY_AUDIO,
      pGuid)) {
        return("KSCATEGORY_AUDIO");
    }
    if(IsEqualGUID(
      &KSNODETYPE_SPEAKER,
      pGuid)) {
        return("KSNODETYPE_SPEAKER");
    }
    if(IsEqualGUID(
      &KSNODETYPE_MICROPHONE,
      pGuid)) {
        return("KSNODETYPE_MICROPHONE");
    }
    if(IsEqualGUID(
      &KSNODETYPE_CD_PLAYER,
      pGuid)) {
        return("KSNODETYPE_CD_PLAYER");
    }
    if(IsEqualGUID(
      &KSNODETYPE_LEGACY_AUDIO_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_LEGACY_AUDIO_CONNECTOR");
    }
    if(IsEqualGUID(
      &KSNODETYPE_ANALOG_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_ANALOG_CONNECTOR");
    }
    if(IsEqualGUID(
      &KSCATEGORY_WDMAUD_USE_PIN_NAME,
      pGuid)) {
        return("KSCATEGORY_WDMAUD_USE_PIN_NAME");
    }
    if(IsEqualGUID(
      &KSNODETYPE_LINE_CONNECTOR,
      pGuid)) {
        return("KSNODETYPE_LINE_CONNECTOR");
    }
    if(IsEqualGUID(
      &GUID_TARGET_DEVICE_QUERY_REMOVE,
      pGuid)) {
        return("GUID_TARGET_DEVICE_QUERY_REMOVE");
    }
    if(IsEqualGUID(
      &GUID_TARGET_DEVICE_REMOVE_CANCELLED,
      pGuid)) {
        return("GUID_TARGET_DEVICE_REMOVE_CANCELLED");
    }
    if(IsEqualGUID(
      &GUID_TARGET_DEVICE_REMOVE_COMPLETE,
      pGuid)) {
        return("GUID_TARGET_DEVICE_REMOVE_COMPLETE");
    }
    if(IsEqualGUID(
      &PINNAME_CAPTURE,
      pGuid)) {
        return("PINNAME_CAPTURE");
    }
    if(IsEqualGUID(&KSNODETYPE_DAC, pGuid)) {
	return("KSNODETYPE_DAC");
    }
    if(IsEqualGUID(&KSNODETYPE_ADC, pGuid)) {
	return("KSNODETYPE_ADC");
    }
    if(IsEqualGUID(&KSNODETYPE_SRC, pGuid)) {
	return("KSNODETYPE_SRC");
    }
    if(IsEqualGUID(&KSNODETYPE_SUPERMIX, pGuid)) {
	return("KSNODETYPE_SUPERMIX");
    }
    if(IsEqualGUID( &KSNODETYPE_MUX, pGuid)) {
	return("KSNODETYPE_MUX");
    }
    if(IsEqualGUID( &KSNODETYPE_DEMUX, pGuid)) {
	return("KSNODETYPE_DEMUX");
    }
    if(IsEqualGUID(&KSNODETYPE_SUM, pGuid)) {
	return("KSNODETYPE_SUM");
    }
    if(IsEqualGUID(&KSNODETYPE_MUTE, pGuid)) {
	return("KSNODETYPE_MUTE");
    }
    if(IsEqualGUID(&KSNODETYPE_VOLUME, pGuid)) {
	return("KSNODETYPE_VOLUME");
    }
    if(IsEqualGUID(&KSNODETYPE_TONE, pGuid)) {
	return("KSNODETYPE_TONE");
    }
    if(IsEqualGUID(&KSNODETYPE_AGC, pGuid)) {
	return("KSNODETYPE_AGC");
    }
    if(IsEqualGUID(&KSNODETYPE_SYNTHESIZER, pGuid)) {
	return("KSNODETYPE_SYNTHESIZER");
    }
    if(IsEqualGUID(&KSNODETYPE_SWSYNTH, pGuid)) {
	return("KSNODETYPE_SWSYNTH");
    }
    if(IsEqualGUID(&KSNODETYPE_3D_EFFECTS, pGuid)) {
	return("KSNODETYPE_3D_EFFECTS");
    }
    sprintf(sz, "%08x %04x %04x %02x%02x%02x%02x%02x%02x%02x%02x",
      pGuid->Data1,
      pGuid->Data2,
      pGuid->Data3,
      pGuid->Data4[0],
      pGuid->Data4[1],
      pGuid->Data4[2],
      pGuid->Data4[3],
      pGuid->Data4[4],
      pGuid->Data4[5],
      pGuid->Data4[6],
      pGuid->Data4[7]);

    return(sz);
}

//---------------------------------------------------------------------------

#ifndef UNDER_NT

#ifdef _X86_

extern ULONG nFilter;
extern ULONG nDevice;
extern ULONG nLogicalFilter;

VOID
DebugCommand(
)
{
    PKSDATAFORMAT pDataFormat;
    PKSDATARANGE pDataRange;
    PCOBJ pcobj;
    CHAR c;

    nFilter = 0;
    nDevice = 0;
    nLogicalFilter = 0;
    ulDebugFlags = 0;
    ulDebugNumber = MAXULONG;
    while((c = DebugGetCommandChar()) != '\0') {
        switch(c) {
            case 'A':
                ulDebugFlags |= DEBUG_FLAGS_ADDRESS;
                break;
            case 'D':
                ulDebugFlags |= DEBUG_FLAGS_DEVICE;
                break;
            case 'F':
                ulDebugFlags |= DEBUG_FLAGS_FILTER;
                break;
            case 'L':
                ulDebugFlags |= DEBUG_FLAGS_LOGICAL_FILTER;
                break;
            case 'P':
                ulDebugFlags |= DEBUG_FLAGS_PIN;
                break;
            case 'I':
                ulDebugFlags |= DEBUG_FLAGS_INSTANCE;
                break;
            case 'G':
                ulDebugFlags |= DEBUG_FLAGS_GRAPH;
                break;
            case 'T':
                ulDebugFlags |= DEBUG_FLAGS_TOPOLOGY;
                break;
            case 'R':
		pDataRange = (PKSDATARANGE)DebugEvaluateExpression();
		if(ulDebugFlags & DEBUG_FLAGS_FILTER) {
		    DumpDataFormat(MAXULONG, pDataRange);
		}
		else {
		    DumpDataRangeAudio((PKSDATARANGE_AUDIO)pDataRange);
		}
		return;
            case 'O':
                ulDebugFlags |= DEBUG_FLAGS_OBJECT;
		pcobj = (PCOBJ)DebugEvaluateExpression();

		if(PFILTER_INSTANCE(pcobj)->m_Signature.IsAssert()) {
		    PFILTER_INSTANCE(pcobj)->Dump();
		    return;
		}
		if(PPIN_INSTANCE(pcobj)->m_Signature.IsAssert()) {
		    PPIN_INSTANCE(pcobj)->Dump();
		    return;
		}
		if(PINSTANCE(pcobj)->m_Signature.IsAssert()) {
		    PINSTANCE(pcobj)->Dump();
		    return;
		}
		pcobj->Dump();
                return;
            case 'V':
                ulDebugFlags |= DEBUG_FLAGS_VERBOSE;
                break;
            case 'X':
                ulDebugFlags |= DEBUG_FLAGS_DETAILS;
                break;
            case '?':
                dprintf(".S[D|F|V|I|O]\n");
                dprintf("[L|P|T|A|V|X]O <addr> - Dump Object\n");
                dprintf("R <addr>              - Dump DataRange\n");
                dprintf("D[0-9][L|P|T][A|V|X]  - Devices\n");
                dprintf("F[0-9][L|P|T][A|V|X]  - Filters\n");
                dprintf("G[0-9][L|P|T][A|V|X]  - Graphs\n");
                dprintf("I[0-9][L|P|T][A|V|X]  - Instances\n");
                dprintf(" 0-9 - Device or Filter number\n");
                dprintf("   L - Logical Filter Nodes\n");
                dprintf("   P - Pins\n");
                dprintf("   T - Topology\n");
                dprintf("   A - Addresses\n");
                dprintf("   V - Verbose\n");
                dprintf("   X - Details\n");
                return;
            default:
                if(c >= '0' && c <= '9') {
		    if(ulDebugNumber == MAXULONG) {
		       ulDebugNumber++;
		    }
                    ulDebugNumber *= 10;
                    ulDebugNumber += c - '0';
                }
                break;
        }
    }
    if((ulDebugFlags != 0) &&
      (ulDebugFlags &
      (DEBUG_FLAGS_DEVICE |
       DEBUG_FLAGS_FILTER |
       DEBUG_FLAGS_INSTANCE |
       DEBUG_FLAGS_LOGICAL_FILTER |
       DEBUG_FLAGS_GRAPH)) == 0) {
        ulDebugFlags |= DEBUG_FLAGS_DEVICE;
    }
    DumpSysAudio();
}

VOID
DebugDotCommand(
)
{
    DebugCommand();
    __asm xor eax, eax
    __asm retf
}

VOID
InitializeDebug(
)
{
    static char *pszHelp = ".S - Dump System Audio Driver data structures\n";

    __asm {
        _emit 0xcd
        _emit 0x20
        _emit 0xc1
        _emit 0x00
        _emit 0x01
        _emit 0x00
        jz exitlab

        mov bl, 'S'
        mov esi, offset DebugDotCommand
        mov edi, pszHelp
        mov eax, 0x70   // DS_RegisterDotCommand
        int 41h
exitlab:
    }
}

VOID
UninitializeDebug(
)
{
    __asm {
        _emit 0xcd
        _emit 0x20
        _emit 0xc1
        _emit 0x00
        _emit 0x01
        _emit 0x00
        jz exitlab

        mov bl, 'S'
        mov eax, 0x72   // DS_DeRegisterDotCommand
        int 41h
exitlab:
    }
}

VOID __cdecl
dprintf(
    PSZ pszFmt,
    ...
)
{
    __asm mov esi, [pszFmt]
    __asm lea edi, [pszFmt+4]
    __asm mov eax, 0x73
    __asm int 41h
}

CHAR
DebugGetCommandChar(
)
{
    CHAR c;
    __asm mov ax, 0x77          // get command char
    __asm mov bl, 1             // get char
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al
    __asm mov c, al
    return(c);
}

ULONG
DebugEvaluateExpression(
)
{
    ULONG ul;
    __asm mov ax, 0x78          // EvaluateExpression
    __asm int 41h
    __asm mov ul, ebx
    return(ul);
}

#endif  // _X86_

#endif  // UNDER_NT

#endif  // DEBUG

//---------------------------------------------------------------------------
//  End of File: util.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\topology.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   topology.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

ENUMFUNC
EnumerateTopology(
    IN PPIN_INFO pPinInfo,
    IN NTSTATUS (*Function)(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PVOID pReference
    ),
    IN OUT PVOID pReference
)
{
    ENUM_TOPOLOGY EnumTopology;
    NTSTATUS Status;

    Assert(pPinInfo);
    EnumTopology.cTopologyRecursion = 0;
    EnumTopology.Function = Function;
    EnumTopology.fToDirection = (pPinInfo->DataFlow == KSPIN_DATAFLOW_IN);
    EnumTopology.pReference = pReference;
    Status = EnumeratePinInfoTopology(pPinInfo, &EnumTopology);
    return(Status);
}

ENUMFUNC
EnumerateGraphTopology(
    IN PSTART_INFO pStartInfo,
    IN NTSTATUS (*Function)(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PVOID pReference
    ),
    IN OUT PVOID pReference
)
{
    PCONNECT_INFO pConnectInfo;
    NTSTATUS Status;

    Assert(pStartInfo);
    Assert(pStartInfo->GetPinInfo());

    Status = EnumerateTopology(
      pStartInfo->GetPinInfo(),
      Function,
      pReference);

    if(Status != STATUS_CONTINUE) {
	goto exit;
    }
    for(pConnectInfo = pStartInfo->GetFirstConnectInfo();
	pConnectInfo != NULL;
	pConnectInfo = pConnectInfo->GetNextConnectInfo()) {

	Assert(pConnectInfo);
	Status = EnumerateTopology(
	  pConnectInfo->pPinInfoSink,
	  Function,
	  pReference);

	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    }
exit:
    return(Status);
}

ENUMFUNC
EnumeratePinInfoTopology(
    IN PPIN_INFO pPinInfo,
    IN PENUM_TOPOLOGY pEnumTopology
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    NTSTATUS Status = STATUS_CONTINUE;

    Assert(pPinInfo);
    Assert(pEnumTopology);
    DPF2(110, "EnumerateTopologyPinInfo %08x #%x", pPinInfo, pPinInfo->PinId);

    FOR_EACH_LIST_ITEM(
      &pPinInfo->lstTopologyConnection,
      pTopologyConnection) {

	Assert(pTopologyConnection);
	if(pEnumTopology->fToDirection) {
	    if(pTopologyConnection->pPinInfoFrom != pPinInfo) {
		continue;
	    }
	    ASSERT(pTopologyConnection->pPinInfoTo != pPinInfo);
	}
	else {
	    if(pTopologyConnection->pPinInfoTo != pPinInfo) {
		continue;
	    }
	    ASSERT(pTopologyConnection->pPinInfoFrom != pPinInfo);
	}
	Status = EnumerateTopologyConnection(
	  pTopologyConnection,
	  pEnumTopology);

	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
EnumerateTopologyPin(
    IN PTOPOLOGY_PIN pTopologyPin,
    IN PENUM_TOPOLOGY pEnumTopology
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    PTOPOLOGY_PIN pTopologyPin2;
    NTSTATUS Status = STATUS_CONTINUE;
    BOOL fFromPinEqual = TRUE;
    ULONG ulFromPinNumber = MAXULONG;
    BOOL fToPinEqual = TRUE;
    ULONG ulToPinNumber = MAXULONG;
    BOOL fPinEqual;
    ULONG ulPinNumber;

    Assert(pTopologyPin);
    Assert(pEnumTopology);
    DPF3(110, "EnumerateTopologyPin %08x TP #%x TN #%x",
      pTopologyPin, 
      pTopologyPin->ulPinNumber,
      pTopologyPin->pTopologyNode->ulRealNodeNumber);

    if(IsEqualGUID(
      &KSNODETYPE_ACOUSTIC_ECHO_CANCEL,
      pTopologyPin->pTopologyNode->pguidType)) {
	switch(pTopologyPin->ulPinNumber) {
	    case KSNODEPIN_AEC_RENDER_OUT:
		ASSERT(!pEnumTopology->fToDirection);
	    case KSNODEPIN_AEC_RENDER_IN:
		ulFromPinNumber = KSNODEPIN_AEC_RENDER_IN;
		ulToPinNumber = KSNODEPIN_AEC_RENDER_OUT;
		break;

	    case KSNODEPIN_AEC_CAPTURE_OUT:
		ASSERT(!pEnumTopology->fToDirection);
	    case KSNODEPIN_AEC_CAPTURE_IN:
		ulFromPinNumber = KSNODEPIN_AEC_CAPTURE_IN;
		ulToPinNumber = KSNODEPIN_AEC_CAPTURE_OUT;
		break;
	}
    }
    else if(IsEqualGUID(
      &KSNODETYPE_SUM,
      pTopologyPin->pTopologyNode->pguidType) ||

      IsEqualGUID(
      &KSNODETYPE_MUX,
      pTopologyPin->pTopologyNode->pguidType)) {

	ulFromPinNumber = KSNODEPIN_SUM_MUX_IN;
	fFromPinEqual = FALSE;
	ulToPinNumber = KSNODEPIN_SUM_MUX_OUT;
    }
    else if(IsEqualGUID(
      &KSNODETYPE_DEMUX,
      pTopologyPin->pTopologyNode->pguidType)) {

	ulFromPinNumber = KSNODEPIN_DEMUX_IN;
	ulToPinNumber = KSNODEPIN_DEMUX_OUT;
	fToPinEqual = FALSE;
    }
    else {
	ulFromPinNumber = KSNODEPIN_STANDARD_IN;
	ulToPinNumber = KSNODEPIN_STANDARD_OUT;
    }

    // Swap pin numbers and flags
    if(!pEnumTopology->fToDirection) {
       ulPinNumber = ulToPinNumber;
       ulToPinNumber = ulFromPinNumber;
       ulFromPinNumber = ulPinNumber;
       fPinEqual = fToPinEqual;
       fToPinEqual = fFromPinEqual;
       fFromPinEqual = fPinEqual;
    }
    ASSERT(ulToPinNumber != MAXULONG);
    ASSERT(ulFromPinNumber != MAXULONG);

    // Validate input/from pin(s)
    if(fFromPinEqual) {
	if(pTopologyPin->ulPinNumber != ulFromPinNumber) {
	    DPF2(5, "EnumerateTopologyPin: %s bad 'from' pin number %08x",
	      pTopologyPin->pTopologyNode->pFilterNode->DumpName(),
	      pTopologyPin->ulPinNumber);
	    Status = STATUS_INVALID_DEVICE_REQUEST;
	    goto exit;
	}
    }
    else {
	if(pTopologyPin->ulPinNumber < ulFromPinNumber) {
	    DPF2(5, "EnumerateTopologyPin: %s bad 'from' pin number %08x",
	      pTopologyPin->pTopologyNode->pFilterNode->DumpName(),
	      pTopologyPin->ulPinNumber);
	    Status = STATUS_INVALID_DEVICE_REQUEST;
	    goto exit;
	}
    }

    FOR_EACH_LIST_ITEM(
      &pTopologyPin->pTopologyNode->lstTopologyPin,
      pTopologyPin2) {

	if(pTopologyPin == pTopologyPin2) {
	    continue;
	}

	// Pick the right output/to pin(s)
	if(fToPinEqual) {
	    if(pTopologyPin2->ulPinNumber != ulToPinNumber) {
		continue;
	    }
	}
	else {
	    if(pTopologyPin2->ulPinNumber < ulToPinNumber) {
		continue;
	    }
	}

	FOR_EACH_LIST_ITEM(
	  &pTopologyPin2->lstTopologyConnection,
	  pTopologyConnection) {

	    Assert(pTopologyConnection);
	    if(pEnumTopology->fToDirection) {
		if(pTopologyConnection->pTopologyPinFrom != pTopologyPin2) {
		    continue;
		}
		ASSERT(pTopologyConnection->pTopologyPinTo != pTopologyPin2);
	    }
	    else {
		if(pTopologyConnection->pTopologyPinTo != pTopologyPin2) {
		    continue;
		}
		ASSERT(pTopologyConnection->pTopologyPinFrom != pTopologyPin2);
	    }
	    Status = EnumerateTopologyConnection(
	      pTopologyConnection,
	      pEnumTopology);

	    if(Status != STATUS_CONTINUE) {
		goto exit;
	    }

	} END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

ENUMFUNC
EnumerateTopologyConnection(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN PENUM_TOPOLOGY pEnumTopology
)
{
    PTOPOLOGY_PIN pTopologyPin;
    PPIN_INFO pPinInfo;
    NTSTATUS Status;

    Assert(pEnumTopology);
    Assert(pTopologyConnection);
    DPF1(110, "EnumerateTopologyConnection %08x", pTopologyConnection);

    if(pEnumTopology->cTopologyRecursion++ > (gcTopologyConnections + 16)) {
	Trap();
	DPF(5, "EnumerateTopologyConnection: recursion too deep");
	Status = STATUS_STACK_OVERFLOW;
	goto exit;
    }
    // Have we visited this topology connection already?
    Status = VisitedTopologyConnection(pTopologyConnection, pEnumTopology);
    if(Status != STATUS_CONTINUE) {
	if(Status == STATUS_DEAD_END) {
	    Status = STATUS_CONTINUE;
	}
	goto exit;
    }
    Status = (*pEnumTopology->Function)(
      pTopologyConnection,
      pEnumTopology->fToDirection,
      pEnumTopology->pReference);

    if(Status != STATUS_CONTINUE) {
	if(Status == STATUS_DEAD_END) {
	    Status = STATUS_CONTINUE;
	}
	goto exit;
    }
    if(pEnumTopology->fToDirection) {
       pTopologyPin = pTopologyConnection->pTopologyPinTo;
       pPinInfo = pTopologyConnection->pPinInfoTo;
    }
    else {
       pTopologyPin = pTopologyConnection->pTopologyPinFrom;
       pPinInfo = pTopologyConnection->pPinInfoFrom;
    }
    if(pTopologyPin != NULL) {

	Status = EnumerateTopologyPin(pTopologyPin, pEnumTopology);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    }
    if(pPinInfo != NULL) {

	Status = EnumeratePinInfoTopology(pPinInfo, pEnumTopology);
	if(Status != STATUS_CONTINUE) {
	    goto exit;
	}
    }
exit:
    pEnumTopology->cTopologyRecursion--;
    return(Status);
}

ENUMFUNC
VisitedTopologyConnection(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN PENUM_TOPOLOGY pEnumTopology
)
{
    NTSTATUS Status;

    Assert(pEnumTopology);
    Assert(pTopologyConnection);

    // Have we visited this topology connection already?
    if(pTopologyConnection->CheckDupList(
      &pEnumTopology->lstTopologyConnection)) {
	DPF1(100, "VisitedTopologyConnection: %08x already visited",
	  pTopologyConnection);
	Status = STATUS_DEAD_END;
	goto exit;		// yes, break cycle in topology
    }
    // Add topology pin to list of pin's visited
    Status = pTopologyConnection->AddList(
      &pEnumTopology->lstTopologyConnection);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    Status = STATUS_CONTINUE;
exit:
    return(Status);
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\util.h ===
//---------------------------------------------------------------------------
//
//  Module:   util.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#ifdef DEBUG
#define DEBUG_FLAGS_OBJECT		0x00000001
#define DEBUG_FLAGS_DEVICE		0x00000002
#define DEBUG_FLAGS_FILTER		0x00000004
#define DEBUG_FLAGS_LOGICAL_FILTER	0x00000008
#define DEBUG_FLAGS_PIN			0x00000010
#define DEBUG_FLAGS_INSTANCE		0x00000020
#define DEBUG_FLAGS_GRAPH		0x00000040
#define DEBUG_FLAGS_TOPOLOGY		0x00000080
#define DEBUG_FLAGS_ADDRESS		0x00000100
#define DEBUG_FLAGS_VERBOSE		0x00000200
#define DEBUG_FLAGS_DETAILS		0x00000400
#endif

#define INTERNAL_WILDCARD       ((PKSIDENTIFIER)-1)

#define	STATUS_DEAD_END		((NTSTATUS)-1)

//---------------------------------------------------------------------------
// Global Data
//---------------------------------------------------------------------------

extern "C" KMUTEX gMutex;

#ifdef DEBUG
extern ULONG ulDebugFlags;
extern ULONG ulDebugNumber;
#endif

//---------------------------------------------------------------------------
// Data structures
//---------------------------------------------------------------------------

typedef struct dataranges {
    KSMULTIPLE_ITEM MultipleItem;
    KSDATARANGE aDataRanges[1];
} DATARANGES, *PDATARANGES;

typedef struct identifiers {
    KSMULTIPLE_ITEM MultipleItem;
    KSIDENTIFIER aIdentifiers[1];	// Array of identifiers
} IDENTIFIERS, *PIDENTIFIERS;

typedef class CQueueWorkListData : public CObj
{
public:
    void * __cdecl operator new(size_t size)
    {
	return(ExAllocatePoolWithTag(NonPagedPool, size, 0x41535953));
    };
    void __cdecl operator delete(void *p)
    {
	ExFreePool(p);
    };

    CQueueWorkListData(
	NTSTATUS (*Function)(PVOID Reference1, PVOID Reference2),
	PVOID Reference1,
	PVOID Reference2
    );

    NTSTATUS
    QueueAsyncList(
    );

    static VOID
    AsyncWorker(
	IN OUT PVOID pReference
    );

#ifdef DEBUG
    ENUMFUNC
    Dump(
    )
    {
	dprintf("CKPD: %08x PFN %08x R1 %08x R2 %08x\n",
	  this,
	  Function,
	  Reference1,
	  Reference2);
	return (STATUS_CONTINUE);
    };
#endif

private:
    LIST_ENTRY leNext;
    NTSTATUS (*Function)(PVOID, PVOID);
    PVOID Reference1;
    PVOID Reference2;
    DefineSignature(0x444c5751);      			// QWLD

} QUEUE_WORK_LIST_DATA, *PQUEUE_WORK_LIST_DATA;

//---------------------------------------------------------------------------

typedef NTSTATUS (*UTIL_PFN)(PVOID, PVOID);

//---------------------------------------------------------------------------
// Inline helper functions
//---------------------------------------------------------------------------

__inline int IsEqualGUID(const GUID *lpguid1, const GUID *lpguid2)
{
    return !memcmp(lpguid1, lpguid2, sizeof(GUID));
}

__inline VOID GrabMutex()
{
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
#ifdef DEBUG
    LARGE_INTEGER li = {0, 600000000};
    NTSTATUS Status;
    while(Status = KeWaitForMutexObject(
      &gMutex,
      Executive,
      KernelMode,
      FALSE,
      &li) == STATUS_TIMEOUT) {
	dprintf("SYSAUDIO: possible deadlock - thread %08x\n",
	  KeGetCurrentThread());
    }
#else
    KeWaitForMutexObject(&gMutex, Executive, KernelMode, FALSE, NULL);
#endif
}

__inline VOID ReleaseMutex()
{
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    KeReleaseMutex(&gMutex, FALSE);
}

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

extern "C" {

NTSTATUS
InitializeUtil(
);

VOID
UninitializeUtil(
);

VOID
UninitializeMemory(
);

NTSTATUS
DispatchInvalidDeviceRequest(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

BOOLEAN
DispatchFastIoDeviceControlFailure(
   IN PFILE_OBJECT FileObject,
   IN BOOLEAN Wait,
   IN PVOID InputBuffer OPTIONAL,
   IN ULONG InputBufferLength,
   OUT PVOID OutputBuffer OPTIONAL,
   IN ULONG OutputBufferLength,
   IN ULONG IoControlCode,
   OUT PIO_STATUS_BLOCK IoStatus,
   IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
DispatchFastReadFailure(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

#define DispatchFastWriteFailure DispatchFastReadFailure

CompareDataRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
);

BOOL
DataIntersectionRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2,
    PKSDATARANGE pDataRangeIntersection
);

BOOL
DataIntersectionAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio1,
    PKSDATARANGE_AUDIO pDataRangeAudio2,
    PKSDATARANGE_AUDIO pDataRangeAudioIntersection
);

BOOL
CompareDataRangeExact(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
);

BOOL
CompareDataRangeGuids(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2
);

BOOL
CompareIdentifier(
    PKSIDENTIFIER pIdentifier1,
    PKSIDENTIFIER pIdentifier2
);

void
ModifyPinConnect(
    PKSPIN_CONNECT pPinConnect,
    WORD nChannels
);


BOOL
WaveFormatExtensibleToWaveFormat(
    PKSPIN_CONNECT pPinConnect
);

NTSTATUS 
OpenDevice(
    IN PWSTR pwstrDevice,
    OUT PHANDLE pHandle
);

NTSTATUS
GetPinProperty(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    ULONG cbProperty,
    PVOID pProperty
);

NTSTATUS
PinConnectionProperty(
    PFILE_OBJECT pFileObject,
    ULONG ulPropertyId,
    ULONG ulFlags,
    ULONG cbProperty,
    PVOID pProperty

);

NTSTATUS
GetPinPropertyEx(
    PFILE_OBJECT pFileObject,
    ULONG PropertyId,
    ULONG PinId,
    PVOID *ppProperty
);

NTSTATUS
GetPinProperty2(
    PFILE_OBJECT pFileObject,
    ULONG ulPropertyId,
    ULONG ulPinId,
    ULONG cbInput,
    PVOID pInputData,
    PVOID *ppPropertyOutput
);

NTSTATUS
GetProperty(
    PFILE_OBJECT pFileObject,
    CONST GUID *pguidPropertySet,
    ULONG ulPropertyId,
    ULONG cbInput,
    PVOID pInputData,
    PVOID *ppPropertyOutput
);

NTSTATUS 
QueueWorkList(
    IN NTSTATUS (*Function)(PVOID Reference1, PVOID Reference2),
    IN PVOID Reference1,
    IN PVOID Reference2
);

VOID 
GetDefaultOrder(
    ULONG fulType,
    PULONG pulOrder
);

NTSTATUS
SetKsFrameHolding(
    PFILE_OBJECT pFileObject
);

//---------------------------------------------------------------------------

#ifdef DEBUG

VOID
DumpPinConnect(
    LONG Level,
    PKSPIN_CONNECT pPinConnect
);

VOID
DumpDataFormat(
    LONG Level,
    PKSDATAFORMAT pDataFormat
);

VOID
DumpWaveFormatEx(
    LONG Level,
    PSZ pszSpecifier,
    WAVEFORMATEX *pWaveFormatEx
);

VOID
DumpDataRange(
    LONG Level,
    PKSDATARANGE_AUDIO pDataRangeAudio
);

VOID
DumpDataRangeAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio
);

VOID
DumpfulType(
    ULONG fulType
);

ENUMFUNC
DumpListData(
    PVOID pData
);

PSZ DbgUnicode2Sz(
    PWSTR pwstr
);

PSZ
DbgIdentifier2Sz(
    PKSIDENTIFIER pIdentifier
);

PSZ
DbgGuid2Sz(
    GUID *pGuid
);

//---------------------------------------------------------------------------

#endif  // DEBUG

} // extern "C"

//---------------------------------------------------------------------------
//  End of File: util.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\topology.h ===
//---------------------------------------------------------------------------
//
//  Module:   topology.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Data structures
//---------------------------------------------------------------------------

typedef struct enum_topology {

    ULONG cTopologyRecursion;
    LIST_MULTI_TOPOLOGY_CONNECTION lstTopologyConnection;
    NTSTATUS (*Function)(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PVOID pReference
    );
    BOOL fToDirection;
    PVOID pReference;
    DefineSignature(0x504F5445);		// ETOP

} ENUM_TOPOLOGY, *PENUM_TOPOLOGY;

//---------------------------------------------------------------------------

typedef ENUMFUNC (*TOP_PFN)(PTOPOLOGY_CONNECTION, BOOL, PVOID);

//---------------------------------------------------------------------------
// Global variables
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

ENUMFUNC
EnumerateTopology(
    IN PPIN_INFO pPinInfo,
    IN NTSTATUS (*Function)(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PVOID pReference
    ),
    IN OUT PVOID pReference
);

ENUMFUNC
EnumerateGraphTopology(
    IN PSTART_INFO pStartInfo,
    IN NTSTATUS (*Function)(
	IN PTOPOLOGY_CONNECTION pTopologyConnection,
	IN BOOL fToDirection,
	IN OUT PVOID pReference
    ),
    IN OUT PVOID pReference
);

ENUMFUNC
EnumeratePinInfoTopology(
    IN PPIN_INFO pPinInfo,
    IN PENUM_TOPOLOGY pEnumTopology
);

ENUMFUNC
EnumerateTopologyPin(
    IN PTOPOLOGY_PIN pTopologyPin,
    IN PENUM_TOPOLOGY pEnumTopology
);

ENUMFUNC
EnumerateTopologyConnection(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN PENUM_TOPOLOGY pEnumTopology
);

ENUMFUNC
VisitedTopologyConnection(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN PENUM_TOPOLOGY pEnumTopology
);

//---------------------------------------------------------------------------
//  End of File: topology.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\virtual.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   virtual.c
//
//  Description:
//     Virtual Source Stuff
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Andy Nicholson
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

// Virtual Source Data

KSDATARANGE DataRangeWildCard =
{
    sizeof(KSDATARANGE),
    0,
    0,
    0,
    STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
    STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
    STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WILDCARD),
};

KSPIN_MEDIUM VirtualPinMedium =
{
    STATICGUIDOF(KSMEDIUMSETID_Standard),
    KSMEDIUM_STANDARD_DEVIO
};

KSDATARANGE VirtualPinDataRange =
{
    sizeof(KSDATARANGE),
    0,
    0,
    0,
    STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
    STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
    STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE),
};

//---------------------------------------------------------------------------

NTSTATUS
CreateVirtualMixer(
    PDEVICE_NODE pDeviceNode
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    PTOPOLOGY_PIN pTopologyPinSumOutput;
    PTOPOLOGY_NODE pTopologyNodeSum;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_NODE pFilterNode;
    PPIN_INFO pPinInfo;
    PPIN_NODE pPinNode;

    //
    // Create a special "virtual source" filter node and related structures
    //

    pFilterNode = new FILTER_NODE(FILTER_TYPE_AUDIO | FILTER_TYPE_VIRTUAL);
    if(pFilterNode == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    pFilterNode->SetFriendlyName(L"Virtual Mixer");

    Status = pFilterNode->AddDeviceInterfaceMatch(
      pDeviceNode->GetDeviceInterface());

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    //
    // Create the logical filter node for this "virtual" filter
    //

    Status = CLogicalFilterNode::Create(&pLogicalFilterNode, pFilterNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    Status = CTopologyNode::Create(
      &pTopologyNodeSum,
      pFilterNode,
      MAXULONG,
      (GUID *)&KSNODETYPE_SUM);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    pTopologyNodeSum->iVirtualSource = 0;

    Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNodeSum);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    Status = pLogicalFilterNode->AddList(
      &pTopologyNodeSum->lstLogicalFilterNode);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinSumOutput,
      0,				// 0 output
      pTopologyNodeSum);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    //
    // Create a virtual sysaudio source pin
    //

    pPinInfo = new PIN_INFO(pFilterNode, 0);
    if(pPinInfo == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }

    pPinInfo->DataFlow = KSPIN_DATAFLOW_OUT;
    pPinInfo->Communication = KSPIN_COMMUNICATION_SOURCE;
    pPinInfo->cPinInstances.PossibleCount = MAXULONG;
    pFilterNode->cPins++;

    pPinNode = new PIN_NODE(pPinInfo);
    if(pPinNode == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    pPinNode->pMedium = INTERNAL_WILDCARD;
    pPinNode->pInterface = INTERNAL_WILDCARD;
    pPinNode->pDataRange = &DataRangeWildCard;

    Status = pLogicalFilterNode->lstPinNode.AddList(pPinNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    pPinNode->pLogicalFilterNode = pLogicalFilterNode;

    //
    // Connect the out of sum node to the source pin
    //

    Status = CTopologyConnection::Create(
      &pTopologyConnection,
      pFilterNode,			// pFilterNode
      NULL,				// pGraphNode
      pTopologyPinSumOutput,		// pTopologyPin From
      NULL,				// pTopologyPin To
      NULL,				// pPinInfo From
      pPinInfo);			// pPinInfo To

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = pTopologyConnection->AddList(
      &pLogicalFilterNode->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    FOR_EACH_LIST_ITEM(gplstVirtualSourceLine, pVirtualSourceLine) {

	ASSERT(pVirtualSourceLine->iVirtualSource < 
	  pDeviceNode->cVirtualSourceData);

	if(pDeviceNode->papVirtualSourceData[
	  pVirtualSourceLine->iVirtualSource]->pTopologyNode != NULL) {
	    continue;
	}

	Status = CreateVirtualLine(
	  pDeviceNode,
	  pFilterNode,
	  pTopologyNodeSum,
	  pLogicalFilterNode,
	  pVirtualSourceLine);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    // if new virtual source lines were created
    if(pFilterNode->cPins > 1) {
	pDeviceNode->pFilterNodeVirtual = pFilterNode;
    }
    else {
	delete pFilterNode;
    }
exit:
    if(!NT_SUCCESS(Status)) {
	Trap();
	delete pFilterNode;
    }
    return(Status);
}

NTSTATUS
CreateVirtualLine(
    PDEVICE_NODE pDeviceNode,
    PFILTER_NODE pFilterNode,
    PTOPOLOGY_NODE pTopologyNodeSum,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine
)
{
    PTOPOLOGY_CONNECTION pTopologyConnection;
    NTSTATUS Status = STATUS_SUCCESS;
    PTOPOLOGY_NODE pTopologyNode;
    PTOPOLOGY_PIN pTopologyPinSumInput;
    PTOPOLOGY_PIN pTopologyPinVolume;
    PTOPOLOGY_PIN pTopologyPinMute;
    PPIN_INFO pPinInfo;
    PPIN_NODE pPinNode;

    //
    // Create a virtual sysaudio pin
    //

    pPinInfo = new PIN_INFO(pFilterNode, pVirtualSourceLine->iVirtualSource+1);
    if(pPinInfo == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    pPinInfo->DataFlow = KSPIN_DATAFLOW_IN;
    pPinInfo->Communication = KSPIN_COMMUNICATION_NONE;
    pPinInfo->pguidCategory = &pVirtualSourceLine->guidCategory;
    pPinInfo->pguidName = &pVirtualSourceLine->guidName;
    pFilterNode->cPins++;

    pPinNode = new PIN_NODE(pPinInfo);
    if(pPinNode == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }
    pPinNode->pMedium = &VirtualPinMedium;
    pPinNode->pDataRange = &VirtualPinDataRange;

    Status = pLogicalFilterNode->lstPinNode.AddList(pPinNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    pPinNode->pLogicalFilterNode = pLogicalFilterNode;

    //
    // Create a virtual volume topology node and input topology pin
    //

    Status = CTopologyNode::Create(
      &pTopologyNode,
      pFilterNode,
      MAXULONG,
      (GUID *)&KSNODETYPE_VOLUME);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    pTopologyNode->iVirtualSource = pVirtualSourceLine->iVirtualSource;

    ASSERT(pVirtualSourceLine->iVirtualSource < 
      pDeviceNode->cVirtualSourceData);

    pDeviceNode->papVirtualSourceData[
      pVirtualSourceLine->iVirtualSource]->pTopologyNode = pTopologyNode;

    Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    Status = pLogicalFilterNode->AddList(&pTopologyNode->lstLogicalFilterNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinVolume,
      KSNODEPIN_STANDARD_IN,		// 1 = input
      pTopologyNode);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    //
    // Create a connection from virtual pin to volume node
    //

    Status = CTopologyConnection::Create(
      &pTopologyConnection,
      pFilterNode,			// pFilterNode
      NULL,				// pGraphNode
      NULL,				// pTopologyPin From
      pTopologyPinVolume,		// pTopologyPin To
      pPinInfo,				// pPinInfo From
      NULL);				// pPinInfo To

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = pTopologyConnection->AddList(
      &pLogicalFilterNode->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinVolume,
      KSNODEPIN_STANDARD_OUT,			// 0 = output
      pTopologyNode);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    //
    // Create a virtual mute topology node and input topology pin
    //

    Status = CTopologyNode::Create(
      &pTopologyNode,
      pFilterNode,
      MAXULONG,
      (GUID *)&KSNODETYPE_MUTE);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    pTopologyNode->iVirtualSource = pVirtualSourceLine->iVirtualSource;

    Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    Status = pLogicalFilterNode->AddList(&pTopologyNode->lstLogicalFilterNode);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinMute,
      KSNODEPIN_STANDARD_IN,		// 1 = input
      pTopologyNode);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    //
    // Create a connection from volume node to mute node pin
    //

    Status = CTopologyConnection::Create(
      &pTopologyConnection,
      pFilterNode,			// pFilterNode
      NULL,				// pGraphNode
      pTopologyPinVolume,		// pTopologyPin From
      pTopologyPinMute,			// pTopologyPin To
      NULL,				// pPinInfo From
      NULL);				// pPinInfo To

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    Status = pTopologyConnection->AddList(
      &pLogicalFilterNode->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinMute,
      KSNODEPIN_STANDARD_OUT,			// 1 = output
      pTopologyNode);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinSumInput,
      pVirtualSourceLine->iVirtualSource + 1,	// >= 1 input
      pTopologyNodeSum);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    //
    // Create a connection from mute node to sum node pin
    //

    Status = CTopologyConnection::Create(
      &pTopologyConnection,
      pFilterNode,			// pFilterNode
      NULL,				// pGraphNode
      pTopologyPinMute,			// pTopologyPin From
      pTopologyPinSumInput,		// pTopologyPin To
      NULL,				// pPinInfo From
      NULL);				// pPinInfo To

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    Status = pTopologyConnection->AddList(
      &pLogicalFilterNode->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    return(Status);
}

//---------------------------------------------------------------------------

ENUMFUNC
VirtualizeFindPin(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    IN PVOID pReference
)
{
    NTSTATUS Status = STATUS_CONTINUE; 
    IN PPIN_INFO pPinInfo;

    Assert(pTopologyConnection);
    if(!IS_CONNECTION_TYPE(pTopologyConnection, FILTER)) {
	Status = STATUS_DEAD_END;
	goto exit;
    }

    if(fToDirection) {
       pPinInfo = pTopologyConnection->pPinInfoTo;
    }
    else {
       pPinInfo = pTopologyConnection->pPinInfoFrom;
    }

    if(pPinInfo == NULL) {
	ASSERT(Status == STATUS_CONTINUE);
	goto exit;
    }

    if(pPinInfo->pguidCategory == NULL) {
	ASSERT(Status == STATUS_CONTINUE);
	goto exit;
    }

    if(IsEqualGUID(pPinInfo->pguidCategory, &KSNODETYPE_SPEAKER)) {
	Status = STATUS_SUCCESS;
    }
exit:
    return(Status);
}

ENUMFUNC
EnumerateVirtualizeFindPin(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection
)
{
    ENUM_TOPOLOGY EnumTopology;
    NTSTATUS Status;

    Assert(pTopologyConnection);
    EnumTopology.cTopologyRecursion = 0;
    EnumTopology.Function = VirtualizeFindPin;
    EnumTopology.fToDirection = fToDirection;
    EnumTopology.pReference = NULL;
    Status = EnumerateTopologyConnection(pTopologyConnection, &EnumTopology);
    return(Status);
}

ENUMFUNC
VirtualizeFindNode(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    OUT PTOPOLOGY_NODE *ppTopologyNode,
    IN GUID const *pguidType
)
{
    NTSTATUS Status = STATUS_CONTINUE; 
    PTOPOLOGY_PIN pTopologyPin;

    Assert(pTopologyConnection);
    if(!IS_CONNECTION_TYPE(pTopologyConnection, FILTER)) {
	Status = STATUS_DEAD_END;
	goto exit;
    }

    if(fToDirection) {
       pTopologyPin = pTopologyConnection->pTopologyPinTo;
    }
    else {
       pTopologyPin = pTopologyConnection->pTopologyPinFrom;
    }

    if(pTopologyPin == NULL) {
	ASSERT(Status == STATUS_CONTINUE);
	goto exit;
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, &KSNODETYPE_SUM)) {
	Status = STATUS_DEAD_END;
	goto exit;
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, &KSNODETYPE_MUX)) {
	Status = STATUS_DEAD_END;
	goto exit;
    }

    if(IsEqualGUID(pTopologyPin->pTopologyNode->pguidType, pguidType)) {

	Status = EnumerateVirtualizeFindPin(pTopologyConnection, fToDirection);
        if(NT_SUCCESS(Status)) {
	    *ppTopologyNode = pTopologyPin->pTopologyNode;
	}
	ASSERT(Status != STATUS_DEAD_END);
    }
exit:
    return(Status);
}

ENUMFUNC
VirtualizeFindMute(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    OUT PTOPOLOGY_NODE *ppTopologyNode
)
{
    return(VirtualizeFindNode(
      pTopologyConnection,
      fToDirection,
      ppTopologyNode, 
      &KSNODETYPE_MUTE));
}

ENUMFUNC
VirtualizeFindVolume(
    IN PTOPOLOGY_CONNECTION pTopologyConnection,
    IN BOOL fToDirection,
    OUT PTOPOLOGY_NODE *ppTopologyNode
)
{
    return(VirtualizeFindNode(
      pTopologyConnection,
      fToDirection,
      ppTopologyNode, 
      &KSNODETYPE_VOLUME));
}

VOID
VirtualizeTopologyNode(
    IN PDEVICE_NODE pDeviceNode,
    IN PTOPOLOGY_NODE pTopologyNode,
    IN PVIRTUAL_SOURCE_LINE pVirtualSourceLine
)
{
    DPF3(100, "VirtualizeTopologyNode: real node #%d index %d %s", 
      pTopologyNode->ulRealNodeNumber, 
      pVirtualSourceLine->iVirtualSource,
      DbgGuid2Sz(&pVirtualSourceLine->guidCategory));

    ASSERT(
      (pTopologyNode->iVirtualSource == MAXULONG) ||
      (pTopologyNode->iVirtualSource == pVirtualSourceLine->iVirtualSource));

    // The PinId of a virtual pininfo has VirtualSourceData index
    pTopologyNode->iVirtualSource = pVirtualSourceLine->iVirtualSource;

    if(pVirtualSourceLine->ulFlags & VSL_FLAGS_CREATE_ONLY) {
	pTopologyNode->ulFlags |= TN_FLAGS_DONT_FORWARD;
    }
    ASSERT(pTopologyNode->iVirtualSource < pDeviceNode->cVirtualSourceData);

    if(IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_VOLUME)) {
	pDeviceNode->papVirtualSourceData[
	  pTopologyNode->iVirtualSource]->pTopologyNode = pTopologyNode;
    }
}

NTSTATUS
AddVirtualMute(
    IN PDEVICE_NODE pDeviceNode,
    IN PTOPOLOGY_NODE pTopologyNodeVolume,
    IN PVIRTUAL_SOURCE_LINE pVirtualSourceLine
)
{
    PTOPOLOGY_CONNECTION pTopologyConnectionNew = NULL;
    PTOPOLOGY_CONNECTION pTopologyConnection = NULL;
    PTOPOLOGY_NODE pTopologyNodeMute = NULL;
    PTOPOLOGY_PIN pTopologyPinMuteInput = NULL;
    PTOPOLOGY_PIN pTopologyPinMuteOutput = NULL;
    PTOPOLOGY_PIN pTopologyPinVolumeOutput = NULL;
    PLOGICAL_FILTER_NODE pLogicalFilterNode;
    NTSTATUS Status;

    ASSERT(pTopologyNodeVolume->iVirtualSource != MAXULONG);

    FOR_EACH_LIST_ITEM(
      &pTopologyNodeVolume->lstTopologyPin,
      pTopologyPinVolumeOutput) {

	if(pTopologyPinVolumeOutput->ulPinNumber == KSNODEPIN_STANDARD_OUT) {
	    break;
	}

    } END_EACH_LIST_ITEM

    if(pTopologyPinVolumeOutput == NULL) {
	Trap();
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }
    ASSERT(pTopologyPinVolumeOutput->ulPinNumber == KSNODEPIN_STANDARD_OUT);

    FOR_EACH_LIST_ITEM(
      &pTopologyPinVolumeOutput->lstTopologyConnection,
      pTopologyConnection) {

	Assert(pTopologyConnection);
	if(EnumerateVirtualizeFindPin(
	  pTopologyConnection,
	  TRUE) == STATUS_SUCCESS) {	// Assumes KSPIN_DATAFLOW_IN
	    break;
	}

    } END_EACH_LIST_ITEM

    if(pTopologyConnection == NULL) {
	Trap();
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }
    ASSERT(pTopologyConnection->pTopologyPinFrom == pTopologyPinVolumeOutput);

    Status = CTopologyNode::Create(
      &pTopologyNodeMute,
      pTopologyNodeVolume->pFilterNode,
      MAXULONG,
      (GUID *)&KSNODETYPE_MUTE);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    VirtualizeTopologyNode(pDeviceNode, pTopologyNodeMute, pVirtualSourceLine);

    Status = CTopologyPin::Create(
      &pTopologyPinMuteInput,
      KSNODEPIN_STANDARD_IN,		// 1 = input
      pTopologyNodeMute);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = CTopologyPin::Create(
      &pTopologyPinMuteOutput,
      KSNODEPIN_STANDARD_OUT,		// 0 = output
      pTopologyNodeMute);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = CTopologyConnection::Create(
      &pTopologyConnectionNew,
      pTopologyNodeVolume->pFilterNode,	// pFilterNode
      NULL,				// pGraphNode
      pTopologyPinVolumeOutput,		// pTopologyPin From
      pTopologyPinMuteInput,		// pTopologyPin To
      NULL,				// pPinInfo From
      NULL);				// pPinInfo To

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    Status = pTopologyConnection->AddList(
      &pTopologyPinMuteOutput->lstTopologyConnection);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    FOR_EACH_LIST_ITEM(
      &pTopologyNodeVolume->lstLogicalFilterNode,
      pLogicalFilterNode) {

	Status = pLogicalFilterNode->AddList(
	  &pTopologyNodeMute->lstLogicalFilterNode);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	Status = pLogicalFilterNode->lstTopologyNode.AddList(pTopologyNodeMute);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	Status = pTopologyConnectionNew->AddList(
	  &pLogicalFilterNode->lstTopologyConnection);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM

    pTopologyConnection->pTopologyPinFrom = pTopologyPinMuteOutput;

    pTopologyConnection->RemoveList(
      &pTopologyPinVolumeOutput->lstTopologyConnection);
exit:
    if(!NT_SUCCESS(Status)) {
	Trap();
	if(pTopologyConnectionNew != NULL) {
	    Trap();
	    pTopologyConnectionNew->Destroy();
	}
	if(pTopologyNodeMute != NULL) {
	    if(pTopologyNodeVolume != NULL) {
		Trap();
		pTopologyNodeMute->RemoveList(
		  &pTopologyNodeVolume->pFilterNode->lstTopologyNode);

		FOR_EACH_LIST_ITEM(
		  &pTopologyNodeVolume->lstLogicalFilterNode,
		  pLogicalFilterNode) {

		    pLogicalFilterNode->lstTopologyNode.RemoveList(
		      pTopologyNodeMute);

		} END_EACH_LIST_ITEM
	    }
	    pTopologyNodeMute->Destroy();
	}
    }
    return(Status);
}

NTSTATUS
VirtualizeTopology(
    PDEVICE_NODE pDeviceNode,
    PFILTER_NODE pFilterNode

)
{
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine;
    PTOPOLOGY_NODE pTopologyNodeVolume;
    PTOPOLOGY_NODE pTopologyNodeMute;
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_INFO pPinInfo;

    FOR_EACH_LIST_ITEM(&pFilterNode->lstPinInfo, pPinInfo) {

	if(pPinInfo->pguidCategory == NULL) {
	    continue;
	}
	FOR_EACH_LIST_ITEM(gplstVirtualSourceLine, pVirtualSourceLine) {

	    if(pPinInfo->DataFlow != KSPIN_DATAFLOW_IN) {
		continue;
	    }
	    if(!IsEqualGUID(
	      pPinInfo->pguidCategory,
	      &pVirtualSourceLine->guidCategory)) {
		continue;
	    }
	    if(EnumerateTopology(
	      pPinInfo,
	      (TOP_PFN)VirtualizeFindVolume,
	      &pTopologyNodeVolume) == STATUS_SUCCESS) {

		VirtualizeTopologyNode(
		  pDeviceNode,
		  pTopologyNodeVolume,
		  pVirtualSourceLine);

		if(EnumerateTopology(
		  pPinInfo,
		  (TOP_PFN)VirtualizeFindMute,
		  &pTopologyNodeMute) == STATUS_SUCCESS) {

		    VirtualizeTopologyNode(
		      pDeviceNode,
		      pTopologyNodeMute,
		      pVirtualSourceLine);
		}
		else {
		    Status = AddVirtualMute(
		      pDeviceNode,
		      pTopologyNodeVolume,
		      pVirtualSourceLine);

		    if(!NT_SUCCESS(Status)) {
			Trap();
			goto exit;
		    }
		}
	    }

	} END_EACH_LIST_ITEM

    } END_EACH_LIST_ITEM
exit:
    return(Status);
}

//---------------------------------------------------------------------------

NTSTATUS
CreateVirtualSource(
    IN PIRP	pIrp,
    PSYSAUDIO_CREATE_VIRTUAL_SOURCE pCreateVirtualSource,
    OUT PULONG	pulMixerPinId
)
{
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILTER_INSTANCE pFilterInstance;
    PIO_STACK_LOCATION pIrpStack;
    PDEVICE_NODE pDeviceNode;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    Assert(pFilterInstance);

    if(!pFilterInstance->IsChildInstance()) {
	Trap();
	DPF(5, "CreateVirtualSource: FAILED - open pin instances");
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }

    FOR_EACH_LIST_ITEM(gplstVirtualSourceLine, pVirtualSourceLine) {

	if(!IsEqualGUID(
	  &pVirtualSourceLine->guidCategory,
	  &pCreateVirtualSource->PinCategory)) {
	    continue;
	}
	if(!IsEqualGUID(
	  &pVirtualSourceLine->guidName,
	  &pCreateVirtualSource->PinName)) {
	    continue;
	}
	ASSERT(NT_SUCCESS(Status));
	goto dup;

    } END_EACH_LIST_ITEM

    pVirtualSourceLine = new VIRTUAL_SOURCE_LINE(pCreateVirtualSource);
    if(pVirtualSourceLine == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	Trap();
	goto exit;
    }

    FOR_EACH_LIST_ITEM(gplstDeviceNode, pDeviceNode) {

	DPF2(60, "CreateVirtualSource: DN %08x %s",
	  pDeviceNode,
	  pDeviceNode->DumpName());

	Status = pDeviceNode->Update();
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}

    } END_EACH_LIST_ITEM
dup:
    *pulMixerPinId = pVirtualSourceLine->iVirtualSource;
    pIrp->IoStatus.Information = sizeof(ULONG);
exit:
    if(!NT_SUCCESS(Status)) {
	delete pVirtualSourceLine;
    }
    return(Status);
}

NTSTATUS
AttachVirtualSource(
    IN PIRP pIrp,
    IN PSYSAUDIO_ATTACH_VIRTUAL_SOURCE pAttachVirtualSource,
    IN OUT PVOID pData
)
{
    PVIRTUAL_NODE_DATA pVirtualNodeData = NULL;
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PVIRTUAL_SOURCE_DATA pVirtualSourceData;
    NTSTATUS Status = STATUS_SUCCESS;
    PPIN_INSTANCE pPinInstance;
    PDEVICE_NODE pDeviceNode;
    LONG Channel;

    Status = ::GetStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    pPinInstance = pStartNodeInstance->pPinInstance;
    Assert(pPinInstance);
    Assert(pPinInstance->pFilterInstance);
    Assert(pPinInstance->pFilterInstance->pGraphNodeInstance);

    pDeviceNode = pPinInstance->pFilterInstance->GetDeviceNode();
    Assert(pDeviceNode);

    if(pAttachVirtualSource->MixerPinId >= pDeviceNode->cVirtualSourceData) {
	DPF(5, "AttachVirtualSource: invalid MixerPinId");
	Status = STATUS_INVALID_DEVICE_REQUEST;
	goto exit;
    }
    ASSERT(pDeviceNode->papVirtualSourceData != NULL);
    pVirtualSourceData = 
      pDeviceNode->papVirtualSourceData[pAttachVirtualSource->MixerPinId];
    Assert(pVirtualSourceData);

    Status = GetVolumeNodeNumber(pPinInstance, pVirtualSourceData);
    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    if(pPinInstance->ulVolumeNodeNumber == MAXULONG) {
	ASSERT(NT_SUCCESS(Status));
	goto exit;
    }

    pVirtualNodeData = new VIRTUAL_NODE_DATA(
      pStartNodeInstance,
      pVirtualSourceData);

    if(pVirtualNodeData == NULL) {
	Trap();
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }

    if(pVirtualSourceData->pTopologyNode->ulRealNodeNumber != MAXULONG) {
	ULONG ulNodeNumber;

	//
	// Get the volume control range for the physical node
	//

	ulNodeNumber = pPinInstance->pFilterInstance->pGraphNodeInstance->
	  paulNodeNumber[pAttachVirtualSource->MixerPinId];

	if(ulNodeNumber == pPinInstance->ulVolumeNodeNumber) {
	    ASSERT(NT_SUCCESS(Status));
	    delete pVirtualNodeData;
	    goto exit;
	}

	Status = pStartNodeInstance->GetTopologyNodeFileObject(
	    &pVirtualNodeData->pFileObject,
	    ulNodeNumber);

	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
	pVirtualNodeData->NodeId = 
	  pVirtualSourceData->pTopologyNode->ulRealNodeNumber;

	Status = GetControlRange(pVirtualNodeData);
	if(!NT_SUCCESS(Status)) {
	    goto exit;
	}
	pVirtualSourceData->MinimumValue = pVirtualNodeData->MinimumValue;
	pVirtualSourceData->MaximumValue = pVirtualNodeData->MaximumValue;
	pVirtualSourceData->Steps = pVirtualNodeData->Steps;
    }

    Status = pStartNodeInstance->GetTopologyNodeFileObject(
        &pVirtualNodeData->pFileObject,
        pPinInstance->ulVolumeNodeNumber);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
    pVirtualNodeData->NodeId = pPinInstance->pFilterInstance->
      pGraphNodeInstance->papTopologyNode[pPinInstance->ulVolumeNodeNumber]->
      ulRealNodeNumber;

    Status = GetControlRange(pVirtualNodeData);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    for(Channel = 0; Channel < pVirtualSourceData->cChannels; Channel++) {
	Status = SetVirtualVolume(pVirtualNodeData, Channel);
	if(!NT_SUCCESS(Status)) {
	    Trap();
	    goto exit;
	}
    }
exit:
    if(!NT_SUCCESS(Status)) {
	delete pVirtualNodeData;
    }
    return(Status);
}

NTSTATUS
FilterVirtualPropertySupportHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PVOID pData
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PTOPOLOGY_NODE pTopologyNode;
    NTSTATUS Status;

    Status = GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    Assert(pGraphNodeInstance);

    Status = STATUS_NOT_FOUND;
    if((pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY) == 0) {
	DPF(5, "FilterVirtualPropertySupportHandler: no TOPOLOGY bit");
	ASSERT(Status == STATUS_NOT_FOUND);
	goto exit;
    }
    if(pNodeProperty->NodeId >= 
       pGraphNodeInstance->Topology.TopologyNodesCount) {
	DPF(5, "FilterVirtualPropertySupportHandler: invalid node #");
	ASSERT(Status == STATUS_NOT_FOUND);
	goto exit;
    }
    pTopologyNode = pGraphNodeInstance->papTopologyNode[pNodeProperty->NodeId];
    Assert(pTopologyNode);

    if(pTopologyNode->ulRealNodeNumber == MAXULONG) {
	ASSERT(pTopologyNode->iVirtualSource != MAXULONG);
	Status = STATUS_SOME_NOT_MAPPED;
	goto exit;
    }
    ASSERT(Status == STATUS_NOT_FOUND);
exit:
    return(Status);
}

NTSTATUS
FilterVirtualPropertyHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PLONG plLevel
)
{
    PGRAPH_NODE_INSTANCE pGraphNodeInstance;
    PVIRTUAL_SOURCE_DATA pVirtualSourceData;
    PVIRTUAL_NODE_DATA pVirtualNodeData;
    PIO_STACK_LOCATION pIrpStack;
    PTOPOLOGY_NODE pTopologyNode;
    LONG StopChannel, Channel;
    NTSTATUS Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    Status = GetGraphNodeInstance(pIrp, &pGraphNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    Assert(pGraphNodeInstance);

    if(((pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY) == 0) ||
      (pNodeProperty->NodeId >= 
       pGraphNodeInstance->Topology.TopologyNodesCount)) {
        DPF(5, "FilterVirtualPropertyHandler: invalid property");
        Status = STATUS_NOT_FOUND;
        goto exit;
    }
    pTopologyNode = pGraphNodeInstance->papTopologyNode[pNodeProperty->NodeId];

    Assert(pTopologyNode);
    if(pTopologyNode->iVirtualSource == MAXULONG) {
        Status = STATUS_NOT_FOUND;
        goto exit;
    }

    ASSERT(pTopologyNode->iVirtualSource < gcVirtualSources);
    ASSERT(pGraphNodeInstance->pGraphNode->pDeviceNode->
      papVirtualSourceData != NULL);

    pVirtualSourceData = pGraphNodeInstance->pGraphNode->pDeviceNode->
      papVirtualSourceData[pTopologyNode->iVirtualSource];

    Assert(pVirtualSourceData);
    if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength < 
       sizeof(KSNODEPROPERTY_AUDIO_CHANNEL) ||
      (pNodeProperty->Property.Id != KSPROPERTY_AUDIO_VOLUMELEVEL &&
       pNodeProperty->Property.Id != KSPROPERTY_AUDIO_MUTE)) {
        Trap();
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    Channel = ((PKSNODEPROPERTY_AUDIO_CHANNEL)pNodeProperty)->Channel;
    StopChannel = Channel;

    if(Channel == MAXULONG) {
        Channel = 0;
        StopChannel = pVirtualSourceData->cChannels - 1;
    }

    if(Channel >= MAX_NUM_CHANNELS || Channel < 0) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    for(; Channel <= StopChannel; Channel++) {

        if(IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_MUTE)) {

            if(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET) {
              *plLevel = pVirtualSourceData->fMuted[Channel];
                pIrp->IoStatus.Information = sizeof(LONG);
            }
            else {
                ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_SET);
                pVirtualSourceData->fMuted[Channel] = *plLevel;

                if(pTopologyNode->ulRealNodeNumber == MAXULONG) {

                    Status = SetPhysicalVolume(
                      pGraphNodeInstance,
                      pVirtualSourceData,
                      Channel);

                    if(!NT_SUCCESS(Status)) {
                        Trap();
                        goto exit;
                    }
                }
            }
        }
        else if(IsEqualGUID(pTopologyNode->pguidType, &KSNODETYPE_VOLUME)) {

            if(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET) {
                *plLevel = pVirtualSourceData->lLevel[Channel];
                pIrp->IoStatus.Information = sizeof(LONG);
            }
            else {
                ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_SET);
                pVirtualSourceData->lLevel[Channel] = *plLevel;
            }
        }
        else {
            DPF2(5, "Invalid TopologyNode Prop.Id %d Node.Id %d",
                pNodeProperty->Property.Id,
                pTopologyNode->ulRealNodeNumber);
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto exit;
        }
        ASSERT(NT_SUCCESS(Status));

        if(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_SET) {

            FOR_EACH_LIST_ITEM(
              &pVirtualSourceData->lstVirtualNodeData,
              pVirtualNodeData) {

                ASSERT(pVirtualSourceData == 
                  pVirtualNodeData->pVirtualSourceData);

                Status = SetVirtualVolume(pVirtualNodeData, Channel);
                if(!NT_SUCCESS(Status)) {
                    Trap();
                    goto exit;
                }

            } END_EACH_LIST_ITEM
        }
    }

    if(pTopologyNode->ulRealNodeNumber == MAXULONG ||
       pTopologyNode->ulFlags & TN_FLAGS_DONT_FORWARD ||
       pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET) {
        Status = STATUS_SUCCESS;
    }
    else {
        // If topology node has a real node number, forward the irp to it
        Status = STATUS_NOT_FOUND;
    }
    
exit:
    return(Status);
}

NTSTATUS
PinVirtualPropertySupportHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PVOID pData
)
{
    return(STATUS_NOT_FOUND);
}

NTSTATUS
PinVirtualPropertyHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodePropertyAudioChannel,
    IN OUT PLONG plLevel
)
{
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PFILTER_INSTANCE pFilterInstance;
    NTSTATUS Status = STATUS_SUCCESS;
    PKSNODEPROPERTY pNodeProperty;
    PPIN_INSTANCE pPinInstance;
    LONG StopChannel, Channel;

    Status = ::GetStartNodeInstance(pIrp, &pStartNodeInstance);
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }
    pPinInstance = pStartNodeInstance->pPinInstance;
    Assert(pPinInstance);

    pFilterInstance = pPinInstance->pFilterInstance;
    Assert(pFilterInstance);
    Assert(pFilterInstance->pGraphNodeInstance);

    pNodeProperty = &pNodePropertyAudioChannel->NodeProperty;
    if(((pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY) == 0) ||
      (pNodeProperty->NodeId >= 
        pFilterInstance->pGraphNodeInstance->Topology.TopologyNodesCount)) {
        DPF(5, "PinVirtualPropertyHandler: invalid property");
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    if(pStartNodeInstance->pVirtualNodeData == NULL ||
       pPinInstance->ulVolumeNodeNumber == MAXULONG ||
       pPinInstance->ulVolumeNodeNumber != pNodeProperty->NodeId) {
        Status = STATUS_NOT_FOUND;
        goto exit;
    }
    Assert(pStartNodeInstance->pVirtualNodeData);
    Assert(pStartNodeInstance->pVirtualNodeData->pVirtualSourceData);

    StopChannel = Channel = pNodePropertyAudioChannel->Channel;
    if(Channel == MAXULONG) {
        Channel = 0;
        StopChannel = pStartNodeInstance->pVirtualNodeData->
          pVirtualSourceData->cChannels - 1;
    }

    if(Channel >= MAX_NUM_CHANNELS || Channel < 0) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto exit;
    }

    for(; Channel <= StopChannel; Channel++) {

        if(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET) {
            *plLevel = pStartNodeInstance->pVirtualNodeData->lLevel[Channel];
            pIrp->IoStatus.Information = sizeof(LONG);
            ASSERT(NT_SUCCESS(Status));
        }
        else {
            ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_SET);
            pStartNodeInstance->pVirtualNodeData->lLevel[Channel] = *plLevel;

            Status = SetVirtualVolume(
              pStartNodeInstance->pVirtualNodeData,
              Channel);

            if(!NT_SUCCESS(Status)) {
                Trap();
                goto exit;
            }
        }
    }
    
exit:
    return(Status);
}

NTSTATUS
GetControlRange(
    PVIRTUAL_NODE_DATA pVirtualNodeData
)
{
    PKSPROPERTY_DESCRIPTION pPropertyDescription = NULL;
    PKSPROPERTY_MEMBERSHEADER pMemberHeader;
    PKSPROPERTY_STEPPING_LONG pSteppingLong;
    NTSTATUS Status = STATUS_SUCCESS;

    // Setup the defaults
    pVirtualNodeData->MinimumValue = (-96 * 65536);
    pVirtualNodeData->MaximumValue = 0;
    pVirtualNodeData->Steps = (65536/2);	// 1/2 db steps

    Status = QueryPropertyRange(
      pVirtualNodeData->pFileObject,
      &KSPROPSETID_Audio,
      KSPROPERTY_AUDIO_VOLUMELEVEL,
      pVirtualNodeData->NodeId,
      &pPropertyDescription);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    if((pPropertyDescription->MembersListCount == 0) ||
       (!IsEqualGUID(
	 &pPropertyDescription->PropTypeSet.Set,
	 &KSPROPTYPESETID_General)) ||
       (pPropertyDescription->PropTypeSet.Id != VT_I4)) {
	Status = STATUS_NOT_SUPPORTED;
	goto exit;
    }

    pMemberHeader = (PKSPROPERTY_MEMBERSHEADER)(pPropertyDescription + 1);
    if(pMemberHeader->MembersFlags & KSPROPERTY_MEMBER_STEPPEDRANGES) {

        pSteppingLong = (PKSPROPERTY_STEPPING_LONG)(pMemberHeader + 1);
        pVirtualNodeData->MinimumValue = pSteppingLong->Bounds.SignedMinimum;
        pVirtualNodeData->MaximumValue = pSteppingLong->Bounds.SignedMaximum;
	pVirtualNodeData->Steps = pSteppingLong->SteppingDelta;
    }
    else {
	Trap();
	Status = STATUS_NOT_SUPPORTED;
	goto exit;
    }
exit:
    delete pPropertyDescription;
    return(STATUS_SUCCESS);
}

NTSTATUS
QueryPropertyRange(
    PFILE_OBJECT pFileObject,
    CONST GUID *pguidPropertySet,
    ULONG ulPropertyId,
    ULONG ulNodeId,
    PKSPROPERTY_DESCRIPTION *ppPropertyDescription
)
{
    KSPROPERTY_DESCRIPTION PropertyDescription;
    KSNODEPROPERTY NodeProperty;
    ULONG BytesReturned;
    NTSTATUS Status;

    NodeProperty.Property.Set = *pguidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags =
      KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodeProperty,
      sizeof(NodeProperty),
      &PropertyDescription,
      sizeof(PropertyDescription),
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    ASSERT(BytesReturned == sizeof(PropertyDescription));

    *ppPropertyDescription =
      (PKSPROPERTY_DESCRIPTION)new BYTE[PropertyDescription.DescriptionSize];

    if(*ppPropertyDescription == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodeProperty,
      sizeof( NodeProperty ),
      *ppPropertyDescription,
      PropertyDescription.DescriptionSize,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
	delete *ppPropertyDescription;
	*ppPropertyDescription = NULL;
	goto exit;
    }
exit:				    
    return(Status);
}

NTSTATUS
SetVirtualVolume(
    PVIRTUAL_NODE_DATA pVirtualNodeData,
    LONG Channel
)
{
    KSNODEPROPERTY_AUDIO_CHANNEL NodePropertyAudioChannel;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned;
    LONG lLevel;

    ASSERT(pVirtualNodeData->NodeId != MAXULONG);
    Assert(pVirtualNodeData->pVirtualSourceData);

    NodePropertyAudioChannel.NodeProperty.Property.Set =
      KSPROPSETID_Audio;
    NodePropertyAudioChannel.NodeProperty.Property.Id =
      KSPROPERTY_AUDIO_VOLUMELEVEL;
    NodePropertyAudioChannel.NodeProperty.Property.Flags =
      KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    NodePropertyAudioChannel.NodeProperty.NodeId = pVirtualNodeData->NodeId;
    NodePropertyAudioChannel.Channel = Channel;
    NodePropertyAudioChannel.Reserved = 0;

    if(pVirtualNodeData->pVirtualSourceData->fMuted[Channel]) {
	lLevel = LONG_MIN;
    }
    else {
	if(pVirtualNodeData->pVirtualSourceData->lLevel[Channel] == LONG_MIN) {
	    lLevel = LONG_MIN;
	}
	else {
	    lLevel = pVirtualNodeData->lLevel[Channel];
	    if(lLevel != LONG_MIN) {
		lLevel += pVirtualNodeData->pVirtualSourceData->lLevel[Channel];
		lLevel = MapVirtualLevel(pVirtualNodeData, lLevel);
	    }
	}
    }
    AssertFileObject(pVirtualNodeData->pFileObject);
    Status = KsSynchronousIoControlDevice(
      pVirtualNodeData->pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodePropertyAudioChannel,
      sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
      &lLevel,
      sizeof(LONG),
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
	DPF4(10, "SetVirtualVolume: [%d] SNI %08x N# %u FAILED %08x",
	  Channel,
	  pVirtualNodeData->pStartNodeInstance,
	  pVirtualNodeData->NodeId,
	  Status);
    }
    return(STATUS_SUCCESS);
}

NTSTATUS
SetPhysicalVolume(
    PGRAPH_NODE_INSTANCE pGraphNodeInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData,
    LONG Channel
)
{
    KSNODEPROPERTY_AUDIO_CHANNEL NodePropertyAudioChannel;
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_OBJECT pFileObject;
    ULONG BytesReturned;
    LONG lLevel;

    Assert(pGraphNodeInstance);
    Assert(pVirtualSourceData);
    ASSERT(IsEqualGUID(
      pVirtualSourceData->pTopologyNode->pguidType,
      &KSNODETYPE_VOLUME));

    if(pVirtualSourceData->pTopologyNode->ulRealNodeNumber == MAXULONG) {
	ASSERT(NT_SUCCESS(Status));
	goto exit;
    }
    ASSERT(pVirtualSourceData->pTopologyNode->iVirtualSource < 
      gcVirtualSources);

    Status = pGraphNodeInstance->GetTopologyNodeFileObject(
      &pFileObject,
      pGraphNodeInstance->paulNodeNumber[
	pVirtualSourceData->pTopologyNode->iVirtualSource]);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    NodePropertyAudioChannel.NodeProperty.Property.Set =
      KSPROPSETID_Audio;

    NodePropertyAudioChannel.NodeProperty.Property.Id =
      KSPROPERTY_AUDIO_VOLUMELEVEL;

    NodePropertyAudioChannel.NodeProperty.Property.Flags =
      KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    NodePropertyAudioChannel.NodeProperty.NodeId =
      pVirtualSourceData->pTopologyNode->ulRealNodeNumber;

    NodePropertyAudioChannel.Channel = Channel;
    NodePropertyAudioChannel.Reserved = 0;

    if(pVirtualSourceData->fMuted[Channel]) {
	lLevel = LONG_MIN;
    }
    else {
	lLevel = pVirtualSourceData->lLevel[Channel];
    }

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodePropertyAudioChannel,
      sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),
      &lLevel,
      sizeof(LONG),
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    if(!NT_SUCCESS(Status)) {
	DPF2(10, "SetPhysicalVolume: [%d] FAILED %08x", Channel, Status);
    }
    return(Status);
}

LONG
MapVirtualLevel(
    PVIRTUAL_NODE_DATA pVirtualNodeData,
    LONG lLevel
)
{
    DPF4(100, "MapVirtualLevel: from %d max %d min %d step %d", 
      lLevel / 65536,
      pVirtualNodeData->pVirtualSourceData->MaximumValue / 65536,
      pVirtualNodeData->pVirtualSourceData->MinimumValue / 65536,
      pVirtualNodeData->pVirtualSourceData->Steps / 65536);

    if(lLevel != LONG_MIN) {
	lLevel += pVirtualNodeData->MaximumValue -
	  pVirtualNodeData->pVirtualSourceData->MaximumValue;
    }

    DPF4(100, "MapVirtualLevel: to %d max %d min %d step %d",
      lLevel / 65536,
      pVirtualNodeData->MaximumValue / 65536,
      pVirtualNodeData->MinimumValue / 65536,
      pVirtualNodeData->Steps / 65536);

    return(lLevel);
}

NTSTATUS
GetVolumeNodeNumber(
    PPIN_INSTANCE pPinInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData OPTIONAL
)
{
    PSTART_NODE pStartNode;
    NTSTATUS Status = STATUS_SUCCESS;
    KSAUDIO_MIXCAP_TABLE AudioMixCapTable;
    // This indicates to GetSuperMixCaps to only get in/out channels
    PKSAUDIO_MIXCAP_TABLE pAudioMixCapTable = &AudioMixCapTable;

    Assert(pPinInstance);
    Assert(pPinInstance->pFilterInstance);
    Assert(pPinInstance->pFilterInstance->pGraphNodeInstance);

    if(pPinInstance->ulVolumeNodeNumber == MAXULONG) {
	Assert(pPinInstance->pStartNodeInstance);
	pStartNode = pPinInstance->pStartNodeInstance->pStartNode;
	Assert(pStartNode);
	Assert(pStartNode->GetStartInfo());
	pPinInstance->ulVolumeNodeNumber =
	  pStartNode->GetStartInfo()->ulVolumeNodeNumberPre;

	if(pStartNode->GetStartInfo()->ulVolumeNodeNumberSuperMix != MAXULONG &&
	   pStartNode->GetStartInfo()->ulVolumeNodeNumberPost != MAXULONG) {

	    Status = GetSuperMixCaps(
	      &pAudioMixCapTable,
	      pPinInstance->pStartNodeInstance,
	      pStartNode->GetStartInfo()->ulVolumeNodeNumberSuperMix);

	    if(!NT_SUCCESS(Status)) {
		Status = STATUS_SUCCESS;
		goto exit;
	    }
	    if(pAudioMixCapTable->OutputChannels != 1) {
		pPinInstance->ulVolumeNodeNumber = 
		  pStartNode->GetStartInfo()->ulVolumeNodeNumberPost;

		if(pVirtualSourceData != NULL) {
		    pVirtualSourceData->cChannels = 
		      pAudioMixCapTable->OutputChannels;
		}
	    }
	}
	DPF2(100, "GetVolumeNodeNumber: SN %08x %02x",
	  pStartNode,
	  pPinInstance->ulVolumeNodeNumber);
    }
exit:
    return(Status);
}

NTSTATUS
GetSuperMixCaps(
    OUT PKSAUDIO_MIXCAP_TABLE *ppAudioMixCapTable,
    IN PSTART_NODE_INSTANCE pStartNodeInstance,
    IN ULONG NodeId
)
{
    KSAUDIO_MIXCAP_TABLE AudioMixCapTable;
    NTSTATUS Status = STATUS_SUCCESS;
    KSNODEPROPERTY NodeProperty;
    PFILE_OBJECT pFileObject;
    ULONG BytesReturned;
    ULONG cb;

    Assert(pStartNodeInstance);
    ASSERT(NodeId != MAXULONG);
      
    Status = pStartNodeInstance->GetTopologyNodeFileObject(
      &pFileObject,
      NodeId);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }

    NodeProperty.Property.Set = KSPROPSETID_Audio;
    NodeProperty.Property.Id = KSPROPERTY_AUDIO_MIX_LEVEL_CAPS;
    NodeProperty.Property.Flags = 
      KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    NodeProperty.NodeId = pStartNodeInstance->pPinInstance->pFilterInstance->
      pGraphNodeInstance->papTopologyNode[NodeId]->ulRealNodeNumber;
    NodeProperty.Reserved = 0;
    ASSERT(NodeProperty.NodeId != MAXULONG);

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodeProperty,
      sizeof(KSNODEPROPERTY),
      &AudioMixCapTable,
      sizeof(KSAUDIO_MIXCAP_TABLE) - sizeof(KSAUDIO_MIX_CAPS),
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    if(*ppAudioMixCapTable != NULL) {
	**ppAudioMixCapTable = AudioMixCapTable;
	ASSERT(NT_SUCCESS(Status));
	goto exit;
    }

    cb = (AudioMixCapTable.InputChannels * 
      AudioMixCapTable.OutputChannels *
      sizeof(KSAUDIO_MIX_CAPS)) +
      sizeof(KSAUDIO_MIXCAP_TABLE) - sizeof(KSAUDIO_MIX_CAPS);

    *ppAudioMixCapTable = (PKSAUDIO_MIXCAP_TABLE)new BYTE[cb];
    if(*ppAudioMixCapTable == NULL) {
	Status = STATUS_INSUFFICIENT_RESOURCES;
	goto exit;
    }

    AssertFileObject(pFileObject);
    Status = KsSynchronousIoControlDevice(
      pFileObject,
      KernelMode,
      IOCTL_KS_PROPERTY,
      &NodeProperty,
      sizeof(KSNODEPROPERTY),
      *ppAudioMixCapTable,
      cb,
      &BytesReturned);

    if(!NT_SUCCESS(Status)) {
	Trap();
	goto exit;
    }
exit:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\virtual.h ===
//---------------------------------------------------------------------------
//
//  Module:   virtual.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
CreateVirtualMixer(
    PDEVICE_NODE pDeviceNode
);

NTSTATUS
CreateVirtualLine(
    PDEVICE_NODE pDeviceNode,
    PFILTER_NODE pFilterNode,
    PTOPOLOGY_NODE pTopologyNodeSum,
    PLOGICAL_FILTER_NODE pLogicalFilterNode,
    PVIRTUAL_SOURCE_LINE pVirtualSourceLine
);

//---------------------------------------------------------------------------

NTSTATUS VirtualizeTopology(
    PDEVICE_NODE pDeviceNode,
    PFILTER_NODE pFilterNode
);

//---------------------------------------------------------------------------

NTSTATUS
CreateVirtualSource(
    IN PIRP pIrp,
    PSYSAUDIO_CREATE_VIRTUAL_SOURCE pCreateVirtualSource,
    OUT PULONG	pulMixerPinId
);

NTSTATUS
AttachVirtualSource(
    IN PIRP pIrp,
    IN PSYSAUDIO_ATTACH_VIRTUAL_SOURCE pAttachVirtualSource,
    IN OUT PVOID pData
);

NTSTATUS
FilterVirtualPropertySupportHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PVOID pData
);

NTSTATUS
FilterVirtualPropertyHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PLONG plLevel
);

NTSTATUS
PinVirtualPropertySupportHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY pNodeProperty,
    IN OUT PVOID pData
);

NTSTATUS
PinVirtualPropertyHandler(
    IN PIRP pIrp,
    IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodePropertyAudioChannel,
    IN OUT PLONG plLevel
);

NTSTATUS
GetControlRange(
    PVIRTUAL_NODE_DATA pVirtualNodeData
);

NTSTATUS
QueryPropertyRange(
    PFILE_OBJECT pFileObject,
    CONST GUID *pguidPropertySet,
    ULONG ulPropertyId,
    ULONG ulNodeId,
    PKSPROPERTY_DESCRIPTION *ppPropertyDescription
);

NTSTATUS
SetVirtualVolume(
    PVIRTUAL_NODE_DATA pVirtualNodeData,
    LONG Channel
);

NTSTATUS
SetPhysicalVolume(
    PGRAPH_NODE_INSTANCE pGraphNodeInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData,
    LONG Channel
);

LONG
MapVirtualLevel(
    PVIRTUAL_NODE_DATA pVirtualNodeData,
    LONG lLevel
);

NTSTATUS
GetVolumeNodeNumber(
    PPIN_INSTANCE pPinInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData OPTIONAL
);

NTSTATUS
GetSuperMixCaps(
    OUT PKSAUDIO_MIXCAP_TABLE *ppAudioMixCapTable,
    IN PSTART_NODE_INSTANCE pStartNodeInstance,
    IN ULONG NodeId
);

//---------------------------------------------------------------------------
//  End of File: virtual.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\vnd.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   vnd.cpp
//
//  Description:
//
//	Virtual Node Data Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CVirtualNodeData::CVirtualNodeData(
    PSTART_NODE_INSTANCE pStartNodeInstance,
    PVIRTUAL_SOURCE_DATA pVirtualSourceData
)
{
    pStartNodeInstance->pVirtualNodeData = this;
    this->pVirtualSourceData = pVirtualSourceData;
    this->pStartNodeInstance = pStartNodeInstance;
    AddList(&pVirtualSourceData->lstVirtualNodeData);
}
    
CVirtualNodeData::~CVirtualNodeData(
)
{
    Assert(this); 
    RemoveList();
    ASSERT(pStartNodeInstance->pVirtualNodeData == this);
    pStartNodeInstance->pVirtualNodeData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\vnd.h ===
//---------------------------------------------------------------------------
//
//  Module:   		vnd.h
//
//  Description:	Virtual Node Data Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define	MAX_NUM_CHANNELS	24

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CVirtualNodeData : public CListDoubleItem
{
public:
    CVirtualNodeData(
	PSTART_NODE_INSTANCE pStartNodeInstance,
	PVIRTUAL_SOURCE_DATA pVirtualSourceData
    );
    ~CVirtualNodeData();
    ENUMFUNC Destroy()
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };
#ifdef DEBUG
    ENUMFUNC Dump()
    {
	int i;
	dprintf(
	  "VND: %08x VSD %08x SNI %08x FO %08x N# %08x\n",
	  this,
	  pVirtualSourceData,
	  pStartNodeInstance,
	  pFileObject,
	  NodeId);
	dprintf("     Min %d Max %d Steps %d lLevel: ",
	  MinimumValue,
	  MaximumValue,
	  Steps);
	for(i = 0; i < MAX_NUM_CHANNELS; i++) {
	    dprintf("%d ", lLevel[i]);
	}
	dprintf("\n");
	return(STATUS_CONTINUE);
    };
#endif
    PVIRTUAL_SOURCE_DATA pVirtualSourceData;
    PSTART_NODE_INSTANCE pStartNodeInstance;
    PFILE_OBJECT pFileObject;
    ULONG NodeId;
    LONG MinimumValue;				// Range to convert to
    LONG MaximumValue;				//
    LONG Steps;					//
    LONG lLevel[MAX_NUM_CHANNELS];		// Local volume
    DefineSignature(0x20444e56);		// VND

} VIRTUAL_NODE_DATA, *PVIRTUAL_NODE_DATA;

//---------------------------------------------------------------------------

typedef ListDoubleDestroy<VIRTUAL_NODE_DATA> LIST_VIRTUAL_NODE_DATA;

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\vsl.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   vsl.cpp
//
//  Description:
//
//	Virtual Source Line Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------

PLIST_VIRTUAL_SOURCE_LINE gplstVirtualSourceLine = NULL;
ULONG gcVirtualSources = 0;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma INIT_CODE
#pragma INIT_DATA

NTSTATUS
InitializeVirtualSourceLine(
)
{
    if(gplstVirtualSourceLine == NULL) {
	gplstVirtualSourceLine = new LIST_VIRTUAL_SOURCE_LINE;
	if(gplstVirtualSourceLine == NULL) {
	    return(STATUS_INSUFFICIENT_RESOURCES);
	}
    }
    return(STATUS_SUCCESS);
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

VOID
UninitializeVirtualSourceLine(
)
{
    delete gplstVirtualSourceLine;
    gplstVirtualSourceLine = NULL;
}

//---------------------------------------------------------------------------

CVirtualSourceLine::CVirtualSourceLine(
    PSYSAUDIO_CREATE_VIRTUAL_SOURCE pCreateVirtualSource
)
{
    ASSERT(gplstVirtualSourceLine != NULL);
    //
    // NOTE: Virtual pins must end up first before the hardware's
    //       pins so wdmaud mixer line parsing works correctly.
    //
    AddListEnd(gplstVirtualSourceLine);

    if(pCreateVirtualSource->Property.Id ==
      KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY) {
	ulFlags |= VSL_FLAGS_CREATE_ONLY;
    }

    RtlCopyMemory(
      &guidCategory,
      &pCreateVirtualSource->PinCategory,
      sizeof(GUID));

    RtlCopyMemory(
      &guidName,
      &pCreateVirtualSource->PinName,
      sizeof(GUID));

    iVirtualSource = gcVirtualSources++;
}

CVirtualSourceLine::~CVirtualSourceLine(
)
{
    RemoveList(gplstVirtualSourceLine);
    gcVirtualSources--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\vsd.cpp ===
//---------------------------------------------------------------------------
//
//  Module:   vsd.cpp
//
//  Description:
//
//	Virtual Source Data Class
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//  To Do:     Date	  Author      Comment
//
//@@END_MSINTERNAL
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

CVirtualSourceData::CVirtualSourceData(
    PDEVICE_NODE pDeviceNode
)
{
    LONG lLevel, i;

    cChannels = 2;
    MinimumValue = (-96 * 65536);
    MaximumValue = 0;
    Steps = (65536/2);
    GetVirtualSourceDefault(pDeviceNode, &lLevel);
    for(i = 0; i < MAX_NUM_CHANNELS; i++) {
	this->lLevel[i] = lLevel;
    }
}

NTSTATUS
GetVirtualSourceDefault(
    IN PDEVICE_NODE pDeviceNode,
    IN PLONG plLevel
)
{
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ustrName;
    HANDLE hkey = NULL;

	// Set the default volume level on virtualized pins.  (0 dB attenuation)
    *plLevel = (0 * 65536);

    // Need to convert the filtername (symbolic link name) to a unicode string
    RtlInitUnicodeString(&ustrName, pDeviceNode->GetDeviceInterface());

    Status = IoOpenDeviceInterfaceRegistryKey(&ustrName, KEY_READ, &hkey);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }

    // Now we can go get the FriendlyName value
    Status = QueryRegistryValue(hkey, L"VirtualSourceDefault", &pkvfi);
    if(!NT_SUCCESS(Status)) {
	goto exit;
    }
    if(pkvfi->Type != REG_DWORD && pkvfi->Type != REG_BINARY) {
	Trap();
	Status = STATUS_INVALID_PARAMETER;
	goto exit;
    }
    if(pkvfi->Type == REG_BINARY && pkvfi->DataLength < sizeof(LONG)) {
	Trap();
	Status = STATUS_INVALID_PARAMETER;
	goto exit;
    }
    *plLevel = *((PLONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset));
exit:
    if(hkey != NULL) {
	ZwClose(hkey);
    }
    delete pkvfi;
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\vsl.h ===
//---------------------------------------------------------------------------
//
//  Module:   		vsl.h
//
//  Description:	Virtual Source Line Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

#define VSL_FLAGS_CREATE_ONLY		0x00000001

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CVirtualSourceLine : public CListSingleItem
{
public:
    CVirtualSourceLine(
	PSYSAUDIO_CREATE_VIRTUAL_SOURCE pCreateVirtualSource
    );
    ~CVirtualSourceLine(
    );
#ifdef DEBUG
    ENUMFUNC Dump(
    )
    {
	dprintf("VSL: %08x i %d ulFlags %08x ", this, iVirtualSource, ulFlags);
	if(ulFlags & VSL_FLAGS_CREATE_ONLY) {
	    dprintf("CREATE_ONLY ");
	}
	dprintf("\n     guidCategory: %s\n", DbgGuid2Sz(&guidCategory));
	dprintf("     guidName:     %s\n", DbgGuid2Sz(&guidName));
	return(STATUS_CONTINUE);
    };
#endif
    ENUMFUNC Destroy(
    )
    {
	Assert(this);
	delete this;
	return(STATUS_CONTINUE);
    };
    GUID guidCategory;
    GUID guidName;
    ULONG iVirtualSource;
    ULONG ulFlags;
    DefineSignature(0x204C5356);		// VSL

} VIRTUAL_SOURCE_LINE, *PVIRTUAL_SOURCE_LINE;

//---------------------------------------------------------------------------

typedef ListSingleDestroy<VIRTUAL_SOURCE_LINE> LIST_VIRTUAL_SOURCE_LINE;
typedef LIST_VIRTUAL_SOURCE_LINE *PLIST_VIRTUAL_SOURCE_LINE;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern PLIST_VIRTUAL_SOURCE_LINE gplstVirtualSourceLine;
extern ULONG gcVirtualSources;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
InitializeVirtualSourceLine(
);

VOID
UninitializeVirtualSourceLine(
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\sysaudio\vsd.h ===
//---------------------------------------------------------------------------
//
//  Module:   		vsd.h
//
//  Description:	Virtual Source Data Class
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Mike McLaughlin
//
//  History:   Date	  Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constants and Macros
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Classes
//---------------------------------------------------------------------------

typedef class CVirtualSourceData : public CObj
{
public:
    CVirtualSourceData(
	PDEVICE_NODE pDeviceNode
    );
#ifdef DEBUG
    ENUMFUNC Dump()
    {
	int i;
	dprintf("VSD: %08x TN %08x Min %d Max %d Steps %d cChannels %d\n",
	  this,
	  pTopologyNode,
	  MinimumValue,
	  MaximumValue,
	  Steps,
	  cChannels);
	dprintf("     fMuted: ");
	for(i = 0; i < MAX_NUM_CHANNELS; i++) {
	    dprintf("%d ", fMuted[i]);
	}
	dprintf("\n     lLevel: ");
	for(i = 0; i < MAX_NUM_CHANNELS; i++) {
	    dprintf("%d ", lLevel[i]);
	}
	dprintf("\n");
	return(lstVirtualNodeData.Dump());
    };
#endif
    PTOPOLOGY_NODE pTopologyNode;
    LONG MinimumValue;				// range to convert from
    LONG MaximumValue;				//
    LONG Steps;					//
    LONG cChannels;
    BOOL fMuted[MAX_NUM_CHANNELS];		// muted if TRUE
    LONG lLevel[MAX_NUM_CHANNELS];
    LIST_VIRTUAL_NODE_DATA lstVirtualNodeData;
    DefineSignature(0x20445356);		// VSD

} VIRTUAL_SOURCE_DATA, *PVIRTUAL_SOURCE_DATA;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------

NTSTATUS
GetVirtualSourceDefault(
    IN PDEVICE_NODE pDeviceNode,
    IN PLONG plLevel
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\bdasup\bdasupi.h ===
//---------------------------------------------------------------------------
//  Bda Topology Implementation Internal Structures
//
//      Minidriver code should not attempt to access these structures
//      directly.
//
//---------------------------------------------------------------------------

#define FILTERNAME          "BdaTopology"
#define DYNAMIC_TOPOLOGY    TRUE


#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)


//===========================================================================
//
//  MACRO definitions
//
//===========================================================================
#define BDA_PIN_STORAGE_INCREMENT   5

//===========================================================================
//
//  Advance declarations
//
//===========================================================================
typedef struct _BDA_PIN_FACTORY_CONTEXT      BDA_PIN_FACTORY_CONTEXT, 
                                        *PBDA_PIN_FACTORY_CONTEXT;



//===========================================================================
//
//  BDA Object Context Structures
//
//===========================================================================


typedef struct _BDA_CONTEXT_ENTRY
{
    PVOID       pvReference;
    PVOID       pvContext;
    ULONG       ulcbContext;

} BDA_CONTEXT_ENTRY, * PBDA_CONTEXT_ENTRY;

typedef struct _BDA_CONTEXT_LIST
{
    ULONG               ulcListEntries;
    ULONG               ulcMaxListEntries;
    ULONG               ulcListEntriesPerBlock;
    PBDA_CONTEXT_ENTRY  pListEntries;
    KSPIN_LOCK          lock;
    BOOLEAN             fInitialized;

} BDA_CONTEXT_LIST, * PBDA_CONTEXT_LIST;


typedef struct _BDA_TEMPLATE_PATH
{
    LIST_ENTRY      leLinkage;

    ULONG           ulInputPinType;
    ULONG           ulOutputPinType;
    ULONG           uliJoint;

    ULONG           ulcControlNodesInPath;
    PULONG          argulControlNodesInPath;

} BDA_TEMPLATE_PATH, * PBDA_TEMPLATE_PATH;

__inline NTSTATUS
NewBdaTemplatePath(
    PBDA_TEMPLATE_PATH *    ppTemplatePath
    )
{
    NTSTATUS            status = STATUS_SUCCESS;

    if (!ppTemplatePath)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    *ppTemplatePath = (PBDA_TEMPLATE_PATH) ExAllocatePool( 
                                               NonPagedPool,
                                               sizeof( BDA_TEMPLATE_PATH)
                                               );
    if (!*ppTemplatePath)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto errExit;
    }

    RtlZeroMemory( *ppTemplatePath, sizeof( BDA_TEMPLATE_PATH));
    InitializeListHead( &(*ppTemplatePath)->leLinkage);

errExit:
    return status;
}

__inline NTSTATUS
DeleteBdaTemplatePath(
    PBDA_TEMPLATE_PATH  pTemplatePath
    )
{
    NTSTATUS            status = STATUS_SUCCESS;

    if (!pTemplatePath)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (pTemplatePath->argulControlNodesInPath)
    {
        ExFreePool( pTemplatePath->argulControlNodesInPath);
        pTemplatePath->argulControlNodesInPath = NULL;
    }

    RtlZeroMemory( pTemplatePath, sizeof( BDA_TEMPLATE_PATH));
    ExFreePool( pTemplatePath);

errExit:
    return status;
}



typedef struct _BDA_DEVICE_CONTEXT
{

    ULONG       ulStartEmpty;

    //$BUG  Add global statistics

} BDA_DEVICE_CONTEXT, *PBDA_DEVICE_CONTEXT;


typedef struct _BDA_PATH_STACK_ENTRY
{
    ULONG       ulHop;
    ULONG       uliConnection;
    BOOLEAN     fJoint;
} BDA_PATH_STACK_ENTRY, *PBDA_PATH_STACK_ENTRY;

typedef struct _BDA_NODE_CONTROL_INFO
{
    ULONG           ulNodeType;
    ULONG           ulControllingPinType;

} BDA_NODE_CONTROL_INFO, * PBDA_NODE_CONTROL_INFO;

typedef struct _BDA_PATH_INFO
{
    ULONG                   ulInputPin;
    ULONG                   ulOutputPin;
    ULONG                   ulcPathEntries;
    BDA_PATH_STACK_ENTRY    rgPathEntries[MIN_DIMENSION];

} BDA_PATH_INFO, * PBDA_PATH_INFO;


typedef struct _BDA_FILTER_FACTORY_CONTEXT
{
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate;
    const KSFILTER_DESCRIPTOR *     pInitialFilterDescriptor;

    PKSFILTERFACTORY                pKSFilterFactory;

} BDA_FILTER_FACTORY_CONTEXT, *PBDA_FILTER_FACTORY_CONTEXT;

typedef struct _BDA_FILTER_CONTEXT
{
    PKSFILTER                       pKSFilter;
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate;

    //  Pins are added as they are created.
    //  Note!  If the filter has m pin factories included in the
    //  initial filter descriptor then the first m entries in this array
    //  will contain null pointers.
    //
    ULONG                           ulcPinFactories;
    ULONG                           ulcPinFactoriesMax;
    PBDA_PIN_FACTORY_CONTEXT        argPinFactoryCtx;

    //  One node path will exist for each pin pairing.
    //
    //$REVIEW - Should we allow more than one path per pin pair?
    //
    ULONG                           ulcPathInfo;
    PBDA_PATH_INFO *                argpPathInfo;

} BDA_FILTER_CONTEXT, *PBDA_FILTER_CONTEXT;


typedef struct _BDA_PIN_FACTORY_CONTEXT
{
    ULONG                   ulPinType;
    ULONG                   ulPinFactoryId;
} BDA_PIN_FACTORY_CONTEXT, *PBDA_PIN_FACTORY_CONTEXT;


typedef struct _BDA_NODE_CONTEXT
{

    ULONG       ulStartEmpty;

} BDA_NODE_CONTEXT, *PBDA_NODE_CONTEXT;


//---------------------------------------------------------------------------
//  BDA Topology Implementation Internal Functions
//
//      Minidriver code should not call these routines directly.
//
//---------------------------------------------------------------------------

/*
**  BdaFindPinPair()
**
**      Returns a pointer to the BDA_PIN_PAIRING that corresponds
**      to the given input and output pins.
**
**  Arguments:
**
**      pTopology   Pointer to the BDA topology that contains the
**                  pin pairing.
**
**      InputPinId  Id of the input Pin to match
**
**      OutputPinId Id of the output Pin to match
**
**  Returns:
**
**      pPinPairing     Pointer to a valid BDA Pin Pairing structure
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

PBDA_PIN_PAIRING
BdaFindPinPair(
    PBDA_FILTER_TEMPLATE    pFilterTemplate,
    ULONG                   InputPinId,
    ULONG                   OutputPinId
    );


/*
**  BdaGetPinFactoryContext()
**
**  Finds a BDA PinFactory Context that corresponds
**  to the given KS Pin Instance.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaGetPinFactoryContext(
    PKSPIN                          pKSPin,
    PBDA_PIN_FACTORY_CONTEXT        pPinFactoryCtx
    );


/*
**  BdaInitFilterFactoryContext()
**
**      Initializes a BDA Filter Factory Context based on the filter's
**      template descriptor.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaInitFilterFactoryContext(
    PBDA_FILTER_FACTORY_CONTEXT pFilterFactoryCtx
    );


/*
**  BdaAddNodeAutomationToPin()
**
**      Merges the automation tables for each node type that is controlled
**      by the pin type being created into the automation table for the
**      the pin factory.  This is how the automation tables for BDA
**      control nodes get linked to the controlling pin.  Otherwise the
**      nodes would not be accesable.
**
**
**  Arguments:
**
**
**      pFilterCtx      The BDA filter context to which the pin factory
**                      belongs.  Must have this to get at the template
**                      topology.
**
**      ulPinType       BDA Pin Type of the pin being created.  Need this
**                      to figure out which nodes are controlled by the
**                      pin.
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaAddNodeAutomationToPin( 
    PBDA_FILTER_CONTEXT         pFilterCtx, 
    ULONG                       ulControllingPinType,
    KSOBJECT_BAG                ObjectBag,
    const KSAUTOMATION_TABLE *  pOriginalAutomationTable,
    PKSAUTOMATION_TABLE *       ppNewAutomationTable
    );


/*
**  BdaCreateTemplatePaths()
**
**      Creates a list of all possible paths through the template filter.
**      Determines the controlling pin type for each node type in the
**      template filter.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateTemplatePaths(
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate,
    PULONG                          pulcPathInfo,
    PBDA_PATH_INFO **               pargpPathInfo
    );


ULONG __inline
OutputBufferLenFromIrp(
    PIRP    pIrp
    )
{
    PIO_STACK_LOCATION pIrpStack;

    ASSERT( pIrp);
    if (!pIrp)
    {
        return 0;
    }

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp);
    ASSERT( pIrpStack);
    if (pIrpStack)
    {
        return pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    }
    else
    {
        return 0;
    }
}



//---------------------------------------------------------------------------
//  BDA Topology Const Data
//
//      Minidriver code should not use these fields directly
//
//---------------------------------------------------------------------------

extern const KSAUTOMATION_TABLE     BdaDefaultPinAutomation;
extern const KSAUTOMATION_TABLE     BdaDefaultFilterAutomation;


#if defined(__cplusplus)
}
#endif // defined(__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\audio\timebomb\timebomb.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       timebomb.c
//
//--------------------------------------------------------------------------

//
//  -- Add these lines after the #include's in the file that handles DriverEntry:
//
//      #ifdef TIME_BOMB
//      #include "..\..\timebomb\timebomb.c"
//      #endif
//
//  -- Add the following lines to the beginning of DriverEntry:
//
//      #ifdef TIME_BOMB
//      if (HasEvaluationTimeExpired()) {
//          return STATUS_EVALUATION_EXPIRATION;
//      }
//      #endif
//
//  -- If you want to override the default expiration value of 31 days after
//     compile, define the constant DAYS_UNTIL_EXPIRATION before you include
//     timebomb.c
//
//  -- Add -DTIME_BOMB to the $(C_DEFINES) line in the sources file.  If you haven't
//     already done so, you may also want to add -DDEBUG_LEVEL=DEBUGLVL_TERSE.
//
//  -- "Cleanly" recompile your binary with 'build -cZ'
//
//  -- NOTE: This uses the __DATE__ preprocessor directive which inserts a _very_
//           clear-text string into the binary which is easily modifiable with a
//           hex editor.  Suggestions on making this more secure are welcome.
//

#if !defined(_KSDEBUG_)
#include <ksdebug.h>
#endif

#ifndef DAYS_UNTIL_EXPIRATION
#define DAYS_UNTIL_EXPIRATION   31
#endif

typedef enum {
    Jan=1,
    Feb,
    Mar,
    Apr,
    May,
    Jun,
    Jul,
    Aug,
    Sep,
    Oct,
    Nov,
    Dec
} MONTH;

MONTH GetMonthFromDateString
(
    char *_BuildDate_
)
{
    MONTH BuildMonth = (MONTH)0;

    ASSERT(_BuildDate_);

    switch (_BuildDate_[0]) {
        case 'A':
            if (_BuildDate_[1] == 'u') {
                BuildMonth = Aug;
            }
            else {
                BuildMonth = Apr;
            }
            break;
        case 'D':
            BuildMonth = Dec;
            break;
        case 'F':
            BuildMonth = Feb;
            break;
        case 'J':
            if (_BuildDate_[1] == 'u') {
                if (_BuildDate_[2] == 'l') {
                    BuildMonth = Jul;
                } else {
                    BuildMonth = Jun;
                }
            } else {
                BuildMonth = Jan;
            }
            break;
        case 'M':
            if (_BuildDate_[2] == 'r') {
                BuildMonth = Mar;
            }
            else {
                BuildMonth = May;
            }
            break;
        case 'N':
            BuildMonth = Nov;
            break;
        case 'O':
            BuildMonth = Oct;
            break;
        case 'S':
            BuildMonth = Sep;
            break;
        default:
            ASSERT(0);
            break;
    }

    return BuildMonth;
}

BOOL HasEvaluationTimeExpired()
{
    //  Get the time that this file was compiled
    char            _BuildDate_[] = __DATE__;
    CSHORT          BuildYear,
                    BuildMonth,
                    BuildDay,
                    ThousandsDigit,
                    HundredsDigit,
                    TensDigit,
                    Digit;
    ULONG           BuildDays,
                    CurrentDays;
    LARGE_INTEGER   CurrentSystemTime;
    TIME_FIELDS     CurrentSystemTimeFields;

    //  Convert _BuildDate_ into something a little more palatable
    _DbgPrintF( DEBUGLVL_TERSE, ("Driver Build Date: %s",_BuildDate_) );

    BuildMonth = GetMonthFromDateString(_BuildDate_);

    //  Compensate for a ' ' in the tens digit
    if ( (_BuildDate_[4] >= '0') && (_BuildDate_[4] <= '9') ) {
        TensDigit = _BuildDate_[4] - '0';
    } else {
        TensDigit = 0;
    }
    Digit     = _BuildDate_[5] - '0';
    BuildDay  = (TensDigit * 10) + Digit;

    ThousandsDigit = _BuildDate_[7] - '0';
    HundredsDigit  = _BuildDate_[8] - '0';
    TensDigit      = _BuildDate_[9] - '0';
    Digit          = _BuildDate_[10] - '0';
    BuildYear      = (ThousandsDigit * 1000) + (HundredsDigit * 100) + (TensDigit * 10) + Digit;

    //  Get the current system time and convert to local time
    KeQuerySystemTime( &CurrentSystemTime ); // returns GMT
    RtlTimeToTimeFields( &CurrentSystemTime, &CurrentSystemTimeFields );

    //  For now, only let this binary float for 31 days
    BuildDays = (BuildYear * 365) +
                (BuildMonth * 31) +
                 BuildDay;
    CurrentDays = (CurrentSystemTimeFields.Year * 365) +
                  (CurrentSystemTimeFields.Month * 31) +
                   CurrentSystemTimeFields.Day;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CurrentDays: %d  BuildDays: %d",CurrentDays, BuildDays) );
    if (CurrentDays > BuildDays + DAYS_UNTIL_EXPIRATION) {
        _DbgPrintF( DEBUGLVL_TERSE, ("Evaluation period expired!") );
        return TRUE;
    }
    else {
        _DbgPrintF( DEBUGLVL_TERSE, ("Evaluation days left: %d", (BuildDays + 31) - CurrentDays) );
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\bdasup\bdatopgy.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;


#include <wdm.h>
#include <limits.h>
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <bdasup.h>
#include "bdasupi.h"

/*
 -  DriverEntry
 -
 *  This the the required DriverEntry for the BDA Support Driver.
 *  Though required, it is never actually called.
 *
 */
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
//$BUGBUG   This entry point is required but never called.

    return STATUS_SUCCESS;
}


STDMETHODIMP_(NTSTATUS)
BdaFindContextEntry(
    PBDA_CONTEXT_LIST   pContextList,
    PVOID               pvReference,
    PVOID *             ppvContext
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               uliEntry;
    KIRQL               oldIrql;

    ASSERT( pContextList);
    ASSERT( ppvContext);

    if (!pContextList->fInitialized)
    {
        status = STATUS_NOT_FOUND;
        goto errExit;
    }

    //  NULL pvReference is not valid.
    //
    if (!pvReference)
    {
        status = STATUS_INVALID_PARAMETER;
        *ppvContext = NULL;
        goto errExit;
    }

    //  Lock down the list while we search it.
    //
    KeAcquireSpinLock( &(pContextList->lock), &oldIrql);

    //  Find a list entry with a matching pvReference
    //
    for (uliEntry = 0; uliEntry < pContextList->ulcListEntries; uliEntry++)
    {
        if (pContextList->pListEntries[uliEntry].pvReference == pvReference)
        {
            break;
        }
    }

    if (uliEntry >= pContextList->ulcListEntries)
    {
        //  No matching entry was found so return error.
        //
        status = STATUS_NOT_FOUND;
        *ppvContext = NULL;
    }
    else
    {
        //  Return the pvContext corresponding to the matching pvReference.
        //
        *ppvContext = pContextList->pListEntries[uliEntry].pvContext;
    }

    KeReleaseSpinLock( &(pContextList->lock), oldIrql);

errExit:
    return status;
}


STDMETHODIMP_(NTSTATUS)
BdaCreateContextEntry(
    PBDA_CONTEXT_LIST   pContextList,
    PVOID               pvReference,
    ULONG               ulcbContext,
    PVOID *             ppvContext
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               uliEntry;
    KIRQL               oldIrql;

    ASSERT( pContextList);
    ASSERT( ppvContext);

    if (!pContextList->fInitialized)
    {
        KeInitializeSpinLock ( &(pContextList->lock));
        pContextList->fInitialized = TRUE;
    }

    //  See if a list entry has already been created.
    //
    status = BdaFindContextEntry( pContextList, pvReference, ppvContext);
    if (status != STATUS_NOT_FOUND)
    {
        goto errExit;
    }
    status = STATUS_SUCCESS;

    KeAcquireSpinLock( &(pContextList->lock), &oldIrql);

    //  If the current block of context entries is full, allocate
    //  a bigger block to put the new entry into.
    //
    if (pContextList->ulcListEntries >= pContextList->ulcMaxListEntries)
    {
        ULONG               ulcEntriesToAllocate;
        PBDA_CONTEXT_ENTRY  pNewList;

        ulcEntriesToAllocate =  pContextList->ulcMaxListEntries
                              + pContextList->ulcListEntriesPerBlock;

        pNewList = (PBDA_CONTEXT_ENTRY) ExAllocatePool(
                       NonPagedPool,
                       ulcEntriesToAllocate * sizeof( BDA_CONTEXT_ENTRY)
                       );
        if (!pNewList)
        {
            status = STATUS_NO_MEMORY;
            KeReleaseSpinLock( &(pContextList->lock), oldIrql);
            goto errExit;
        }

        RtlZeroMemory( pNewList,
                        ulcEntriesToAllocate * sizeof( BDA_CONTEXT_ENTRY)
                     );
        if (pContextList->pListEntries)
        {
            RtlMoveMemory( pNewList,
                           pContextList->pListEntries,
                             pContextList->ulcMaxListEntries
                           * sizeof( BDA_CONTEXT_ENTRY)
                         );
            ExFreePool( pContextList->pListEntries);
        }

        pContextList->pListEntries = pNewList;
        pContextList->ulcMaxListEntries = ulcEntriesToAllocate;
    }

#ifdef SORTED_CONTEXT_ENTRIES

    //  Find the proper place to insert the new entry into the list.
    //
    for (uliEntry = 0; uliEntry < pContextList->ulcListEntries; uliEntry++)
    {
        if (pContextList->pListEntries[uliEntry].pvReference > pvReference)
        {
            break;
        }
    }

#else

    uliEntry = pContextList->ulcListEntries;

#endif // SORTED_CONTEXT_ENTRIES


    //  Allocate a new context entry
    //
    *ppvContext = ExAllocatePool( NonPagedPool, ulcbContext);
    if (!*ppvContext)
    {
        status = STATUS_NO_MEMORY;
        KeReleaseSpinLock( &(pContextList->lock), oldIrql);
        goto errExit;
    }

#ifdef SORTED_CONTEXT_ENTRIES

    //  If the new entry is in the middle of the list, then create
    //  a whole for it by moving the end of the list down.
    //
    if (uliEntry < pContextList->ulcListEntries)
    {
        //  NOTE!  RtlMoveMemory handles overlapped source and destination.
        //
        RtlMoveMemory( &(pContextList->pListEntries[uliEntry + 1]),
                       &(pContextList->pListEntries[uliEntry]),
                         (pContextList->ulcListEntries - uliEntry)
                       * sizeof( BDA_CONTEXT_ENTRY)
                     );
    }

#endif // SORTED_CONTEXT_ENTRIES


    RtlZeroMemory( *ppvContext, ulcbContext);
    pContextList->pListEntries[uliEntry].pvContext = *ppvContext;
    pContextList->pListEntries[uliEntry].ulcbContext = ulcbContext;
    pContextList->pListEntries[uliEntry].pvReference = pvReference;
    pContextList->ulcListEntries++;

    KeReleaseSpinLock( &(pContextList->lock), oldIrql);

errExit:
    return status;
}


STDMETHODIMP_(NTSTATUS)
BdaDeleteContextEntry(
    PBDA_CONTEXT_LIST   pContextList,
    PVOID               pvReference
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               uliEntry;
    KIRQL               oldIrql;
    PVOID               pvContext;
    ULONG               ulcbContext;

    ASSERT( pContextList);
    ASSERT( pvReference);
    ASSERT( pContextList->fInitialized);

    if (!pContextList->fInitialized)
    {
        goto errExit;
    }

    KeAcquireSpinLock( &(pContextList->lock), &oldIrql);

    //  Find the Context Entry in the list
    //
    for (uliEntry = 0; uliEntry < pContextList->ulcListEntries; uliEntry++)
    {
        if (pContextList->pListEntries[uliEntry].pvReference == pvReference)
        {
            break;
        }
    }

    if (uliEntry >= pContextList->ulcListEntries)
    {
        status = STATUS_NOT_FOUND;
        KeReleaseSpinLock( &(pContextList->lock), oldIrql);
        goto errExit;
    }

    pvContext = pContextList->pListEntries[uliEntry].pvContext;
    ulcbContext = pContextList->pListEntries[uliEntry].ulcbContext;
    pContextList->pListEntries[uliEntry].pvContext = NULL;
    pContextList->pListEntries[uliEntry].pvReference = NULL;
    RtlZeroMemory( pvContext, ulcbContext);
    ExFreePool( pvContext);

    pContextList->ulcListEntries -= 1;
    if (uliEntry < pContextList->ulcListEntries)
    {
        //  NOTE!  RtlMoveMemory handles overlapped source and destination.
        //
        RtlMoveMemory( &(pContextList->pListEntries[uliEntry]),
                       &(pContextList->pListEntries[uliEntry + 1]),
                       (pContextList->ulcListEntries - uliEntry)
                       * sizeof( BDA_CONTEXT_ENTRY)
                     );
    }

    KeReleaseSpinLock( &(pContextList->lock), oldIrql);

errExit:
    return status;
}


STDMETHODIMP_(NTSTATUS)
BdaDeleteContextEntryByValue(
    PBDA_CONTEXT_LIST   pContextList,
    PVOID               pvContext
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               uliEntry;
    KIRQL               oldIrql;
    ULONG               ulcbContext;

    ASSERT( pContextList);
    ASSERT( pvContext);
    ASSERT( pContextList->fInitialized);

    if (!pContextList->fInitialized)
    {
        goto errExit;
    }

    KeAcquireSpinLock( &(pContextList->lock), &oldIrql);

    //  Find the Context Entry in the list
    //
    for (uliEntry = 0; uliEntry < pContextList->ulcListEntries; uliEntry++)
    {
        if (pContextList->pListEntries[uliEntry].pvContext == pvContext)
        {
            break;
        }
    }

    if (uliEntry >= pContextList->ulcListEntries)
    {
        status = STATUS_NOT_FOUND;
        KeReleaseSpinLock( &(pContextList->lock), oldIrql);
        goto errExit;
    }

    ulcbContext = pContextList->pListEntries[uliEntry].ulcbContext;
    pContextList->pListEntries[uliEntry].pvContext = NULL;
    pContextList->pListEntries[uliEntry].pvReference = NULL;
    RtlZeroMemory( pvContext, ulcbContext);
    ExFreePool( pvContext);

    pContextList->ulcListEntries -= 1;
    if (uliEntry < pContextList->ulcListEntries)
    {
        //  NOTE!  RtlMoveMemory handles overlapped source and destination.
        //
        RtlMoveMemory( &(pContextList->pListEntries[uliEntry]),
                       &(pContextList->pListEntries[uliEntry + 1]),
                       (pContextList->ulcListEntries - uliEntry)
                       * sizeof( BDA_CONTEXT_ENTRY)
                     );
    }

    KeReleaseSpinLock( &(pContextList->lock), oldIrql);

errExit:
    return status;
}


/*
**  BdaDeleteFilterFactoryContextByValue()
**
**  Finds the given BDA Filter Factory Context in the FilterFactory
**  context list and removes it.
**
**  This function is provided as a callback when the Filter Facotry Context
**  is added to the KSFilterFactory's Object Bag.  This allows KS to clean
**  up the context when the filter factory is unexpectedly closed.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

BDA_CONTEXT_LIST    FilterFactoryContextList = { 0, 0, 4, NULL, 0, FALSE};

STDMETHODIMP_(VOID)
BdaDeleteFilterFactoryContextByValue(
    PVOID       pFilterFactoryCtx
    )
{
    BdaDeleteContextEntryByValue( &FilterFactoryContextList,
                                  pFilterFactoryCtx
                                );
}


/*
**  BdaCreateFilterFactoryContext()
**
**  Finds or creates a BDA Filter Factory Context that corresponds
**  to the given KS Filter Factory.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterFactoryContext(
    PKSFILTERFACTORY                pKSFilterFactory,
    PBDA_FILTER_FACTORY_CONTEXT *   ppFilterFactoryCtx
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;

    status = BdaCreateContextEntry( &FilterFactoryContextList,
                                    pKSFilterFactory,
                                    sizeof( BDA_FILTER_FACTORY_CONTEXT),
                                    (PVOID *) ppFilterFactoryCtx
                                  );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

    status = KsAddItemToObjectBag( pKSFilterFactory->Bag,
                                   *ppFilterFactoryCtx,
                                   BdaDeleteFilterFactoryContextByValue
                                 );

errExit:
    return status;
}


/*
**  BdaDestructFilterContext()
**
**  Finds the given BDA Filter Context in the Filter
**  context list and removes it.
**
**  This function is provided as a callback when the Filter Context is
**  added to the KSFilter's Object Bag.  This allows KS to clean up the
**  context when the filter is unexpectedly closed.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/


STDMETHODIMP_(VOID)
BdaDestructFilterContext(
    PBDA_FILTER_CONTEXT       pFilterCtx
    )
{
    ULONG       uliPath;

    ASSERT( pFilterCtx);
    
    if (!pFilterCtx || !pFilterCtx->argpPathInfo)
    {
        goto exit;
    }

    //  Delete the path information.
    //

    for ( uliPath = 0; uliPath < pFilterCtx->ulcPathInfo; uliPath++)
    {
        if (pFilterCtx->argpPathInfo[uliPath])
        {
            ExFreePool( pFilterCtx->argpPathInfo[uliPath]);
            pFilterCtx->argpPathInfo[uliPath] = NULL;
        }
    }

    ExFreePool( pFilterCtx->argpPathInfo);
    pFilterCtx->argpPathInfo = NULL;
    pFilterCtx->ulcPathInfo = 0;

exit:
    return;
}


/*
**  BdaDeleteFilterContextByValue()
**
**  Finds the given BDA Filter Context in the Filter
**  context list and removes it.
**
**  This function is provided as a callback when the Filter Context is
**  added to the KSFilter's Object Bag.  This allows KS to clean up the
**  context when the filter is unexpectedly closed.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

BDA_CONTEXT_LIST    FilterContextList = { 0, 0, 4, NULL, 0, FALSE};

STDMETHODIMP_(VOID)
BdaDeleteFilterContextByValue(
    PVOID       pFilterCtx
    )
{
    BdaDestructFilterContext( (PBDA_FILTER_CONTEXT) pFilterCtx);

    BdaDeleteContextEntryByValue( &FilterContextList,
                                  pFilterCtx
                                );
}


/*
**  BdaCreateFilterContext()
**
**  Finds or creates a BDA Filter Context that corresponds
**  to the given KS Filter.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterContext(
    PKSFILTER               pKSFilter,
    PBDA_FILTER_CONTEXT *   ppFilterCtx
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;

    status = BdaCreateContextEntry( &FilterContextList,
                                    pKSFilter,
                                    sizeof( BDA_FILTER_CONTEXT),
                                    (PVOID *) ppFilterCtx
                                  );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

    status = KsAddItemToObjectBag( pKSFilter->Bag,
                                   *ppFilterCtx,
                                   BdaDeleteFilterContextByValue
                                 );

    (*ppFilterCtx)->pKSFilter = pKSFilter;

errExit:
    return status;
}


/*
**  BdaGetFilterContext()
**
**  Finds a BDA Filter Context that corresponds
**  to the given KS Filter Instance.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaGetFilterContext(
    PKSFILTER                       pKSFilter,
    PBDA_FILTER_CONTEXT *           ppFilterCtx
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;

    status = BdaFindContextEntry( &FilterContextList,
                                  pKSFilter,
                                  (PVOID *) ppFilterCtx
                                );

    return status;
}


/*
**  BdaDeleteFilterContext()
**
**  Deletes a BDA Filter Context.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaDeleteFilterContext(
    PVOID               pvReference
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       uliPath;
    PBDA_FILTER_CONTEXT         pFilterCtx;

    status = BdaGetFilterContext( (PKSFILTER) pvReference, &pFilterCtx);
    if (status == STATUS_SUCCESS)
    {
        BdaDestructFilterContext( pFilterCtx);
    }

    status = BdaDeleteContextEntry( &FilterContextList,
                                    pvReference
                                  );
    return status;
}


/*
**  BdaGetControllingPinType()
**
**  
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaGetControllingPinType( 
    ULONG                       ulNodeType,
    ULONG                       ulInputPinType,
    ULONG                       ulOutputPinType,
    PBDA_FILTER_CONTEXT         pFilterCtx,
    PULONG                      pulControllingPinType
    )
{
    NTSTATUS                    status = STATUS_NOT_FOUND;
    ULONG                       ulControllingPinType;
    ULONG                       uliPath;
    const KSFILTER_DESCRIPTOR * pKSFilterDescriptor;

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    ASSERT( pFilterCtx->pBdaFilterTemplate->pFilterDescriptor);

    if (   !pFilterCtx
        || !pFilterCtx->pBdaFilterTemplate
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (   !pFilterCtx->ulcPathInfo
        || !pFilterCtx->argpPathInfo
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->Connections
       )
    {
        goto errExit;
    }

    pKSFilterDescriptor = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;

    for (uliPath = 0; uliPath < pFilterCtx->ulcPathInfo; uliPath++)
    {
        PBDA_PATH_INFO      pPathInfo;
        ULONG               uliPathEntry;

        pPathInfo = pFilterCtx->argpPathInfo[uliPath];

        if (   !pPathInfo
            || (pPathInfo->ulInputPin != ulInputPinType)
            || (pPathInfo->ulOutputPin != ulOutputPinType)
           )
        {
            //  This is not the path for this pin pair.
            //
            continue;
        }

        //  Search the Path for the given node type.
        //
        ulControllingPinType = ulInputPinType;
        for ( uliPathEntry = 0
            ; uliPathEntry < pPathInfo->ulcPathEntries
            ; uliPathEntry++
            )
        {
            ULONG                           uliConnection;

            //  If we encounter topology joint then switch the controlling
            //  pin to be the output pin.
            //
            if (pPathInfo->rgPathEntries[uliPathEntry].fJoint)
            {
                ulControllingPinType = ulOutputPinType;
            }

            uliConnection = pPathInfo->rgPathEntries[uliPathEntry].uliConnection;
            if (pKSFilterDescriptor->Connections[uliConnection].ToNode == ulNodeType)
            {
                //  We found the controlling pin type for the node type.
                //  Indicate success and set the output parameter.
                //
                status = STATUS_SUCCESS;
                *pulControllingPinType = ulControllingPinType;
                break;
            }
        }

        if (uliPathEntry < pPathInfo->ulcPathEntries)
        {
            //  We found the controlling pin type for the node type.
            //
            break;
        }
    }
    
errExit:
    return status;
}


/*
**  BdaFilterInitTopologyData()
**
**  Initializes the common BDA filter context's topology info.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaFilterInitTopologyData(
    PBDA_FILTER_CONTEXT     pFilterCtx   
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       ulcTemplateNodes;
    PBDA_NODE_CONTROL_INFO      pNodeControlInfo = NULL;

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pKSFilter);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    ASSERT( pFilterCtx->pBdaFilterTemplate->pFilterDescriptor);

    if (   !pFilterCtx
        || !pFilterCtx->pBdaFilterTemplate
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor
        || !pFilterCtx->pKSFilter
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

#ifdef REMOVE

    ulcTemplateNodes 
        = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptorsCount;

    if (ulcTemplateNodes)
    {
        PKSNODE_DESCRIPTOR  pCurNode;
        ULONG               uliNode;

        ASSERT( pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptors);
        ASSERT( pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptorSize);

        //  Allocate an array of node control info structures
        //
        pNodeControlInfo = ExAllocatePool( 
                               NonPagedPool, 
                               ulcTemplateNodes * sizeof( BDA_NODE_CONTROL_INFO)
                               );
        if (!pNodeControlInfo)
        {
            status = STATUS_NO_MEMORY;
            goto errExit;
        }
        RtlZeroMemory( pNodeControlInfo,
                       ulcTemplateNodes * sizeof( BDA_NODE_CONTROL_INFO)
                       );

        //  Add the allocation to the KS Filter's object bag so that it
        //  will be freed on filter destruction.
        //
        status = KsAddItemToObjectBag( pFilterCtx->pKSFilter->Bag,
                                       pNodeControlInfo,
                                       NULL
                                       );

        //  Point the BDA Filter Context at the node control info.
        //
        pFilterCtx->argNodeControlInfo = pNodeControlInfo;
    
        //  Determine the contolling pin type for each node type and fill
        //  it in to the node control array
        //
        for ( uliNode = 0
            ; uliNode < ulcTemplateNodes
            ; uliNode++, pNodeControlInfo++
            )
        {
            //  BdaSup.sys always uses the index of the node descriptor as
            //  the node type.
            //
            pNodeControlInfo->ulNodeType = uliNode;

            //  Determine which template pin type controls this node type.
            //
            status = BdaGetControllingPinType( 
                         uliNode, 
                         pFilterCtx->pBdaFilterTemplate,
                         &pNodeControlInfo->ulControllingPinType
                         );
            if (status != STATUS_SUCCESS)
            {
                goto errExit;
            }
            
            //  Add the node control info as we determine it.
            //
            pFilterCtx->ulcNodeControlInfo++;
        }
    }
#endif // REMOVE

errExit:
    return status;
}


/*
**  BdaAddPinFactoryContext()
**
**  Adds pin factory information to the array of pin factory context
**  structures for this filter instance.  It will enlarge the array
**  if necessary.
**  NOTE!  Since the array is an array of structure NOT pointers to
**  structures, AND since the array can be moved, one should NOT keep
**  pointers to the pin factory context entries.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreatePinFactoryContext(
    PKSFILTER                       pKSFilter,
    PBDA_FILTER_CONTEXT             pFilterCtx,
    ULONG                           uliPinId,
    ULONG                           ulPinType
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;


    //  Add the Pin Factory info to the filter context.
    //
    if (uliPinId >= pFilterCtx->ulcPinFactoriesMax)
    {
        //  If there isn't enough room then add more.
        //
        PBDA_PIN_FACTORY_CONTEXT    argNewPinCtx = NULL;
        PVOID                       pvTemp;
        ULONG                       ulcPinFactoriesMax;

        ulcPinFactoriesMax = uliPinId + BDA_PIN_STORAGE_INCREMENT;

        argNewPinCtx = ExAllocatePool( 
                               NonPagedPool,
                               ulcPinFactoriesMax * sizeof(BDA_PIN_FACTORY_CONTEXT)
                               );
        if (!argNewPinCtx)
        {
            status = STATUS_NO_MEMORY;
            goto errExit;
        }
        
        if (pFilterCtx->argPinFactoryCtx)
        {
            RtlMoveMemory( argNewPinCtx,
                           pFilterCtx->argPinFactoryCtx,
                           pFilterCtx->ulcPinFactoriesMax * sizeof(BDA_PIN_FACTORY_CONTEXT)
                           );
        }

        KsAddItemToObjectBag( pKSFilter->Bag,
                              argNewPinCtx,
                              NULL
                              );

        pvTemp = pFilterCtx->argPinFactoryCtx;
        pFilterCtx->argPinFactoryCtx = argNewPinCtx;
        pFilterCtx->ulcPinFactoriesMax = ulcPinFactoriesMax;

        KsRemoveItemFromObjectBag( pKSFilter->Bag,
                                   pvTemp,
                                   TRUE
                                   );
    }

    //  Fill in the pin factory context information.
    //
    pFilterCtx->argPinFactoryCtx[uliPinId].ulPinType = ulPinType;
    pFilterCtx->argPinFactoryCtx[uliPinId].ulPinFactoryId = uliPinId;
    if (uliPinId >= pFilterCtx->ulcPinFactories)
    {
        pFilterCtx->ulcPinFactories = uliPinId + 1;

    }

errExit:
    return status;
}


/*
**  BdaInitFilter()
**
**  Creates a BDA filter context for use by BdaCreatePinFactory etc.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaInitFilter(
    PKSFILTER                       pKSFilter,
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PBDA_FILTER_FACTORY_CONTEXT pFilterFactoryCtx = NULL;
    PBDA_FILTER_CONTEXT         pFilterCtx = NULL;
    PKSFILTERFACTORY            pKSFilterFactory = NULL;
    ULONG                       ulcPinFactoriesMax;
    const KSFILTER_DESCRIPTOR * pInitialFilterDescriptor = NULL;

    status = BdaFindContextEntry( &FilterContextList,
                                  pKSFilter,
                                  (PVOID *) &pFilterCtx
                                );
    if (NT_SUCCESS( status))
    {
        status = STATUS_SHARING_VIOLATION;
        goto errExit;
    }
    if (status != STATUS_NOT_FOUND)
    {
        goto errExit;
    }


    //  Get the filter factory context so that we can determine
    //  the initial pin list.
    //
    pKSFilterFactory = KsFilterGetParentFilterFactory( pKSFilter);

    ASSERT( pKSFilterFactory);

    if (!pKSFilterFactory)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    status = BdaFindContextEntry( &FilterFactoryContextList,
                                  pKSFilterFactory,
                                  (PVOID *) &pFilterFactoryCtx
                                );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

    if (!pFilterFactoryCtx)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    pInitialFilterDescriptor = pFilterFactoryCtx->pInitialFilterDescriptor;

    //  Create a BDA filter context and put it in the list so we can
    //  find it when BDA calls are made relative to the filter.
    //
    status = BdaCreateFilterContext( pKSFilter, &pFilterCtx);
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Point the BDA filter context at the template topology for the
    //  filter.
    //
    if (pBdaFilterTemplate)
    {
        pFilterCtx->pBdaFilterTemplate = pBdaFilterTemplate;
    }
    else
    {
        pFilterCtx->pBdaFilterTemplate
            = pFilterFactoryCtx->pBdaFilterTemplate;
    }
    
    //  Expand the template topology information into a list
    //  of paths keyed by the input-output pin type pair.
    //
    status = BdaCreateTemplatePaths( pFilterCtx->pBdaFilterTemplate,
                                     &pFilterCtx->ulcPathInfo,
                                     &pFilterCtx->argpPathInfo
                                     );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

    //$REVIEW - Should we allow filters with no input-output paths?
    //
    ASSERT( pFilterCtx->ulcPathInfo);
    ASSERT( pFilterCtx->argpPathInfo);

    //  Allocate space for the Pin Factory context information
    //
    ulcPinFactoriesMax = pBdaFilterTemplate->pFilterDescriptor->PinDescriptorsCount;
    ulcPinFactoriesMax += BDA_PIN_STORAGE_INCREMENT;
    pFilterCtx->argPinFactoryCtx 
        = ExAllocatePool( NonPagedPool,
                          ulcPinFactoriesMax * sizeof( BDA_PIN_FACTORY_CONTEXT)
                          );
    if (!pFilterCtx->argPinFactoryCtx)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }
    pFilterCtx->ulcPinFactories = 0;
    pFilterCtx->ulcPinFactoriesMax = ulcPinFactoriesMax;


    //  Loop through each initial pin descriptor and fill in the pin
    //  context info.
    //
    if (pInitialFilterDescriptor && pInitialFilterDescriptor->PinDescriptors)
    {
        ULONG   ulcbPinDescriptor;
        ULONG   uliPinType;

        if (pInitialFilterDescriptor->PinDescriptorsCount > pFilterCtx->ulcPinFactoriesMax)
        {
            status = STATUS_INVALID_DEVICE_STATE;
            goto errExit;
        }

        ulcbPinDescriptor = pInitialFilterDescriptor->PinDescriptorSize;
        for ( uliPinType = 0
            ; uliPinType < pInitialFilterDescriptor->PinDescriptorsCount
            ; uliPinType++
            )
        {
            ULONG   ulPinId;

            //  It is a BDA requirement that the index of all pins listed in the initial
            //  filter descriptor correspond to the index of its pin type
            //  in the BDA Template Descriptor.
            //

            status = BdaCreatePin( pKSFilter,
                                   uliPinType,
                                   &ulPinId
                                   );
            if (status != STATUS_SUCCESS)
            {
                goto errExit;
            }

            //
            //  We do not "CreateTopology" on the initial pins.  The
            //  initial pins are usually only input pins.  The Network
            //  Provider will create output pins and "CreateTopology".
            //
        }
    }


errExit:
    return status;
}


/*
**  BdaUninitFilter()
**
**  Deletes the BDA filter context for use by BdaCreatePinFactory etc.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaUninitFilter(
    PKSFILTER                       pKSFilter
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
#ifdef NO_KS_OBJECT_BAG
    status = BdaDeleteContextEntry( &FilterContextList,
                                    pKSFilter
                                );
    if (!NT_SUCCESS( status))
    {
        goto errExit;
    }

errExit:
#endif // def NO_KS_OBJECT_BAG
    return status;
}


/*
**  BdaCreateFilterFactoryEx()
**
**  Initializes the common BDA filter context.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterFactoryEx(
    PKSDEVICE                       pKSDevice,
    const KSFILTER_DESCRIPTOR *     pInitialFilterDescriptor,
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate,
    PKSFILTERFACTORY *              ppKSFilterFactory
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PBDA_FILTER_FACTORY_CONTEXT pFilterFactoryCtx = NULL;
    PKSFILTERFACTORY            pKSFilterFactory = NULL;
    PKSFILTER_DESCRIPTOR        pFilterDescriptor = NULL;
    PKSAUTOMATION_TABLE         pNewAutomationTable = NULL;
    
    ASSERT( pKSDevice);
    if (!pKSDevice)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( pInitialFilterDescriptor);
    if (!pInitialFilterDescriptor)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( pBdaFilterTemplate);
    if (!pBdaFilterTemplate)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Create a copy of the filter factory descriptor information and
    //  remove any pins and connections.  These will be added when
    //  the filter is initialized by BDAInitFilter.
    //
    pFilterDescriptor = ExAllocatePool( NonPagedPool,
                                        sizeof( KSFILTER_DESCRIPTOR)
                                        );
    if (!pFilterDescriptor)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }
    *pFilterDescriptor = *pInitialFilterDescriptor;
    pFilterDescriptor->PinDescriptorsCount = 0;
    pFilterDescriptor->PinDescriptors = NULL;
    pFilterDescriptor->NodeDescriptorsCount = 0;
    pFilterDescriptor->NodeDescriptors = NULL;
    pFilterDescriptor->ConnectionsCount = 0;
    pFilterDescriptor->Connections = NULL;
    
    status = KsMergeAutomationTables( 
                 &pNewAutomationTable,
                 (PKSAUTOMATION_TABLE) (pFilterDescriptor->AutomationTable),
                 (PKSAUTOMATION_TABLE) &BdaDefaultFilterAutomation,
                 NULL
                 );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    if (!pNewAutomationTable)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }
    pFilterDescriptor->AutomationTable = pNewAutomationTable;

    //$BUG - Check Filter Factory Dispatch for Filter Close.  If none
    //$BUG - we must add BdaDeleteFilterFactory to clean up.
    
    //  Create the KSFilterFactory
    //
    status = KsCreateFilterFactory(
                pKSDevice->FunctionalDeviceObject,
                pFilterDescriptor,
                NULL,   // RefString
                NULL,   // SecurityDescriptor
                0,      // CreateItemFlags
                NULL,   // SleepCallback
                NULL,   // WakeCallback
                &pKSFilterFactory
                );

    if ((status != STATUS_SUCCESS) || !pKSFilterFactory)
    {
        goto errExit;
    }


    //  Add our copy of the Filter Factory's new automation table to the
    //  KSFilterFactory's object bag.  This insures the memory will
    //  be freed when the filter factory is destroyed.
    //
    if (   pNewAutomationTable
        && (pNewAutomationTable != &BdaDefaultFilterAutomation)
       )
    {
        KsAddItemToObjectBag( pKSFilterFactory->Bag,
                              pNewAutomationTable,
                              NULL
                              );
    }
    pNewAutomationTable = NULL;


    //  Add our copy of the Filter Factory's descriptor to the
    //  KSFilterFactory's object bag.  This insures the memory will
    //  be freed when the filter factory is destroyed.
    //
    KsAddItemToObjectBag( pKSFilterFactory->Bag,
                          pFilterDescriptor,
                          NULL
                          );
    pFilterDescriptor = NULL;


    //  Merge our default filter automation table onto the filter
    //  factory descriptor
    //
    status = KsEdit( pKSFilterFactory, 
                     &(pKSFilterFactory->FilterDescriptor->AutomationTable),
                     'SadB'
                     );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }


    //  Create a filter factory context for BdaSup to use.
    //
    status = BdaCreateFilterFactoryContext( pKSFilterFactory,
                                            &pFilterFactoryCtx
                                            );
    if ((status != STATUS_SUCCESS) || !pFilterFactoryCtx)
    {
        KsDeleteFilterFactory( pKSFilterFactory);
        goto errExit;
    }

    //  Allow for the filter factory to use a default filter template
    //  topology when it creates a filter
    //
    //$REVIEW
    pFilterFactoryCtx->pInitialFilterDescriptor = pInitialFilterDescriptor;
    pFilterFactoryCtx->pBdaFilterTemplate = pBdaFilterTemplate;
    pFilterFactoryCtx->pKSFilterFactory = pKSFilterFactory;

    if (ppKSFilterFactory)
    {
        *ppKSFilterFactory = pKSFilterFactory;
    }

errExit:
    if (pFilterDescriptor)
    {
        ExFreePool( pFilterDescriptor);
        pFilterDescriptor = NULL;
    }

    if (   pNewAutomationTable
        && (pNewAutomationTable != &BdaDefaultFilterAutomation)
       )
    {
        ExFreePool( pNewAutomationTable);
        pNewAutomationTable = NULL;
    }

    return status;
}


/*
**  BdaCreateFilterFactory()
**
**  Initializes the common BDA filter context.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateFilterFactory(
    PKSDEVICE                       pKSDevice,
    const KSFILTER_DESCRIPTOR *     pInitialFilterDescriptor,
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    Status = BdaCreateFilterFactoryEx( pKSDevice,
                                       pInitialFilterDescriptor,
                                       pBdaFilterTemplate,
                                       NULL
                                       );
    return Status;
}


/*
**  BdaFilterFactoryUpdateCacheData()
**
**  Updates the pin data cache for the given filter factory.
**  The function will update the cached information for all pin factories
**  exposed by the given filter factory.  
**  
**  If the option filter descriptor is given, the function will update
**  the pin data cache for all pins listed in the given filter descriptor
**  instead of those in the filter factory.
**
**  Drivers will call this to update the pin data cache for all
**  pins that may be exposed by the filter factory.  The driver will
**  provide a filter descriptor listing pins that are not initially exposed
**  by the filter factory (this is usually the same as the template filter
**  descriptor).
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaFilterFactoryUpdateCacheData(
    IN PKSFILTERFACTORY             pFilterFactory,
    IN const KSFILTER_DESCRIPTOR *  pFilterDescriptor OPTIONAL
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    Status = KsFilterFactoryUpdateCacheData( pFilterFactory,
                                             pFilterDescriptor
                                             );

    return Status;
}


/*
**  BdaSyncTopology()
**
**  This routine updates the existing topology to complete all
**  Pending topology changes.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaSyncTopology(
    PKSFILTER       pKSFilter
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    //$BUG  Implement topology sync.

    return STATUS_NOT_IMPLEMENTED;
}


// -------------------------------------------------------------------
// BDA Filter Global Property Set functions
// -------------------------------------------------------------------


/*
** BdaPropertyNodeTypes ()
**
**    Returns a list of ULONGS.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeTypes(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT ULONG *     pulProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    if (pulProperty)
    {
        ULONG                       uliNodeDesc;

        for ( uliNodeDesc = 0
            ; uliNodeDesc < pTemplateDesc->NodeDescriptorsCount
            ; uliNodeDesc++, pulProperty++
            )
        {
            //  For this implementation, the NodeType is just the
            //  index into the NodeDescriptor table.
            //
            *pulProperty = uliNodeDesc;
        }

        Irp->IoStatus.Information = uliNodeDesc * sizeof( ULONG);
    }
    else
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information
            = pTemplateDesc->NodeDescriptorsCount * sizeof( ULONG);
    }


errExit:
    return status;
}


/*
** BdaPropertyNodeDescriptors ()
**
**    Returns a list of GUIDS.  The index of the GUID in the list
**    corresponds to the Node type.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeDescriptors(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT BDANODE_DESCRIPTOR *    pNodeDescripterProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    ULONG                       ulcPropertyEntries;
    ULONG                       ulcNodes;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Determine how many entries the input buffer can hold.
    //
    ulcPropertyEntries = OutputBufferLenFromIrp( Irp);
    ulcPropertyEntries = ulcPropertyEntries / sizeof( BDANODE_DESCRIPTOR);

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);

    if (   !pFilterCtx
        || !pFilterCtx->pBdaFilterTemplate
       )
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    if (!pTemplateDesc)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    //  Handle the case of a NULL NodeDesriptor array as 0 nodes.
    //
    if (!pTemplateDesc->NodeDescriptors)
    {
        ulcNodes = 0;
    }
    else
    {
        ulcNodes = pTemplateDesc->NodeDescriptorsCount;
    }

    if (!pNodeDescripterProperty || (ulcPropertyEntries < ulcNodes))
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
    }
    else
    {
        const KSNODE_DESCRIPTOR *   pNodeDesc;
        ULONG                       uliNodeDesc;
    
        pNodeDesc = pTemplateDesc->NodeDescriptors;

        if (pNodeDesc)
        {
            for ( uliNodeDesc = 0
                ; uliNodeDesc < ulcNodes
                ; uliNodeDesc++, pNodeDescripterProperty++
                )
            {
                //  For this implementation, the NodeType is just the
                //  index into the NodeDescriptor table.
                //
                pNodeDescripterProperty->ulBdaNodeType = uliNodeDesc;

                //  Fill in the function GUID for the node type.
                //  
                if (pNodeDesc->Type)
                {
                    pNodeDescripterProperty->guidFunction = *pNodeDesc->Type;
                }
                else 
                {
                    pNodeDescripterProperty->guidFunction = GUID_NULL;
                }

                //  Fill in the GUID that represents a displayable name
                //  for the node type.
                if (pNodeDesc->Name)
                {
                    pNodeDescripterProperty->guidName = *pNodeDesc->Name;
                }
                else
                {
                    pNodeDescripterProperty->guidName = GUID_NULL;
                }

                //  Point at the next node descriptor
                //
                pNodeDesc = (const KSNODE_DESCRIPTOR *)
                            ((BYTE *) pNodeDesc + pTemplateDesc->NodeDescriptorSize);
            }
        }
    }

    Irp->IoStatus.Information = ulcNodes * sizeof( BDANODE_DESCRIPTOR);


errExit:
    return status;
}


/*
** BdaPropertyNodeProperties ()
**
**    Returns a list of GUIDS.  The guid for each property set
**    supported by the specified node is included in the list.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeProperties(
    IN PIRP         Irp,
    IN PKSP_NODE    Property,
    OUT GUID *      pguidProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    const KSNODE_DESCRIPTOR *   pNodeDesc;
    const KSAUTOMATION_TABLE*   pAutomationTable;
    ULONG                       uliNodeDesc;
    ULONG                       ulcInterfaces;
    ULONG                       ulcPropertyEntries;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Determine how many entries the input buffer can hold.
    //
    ulcPropertyEntries = OutputBufferLenFromIrp( Irp);
    ulcPropertyEntries = ulcPropertyEntries / sizeof( GUID);

    pKSFilter = KsGetFilterFromIrp( Irp);
    if (!pKSFilter)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    if (!pFilterCtx->pBdaFilterTemplate)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    if (!pTemplateDesc)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }
    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    uliNodeDesc = Property->NodeId;

    if (uliNodeDesc >= pTemplateDesc->NodeDescriptorsCount)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pNodeDesc = pTemplateDesc->NodeDescriptors;
    ASSERT( pNodeDesc);
    if (!pNodeDesc)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    ASSERT( pTemplateDesc->NodeDescriptorSize);
    pNodeDesc = (const KSNODE_DESCRIPTOR *)
                ((BYTE *) pNodeDesc + uliNodeDesc * pTemplateDesc->NodeDescriptorSize);

    if (   !pNodeDesc->AutomationTable
        || !pNodeDesc->AutomationTable->PropertySets
       )
    {
        ulcInterfaces =  0;
    }
    else
    {
        ulcInterfaces =  pNodeDesc->AutomationTable->PropertySetsCount;
    }

    if (!pguidProperty || (ulcPropertyEntries < ulcInterfaces))
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
    }
    else
    {
        ULONG                   uliSet;
        const KSPROPERTY_SET *  pPropertySet;
        GUID *                  pguidOut;

        pguidOut = pguidProperty;
        
        pPropertySet = pNodeDesc->AutomationTable->PropertySets;
        if (pPropertySet)
        {
            for ( uliSet = 0
                ; uliSet < ulcInterfaces
                ; uliSet++
                )
            {
                RtlMoveMemory( pguidOut,
                               pPropertySet->Set,
                               sizeof( GUID)
                               );
                pguidOut += 1;
                pPropertySet += 1;
            }
        }
    }

    Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);

errExit:
    return status;
}


/*
** BdaPropertyNodeMethods ()
**
**    Returns a list of GUIDS.  The guid for each property set
**    supported by the specified node is included in the list.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeMethods(
    IN PIRP         Irp,
    IN PKSP_NODE    Property,
    OUT GUID *      pguidProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    const KSNODE_DESCRIPTOR *   pNodeDesc;
    const KSAUTOMATION_TABLE*   pAutomationTable;
    ULONG                       uliNodeDesc;
    ULONG                       ulcInterfaces;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    uliNodeDesc = Property->NodeId;

    if (uliNodeDesc >= pTemplateDesc->NodeDescriptorsCount)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pNodeDesc = pTemplateDesc->NodeDescriptors;
    ASSERT( pTemplateDesc->NodeDescriptorSize);
    pNodeDesc = (const KSNODE_DESCRIPTOR *)
                ((BYTE *) pNodeDesc + uliNodeDesc * pTemplateDesc->NodeDescriptorSize);

    ulcInterfaces =  pNodeDesc->AutomationTable->PropertySetsCount;

    if (pguidProperty)
    {
        ULONG                   uliSet;
        const KSMETHOD_SET *    pMethodSet;
        GUID *                  pguidOut;

        pguidOut = pguidProperty;
        ulcInterfaces = 0;
        
        pMethodSet = pNodeDesc->AutomationTable->MethodSets;
        if (pMethodSet)
        {
            for ( uliSet = 0
                ; uliSet < pNodeDesc->AutomationTable->MethodSetsCount
                ; uliSet++
                )
            {
                RtlMoveMemory( pguidOut,
                               pMethodSet->Set,
                               sizeof( GUID)
                               );
                pguidOut += 1;
                pMethodSet += 1;
                ulcInterfaces += 1;
            }
        }

        Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);
    }
    else
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);
    }


errExit:
    return status;
}


/*
** BdaPropertyNodeEvents ()
**
**    Returns a list of GUIDS.  The guid for each event set
**    supported by the specified node is included in the list.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyNodeEvents(
    IN PIRP         Irp,
    IN PKSP_NODE    Property,
    OUT GUID *      pguidProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    const KSNODE_DESCRIPTOR *   pNodeDesc;
    const KSAUTOMATION_TABLE*   pAutomationTable;
    ULONG                       uliNodeDesc;
    ULONG                       ulcInterfaces;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    ASSERT( pTemplateDesc->NodeDescriptorSize == sizeof( KSNODE_DESCRIPTOR));

    uliNodeDesc = Property->NodeId;

    if (uliNodeDesc >= pTemplateDesc->NodeDescriptorsCount)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pNodeDesc = pTemplateDesc->NodeDescriptors;
    ASSERT( pTemplateDesc->NodeDescriptorSize);
    pNodeDesc = (const KSNODE_DESCRIPTOR *)
                ((BYTE *) pNodeDesc + uliNodeDesc * pTemplateDesc->NodeDescriptorSize);

    ulcInterfaces =  pNodeDesc->AutomationTable->PropertySetsCount;

    if (pguidProperty)
    {
        ULONG                   uliSet;
        const KSEVENT_SET *     pEventSet;
        GUID *                  pguidOut;

        pguidOut = pguidProperty;
        ulcInterfaces = 0;
        
        pEventSet = pNodeDesc->AutomationTable->EventSets;
        if (pEventSet)
        {
            for ( uliSet = 0
                ; uliSet < pNodeDesc->AutomationTable->EventSetsCount
                ; uliSet++
                )
            {
                RtlMoveMemory( pguidOut,
                               pEventSet->Set,
                               sizeof( GUID)
                               );
                pguidOut += 1;
                pEventSet += 1;
                ulcInterfaces += 1;
            }
        }

        Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);
    }
    else
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information = ulcInterfaces * sizeof( GUID);
    }


errExit:
    return status;
}


/*
** BdaPropertyPinTypes ()
**
**    Returns a list of GUIDS.  The index of the GUID in the list
**    corresponds to the Node type.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyPinTypes(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT ULONG *     pulProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx;
    const KSFILTER_DESCRIPTOR * pTemplateDesc;
    const KSPIN_DESCRIPTOR_EX * pPinDesc;
    ULONG                       uliPinDesc;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);
    ASSERT( pTemplateDesc->PinDescriptorSize == sizeof( KSPIN_DESCRIPTOR_EX));

    if (pulProperty)
    {
        for ( uliPinDesc = 0
            ; uliPinDesc < pTemplateDesc->PinDescriptorsCount
            ; uliPinDesc++, pulProperty++
            )
        {
            //  For this implementation, the PinType is just the
            //  index into the PinDescriptor table.
            //
            *pulProperty = uliPinDesc;
        }

        Irp->IoStatus.Information = uliPinDesc * sizeof( ULONG);
    }
    else
    {
        status = STATUS_BUFFER_OVERFLOW;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information
            = pTemplateDesc->PinDescriptorsCount * sizeof( ULONG);
    }

errExit:
    return status;
}


/*
** BdaPropertyTemplateConnections ()
**
**    Returns a list of KSTOPOLOGY_CONNECTIONS.  The list of connections
**    describs how pin types and node types are connected in the template
**    topology
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyTemplateConnections(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSTOPOLOGY_CONNECTION  pConnectionProperty
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PKSFILTER                       pKSFilter;
    PBDA_FILTER_CONTEXT             pFilterCtx;
    const KSFILTER_DESCRIPTOR *     pTemplateDesc;
    const KSTOPOLOGY_CONNECTION *   pConnection;
    ULONG                           uliConnection;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    ASSERT( pFilterCtx->pBdaFilterTemplate);
    pTemplateDesc = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;
    ASSERT( pTemplateDesc);


    if (pConnectionProperty)
    {
        for ( uliConnection = 0, pConnection = pTemplateDesc->Connections
            ; uliConnection < pTemplateDesc->ConnectionsCount
            ; uliConnection++, pConnection++, pConnectionProperty++
            )
        {
            *pConnectionProperty = *pConnection;
        }

        Irp->IoStatus.Information
            = uliConnection * sizeof( KSTOPOLOGY_CONNECTION);
    }
    else
    {
        status = STATUS_BUFFER_OVERFLOW;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information
            = pTemplateDesc->ConnectionsCount * sizeof( KSTOPOLOGY_CONNECTION);
    }

errExit:
    return status;
}


/*
** BdaPinTypeFromPinId()
**
**    Gets the ID of the pin on which to submit node properties, methods
**    and events.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPinTypeFromPinId(
    PBDA_FILTER_CONTEXT         pFilterCtx,
    ULONG                       ulPinId,
    PULONG                      pulPinType
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;

    if (   !pFilterCtx
        || !pFilterCtx->argPinFactoryCtx
        || (ulPinId >= pFilterCtx->ulcPinFactories)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (pFilterCtx->argPinFactoryCtx[ulPinId].ulPinFactoryId != ulPinId)
    {
        status = STATUS_NOT_FOUND;
        goto errExit;
    }

    *pulPinType = pFilterCtx->argPinFactoryCtx[ulPinId].ulPinType;

errExit:
    return status;
}

/*
** BdaGetControllingPinId ()
**
**    Gets the ID of the pin on which to submit node properties, methods
**    and events.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaGetControllingPinId(
    PBDA_FILTER_CONTEXT         pFilterCtx,
    ULONG                       ulInputPinId,
    ULONG                       ulOutputPinId,
    ULONG                       ulNodeType,
    PULONG                      pulControllingPinId
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    ULONG                           ulInputPinType = 0;
    ULONG                           ulOutputPinType = -1;
    ULONG                           ulControllingPinType = -1;

    //  Get the input pin type.
    //
    status = BdaPinTypeFromPinId( pFilterCtx, 
                                  ulInputPinId,
                                  &ulInputPinType
                                  );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Get the output pin type.
    //
    status = BdaPinTypeFromPinId( pFilterCtx, 
                                  ulOutputPinId,
                                  &ulOutputPinType
                                  );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Determine the cotnrolling pin type.
    //
    status = BdaGetControllingPinType( ulNodeType,
                                       ulInputPinType,
                                       ulOutputPinType,
                                       pFilterCtx,
                                       &ulControllingPinType
                                       );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Map the controlling pin type to the controlling pin ID.
    //
    if (ulControllingPinType == ulInputPinType)
    {
        *pulControllingPinId = ulInputPinId;
    }
    else if (ulControllingPinType == ulOutputPinType)
    {
        *pulControllingPinId = ulOutputPinId;
    }
    else
    {
        status = STATUS_NOT_FOUND;
    }


errExit:

    return status;
}

/*
** BdaPropertyGetControllingPinId ()
**
**    Gets the ID of the pin on which to submit node properties, methods
**    and events.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyGetControllingPinId(
    IN PIRP                     Irp,
    IN PKSP_BDA_NODE_PIN        Property,
    OUT PULONG                  pulControllingPinId
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PKSFILTER                       pKSFilter;
    PBDA_FILTER_CONTEXT             pFilterCtx;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsGetFilterFromIrp( Irp);

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    if (!pFilterCtx)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (pulControllingPinId)
    {
        status = BdaGetControllingPinId(
                                        pFilterCtx,
                                        Property->ulInputPinId,
                                        Property->ulOutputPinId,
                                        Property->ulNodeType,
                                        pulControllingPinId
                                        );

        if (status == STATUS_NOT_FOUND)
        {
            //  See if the pins were part of a static filter configuration.
            //
            //$BUG - Pins that are configured without template type information
            //       should always be controlled by the output pin.
            //
            if (Property->ulNodeType == 0)
            {
                *pulControllingPinId = Property->ulInputPinId;
            }
            else
            {
                *pulControllingPinId = Property->ulOutputPinId;
            }

            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Information = sizeof( ULONG);
    }
    else
    {
        status = STATUS_BUFFER_OVERFLOW;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information = sizeof( ULONG);
    }

errExit:
    return status;
}


/*
** BdaStartChanges ()
**
**    Puts the filter into change state.  All changes to BDA topology
**    and properties changed after this will be in effect only after
**    CommitChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaStartChanges(
    IN PIRP         pIrp
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaCheckChanges ()
**
**    Checks the changes to BDA interfaces that have occured since the
**    last StartChanges.  Returns the result that would have occurred if
**    CommitChanges had been called.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaCheckChanges(
    IN PIRP         pIrp
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaCommitChanges ()
**
**    Checks the changes to BDA interfaces that have occured since the
**    last StartChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaCommitChanges(
    IN PIRP         pIrp
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaGetChangeState ()
**
**    Checks the changes to BDA interfaces that have occured since the
**    last StartChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaGetChangeState(
    IN PIRP             pIrp,
    PBDA_CHANGE_STATE   pChangeState
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    ASSERT( pChangeState);
    if (!pChangeState)
    {
        return STATUS_INVALID_PARAMETER;
    }
    *pChangeState = BDA_CHANGES_COMPLETE;

    return STATUS_SUCCESS;
}


/*
** BdaMethodCreatePin ()
**
**    Creates a new pin factory for the given pin type.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaMethodCreatePin(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OUT PULONG      pulPinFactoryID
    )
{
    NTSTATUS        status = STATUS_SUCCESS;

    ASSERT(pIrp);
    if (pIrp)
    {
        PKSFILTER       pKSFilter;
        PKSM_BDA_PIN    pKSPinMethod;
        ULONG           ulPinId;

        pKSPinMethod = (PKSM_BDA_PIN) pKSMethod;

        pKSFilter = KsGetFilterFromIrp( pIrp);
    
        if (pKSFilter && pKSPinMethod)
        {

            status = BdaCreatePin( pKSFilter,
                                   pKSPinMethod->PinType,
                                   pulPinFactoryID
                                   );
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}


/*
** BdaMethodDeletePin ()
**
**    Deletes the given pin factory
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaMethodDeletePin(
    IN PIRP         Irp,
    IN PKSMETHOD    Method,
    OPTIONAL PVOID  pvIgnored
    )
{
    ASSERT( Irp);
    if (!Irp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaPropertyGetPinControl ()
**
**    Returns a the BDA ID or BDA Template Type of the Pin.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaPropertyGetPinControl(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT ULONG *     pulProperty
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSPIN                      pKSPin;
    BDA_PIN_FACTORY_CONTEXT     pinCtx;

    ASSERT( Irp);
    if (!Irp)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    ASSERT( Property);
    if (!Property)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSPin = KsGetPinFromIrp( Irp);

    status = BdaGetPinFactoryContext( pKSPin, &pinCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    if (pulProperty)
    {
        Irp->IoStatus.Information = sizeof( ULONG);

        switch (Property->Id)
        {
        case KSPROPERTY_BDA_PIN_ID:
            //  Return the BDA ID of this pin
            //
            *pulProperty = pinCtx.ulPinFactoryId;
            break;

        case KSPROPERTY_BDA_PIN_TYPE:
            //  Return the BDA Type of this pin
            //
            *pulProperty = pinCtx.ulPinType;
            break;

        default:
            Irp->IoStatus.Information = 0;
            status = STATUS_INVALID_PARAMETER;
            ASSERT( FALSE);
        }
    }
    else
    {
        status = STATUS_MORE_ENTRIES;

        //  If there is no place to put the property then just
        //  return the data size.
        //
        Irp->IoStatus.Information = sizeof( ULONG);
    }


errExit:
    return status;
}


/*
** BdaValidateNodeProperty ()
**
**    Validates that the IRP is for a Pin and that
**    the property belongs to a node associated with that
**    Pin.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaValidateNodeProperty(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSProperty
    )
{
    ASSERT( pIrp);
    if (!pIrp)
    {
        return STATUS_INVALID_PARAMETER;
    }
    ASSERT( pKSProperty);
    if (!pKSProperty)
    {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


/*
** BdaMethodCreateTopology ()
**
**    Creates the topology between the two given pin factories.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
STDMETHODIMP_(NTSTATUS)
BdaMethodCreateTopology(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PKSFILTER           pKSFilter;
    PKSM_BDA_PIN_PAIR   pKSPinPairMethod;
    ULONG               ulPinId;

    if (pIrp)
    {
        pKSPinPairMethod = (PKSM_BDA_PIN_PAIR) pKSMethod;

        pKSFilter = KsGetFilterFromIrp( pIrp);
    
        if (pKSFilter && pKSPinPairMethod)
        {
            //  Obtain the KS Filter Mutex
            //
            //$BUG - Obtain the KS Filter Mutex

            status = BdaCreateTopology( pKSFilter,
                                        pKSPinPairMethod->InputPinId,
                                        pKSPinPairMethod->OutputPinId
                                        );
        
            //  Release the KS Filter Mutex
            //
            //$BUG - Obtain the KS Filter Mutex
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}


/*
**  BdaFindPinPair()
**
**      Returns a pointer to the BDA_PIN_PAIRING that corresponds
**      to the given input and output pins.
**
**  Arguments:
**
**      pTopology   Pointer to the BDA topology that contains the
**                  pin pairing.
**
**      InputPinId  Id of the input Pin to match
**
**      OutputPinId Id of the output Pin to match
**
**  Returns:
**
**      pPinPairing     Pointer to a valid BDA Pin Pairing structure
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

PBDA_PIN_PAIRING
BdaFindPinPair(
    PBDA_FILTER_TEMPLATE    pFilterTemplate,
    ULONG                   InputPinId,
    ULONG                   OutputPinId
    )
{
    return NULL;
}


/*
**  BdaGetPinFactoryContext()
**
**  Finds a BDA PinFactory Context that corresponds
**  to the given KS Pin Instance.
**
** Arguments:
**
**
** Returns:
**
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaGetPinFactoryContext(
    PKSPIN                          pKSPin,
    PBDA_PIN_FACTORY_CONTEXT        pPinFactoryCtx
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PKSFILTER                   pKSFilter;
    PBDA_FILTER_CONTEXT         pFilterCtx = NULL;

    if (!pKSPin || !pPinFactoryCtx)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    pKSFilter = KsPinGetParentFilter( pKSPin);
    if (!pKSFilter)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }


    //  Find our Filter Context so that we can look up the pin type
    //  in the Template Topology.
    //
    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    ASSERT( pFilterCtx);

    if (pKSPin->Id >= pFilterCtx->ulcPinFactories)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    *pPinFactoryCtx = pFilterCtx->argPinFactoryCtx[pKSPin->Id];

errExit:
    return status;
}


/*
**  BdaCreatePin()
**
**      Utility function creates a new pin in the given filter instance.
**
**
**  Arguments:
**
**
**
**      PinType         Pin type to create.
**
**      pPinId          Id of the Pin that was created.
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreatePin(
    PKSFILTER                   pKSFilter,
    ULONG                       ulPinType,
    PULONG                      pulPinId
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    PBDA_FILTER_CONTEXT             pFilterCtx;
    PBDA_PIN_FACTORY_CONTEXT        pPinFactoryCtx;
    KSPIN_DESCRIPTOR_EX             myKSPinDescriptorEx;
    KSAUTOMATION_TABLE *            pNewAutomationTable = NULL;
    const KSPIN_DESCRIPTOR_EX *     pKSPinDescriptorEx;
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate;
    const KSFILTER_DESCRIPTOR *     pFilterDescriptor;


    ASSERT( pulPinId);
    if (!pulPinId)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Find our Filter Context so that we can look up the pin type
    //  in the Template Topology.
    //
    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    ASSERT( pFilterCtx);

    //  Locate this filter's Template Topology
    //
    if (   !pFilterCtx
        || !pFilterCtx->pBdaFilterTemplate
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    pFilterDescriptor = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;

    //  Locate the Pin Type in this filter's Template Topology
    //
    if (pFilterDescriptor->PinDescriptorsCount <= ulPinType)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Get the KSPIN_DESCRIPTOR_EX for this pin type
    //
    pKSPinDescriptorEx = pFilterDescriptor->PinDescriptors;
    ASSERT( pKSPinDescriptorEx);
    ASSERT( pFilterDescriptor->PinDescriptorSize);
    pKSPinDescriptorEx = (const KSPIN_DESCRIPTOR_EX *)
                         (  (BYTE *) pKSPinDescriptorEx
                          + ulPinType * pFilterDescriptor->PinDescriptorSize
                         );

    //  Create a new copy of the pin descriptor so that it is easier to
    //  modify
    //
    myKSPinDescriptorEx = *pKSPinDescriptorEx;
    myKSPinDescriptorEx.AutomationTable = NULL;

    status = BdaAddNodeAutomationToPin( pFilterCtx, 
                                        ulPinType,
                                        pKSFilter->Bag,
                                        pKSPinDescriptorEx->AutomationTable,
                                        &pNewAutomationTable
                                      );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Merge required properties for which BdaSup.sys provides a default
    //  implementation.
    //
    status = KsMergeAutomationTables( 
                 &((PKSAUTOMATION_TABLE)(myKSPinDescriptorEx.AutomationTable)),
                 pNewAutomationTable,
                 (PKSAUTOMATION_TABLE) &BdaDefaultPinAutomation,
                 pKSFilter->Bag
                 );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }


    status = KsFilterCreatePinFactory ( pKSFilter,
                                        &myKSPinDescriptorEx,
                                        pulPinId
                                      );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    status = BdaCreatePinFactoryContext( pKSFilter,
                                         pFilterCtx,
                                         *pulPinId,
                                         ulPinType
                                         );

errExit:

    return status;
}


/*
**  BdaAddNodeAutomationToPin()
**
**      Merges the automation tables for each node type that is controlled
**      by the pin type being created into the automation table for the
**      the pin factory.  This is how the automation tables for BDA
**      control nodes get linked to the controlling pin.  Otherwise the
**      nodes would not be accesable.
**
**
**  Arguments:
**
**
**      pFilterCtx      The BDA filter context to which the pin factory
**                      belongs.  Must have this to get at the template
**                      topology.
**
**      ulPinType       BDA Pin Type of the pin being created.  Need this
**                      to figure out which nodes are controlled by the
**                      pin.
**
**  Returns:
**      Always returns a resulting automation table, even on error.
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaAddNodeAutomationToPin( 
    PBDA_FILTER_CONTEXT         pFilterCtx, 
    ULONG                       ulControllingPinType,
    KSOBJECT_BAG                ObjectBag,
    const KSAUTOMATION_TABLE *  pOriginalAutomationTable,
    PKSAUTOMATION_TABLE *       ppNewAutomationTable
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    const KSFILTER_DESCRIPTOR * pFilterDescriptor;      
    KSAUTOMATION_TABLE *        pNewAutomationTable = NULL;
    ULONG                       uliPath;
    ULONG                       ulcNodes;
    ULONG                       ulcbNodeDescriptor;

    //  Check for required parameters
    //
    if (!pFilterCtx || !ObjectBag)
    {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if (   !pFilterCtx->ulcPathInfo
        || !pFilterCtx->pBdaFilterTemplate
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptorsCount
        || !pFilterCtx->pBdaFilterTemplate->pFilterDescriptor->NodeDescriptors
       )
    {
        goto exit;
    }

    pFilterDescriptor = pFilterCtx->pBdaFilterTemplate->pFilterDescriptor;

    //  If ulcNodeControlInfo is not zero the that array of control info
    //  structures must exist
    //
    ASSERT( pFilterCtx->argpPathInfo);
    if (!pFilterCtx->argpPathInfo)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto exit;
    }

    //  Initial variables used to step through the list of node descriptors
    //  for the filter to which this pin type belongs.
    //
    ulcNodes = pFilterDescriptor->NodeDescriptorsCount;
    ulcbNodeDescriptor = pFilterDescriptor->NodeDescriptorSize;

    //  Step through each template node descriptor and, if it is controlled,
    //  by the given pin type, add its automation table to resulting table.
    //
    for ( uliPath = 0
        ; uliPath < pFilterCtx->ulcPathInfo
        ; uliPath++
        )
    {
        PBDA_PATH_INFO              pPathInfo;
        ULONG                       uliPathEntry;
        BOOLEAN                     fMergeNode = FALSE;

        pPathInfo = pFilterCtx->argpPathInfo[uliPath];

        //  Skip paths that don't include this pin type.
        //
        if (pPathInfo->ulInputPin == ulControllingPinType)
        {
            //  If the controlling pin is an input pin then we
            //  will start merging nodes right away and quit when
            //  we find a topology joint.
            //
            fMergeNode = TRUE;
        }
        else if (pPathInfo->ulOutputPin == ulControllingPinType)
        {
            //  If the controlling pin is an output pin then we
            //  will not merge nodes until we find a topology
            //  joint.
            //
            fMergeNode = FALSE;
        }
        else
        {
            //  The pin we're interested in isn't part of this path.
            continue;
        }

        //  Loop through each connection in the path to see if it points
        //  to a node whose automation table needs to be merged to the
        //  pin.
        //
        for ( uliPathEntry = 0
            ; uliPathEntry < pPathInfo->ulcPathEntries
            ; uliPathEntry++
            )
        {
            const KSTOPOLOGY_CONNECTION *   pConnection;
            ULONG                           uliConnection;
            const KSNODE_DESCRIPTOR *       pNodeDescriptor;
            ULONG                           uliNode;

            if (pPathInfo->rgPathEntries[uliPathEntry].fJoint)
            {
                //  Switch the merge state on a topology joint.
                //
                fMergeNode = !fMergeNode;
                if (!fMergeNode)
                {
                    //  If we were merging input side nodes then we're done
                    //
                    break;
                }
            }

            if (!fMergeNode)
            {
                continue;
            }

            //  Get the "ToNode" from this connection and, if it is not
            //  an output pin, merge its automation table.
            //
            uliConnection = pPathInfo->rgPathEntries[uliPathEntry].uliConnection;
            pConnection = &(pFilterDescriptor->Connections[uliConnection]);
            uliNode = pConnection->ToNode;
            if (   (uliNode == -1)
                || (uliNode >= pFilterDescriptor->NodeDescriptorsCount)
               )
            {
                //  This connection's "ToNode" is an output pin so
                //  skip it.
                //
                continue;
            }
    
            //  Find the Node Descriptor for the node type
            //
            pNodeDescriptor = pFilterDescriptor->NodeDescriptors;
            pNodeDescriptor = (const KSNODE_DESCRIPTOR *)
                                 (  (const BYTE *) (pNodeDescriptor)
                                  + (ulcbNodeDescriptor * uliNode)
                                 );
        
            //  Merge the nodes automation table into the resulting automation
            //  table.
            //
            //$BUGBUG - KsMergeAutomationTables should take const xxx *
            //
            if (!pOriginalAutomationTable)
            {
                pOriginalAutomationTable 
                    = (PKSAUTOMATION_TABLE) (pNodeDescriptor->AutomationTable);
            }
            else
            {
                status = KsMergeAutomationTables( 
                             &pNewAutomationTable,
                             (PKSAUTOMATION_TABLE) pOriginalAutomationTable,
                             (PKSAUTOMATION_TABLE) (pNodeDescriptor->AutomationTable),
                             ObjectBag
                             );
                if (status != STATUS_SUCCESS)
                {
                    goto exit;
                }
                ASSERT( pNewAutomationTable);
        
                pOriginalAutomationTable = pNewAutomationTable;
                pNewAutomationTable = NULL;
            }
        }

    }

exit:
    *ppNewAutomationTable = (PKSAUTOMATION_TABLE) pOriginalAutomationTable;
    return status;
}


/*
**  BdaDeletePin()
**
**      Utility function deletes a pin from the given filter instance.
**
**
**  Arguments:
**
**
**      PinType         Pin type to create.
**
**      pPinId          Id of the Pin that was created.
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaDeletePin(
    PKSFILTER                   pKSFilter,
    PULONG                      pulPinId
    )
{
    NTSTATUS                status = STATUS_SUCCESS;
    PBDA_FILTER_CONTEXT     pFilterCtx;

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);

errExit:
    return status;
}


/*
**  BdaPathExists()
**
**      Utility function checks if there is a path between the input and
**      the output.
**
**
**  Arguments:
**
**      InputPinId
**
**      OutPutPinId
**
**  Returns:
**
**      TRUE            If a path exists.
**      FALSE           If no path exists.
**
** Side Effects:  none
*/

STDMETHODIMP_(BOOLEAN)
BdaPathExists(
    const KSFILTER_DESCRIPTOR * pFilterDescriptor,
    ULONG                       ulInputPinId,
    ULONG                       ulOutputPinId
    )
{
    const KSTOPOLOGY_CONNECTION *   pConnection;
    ULONG                           ulcConnections;
    ULONG                           uliConnection;

    if (   !pFilterDescriptor
        || !pFilterDescriptor->ConnectionsCount
        || !pFilterDescriptor->Connections
       )
    {
        return FALSE;
    }

    //$REVIEW - Assume only DShow style internal connections.
    //$REVIEW   (ie connections between pins with no intervening nodes)
    //
    ulcConnections = pFilterDescriptor->ConnectionsCount;
    pConnection = pFilterDescriptor->Connections;
    for (uliConnection = 0; uliConnection < ulcConnections; uliConnection++)
    {
        if (   (pConnection[uliConnection].FromNode == -1)
            && (pConnection[uliConnection].FromNodePin == ulInputPinId)
            && (pConnection[uliConnection].ToNode == -1)
            && (pConnection[uliConnection].ToNodePin == ulOutputPinId)
           )
        {
            break;
        }
    }

    return (uliConnection < ulcConnections);
}


/*
**  BdaCreateTopology()
**
**      Utility function creates the topology between two pins.
**
**
**  Arguments:
**
**
**      InputPinId
**
**      OutPutPinId
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateTopology(
    PKSFILTER                   pKSFilter,
    ULONG                       ulInputPinId,
    ULONG                       ulOutputPinId
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    PBDA_FILTER_CONTEXT         pFilterCtx = NULL;
    const KSFILTER_DESCRIPTOR * pFilterDesc;
    ULONG                       uliPinPair;
    ULONG                       ulcPinPairs;
    const BDA_PIN_PAIRING *     pPinPairs;
    ULONG                       ulInputPinType;
    ULONG                       ulOutputPinType;

    if (!pKSFilter)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    status = BdaGetFilterContext( pKSFilter, &pFilterCtx);

    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    ASSERT( pFilterCtx);
    if (!pFilterCtx)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    ASSERT( pFilterCtx->pBdaFilterTemplate);
    if (!pFilterCtx->pBdaFilterTemplate)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    pPinPairs = pFilterCtx->pBdaFilterTemplate->pPinPairs;
    ulcPinPairs = pFilterCtx->pBdaFilterTemplate->ulcPinPairs;

    pFilterDesc = pKSFilter->Descriptor;

    if (   !pFilterDesc
        || (ulInputPinId >= pFilterDesc->PinDescriptorsCount)
        || (ulOutputPinId >= pFilterDesc->PinDescriptorsCount)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (BdaPathExists( pFilterDesc, ulInputPinId, ulOutputPinId))
    {
        goto errExit;
    }

    //  Get the input pin type.
    //
    status = BdaPinTypeFromPinId( pFilterCtx, 
                                  ulInputPinId,
                                  &ulInputPinType
                                  );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  Get the output pin type.
    //
    status = BdaPinTypeFromPinId( pFilterCtx, 
                                  ulOutputPinId,
                                  &ulOutputPinType
                                  );
    if (status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  See if there is a pin pairing to match the requested topology.
    //
    for (uliPinPair = 0; uliPinPair < ulcPinPairs; uliPinPair++)
    {
        if (   (pPinPairs[uliPinPair].ulInputPin == ulInputPinType)
            && (pPinPairs[uliPinPair].ulOutputPin == ulOutputPinType)
           )
        {
            break;
        }
    }
    if (uliPinPair >= ulcPinPairs)
    {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto errExit;
    }

    {
        KSTOPOLOGY_CONNECTION   ksConnection;

        //  Add a path between the pins to the filter descriptor
        //
        ksConnection.FromNode = -1;
        ksConnection.FromNodePin = ulInputPinId;
        ksConnection.ToNode = -1;
        ksConnection.ToNodePin = ulOutputPinId;
    
        status = KsFilterAddTopologyConnections ( pKSFilter,
                                                  1,
                                                  &ksConnection
                                                  );
    }

errExit:
    return status;
}


/*
**  BdaInitFilterFactoryContext()
**
**      Initializes a BDA Filter Factory Context based on the filter's
**      template descriptor.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaInitFilterFactoryContext(
    PBDA_FILTER_FACTORY_CONTEXT pFilterFactoryCtx
    )
{
    NTSTATUS                status = STATUS_SUCCESS;

    ASSERT( pFilterFactoryCtx);
    if (!pFilterFactoryCtx)
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    if (!pFilterFactoryCtx->pBdaFilterTemplate)
    {
        goto errExit;
    }

errExit:
    return status;
}


/*
**  BdaPushNextPathHop()
**
**      Recursively pushes connections onto the connection stack until
**      (starting with the input pin of the pin pair) until either the
**      output pin is found or there are no connections that can be pushed.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaPushNextPathHop(
    PULONG                          puliPathStack,
    PBDA_PATH_STACK_ENTRY           pPathStack,
    ULONG                           ulcConnections,
    const KSTOPOLOGY_CONNECTION *   pConnections,
    const BDA_PIN_PAIRING *         pPinPair
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    ULONG                           ulHop;
    ULONG                           ulFromNode;
    ULONG                           ulFromNodePin;
    ULONG                           uliConnection;

    //  Determine which node we are currently finding connection to.
    //
    if (!*puliPathStack)
    {
        //  We are pushing the first hop.
        //
        ulHop = 0;

        //  Hop 0 is always the input pin
        //
        ulFromNode = -1;
        ulFromNodePin = pPinPair->ulInputPin;
    }
    else
    {
        //  We are pushing the next hop.
        //
        ulHop = pPathStack[*puliPathStack - 1].ulHop + 1;

        //  We will be looking for connections from the "ToNode" of the
        //  connection at the top of the stack.
        //
        uliConnection = pPathStack[*puliPathStack - 1].uliConnection;
        ulFromNode = pConnections[uliConnection].ToNode;
        ulFromNodePin = pConnections[uliConnection].ToNodePin;
    }

    //  GO through each connection in the filter factories connection
    //  and push any connection to ulFromNode onto the connections stack.
    //  If a connection from ulFromNode to the output pin of the given
    //  pin pair is found then we have found a complete path for the
    //  pin pair.
    //
    for ( uliConnection = 0
        ; uliConnection < ulcConnections
        ; uliConnection++
        )
    {
        ULONG           uliJoints;
        const ULONG *   pJoints;


        if (pConnections[uliConnection].FromNode != ulFromNode)
        {
            //  Connection is not from the node at the top of the stack.
            //
            continue;
        }

        if (   (pConnections[uliConnection].FromNode == -1)
            && (pConnections[uliConnection].FromNodePin != ulFromNodePin)
           )
        {
            //  The input pin is at the top of the stack and this connection
            //  is not from the input pin of the pin pair.
            //
            continue;
        }
        
        //
        //  This connection is from the node that was on top of the stack
        //  when this function was called.  Push it onto the stack.
        //

        if (*puliPathStack >= ulcConnections)
        {
            //  Stack overflow
            //  Can only occur when the BDA topology contains
            //  cirular references.
            //
            status = STATUS_INVALID_PARAMETER;
            goto errExit;
        }
        
        //  Write the connection info to the next stack entry.
        //
        pPathStack[*puliPathStack].ulHop = ulHop;
        pPathStack[*puliPathStack].uliConnection = uliConnection;
        pPathStack[*puliPathStack].fJoint = FALSE;

        //  See if this connection is also a topology joint.
        //
        for ( uliJoints = 0, pJoints = pPinPair->pTopologyJoints
            ; (uliJoints < pPinPair->ulcTopologyJoints) && pJoints
            ; uliJoints++ 
            )
        {
            if (pJoints[uliJoints] == uliConnection)
            {
                pPathStack[*puliPathStack].fJoint = TRUE;
                break;
            }
        }
        
        //  Increment the stack pointer
        //
        *puliPathStack += 1;

        //  Now that the connection has been pushed on the stack.  See if it
        //  completes a path between the input and output pin pair.
        //
        if (   (pConnections[uliConnection].ToNode == -1)
            && (pConnections[uliConnection].ToNodePin == pPinPair->ulOutputPin)
           )
        {
            //  If this connection completes the path, then complete
            //  now so that the caller will find the end of the path
            //  at the top of the stack.
            //
            break;
        }
    }

errExit:

    return status;
}


/*
**  BdaPopPathSegment()
**
**      Pops the stack back to the next path segment to try.
**
**
**  Arguments:
**
**
**  Returns:
**
**
** Side Effects:  none
*/

BdaPopPathSegment(
    PULONG                          puliPathStack,
    PBDA_PATH_STACK_ENTRY           pPathStack
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    ULONG                           ulCurHop;
    ULONG                           ulNewHop;

    ulCurHop = pPathStack[*puliPathStack].ulHop;
    while (*puliPathStack)
    {
        *puliPathStack -= 1;

        if (!*puliPathStack)
        {
            //  Empty Stack
            //
            break;
        }

        if (pPathStack[(*puliPathStack) - 1].ulHop == ulCurHop)
        {
            //  Stop here if there is another entry on the stack at
            //  the current hop count.
            // 
            break;
        }

        //  We've popped back to a new hop count, so set the current
        //  hop count and pop off another entry.
        //
        ulCurHop = pPathStack[(*puliPathStack) - 1].ulHop;
    }
    
    return status;
}


/*
**  BdaPathInfoFromPathStack()
**
**      Builds a connection path between the input and output pins of
**      a pin pair.
**
**
**  Arguments:
**
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaPathInfoFromPathStack(
    ULONG                           uliPathStack,
    PBDA_PATH_STACK_ENTRY           pPathStack,
    ULONG                           ulcConnections,
    const KSTOPOLOGY_CONNECTION *   pConnections,
    const BDA_PIN_PAIRING *         pPinPair,
    PBDA_PATH_INFO *                ppPathInfo
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PBDA_PATH_INFO      pPathInfo = NULL;
    ULONG               uliConnection;
    ULONG               ulHop;

    ASSERT( uliPathStack);
    ASSERT( pPathStack);
    ASSERT( uliPathStack <= ulcConnections);
    ASSERT( ulcConnections);
    ASSERT( pConnections);
    ASSERT( ppPathInfo);
    ASSERT( pPinPair);

    if (   !ppPathInfo
        || !pConnections
        || !pPathStack
        || !pPinPair
        || !uliPathStack
        || !ulcConnections
        || (uliPathStack > ulcConnections)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Make sure the connection at the top of the path stack points
    //  to the output pin of the pin pair.
    //
    uliConnection = pPathStack[uliPathStack - 1].uliConnection;
    if (   (pConnections[uliConnection].ToNode != -1)
        || (pConnections[uliConnection].ToNodePin != pPinPair->ulOutputPin)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }
    
    //  Start filling in from the node at the last hop.  If the last
    //  hop == 0 then there was only one connection between the input
    //  and output pins with no intervening nodes.
    //
    ulHop = pPathStack[uliPathStack - 1].ulHop;

    //  Allocate enough space for the node path structure and all
    //  nodes in the path.
    //
    pPathInfo = ExAllocatePool( 
                           NonPagedPool,
                             sizeof( BDA_PATH_INFO)
                           + (ulHop + 1) * sizeof( BDA_PATH_STACK_ENTRY)
                           );
    if (!pPathInfo)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }

    pPathInfo->ulInputPin = pPinPair->ulInputPin;
    pPathInfo->ulOutputPin = pPinPair->ulOutputPin;
    pPathInfo->ulcPathEntries = ulHop + 1;

    while (uliPathStack)
    {
        //  Enter the Connection info into the path connection list
        //
        //
        pPathInfo->rgPathEntries[ulHop] = pPathStack[uliPathStack - 1];

        //  Pop the path stack up to the top entry of the next lower hop.
        //  If exhaust the path stack then we are either done or the path
        //  stack didn't reflect a complete path from input pin to
        //  output pin.
        //
        ulHop -= 1;
        while (   uliPathStack
               && (pPathStack[uliPathStack - 1].ulHop != ulHop)
              )
        {
            uliPathStack -= 1;
        }
    }

    //  We should alway end up pointing to a connection between the input
    //  pin and the first node of the path to the output pin.
    //
    ASSERT( ulHop == -1);
    if (ulHop != -1)
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    //  Make sure the last connection points back to the input pin.
    //
    uliConnection = pPathInfo->rgPathEntries[0].uliConnection;
    if (   (pConnections[uliConnection].FromNode != -1)
        || (pConnections[uliConnection].FromNodePin != pPinPair->ulInputPin)
       )
    {
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

exit:
    *ppPathInfo = pPathInfo;
    pPathInfo = NULL;

    return status;

errExit:
    if (pPathInfo)
    {
        ExFreePool( pPathInfo);
        pPathInfo = NULL;
    }

    goto exit;
}


/*
**  BdaBuildPath()
**
**      Builds a connection path between the input and output pins of
**      a pin pair.
**
**
**  Arguments:
**
**
**  Returns:
**
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaBuildPath(
    ULONG                           ulcConnections,
    const KSTOPOLOGY_CONNECTION *   pConnections,
    const BDA_PIN_PAIRING *         pPinPair,
    PBDA_PATH_INFO *                ppPathInfo
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    ULONG                           uliStackPointer;
    PBDA_PATH_STACK_ENTRY           pPathStack = NULL;
    ULONG                           ulcAttempts;
    ULONG                           uliConnection;


    //  Allocate a stack on which to put unfollowed connections to a path.
    //
    pPathStack = ExAllocatePool( 
                               NonPagedPool, 
                               ulcConnections * sizeof( BDA_PATH_STACK_ENTRY)
                               );
    if (!pPathStack)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }


    //  Initialize the unfollowed connection stack
    //
    uliStackPointer = 0;

    //  Build a path stack by pushing each connection that connects from
    //  the previous hop.
    //
    //  It isn't possible to attempt to push the next hop more times than
    //  there are connections.  If this happens then there is an illegal
    //  circular path in the connection list.
    //
    for (ulcAttempts = 0; ulcAttempts < ulcConnections; ulcAttempts++)
    {
        ULONG   uliPrevStackPointer;

        uliPrevStackPointer = uliStackPointer;

        status = BdaPushNextPathHop( &uliStackPointer, 
                                     pPathStack, 
                                     ulcConnections,
                                     pConnections,
                                     pPinPair
                            );

        if (!uliStackPointer)
        {
            //  If the stack is empty at this point then there is
            //  no path from the input pin to the output pin.
            //
            break;
        }

        //  See if the connection at the top of the stack connects to
        //  the output pin of the pin pair.
        //
        uliConnection = pPathStack[uliStackPointer - 1].uliConnection;
        if (   (pConnections[uliConnection].ToNode == -1)
            && (pConnections[uliConnection].ToNodePin == pPinPair->ulOutputPin)
           )
        {
            //  A path from the input pin to the output pin has been
            //  located.
            //
            break;
        }

        //  If no hop could be pushed onto the connnection at the top of
        //  the stack then it is a dead end.
        //
        if (uliStackPointer <= uliPrevStackPointer)
        {
            //  Pop connections from the stack until we reach a viable
            //  (new) candidate to attempt a path from.
            //
            BdaPopPathSegment( &uliStackPointer, pPathStack);

            if (!uliStackPointer)
            {
                //  If the stack is empty at this point then there is
                //  no path from the input pin to the output pin.
                //
                break;
            }
        }
    }

    if (!uliStackPointer || (ulcAttempts >= ulcConnections))
    {
        //  Either there is no path from the input pin to the output pin
        //  or there is an illegal circular path in the connection list
        //
        status = STATUS_INVALID_PARAMETER;
        goto errExit;
    }

    //  Create a BDA node path structure from the Path Stack
    //
    //$REVIEW - Should we allow more than one path per pin pair
    //
    status = BdaPathInfoFromPathStack( uliStackPointer,
                                       pPathStack,
                                       ulcConnections,
                                       pConnections,
                                       pPinPair,
                                       ppPathInfo
                                       );

errExit:
    if (pPathStack)
    {
        ExFreePool( pPathStack);
        pPathStack = NULL;
    }

    return status;
}


/*
**  BdaCreateTemplatePaths()
**
**      Creates a list of all possible paths through the template filter.
**      Determines the controlling pin type for each node type in the
**      template filter.
**
**
**  Arguments:
**
**
**      pFilterFactoryCtx
**
**  Returns:
**
**      NULL            If no valid pin pairing exists with the
**                      given input and output pins.
**
** Side Effects:  none
*/

STDMETHODIMP_(NTSTATUS)
BdaCreateTemplatePaths(
    const BDA_FILTER_TEMPLATE *     pBdaFilterTemplate,
    PULONG                          pulcPathInfo,
    PBDA_PATH_INFO **               pargpPathInfo
    )
{
    NTSTATUS                        status = STATUS_SUCCESS;
    const BDA_FILTER_TEMPLATE *     pFilterTemplate;
    ULONG                           uliPinPair;
    ULONG                           ulcPinPairs;
    const BDA_PIN_PAIRING *         pPinPairs;
    ULONG                           ulcConnections;
    const KSTOPOLOGY_CONNECTION *   pConnections;
    PBDA_PATH_INFO *                argpPathInfo = NULL;

    ASSERT( pBdaFilterTemplate);
    ASSERT( pBdaFilterTemplate->pFilterDescriptor);
    ASSERT( pBdaFilterTemplate->ulcPinPairs);

    if (   !pBdaFilterTemplate
        || !pBdaFilterTemplate->pFilterDescriptor
        || !pBdaFilterTemplate->ulcPinPairs
       )
    {
        goto errExit;
    }

    if (   !pBdaFilterTemplate->pFilterDescriptor->ConnectionsCount
        || !pBdaFilterTemplate->pFilterDescriptor->Connections
        || !pBdaFilterTemplate->pPinPairs
       )
    {
        status = STATUS_INVALID_DEVICE_STATE;
        goto errExit;
    }

    ulcPinPairs = pBdaFilterTemplate->ulcPinPairs;
    pPinPairs = pBdaFilterTemplate->pPinPairs;
    ulcConnections = pBdaFilterTemplate->pFilterDescriptor->ConnectionsCount;
    pConnections = pBdaFilterTemplate->pFilterDescriptor->Connections;


    //  Allocate the node path list (one entry for each pin pairing).
    //
    //$REVIEW - Should we allow more than one path per pin pair
    //
    argpPathInfo = ExAllocatePool(
                     NonPagedPool,
                     ulcPinPairs * sizeof( PBDA_PATH_INFO)
                     );
    if (!argpPathInfo)
    {
        status = STATUS_NO_MEMORY;
        goto errExit;
    }


    for (uliPinPair = 0; uliPinPair < ulcPinPairs; uliPinPair++)
    {
        status = BdaBuildPath(
                    ulcConnections,
                    pConnections,
                    &(pPinPairs[uliPinPair]),
                    &(argpPathInfo[uliPinPair])
                    );
        if (status != STATUS_SUCCESS)
        {
            goto errExit;
        }
    }

    *pulcPathInfo = ulcPinPairs;
    *pargpPathInfo = argpPathInfo;
    argpPathInfo = NULL;


errExit:
    if (argpPathInfo)
    {
        ExFreePool( argpPathInfo);
        argpPathInfo = NULL;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\bdasup\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys

# Build WinDbg symbols
#
$(TARGETPATH)\$(TARGETNAME).dbg: $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(TARGETPATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
    -del $(TARGETPATH)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\inc\ipsink.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      ipsink.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _IPSINK_H_
#define _IPSINK_H_


/////////////////////////////////////////////////////////////////////////////
//
//
#define BDA_NDIS_MINIPORT        L"\\Device\\NDIS_IPSINK"
#define BDA_NDIS_SYMBOLIC_NAME   L"\\DosDevices\\NDIS_IPSINK"

#define BDA_NDIS_STARTUP         L"\\Device\\NDIS_IPSINK_STARTUP"

//////////////////////////////////////////////////////////
//
//
#define MULTICAST_LIST_SIZE             256
#define ETHERNET_ADDRESS_LENGTH         6


/////////////////////////////////////////////////////////////////////////////
//
//
#define NTStatusFromNdisStatus(nsResult)  ((NTSTATUS) nsResult)


/////////////////////////////////////////////////////////////////////////////
//
//
typedef struct _ADAPTER  ADAPTER,  *PADAPTER;
typedef struct _IPSINK_FILTER_  IPSINK_FILTER,   *PIPSINK_FILTER;
typedef struct _LINK_    LINK,     *PLINK;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef enum
{
    IPSINK_EVENT_SHUTDOWN = 0x00000001,
    IPSINK_EVENT_MAX

} IPSINK_EVENT;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*QUERY_INTERFACE) (PVOID pvContext);
typedef ULONG    (*ADD_REF) (PVOID pvContext);
typedef ULONG    (*RELEASE) (PVOID pvContext);

/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*NDIS_INDICATE_DATA)   (PVOID pvContext, PVOID pvData, ULONG ulcbData);
typedef NTSTATUS (*NDIS_INDICATE_STATUS) (PVOID pvContext, PVOID pvEvent);
typedef VOID     (*NDIS_INDICATE_RESET)  (PVOID pvContext);
typedef ULONG    (*NDIS_GET_DESCRIPTION) (PVOID pvContext, PUCHAR pDescription);
typedef VOID     (*NDIS_CLOSE_LINK)      (PVOID pvContext);

typedef struct
{
    QUERY_INTERFACE      QueryInterface;
    ADD_REF              AddRef;
    RELEASE              Release;
    NDIS_INDICATE_DATA   IndicateData;
    NDIS_INDICATE_STATUS IndicateStatus;
    NDIS_INDICATE_RESET  IndicateReset;
    NDIS_GET_DESCRIPTION GetDescription;
    NDIS_CLOSE_LINK      CloseLink;

} ADAPTER_VTABLE, *PADAPTER_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*STREAM_SET_MULTICASTLIST) (PVOID pvContext, PVOID pvMulticastList, ULONG ulcbList);
typedef NTSTATUS (*STREAM_SIGNAL_EVENT)      (PVOID pvContext, ULONG ulEvent);
typedef NTSTATUS (*STREAM_RETURN_FRAME)      (PVOID pvContext, PVOID pvFrame);

typedef struct
{
    QUERY_INTERFACE          QueryInterface;
    ADD_REF                  AddRef;
    RELEASE                  Release;
    STREAM_SET_MULTICASTLIST SetMulticastList;
    STREAM_SIGNAL_EVENT      IndicateStatus;
    STREAM_RETURN_FRAME      ReturnFrame;

} FILTER_VTABLE, *PFILTER_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{
    QUERY_INTERFACE    QueryInterface;
    ADD_REF            AddRef;
    RELEASE            Release;

} FRAME_POOL_VTABLE, *PFRAME_POOL_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{
    QUERY_INTERFACE    QueryInterface;
    ADD_REF            AddRef;
    RELEASE            Release;

} FRAME_VTABLE, *PFRAME_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{

    ULONG       ulOID_GEN_XMIT_OK;
    ULONG       ulOID_GEN_RCV_OK;
    ULONG       ulOID_GEN_XMIT_ERROR;
    ULONG       ulOID_GEN_RCV_ERROR;
    ULONG       ulOID_GEN_RCV_NO_BUFFER;
    ULONG       ulOID_GEN_DIRECTED_BYTES_XMIT;
    ULONG       ulOID_GEN_DIRECTED_FRAMES_XMIT;
    ULONG       ulOID_GEN_MULTICAST_BYTES_XMIT;
    ULONG       ulOID_GEN_MULTICAST_FRAMES_XMIT;
    ULONG       ulOID_GEN_BROADCAST_BYTES_XMIT;
    ULONG       ulOID_GEN_BROADCAST_FRAMES_XMIT;
    ULONG       ulOID_GEN_DIRECTED_BYTES_RCV;
    ULONG       ulOID_GEN_DIRECTED_FRAMES_RCV;
    ULONG       ulOID_GEN_MULTICAST_BYTES_RCV;
    ULONG       ulOID_GEN_MULTICAST_FRAMES_RCV;
    ULONG       ulOID_GEN_BROADCAST_BYTES_RCV;
    ULONG       ulOID_GEN_BROADCAST_FRAMES_RCV;
    ULONG       ulOID_GEN_RCV_CRC_ERROR;
    ULONG       ulOID_GEN_TRANSMIT_QUEUE_LENGTH;

} NDISIP_STATS, *PNDISIP_STATS;


/////////////////////////////////////////////////////////////////////////////
//
//  The NDIS Adapter structure
//
typedef struct _ADAPTER
{
    ULONG               ulRefCount;

    //
    //  Adapter Context passed in by NDIS to the miniport.
    //
    PVOID               ndishMiniport;

    PDEVICE_OBJECT      pDeviceObject;

    PVOID               ndisDeviceHandle;

    PUCHAR              pVendorDescription;

    ULONG               ulInstance;

    PIPSINK_FILTER      pFilter;

    PADAPTER_VTABLE     lpVTable;

    PFRAME_POOL         pFramePool;

    PFRAME              pCurrentFrame;
    PUCHAR              pIn;
    ULONG               ulPR;

    ULONG               ulPacketFilter;

    NDISIP_STATS        stats;

    ULONG               ulcbMulticastListEntries;

    UCHAR               multicastList[MULTICAST_LIST_SIZE]
                                     [ETHERNET_ADDRESS_LENGTH];

};

typedef struct _STATS_
{
    ULONG ulTotalPacketsWritten;
    ULONG ulTotalPacketsRead;

    ULONG ulTotalStreamIPPacketsWritten;
    ULONG ulTotalStreamIPBytesWritten;
    ULONG ulTotalStreamIPFrameBytesWritten;

    ULONG ulTotalNetPacketsWritten;
    ULONG ulTotalUnknownPacketsWritten;

} STATS, *PSTATS;


//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//

typedef struct _IPSINK_FILTER_
{

    LIST_ENTRY                          AdapterSRBQueue;
    KSPIN_LOCK                          AdapterSRBSpinLock;
    BOOLEAN                             bAdapterQueueInitialized;

    //
    // Statistics
    //
    STATS                               Stats;

    //
    // Link to NDIS Component
    //
    LINK                                NdisLink;

    //
    // NDIS VTable
    //
    PADAPTER                            pAdapter;

    //
    //
    //
    PDEVICE_OBJECT                      DeviceObject;

    //
    //
    //
    PDRIVER_OBJECT                      DriverObject;

    //
    //
    //
    PFILTER_VTABLE                      lpVTable;

    //
    //
    //
    //WORK_QUEUE_ITEM                     WorkItem;

    //
    //
    //
    ULONG                               ulRefCount;

    //
    //
    //
    PKEVENT                             pNdisStartEvent;
    PHANDLE                             hNdisStartEvent;

    //
    //
    //
    BOOLEAN                             bTerminateWaitForNdis;

    //
    //
    //
    BOOLEAN                             bInitializationComplete;

    //
    //
    //
    PVOID                               pStream [2][1];

    ULONG                               ulActualInstances [2];   // Count of instances per stream

    //
    // NIC Description string pointer
    //
    PUCHAR                              pAdapterDescription;
    ULONG                               ulAdapterDescriptionLength;

    //
    // NIC Address string
    //
    PUCHAR                              pAdapterAddress;
    ULONG                               ulAdapterAddressLength;

    //
    // Multicast list local storage
    //
    ULONG               ulcbMulticastListEntries;

    UCHAR               multicastList[MULTICAST_LIST_SIZE]
                                     [ETHERNET_ADDRESS_LENGTH];


};



/////////////////////////////////////////////
//
//
typedef enum
{
    RECEIVE_DATA,
    MAX_IOCTLS
};

/////////////////////////////////////////////
//
//
typedef enum
{
    CMD_QUERY_INTERFACE = 0x00000001,
    MAX_COMMANDS
};


/////////////////////////////////////////////
//
//
typedef struct _IPSINK_NDIS_COMMAND
{
    ULONG ulCommandID;

    union
    {
        struct
        {
            PVOID pNdisAdapter;
            PVOID pStreamAdapter;

        } Query;

    } Parameter;

} IPSINK_NDIS_COMMAND, *PIPSINK_NDIS_COMMAND;


/////////////////////////////////////////////
//
//
#define _IPSINK_CTL_CODE(function, method, access) CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)
#define IOCTL_GET_INTERFACE     _IPSINK_CTL_CODE(RECEIVE_DATA, METHOD_NEITHER, FILE_ANY_ACCESS)


#endif  // _IPSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\inc\forward.h ===
//////////////////////////////////////////////////////////
//
//
//
typedef struct _FRAME_POOL_ FRAME_POOL,   *PFRAME_POOL;
typedef struct _FRAME_      FRAME,        *PFRAME;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\bdasup\objdesc.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjDesc.cpp

Abstract:

    Static object description data structures.

    This file includes Property, Method, and Event descriptors that
    the BDA Support Library will add to client filters and pins

--*/



#include <wdm.h>
#include <limits.h>
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <bdasup.h>
#include "bdasupi.h"


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)


//
//  Filter BDA_Topology property Set.
//
//  Defines the dispatch routines for the Default BDA_Topology
//  properties added to a BDA filter.
//
DEFINE_KSPROPERTY_TABLE(BdaTopologyProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_TYPES(
        BdaPropertyNodeTypes,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPES(
        BdaPropertyPinTypes,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_TEMPLATE_CONNECTIONS(
        BdaPropertyTemplateConnections,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_METHODS(
        BdaPropertyNodeMethods,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_PROPERTIES(
        BdaPropertyNodeProperties,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_EVENTS(
        BdaPropertyNodeEvents,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_CONTROLLING_PIN_ID(
        BdaPropertyGetControllingPinId,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_DESCRIPTORS(
        BdaPropertyNodeDescriptors,
        NULL
        )
};


//
//  Filter BDA_DeviceConfiguration Method Set.
//
//  Defines the dispatch routines for the Default BdaDeviceConfiguration
//  properties added to a BDA filter.
//
DEFINE_KSMETHOD_TABLE(BdaDeviceConfigurationMethods)
{
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_PIN_FACTORY(
        BdaMethodCreatePin,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_TOPOLOGY(
        BdaMethodCreateTopology,
        NULL
        )
};


//
//  Filter Property Sets supported by defualt
//
//  This table defines all property sets added to filters by
//  the BDA Support Library
//
DEFINE_KSPROPERTY_SET_TABLE(BdaFilterPropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaTopology,                   // Set
        SIZEOF_ARRAY(BdaTopologyProperties),        // PropertiesCount
        BdaTopologyProperties,                      // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),
};


//
//  Filter Mtehod Sets supported by defualt
//
//  This table defines all method sets added to filters by
//  the BDA Support Library
//
DEFINE_KSMETHOD_SET_TABLE(BdaFilterMethodSets)
{
    DEFINE_KSMETHOD_SET
    (
        &KSMETHODSETID_BdaDeviceConfiguration,          // Set
        SIZEOF_ARRAY(BdaDeviceConfigurationMethods),    // PropertiesCount
        BdaDeviceConfigurationMethods,                  // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};


//
//  Pin Control Property Set
//
//  Defines the dispatch routines for the BDA Control Properties
//  on a pin
//
DEFINE_KSPROPERTY_TABLE(BdaPinControlProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_PIN_ID(
        BdaPropertyGetPinControl,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPE(
        BdaPropertyGetPinControl,
        NULL
        )
};


//
//  Pin Property Sets supported by defualt
//
//  This table defines all property sets added to pins by
//  the BDA Support Library
//
DEFINE_KSPROPERTY_SET_TABLE(BdaPinPropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaPinControl,                 // Set
        SIZEOF_ARRAY(BdaPinControlProperties),      // PropertiesCount
        BdaPinControlProperties,                    // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    )
};


//
//  BDA Pin Automation Table
//
//  Lists all Property, Method, and Event Set tables added to a pin's
//  automation table by the BDA Support Library
//
DEFINE_KSAUTOMATION_TABLE(BdaDefaultPinAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(BdaPinPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  BDA Filter Automation Table
//
//  Lists all Property, Method, and Event Set tables added to a filter's
//  automation table by the BDA Support Library
//
DEFINE_KSAUTOMATION_TABLE(BdaDefaultFilterAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(BdaFilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS(BdaFilterMethodSets),
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\inc\link.h ===
/////////////////////////////////////////////////////////////////////////
//
//
typedef struct _LINK_
{
    KSPIN_LOCK       spinLock;
    PDEVICE_OBJECT   pDeviceObject;
    PFILE_OBJECT     pFileObject;
    USHORT           flags;
} LINK, *PLINK;


#define LINK_ESTABLISHED 0x00000001

//////////////////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateDevice (
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING DeviceName,
    PUNICODE_STRING SymbolicName,
    ULONG ulcbDeviceExtension,
    PDEVICE_OBJECT  pDeviceObject
    );

VOID
CloseLink (
    PLINK pLink
    );

PLINK
OpenLink (
    PLINK   pLink,
    UNICODE_STRING  DriverName
    );

NTSTATUS
SendIOCTL (
    PLINK     pLink,
    ULONG     ulIoctl,
    PVOID     pData,
    ULONG     ulcbData
    );

NTSTATUS
CreateWaitForNdisThread (
    PVOID pContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\adapter.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <forward.h>
#include <memory.h>
#include <ndis.h>
#include <link.h>
#include <ipsink.h>

#include "device.h"
#include "NdisApi.h"
#include "frame.h"
#include "mem.h"
#include "adapter.h"
#include "main.h"

//////////////////////////////////////////////////////////
//
//
//
PADAPTER       global_pAdapter;
UCHAR          achGlobalVendorDescription [] = "Microsoft TV/Video Connection";
ULONG          ulGlobalInstance              = 1;


//////////////////////////////////////////////////////////
//
//
const ADAPTER_VTABLE AdapterVTable =
    {
    Adapter_QueryInterface,
    Adapter_AddRef,
    Adapter_Release,
    Adapter_IndicateData,
    Adapter_IndicateStatus,
    Adapter_IndicateReset,
    Adapter_GetDescription,
    Adapter_CloseLink
    };


//////////////////////////////////////////////////////////
//
//
#pragma pack (push, 1)

typedef ULONG CHECKSUM;

typedef struct _MAC_ADDRESS_
{
    UCHAR Address [6];

} MAC_ADDRESS, *PMAC_ADDRESS;

typedef struct _HEADER_802_3
{
    MAC_ADDRESS DestAddress;
    MAC_ADDRESS SourceAddress;
    UCHAR       Type[2];

} HEADER_802_3, *PHEADER_802_3;


typedef struct _HEADER_IP_
{
    UCHAR  ucVersion_Length;
    UCHAR  ucTOS;
    USHORT usLength;
    USHORT usId;
    USHORT usFlags_Offset;
    UCHAR  ucTTL;
    UCHAR  ucProtocol;
    USHORT usHdrChecksum;
    UCHAR  ucSrcAddress [4];
    UCHAR  ucDestAddress [4];

} HEADER_IP, *PHEADER_IP;

#pragma pack (pop)


//////////////////////////////////////////////////////////
//
//
const HEADER_802_3 h802_3Template =
{
    {0x01, 0x00, 0x5e, 0, 0, 0}
  , {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
  , {0x08, 0x00}
};


//////////////////////////////////////////////////////////////////////////////
VOID
DumpData (
    PUCHAR pData,
    ULONG  ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
  ULONG  ulCount;
  ULONG  ul;
  UCHAR  uc;

  while (ulSize)
  {
      ulCount = 16 < ulSize ? 16 : ulSize;

      for (ul = 0; ul < ulCount; ul++)
      {
          uc = *pData;

          TEST_DEBUG (TEST_DBG_TRACE, ("%02X ", uc));
          ulSize -= 1;
          pData  += 1;
      }

      TEST_DEBUG (TEST_DBG_TRACE, ("\n"));
  }

}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateAdapter (
    PADAPTER *ppAdapter,
    NDIS_HANDLE ndishWrapper,
    NDIS_HANDLE ndishAdapterContext
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS nsResult;
    PADAPTER pAdapter;
    UCHAR    tmp_buffer [32] = {0};


    //
    // Init the output paramter
    //
    *ppAdapter = NULL;

    //
    //  Allocate memory for the adapter block now.
    //
    nsResult = AllocateMemory (&pAdapter, sizeof(ADAPTER));
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }
    NdisZeroMemory (pAdapter, sizeof (ADAPTER));

    //
    // Init the reference count
    //
    pAdapter->ulRefCount = 1;

    //
    // Save the pAdapter into global storage
    //
    global_pAdapter = pAdapter;

    //
    // Initialize the adapter structure fields
    //
    pAdapter->ndishMiniport = ndishAdapterContext;

    //
    // Initialize the adapter vtable
    //
    pAdapter->lpVTable = (PADAPTER_VTABLE) &AdapterVTable;

    //
    // Save off the instance for this adapter
    //
    pAdapter->ulInstance = ulGlobalInstance++;

    //
    // Setup the vendor description string for this instance
    //
    nsResult = AllocateMemory (&pAdapter->pVendorDescription, sizeof(achGlobalVendorDescription) + 8);
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }
    NdisZeroMemory (pAdapter->pVendorDescription, sizeof (achGlobalVendorDescription) + 8);

    NdisMoveMemory (pAdapter->pVendorDescription, (PVOID) achGlobalVendorDescription, sizeof (achGlobalVendorDescription));

#if DBG
    MyStrCat (pAdapter->pVendorDescription, "(");
    MyStrCat (pAdapter->pVendorDescription, MyUlToA (pAdapter->ulInstance, tmp_buffer, 10));
    MyStrCat (pAdapter->pVendorDescription, ")");

    DbgPrint ("Vendor description: %s\n", pAdapter->pVendorDescription);
#endif // DEBUG


    //
    // Set default completion timeout to IGNORE
    //
    //  WARNING!  The interface type is not optional!
    //
    NdisMSetAttributesEx (
        ndishAdapterContext,
        pAdapter,
        4,
        NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
        NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT,
        NdisInterfaceInternal);


    #ifndef WIN9X

    //
    // Create a device so other drivers (ie Streaming minidriver) can
    // link up with us
    //
    nsResult = (NTSTATUS) ntInitializeDeviceObject (
                         ndishWrapper,
                         pAdapter,
                         &pAdapter->pDeviceObject,
                         &pAdapter->ndisDeviceHandle);

    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    #endif

    ///////////////////////////////////////////////////
    //
    // Allocate a buffer pool.  This pool will be used
    // to indicate the streaming data frames.
    //
    CreateFramePool (pAdapter,
                     &pAdapter->pFramePool,
                     IPSINK_NDIS_MAX_BUFFERS,
                     IPSINK_NDIS_BUFFER_SIZE,
                     sizeof (IPSINK_MEDIA_SPECIFIC_INFORMATION)
                     );


    return nsResult;

}


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Adapter_QueryInterface (
    PADAPTER pAdapter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Adapter_AddRef (
    PADAPTER pAdapter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pAdapter)
    {
        pAdapter->ulRefCount += 1;
        return pAdapter->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Adapter_Release (
    PADAPTER pAdapter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pAdapter)
    {
        pAdapter->ulRefCount -= 1;

        ulRefCount = pAdapter->ulRefCount;

        if (pAdapter->ulRefCount == 0)
        {
            FreeMemory (pAdapter, sizeof (ADAPTER));
        }
    }

    return ulRefCount;
}


//////////////////////////////////////////////////////////////////////////////
VOID
Adapter_IndicateReset (
    PADAPTER pAdapter
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pAdapter)
    {
        if (pAdapter->pCurrentFrame != NULL)
        {
            if (pAdapter->pCurrentFrame->pFramePool)
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("Putting Current Frame %08X back on Available Queue\n", pAdapter->pCurrentFrame));
                PutFrame (pAdapter->pCurrentFrame->pFramePool, &pAdapter->pCurrentFrame->pFramePool->leAvailableQueue, pAdapter->pCurrentFrame);
            }

            pAdapter->pCurrentFrame = NULL;
            pAdapter->pIn  = NULL;
            pAdapter->ulPR = 0;
        }
    }

}


//////////////////////////////////////////////////////////////////////////////
ULONG
Adapter_GetDescription (
    PADAPTER pAdapter,
    PUCHAR  pDescription
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG ulLength;

    ulLength = MyStrLen (pAdapter->pVendorDescription) + 1;   // add 1 to include terminator

    //
    // If the description pointer is NULL, then pass back the length only
    //
    if (pDescription != NULL)
    {
        NdisMoveMemory (pDescription, pAdapter->pVendorDescription, ulLength);
    }

    return ulLength;
}

//////////////////////////////////////////////////////////////////////////////
VOID
Adapter_CloseLink (
    PADAPTER pAdapter
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pAdapter)
    {
        if (pAdapter->pFilter != NULL)
        {
            pAdapter->pFilter->lpVTable->Release (pAdapter->pFilter);
            pAdapter->pFilter = NULL;
        }
    }

}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
GetNdisFrame (
    PADAPTER  pAdapter,
    PFRAME   *ppFrame
    )
//////////////////////////////////////////////////////////////////////////////
{
    PFRAME pFrame            = NULL;
    NTSTATUS ntStatus        = STATUS_UNSUCCESSFUL;
    PHEADER_802_3 pEthHeader = NULL;
    PHEADER_IP pIPHeader     = NULL;

    *ppFrame = NULL;

    pFrame = GetFrame (pAdapter->pFramePool, &pAdapter->pFramePool->leAvailableQueue);
    TEST_DEBUG (TEST_DBG_TRACE, ("Getting Frame %08X from the Available Queue\n", pFrame));

    if (pFrame)
    {
        ntStatus = STATUS_SUCCESS;

        *ppFrame = pFrame;
    }

    return ntStatus;
}

#define SWAP_WORD(A) ((A >> 8) & 0x00FF) + ((A << 8) & 0xFF00)


//////////////////////////////////////////////////////////////////////////////
USHORT
sizeof_packet (
    PHEADER_IP pIpHdr
    )
//////////////////////////////////////////////////////////////////////////////
{
    USHORT usLength;

    usLength = pIpHdr->usLength;

    usLength = SWAP_WORD (usLength);

    return usLength;
}



//////////////////////////////////////////////////////////////////////////////
NTSTATUS
TranslateAndIndicate (
    PADAPTER pAdapter,
    PUCHAR   pOut,
    ULONG    ulSR
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS nsResult = STATUS_SUCCESS;
    ULONG    ulAmtToCopy;
    ULONG    uliNextByte;

    ASSERT (pAdapter);
    ASSERT (pOut);
    
    for ( uliNextByte = 0; uliNextByte < ulSR; )
    {
        HEADER_802_3 *  pHeader802_3;
        HEADER_IP *     pHeaderIP;

        ulAmtToCopy = 0;

        //  If there is no current frame then sync up to a new
        //  802.3 (RFC 894) ethernet frame.
        //
        if (pAdapter->pCurrentFrame == NULL)
        {
            //  Sync to a valid looking 802.3 frame
            //
            while ((ulSR - uliNextByte) >= (sizeof (HEADER_802_3) + sizeof (HEADER_IP)))
            {
                pHeader802_3 = (HEADER_802_3 *) &(pOut[uliNextByte]);
                pHeaderIP = (HEADER_IP *) &(pOut[uliNextByte + sizeof(HEADER_802_3)]);

                if (   (pHeader802_3->Type[0] == 0x08)
                    && (pHeader802_3->Type[1] == 0x00)
                    && (pHeaderIP->ucVersion_Length == 0x45)
                    && (sizeof_packet( pHeaderIP) <= MAX_IP_PACKET_SIZE)
                   )
                {
                    break;
                }
                uliNextByte++;
            }

            if ((ulSR - uliNextByte) < (sizeof (HEADER_802_3) + sizeof (HEADER_IP)))
            {
                TEST_DEBUG (TEST_DBG_INFO, ("Stream buffer consumed while searching for valid IP packet\n"));
                nsResult = STATUS_SUCCESS;
                goto ret;
            }

            //
            //  Everything looks good...get a new frame and start data transfer
            //
            nsResult = GetNdisFrame( pAdapter, 
                                     &pAdapter->pCurrentFrame
                                     );
            if (nsResult != STATUS_SUCCESS)
            {
                TEST_DEBUG (TEST_DBG_ERROR, ("Get NDIS frame failed.  No more NDIS frames available. No Frame built\n"));
                nsResult = STATUS_SUCCESS;
                pAdapter->stats.ulOID_GEN_RCV_NO_BUFFER += 1;
                pAdapter->pIn = NULL;
                pAdapter->pCurrentFrame = NULL;
                pAdapter->ulPR = 0;
                goto ret;
            }

            //
            // Update the reference count for this frame
            //
            pAdapter->pCurrentFrame->lpVTable->AddRef( pAdapter->pCurrentFrame);

            //
            // define pointers to the data in and out buffers, and init the packet size field
            //
            pAdapter->pIn = (PUCHAR) (pAdapter->pCurrentFrame->pvMemory);
            pAdapter->ulPR = sizeof_packet( pHeaderIP) + sizeof (HEADER_802_3);
            pAdapter->pCurrentFrame->ulcbData = pAdapter->ulPR;

            TEST_DEBUG (TEST_DBG_TRACE, ("CREATING NEW NDIS FRAME %08X, packet size %d\n", pAdapter->pCurrentFrame, pAdapter->ulPR));
        }

        if (pAdapter->ulPR <= (ulSR - uliNextByte))
        {
            ulAmtToCopy = pAdapter->ulPR;
        }
        else
        {
            ulAmtToCopy = ulSR - uliNextByte;
        }

        NdisMoveMemory( pAdapter->pIn, 
                        &(pOut[uliNextByte]), 
                        ulAmtToCopy
                        );
        pAdapter->pIn += ulAmtToCopy;
        pAdapter->ulPR -= ulAmtToCopy;
        uliNextByte += ulAmtToCopy;

        if (pAdapter->ulPR == 0)
        {
            BOOLEAN bResult;
            PINDICATE_CONTEXT pIndicateContext = NULL;
            NDIS_HANDLE SwitchHandle = NULL;

            AllocateMemory (&pIndicateContext, sizeof (INDICATE_CONTEXT));
            if(!pIndicateContext)
            {
                nsResult = STATUS_NO_MEMORY;
                goto ret;
            }

            pIndicateContext->pAdapter = pAdapter;

            //
            // Place the frame on the indicateQueue
            //
            TEST_DEBUG (TEST_DBG_TRACE, ("Putting Frame %08X on Indicate Queue\n", pAdapter->pCurrentFrame));
            PutFrame (pAdapter->pFramePool, &pAdapter->pFramePool->leIndicateQueue, pAdapter->pCurrentFrame);

            pAdapter->pCurrentFrame = NULL;

            //
            //
            // Switch to a state which allows us to call NDIS functions
            //
            bResult = NdisIMSwitchToMiniport (pAdapter->ndishMiniport, &SwitchHandle);
            if (bResult == TRUE)
            {

                nsResult = IndicateCallbackHandler (pAdapter->ndishMiniport, (PVOID) pIndicateContext);

                NdisIMRevertBack (pAdapter->ndishMiniport, SwitchHandle);

            }
            else
            {
                nsResult = NdisIMQueueMiniportCallback (pAdapter->ndishMiniport, IndicateCallbackHandler, (PVOID) pIndicateContext);
            }
        }
    }

ret:

    return nsResult;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Adapter_IndicateData (
    IN PADAPTER pAdapter,
    IN PVOID pvData,
    IN ULONG ulcbData
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus        = STATUS_SUCCESS;

    ntStatus = TranslateAndIndicate (pAdapter, pvData, ulcbData);

    return ntStatus;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Adapter_IndicateStatus (
    IN PADAPTER pAdapter,
    IN PVOID pvEvent
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus        = STATUS_UNSUCCESSFUL;
    BOOLEAN bResult          = FALSE;
    NDIS_HANDLE SwitchHandle = NULL;

    //
    // Switch to a state which allows us to call NDIS functions
    //
    bResult = NdisIMSwitchToMiniport (pAdapter, &SwitchHandle);
    if (bResult == TRUE)
    {
        //ntStatus = IndicateEvent (pAdapter, pvEvent);

        //
        // Revert back to previous state
        //
        NdisIMRevertBack (pAdapter, SwitchHandle);

        ntStatus = STATUS_SUCCESS;
        goto ret;
    }
    else
    {
        // Queue a miniport callback
    }

ret:

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\device.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     ipndis.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _IP_NDIS_H
#define _IP_NDIS_H


NTSTATUS
ntInitializeDeviceObject(
    IN  PVOID           nhWrapperHandle,
    IN  PADAPTER        pAdapter,
    OUT PDEVICE_OBJECT *pndisDriverObject,
    OUT PVOID           pndisDeviceHandle
    );


#endif // _IP_NDIS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\adapter.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     ipndis.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _ADAPTER_H
#define _ADAPTER_H


//////////////////////////////////////////////////////////////////////////////\
//
//
//  Prototypes
//
//
NTSTATUS
Adapter_QueryInterface (
    IN PADAPTER pAdapter
    );

ULONG
Adapter_AddRef (
    IN PADAPTER pAdapter
    );

ULONG
Adapter_Release (
    IN PADAPTER pAdapter
    );

NTSTATUS
Adapter_IndicateData (
    IN PADAPTER pAdapter,
    IN PVOID pvData,
    ULONG ulcbData
    );

NTSTATUS
Adapter_IndicateStatus (
    IN PADAPTER pAdapter,
    IN PVOID pvData
    );

ULONG
Adapter_GetDescription (
    PADAPTER pAdapter,
    PUCHAR  pDescription
    );

VOID
Adapter_IndicateReset (
    IN PADAPTER pAdapter
    );

VOID
Adapter_CloseLink (
    IN PADAPTER pAdapter
    );

#endif // _ADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(_NT_SYMBOL_PATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\main.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////


//
//
#include <forward.h>
#include <memory.h>
#include <ndis.h>
#include <link.h>
#include <ipsink.h>

#include "Main.h"
#include "NdisApi.h"

/////////////////////////////////////////////////////////////////////////////
//
// Highest accepatble memory address
//
NDIS_HANDLE global_ndishWrapper = NULL;



/////////////////////////////////////////////////////////////////////////////
//
// Default debug mode
//
ULONG TestDebugFlag = 0;
//ULONG TestDebugFlag = TEST_DBG_INFO | TEST_DBG_ERROR;

#ifdef  DBG

/////////////////////////////////////////////////////////////////////////////
// Debugging definitions
//


//
// Debug tracing defintions
//
#define TEST_LOG_SIZE 256
UCHAR TestLogBuffer[TEST_LOG_SIZE]={0};
UINT  TestLogLoc = 0;

/////////////////////////////////////////////////////////////////////////////
//
// Logging function in debug builds
//
extern VOID
TestLog (
    UCHAR c         // input character
    )
/////////////////////////////////////////////////////////////////////////////
{
    TestLogBuffer[TestLogLoc++] = c;

    TestLogBuffer[(TestLogLoc + 4) % TEST_LOG_SIZE] = '\0';

    if (TestLogLoc >= TEST_LOG_SIZE) {
        TestLogLoc = 0;
    }
}

#endif // DBG

//////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS    ntStatus     = STATUS_SUCCESS;


    #ifdef BREAK_ON_STARTUP
    _asm {int 3};
    #endif

    //
    // Register the NDIS binding
    //
    ntStatus = NdisDriverInitialize (pDriverObject, pszuRegistryPath, &global_ndishWrapper);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }




ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("Driver Entry complete, ntStatus: %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\main.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     test.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _TEST_H
#define _TEST_H


#if DBG

extern  ULONG TestDebugFlag;

#define TEST_DBG_NONE    0x00000000
#define TEST_DBG_TRACE   0x00000001

#define TEST_DBG_DETAIL  0x00001000
#define TEST_DBG_INFO    0x00002000
#define TEST_DBG_WARNING 0x00004000
#define TEST_DBG_ERROR   0x00008000

#ifdef DEBUG_EXTRAS
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
        __int64                 llTime = 0;             \
        ULONG                   ulTime = 0;                     \
        NdisGetCurrentSystemTime ((PLARGE_INTEGER)&llTime);     \
        ulTime = (ULONG) (llTime >> 2);         \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint ("%04X %08X %-10.10s %4d  ", ulTime & 0xffff, _Trace, &__FILE__[2], __LINE__); \
        DbgPrint _Msg;                          \
    }                                           \
}

#else
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint _Msg;                          \
    }                                           \
}
#endif  // DEBUG_EXTRAS

#define IF_TESTDEBUG(f) if (TestDebugFlag & (f))

#define TEST_DEBUG_LOUD               0x00010000  // debugging info
#define TEST_DEBUG_VERY_LOUD          0x00020000  // excessive debugging info
#define TEST_DEBUG_LOG                0x00040000  // enable Log
#define TEST_DEBUG_CHECK_DUP_SENDS    0x00080000  // check for duplicate sends
#define TEST_DEBUG_TRACK_PACKET_LENS  0x00100000  // track directed packet lens
#define TEST_DEBUG_WORKAROUND1        0x00200000  // drop DFR/DIS packets
#define TEST_DEBUG_CARD_BAD           0x00400000  // dump data if CARD_BAD
#define TEST_DEBUG_CARD_TESTS         0x00800000  // print reason for failing


//
// Macro for deciding whether to print a lot of debugging information.
//
#define IF_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_VERY_LOUD ) { A }


//
// Whether to use the Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_TESTDEBUG( TEST_DEBUG_LOG ) { A }
extern VOID TESTLog(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_TESTDEBUG( TEST_DEBUG_CARD_TESTS ) { A }

#else

//extern  ULONG TestDebugFlag;


#define TEST_NONE
#define TEST_FUNCTIONS
#define TEST_COMMANDS
#define TEST_CONNECTIONS
#define TEST_SCIDS
#define TEST_LIST_ALLOCS
#define TEST_POOL
#define TEST_INDICATES
#define TEST_ALLOCATION


#define TEST_DEBUG(_Trace, _Msg)

#define IF_TESTDEBUG(f)

#define TEST_DEBUG_LOUD
#define TEST_DEBUG_VERY_LOUD
#define TEST_DEBUG_LOG
#define TEST_DEBUG_CHECK_DUP_SENDS
#define TEST_DEBUG_TRACK_PACKET_LENS
#define TEST_DEBUG_WORKAROUND1
#define TEST_DEBUG_CARD_BAD
#define TEST_DEBUG_CARD_TESTS


//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif // DBG


extern PDRIVER_OBJECT  pGlobalDriverObject;
extern PADAPTER        global_pAdapter;


////////////////////////////////////////////////////////////////
//
// This structure contains information about the driver
// itself.  There is only have one of these structures.
//
typedef struct _DRIVER_BLOCK
{

    //
    // NDIS wrapper information.
    //
    PVOID         NdisMacHandle;      // returned from NdisRegisterMac
    PVOID         ndishWrapper;       // returned from NdisInitializeWrapper

} DRIVER_BLOCK, * PDRIVER_BLOCK;


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath);


NTSTATUS
NdisDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath,
    IN PVOID            *pNdishWrapper
    );


#endif // _TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\device.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DWORD
#define DWORD ULONG
#endif

#include <forward.h>
#include <wdm.h>
#include <link.h>
#include <ipsink.h>

#include "device.h"
#include "main.h"


VOID
vUnload(IN PDRIVER_OBJECT pDriverObject);

//////////////////////////////////////////////////////////////////////////////
//
//
NTSTATUS
RegisterDevice(
        IN      PVOID              NdisWrapperHandle,
        IN      UNICODE_STRING     *DeviceName,
        IN      UNICODE_STRING     *SymbolicName,
        IN      PDRIVER_DISPATCH   MajorFunctions[],
        OUT     PDEVICE_OBJECT    *pDeviceObject,
        OUT     PVOID             *NdisDeviceHandle
        );


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntDispatchOpenClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status           = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp = NULL;

    //
    // Make sure status information is consistent every time.
    //
    IoMarkIrpPending (pIrp);
    pIrp->IoStatus.Status      = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //
    pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //

    switch (pIrpSp->MajorFunction)
    {

    //
    // The Create function opens a transport object (either address or
    // connection).  Access checking is performed on the specified
    // address to ensure security of transport-layer addresses.
    //
        case IRP_MJ_CREATE:
            status = STATUS_SUCCESS;
            break;


        case IRP_MJ_CLEANUP:
            status = STATUS_SUCCESS;
            break;


        case IRP_MJ_CLOSE:
            status = STATUS_SUCCESS;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;

    }


    if (status != STATUS_PENDING)
    {
        pIrpSp->Control &= ~SL_PENDING_RETURNED;
        pIrp->IoStatus.Status = status;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
    }

   return status;
}




//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntDispatchInternal (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus         = STATUS_SUCCESS;
    PIO_STACK_LOCATION pIrpSp = NULL;

    ULONG ulIoctl        = 0L;
    ULONG ulInputLen     = 0L;
    ULONG ulOutputLen    = 0L;
    PVOID pvInputBuffer  = NULL;
    PVOID pvOutputBuffer = NULL;

    PIPSINK_NDIS_COMMAND pCmd = NULL;


    //
    // Make sure status information is consistent every time.
    //
    IoMarkIrpPending (pIrp);
    pIrp->IoStatus.Status      = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //
    pIrpSp = IoGetCurrentIrpStackLocation (pIrp);

    ulIoctl     = pIrpSp->Parameters.DeviceIoControl.IoControlCode;
    ulInputLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    ulOutputLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    pvInputBuffer = pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //
    switch (pIrpSp->MajorFunction)
    {

        case IRP_MJ_CREATE:
            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal called, IRP_MJ_CREATE\n"));
            TEST_DEBUG (TEST_DBG_TRACE, ("    FileObject: %08X\n", pIrpSp->FileObject));
            ntStatus = STATUS_SUCCESS;
            break;


        case IRP_MJ_CLEANUP:
            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal called, IRP_MJ_CLEANUP\n"));
            ntStatus = STATUS_SUCCESS;
            break;


        case IRP_MJ_CLOSE:
            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal called, IRP_MJ_CLOSE\n"));
            ntStatus = STATUS_SUCCESS;
            break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal called, IRP_MJ_INTERNAL_DEVICE_CONTROL\n"));

            switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
            {
                case IOCTL_GET_INTERFACE:
                    TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal control code: IOCTL_GET_NDIS_INTERFACE\n"));

                    pCmd = (PIPSINK_NDIS_COMMAND) pvInputBuffer;

                    switch (pCmd->ulCommandID)
                    {
                        case CMD_QUERY_INTERFACE:
                            TEST_DEBUG (TEST_DBG_TRACE, ("ntDispatchInternal control code: QueryInterface Command\n"));

                            //
                            // Define paramters we're returning to the streaming component
                            //
                            pCmd->Parameter.Query.pNdisAdapter = (PVOID) global_pAdapter;

                            //
                            // Save a pointer to the Streaming components vtable
                            //
                            global_pAdapter->pFilter = (PIPSINK_FILTER) pCmd->Parameter.Query.pStreamAdapter;

                            //
                            // Increment the reference count for the filter
                            //
                            global_pAdapter->pFilter->lpVTable->AddRef (global_pAdapter->pFilter);


                            ntStatus = STATUS_SUCCESS;
                            break;

                        default:
                            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                            break;
                    }
                    break;


                default:
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                    break;
            }
            break;

        default:
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;

    }

//ret:

    if (ntStatus != STATUS_PENDING)
    {
        pIrpSp->Control &= ~SL_PENDING_RETURNED;
        pIrp->IoStatus.Status = ntStatus;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
    }

   return ntStatus;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntInitializeDeviceObject(
    IN PVOID            nhWrapperHandle,
    IN PADAPTER         pAdapter,
    OUT PDEVICE_OBJECT *pndisDriverObject,
    OUT PVOID          *pndisDeviceHandle
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status                                             = 0l;
    PDEVICE_OBJECT   pDeviceObject                              = NULL;
    PVOID            ndisDeviceHandle                           = NULL;
    UNICODE_STRING   DeviceName;
    UNICODE_STRING   SymbolicName;
    PDRIVER_DISPATCH pDispatchTable[IRP_MJ_MAXIMUM_FUNCTION]    = {NULL};

    //
    // Set the dispatch entries we are interested in.
    //
    pDispatchTable[IRP_MJ_CREATE]                  = ntDispatchOpenClose;
    pDispatchTable[IRP_MJ_CLOSE]                   = ntDispatchOpenClose;
    pDispatchTable[IRP_MJ_CLEANUP]                 = ntDispatchOpenClose;
    pDispatchTable[IRP_MJ_INTERNAL_DEVICE_CONTROL] = ntDispatchInternal;
    //pDispatchTable[IRP_MJ_DEVICE_CONTROL]          = NULL;

    //
    // Initialize the device, dosdevice and symbolic names.
    //
    RtlInitUnicodeString(&DeviceName, BDA_NDIS_MINIPORT);
    RtlInitUnicodeString(&SymbolicName, BDA_NDIS_SYMBOLIC_NAME);

    status = RegisterDevice (nhWrapperHandle,
                             &DeviceName,
                             &SymbolicName,
                             pDispatchTable,
                             &pDeviceObject,
                             &ndisDeviceHandle);

    if (status == STATUS_SUCCESS)
    {
        *pndisDeviceHandle = ndisDeviceHandle;
        *pndisDriverObject = pDeviceObject;
    }

    return status;
}


#ifdef WIN9X


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntCreateDeviceContext(
    IN PDRIVER_OBJECT pDriverObject
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT  pDeviceObject;
    UNICODE_STRING  DeviceName;
    UNICODE_STRING  dosdeviceName;
    UNICODE_STRING  symbolicName;

    //
    // Create the device object for the sample transport, allowing
    // room at the end for the device name to be stored (for use
    // in logging errors).
    //

    RtlInitUnicodeString(&DeviceName, BDA_NDIS_MINIPORT);
    ntStatus = IoCreateDevice(
                 pDriverObject,
                 0,
                 &DeviceName,
                 0x00000022,  // FILE_DEVICE_UNKNOWN
                 0,
                 FALSE,
                 &pDeviceObject);

    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

    //
    // Set device flag(s).
    //

    pDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // Create Symbolic Link
    //
    RtlInitUnicodeString(&dosdeviceName, BDA_NDIS_MINIPORT);
    RtlInitUnicodeString(&symbolicName,  BDA_NDIS_SYMBOLIC_NAME);

    ntStatus = IoCreateSymbolicLink(
                &symbolicName,
                &dosdeviceName );

    if (ntStatus != STATUS_SUCCESS)
    {
        ASSERT (FALSE);
    }

    pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

ret:

    return ntStatus;
}



//////////////////////////////////////////////////////////////////////////////
NTSTATUS
ntInitializeDriverObject(
    PDRIVER_OBJECT *ppDriverObject
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = 0l;
    UNICODE_STRING  objectName;
    PDRIVER_OBJECT  pDriverObject = *ppDriverObject;

    //
    // In case we did not create this driver object, set our global variable
    // equal to the one supplied.
    //
    pGlobalDriverObject = pDriverObject;
    *ppDriverObject = pDriverObject;

    //
    // Create a device object and symbolic name.
    //
    ntStatus = ntCreateDeviceContext(pDriverObject);
    if(ntStatus)
    {
        goto ret;
    }

ret:

    return ntStatus;
}

//////////////////////////////////////////////////////////////////////////////
VOID
vSetDriverDispatchTable(
    PDRIVER_OBJECT pDriverObject
    )
//////////////////////////////////////////////////////////////////////////////
{

    //
    // Initialize the driver object with this driver's entry points.
    //

    pDriverObject->MajorFunction [IRP_MJ_CREATE] = ntDispatchOpenClose;
    pDriverObject->MajorFunction [IRP_MJ_CLOSE] = ntDispatchOpenClose;
    pDriverObject->MajorFunction [IRP_MJ_CLEANUP] = ntDispatchOpenClose;
    pDriverObject->MajorFunction [IRP_MJ_INTERNAL_DEVICE_CONTROL] = ntDispatchInternal;
    pDriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = NULL;
    pDriverObject->DriverUnload = vUnload;

}

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\frame.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      frame.h
//
// Abstract:
//
//      This file is the include file for frame objects
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
//
#define IPSINK_NDIS_MAX_BUFFERS                 64
#define MAX_IP_PACKET_SIZE                      4082
#define IPSINK_NDIS_BUFFER_SIZE                 4096


//////////////////////////////////////////////////////////
//
//
//
typedef enum
{
    FRAME_STATE_AVAILABLE  = 0x00000001,
    FRAME_STATE_INDICATED,
    MAX_FRAME_STATES

} FRAME_STATE;

//////////////////////////////////////////////////////////
//
//
//
typedef struct _MEDIA_SPECIFIC_INFORMATION_
{
    PFRAME pFrame;

} IPSINK_MEDIA_SPECIFIC_INFORMATION, *PIPSINK_MEDIA_SPECIFIC_INFORAMTION;

//////////////////////////////////////////////////////////
//
//
//
typedef struct _FRAME_
{
    LIST_ENTRY    leLinkage;
    ULONG         ulRefCount;
    ULONG         ulFrameSize;
    ULONG         ulState;
    ULONG         ulcbData;
    PFRAME_POOL   pFramePool;
    PVOID         pvMemory;
    PNDIS_BUFFER  pNdisBuffer;
    PFRAME_VTABLE lpVTable;
    IPSINK_MEDIA_SPECIFIC_INFORMATION MediaSpecificInformation;

};

//////////////////////////////////////////////////////////
//
//
//
typedef struct _FRAME_POOL_
{
    PADAPTER    pAdapter;
    ULONG       ulRefCount;
    ULONG       ulNumFrames;
    ULONG       ulFrameSize;
    ULONG       ulState;
    NDIS_HANDLE ndishBufferPool;
    NDIS_HANDLE ndishPacketPool;
    LIST_ENTRY  leAvailableQueue;
    LIST_ENTRY  leIndicateQueue;
    KSPIN_LOCK  SpinLock;
    PFRAME_POOL_VTABLE lpVTable;

};


///////////////////////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFramePool (
 PADAPTER pAdapter,
 PFRAME_POOL  *pFramePool,
 ULONG    ulNumFrames,
 ULONG    ulFrameSize,
 ULONG    ulcbMediaInformation
 );

NDIS_STATUS
FreeFramePool (
    PFRAME_POOL pFramePool
    );

NTSTATUS
FramePool_QueryInterface (
    PFRAME_POOL pFramePool
    );

ULONG
FramePool_AddRef (
    PFRAME_POOL pFramePool
    );

ULONG
FramePool_Release (
    PFRAME_POOL pFramePool
    );

PFRAME
GetFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue
    );

PFRAME
PutFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue,
    PFRAME pFrame
    );

///////////////////////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFrame (
    PFRAME *pFrame,
    ULONG  ulFrameSize,
    NDIS_HANDLE ndishBufferPool,
    PFRAME_POOL pFramePool
    );

NTSTATUS
Frame_QueryInterface (
    PFRAME pFrame
    );

ULONG
Frame_AddRef (
    PFRAME pFrame
    );

ULONG
Frame_Release (
    PFRAME pFrame
    );

NTSTATUS
IndicateFrame (
    IN  PFRAME    pFrame,
    IN  ULONG     ulcbData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\frame.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <forward.h>
#include <memory.h>
#include <ndis.h>
#include <link.h>
#include <ipsink.h>

#include "NdisApi.h"
#include "frame.h"
#include "mem.h"
#include "main.h"

//////////////////////////////////////////////////////////
//
//
const FRAME_POOL_VTABLE FramePoolVTable =
    {
    FramePool_QueryInterface,
    FramePool_AddRef,
    FramePool_Release,
    };



//////////////////////////////////////////////////////////
//
//
const FRAME_VTABLE FrameVTable =
    {
    Frame_QueryInterface,
    Frame_AddRef,
    Frame_Release,
    };



///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFramePool (
 PADAPTER pAdapter,
 PFRAME_POOL  *pFramePool,
 ULONG    ulNumFrames,
 ULONG    ulFrameSize,
 ULONG    ulcbMediaInformation
 )
///////////////////////////////////////////////////////////////////////////////////
{
    KIRQL Irql;
    NTSTATUS nsResult = STATUS_UNSUCCESSFUL;
    PFRAME_POOL  pF = NULL;
    PFRAME pFrame = NULL;
    ULONG uli = 0;


    nsResult = AllocateMemory (&pF, sizeof (FRAME_POOL));
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    KeInitializeSpinLock (&pF->SpinLock);

    pF->pAdapter    = pAdapter;
    pF->ulFrameSize = ulFrameSize;
    pF->ulNumFrames = ulNumFrames;
    pF->ulRefCount  = 1;
    pF->lpVTable    = (PFRAME_POOL_VTABLE) &FramePoolVTable;

    //
    //  Allocate the NDIS buffer pool.
    //
    NdisAllocateBufferPool( &nsResult,
                            &pF->ndishBufferPool,
                            pF->ulNumFrames
                          );
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    //
    //  Allocate the NDIS packet pool.
    //
    NdisAllocatePacketPool (&nsResult,
                            &pF->ndishPacketPool,
                            pF->ulNumFrames,
                            ulcbMediaInformation
                           );
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    InitializeListHead (&pF->leAvailableQueue);
    InitializeListHead (&pF->leIndicateQueue);

    //
    // Create the frames
    //
    for (uli = 0; uli < pF->ulNumFrames; uli++)
    {
        nsResult = CreateFrame (&pFrame, pF->ulFrameSize, pF->ndishBufferPool, pF);
        if (nsResult != STATUS_SUCCESS)
        {
            pF->lpVTable->Release (pF);
        }


        //
        // Save the frame on the available frame queue
        //
        TEST_DEBUG (TEST_DBG_TRACE, ("Putting Frame %08X on Available Queue", pFrame));
        PutFrame (pF, &pF->leAvailableQueue, pFrame);
    }


    *pFramePool = pF;

    return nsResult;
}



///////////////////////////////////////////////////////////////////////////////////
NDIS_STATUS
FreeFramePool (
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    PLIST_ENTRY ple = NULL;
    PFRAME pFrame   = NULL;
    KIRQL  Irql;
    ULONG  uli      = 0;
    NDIS_STATUS nsResult = NDIS_STATUS_SUCCESS;

    if (pFramePool == NULL)
    {
        nsResult = NDIS_STATUS_FAILURE;
        return nsResult;
    }

    //
    // If there are any indicated frames we return an error
    //
    KeAcquireSpinLock (&pFramePool->SpinLock, &Irql );
    if (! IsListEmpty (&pFramePool->leIndicateQueue))
    {
        nsResult = NDIS_STATUS_FAILURE;
        goto ret;
    }

    //
    // Go thru each frame in the available queue delete it
    //
    for (uli = 0; uli < pFramePool->ulNumFrames; uli++)
    {
        if (! IsListEmpty (&pFramePool->leAvailableQueue))
        {
            ple = RemoveHeadList (&pFramePool->leAvailableQueue);
            pFrame = CONTAINING_RECORD (ple, FRAME, leLinkage);

            if (pFrame->lpVTable->Release (pFrame) != 0)
            {
                InsertTailList (&pFramePool->leAvailableQueue, &pFrame->leLinkage);
            }
        }
    }

    if (pFramePool->ndishBufferPool)
    {
        NdisFreeBufferPool (pFramePool->ndishBufferPool);
    }

    if (pFramePool->ndishPacketPool)
    {
        NdisFreePacketPool (pFramePool->ndishPacketPool);
    }

    nsResult = NDIS_STATUS_SUCCESS;

ret:

    KeReleaseSpinLock (&pFramePool->SpinLock, Irql );

    if (nsResult == NDIS_STATUS_SUCCESS)
    {
        FreeMemory (pFramePool, sizeof (FRAME_POOL));
    }

    return nsResult;

}

///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
FramePool_QueryInterface (
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
FramePool_AddRef (
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFramePool)
    {
        pFramePool->ulRefCount += 1;
        return pFramePool->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
FramePool_Release (
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFramePool)
    {
        pFramePool->ulRefCount -= 1;
        ulRefCount = pFramePool->ulRefCount;

        if (pFramePool->ulRefCount == 0)
        {
            FreeFramePool (pFramePool);
            return ulRefCount;
        }
    }

    return ulRefCount;
}


///////////////////////////////////////////////////////////////////////////////////
PFRAME
GetFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue
    )
///////////////////////////////////////////////////////////////////////////////////
{
    PFRAME pFrame   = NULL;
    PLIST_ENTRY ple = NULL;
    KIRQL Irql;

    KeAcquireSpinLock (&pFramePool->SpinLock, &Irql );

    if (IsListEmpty (pQueue))
    {
        KeReleaseSpinLock (&pFramePool->SpinLock, Irql );
        return NULL;
    }


    ple = RemoveHeadList (pQueue);
    if (ple)
    {
        pFrame = CONTAINING_RECORD (ple, FRAME, leLinkage);

    }

    KeReleaseSpinLock (&pFramePool->SpinLock, Irql );

    return pFrame;

}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
IndicateFrame (
    IN  PFRAME    pFrame,
    IN  ULONG     ulcbData
    )
//////////////////////////////////////////////////////////////////////////////
{
    NDIS_STATUS  nsResult    = NDIS_STATUS_SUCCESS;
    PFRAME_POOL  pFramePool  = NULL;
    PNDIS_PACKET pNdisPacket = NULL;

    //
    //
    //
    pFramePool = pFrame->pFramePool;

    //
    //      Allocate and initialize an NDIS Packet.
    //
    NdisAllocatePacket (&nsResult, &pNdisPacket, pFramePool->ndishPacketPool);
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        pFramePool->pAdapter->stats.ulOID_GEN_RCV_NO_BUFFER += 1;
        goto ret;
    }


    NDIS_SET_PACKET_HEADER_SIZE (pNdisPacket, 14);
    NDIS_SET_PACKET_STATUS (pNdisPacket, NDIS_STATUS_SUCCESS);

    //
    //      Fill in the media specific info.
    //
    pFrame->MediaSpecificInformation.pFrame = pFrame;
    NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO (
             pNdisPacket,
             &pFrame->MediaSpecificInformation,
             sizeof (IPSINK_MEDIA_SPECIFIC_INFORMATION)
             );

    //
    //      Add the data to the packet.
    //
    NdisChainBufferAtBack (pNdisPacket, pFrame->pNdisBuffer);

    //
    //  Set the number of bytes we'll be indicating
    //
    NdisAdjustBufferLength (pFrame->pNdisBuffer, ulcbData);


    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: Indicating IP Packet, size: %d to Ndis\n", ulcbData));


    NdisMIndicateReceivePacket (pFramePool->pAdapter->ndishMiniport, &pNdisPacket, 1);

    pFramePool->pAdapter->stats.ulOID_GEN_RCV_OK += 1;
    pFramePool->pAdapter->stats.ulOID_GEN_MULTICAST_BYTES_RCV += ulcbData;
    pFramePool->pAdapter->stats.ulOID_GEN_MULTICAST_FRAMES_RCV += 1;


    nsResult = NDIS_GET_PACKET_STATUS( pNdisPacket);
    if (nsResult != NDIS_STATUS_PENDING)
    {
        //
        //      NDIS is through with the packet so we need to free it
        //      here.
        //
        NdisFreePacket (pNdisPacket);

        //
        // Release this frame since we're done using it
        //
        pFrame->lpVTable->Release (pFrame);

        //
        // Put Frame back on available queue.
        //
        if (nsResult != STATUS_SUCCESS)
        {
            TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: Frame %08X Rejected by NDIS...putting back on Available Queue\n", pFrame));
        }
        else
        {
            TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: Frame %08X successfully indicated\n", pFrame));
        }

        PutFrame (pFrame->pFramePool, &pFrame->pFramePool->leAvailableQueue, pFrame);
    }

ret:

    return NTStatusFromNdisStatus (nsResult);
}



///////////////////////////////////////////////////////////////////////////////////
PFRAME
PutFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue,
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    KIRQL Irql;
    PLIST_ENTRY ple = NULL;

    KeAcquireSpinLock (&pFramePool->SpinLock, &Irql );
    InsertTailList (pQueue, &pFrame->leLinkage);
    KeReleaseSpinLock (&pFramePool->SpinLock, Irql );

    return pFrame;

}



///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFrame (
    PFRAME *pFrame,
    ULONG  ulFrameSize,
    NDIS_HANDLE ndishBufferPool,
    PFRAME_POOL pFramePool
    )
///////////////////////////////////////////////////////////////////////////////////
{
    PFRAME pF;
    NDIS_STATUS nsResult;

    nsResult = AllocateMemory (&pF, sizeof (FRAME));
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    nsResult = AllocateMemory (&pF->pvMemory, ulFrameSize);
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }


    NdisAllocateBuffer (&nsResult,
                        &pF->pNdisBuffer,
                        ndishBufferPool,
                        pF->pvMemory,
                        ulFrameSize
                       );
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    pF->pFramePool       = pFramePool;
    pF->ulState          = 0;
    pF->ulFrameSize      = ulFrameSize;
    pF->ulRefCount       = 1;
    pF->lpVTable         = (PFRAME_VTABLE) &FrameVTable;

    *pFrame = pF;

    return nsResult;

}

///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
FreeFrame (
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS nsResult = STATUS_UNSUCCESSFUL;

    if (pFrame)
    {
        NdisFreeBuffer (pFrame->pNdisBuffer);
        FreeMemory (pFrame->pvMemory, pFrame->ulFrameSize);
        FreeMemory (pFrame, sizeof (FRAME));
        nsResult = STATUS_SUCCESS;
    }

    return nsResult;
}

///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Frame_QueryInterface (
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Frame_AddRef (
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFrame)
    {
        pFrame->ulRefCount += 1;
        return pFrame->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Frame_Release (
    PFRAME pFrame
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFrame)
    {
        pFrame->ulRefCount -= 1;
        ulRefCount = pFrame->ulRefCount;

        if (pFrame->ulRefCount == 0)
        {
            FreeFrame (pFrame);
            return ulRefCount;
        }
    }

    return ulRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\mem.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////


#include <memory.h>
#include <ndis.h>


NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);

//////////////////////////////////////////////////////////////////////////////
VOID
FreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pvToFree != NULL)
    {
        NdisFreeMemory(pvToFree, ulSize, 0);
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
AllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    PVOID pvBlock;
    NDIS_STATUS nsResult = NDIS_STATUS_SUCCESS;

    nsResult = NdisAllocateMemory (&pvBlock, ulcbSize, 0, HighestAcceptableMax);
    if (!pvBlock)
    {
        nsResult = NDIS_STATUS_RESOURCES;
    }

    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    NdisZeroMemory( pvBlock, ulcbSize);

    *ppvAllocated = pvBlock;

    return NDIS_STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
ULONG
MyStrLen (
    PUCHAR p
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG ul = 0;

    while (*p++) ul++;

    return ul;
}


//////////////////////////////////////////////////////////////////////////////
VOID
MyStrCat (
    PUCHAR pTarget,
    PUCHAR pSource
    )
//////////////////////////////////////////////////////////////////////////////
{
    PUCHAR p = pTarget + MyStrLen (pTarget);

    NdisMoveMemory (p, pSource, MyStrLen (pSource));

    return;
}

//////////////////////////////////////////////////////////////////////////////
PUCHAR
MyUlToA (
    ULONG  dwValue,
    PUCHAR pszStr,
    ULONG  dwRadix
    )
//////////////////////////////////////////////////////////////////////////////
{
    PUCHAR psz;
    char ch;

    for (psz = pszStr; dwValue != 0; dwValue/=dwRadix, psz++)
    {
        ch = (char)(dwValue%dwRadix);
        if (ch <= 9)
        {
            *psz = (char)(ch + '0');
        }
        else
        {
            *psz = (char)(ch - 10 + 'A');
        }
    }

    if (psz == pszStr)
    {
        pszStr[0] = '0';
        pszStr[1] = '\0';
    }
    else
    {
        PUCHAR psz2;

        *psz = '\0';
        for (psz2 = pszStr, psz--; psz2 < psz; psz2++, psz--)
        {
            ch = *psz2;
            *psz2 = *psz;
            *psz = ch;
        }
    }

    return pszStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\mem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _MEM_H_
#define _MEM_H_

VOID
FreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    );

NTSTATUS
AllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    );

ULONG
MyStrLen (
    PUCHAR p
    );

VOID
MyStrCat (
    PUCHAR pTarget,
    PUCHAR pSource
    );

      PUCHAR
MyUlToA (
    ULONG  dwValue,
    PUCHAR pszStr,
    ULONG  dwRadix
    );


#endif // _MEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\ndisapi.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     ipndis.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _NDIS_MAIN_H
#define _NDIS_MAIN_H


/////////////////////////////////////////////////////////////////////////////
//
//
extern NDIS_HANDLE global_ndishWrapper;


//////////////////////////////////////////////////////////
//
//
//
#define ETHERNET_LENGTH_OF_ADDRESS      6
#define ETHERNET_HEADER_SIZE            14
#define BDA_802_3_MAX_LOOKAHEAD         ((4 * 1024) - ETHERNET_HEADER_SIZE)
#define BDA_802_3_MAX_PACKET            (BDA_802_3_MAX_LOOKAHEAD + ETHERNET_HEADER_SIZE)
#define MAX_IP_PACKET_LEN               BDA_802_3_MAX_LOOKAHEAD
#define BDALM_MAX_MULTICAST_LIST_SIZE   256


//////////////////////////////////////////////////////////
//
//
//
typedef struct _INDICATE_CONTEXT_
{
    PADAPTER pAdapter;

} INDICATE_CONTEXT, *PINDICATE_CONTEXT;


//////////////////////////////////////////////////////////////////////////////\
//
//
//  Prototypes
//
//
NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );


VOID
NdisIPHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );


NDIS_STATUS
NdisIPInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE ConfigurationHandle
    );

NDIS_STATUS
NdisIPQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );

NDIS_STATUS
NdisIPReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext
    );


NDIS_STATUS
NdisIPSend(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet,
    IN UINT Flags
    );

NDIS_STATUS
NdisIPSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    );

NTSTATUS
StreamIndicateEvent (
        IN PVOID  pvEvent
        );


VOID
NdisIPReturnPacket(
    IN NDIS_HANDLE     ndishAdapterContext,
    IN PNDIS_PACKET    pNdisPacket
    );

PFRAME
GetFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue
    );

PFRAME
PutFrame (
    PFRAME_POOL pFramePool,
    PLIST_ENTRY pQueue,
    PFRAME pFrame
    );

NTSTATUS
IndicateCallbackHandler (
     IN NDIS_HANDLE ndishMiniport,
     IN PINDICATE_CONTEXT  pIndicateContext
     );

NTSTATUS
CreateAdapter (
    PADAPTER *ppAdapter,
    NDIS_HANDLE ndishWrapper,
    NDIS_HANDLE ndishAdapterContext
    );


//
// These are now obsolete. Use Deserialized driver model for optimal performance.
//
#ifndef NdisIMQueueMiniportCallback

EXPORT
NDIS_STATUS
NdisIMQueueMiniportCallback(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  W_MINIPORT_CALLBACK     CallbackRoutine,
    IN  PVOID                   CallbackContext
    );
#endif

#ifndef NdisIMSwitchToMiniport

EXPORT
BOOLEAN
NdisIMSwitchToMiniport(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    OUT PNDIS_HANDLE            SwitchHandle
    );

#endif

#ifndef NdisIMRevertBack

EXPORT
VOID
NdisIMRevertBack(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             SwitchHandle
    );

#endif


#endif // _NDIS_MAIN_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\ndis\ndisapi.c ===
////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <forward.h>
#include <memory.h>
#include <ndis.h>
#include <link.h>
#include <ipsink.h>

#include "device.h"
#include "main.h"
#include "NdisApi.h"
#include "frame.h"
#include "mem.h"
#include "adapter.h"

//////////////////////////////////////////////////////////
//
// Global vars
//
PDRIVER_OBJECT        pGlobalDriverObject                  = NULL;
extern ULONG          ulGlobalInstance;
extern UCHAR          achGlobalVendorDescription [];

//////////////////////////////////////////////////////////
//
// List of supported OID for this driver.
//
//
static UINT SupportedOids[] = {

    //
    //  Required General OIDs
    //
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_CAPABILITIES,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_TRANSPORT_HEADER_OFFSET,

    //
    //  Required General Statistics
    //
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,

    //
    //  Optional General Statistics
    //
    OID_GEN_DIRECTED_BYTES_XMIT,
    OID_GEN_DIRECTED_FRAMES_XMIT,
    OID_GEN_MULTICAST_BYTES_XMIT,
    OID_GEN_MULTICAST_FRAMES_XMIT,
    OID_GEN_BROADCAST_BYTES_XMIT,
    OID_GEN_BROADCAST_FRAMES_XMIT,
    OID_GEN_DIRECTED_BYTES_RCV,
    OID_GEN_DIRECTED_FRAMES_RCV,
    OID_GEN_MULTICAST_BYTES_RCV,
    OID_GEN_MULTICAST_FRAMES_RCV,
    OID_GEN_BROADCAST_BYTES_RCV,
    OID_GEN_BROADCAST_FRAMES_RCV,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,

    //
    //  Required 802.3 OIDs
    //
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_MAC_OPTIONS,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,


    };

//////////////////////////////////////////////////////////
//
//$BUGBUG - Fix Permanent Ethernet Address
//
//
UCHAR   rgchPermanentAddress[ETHERNET_ADDRESS_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

//$BUGBUG - Fix Ethernet Station Address
UCHAR   rgchStationAddress[ETHERNET_ADDRESS_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };


NTSTATUS
ntInitializeDriverObject(
    PDRIVER_OBJECT *ppDriverObject
    );

VOID
vSetDriverDispatchTable(
    PDRIVER_OBJECT pDriverObject
    );


VOID
vUnload(
    IN PDRIVER_OBJECT pDriverObject
    )
{
    return;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
NdisDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath,
    IN PNDIS_HANDLE      pNdishWrapper
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS        ntStatus = STATUS_SUCCESS;
    NDIS_STATUS     nsResult = NDIS_STATUS_SUCCESS;

    //
    // NDIS data
    //
    NDIS_MINIPORT_CHARACTERISTICS   ndisMiniChar = {0};
    NDIS_HANDLE                     ndishWrapper = {0};

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisDriverInitialize Called\n"));


    //
    // Initialize Driver Object.
    // NOTE: The value of pDriverObject may change.
    //

    #ifdef WIN9X

    ntStatus = ntInitializeDriverObject(&DriverObject);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

    #endif

    //////////////////////////////////////////////////////
    //
    // Initialize the NDIS wrapper.
    //
    NdisMInitializeWrapper (&ndishWrapper,
                            DriverObject,
                            RegistryPath,
                            NULL);

    //////////////////////////////////////////////////////
    //
    // Initialize the Miniport Dispatch Table
    //
    ndisMiniChar.MajorNdisVersion            = 4;
    ndisMiniChar.MinorNdisVersion            = 0;

#ifdef NDIS30
    ndisMiniChar.Flags                       = 0;
#endif // NDIS30

    ndisMiniChar.HaltHandler                 = NdisIPHalt;
    ndisMiniChar.InitializeHandler           = NdisIPInitialize;
    ndisMiniChar.QueryInformationHandler     = NdisIPQueryInformation;
    ndisMiniChar.ResetHandler                = NdisIPReset;
    ndisMiniChar.SendHandler                 = NdisIPSend;
    ndisMiniChar.SetInformationHandler       = NdisIPSetInformation;
    ndisMiniChar.ReturnPacketHandler         = NdisIPReturnPacket;

    //
    // Register the miniport driver
    //
    nsResult = NdisMRegisterMiniport (ndishWrapper, &ndisMiniChar, sizeof(ndisMiniChar));
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        ntStatus = STATUS_UNSUCCESSFUL;
        goto ret;
    }



    *pNdishWrapper = ndishWrapper;

    #ifdef WIN9X

    vSetDriverDispatchTable (DriverObject);

    #endif

ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisDriverInitialize Called, ntStatus = %08X\n", ntStatus));

    return ntStatus;
}


///////////////////////////////////////////////////////////////////////////////////
extern
NDIS_STATUS
NdisIPInitialize(
    OUT PNDIS_STATUS   pnsOpenResult,
    OUT PUINT          puiSelectedMedium,
    IN PNDIS_MEDIUM    pNdisMediumArray,
    IN UINT            ucNdispNdisMediumArrayEntries,
    IN NDIS_HANDLE     ndishAdapterContext,
    IN NDIS_HANDLE     ndishWrapperConfiguration
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NDIS_STATUS  nsResult            = NDIS_STATUS_SUCCESS;
    NDIS_HANDLE  ndishConfiguration  = NULL;
    PADAPTER     pAdapter            = NULL;
    UINT         uTemp               = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("NdisInitialize handler called\n"));

    //
    //  Search for the medium type (DSS) in the given array.
    //
    for ( uTemp = 0; uTemp < ucNdispNdisMediumArrayEntries; uTemp++)
    {
        if (pNdisMediumArray[uTemp] == NdisMedium802_3)
        {
            break;
        }
    }


    if (uTemp == ucNdispNdisMediumArrayEntries)
    {
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    *puiSelectedMedium = uTemp;


    nsResult = CreateAdapter (&pAdapter, global_ndishWrapper, ndishAdapterContext);
    if (nsResult != NDIS_STATUS_SUCCESS)
    {
        return nsResult;
    }

    //
    // Initialize the information used to do indicates with
    //
    Adapter_IndicateReset (pAdapter);



    TEST_DEBUG (TEST_DBG_TRACE, ("NdisInitialize Handler Completed, nsResult = %08x\n", nsResult));


    return nsResult;
}


//////////////////////////////////////////////////////////////////////////////
// Removes an adapter that was previously initialized.
//
extern
VOID
NdisIPHalt(
    IN NDIS_HANDLE ndishAdapter
    )

//////////////////////////////////////////////////////////////////////////////
{
    PADAPTER   pAdapter = (PADAPTER) ndishAdapter;

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPHalt Handler Called\n"));


    #ifndef WIN9X

    //
    // Deregister our device interface.  This should shut down the link to the
    // streaming component.
    //
    NdisMDeregisterDevice(pAdapter->ndisDeviceHandle);

    #endif

    //
    // Signal the Streaming component that we're halting.
    //
    if (pAdapter)
    {
        if (pAdapter->pFilter)
        {
            if (pAdapter->pFilter->lpVTable->IndicateStatus)
            {
                pAdapter->pFilter->lpVTable->IndicateStatus (pAdapter->pFilter, IPSINK_EVENT_SHUTDOWN);

                //
                // Release the filter reference
                //
                pAdapter->pFilter->lpVTable->Release (pAdapter->pFilter);

                //
                // Release the frame pool
                //
                pAdapter->pFramePool->lpVTable->Release (pAdapter->pFramePool);

            }
        }
    }

    //
    // Release the adapter
    //
    pAdapter->lpVTable->Release (pAdapter);

    return;

}

//////////////////////////////////////////////////////////////////////////////////////
// The TestReset request, instructs the Miniport to issue
// a hardware reset to the network adapter.  The driver also
// resets its software state.  See the description of NdisMReset
// for a detailed description of this request.
//
NDIS_STATUS
NdisIPReset(
    OUT PBOOLEAN    pfAddressingReset,
    IN NDIS_HANDLE  ndishAdapter
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NDIS_STATUS  nsResult      = NDIS_STATUS_SUCCESS;
    PADAPTER pAdapter = (PADAPTER) ndishAdapter;

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPRest Handler Called\n"));

    nsResult = NDIS_STATUS_NOT_RESETTABLE;

    return nsResult;
}

//////////////////////////////////////////////////////////////////////////////////////
NDIS_STATUS
NdisIPQueryInformation (
    NDIS_HANDLE ndishAdapter,
    NDIS_OID    ndisOid,
    PVOID       pvInformationBuffer,
    ULONG       dwcbInformationBuffer,
    PULONG      pdwBytesWritten,
    PULONG      pdwBytesNeeded
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NDIS_STATUS                 nsResult       = NDIS_STATUS_SUCCESS;
    PADAPTER                    pAdapter       = (PADAPTER) ndishAdapter;
    ULONG                       ulcbWritten    = 0;
    ULONG                       ulcbNeeded     = 0;

    //
    // These variables hold the result of queries on General OIDS.
    //
    NDIS_HARDWARE_STATUS    ndisHardwareStatus  = NdisHardwareStatusReady;
    NDIS_MEDIUM             ndisMedium          = NdisMedium802_3;
    ULONG                   dwGeneric           = 0;
    USHORT                  wGeneric            = 0;
    UINT                    ucbToMove           = 0;
    PUCHAR                  pbMoveSource        = NULL;


    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPQuery Handler Called, ndsOid: %08X\n", ndisOid));

    if (!pAdapter || !pdwBytesWritten || !pdwBytesNeeded)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPQuery Handler Complete, nsResult: NDIS_STATUS_INVALID_DATA,\n"));
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPQuery Handler pAdapter: %08X    pdwBytesWritten: %08X   pdwBytesNeeded: %08X\n",
                                     pAdapter, pdwBytesWritten, pdwBytesNeeded));
        return (NDIS_STATUS_INVALID_DATA);
    }

    //
    //  Process OID's
    //
    pbMoveSource = (PUCHAR) (&dwGeneric);
    ulcbWritten = sizeof(ULONG);

    switch (ndisOid)
    {


        case OID_GEN_MEDIA_CAPABILITIES:

            dwGeneric = NDIS_MEDIA_CAP_RECEIVE;
            break;


        case OID_GEN_MAC_OPTIONS:
            dwGeneric = (ULONG) (  NDIS_MAC_OPTION_TRANSFERS_NOT_PEND
                                 | NDIS_MAC_OPTION_RECEIVE_SERIALIZED
                                 | NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
                                 | NDIS_MAC_OPTION_NO_LOOPBACK);
            break;


        case OID_GEN_SUPPORTED_LIST:
            pbMoveSource = (PUCHAR) (SupportedOids);
            ulcbWritten = sizeof(SupportedOids);
            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
            pbMoveSource = (PUCHAR) (&ndisMedium);
            ulcbWritten = sizeof(NDIS_MEDIUM);
            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            dwGeneric = 1;
            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
            dwGeneric = (ULONG)(BDA_802_3_MAX_PACKET);
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            dwGeneric = (ULONG)(BDA_802_3_MAX_PACKET);
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;

        case OID_GEN_RECEIVE_BLOCK_SIZE:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            dwGeneric = BDA_802_3_MAX_LOOKAHEAD;
            break;


        case OID_GEN_CURRENT_PACKET_FILTER:
            dwGeneric = (ULONG) pAdapter->ulPacketFilter;
            break;


        case OID_GEN_XMIT_OK:
            dwGeneric = pAdapter->stats.ulOID_GEN_XMIT_OK;
            break;

        case OID_GEN_RCV_OK:
            dwGeneric = pAdapter->stats.ulOID_GEN_RCV_OK;
            break;

        case OID_GEN_XMIT_ERROR:
            dwGeneric = pAdapter->stats.ulOID_GEN_XMIT_ERROR;
            break;

        case OID_GEN_RCV_ERROR:
            dwGeneric = pAdapter->stats.ulOID_GEN_RCV_ERROR;
            break;

        case OID_GEN_RCV_NO_BUFFER:
            dwGeneric = pAdapter->stats.ulOID_GEN_RCV_NO_BUFFER;
            break;

        case OID_GEN_DIRECTED_BYTES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_DIRECTED_BYTES_XMIT;
            break;

        case OID_GEN_DIRECTED_FRAMES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_DIRECTED_FRAMES_XMIT;
            break;

        case OID_GEN_MULTICAST_BYTES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_MULTICAST_BYTES_XMIT;
            break;
    
        case OID_GEN_MULTICAST_FRAMES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_MULTICAST_FRAMES_XMIT;
            break;
    
        case OID_GEN_BROADCAST_BYTES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_BROADCAST_BYTES_XMIT;
            break;
    
        case OID_GEN_BROADCAST_FRAMES_XMIT:
            dwGeneric = pAdapter->stats.ulOID_GEN_BROADCAST_FRAMES_XMIT;
            break;

        case OID_GEN_DIRECTED_BYTES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_DIRECTED_BYTES_RCV;
            break;

        case OID_GEN_DIRECTED_FRAMES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_DIRECTED_FRAMES_RCV;
            break;

        case OID_GEN_MULTICAST_BYTES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_MULTICAST_BYTES_RCV;
            break;

        case OID_GEN_MULTICAST_FRAMES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_MULTICAST_FRAMES_RCV;
            break;

        case OID_GEN_BROADCAST_BYTES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_BROADCAST_BYTES_RCV;
            break;

        case OID_GEN_BROADCAST_FRAMES_RCV:
            dwGeneric = pAdapter->stats.ulOID_GEN_BROADCAST_FRAMES_RCV;
            break;

        case OID_GEN_RCV_CRC_ERROR:
            dwGeneric = pAdapter->stats.ulOID_GEN_RCV_CRC_ERROR;
            break;

        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
            dwGeneric = pAdapter->stats.ulOID_GEN_TRANSMIT_QUEUE_LENGTH;
            break;

        case OID_802_3_RCV_ERROR_ALIGNMENT:
            dwGeneric = 0;
            break;

        case OID_802_3_XMIT_ONE_COLLISION:
            dwGeneric = 0;
            break;

        case OID_802_3_XMIT_MORE_COLLISIONS:
            dwGeneric = 0;
            break;

        case OID_802_3_PERMANENT_ADDRESS:
            pbMoveSource = (PVOID)(rgchPermanentAddress);
            ulcbWritten = sizeof(rgchPermanentAddress);
            break;

        case OID_802_3_CURRENT_ADDRESS:
            pbMoveSource = (PVOID)(rgchStationAddress);
            ulcbWritten = sizeof(rgchStationAddress);
            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            dwGeneric = MULTICAST_LIST_SIZE;
            break;

        case OID_GEN_HARDWARE_STATUS:
            ndisHardwareStatus = NdisHardwareStatusReady;
            pbMoveSource = (PUCHAR)(&ndisHardwareStatus);
            ulcbWritten = sizeof(NDIS_HARDWARE_STATUS);
            break;

        case OID_GEN_LINK_SPEED:
            dwGeneric = (ULONG)(300000);
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            dwGeneric = BDA_802_3_MAX_PACKET * 20;
            break;

        case OID_GEN_DRIVER_VERSION:
            dwGeneric =  ((USHORT) 4 << 8) | 0;
            pbMoveSource = (PVOID)(&dwGeneric);
            ulcbWritten = sizeof(dwGeneric);
            break;

        case OID_GEN_VENDOR_ID:
            wGeneric = (USHORT) 0xDDDD;           // BOGUS ID
            pbMoveSource = (PVOID)(&wGeneric);
            ulcbWritten = sizeof(wGeneric);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            pbMoveSource = (PVOID) pAdapter->pVendorDescription;
            ulcbWritten = MyStrLen (pAdapter->pVendorDescription);
            break;

        case OID_GEN_VENDOR_DRIVER_VERSION:
            dwGeneric = 0x0401;
            pbMoveSource = (PVOID)(&dwGeneric);
            ulcbWritten  = sizeof(dwGeneric);
            break;

        case OID_GEN_MEDIA_CONNECT_STATUS:
            dwGeneric = NdisMediaStateConnected;
            break;

        case OID_802_3_MAC_OPTIONS:
            dwGeneric = 0;
            break;

        case OID_PNP_CAPABILITIES:
            dwGeneric = 0;
            break;

        case OID_802_3_MULTICAST_LIST:
            pbMoveSource = (PVOID)(pAdapter->multicastList[0]);
            ulcbWritten  =  pAdapter->ulcbMulticastListEntries;
            break;

        case OID_PNP_QUERY_POWER:

            nsResult = NDIS_STATUS_SUCCESS;
            ulcbWritten = 0;
            break;

        case OID_TCP_TASK_OFFLOAD:
        case OID_TCP_TASK_IPSEC_ADD_SA:
        case OID_TCP_TASK_IPSEC_DELETE_SA:
        case OID_TCP_SAN_SUPPORT:
    
        case OID_FFP_SUPPORT:
        case OID_FFP_FLUSH:
        case OID_FFP_CONTROL:
        case OID_FFP_PARAMS:
        case OID_FFP_DATA:
        case OID_FFP_DRIVER_STATS:
        case OID_FFP_ADAPTER_STATS:

        case OID_PNP_WAKE_UP_OK:
        case OID_PNP_WAKE_UP_ERROR:

            nsResult = NDIS_STATUS_NOT_SUPPORTED;
            break;

        default:
            //
            nsResult = NDIS_STATUS_INVALID_OID;
            break;

    }


    //
    // First take care of the case where the size of the output buffer is
    // zero, or the pointer to the buffer is NULL
    //
    if (nsResult == NDIS_STATUS_SUCCESS)
    {

        ulcbNeeded = ulcbWritten;

        if (ulcbWritten > dwcbInformationBuffer)
        {
            //
            //  There isn't enough room in InformationBuffer.
            //  Don't move any of the info.
            //
            ulcbWritten = 0;
            nsResult = NDIS_STATUS_INVALID_LENGTH;
        }
        else if (ulcbNeeded && (pvInformationBuffer == NULL))
        {
            ulcbWritten = 0;
            nsResult = NDIS_STATUS_INVALID_LENGTH;
        }
        else if (ulcbNeeded)
        {
            //
            //  Move the requested information into the info buffer.
            //
            NdisMoveMemory (pvInformationBuffer, pbMoveSource, ulcbWritten);
        }
    }

    if (nsResult == NDIS_STATUS_SUCCESS)
    {
        //
        // A status of success always indicates 0 bytes needed.
        //
        *pdwBytesWritten = ulcbWritten;
        *pdwBytesNeeded = 0;
    }
    else if (nsResult == NDIS_STATUS_INVALID_LENGTH)
    {
        //
        //  For us a failure status always indicates 0 bytes read.
        //
        *pdwBytesWritten = 0;
        *pdwBytesNeeded = ulcbNeeded;
    }

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPQuery Handler Complete, nsResult: %08X\n", nsResult));

    return nsResult;

}


////////////////////////////////////////////////////////////////////////
extern
NDIS_STATUS
NdisIPSetInformation (
    NDIS_HANDLE ndishAdapterContext,
    NDIS_OID ndisOid,
    PVOID pvInformationBuffer,
    ULONG dwcbInformationBuffer,
    PULONG pdwBytesRead,
    PULONG pdwBytesNeeded
    )
////////////////////////////////////////////////////////////////////////
{
    ULONG          ulcbNeeded   = 0;
    NDIS_STATUS    nsResult     = NDIS_STATUS_SUCCESS;
    PADAPTER       pAdapter = (PADAPTER) ndishAdapterContext;


    #ifdef PFP

    ASSERT (pAdapter != NULL);
    ASSERT (pvInformationBuffer != NULL);
    ASSERT (pdwBytesRead != NULL);
    ASSERT (pdwBytesNeeded != NULL);

    #endif

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPSetInfo Handler Called, ndsOid: %08X\n", ndisOid));

    if (!pAdapter || !pvInformationBuffer || !pdwBytesRead || !pdwBytesNeeded)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPSetInfo Handler returns Invalid data\n"));
        return (NDIS_STATUS_INVALID_DATA);
    }


    switch (ndisOid)
    {
        case OID_GEN_CURRENT_PACKET_FILTER:
            {
                pAdapter->ulPacketFilter = * ((PULONG) pvInformationBuffer);
                *pdwBytesRead = 4;
            }
            break;


        case OID_GEN_CURRENT_LOOKAHEAD:

            if (dwcbInformationBuffer != 4)
            {
                nsResult = NDIS_STATUS_INVALID_LENGTH;

                *pdwBytesRead = 0;

                break;
            }

            //
            // Current Lookahead is not set this way so just ignore the
            // data.
            //
            *pdwBytesRead = 4;
            break;



        case OID_802_3_MULTICAST_LIST:

            //  If our current multicast address buffer isn't big
            //  enough, then free it.
            //
            if (dwcbInformationBuffer > sizeof (pAdapter->multicastList))
            {
                nsResult = NDIS_STATUS_RESOURCES;
                break;
            }

            //  Copy the Multicast List.
            //
            RtlCopyMemory (pAdapter->multicastList,
                           pvInformationBuffer,
                           dwcbInformationBuffer
                         );

            pAdapter->ulcbMulticastListEntries = dwcbInformationBuffer;

            //
            // Now we send the multicast list to the stream component so
            // it can get passed on to the net provider filter
            //
            if (pAdapter)
            {
                if (pAdapter->pFilter)
                {
                    if (pAdapter->pFilter->lpVTable->SetMulticastList)
                    {
                        pAdapter->pFilter->lpVTable->SetMulticastList (
                             pAdapter->pFilter,
                             pAdapter->multicastList,
                             pAdapter->ulcbMulticastListEntries
                             );
                    }
                }
            }

            break;


        case OID_802_3_PERMANENT_ADDRESS:
            RtlCopyMemory (rgchPermanentAddress,
                           pvInformationBuffer,
                           dwcbInformationBuffer
                         );
            break;

        case OID_802_3_CURRENT_ADDRESS:
            RtlCopyMemory (rgchStationAddress,
                           pvInformationBuffer,
                           dwcbInformationBuffer
                         );
            break;


        case OID_PNP_SET_POWER:

            nsResult = NDIS_STATUS_SUCCESS;
            ulcbNeeded = 0;
            break;


        default:

            nsResult = NDIS_STATUS_INVALID_OID;

            *pdwBytesRead = 0;
            ulcbNeeded = 0;

            break;
    }

    if (nsResult == NDIS_STATUS_SUCCESS)
    {
        //
        // A status of success always indicates 0 bytes needed.
        //
        *pdwBytesRead = dwcbInformationBuffer;
        *pdwBytesNeeded = 0;

    }
    else
    {
        //
        //  A failure status always indicates 0 bytes read.
        //
        *pdwBytesRead = 0;
        *pdwBytesNeeded = ulcbNeeded;
    }


    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPSetInfo Handler Complete, nsResult: %08X\n", nsResult));

    return nsResult;

}



//////////////////////////////////////////////////////////////////////////////////////
VOID
NdisIPReturnPacket(
    IN NDIS_HANDLE     ndishAdapterContext,
    IN PNDIS_PACKET    pNdisPacket
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    PFRAME pFrame = NULL;
    ULONG ulMediaSpecificInfoSize;
    PIPSINK_MEDIA_SPECIFIC_INFORAMTION pMediaSpecificInfo;

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPReturnPacket Handler Called\n"));


    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO (pNdisPacket,&pMediaSpecificInfo,&ulMediaSpecificInfoSize);

    //
    // Make sure we free up any frames
    //
    if (pMediaSpecificInfo)
    {
        pFrame = (PFRAME) pMediaSpecificInfo->pFrame;
        ASSERT(pFrame);
    }

    //
    //      NDIS is through with the packet so we need to free it
    //      here.
    //
    NdisFreePacket (pNdisPacket);

    //
    // Put Frame back on available queue.
    //
    if (pFrame)
    {
        //
        // Release this frame since we're done using it
        //
        pFrame->lpVTable->Release (pFrame);

        //
        // Store the frame back on the available queue
        //
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPReturnPacket: Putting frame %08X back on Available Queue\n", pFrame));
        PutFrame (pFrame->pFramePool, &pFrame->pFramePool->leAvailableQueue, pFrame);
    }


    return;
}


//////////////////////////////////////////////////////////////////////////////
NDIS_STATUS
NdisIPSend(
    IN NDIS_HANDLE ndishAdapterContext,
    IN PNDIS_PACKET Packet,
    IN UINT Flags
    )
//////////////////////////////////////////////////////////////////////////////
{
    PADAPTER       pAdapter = (PADAPTER) ndishAdapterContext;

    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPSend Handler Called\n"));

    pAdapter->stats.ulOID_GEN_XMIT_ERROR += 1;

    return NDIS_STATUS_FAILURE;
}


//////////////////////////////////////////////////////////////////////////////
extern VOID
NdisIPShutdown(
    IN PVOID ShutdownContext
    )
//////////////////////////////////////////////////////////////////////////////
{
    TEST_DEBUG (TEST_DBG_TRACE, ("NdisIPShutdown Handler Called\n"));

    //BREAK(0x10);
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
RegisterDevice(
        IN      PVOID              NdisWrapperHandle,
        IN      UNICODE_STRING     *DeviceName,
        IN      UNICODE_STRING     *SymbolicName,
        IN      PDRIVER_DISPATCH   pDispatchTable[],
        OUT     PDEVICE_OBJECT    *pDeviceObject,
        OUT     PVOID             *NdisDeviceHandle
        )
//////////////////////////////////////////////////////////////////////////////
{

    NDIS_STATUS status;

    status = NdisMRegisterDevice ((NDIS_HANDLE) NdisWrapperHandle,
                                  DeviceName,
                                  SymbolicName,
                                  pDispatchTable,
                                  pDeviceObject,
                                  (NDIS_HANDLE *) NdisDeviceHandle);

    return (NTSTATUS) status;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamIndicateEvent (
        IN PVOID  pvEvent
        )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //ntStatus = StreamIPIndicateEvent (pvEvent);

    return ntStatus;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
IndicateCallbackHandler (
     IN NDIS_HANDLE  ndishMiniport,
     IN PINDICATE_CONTEXT  pIndicateContext
     )
//////////////////////////////////////////////////////////////////////////////
{
    PFRAME pFrame = NULL;
    PVOID pvData  = NULL;
    ULONG ulcbData = 0L;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PADAPTER pAdapter;


    pAdapter = pIndicateContext->pAdapter;

    //
    // Take the source data and stuff the data into a FRAME object
    //
    while ((pFrame = GetFrame (pAdapter->pFramePool, &pAdapter->pFramePool->leIndicateQueue)) != NULL)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: Getting Frame (%08X) from Indicate Queue\n", pFrame));
        //
        // Indicate the NDIS packet
        //
        ntStatus = IndicateFrame (pFrame, pFrame->ulcbData);
    }

    if (pFrame == NULL)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("NdisIP: No more frames on Indicate Queue\n", pFrame));
    }

    //
    // Free up the context area.  NOTE: this is alloc'ed in the indicate handler
    //
    FreeMemory (pIndicateContext, sizeof (INDICATE_CONTEXT));

    return ntStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(_NT_SYMBOL_PATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_


//////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PIPSINK_FILTER pFilter
    );

NTSTATUS
Filter_QueryInterface (
    PIPSINK_FILTER pFilter
    );

ULONG
Filter_AddRef (
    PIPSINK_FILTER pFilter
    );

ULONG
Filter_Release (
    PIPSINK_FILTER pFilter
    );

NTSTATUS
Filter_SetMulticastList (
                  IN PVOID pvContext,
    IN PVOID pvMulticastList,
    IN ULONG ulcbList
    );

NTSTATUS
Filter_IndicateStatus (
    IN PVOID pvContext,
    IN ULONG ulEvent
    );

NTSTATUS
Filter_ReturnFrame (
    IN PVOID pvContext,
    IN PVOID pvFrame
    );

#endif  // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\bdastream.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __BDASTRM_H__
#define __BDASTRM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_TABLE(IPSinkConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    ),

};

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_TABLE(StreamAllocatorProperties)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR
    (
        FALSE,
        TRUE
    )
};

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_SET_TABLE(IPSinkStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(IPSinkConnectionProperties),       // PropertiesCount
        IPSinkConnectionProperties,                     // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Stream,                             // Set
        SIZEOF_ARRAY(StreamAllocatorProperties),         // PropertiesCount
        StreamAllocatorProperties,                       // PropertyItems
        0,                                               // FastIoCount
        NULL                                             // FastIoTable
    ),

};

#define NUMBER_IPSINK_STREAM_PROPERTIES (SIZEOF_ARRAY(IPSinkStreamProperties))


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_TABLE(IPSinkDefaultProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_IPSINK_MULTICASTLIST,
        TRUE,
        sizeof (KSPROPERTY),
        0,
        FALSE,
        NULL,
        0,
        NULL,
        NULL,
        0,
     ),


    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION,
        TRUE,
        sizeof (KSPROPERTY),
        0,
        FALSE,
        NULL,
        0,
        NULL,
        NULL,
        0,
     ),


     DEFINE_KSPROPERTY_ITEM
     (
         KSPROPERTY_IPSINK_ADAPTER_ADDRESS,
         TRUE,                                   // GetSupported or Handler
         sizeof(KSPROPERTY),                     // MinProperty
         0,                                      // MinData
         TRUE,                                   // SetSupported or Handler
         NULL,                                   // Values
         0,                                      // RelationsCount
         NULL,                                   // Relations
         NULL,                                   // SupportHandler
         0,                                      // SerializedSize
     )
};



////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSPROPERTY_SET_TABLE(IPSinkCodecProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &IID_IBDA_IPSinkControl,                        // Set
        SIZEOF_ARRAY(IPSinkDefaultProperties),          // PropertiesCount
        IPSinkDefaultProperties,                        // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable

    ),

};

#define NUMBER_IPSINK_CODEC_PROPERTIES (SIZEOF_ARRAY(IPSinkCodecProperties))


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DEFINE_KSEVENT_TABLE(IPSinkDefaultEvents)
{
    DEFINE_KSEVENT_ITEM
    (
        KSEVENT_IPSINK_MULTICASTLIST,       // Event Id
        sizeof (KSEVENTDATA),               // Minimum size of event data
        0,                                  // size of extra data staorage
        NULL,                               // Add Handler
        NULL,                               // RemoveHandler
        NULL                                // SupportHandler
    ),
    DEFINE_KSEVENT_ITEM
    (
        KSEVENT_IPSINK_ADAPTER_DESCRIPTION, // Event Id
        sizeof (KSEVENTDATA),               // Minimum size of event data
        0,                                  // size of extra data staorage
        NULL,                               // Add Handler
        NULL,                               // RemoveHandler
        NULL                                // SupportHandler
    )
};


DEFINE_KSEVENT_SET_TABLE(IPSinkEvents)
{
    DEFINE_KSEVENT_SET
    (
        &IID_IBDA_IPSinkEvent,                          // Event GUID
        SIZEOF_ARRAY(IPSinkDefaultEvents),              // Event count
        IPSinkDefaultEvents                             // Event items
    ),
};

#define NUMBER_IPSINK_EVENTS (SIZEOF_ARRAY(IPSinkEvents))



//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

KS_DATAFORMAT_IPSINK_IP StreamFormatIPSinkIP =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    4096,               // sizeof an MPE section
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP }
};


KS_DATAFORMAT_IPSINK_IP StreamFormatNetControl =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    4093,               // sizeof an IP Packet
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP_CONTROL },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP_CONTROL },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};



//---------------------------------------------------------------------------
//  STREAM_Input Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream0Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatIPSinkIP,

    // Add more formats here for to mirror output formats for "passthrough" mode
    // The idea is that upstream capture drivers may have done some decoding already
    // or downstream drivers may wish to have the raw data without any decoding at all.
    // In that case all we need to do is copy the data(if there is a pending SRB) OR
    // forward the SRB to the downstream client.
};

#define NUM_STREAM_0_FORMATS (SIZEOF_ARRAY(Stream0Formats))


//---------------------------------------------------------------------------
//  STREAM_Output Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream1Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatNetControl,

    //
    // Add more formats here for whatever output formats are supported.
    //
};
#define NUM_STREAM_1_FORMATS (SIZEOF_ARRAY (Stream1Formats))

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO
{
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;

} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO Streams [] =
{
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                        // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                        // DataFlow
            TRUE,                                     // DataAccessible
            NUM_STREAM_0_FORMATS,                     // NumberOfFormatArrayEntries
            Stream0Formats,                           // StreamFormatsArray
            0,                                        // ClassReserved[0]
            0,                                        // ClassReserved[1]
            0,                                        // ClassReserved[2]
            0,                                        // ClassReserved[3]
            NUMBER_IPSINK_STREAM_PROPERTIES,          // Number of stream properties
            (PKSPROPERTY_SET) IPSinkStreamProperties, // Stream Property Array
            0,                                        // NumStreamEventArrayEntries
            0,                                        // StreamEventsArray
            NULL,                                     // Category
            (GUID*) &PINNAME_IPSINK,                  // Name
            0,                                        // MediumsCount
            NULL,                                     // Mediums
            FALSE,                                    // BridgeStream
            0, 0                                      // Reserved  
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,
            ReceiveCtrlPacket,
            {                                       // HW_CLOCK_OBJECT
                NULL,                               // .HWClockFunction
                0,                                  // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            //sizeof (KS_VBI_FRAME_INFO),           // StreamHeaderMediaSpecific
            0,
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            EventHandler,                           // HwEventRoutine
        },
    },

    //
    // Network Provider Control Interface Pin
    //
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_STREAM_1_FORMATS,                   // NumberOfFormatArrayEntries
            Stream1Formats,                         // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NUMBER_IPSINK_STREAM_PROPERTIES,          // Number of stream properties
            (PKSPROPERTY_SET) IPSinkStreamProperties, // Stream Property Array
            0,
            0,
            NULL,
            (GUID *)&PINNAME_BDA_NET_CONTROL,       // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
            FALSE,                                  // BridgeStream
            0, 0                                    // Reserved  
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,                 // HwReceiveDataPacket
            ReceiveCtrlPacket,                 // HwReceiveControlPacket
            {                                       // HW_CLOCK_OBJECT
                NULL,                                // .HWClockFunction
                0,                                   // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            //sizeof (KS_VBI_FRAME_INFO),             // StreamHeaderMediaSpecific
            0,
            0,                                      // StreamHeaderWorkspace
            FALSE,                                  // Allocator
            NULL,                                   // HwEventRoutine
        },
    }
};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Topology connections

KSTOPOLOGY_CONNECTION   rgConnections[] =
{
    {-1, 0, -1, 1}
};

// Categories define what the device does.

static GUID Categories[] =
{
    STATIC_KSCATEGORY_BDA_IP_SINK
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    (GUID*) NULL,
    1,
    rgConnections,
    NULL,
    0
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader =
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif // __BDASTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\filter.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      filter.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DWORD
#define DWORD ULONG
#endif

#include <forward.h>
#include <strmini.h>
#include <link.h>
#include <ipsink.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>

#include "Main.h"
#include "ipmedia.h"
#include "streamip.h"
#include "filter.h"


//////////////////////////////////////////////////////////////////////////////
//
//
//
const FILTER_VTABLE FilterVTable =
    {
    Filter_QueryInterface,
    Filter_AddRef,
    Filter_Release,
    Filter_SetMulticastList,
    Filter_IndicateStatus,
    Filter_ReturnFrame
    };


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PIPSINK_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Save off our Device/Driver Objectsx in our context area
    //
    pFilter->DeviceObject          = DeviceObject;
    pFilter->DriverObject          = DriverObject;
    pFilter->lpVTable              = (PFILTER_VTABLE) &FilterVTable;
    pFilter->bTerminateWaitForNdis = FALSE;
    pFilter->ulRefCount            = 1;

    return ntStatus;
}


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_QueryInterface (
    PIPSINK_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_AddRef (
    PIPSINK_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFilter)
    {
        pFilter->ulRefCount += 1;
        return pFilter->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_Release (
    PIPSINK_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFilter)
    {
        pFilter->ulRefCount -= 1;
        ulRefCount = pFilter->ulRefCount;

        if (pFilter->ulRefCount == 0)
        {
            // $$BUG  Free Filter here
            return ulRefCount;
        }
    }

    return ulRefCount;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_SetMulticastList (
    IN PVOID pvContext,
    IN PVOID pvMulticastList,
    IN ULONG ulcbList
    )
//////////////////////////////////////////////////////////////////////////////
{
    PKSEVENT_ENTRY pEventEntry = NULL;
    PIPSINK_FILTER pFilter = (PIPSINK_FILTER) pvContext;

    //
    // Save off the multicast locally then forward it to the net provider
    //
    pFilter->ulcbMulticastListEntries = ulcbList;

    RtlCopyMemory (pFilter->multicastList, pvMulticastList, ulcbList);

    //
    // Signal the event to anyone waiting for it
    //
    pEventEntry = StreamClassGetNextEvent(
                      pFilter,
                      NULL,
                      (GUID *) &IID_IBDA_IPSinkEvent,
                      KSEVENT_IPSINK_MULTICASTLIST, //0,
                      NULL
                      );

    if (pEventEntry)
    {
        StreamClassDeviceNotification (SignalDeviceEvent, pFilter, pEventEntry);
    }



    return STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_IndicateStatus (
    PVOID pvContext,
    IN ULONG ulEvent
    )
//////////////////////////////////////////////////////////////////////////////
{
    PIPSINK_FILTER pFilter = (PIPSINK_FILTER) pvContext;

    switch (ulEvent)
    {
        case IPSINK_EVENT_SHUTDOWN:

            //
            // The NDIS component is shutting down.
            //
            CloseLink (&pFilter->NdisLink);

            TEST_DEBUG (TEST_DBG_TRACE, ("Driver Link Severed\n"));

            //
            //  Deref the adapter object and set it to NULL
            //
            pFilter->pAdapter->lpVTable->Release (pFilter->pAdapter);
            pFilter->pAdapter = NULL;

            break;

        default:
            break;
    }

    return STATUS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_ReturnFrame (
    IN PVOID pvContext,
    IN PVOID pvFrame
    )
//////////////////////////////////////////////////////////////////////////////
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\ipmedia.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MEDIA_H__
#define __MEDIA_H__


#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#include <ksguid.h>
#endif


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define STATIC_IID_IBDA_IPSinkControl\
    0x3F4DC8E2L, 0x4050, 0x11D3, 0x8F, 0x4B, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("3F4DC8E2-4050-11d3-8F4B-00C04F7971E2", IID_IBDA_IPSinkControl);
#define IID_IBDA_IPSinkControl DEFINE_GUIDNAMED(IID_IBDA_IPSinkControl)

#define STATIC_IID_IBDA_IPSinkEvent\
    0x3F4DC8E3L, 0x4050, 0x11D3, 0x8F, 0x4B, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("3F4DC8E3-4050-11d3-8F4B-00C04F7971E2", IID_IBDA_IPSinkEvent);
#define IID_IBDA_IPSinkEvent DEFINE_GUIDNAMED(IID_IBDA_IPSinkEvent)

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define STATIC_IID_IBDA_BDANetInterface\
    0x9AA4A2CCL, 0x81E0, 0x4CFD, 0x80, 0x2F, 0x0F, 0x74, 0x52, 0x6D, 0x2B, 0xD3
DEFINE_GUIDSTRUCT("9AA4A2CC-81E0-4CFD-802F-0F74526D2BD3", IID_IBDA_BDANetInterface);
#define IID_IBDA_BDANetInterface  DEFINE_GUIDNAMED(IID_IBDA_BDANetInterface)

typedef enum
{
    KSPROPERTY_IPSINK_MULTICASTLIST,
    KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION,
    KSPROPERTY_IPSINK_ADAPTER_ADDRESS

} KSPROPERTY_IPSINK;

////////////////////////////////////////////////////////////////////////
//
//
//
typedef enum
{
    KSEVENT_IPSINK_MULTICASTLIST,
    KSEVENT_IPSINK_ADAPTER_DESCRIPTION,
    KSEVENT_IPSINK_SHUTDOWN

} KSEVENT_IPSINK;


/////////////////////////////////////////////////////////////
//
// PINNAME CATEGORY GUID
//
#define STATIC_PINNAME_IPSINK \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK);
#define PINNAME_IPSINK   DEFINE_GUIDNAMED(PINNAME_IPSINK)

#define STATIC_PINNAME_BDA_NET_CONTROL \
    0xfb61415dL, 0x434b, 0x4cef, 0xac, 0xf4, 0x88, 0x66, 0xde, 0xdb, 0xec, 0x68
DEFINE_GUIDSTRUCT("FB61415D-434B-4cef-ACF4-8866DEDBEC68", PINNAME_BDA_NET_CONTROL);
#define PINNAME_BDA_NET_CONTROL   DEFINE_GUIDNAMED(PINNAME_BDA_NET_CONTROL)


/////////////////////////////////////////////////////////////
//
// IPSnk Data Format structure
//
typedef struct tagKS_DATAFORMAT_IPSINK_IP
{
   KSDATAFORMAT                 DataFormat;

} KS_DATAFORMAT_IPSINK_IP, *PKS_DATAFORMAT_IPSINK_IP;




#endif // __MEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\link.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      ipstream.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DWORD
#define DWORD ULONG
#endif

#include <forward.h>
#include <strmini.h>
#include <link.h>
#include <ipsink.h>
#include "ipmedia.h"

#include "main.h"


//////////////////////////////////////////////////////////////////////////////
VOID
CloseLink (
    PLINK pLink
)
//////////////////////////////////////////////////////////////////////////////
{
    PDEVICE_OBJECT   pDeviceObject = NULL;
    PFILE_OBJECT     pFileObject = NULL;
    HANDLE           hFileHandle = 0;
    KIRQL            Irql;

    //  Validate the parameter
    //
    ASSERT( pLink);
    if (!pLink)
    {
        return;
    }

    //  Swap our new objects into the NdisLink.
    //
    KeAcquireSpinLock( &pLink->spinLock, &Irql);
    if (pLink->flags & LINK_ESTABLISHED)
    {
        pDeviceObject = pLink->pDeviceObject;
        pLink->pDeviceObject = NULL;

        pFileObject = pLink->pFileObject;
        pLink->pFileObject = NULL;

        pLink->flags &= ~LINK_ESTABLISHED;
    }
    KeReleaseSpinLock( &pLink->spinLock, Irql);

    //
    // DeReference the private interface handles.
    //

    if (pDeviceObject)
    {
        ObDereferenceObject(pDeviceObject);
        pDeviceObject = NULL;
    }

    if (pFileObject)
    {
        ObDereferenceObject(pFileObject);
        pFileObject = NULL;
    }

}


//////////////////////////////////////////////////////////////////////////////
PLINK
OpenLink (
    PLINK   pLink,
    UNICODE_STRING  DriverName
)
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PWSTR       pwstr = (PWSTR)NULL;
    UNICODE_STRING uni = {0};
    OBJECT_ATTRIBUTES objAttrib = {0};
    IO_STATUS_BLOCK IoStatusBlock = {0};

    PDEVICE_OBJECT   pDeviceObject = NULL;
    PFILE_OBJECT     pFileObject = NULL;
    HANDLE           hFileHandle = 0;
    KIRQL            Irql;
    
    if (pLink->flags & LINK_ESTABLISHED)
    {
        goto err;
    }


    //
    // Set the link_established flag.  This will be cleared if the call fails.
    //


#ifndef WIN9X

    //
    // Look up the interface for NDISIP. This gets the full path used by
    // swenum to find and open NdisIp.sys.
    //

    ntStatus = IoGetDeviceInterfaces( (GUID *) &IID_IBDA_BDANetInterface,
                                      NULL,
                                      0,
                                      &pwstr);

    if (ntStatus != STATUS_SUCCESS || pwstr == NULL)
    {
        goto err;
    }

    //
    // Initialize a Unicode string to the NDIS driver's Software Enum Path/Name.
    //

    RtlInitUnicodeString( &uni, pwstr);

    //
    // Open Ndisip.sys via swenum.
    //

    InitializeObjectAttributes( &objAttrib,
                                &uni,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    ntStatus = ZwCreateFile( &hFileHandle,
                             FILE_WRITE_DATA|FILE_READ_ATTRIBUTES,
                             &objAttrib,
                             &IoStatusBlock,
                             0,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_WRITE|FILE_SHARE_READ,
                             FILE_OPEN_IF,
                             0,
                             NULL,
                             0);


    if (ntStatus != STATUS_SUCCESS)
    {
        goto err;
    }
#endif

    //
    // Now get get handles to the Ndisip.sys/streamip.sys private
    // data interface.
    //

    ntStatus = IoGetDeviceObjectPointer (
                   &DriverName,
                   FILE_READ_ATTRIBUTES,
                   &pFileObject,
                   &pDeviceObject);

    if (ntStatus != STATUS_SUCCESS)
    {
        goto err;
    }

    ObReferenceObject(pDeviceObject);
    ObReferenceObject(pFileObject);


    //  Swap our new objects into the NdisLink.
    //
    KeAcquireSpinLock( &pLink->spinLock, &Irql);
    pLink->flags |= LINK_ESTABLISHED;

    //  Exchange our new device object reference for the one currently used.
    //
    {
        PDEVICE_OBJECT   pDeviceObjectT;
        
        pDeviceObjectT = pLink->pDeviceObject;
        pLink->pDeviceObject = pDeviceObject;
        pDeviceObject = pDeviceObjectT;
    }

    //  Exchange our new file object reference for the one currently used.
    //
    {
        PFILE_OBJECT     pFileObjectT;

        pFileObjectT = pLink->pFileObject;
        pLink->pFileObject = pFileObject;
        pFileObject = pFileObjectT;
    }
    KeReleaseSpinLock( &pLink->spinLock, Irql);


err:
    
//  Clean up temp string allocation.
    //
    if(pwstr)
    {
        ExFreePool(pwstr);
        pwstr = NULL;
    }
    
    // DeReference any leaked objects.
    //
    //  These objects are leaked only if two or more calls to
    //  OpenLink collide or if an open failed in this routine.
    //
    if (pDeviceObject)
    {
        ObDereferenceObject( pDeviceObject);
        pDeviceObject = NULL;
    }
    if (pFileObject)
    {
        ObDereferenceObject( pFileObject);
        pFileObject = NULL;
    }
    if(hFileHandle)
    {
        ZwClose( hFileHandle);
        hFileHandle = 0;
    }

    return (pLink->flags & LINK_ESTABLISHED) ? pLink : NULL;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
SendIOCTL (
    PLINK     pLink,
    ULONG     ulIoctl,
    PVOID     pData,
    ULONG     ulcbData
)
//////////////////////////////////////////////////////////////////////////////
{
    PIRP pIrp                      = NULL;
    NTSTATUS ntStatus              = STATUS_SUCCESS;
    IO_STATUS_BLOCK  IoStatusBlock = {0};

    //
    // Create a control request block
    //
    pIrp = IoBuildDeviceIoControlRequest(
                ulIoctl,
                pLink->pDeviceObject,
                pData,
                ulcbData,
                0,                            // Optional output buffer
                0,                            // Optional output buffer length
                TRUE,                         // InternalDeviceIoControl == TRUE
                NULL,                         // Optional Event
                &IoStatusBlock);

    if (pIrp != NULL)
    {
        PIO_STACK_LOCATION   pNextStackLocation;

        pNextStackLocation = IoGetNextIrpStackLocation(pIrp);
        if (pNextStackLocation)
        {
            pNextStackLocation->FileObject = pLink->pFileObject;
    
            IoStatusBlock.Status = STATUS_SUCCESS;
    
            //
            // Feed the NDIS mini-driver
            //
            
            ntStatus = IoCallDriver( pLink->pDeviceObject, pIrp);
    
            if (ntStatus  != STATUS_SUCCESS ||
                IoStatusBlock.Status != STATUS_SUCCESS)
            {
                ntStatus = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }


    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\main.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     test.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H
#define _MAIN_H


#ifdef DBG

extern  ULONG TestDebugFlag;

#define TEST_DBG_NONE    0x00000000
#define TEST_DBG_TRACE   0x00000001
#define TEST_DBG_GET     0x00000002
#define TEST_DBG_BUF     0x00000080

#define TEST_DBG_DETAIL  0x00001000
#define TEST_DBG_INFO    0x00002000
#define TEST_DBG_WARNING 0x00004000
#define TEST_DBG_ERROR   0x00008000

#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint _Msg;                          \
    }                                           \
}

#define IF_TESTDEBUG(f) if (TestDebugFlag & (f))

#define TEST_DEBUG_LOUD               0x00010000  // debugging info
#define TEST_DEBUG_VERY_LOUD          0x00020000  // excessive debugging info
#define TEST_DEBUG_LOG                0x00040000  // enable Log
#define TEST_DEBUG_CHECK_DUP_SENDS    0x00080000  // check for duplicate sends
#define TEST_DEBUG_TRACK_PACKET_LENS  0x00100000  // track directed packet lens
#define TEST_DEBUG_WORKAROUND1        0x00200000  // drop DFR/DIS packets
#define TEST_DEBUG_CARD_BAD           0x00400000  // dump data if CARD_BAD
#define TEST_DEBUG_CARD_TESTS         0x00800000  // print reason for failing


//
// Macro for deciding whether to print a lot of debugging information.
//
#define IF_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_VERY_LOUD ) { A }


//
// Whether to use the Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_TESTDEBUG( TEST_DEBUG_LOG ) { A }
extern VOID TESTLog(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_TESTDEBUG( TEST_DEBUG_CARD_TESTS ) { A }

#else

//extern  ULONG TestDebugFlag;

#define TEST_NONE
#define TEST_FUNCTIONS
#define TEST_COMMANDS
#define TEST_CONNECTIONS
#define TEST_SCIDS
#define TEST_LIST_ALLOCS
#define TEST_POOL
#define TEST_INDICATES
#define TEST_ALLOCATION


#define TEST_DEBUG(_Trace, _Msg)

#define IF_TESTDEBUG(f)

#define TEST_DEBUG_LOUD
#define TEST_DEBUG_VERY_LOUD
#define TEST_DEBUG_LOG
#define TEST_DEBUG_CHECK_DUP_SENDS
#define TEST_DEBUG_TRACK_PACKET_LENS
#define TEST_DEBUG_WORKAROUND1
#define TEST_DEBUG_CARD_BAD
#define TEST_DEBUG_CARD_TESTS


//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif // DBG


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath);


VOID
StreamIPFreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    );

NTSTATUS
StreamIPAllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    );


NTSTATUS
StreamDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    );

#endif // _MAIN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\main.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

//
//
#include <memory.h>
#include <ndis.h>

#include "Main.h"

NTSTATUS
CreateDeviceObject(
    IN PDRIVER_OBJECT pDriverObject
    );

/////////////////////////////////////////////////////////////////////////////
//
// Highest accepatble memory address
//
NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);



/////////////////////////////////////////////////////////////////////////////
//
// Default debug mode
//
// ULONG TestDebugFlag = TEST_DBG_INFO;
ULONG TestDebugFlag = 0;


#ifdef DBG

/////////////////////////////////////////////////////////////////////////////
// Debugging definitions
//


//
// Debug tracing defintions
//
#define TEST_LOG_SIZE 256
UCHAR TestLogBuffer[TEST_LOG_SIZE]={0};
UINT  TestLogLoc = 0;

/////////////////////////////////////////////////////////////////////////////
//
// Logging function in debug builds
//
extern VOID
TestLog (
    UCHAR c         // input character
    )
/////////////////////////////////////////////////////////////////////////////
{
    TestLogBuffer[TestLogLoc++] = c;

    TestLogBuffer[(TestLogLoc + 4) % TEST_LOG_SIZE] = '\0';

    if (TestLogLoc >= TEST_LOG_SIZE) {
        TestLogLoc = 0;
    }
}

#endif // DBG

//////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS                        ntStatus = STATUS_SUCCESS;

    //
    // Register the Stream Class binding
    //
    ntStatus = StreamDriverInitialize (pDriverObject,  pszuRegistryPath);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("Driver Entry complete, ntStatus: %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\makefile.inc ===
# HACK ALERT: This target is solely to keep nmake from whining that it doesn't
# know how to make the dependency in rules that depend on the target executable.
$(TARGETPATHEX)\$(TARGETNAME).sys:

# Build SoftICE symbols
$(TARGETPATHEX)\$(TARGETNAME).nms: $(TARGETPATHEX)\$(TARGETNAME).sys
    echo $(TARGETPATHEX)\$(TARGETNAME) > target.txt
    nmsym /translate:source,package,always /source:. /output:$(TARGETPATHEX)\$(TARGETNAME).nms $(TARGETPATHEX)\$(TARGETNAME).sys
    splitsym -s $(_NT_SYMBOL_PATH)  $(TARGETPATHEX)\$(TARGETNAME).sys

# Delete built files
clean:
    -echo $(TARGETPATHEX)\$(TARGETNAME).*
    -del /s *.obj
    -del /s *.res
    -del build.log
    -del build.err
    -del /s _objects.mac
    -del $(TARGETPATHEX)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\mymedia.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MEDIA_H__
#define __MEDIA_H__


#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#include <ksguid.h>
#endif


/////////////////////////////////////////////////////////////
//
// PINNAME CATEGORY GUID
//
#define STATIC_PINNAME_IPSINK \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK);
#define PINNAME_IPSINK   DEFINE_GUIDNAMED(PINNAME_IPSINK)


/////////////////////////////////////////////////////////////
//
// IPSnk Data Format structure
//
typedef struct tagKS_DATAFORMAT_IPSINK_IP
{
   KSDATAFORMAT                 DataFormat;

} KS_DATAFORMAT_IPSINK_IP, *PKS_DATAFORMAT_IPSINK_IP;




#endif // __MEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\streamip.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __STREAMIP_H__
#define __STREAMIP_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

/**************************************************************/
/* Driver Name - Change this to reflect your executable name! */
/**************************************************************/

#define STREAMIPNAME            "STREAMIP"
#define STREAMIPNAMEUNICODE    L"STREAMIP"

// This defines the name of the WMI device that manages service IOCTLS
#define CodecDeviceName (L"\\\\.\\" STREAMIPNAMEUNICODE)
#define CodecSymbolicName (L"\\DosDevices\\" STREAMIPNAMEUNICODE)


// ------------------------------------------------------------------------
// The master list of all streams supported by this driver
// ------------------------------------------------------------------------

typedef enum
{
    STREAM_IP,
    STREAM_NET_CONTROL
};


// The MAX_STREAM_COUNT value must be equal to DRIVER_STREAM_COUNT
// This particular value must be defined here to avoid circular references
#define MAX_STREAM_COUNT    1

// We manage multiple instances of each pin up to this limit
#define MAX_PIN_INSTANCES   8

#define BIT(n)              (1L<<(n))
#define BITSIZE(v)          (sizeof(v)*8)
#define SETBIT(array,n)     (array[n/BITSIZE(*array)] |= BIT(n%BITSIZE(*array)))
#define CLEARBIT(array,n)   (array[n/BITSIZE(*array)] &= ~BIT(n%BITSIZE(*array)))

/*****************************************************************************
*
* The following structures are samples of information that could be used in
* a device extension structure
*
*****************************************************************************/

//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAM_
{
    PIPSINK_FILTER                      pFilter;
    PHW_STREAM_OBJECT                   pStreamObject;      // For timer use
    KSSTATE                             KSState;            // Run, Stop, Pause
    REFERENCE_TIME                      FrameTime100ns;     // elapsed time based on frames captured
    HANDLE                              hMasterClock;
    HANDLE                              hClock;
    ULONG                               ulStreamInstance;   // 0..NumberOfPossibleInstances-1
    KSDATAFORMAT                        OpenedFormat;       // Based on the actual open request.

    KSDATARANGE                         MatchedFormat;

    KSPIN_LOCK                          StreamControlSpinLock;  // Command queue spin lock
    KSPIN_LOCK                          StreamDataSpinLock;     // Data queue spin lock
    LIST_ENTRY                          StreamDataQueue;        // Stream data queue
    LIST_ENTRY                          StreamControlQueue;     // Stream command queue

} STREAM, *PSTREAM;

//
// This structure is our per SRB extension, and carries the forward and backward
// links for the pending SRB queue.
//
typedef struct _SRB_EXTENSION
{
    LIST_ENTRY                      ListEntry;
    PHW_STREAM_REQUEST_BLOCK        pSrb;

} SRB_EXTENSION, *PSRB_EXTENSION;


/*****************************************************************************
*
* the following section defines prototypes for the minidriver initialization
* routines
*
******************************************************************************/

//
// This routine is called by the stream class driver with configuration
// information for an adapter that the mini driver should load on.  The mini
// driver should still perform a small verification to determine that the
// adapter is present at the specified addresses, but should not attempt to
// find an adapter as it would have with previous NT miniports.
//
// All initialization of the codec should also be performed at this time.
//

BOOLEAN CodecInitialize (IN OUT PHW_STREAM_REQUEST_BLOCK pSrb);


//
// This routine is called when the system is going to remove or disable the
// device.
//
// The mini-driver should free any system resources that it allocated at this
// time.  Note that system resources allocated for the mini-driver by the
// stream class driver will be free'd by the stream driver, and should not be
// free'd in this routine.  (Such as the HW_DEVICE_EXTENSION)
//

BOOLEAN CodecUnInitialize( PHW_STREAM_REQUEST_BLOCK pSrb);


BOOLEAN CodecQueryUnload ( PHW_STREAM_REQUEST_BLOCK pSrb);      // Not implemented currently


//
// This is the prototype for the Hardware Interrupt Handler.  This routine
// will be called if the minidriver registers for and receives an interrupt
//

BOOLEAN HwInterrupt (IN PIPSINK_FILTER pFilter);

//
// This is the prototype for the stream enumeration function.  This routine
// provides the stream class driver with the information on data stream types
// supported
//

VOID CodecStreamInfo(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream open function
//

VOID CodecOpenStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the stream close function
//

VOID CodecCloseStream(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// This is the prototype for the CodecReceivePacket routine.  This is the
// entry point for command packets that are sent to the codec (not to a
// specific open stream)
//

VOID STREAMAPI CodecReceivePacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the protoype for the cancel packet routine.  This routine enables
// the stream class driver to cancel an outstanding packet.
//

VOID STREAMAPI CodecCancelPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

//
// This is the packet timeout function.  The codec may choose to ignore a
// packet timeout, or reset the codec and cancel the requests, as required.
//

VOID STREAMAPI CodecTimeoutPacket(IN PHW_STREAM_REQUEST_BLOCK Srb);

VOID STREAMAPI CodecGetProperty(IN PHW_STREAM_REQUEST_BLOCK Srb);
VOID STREAMAPI CodecSetProperty(IN PHW_STREAM_REQUEST_BLOCK Srb);

BOOL
CodecVerifyFormat(IN KSDATAFORMAT *pKSDataFormat,
                  UINT StreamNumber,
                  PKSDATARANGE pMatchedFormat);

BOOL
CodecFormatFromRange(
        IN PHW_STREAM_REQUEST_BLOCK pSrb);

void
CompleteStreamSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb,
         STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType1,
         BOOL fUseNotification2,
         STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType2
        );
void
CompleteDeviceSRB (
         IN PHW_STREAM_REQUEST_BLOCK pSrb,
         IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
         BOOL fReadyForNext
        );

//
// prototypes for data handling routines
//
void            CompleteStreamIRP (IN PHW_STREAM_REQUEST_BLOCK pSrb, BOOLEAN ReadyForNext);

VOID STREAMAPI VideoReceiveDataPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
VOID STREAMAPI VideoReceiveCtrlPacket(IN PHW_STREAM_REQUEST_BLOCK pSrb);
void           EnableIRQ(PHW_STREAM_OBJECT pstrm);
void           DisableIRQ(PHW_STREAM_OBJECT pstrm);

//
// prototypes for properties and states
//
VOID            VideoSetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoGetState(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoSetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoGetProperty(PHW_STREAM_REQUEST_BLOCK pSrb);
//VOID          VideoStreamSetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb); // Not implemented
VOID            VideoStreamGetConnectionProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoStreamSetVBIFilteringProperty (PHW_STREAM_REQUEST_BLOCK pSrb);
VOID            VideoStreamGetVBIFilteringProperty (PHW_STREAM_REQUEST_BLOCK pSrb);

//
// system time functions
//

ULONGLONG       VideoGetSystemTime();

//
// stream clock functions
//
VOID            VideoIndicateMasterClock(PHW_STREAM_REQUEST_BLOCK pSrb);

//
// SRB Queue Management functions
//
BOOL STREAMAPI QueueAddIfNotEmpty(
                                                        IN PHW_STREAM_REQUEST_BLOCK,
                                                        IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueAdd(
                                                        IN PHW_STREAM_REQUEST_BLOCK,
                                                        IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueRemove(
                                                        IN OUT PHW_STREAM_REQUEST_BLOCK *,
                                                        IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueRemoveSpecific(
                                                        IN PHW_STREAM_REQUEST_BLOCK,
                           IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
BOOL STREAMAPI QueueEmpty(
                           IN PKSPIN_LOCK,
                           IN PLIST_ENTRY
                           );
#ifdef    __cplusplus
}
#endif // __cplusplus


VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
LinkToNdisHandler (
    PVOID pvContext
    );


BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    );

BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

NTSTATUS
STREAMAPI
EventHandler (
    IN PHW_EVENT_DESCRIPTOR pEventDesriptor
    );

VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
IpSinkSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

#endif // _STREAM_IP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_


//////////////////////////////////////////////////////////////////
//
//
//
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PMPE_FILTER   pFilter
    );

NTSTATUS
Filter_QueryInterface (
    PMPE_FILTER pFilter
    );

ULONG
Filter_AddRef (
    PMPE_FILTER pFilter
    );

ULONG
Filter_Release (
    PMPE_FILTER pFilter
    );

#endif  // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\main.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      test.c
//
// Abstract:
//
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

//
//
#include <wdm.h>
#include <memory.h>
#include "Main.h"

/////////////////////////////////////////////////////////////////////////////
//
// Default debug mode
//
ULONG TestDebugFlag = TEST_DBG_NONE;

#if DBG

/////////////////////////////////////////////////////////////////////////////
// Debugging definitions
//


//
// Debug tracing defintions
//
#define TEST_LOG_SIZE 256
UCHAR TestLogBuffer[TEST_LOG_SIZE]={0};
ULONG TestLogLoc = 0;

/////////////////////////////////////////////////////////////////////////////
//
// Logging function in debug builds
//
extern VOID
TestLog (
    UCHAR c         // input character
    )
/////////////////////////////////////////////////////////////////////////////
{
    TestLogBuffer[TestLogLoc++] = c;

    TestLogBuffer[(TestLogLoc + 4) % TEST_LOG_SIZE] = '\0';

    if (TestLogLoc >= TEST_LOG_SIZE) {
        TestLogLoc = 0;
    }
}

#endif // DBG

//////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath
    )
//////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Register the Mpe Class binding
    //
    ntStatus = MpeDriverInitialize (pDriverObject,  pszuRegistryPath);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Driver Entry complete, ntStatus: %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\filter.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      filter.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>

#include "mpe.h"
#include "Main.h"
#include "filter.h"


//////////////////////////////////////////////////////////////////////////////
//
//
//
const FILTER_VTABLE FilterVTable =
    {
    Filter_QueryInterface,
    Filter_AddRef,
    Filter_Release,
    };


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
CreateFilter (
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT DeviceObject,
    PMPE_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Save off our Device/Driver Objectsx in our context area
    //
    pFilter->DeviceObject          = DeviceObject;
    pFilter->DriverObject          = DriverObject;
    pFilter->lpVTable              = (PFILTER_VTABLE) &FilterVTable;
    pFilter->ulRefCount            = 1;

    pFilter->bDiscontinuity        = FALSE;

    return ntStatus;
}


///////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Filter_QueryInterface (
    PMPE_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_AddRef (
    PMPE_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    if (pFilter)
    {
        pFilter->ulRefCount += 1;
        return pFilter->ulRefCount;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////
ULONG
Filter_Release (
    PMPE_FILTER pFilter
    )
///////////////////////////////////////////////////////////////////////////////////
{
    ULONG ulRefCount = 0L;

    if (pFilter)
    {
        pFilter->ulRefCount -= 1;
        ulRefCount = pFilter->ulRefCount;

        if (pFilter->ulRefCount == 0)
        {
            // $$BUG  Free Filter here
            return ulRefCount;
        }
    }

    return ulRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\main.h ===
//////////////////////////////////////////////////////////////////////////////\
//
//  Copyright (c) 1990  Microsoft Corporation
//
//  Module Name:
//
//     test.h
//
//  Abstract:
//
//     The main header for the NDIS/KS test driver
//
//  Author:
//
//     P Porzuczek
//
//  Environment:
//
//  Notes:
//
//  Revision History:
//
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H
#define _MAIN_H


#ifdef DBG

extern  ULONG TestDebugFlag;

#define TEST_DBG_NONE       0x00000000
#define TEST_DBG_TRACE      0x00000001
#define TEST_DBG_WRITE_DATA 0x00000002
#define TEST_DBG_READ_DATA  0x00000004

#define TEST_DBG_RECV       0x00000008
#define TEST_DBG_SRB        0x00000010
#define TEST_DBG_CRC        0x00000020
#define TEST_DBG_MPE        0x00000040


#define TEST_DBG_DETAIL  0x00001000
#define TEST_DBG_INFO    0x00002000
#define TEST_DBG_WARNING 0x00004000
#define TEST_DBG_ERROR   0x00008000

#ifdef DEBUG_EXTRAS
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
        __int64                 llTime = 0;             \
        ULONG                   ulTime = 0;                     \
        NdisGetCurrentSystemTime ((PLARGE_INTEGER)&llTime);     \
        ulTime = (ULONG) (llTime >> 2);         \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint ("%04X %08X %-10.10s %4d  ", ulTime & 0xffff, _Trace, &__FILE__[2], __LINE__); \
        DbgPrint _Msg;                          \
    }                                           \
}

#else
#define TEST_DEBUG(_Trace, _Msg)                 \
{                                               \
    if (_Trace & TestDebugFlag)                  \
    {                                           \
        DbgPrint _Msg;                          \
    }                                           \
}
#endif  // DEBUG_EXTRAS

#define IF_TESTDEBUG(f) if (TestDebugFlag & (f))

#define TEST_DEBUG_LOUD               0x00010000  // debugging info
#define TEST_DEBUG_VERY_LOUD          0x00020000  // excessive debugging info
#define TEST_DEBUG_LOG                0x00040000  // enable Log
#define TEST_DEBUG_CHECK_DUP_SENDS    0x00080000  // check for duplicate sends
#define TEST_DEBUG_TRACK_PACKET_LENS  0x00100000  // track directed packet lens
#define TEST_DEBUG_WORKAROUND1        0x00200000  // drop DFR/DIS packets
#define TEST_DEBUG_CARD_BAD           0x00400000  // dump data if CARD_BAD
#define TEST_DEBUG_CARD_TESTS         0x00800000  // print reason for failing


//
// Macro for deciding whether to print a lot of debugging information.
//
#define IF_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_TESTDEBUG( TEST_DEBUG_VERY_LOUD ) { A }


//
// Whether to use the Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_TESTDEBUG( TEST_DEBUG_LOG ) { A }
extern VOID TESTLog(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_TESTDEBUG( TEST_DEBUG_CARD_TESTS ) { A }

#else

extern  ULONG TestDebugFlag;


#define TEST_NONE
#define TEST_FUNCTIONS
#define TEST_COMMANDS
#define TEST_CONNECTIONS
#define TEST_SCIDS
#define TEST_LIST_ALLOCS
#define TEST_POOL
#define TEST_INDICATES
#define TEST_ALLOCATION


#define TEST_DEBUG(_Trace, _Msg)

#define IF_TESTDEBUG(f)

#define TEST_DEBUG_LOUD
#define TEST_DEBUG_VERY_LOUD
#define TEST_DEBUG_LOG
#define TEST_DEBUG_CHECK_DUP_SENDS
#define TEST_DEBUG_TRACK_PACKET_LENS
#define TEST_DEBUG_WORKAROUND1
#define TEST_DEBUG_CARD_BAD
#define TEST_DEBUG_CARD_TESTS


//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif // DBG


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT    pDriverObject,
    IN PUNICODE_STRING   pszuRegistryPath);


VOID
MpeFreeMemory (
    PVOID pvToFree,
    ULONG ulSize
    );

NTSTATUS
MpeAllocateMemory (
    PVOID  *ppvAllocated,
    ULONG   ulcbSize
    );


NTSTATUS
MpeDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    );

#endif // _MAIN_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\ipsink\stream\streamip.c ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      ipstream.c
//
// Abstract:
//
//      This file is a test to find out if dual binding to NDIS and KS works
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef DWORD
#define DWORD ULONG
#endif

#include <forward.h>
#include <strmini.h>
#include <ksmedia.h>

#include <winerror.h>

#include <link.h>
#include <ipsink.h>
#include <BdaTypes.h>
#include <BdaMedia.h>

#include "IpMedia.h"
#include "StreamIP.h"
#include "bdastream.h"

#include "Main.h"
#include "filter.h"


#ifdef DEBUG

#define SRB_TABLE_SIZE  1000
PHW_STREAM_REQUEST_BLOCK     SRBTable [SRB_TABLE_SIZE] = {0};

//////////////////////////////////////////////////////////////////////////////
void
TraceSRB (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    int i;
    PHW_STREAM_REQUEST_BLOCK *p = NULL;

    //
    // Find a NULL entry in the SRB Table
    //
    for (i = 0, p = SRBTable; i < SRB_TABLE_SIZE; i++, p++)
    {
        if (*p == NULL)
        {
            *p = pSRB;
            return;
        }
    }

    return;
}



//////////////////////////////////////////////////////////////////////////////
VOID STREAMAPI
MyStreamClassStreamNotification(
    IN STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType,
    IN PHW_STREAM_OBJECT StreamObject,
    PHW_STREAM_REQUEST_BLOCK pSrb
)
//////////////////////////////////////////////////////////////////////////////
{
    int i;
    PHW_STREAM_REQUEST_BLOCK *p = NULL;

    //
    // Find this SRB pointer in the SRB Table
    //
    for (i = 0, p = SRBTable; i < SRB_TABLE_SIZE; i++. p++)
    {
        if (*p == pSRB)
        {
            *p = NULL;
        }
    }

    StreamClassStreamNotification (NotificationType, StreamObject, pSrb );

    return;
}

//////////////////////////////////////////////////////////////////////////////
void
DumpSRBTable (
    void
    )
//////////////////////////////////////////////////////////////////////////////
{
    int i;
    PHW_STREAM_REQUEST_BLOCK *p = NULL;

    //
    // Find this SRB pointer in the SRB Table
    //
    for (i = 0, p = SRBTable; i < SRB_TABLE_SIZE; i++. p++)
    {
        if (*p != NULL)
        {
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: ERROR....SRB NOT Completed %08X\n, *p"));
        }
    }

    return;
}



#define StreamNotification(a,b,c) MyStreamClassStreamNotification (a,b,c)



#else

#define StreamNotification(a,b,c) StreamClassStreamNotification (a,b,c)
#define DumpSRBTable()

#endif



//////////////////////////////////////////////////////////////////////////////
//
//
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    );


#ifdef DBG
BOOLEAN     fAllocatedDescription = FALSE;
#endif // DBG

//////////////////////////////////////////////////////////////////////////////
VOID
GetAdapterDescription (
    PIPSINK_FILTER pFilter
    )
//////////////////////////////////////////////////////////////////////////////
{
    PKSEVENT_ENTRY pEventEntry = NULL;

    ASSERT( pFilter);

    if (!pFilter->pAdapter)
    {
        //$REVIEW - Should we return a failure code?
        return;
    }

    //
    //  If we already got an adapter description then free it
    //
    if (pFilter->pAdapterDescription)
    {
        #if DBG
        ASSERT( fAllocatedDescription);
        #endif // DBG

        ExFreePool( pFilter->pAdapterDescription);
        pFilter->pAdapterDescription = NULL;
        pFilter->ulAdapterDescriptionLength = 0;
    }

    //
    // Get the length of the description string.  This should include the terminating NULL in the count
    //
    pFilter->ulAdapterDescriptionLength = pFilter->pAdapter->lpVTable->GetDescription (pFilter->pAdapter, NULL);

    if (pFilter->ulAdapterDescriptionLength)
    {
        pFilter->pAdapterDescription = ExAllocatePool(NonPagedPool, pFilter->ulAdapterDescriptionLength);

        #ifdef DBG
        fAllocatedDescription = TRUE;
        #endif // DBG

        //
        // Get the adapter description string.  This is passed up to the IPSINK
        // plugin, which then uses it to determine the NIC IP Address via calls to the
        // TCP/IP protocol.  NOTE:  This call should copy the description including the NULL terminator
        //
        if (pFilter->pAdapterDescription)
        {
            pFilter->pAdapter->lpVTable->GetDescription (pFilter->pAdapter, pFilter->pAdapterDescription);


            //
            // Signal the event to anyone waiting for it
            //
            pEventEntry = StreamClassGetNextEvent(
                              pFilter,
                              NULL,
                              (GUID *) &IID_IBDA_IPSinkEvent,
                              KSEVENT_IPSINK_ADAPTER_DESCRIPTION,
                              NULL
                              );

            if (pEventEntry)
            {
                StreamClassDeviceNotification (SignalDeviceEvent, pFilter, pEventEntry);
            }
        }
    }

    return;
}

//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream                     = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;              // index of the property
    ULONG ulStreamNumber                = pSrb->StreamObject->StreamNumber;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        {
            PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

            Framing->RequirementsFlags   = KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY    |
                                           KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                                           KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

            Framing->PoolType            = NonPagedPool;
            Framing->Frames              = 0;
            Framing->FrameSize           = 0;
            Framing->FileAlignment       = 0;         // None OR FILE_QUAD_ALIGNMENT-1 OR PAGE_SIZE-1;
            Framing->Reserved            = 0;

            switch (ulStreamNumber)
            {
                case STREAM_IP:
                    Framing->Frames    = 16;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                case STREAM_NET_CONTROL:
                    Framing->Frames    = 4;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                default:
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    break;
            }

            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
        }
        break;

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkGetCodecProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;              // index of the property

    PIPSINK_FILTER pFilter              = (PIPSINK_FILTER)pSrb->HwDeviceExtension;
    PVOID pProperty                     = (PVOID) pSPD->PropertyInfo;

    PULONG pPacketCount                 = NULL;
    PBYTE  pMulticastList               = NULL;
    PBYTE  pDescription                 = NULL;
    PBYTE  pAddress                     = NULL;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_IPSINK_MULTICASTLIST:

            //
            // Check if the output buffer is large enough to hold the multicast list
            //
            if (pSPD->PropertyOutputSize < pFilter->ulcbMulticastListEntries)
            {
                TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Multicast buffer too small.  Buffer size needed: %08X\n", pFilter->ulcbMulticastListEntries));
                pSrb->ActualBytesTransferred = pFilter->ulcbMulticastListEntries;
                pSrb->Status = STATUS_MORE_ENTRIES;
                break;
            }

            pMulticastList = (PBYTE) pProperty;
            RtlCopyMemory (pMulticastList, pFilter->multicastList, pFilter->ulcbMulticastListEntries);
            TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Multicast property succeeded...Buffer size returned: %08X\n", pFilter->ulcbMulticastListEntries));
            pSrb->ActualBytesTransferred = pFilter->ulcbMulticastListEntries;
            pSrb->Status = STATUS_SUCCESS;

            break;


        case KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION:
            //
            // Check to see if we actually have the data
            //
            if (pFilter->ulAdapterDescriptionLength == 0)
            {
                pSrb->ActualBytesTransferred = 0;
                pSrb->Status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Check if the output buffer is large enough to hold the adapter description string
            //
            if (pSPD->PropertyOutputSize < pFilter->ulAdapterDescriptionLength)
            {
                TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Adapter Description buffer too small.  Buffer size needed: %08X\n", pFilter->ulAdapterDescriptionLength));
                pSrb->ActualBytesTransferred = pFilter->ulAdapterDescriptionLength;
                pSrb->Status = STATUS_MORE_ENTRIES;
                break;
            }

            pDescription = (PBYTE) pProperty;
            RtlCopyMemory (pDescription, pFilter->pAdapterDescription, pFilter->ulAdapterDescriptionLength);
            TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Adapter Description property succeeded...Buffer size returned: %08X\n", pFilter->ulAdapterDescriptionLength));
            pSrb->ActualBytesTransferred = pFilter->ulAdapterDescriptionLength;
            pSrb->Status = STATUS_SUCCESS;
            break;


        case KSPROPERTY_IPSINK_ADAPTER_ADDRESS:
            //
            // Check to see if we actually have the data
            //
            if (pFilter->ulAdapterAddressLength == 0)
            {
                pSrb->ActualBytesTransferred = 0;
                pSrb->Status = STATUS_UNSUCCESSFUL;
                break;
            }

            //
            // Check if the output buffer is large enough to hold the adapter address string
            //
            if (pSPD->PropertyOutputSize < pFilter->ulAdapterAddressLength)
            {
                TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Adapter Address buffer too small.  Buffer size needed: %08X\n", pFilter->ulAdapterAddressLength));
                pSrb->ActualBytesTransferred = pFilter->ulAdapterAddressLength;
                pSrb->Status = STATUS_MORE_ENTRIES;
                break;
            }

            pAddress = (PBYTE) pProperty;
            RtlCopyMemory (pAddress, pFilter->pAdapterAddress, pFilter->ulAdapterAddressLength);
            TEST_DEBUG (TEST_DBG_GET, ("STREAMIP: GET Adapter Address property succeeded...Buffer size returned: %08X\n", pFilter->ulAdapterAddressLength));
            pSrb->ActualBytesTransferred = pFilter->ulAdapterAddressLength;
            pSrb->Status = STATUS_SUCCESS;
            break;


        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkGetProperty (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set))
    {
        IPSinkGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (&KSPROPSETID_Stream, &pSPD->Property->Set))
    {
        IPSinkGetConnectionProperty (pSrb);
    }
    else if (IsEqualGUID (&IID_IBDA_IPSinkControl, &pSPD->Property->Set))
    {
        IPSinkGetCodecProperty (pSrb);
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkSetCodecProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;              // index of the property

    PIPSINK_FILTER pFilter              = (PIPSINK_FILTER)pSrb->HwDeviceExtension;
    PVOID pProperty                     = (PVOID) pSPD->PropertyInfo;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_IPSINK_ADAPTER_ADDRESS:
            pFilter->ulAdapterAddressLength = pSPD->PropertyOutputSize;

            if (pFilter->pAdapterAddress != NULL)
            {
                ExFreePool (pFilter->pAdapterAddress);
            }

            pFilter->pAdapterAddress = ExAllocatePool(NonPagedPool, pFilter->ulAdapterAddressLength);
            if (pFilter->pAdapterAddress == NULL)
            {
                pSrb->Status = STATUS_NO_MEMORY;
                break;
            }

            RtlCopyMemory (pFilter->pAdapterAddress, pProperty, pFilter->ulAdapterAddressLength);

            pSrb->Status = STATUS_SUCCESS;

            break;


        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IPSinkSetProperty (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&IID_IBDA_IPSinkControl, &pSPD->Property->Set))
    {
        IPSinkSetCodecProperty (pSrb);
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    return;
}



//////////////////////////////////////////////////////////////////////////////
BOOLEAN
LinkEstablished (
    PIPSINK_FILTER pFilter
    )
//////////////////////////////////////////////////////////////////////////////
{
    return (pFilter->NdisLink.flags & LINK_ESTABLISHED);
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
LinkToNdisHandler (
    PVOID pvContext
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus           = STATUS_SUCCESS;
    IPSINK_NDIS_COMMAND Cmd     = {0};
    PIPSINK_FILTER pFilter      = (PIPSINK_FILTER) pvContext;
    UNICODE_STRING DriverName;

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Linking to Ndis....\n"));

    if (   (pFilter->NdisLink.flags & LINK_ESTABLISHED)
        && pFilter->pAdapter
       )
    {
        //  Link already established.
        //
        return ntStatus;
    }

    //
    // Initialize a Unicode string to the NDIS driver's name
    //
    RtlInitUnicodeString(&DriverName, BDA_NDIS_MINIPORT);

    if (OpenLink (&pFilter->NdisLink, DriverName))
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Driver Link Established\n"));

        //
        // Get the NDIS VTable via a read over the link
        //
        Cmd.ulCommandID                    = CMD_QUERY_INTERFACE;
        Cmd.Parameter.Query.pStreamAdapter = (PVOID) pFilter;
        Cmd.Parameter.Query.pNdisAdapter   = NULL;

        ntStatus = SendIOCTL( &pFilter->NdisLink, 
                              IOCTL_GET_INTERFACE, 
                              &Cmd, 
                              sizeof( IPSINK_NDIS_COMMAND)
                              );
        if (!FAILED( ntStatus))
        {
            if (Cmd.Parameter.Query.pNdisAdapter)
            {
                //  Get the adapter object.
                //
                pFilter->pAdapter = (PVOID) Cmd.Parameter.Query.pNdisAdapter;
    
                // Increment the reference count on this object
                //
                //$REVIEW - Shoutn't the IOCTL_GET_INTERFACE return a
                //$REVIEW - reference?
                //
                pFilter->pAdapter->lpVTable->AddRef( pFilter->pAdapter);
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: IOCTL_GET_INTERFACE didn't return an adapter.\n"));
                ntStatus = STATUS_UNSUCCESSFUL;
            }

        }
        else
        {
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: IOCTL_GET_INTERFACE failed.\n"));
        }
    }
    else
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Link cannot be established\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    //  Make sure the link is closed on failure.
    //
    if (FAILED( ntStatus))
    {
        CloseLink( &pFilter->NdisLink);
    }


    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Driver Link NOT Established\n"));
    return ntStatus;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                        = STATUS_SUCCESS;
    HW_INITIALIZATION_DATA   HwInitData;
    UNICODE_STRING           DeviceNameString;
    UNICODE_STRING           SymbolicNameString;

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));
    HwInitData.HwInitializationDataSize = sizeof(HwInitData);


    ////////////////////////////////////////////////////////////////
    //
    // Setup the stream class dispatch table
    //
    HwInitData.HwInterrupt                 = NULL; // HwInterrupt is only for HW devices

    HwInitData.HwReceivePacket             = CodecReceivePacket;
    HwInitData.HwCancelPacket              = CodecCancelPacket;
    HwInitData.HwRequestTimeoutHandler     = CodecTimeoutPacket;

    HwInitData.DeviceExtensionSize         = sizeof(IPSINK_FILTER);
    HwInitData.PerRequestExtensionSize     = sizeof(SRB_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize      = sizeof(STREAM);
    HwInitData.BusMasterDMA                = FALSE;
    HwInitData.Dma24BitAddresses           = FALSE;
    HwInitData.BufferAlignment             = 3;
    HwInitData.TurnOffSynchronization      = TRUE;
    HwInitData.DmaBufferSize               = 0;


    ntStatus = StreamClassRegisterAdapter (DriverObject, RegistryPath, &HwInitData);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    return ntStatus;
}


//
//
//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PIPSINK_FILTER pFilter                      = (PIPSINK_FILTER) pConfigInfo->HwDeviceExtension;

    //
    // Define the default return codes
    //
    pSrb->Status = STATUS_SUCCESS;
    bStatus = TRUE;

    //
    // Initialize Statistics block
    //
    RtlZeroMemory(&pFilter->Stats, sizeof (STATS));

    //
    // Initialize members
    //
    pFilter->pAdapterDescription = NULL;
    pFilter->ulAdapterDescriptionLength = 0;


    //
    // Check out init flag so we don't try to init more then once.  The Streaming
    // Class driver appears to call the init handler several times for some reason.
    //
    if (pFilter->bInitializationComplete)
    {
        goto ret;
    }

    pFilter->NdisLink.flags = 0;


    if (pConfigInfo->NumberOfAccessRanges == 0)
    {
        pConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

    }
    else
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        bStatus = FALSE;
        goto ret;
    }


    //
    // Create a filter object to represent our context
    //
    pSrb->Status = CreateFilter (pConfigInfo->ClassDeviceObject->DriverObject, pConfigInfo->ClassDeviceObject, pFilter);
    if (pSrb->Status != STATUS_SUCCESS)
    {
        bStatus = FALSE;
        goto ret;
    }


    //
    // Start up a timer to poll until the NDIS driver loads
    //
    //IoInitializeTimer (pFilter->DeviceObject, LinkToNdisTimer, pFilter);

    //IoStartTimer (pFilter->DeviceObject);

    pFilter->bInitializationComplete = TRUE;

ret:

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecUnInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PIPSINK_FILTER pFilter                      = ((PIPSINK_FILTER)pSrb->HwDeviceExtension);
    PSTREAM pStream                             = NULL;
    KIRQL    Irql;

    //
    // Close our link to the NDIS component
    //
    KeAcquireSpinLock (&pFilter->AdapterSRBSpinLock, &Irql);

    //
    // Call adapter close link to give the adapter a chance to release its
    // reference to the filter
    //
    if (pFilter->pAdapter)
    {
        if (pFilter->pAdapter->lpVTable->CloseLink)
        {
            pFilter->pAdapter->lpVTable->CloseLink( pFilter->pAdapter);
        }

        pFilter->pAdapter = NULL;
    }

    //  Free the IP Sink NDIS Adapter's description
    //
    if (pFilter->pAdapterDescription)
    {
        ExFreePool( pFilter->pAdapterDescription);
        pFilter->pAdapterDescription = NULL;
        pFilter->ulAdapterDescriptionLength = 0;
    }

    KeReleaseSpinLock (&pFilter->AdapterSRBSpinLock, Irql);

    //  The call to CloseLink can only be made at PASSIVE_LEVEL and
    //  therefore must be outside the spinlock.
    //
    CloseLink( &pFilter->NdisLink);


    if (pSrb->StreamObject != NULL)
    {
        pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    }

    if (pStream)
    {
        //
        // Clean up any queues we have and complete any outstanding SRB's
        //
        while (QueueRemove (&pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        }


        while (QueueRemove (&pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        }

    }

    while (QueueRemove (&pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
    }


    bStatus = TRUE;

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
VOID
CodecStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    int j;

    PIPSINK_FILTER pFilter =
            ((PIPSINK_FILTER)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //
    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

    //
    // pick up the pointer to the array of stream information data structures
    //
    PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


    //
    // Set the header
    //
    StreamHeader.NumDevPropArrayEntries = NUMBER_IPSINK_CODEC_PROPERTIES;
    StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET) IPSinkCodecProperties;

    //
    // Set events array
    //
    StreamHeader.NumDevEventArrayEntries = NUMBER_IPSINK_EVENTS;
    StreamHeader.DeviceEventsArray       = (PKSEVENT_SET) IPSinkEvents;

    *pstrhdr = StreamHeader;

    //
    // stuff the contents of each HW_STREAM_INFORMATION struct
    //
    for (j = 0; j < DRIVER_STREAM_COUNT; j++)
    {
       *pstrinfo++ = Streams[j].hwStreamInfo;
    }

    pSrb->Status = STATUS_SUCCESS;

}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM  pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PIPSINK_FILTER  pFilter = ((PIPSINK_FILTER)pSrb->HwDeviceExtension);

    //
    // Check whether the SRB to cancel is in use by this stream
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: CancelPacket Called\n"));

    if (QueueRemoveSpecific (pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        return;
    }

    if (QueueRemoveSpecific (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        return;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // if we timeout while playing, then we need to consider this
    // condition an error, and reset the hardware, and reset everything
    // as well as cancelling this and all requests
    //

    //
    // if we are not playing, and this is a CTRL request, we still
    // need to reset everything as well as cancelling this and all requests
    //

    //
    // if this is a data request, and the device is paused, we probably have
    // run out of data buffer, and need more time, so just reset the timer,
    // and let the packet continue
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: TimeoutPacket Called\n"));

    pSrb->TimeoutCounter = 0;

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PIPSINK_FILTER pFilter = ((PIPSINK_FILTER)pSrb->HwDeviceExtension);
    IPSINK_NDIS_COMMAND  Cmd       = {0};


    //
    // Make sure queue & SL initted
    //
    if (!pFilter->bAdapterQueueInitialized)
    {
        InitializeListHead (&pFilter->AdapterSRBQueue);
        KeInitializeSpinLock (&pFilter->AdapterSRBSpinLock);
        KeInitializeSpinLock (&pFilter->NdisLink.spinLock);
        pFilter->bAdapterQueueInitialized = TRUE;
    }

    //
    // Assume success
    //
    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //
    //if (QueueAddIfNotEmpty (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    //{
    //    pSrb->Status = STATUS_SUCCESS;
    //    return;
    //}
    QueueAdd (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue);


    while (QueueRemove( &pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue ))
    {
        switch (pSrb->Command)
        {

            case SRB_INITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_INITIALIZE Command\n"));
                CodecInitialize(pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_UNINITIALIZE Command\n"));
                CodecUnInitialize(pSrb);
                break;

            case SRB_INITIALIZATION_COMPLETE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_INITIALIZE_COMPLETE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_OPEN_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_OPEN_STREAM Command\n"));

                if (LinkToNdisHandler ((PVOID) pFilter) != STATUS_SUCCESS)
                {
                    pSrb->Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Get the Adapter description string.  This is used to determine the
                // adapter NIC address
                //
                GetAdapterDescription (pFilter);

                //
                // Open up the stream and connect
                //
                OpenStream (pSrb);
                break;

            case SRB_CLOSE_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_CLOSE_STREAM Command\n"));
                CloseStream (pSrb);
                break;

            case SRB_GET_STREAM_INFO:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_GET_STREAM_INFO Command\n"));
                CodecStreamInfo (pSrb);
                break;

            case SRB_GET_DATA_INTERSECTION:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_GET_DATA_INTERSECTION Command\n"));

                //
                // Compare our stream formats.  NOTE, the compare functions sets the SRB
                // status fields
                //
                CompareStreamFormat (pSrb);
                break;

            case SRB_OPEN_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_OPEN_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CLOSE_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_CLOSE_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_UNKNOWN_DEVICE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CHANGE_POWER_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_CHANGE_POWER_STATE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_GET_DEVICE_PROPERTY Command\n"));
                IPSinkGetProperty(pSrb);
                break;

            case SRB_SET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_SET_DEVICE_PROPERTY Command\n"));
                IPSinkSetProperty(pSrb);
                break;

            case SRB_UNKNOWN_STREAM_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_UNKNOWN Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: SRB_DEFAULT Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        };


        //
        // NOTE:
        //
        // All of the commands that we do, or do not understand can all be completed
        // syncronously at this point, so we can use a common callback routine here.
        // If any of the above commands require asyncronous processing, this will
        // have to change
        //

       StreamClassDeviceNotification (DeviceRequestComplete, pFilter, pSrb);

    } // while (QueueRemove( &pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue ));

}


//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAdd (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertTailList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAddIfNotEmpty (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   BOOL            bAddedSRB = FALSE;

   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pSrbExtension->pSrb = pSrb;
       InsertTailList (pQueue, &pSrbExtension->ListEntry );
       bAddedSRB = TRUE;
   }

   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bAddedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemove (
    IN OUT PHW_STREAM_REQUEST_BLOCK * pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL    Irql;
   BOOL     bRemovedSRB = FALSE;

   KeAcquireSpinLock (pQueueSpinLock, &Irql);

   *pSrb =  (PHW_STREAM_REQUEST_BLOCK) NULL;

   if( !IsListEmpty( pQueue ))
   {
       PHW_STREAM_REQUEST_BLOCK *pCurrentSrb = NULL;
       PUCHAR Ptr                            = (PUCHAR) RemoveHeadList(pQueue);

       pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK *) (((PUCHAR)Ptr) + sizeof (LIST_ENTRY));

       *pSrb = *pCurrentSrb;
       bRemovedSRB = TRUE;

   }

   KeReleaseSpinLock (pQueueSpinLock, Irql);

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemoveSpecific (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL Irql;
   BOOL  bRemovedSRB = FALSE;
   PLIST_ENTRY pCurrentEntry;
   PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pCurrentEntry = pQueue->Flink;
       while ((pCurrentEntry != pQueue ) && !bRemovedSRB)
       {
           pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK * ) ((( PUCHAR )pCurrentEntry ) + sizeof( LIST_ENTRY ));

           if( *pCurrentSrb == pSrb )
           {
               RemoveEntryList( pCurrentEntry );
               bRemovedSRB = TRUE;
           }
           pCurrentEntry = pCurrentEntry->Flink;
       }
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamIPIndicateEvent (
    PVOID pvEvent
)
//////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}



//////////////////////////////////////////////////////////////////////////////
BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL bResult = FALSE;

    if ( IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) )
    {

        if ( IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) )
        {

            if ( IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) )
            {
                if ( !bCheckSize || pDataRange1->FormatSize == pDataRange2->FormatSize)
                {
                    bResult = TRUE;
                }
            }
        }
    }

    return bResult;

}

//////////////////////////////////////////////////////////////////////////////
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    )
//////////////////////////////////////////////////////////////////////////////
{
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: DATA Format\n"));
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Format Size:   %08X\n", pF->FormatSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Flags:         %08X\n", pF->Flags));
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     SampleSize:    %08X\n", pF->SampleSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Reserved:      %08X\n", pF->Reserved));



    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Major GUID:  %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->MajorFormat.Data1,
                                                pF->MajorFormat.Data2,
                                                pF->MajorFormat.Data3,
                                                pF->MajorFormat.Data4[0],
                                                pF->MajorFormat.Data4[1],
                                                pF->MajorFormat.Data4[2],
                                                pF->MajorFormat.Data4[3],
                                                pF->MajorFormat.Data4[4],
                                                pF->MajorFormat.Data4[5],
                                                pF->MajorFormat.Data4[6],
                                                pF->MajorFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Sub GUID:    %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->SubFormat.Data1,
                                                pF->SubFormat.Data2,
                                                pF->SubFormat.Data3,
                                                pF->SubFormat.Data4[0],
                                                pF->SubFormat.Data4[1],
                                                pF->SubFormat.Data4[2],
                                                pF->SubFormat.Data4[3],
                                                pF->SubFormat.Data4[4],
                                                pF->SubFormat.Data4[5],
                                                pF->SubFormat.Data4[6],
                                                pF->SubFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP:     Specifier:   %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->Specifier.Data1,
                                                pF->Specifier.Data2,
                                                pF->Specifier.Data3,
                                                pF->Specifier.Data4[0],
                                                pF->Specifier.Data4[1],
                                                pF->Specifier.Data4[2],
                                                pF->Specifier.Data4[3],
                                                pF->Specifier.Data4[4],
                                                pF->Specifier.Data4[5],
                                                pF->Specifier.Data4[6],
                                                pF->Specifier.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("\n"));
}


//////////////////////////////////////////////////////////////////////////////
BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL                        bStatus = FALSE;
    PSTREAM_DATA_INTERSECT_INFO pIntersectInfo;
    PKSDATARANGE                pDataRange1;
    PKSDATARANGE                pDataRange2;
    ULONG                       FormatSize = 0;
    ULONG                       ulStreamNumber;
    ULONG                       j;
    ULONG                       ulNumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    pIntersectInfo = pSrb->CommandData.IntersectInfo;
    ulStreamNumber = pIntersectInfo->StreamNumber;


    pSrb->ActualBytesTransferred = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Comparing Stream Formats\n"));


    //
    // Check that the stream number is valid
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT)
    {
        ulNumberOfFormatArrayEntries = Streams[ulStreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

        //
        // Get the pointer to the array of available formats
        //
        pAvailableFormats = Streams[ulStreamNumber].hwStreamInfo.StreamFormatsArray;

        //
        // Walk the formats supported by the stream searching for a match
        // of the three GUIDs which together define a DATARANGE
        //
        for (pDataRange1 = pIntersectInfo->DataRange, j = 0;
             j < ulNumberOfFormatArrayEntries;
             j++, pAvailableFormats++)

        {
            bStatus = FALSE;
            pSrb->Status = STATUS_UNSUCCESSFUL;

            pDataRange2 = *pAvailableFormats;

            if (CompareGUIDsAndFormatSize (pDataRange1, pDataRange2, TRUE))
            {

                ULONG   ulFormatSize = pDataRange2->FormatSize;

                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Stream Formats compare\n"));

                //
                // Is the caller trying to get the format, or the size of the format?
                //
                if (pIntersectInfo->SizeOfDataFormatBuffer == sizeof (ULONG))
                {
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Returning Stream Format size\n"));

                    *(PULONG) pIntersectInfo->DataFormatBuffer = ulFormatSize;
                    pSrb->ActualBytesTransferred = sizeof (ULONG);
                    pSrb->Status = STATUS_SUCCESS;
                    bStatus = TRUE;
                }
                else
                {
                    //
                    // Verify that there is enough room in the supplied buffer for the whole thing
                    //
                    pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                    bStatus = FALSE;

                    if (pIntersectInfo->SizeOfDataFormatBuffer >= ulFormatSize)
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Returning Stream Format\n"));
                        RtlCopyMemory (pIntersectInfo->DataFormatBuffer, pDataRange2, ulFormatSize);
                        pSrb->ActualBytesTransferred = ulFormatSize;
                        pSrb->Status = STATUS_SUCCESS;
                        bStatus = TRUE;
                    }
                    else
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Stream Format return buffer too small\n"));
                    }
                }
                break;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Stream Formats DO NOT compare\n"));
            }
        }

        if ( j >= ulNumberOfFormatArrayEntries )
        {
            pSrb->ActualBytesTransferred = 0;
            pSrb->Status = STATUS_UNSUCCESSFUL;
            bStatus = FALSE;
        }

    }
    else
    {
        pSrb->ActualBytesTransferred = 0;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        bStatus = FALSE;
    }

    return bStatus;
}


//////////////////////////////////////////////////////////////////////////////
VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream                = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PIPSINK_FILTER  pFilter                = (PIPSINK_FILTER)pSrb->HwDeviceExtension;
    ULONG           ulStreamNumber         = (ULONG) pSrb->StreamObject->StreamNumber;
    ULONG           ulStreamInstance       = pStream->ulStreamInstance;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb   = NULL;
    KIRQL    Irql;
    PLINK           pLink = NULL;

    //
    // Close our link to the NDIS component
    //
    KeAcquireSpinLock (&pFilter->AdapterSRBSpinLock, &Irql);

    //
    // Call adapter close link to give the adapter a chance to release its
    // reference to the filter
    //
    if (pFilter->pAdapter)
    {
        if (pFilter->pAdapter->lpVTable->CloseLink)
        {
            pFilter->pAdapter->lpVTable->CloseLink (pFilter->pAdapter);
        }

        pFilter->pAdapter = NULL;
    }

    pFilter->pAdapter = NULL;

    KeReleaseSpinLock (&pFilter->AdapterSRBSpinLock, Irql);

    //  The call to CloseLink can only be made at PASSIVE_LEVEL
    //  and thus is moved outside the spin lock
    //
    CloseLink (&pFilter->NdisLink);

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        //
        // Clear this streams spot in the filters stream array
        //
        pFilter->pStream[ulStreamNumber][ulStreamInstance] = NULL;

        //
        // decrement the stream instance count for this filter
        //
        pFilter->ulActualInstances[ulStreamNumber]--;

        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
        }

        //
        // Flush the stream control queue
        //
        while (QueueRemove( &pCurrentSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification (StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
        }

        //
        // reset pointers to the handlers for the stream data and control handlers
        //
        pSrb->StreamObject->ReceiveDataPacket    = NULL;
        pSrb->StreamObject->ReceiveControlPacket = NULL;

        //
        // The DMA flag must be set when the device will be performing DMA directly
        // to the data buffer addresses passed in to the ReceiveDataPacket routines.
        //
        pSrb->StreamObject->Dma = 0;

        //
        // The PIO flag must be set when the mini driver will be accessing the data
        // buffers passed in using logical addressing
        //
        pSrb->StreamObject->Pio       = 0;
        pSrb->StreamObject->Allocator = 0;

        //
        // How many extra bytes will be passed up from the driver for each frame?
        //
        pSrb->StreamObject->StreamHeaderMediaSpecific = 0;
        pSrb->StreamObject->StreamHeaderWorkspace     = 0;

        //
        // Indicate the clock support available on this stream
        //
        //pSrb->StreamObject->HwClockObject = 0;

        //
        // Reset the stream state to stopped
        //
        pStream->KSState = KSSTATE_STOP;

        //
        // Reset the stream extension blob
        //
        RtlZeroMemory(pStream, sizeof (STREAM));

        pSrb->Status = STATUS_SUCCESS;

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }

    #ifdef DEBUG

    DumpSRBTable ();

    #endif // DEBUG
}


//////////////////////////////////////////////////////////////////////////////
VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream        = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PIPSINK_FILTER  pFilter        = ((PIPSINK_FILTER)pSrb->HwDeviceExtension);
    ULONG           ulStreamNumber = (ULONG) pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT   pKSDataFormat  = (PKSDATAFORMAT)pSrb->CommandData.OpenFormat;

    //
    // Initialize the stream extension blob
    //
    RtlZeroMemory(pStream, sizeof (STREAM));

    //
    // Initialize stream state
    //
    pStream->KSState = KSSTATE_STOP;

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        ULONG ulStreamInstance;
        ULONG ulMaxInstances = Streams[ulStreamNumber].hwStreamInfo.NumberOfPossibleInstances;

        //
        // Search for next open slot
        //
        for (ulStreamInstance = 0; ulStreamInstance < ulMaxInstances; ++ulStreamInstance)
        {
            if (pFilter->pStream[ulStreamNumber][ulStreamInstance] == NULL)
            {
                break;
            }
        }

        if (ulStreamInstance < ulMaxInstances)
        {
            if (VerifyFormat(pKSDataFormat, ulStreamNumber, &pStream->MatchedFormat))
            {
                InitializeListHead(&pStream->StreamControlQueue);
                InitializeListHead(&pStream->StreamDataQueue);
                KeInitializeSpinLock(&pStream->StreamControlSpinLock);
                KeInitializeSpinLock(&pStream->StreamDataSpinLock);

                //
                // Maintain an array of all the StreamEx structures in the HwDevExt
                // so that we can reference IRPs from any stream
                //
                pFilter->pStream[ulStreamNumber][ulStreamInstance] = pStream;

                //
                // Save the Stream Format in the Stream Extension as well.
                //
                pStream->OpenedFormat = *pKSDataFormat;


                //
                // Set up pointers to the handlers for the stream data and control handlers
                //
                pSrb->StreamObject->ReceiveDataPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveDataPacket;
                pSrb->StreamObject->ReceiveControlPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveControlPacket;

                //
                // The DMA flag must be set when the device will be performing DMA directly
                // to the data buffer addresses passed in to the ReceiveDataPacket routines.
                //
                pSrb->StreamObject->Dma = Streams[ulStreamNumber].hwStreamObject.Dma;

                //
                // The PIO flag must be set when the mini driver will be accessing the data
                // buffers passed in using logical addressing
                //
                pSrb->StreamObject->Pio = Streams[ulStreamNumber].hwStreamObject.Pio;

                pSrb->StreamObject->Allocator = Streams[ulStreamNumber].hwStreamObject.Allocator;

                //
                // How many extra bytes will be passed up from the driver for each frame?
                //
                pSrb->StreamObject->StreamHeaderMediaSpecific =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

                pSrb->StreamObject->StreamHeaderWorkspace =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderWorkspace;

                //
                // Indicate the clock support available on this stream
                //
                pSrb->StreamObject->HwClockObject =
                                        Streams[ulStreamNumber].hwStreamObject.HwClockObject;

                //
                // Increment the instance count on this stream
                //
                pStream->ulStreamInstance = ulStreamInstance;
                pFilter->ulActualInstances[ulStreamNumber]++;


                //
                // Retain a private copy of the HwDevExt and StreamObject in the stream extension
                // so we can use a timer
                //
                pStream->pFilter = pFilter;                     // For timer use
                pStream->pStreamObject = pSrb->StreamObject;        // For timer use


                pSrb->Status = STATUS_SUCCESS;

            }
            else
            {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOLEAN   bResult               = FALSE;
    ULONG     FormatCount           = 0;
    PKS_DATARANGE_VIDEO pThisFormat = NULL;

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Verify Format\n"));

    for (FormatCount = 0; !bResult && FormatCount < Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
        FormatCount++ )
    {


        pThisFormat = (PKS_DATARANGE_VIDEO) Streams [StreamNumber].hwStreamInfo.StreamFormatsArray [FormatCount];

        if (CompareGUIDsAndFormatSize( pKSDataFormat, &pThisFormat->DataRange, TRUE ) )
        {
            bResult = TRUE;
        }
    }

    if (bResult == TRUE && pMatchedFormat)
    {
        *pMatchedFormat = pThisFormat->DataRange;
    }

    return bResult;
}



//////////////////////////////////////////////////////////////////////////////
NTSTATUS
STREAMAPI
EventHandler (
    IN PHW_EVENT_DESCRIPTOR pEventDesriptor
    )
//////////////////////////////////////////////////////////////////////////////
{

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: EventHandler called\n"));

    return STATUS_NOT_IMPLEMENTED;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    ULONG             ulBuffers  = pSrb->NumberOfBuffers;
    PIPSINK_FILTER    pFilter    = (PIPSINK_FILTER) pSrb->HwDeviceExtension;
    PSTREAM           pStream    = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    int               iStream    = (int) pSrb->StreamObject->StreamNumber;
    PKSSTREAM_HEADER  pStreamHdr = pSrb->CommandData.DataBufferArray;
    ULONG             ul         = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called\n"));

    //
    // Default to success, disable timeouts
    //
    pSrb->Status = STATUS_SUCCESS;

    //
    // Check for last buffer
    //
    if (pStreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet is LAST PACKET\n"));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);


        if (pFilter->pAdapter)
        {
            if (pFilter->pAdapter->lpVTable->IndicateReset)
            {
                pFilter->pAdapter->lpVTable->IndicateReset (pFilter->pAdapter);
            }
        }

        return;
    }


    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
        case SRB_WRITE_DATA:

            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler - SRB_WRITE_DATA, pSrb: %08X\n", pSrb));

            if (pStream->KSState == KSSTATE_STOP)
            //if ((pStream->KSState == KSSTATE_STOP) || (pStream->KSState == KSSTATE_PAUSE))
            {
                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));

                break;
            }

            //
            // Update the total number of packets written statistic
            //
            pFilter->Stats.ulTotalPacketsWritten += 1;


            //
            // Handle data input, output requests differently.
            //
            switch (iStream)
            {
                //
                //  Frame input stream
                //
                case STREAM_IP:
                {
                    QueueAdd (pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue);

                    while (QueueRemove( &pSrb, &pStream->StreamDataSpinLock,&pStream->StreamDataQueue ))

                    {
                        #ifdef DEBUG

                        DbgPrint ("SIW: S:%08X B:%08X\n", pSrb, pStreamHdr->Data);

                        #endif

                        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Processing pSrb: %08X\n", pSrb));

                        for (ul = 0; ul < ulBuffers; ul++, pStreamHdr++)
                        {
                            //
                            // If Data Used is 0 then don't bother sending the packet
                            // to NdisIp.
                            //

                            if(pStreamHdr->DataUsed)
                            {
                                //
                                // Update stats for IP Stream count
                                //
                                pFilter->Stats.ulTotalStreamIPPacketsWritten += 1;
                                pFilter->Stats.ulTotalStreamIPBytesWritten   += pStreamHdr->DataUsed;
                                pFilter->Stats.ulTotalStreamIPFrameBytesWritten   += pStreamHdr->FrameExtent;
    
                                if (pFilter->pAdapter)
                                {
                                    if (pFilter->pAdapter->lpVTable->IndicateData)
                                    {
                                        pSrb->Status = pFilter->pAdapter->lpVTable->IndicateData (
                                                           pFilter->pAdapter,
                                                           pStreamHdr->Data,
                                                           pStreamHdr->DataUsed
                                                           );
    
                                        if (pSrb->Status != STATUS_SUCCESS)
                                        {
                                            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: IndicateData returned ERROR %08X\n", pSrb->Status));
    
                                            pSrb->Status = STATUS_SUCCESS;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                pSrb->Status = STATUS_SUCCESS;
                            }
                        }

                        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                        TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    }
                }
                break;

                //
                // Other "unknown" streams are not valid and will be rejected.
                //
                case STREAM_NET_CONTROL:
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - SRB_WRITE - STREAM_NET_CONTROL\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Net packet count
                    //
                    pFilter->Stats.ulTotalNetPacketsWritten += 1;

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - SRB_WRITE - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalUnknownPacketsWritten += 1;

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;
            }
            break;


        case SRB_READ_DATA:

            //
            // Update stats for Unkown packet count
            //
            pFilter->Stats.ulTotalPacketsRead += 1;

            switch (iStream)
            {
                case STREAM_NET_CONTROL:
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - SRB_READ - STREAM_NET_CONTROL, pSrb: %08X\n", pSrb));


                    // Take the SRB we get and  queue it up.  These Queued SRB's will be filled with data on a WRITE_DATA
                    // request, at which point they will be completed.
                    //
                    pSrb->Status = STATUS_SUCCESS;
                    QueueAdd (pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue);
                    TEST_DEBUG( TEST_DBG_TRACE, ("IPSInk Queuing Output SRB %08X\n", pSrb));

                    //
                    // Since the stream state may have changed while we were adding the SRB to the queue
                    // we'll check it again, and cancel it if necessary
                    //
                    if (pStream->KSState == KSSTATE_STOP)
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("IPSink: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                        if (QueueRemoveSpecific (pSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
                        {
                            pSrb->Status = STATUS_CANCELLED;
                            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                            TEST_DEBUG( TEST_DBG_TRACE, ("IPSink Completed SRB %08X\n", pSrb));
                            return;
                        }
                        break;
                    }
                    
                    // StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - SRB_READ - Default, pSrb: %08X\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
                    break;

            }
            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Data packet handler called - Unsupported Command\n"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: StreamRequestComplete on pSrb: %08X\n", pSrb));
            ASSERT (FALSE);
            break;

    }

    return;
}

//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PIPSINK_FILTER pFilter = (PIPSINK_FILTER) pSrb->HwDeviceExtension;
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler called\n"));

    pSrb->Status = STATUS_SUCCESS;

    QueueAdd (pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue);
    //if (QueueAddIfNotEmpty (pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
    //{
    //    pSrb->Status = STATUS_SUCCESS;
    //    return;
    //}


    //do
    while (QueueRemove (&pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue))
    {
        //
        // determine the type of packet.
        //
        switch (pSrb->Command)
        {
            case SRB_PROPOSE_DATA_FORMAT:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Propose data format\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Set Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                IpSinkSetState (pSrb);
                break;

            case SRB_GET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Get Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                pSrb->CommandData.StreamState = pStream->KSState;
                pSrb->ActualBytesTransferred = sizeof (KSSTATE);
                break;

            case SRB_GET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Get Stream Property\n"));
                IPSinkGetProperty(pSrb);
                break;

            case SRB_SET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Set Stream Property\n"));
                IPSinkSetProperty(pSrb);
                break;

            case SRB_INDICATE_MASTER_CLOCK:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Indicate Master Clock\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_SET_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Set Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_PROPOSE_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Propose Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Receive Control packet handler - Default case\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        }

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);

    } //  while (QueueRemove (&pSrb, &pStream->StreamControlSpinLock, &pStream->StreamControlQueue));

}



//////////////////////////////////////////////////////////////////////////////
VOID
IpSinkSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PIPSINK_FILTER pFilter               = ((PIPSINK_FILTER) pSrb->HwDeviceExtension);
    PSTREAM pStream                      = (PSTREAM) pSrb->StreamObject->HwStreamExtension;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb = NULL;

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //
    switch (pSrb->CommandData.StreamState)
    {
        case KSSTATE_STOP:

            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Set Stream State KSSTATE_STOP\n"));

            //
            // If transitioning to STOP state, then complete any outstanding IRPs
            //
            while (QueueRemove(&pCurrentSrb, &pStream->StreamDataSpinLock, &pStream->StreamDataQueue))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
            }

            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;


        case KSSTATE_ACQUIRE:
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Set Stream State KSSTATE_ACQUIRE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_PAUSE:
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Set Stream State KSSTATE_PAUSE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_RUN:
            TEST_DEBUG (TEST_DBG_TRACE, ("STREAMIP: Set Stream State KSSTATE_RUN\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

    } // end switch (pSrb->CommandData.StreamState)

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\mpe.c ===
///////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      mpe.c
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>
#include <BdaTypes.h>
#include <BdaMedia.h>

#include "Mpe.h"
#include "MpeMedia.h"
#include "MpeStream.h"
#include "Recv.h"

#include "Main.h"
#include "filter.h"


#pragma pack (1)

typedef struct
{
    BYTE   table_id;
    USHORT section_syntax_indicator : 1;
    USHORT private_indicator: 1;
    USHORT reserved1: 2;
    USHORT section_length: 12;
    BYTE   MAC_address_6;
    BYTE   MAC_address_5;
    BYTE   reserved2 : 2;
    BYTE   payload_scrambling : 2;
    BYTE   address_scrambling : 2;
    BYTE   LLC_SNAP_flag : 1;
    BYTE   current_next_indicator : 1;
    BYTE   section_number;
    BYTE   last_section_number;
    BYTE   MAC_address_4;
    BYTE   MAC_address_3;
    BYTE   MAC_address_2;
    BYTE   MAC_address_1;
    BYTE   Data [0];

} SECTION_HEADER, *PSECTION_HEADER;

typedef struct
{
    BYTE   dsap;
    BYTE   ssap;
    BYTE   cntl;
    BYTE   org [3];
    USHORT type;
    BYTE Data [0];

} LLC_SNAP, *PLLC_SNAP;


typedef struct
{
    BYTE MAC_Dest_Address [6];
    BYTE MAC_Src_Address [6];
    USHORT usLength;

} MAC_Address, *PMAC_Address;

typedef struct _HEADER_IP_
{
    UCHAR  ucVersion_Length;
    UCHAR  ucTOS;
    USHORT usLength;
    USHORT usId;
    USHORT usFlags_Offset;
    UCHAR  ucTTL;
    UCHAR  ucProtocol;
    USHORT usHdrChecksum;
    UCHAR  ucSrcAddress [4];
    UCHAR  ucDestAddress [4];

} HEADER_IP, *PHEADER_IP;


#pragma pack ()



#define ES2(s) ((((s) >> 8) & 0x00FF) + (((s) << 8) & 0xFF00))

//////////////////////////////////////////////////////////////////////////////
BOOLEAN
ValidSection (
    PSECTION_HEADER pSection
    )
//////////////////////////////////////////////////////////////////////////////
{
    if (pSection->table_id != 0x3E)
    {
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOLEAN
ValidSnap (
    PLLC_SNAP pSnap
    )
//////////////////////////////////////////////////////////////////////////////
{

    if (pSnap->dsap != 0xAA)
    {
        return FALSE;
    }

    if (pSnap->ssap != 0xAA)
    {
        return FALSE;
    }

    if (pSnap->cntl != 0x03)
    {
        return FALSE;
    }

    if (pSnap->type != 0x0800)
    {
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
VOID
NormalizeSection (
    PBYTE pStream,
    PSECTION_HEADER pSection
    )
//////////////////////////////////////////////////////////////////////////////
{
    PBYTE   pb = pStream;
    PUSHORT ps = (PUSHORT) pStream;

    if (pSection)
    {
        pSection->table_id = *pb;

        pb += 1;
        pSection->section_syntax_indicator = (*pb >> 7) & 0x01;
        pSection->private_indicator = (*pb >> 6 )& 0x01;
        pSection->reserved1 = (*pb >> 4) & 0x03;

        ps = (PUSHORT) pb;
        pSection->section_length = ES2 (*ps) & 0x0FFF;

        pb += 2;
        pSection->MAC_address_6 = *pb;

        pb += 1;
        pSection->MAC_address_5 = *pb;

        pb += 1;
        pSection->reserved2 = (*pb >> 6) & 0x03;
        pSection->payload_scrambling = (*pb >> 4) & 0x3;
        pSection->address_scrambling = (*pb >> 2) & 0x3;
        pSection->LLC_SNAP_flag = (*pb >> 1) & 0x01;
        pSection->current_next_indicator = *pb & 0x01;

        pb += 1;
        pSection->section_number = *pb;

        pb += 1;
        pSection->last_section_number = *pb;

        pb += 1;
        pSection->MAC_address_4 = *pb;

        pb += 1;
        pSection->MAC_address_3 = *pb;

        pb += 1;
        pSection->MAC_address_2 = *pb;

        pb += 1;
        pSection->MAC_address_1 = *pb;

    }

    return;

}

//////////////////////////////////////////////////////////////////////////////
VOID
NormalizeSnap (
    PBYTE pStream,
    PLLC_SNAP pSnap
    )
//////////////////////////////////////////////////////////////////////////////
{
    PUSHORT ps = (PUSHORT) pStream;

    if (pSnap)
    {
        pSnap->type = ES2 (pSnap->type);
    }

    return;

}

//////////////////////////////////////////////////////////////////////////////
//
//
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    );


//////////////////////////////////////////////////////////////////////////////
VOID
MpeGetConnectionProperty(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream                     = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PSTREAM_PROPERTY_DESCRIPTOR pSPD    = pSrb->CommandData.PropertyInfo;
    ULONG Id                            = pSPD->Property->Id;                // index of the property
    ULONG ulStreamNumber                = pSrb->StreamObject->StreamNumber;

    pSrb->ActualBytesTransferred = 0;

    switch (Id)
    {
        case KSPROPERTY_CONNECTION_ALLOCATORFRAMING:
        {
            PKSALLOCATOR_FRAMING Framing = (PKSALLOCATOR_FRAMING) pSPD->PropertyInfo;

            Framing->RequirementsFlags   = KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY    |
                                           KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                                           KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

            Framing->PoolType            = NonPagedPool;
            Framing->Frames              = 0;
            Framing->FrameSize           = 0;
            Framing->FileAlignment       = 0;         // None OR FILE_QUAD_ALIGNMENT-1 OR PAGE_SIZE-1;
            Framing->Reserved            = 0;

            switch (ulStreamNumber)
            {
                case MPE_IPV4:
                    Framing->Frames    = 16;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                case MPE_STREAM:
                    Framing->Frames    = 32;
                    Framing->FrameSize = pStream->OpenedFormat.SampleSize;
                    pSrb->Status = STATUS_SUCCESS;
                    break;

                default:
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    break;
            }

            pSrb->ActualBytesTransferred = sizeof (KSALLOCATOR_FRAMING);
        }
        break;

        default:
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            break;
    }


    return;
}


//////////////////////////////////////////////////////////////////////////////
NTSTATUS
MpeDriverInitialize (
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   RegistryPath
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                        = STATUS_SUCCESS;
    HW_INITIALIZATION_DATA   HwInitData;
    UNICODE_STRING           DeviceNameString;
    UNICODE_STRING           SymbolicNameString;

    RtlZeroMemory(&HwInitData, sizeof(HwInitData));
    HwInitData.HwInitializationDataSize = sizeof(HwInitData);


    ////////////////////////////////////////////////////////////////
    //
    // Setup the stream class dispatch table
    //
    HwInitData.HwInterrupt                 = NULL; // HwInterrupt is only for HW devices

    HwInitData.HwReceivePacket             = CodecReceivePacket;
    HwInitData.HwCancelPacket              = CodecCancelPacket;
    HwInitData.HwRequestTimeoutHandler     = CodecTimeoutPacket;

    HwInitData.DeviceExtensionSize         = sizeof(MPE_FILTER);
    HwInitData.PerRequestExtensionSize     = sizeof(SRB_EXTENSION);
    HwInitData.FilterInstanceExtensionSize = 0;
    HwInitData.PerStreamExtensionSize      = sizeof(STREAM);
    HwInitData.BusMasterDMA                = FALSE;
    HwInitData.Dma24BitAddresses           = FALSE;
    HwInitData.BufferAlignment             = 3;
    HwInitData.TurnOffSynchronization      = TRUE;
    HwInitData.DmaBufferSize               = 0;


    ntStatus = StreamClassRegisterAdapter (DriverObject, RegistryPath, &HwInitData);
    if (ntStatus != STATUS_SUCCESS)
    {
        goto ret;
    }

ret:

    return ntStatus;
}


//
//
//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PMPE_FILTER pFilter                      = (PMPE_FILTER) pConfigInfo->HwDeviceExtension;

    //
    // Define the default return codes
    //
    pSrb->Status = STATUS_SUCCESS;
    bStatus = TRUE;

    //
    // Initialize Statistics block
    //
    RtlZeroMemory(&pFilter->Stats, sizeof (STATS));

    //
    // Check out init flag so we don't try to init more then once.  The Streaming
    // Class driver appears to call the init handler several times for some reason.
    //
    if (pFilter->bInitializationComplete)
    {
        goto ret;
    }

    if (pConfigInfo->NumberOfAccessRanges == 0)
    {
        pConfigInfo->StreamDescriptorSize = sizeof (HW_STREAM_HEADER) +
            DRIVER_STREAM_COUNT * sizeof (HW_STREAM_INFORMATION);

    }
    else
    {
        pSrb->Status = STATUS_NO_SUCH_DEVICE;
        bStatus = FALSE;
        goto ret;
    }


    //
    // Create a filter object to represent our context
    //
    pSrb->Status = CreateFilter (pConfigInfo->ClassDeviceObject->DriverObject, pConfigInfo->ClassDeviceObject, pFilter);
    if (pSrb->Status != STATUS_SUCCESS)
    {
        bStatus = FALSE;
        goto ret;
    }

    pFilter->bInitializationComplete = TRUE;

ret:

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
CodecUnInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS ntStatus                           = STATUS_SUCCESS;
    BOOLEAN bStatus                             = FALSE;
    PPORT_CONFIGURATION_INFORMATION pConfigInfo = pSrb->CommandData.ConfigInfo;
    PMPE_FILTER pFilter                      = ((PMPE_FILTER)pSrb->HwDeviceExtension);
    PSTREAM pStream                             = NULL;


    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Codec Unitialize called\n"));

    if (pSrb->StreamObject != NULL)
    {
        pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    }

    if (pStream)
    {

        //
        // Clean up the NAB_STREAM QUEUE used for deframing
        //
        //$$BUG
        //DeleteNabStreamQueue (pFilter);

        //
        // Clean up any queues we have and complete any outstanding SRB's
        //
        while (QueueRemove (&pSrb, &pFilter->StreamUserSpinLock, &pFilter->StreamContxList))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 5Completed SRB %08X\n", pSrb));

        }

        while (QueueRemove (&pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 6Completed SRB %08X\n", pSrb));
        }


        while (QueueRemove (&pSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 7Completed SRB %08X\n", pSrb));
        }


        while (QueueRemove (&pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
        {
            pSrb->Status = STATUS_CANCELLED;
            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 8Completed SRB %08X\n", pSrb));
        }

    }


    while (QueueRemove (&pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_RECV, ("MPE 9Completed SRB %08X\n", pSrb));
    }


    bStatus = TRUE;

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Codec Unitialize completed\n"));

    return (bStatus);
}


//////////////////////////////////////////////////////////////////////////////
VOID
CodecStreamInfo (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    int j;

    PMPE_FILTER pFilter =
            ((PMPE_FILTER)pSrb->HwDeviceExtension);

    //
    // pick up the pointer to header which preceeds the stream info structs
    //
    PHW_STREAM_HEADER pstrhdr =
            (PHW_STREAM_HEADER)&(pSrb->CommandData.StreamBuffer->StreamHeader);

    //
    // pick up the pointer to the array of stream information data structures
    //
    PHW_STREAM_INFORMATION pstrinfo =
            (PHW_STREAM_INFORMATION)&(pSrb->CommandData.StreamBuffer->StreamInfo);


    //
    // Set the header
    //
    StreamHeader.NumDevPropArrayEntries = 0;
    StreamHeader.DevicePropertiesArray = (PKSPROPERTY_SET)NULL;

    *pstrhdr = StreamHeader;

    //
    // stuff the contents of each HW_STREAM_INFORMATION struct
    //
    for (j = 0; j < DRIVER_STREAM_COUNT; j++)
    {
       *pstrinfo++ = Streams[j].hwStreamInfo;
    }

    pSrb->Status = STATUS_SUCCESS;

}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM  pStream = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PMPE_FILTER  pFilter = ((PMPE_FILTER)pSrb->HwDeviceExtension);

    //
    // Check whether the SRB to cancel is in use by this stream
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: CancelPacket Called\n"));

    //
    //$$BUG
    //
    //CancelNabStreamSrb (pFilter, pSrb);


    if (QueueRemoveSpecific (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 10Completed SRB %08X\n", pSrb));
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 11Completed SRB %08X\n", pSrb));
        return;
    }


    if (QueueRemoveSpecific (pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 12Completed SRB %08X\n", pSrb));
        return;
    }

    if (QueueRemoveSpecific (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue))
    {
        pSrb->Status = STATUS_CANCELLED;
        StreamClassDeviceNotification (DeviceRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 13Completed SRB %08X\n", pSrb));
        return;
    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // if we timeout while playing, then we need to consider this
    // condition an error, and reset the hardware, and reset everything
    // as well as cancelling this and all requests
    //

    //
    // if we are not playing, and this is a CTRL request, we still
    // need to reset everything as well as cancelling this and all requests
    //

    //
    // if this is a data request, and the device is paused, we probably have
    // run out of data buffer, and need more time, so just reset the timer,
    // and let the packet continue
    //

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: TimeoutPacket Called\n"));

    pSrb->TimeoutCounter = 0;

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PMPE_FILTER pFilter = ((PMPE_FILTER)pSrb->HwDeviceExtension);


    //
    // Make sure queue & SL initted
    //
    if (!pFilter->bAdapterQueueInitialized)
    {
        InitializeListHead (&pFilter->AdapterSRBQueue);
        KeInitializeSpinLock (&pFilter->AdapterSRBSpinLock);
        pFilter->bAdapterQueueInitialized = TRUE;
    }

    //
    // Assume success
    //
    pSrb->Status = STATUS_SUCCESS;

    //
    // determine the type of packet.
    //
    QueueAdd (pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue);
    TEST_DEBUG( TEST_DBG_SRB, ("MPE Queuing SRB %08X\n", pSrb));


    while (QueueRemove( &pSrb, &pFilter->AdapterSRBSpinLock, &pFilter->AdapterSRBQueue ))
    {
        switch (pSrb->Command)
        {

            case SRB_INITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_INITIALIZE Command\n"));
                CodecInitialize(pSrb);
                break;

            case SRB_UNINITIALIZE_DEVICE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_UNINITIALIZE Command\n"));
                CodecUnInitialize(pSrb);
                break;

            case SRB_INITIALIZATION_COMPLETE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_INITIALIZE_COMPLETE Command\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_OPEN_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_OPEN_STREAM Command\n"));
                OpenStream (pSrb);
                break;

            case SRB_CLOSE_STREAM:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_CLOSE_STREAM Command\n"));
                CloseStream (pSrb);
                break;

            case SRB_GET_STREAM_INFO:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_GET_STREAM_INFO Command\n"));
                CodecStreamInfo (pSrb);
                break;

            case SRB_GET_DATA_INTERSECTION:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_GET_DATA_INTERSECTION Command\n"));

                //
                // Compare our stream formats.  NOTE, the compare functions sets the SRB
                // status fields
                //
                CompareStreamFormat (pSrb);
                break;

            case SRB_OPEN_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_OPEN_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CLOSE_DEVICE_INSTANCE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_CLOSE_DEVICE_INSTANCE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_DEVICE_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_UNKNOWN_DEVICE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_CHANGE_POWER_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_CHANGE_POWER_STATE Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_GET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_GET_DEVICE_PROPERTY Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_DEVICE_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_SET_DEVICE_PROPERTY Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_UNKNOWN_STREAM_COMMAND:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_UNKNOWN Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_DEFAULT Command\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        };


        //
        // NOTE:
        //
        // All of the commands that we do, or do not understand can all be completed
        // syncronously at this point, so we can use a common callback routine here.
        // If any of the above commands require asyncronous processing, this will
        // have to change
        //

        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB Status returned: %08X\n", pSrb->Status));

        StreamClassDeviceNotification (DeviceRequestComplete, pFilter, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 14Completed SRB %08X\n", pSrb));

    }




}


//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAdd (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertTailList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueuePush (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
    KIRQL           Irql;
    PSRB_EXTENSION  pSrbExtension;

    pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

    KeAcquireSpinLock( pQueueSpinLock, &Irql );

    pSrbExtension->pSrb = pSrb;
    InsertHeadList( pQueue, &pSrbExtension->ListEntry );

    KeReleaseSpinLock( pQueueSpinLock, Irql );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueAddIfNotEmpty (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL           Irql;
   PSRB_EXTENSION  pSrbExtension;
   BOOL            bAddedSRB = FALSE;

   pSrbExtension = ( PSRB_EXTENSION )pSrb->SRBExtension;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pSrbExtension->pSrb = pSrb;
       InsertTailList (pQueue, &pSrbExtension->ListEntry );
       bAddedSRB = TRUE;
   }

   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bAddedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemove (
    IN OUT PHW_STREAM_REQUEST_BLOCK * pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL    Irql;
   BOOL     bRemovedSRB = FALSE;

   KeAcquireSpinLock (pQueueSpinLock, &Irql);

   *pSrb =  (PHW_STREAM_REQUEST_BLOCK) NULL;

   if( !IsListEmpty( pQueue ))
   {
       PHW_STREAM_REQUEST_BLOCK *pCurrentSrb = NULL;
       PUCHAR Ptr                            = (PUCHAR) RemoveHeadList(pQueue);

       pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK *) (((PUCHAR)Ptr) + sizeof (LIST_ENTRY));

       *pSrb = *pCurrentSrb;
       bRemovedSRB = TRUE;

   }

   KeReleaseSpinLock (pQueueSpinLock, Irql);

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
BOOL STREAMAPI
QueueRemoveSpecific (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    )
//////////////////////////////////////////////////////////////////////////////
{
   KIRQL Irql;
   BOOL  bRemovedSRB = FALSE;
   PLIST_ENTRY pCurrentEntry;
   PHW_STREAM_REQUEST_BLOCK * pCurrentSrb;

   KeAcquireSpinLock( pQueueSpinLock, &Irql );

   if( !IsListEmpty( pQueue ))
   {
       pCurrentEntry = pQueue->Flink;
       while ((pCurrentEntry != pQueue ) && !bRemovedSRB)
       {
           pCurrentSrb = (PHW_STREAM_REQUEST_BLOCK * ) ((( PUCHAR )pCurrentEntry ) + sizeof( LIST_ENTRY ));

           if( *pCurrentSrb == pSrb )
           {
               RemoveEntryList( pCurrentEntry );
               bRemovedSRB = TRUE;
           }
           pCurrentEntry = pCurrentEntry->Flink;
       }
   }
   KeReleaseSpinLock( pQueueSpinLock, Irql );

   return bRemovedSRB;
}

//////////////////////////////////////////////////////////////////////////////
NTSTATUS
StreamIPIndicateEvent (
    PVOID pvEvent
)
//////////////////////////////////////////////////////////////////////////////
{
    return STATUS_NOT_IMPLEMENTED;
}



//////////////////////////////////////////////////////////////////////////////
BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL bResult = FALSE;

    if ( IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange2->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
         IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) )
    {

        if ( IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange2->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
             IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) )
        {

            if ( IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange2->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                 IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) )
            {
                if ( !bCheckSize || pDataRange1->FormatSize == pDataRange2->FormatSize)
                {
                    bResult = TRUE;
                }
            }
        }
    }

    return bResult;

}

//////////////////////////////////////////////////////////////////////////////
VOID
DumpDataFormat (
    PKSDATAFORMAT   pF
    )
//////////////////////////////////////////////////////////////////////////////
{
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: DATA Format\n"));
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Format Size:   %08X\n", pF->FormatSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Flags:         %08X\n", pF->Flags));
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     SampleSize:    %08X\n", pF->SampleSize));
    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Reserved:      %08X\n", pF->Reserved));



    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Major GUID:  %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->MajorFormat.Data1,
                                                pF->MajorFormat.Data2,
                                                pF->MajorFormat.Data3,
                                                pF->MajorFormat.Data4[0],
                                                pF->MajorFormat.Data4[1],
                                                pF->MajorFormat.Data4[2],
                                                pF->MajorFormat.Data4[3],
                                                pF->MajorFormat.Data4[4],
                                                pF->MajorFormat.Data4[5],
                                                pF->MajorFormat.Data4[6],
                                                pF->MajorFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Sub GUID:    %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->SubFormat.Data1,
                                                pF->SubFormat.Data2,
                                                pF->SubFormat.Data3,
                                                pF->SubFormat.Data4[0],
                                                pF->SubFormat.Data4[1],
                                                pF->SubFormat.Data4[2],
                                                pF->SubFormat.Data4[3],
                                                pF->SubFormat.Data4[4],
                                                pF->SubFormat.Data4[5],
                                                pF->SubFormat.Data4[6],
                                                pF->SubFormat.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE:     Specifier:   %08X %04X %04X %02X %02X %02X %02X %02X %02X %02X %02X\n",
                                                pF->Specifier.Data1,
                                                pF->Specifier.Data2,
                                                pF->Specifier.Data3,
                                                pF->Specifier.Data4[0],
                                                pF->Specifier.Data4[1],
                                                pF->Specifier.Data4[2],
                                                pF->Specifier.Data4[3],
                                                pF->Specifier.Data4[4],
                                                pF->Specifier.Data4[5],
                                                pF->Specifier.Data4[6],
                                                pF->Specifier.Data4[7]
                                ));

    TEST_DEBUG (TEST_DBG_TRACE, ("\n"));
}


//////////////////////////////////////////////////////////////////////////////
BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOL                        bStatus = FALSE;
    PSTREAM_DATA_INTERSECT_INFO pIntersectInfo;
    PKSDATARANGE                pDataRange1;
    PKSDATARANGE                pDataRange2;
    ULONG                       FormatSize = 0;
    ULONG                       ulStreamNumber;
    ULONG                       j;
    ULONG                       ulNumberOfFormatArrayEntries;
    PKSDATAFORMAT               *pAvailableFormats;


    pIntersectInfo = pSrb->CommandData.IntersectInfo;
    ulStreamNumber = pIntersectInfo->StreamNumber;


    pSrb->ActualBytesTransferred = 0;


    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Comparing Stream Formats\n"));


    //
    // Check that the stream number is valid
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT)
    {
        ulNumberOfFormatArrayEntries = Streams[ulStreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;

        //
        // Get the pointer to the array of available formats
        //
        pAvailableFormats = Streams[ulStreamNumber].hwStreamInfo.StreamFormatsArray;

        //
        // Walk the formats supported by the stream searching for a match
        // of the three GUIDs which together define a DATARANGE
        //
        for (pDataRange1 = pIntersectInfo->DataRange, j = 0;
             j < ulNumberOfFormatArrayEntries;
             j++, pAvailableFormats++)

        {
            bStatus = FALSE;
            pSrb->Status = STATUS_UNSUCCESSFUL;

            pDataRange2 = *pAvailableFormats;

            if (CompareGUIDsAndFormatSize (pDataRange1, pDataRange2, TRUE))
            {

                ULONG   ulFormatSize = pDataRange2->FormatSize;

                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Stream Formats compare\n"));

                //
                // Is the caller trying to get the format, or the size of the format?
                //
                if (pIntersectInfo->SizeOfDataFormatBuffer == sizeof (ULONG))
                {
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Returning Stream Format size\n"));

                    *(PULONG) pIntersectInfo->DataFormatBuffer = ulFormatSize;
                    pSrb->ActualBytesTransferred = sizeof (ULONG);
                    pSrb->Status = STATUS_SUCCESS;
                    bStatus = TRUE;
                }
                else
                {
                    //
                    // Verify that there is enough room in the supplied buffer for the whole thing
                    //
                    pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                    bStatus = FALSE;

                    if (pIntersectInfo->SizeOfDataFormatBuffer >= ulFormatSize)
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Returning Stream Format\n"));
                        RtlCopyMemory (pIntersectInfo->DataFormatBuffer, pDataRange2, ulFormatSize);
                        pSrb->ActualBytesTransferred = ulFormatSize;
                        pSrb->Status = STATUS_SUCCESS;
                        bStatus = TRUE;
                    }
                    else
                    {
                        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Stream Format return buffer too small\n"));
                    }
                }
                break;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Stream Formats DO NOT compare\n"));
            }
        }

        if ( j >= ulNumberOfFormatArrayEntries )
        {
            pSrb->ActualBytesTransferred = 0;
            pSrb->Status = STATUS_UNSUCCESSFUL;
            bStatus = FALSE;
        }

    }
    else
    {
        pSrb->ActualBytesTransferred = 0;
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
        bStatus = FALSE;
    }

    return bStatus;
}


//////////////////////////////////////////////////////////////////////////////
VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream                = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PMPE_FILTER  pFilter                = (PMPE_FILTER)pSrb->HwDeviceExtension;
    ULONG           ulStreamNumber         = (ULONG) pSrb->StreamObject->StreamNumber;
    ULONG           ulStreamInstance       = pStream->ulStreamInstance;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb   = NULL;

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("MPE 15Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Flush the stream data queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->StreamDataSpinLock, &pFilter->StreamDataQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification( StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("MPE 16Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Flush the stream control queue
        //
        while (QueueRemove( &pCurrentSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
        {
           pCurrentSrb->Status = STATUS_CANCELLED;
           StreamClassStreamNotification (StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
           TEST_DEBUG( TEST_DBG_SRB, ("MPE 17Completed SRB %08X\n", pCurrentSrb));
        }

        //
        // Clear this streams spot in the filters stream array
        //
        pFilter->pStream[ulStreamNumber][ulStreamInstance] = NULL;

        //
        // decrement the stream instance count for this filter
        //
        pFilter->ulActualInstances[ulStreamNumber]--;

        //
        // Indicate the clock support available on this stream
        //
        //pSrb->StreamObject->HwClockObject = 0;

        //
        // Reset the stream state to stopped
        //
        pStream->KSState = KSSTATE_STOP;

        //
        //
        //
        pStream->hMasterClock = NULL;

        //
        // Cleanup the streams transform buffer
        //
        if (pStream->pTransformBuffer)
        {
            ExFreePool (pStream->pTransformBuffer);
            pStream->pTransformBuffer = NULL;
        }

        //
        // Reset the stream extension blob
        //
        RtlZeroMemory(pStream, sizeof (STREAM));

        pSrb->Status = STATUS_SUCCESS;

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    //
    // the stream extension structure is allocated by the stream class driver
    //
    PSTREAM         pStream        = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    PMPE_FILTER    pFilter        = ((PMPE_FILTER)pSrb->HwDeviceExtension);
    ULONG           ulStreamNumber = (ULONG) pSrb->StreamObject->StreamNumber;
    PKSDATAFORMAT   pKSDataFormat  = (PKSDATAFORMAT)pSrb->CommandData.OpenFormat;

    //
    // Initialize the stream extension blob
    //
    //RtlZeroMemory(pStream, sizeof (STREAM));

    //
    // Initialize stream state
    //
    //pStream->KSState = KSSTATE_STOP;

    //
    // Initialize the next stream life check time.
    //
    KeQuerySystemTime( &pFilter->liLastTimeChecked );

    //
    // check that the stream index requested isn't too high
    // or that the maximum number of instances hasn't been exceeded
    //
    if (ulStreamNumber < DRIVER_STREAM_COUNT )
    {
        ULONG ulStreamInstance;
        ULONG ulMaxInstances = Streams[ulStreamNumber].hwStreamInfo.NumberOfPossibleInstances;

        //
        // Search for next open slot
        //
        for (ulStreamInstance = 0; ulStreamInstance < ulMaxInstances; ++ulStreamInstance)
        {
            if (pFilter->pStream[ulStreamNumber][ulStreamInstance] == NULL)
            {
                break;
            }
        }

        if (ulStreamInstance < ulMaxInstances)
        {
            if (VerifyFormat(pKSDataFormat, ulStreamNumber, &pStream->MatchedFormat))
            {
                //
                // Initialize Data queues and SpinLocks
                //
                InitializeListHead(&pFilter->StreamControlQueue);
                KeInitializeSpinLock(&pFilter->StreamControlSpinLock);

                InitializeListHead(&pFilter->StreamDataQueue);
                KeInitializeSpinLock(&pFilter->StreamDataSpinLock);

                InitializeListHead(&pFilter->IpV4StreamDataQueue);
                KeInitializeSpinLock(&pFilter->IpV4StreamDataSpinLock);

                InitializeListHead(&pFilter->StreamContxList);
                KeInitializeSpinLock(&pFilter->StreamUserSpinLock);


                //
                // Maintain an array of all the StreamEx structures in the HwDevExt
                // so that we can reference IRPs from any stream
                //
                pFilter->pStream[ulStreamNumber][ulStreamInstance] = pStream;

                //
                // Save the Stream Format in the Stream Extension as well.
                //
                pStream->OpenedFormat = *pKSDataFormat;

                //
                // Set up pointers to the handlers for the stream data and control handlers
                //
                pSrb->StreamObject->ReceiveDataPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveDataPacket;
                pSrb->StreamObject->ReceiveControlPacket =
                                                (PVOID) Streams[ulStreamNumber].hwStreamObject.ReceiveControlPacket;

                //
                // The DMA flag must be set when the device will be performing DMA directly
                // to the data buffer addresses passed in to the ReceiveDataPacket routines.
                //
                pSrb->StreamObject->Dma = Streams[ulStreamNumber].hwStreamObject.Dma;

                //
                // The PIO flag must be set when the mini driver will be accessing the data
                // buffers passed in using logical addressing
                //
                pSrb->StreamObject->Pio = Streams[ulStreamNumber].hwStreamObject.Pio;

                pSrb->StreamObject->Allocator = Streams[ulStreamNumber].hwStreamObject.Allocator;

                //
                // How many extra bytes will be passed up from the driver for each frame?
                //
                pSrb->StreamObject->StreamHeaderMediaSpecific =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderMediaSpecific;

                pSrb->StreamObject->StreamHeaderWorkspace =
                                        Streams[ulStreamNumber].hwStreamObject.StreamHeaderWorkspace;

                //
                // Indicate the clock support available on this stream
                //
                pSrb->StreamObject->HwClockObject =
                                        Streams[ulStreamNumber].hwStreamObject.HwClockObject;

                //
                // Increment the instance count on this stream
                //
                pStream->ulStreamInstance = ulStreamInstance;
                pFilter->ulActualInstances[ulStreamNumber]++;

                //
                // Allocate a transform buffer
                //
                pStream->pTransformBuffer = ExAllocatePool (NonPagedPool, sizeof(SECTION_HEADER) + 4096);

                if (pStream->pTransformBuffer == NULL)
                {
                    pSrb->Status = STATUS_NO_MEMORY;
                    return;
                }

                RtlZeroMemory (pStream->pTransformBuffer, sizeof(SECTION_HEADER) + 4096);

                //
                // Initalize persistent pointer to output buffer to NULL
                //
                pStream->pOut = NULL;

                //
                // Initialize the exepected section number to zero
                //
                pStream->bExpectedSection = 0;


                //
                // Retain a private copy of the HwDevExt and StreamObject in the stream extension
                // so we can use a timer
                //
                pStream->pFilter = pFilter;                     // For timer use
                pStream->pStreamObject = pSrb->StreamObject;        // For timer use


                pSrb->Status = STATUS_SUCCESS;

            }
            else
            {
                pSrb->Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            pSrb->Status = STATUS_INVALID_PARAMETER;
        }

    }
    else
    {
        pSrb->Status = STATUS_INVALID_PARAMETER;
    }
}


//////////////////////////////////////////////////////////////////////////////
BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    )
//////////////////////////////////////////////////////////////////////////////
{
    BOOLEAN   bResult               = FALSE;
    ULONG     FormatCount           = 0;
    PKS_DATARANGE_VIDEO pThisFormat = NULL;

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Verify Format\n"));

    for (FormatCount = 0; !bResult && FormatCount < Streams[StreamNumber].hwStreamInfo.NumberOfFormatArrayEntries;
         FormatCount++ )
    {


        pThisFormat = (PKS_DATARANGE_VIDEO) Streams [StreamNumber].hwStreamInfo.StreamFormatsArray [FormatCount];

        if (CompareGUIDsAndFormatSize( pKSDataFormat, &pThisFormat->DataRange, FALSE ) )
        {
            bResult = FALSE;

            if (pThisFormat->DataRange.SampleSize >= pKSDataFormat->SampleSize)
            {
                bResult = TRUE;
            }
            else
            {
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: VerifyFormat: Data range Sample Sizes don't match\n"));
            }
        }
    }

    if (bResult == TRUE && pMatchedFormat)
    {
        *pMatchedFormat = pThisFormat->DataRange;
    }

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
GetOutputBuffer (
    PMPE_FILTER pFilter,
    PHW_STREAM_REQUEST_BLOCK *ppSrb,
    PUCHAR *ppBuffer,
    PULONG pulSize
    )
///////////////////////////////////////////////////////////////////////////////////////
{
    NTSTATUS status                   = STATUS_INSUFFICIENT_RESOURCES;
    PKSSTREAM_HEADER  pStreamHdr      = NULL;
    PHW_STREAM_REQUEST_BLOCK pSrb     = NULL;



    if (QueueRemove( &pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
    {

        pStreamHdr = pSrb->CommandData.DataBufferArray;

        *ppSrb    = pSrb;
        *ppBuffer = pStreamHdr->Data;
        *pulSize  = pStreamHdr->FrameExtent;

        status = STATUS_SUCCESS;

    }

    return status;
}

//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PMPE_FILTER       pFilter         = (PMPE_FILTER) pSrb->HwDeviceExtension;
    PSTREAM           pStream         = (PSTREAM)pSrb->StreamObject->HwStreamExtension;
    int               iStream         = (int) pSrb->StreamObject->StreamNumber;
    PKSSTREAM_HEADER  pStreamHdr      = pSrb->CommandData.DataBufferArray;
    PKSDATAFORMAT     pKSDataFormat   = (PKSDATAFORMAT) &pStream->MatchedFormat;
    ULONG             ul              = 0;
    PHW_STREAM_REQUEST_BLOCK pOutSrb  = NULL;
    SECTION_HEADER    Section         = {0};
    PSECTION_HEADER   pSection        = NULL;
    PUCHAR            pIn             = NULL;
    PLLC_SNAP         pSnap           = NULL;
    ULONG             ulSize          = 0;
    ULONG             ulLength        = 0;

    PHEADER_IP        pIP             = NULL;


    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called\n"));

    //
    // Default to success, disable timeouts
    //
    pSrb->TimeoutCounter = 0;
    pSrb->Status = STATUS_SUCCESS;

    //
    // Check for last buffer
    //
    if (pStreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet is LAST PACKET\n"));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 18Completed SRB %08X\n", pSrb));

        return;
    }


    if (pStreamHdr->OptionsFlags != 0)
    {
        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: OptionsFlags: %08X\n", pStreamHdr->OptionsFlags));
    }


    //
    // determine the type of packet.
    //
    switch (pSrb->Command)
    {
        case SRB_WRITE_DATA:


            if (pStream->KSState == KSSTATE_STOP)
            {
                pSrb->Status = STATUS_SUCCESS;

                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_WRITE STOP SRB Status returned: %08X\n", pSrb->Status));

                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 19Completed SRB %08X\n", pSrb));

                break;
            }

            //
            // Update the total number of packets written statistic
            //
            pFilter->Stats.ulTotalSectionsWritten += 1;


            //
            // Handle data input, output requests differently.
            //
            switch (iStream)
            {
                //
                //  Frame input stream
                //
                case MPE_STREAM:
                {
                    ULONG             ulBuffers        = pSrb->NumberOfBuffers;
                    ULONG             ulSkip           = 0;

                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler - SRB_WRITE - MPE_STREAM\n"));

                    //
                    // Initialize SRB Status to success
                    //
                    pSrb->Status = STATUS_SUCCESS;

                    //
                    // copy the contents of all buffers into one big buffer
                    //
                    ASSERT( ulBuffers == 1);
                    for (ul = 0; ul < ulBuffers; ul++, pStreamHdr++)
                    {
                        ASSERT( pStreamHdr);
                        ASSERT( pStreamHdr->DataUsed <= (sizeof(SECTION_HEADER) + 4096));
                        if (   pStreamHdr
                            && (pStreamHdr->DataUsed <= (sizeof(SECTION_HEADER) + 4096))
                           )
                        {
                            //
                            // Copy the data
                            //
                            RtlCopyMemory (pStream->pTransformBuffer,
                                           pStreamHdr->Data,
                                           pStreamHdr->DataUsed
                                           );
                        }
                    }

                    //
                    // Process the transform buffer
                    //
                    pSection = (PSECTION_HEADER) pStream->pTransformBuffer;
                    NormalizeSection (pStream->pTransformBuffer, &Section);

                    //
                    // Do a quick check of the section header to confirm it looks valid
                    //
                    if (! ValidSection (&Section))
                    {
                        //  Ignore non-MPE sections
                        //
                        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                        pStream->bExpectedSection = 0;

                        pFilter->Stats.ulTotalInvalidSections += 1;

                        //
                        // Since we're discarding the data at this point, we'll re-queue the output
                        // SRB and re-use it when we get re-synched.
                        //
                        if (pOutSrb)
                        {
                            //$REVIEW - Can this cause out of order completion of sections.
                            //
                            QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                        }
                        pStream->pOut = NULL;
                        pOutSrb = NULL;
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Invalid TableID", pSrb));
                        break;
                    }

                    //
                    // Update our UnNormalized section header with our normalized one.
                    //
                    RtlCopyMemory (pStream->pTransformBuffer, &Section, sizeof (SECTION_HEADER));

                    //
                    // Check our section number and see if it's what we expect
                    //
                    if (pSection->section_number != pStream->bExpectedSection)
                    {
                        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                        pStream->bExpectedSection = 0;

                        pFilter->Stats.ulTotalUnexpectedSections += 1;

                        //
                        // Since we're discarding the data at this point, we'll re-queue the output
                        // SRB and re-use it when we get re-synched.
                        //
                        if (pOutSrb)
                        {
                            //$REVIEW - Can this cause out of order completion of sections.
                            //
                            QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                        }
                        pStream->pOut = NULL;
                        pOutSrb = NULL;
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Invalid section_number", pSrb));
                        break;
                    }

                    //
                    // Process the 1st section
                    //
                    if (pSection->section_number == 0)
                    {
                        PMAC_Address pMAC = NULL;

                        //
                        // Initialize packet length to zero
                        //
                        ulLength = 0;

                        //
                        //
                        //
                        if (GetOutputBuffer (pFilter, &pOutSrb, &pStream->pOut, &ulSize) != STATUS_SUCCESS)
                        {
                            //
                            // Failure....no buffers available most likely
                            //
                            pFilter->Stats.ulTotalUnavailableOutputBuffers += 1;
                            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                            TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Can't get SRB for output pin", pSrb));
                            break;
                        }

                        if (ulSize < (pSection->section_length - (sizeof (SECTION_HEADER) - 3)))
                        {
                            StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                            pStream->bExpectedSection = 0;
                            pFilter->Stats.ulTotalOutputBuffersTooSmall += 1;

                            //
                            // Since we're discarding the data at this point, we'll re-queue the output
                            // SRB and re-use it when we get re-synched.
                            //
                            if (pOutSrb)
                            {
                                //$REVIEW - Can this cause out of order completion of sections.
                                //
                                QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                            }
                            pStream->pOut = NULL;
                            pOutSrb = NULL;

                            TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Section too big", pSrb));
                            break;
                        }

                        pIP = (PHEADER_IP) pSection->Data;
                        if (pSection->LLC_SNAP_flag == 0x1)
                        {
                            pSnap = (PLLC_SNAP) pSection->Data;
                            pIP = (PHEADER_IP) pSnap->Data;
                            ulSkip = sizeof( LLC_SNAP);
                        }

                        //
                        // Add the MAC address to the buffer.  The MAC address prefix's the IP packet
                        //
                        pMAC = (PMAC_Address) pStream->pOut;
                        pMAC->MAC_Dest_Address [0] = pSection->MAC_address_1;
                        pMAC->MAC_Dest_Address [1] = pSection->MAC_address_2;
                        pMAC->MAC_Dest_Address [2] = pSection->MAC_address_3;
                        pMAC->MAC_Dest_Address [3] = pSection->MAC_address_4;
                        pMAC->MAC_Dest_Address [4] = pSection->MAC_address_5;
                        pMAC->MAC_Dest_Address [5] = pSection->MAC_address_6;

                        pMAC->MAC_Src_Address [0] = 0x00;
                        pMAC->MAC_Src_Address [1] = 0x00;
                        pMAC->MAC_Src_Address [2] = 0x00;
                        pMAC->MAC_Src_Address [3] = 0x00;
                        pMAC->MAC_Src_Address [4] = 0x00;
                        pMAC->MAC_Src_Address [5] = 0x00;

                        pMAC->usLength = 0x0008;

                        //
                        // Adjust pointer to output buffer where we'll put data
                        //
                        pStream->pOut += sizeof (MAC_Address);

                        pIn = pSection->Data;

                        if (pSection->LLC_SNAP_flag == 0x1)
                        {
                            pSnap = (PLLC_SNAP) pSection->Data;

                            if (pSnap->type != 0x0008)
                            {
                                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);

                                //
                                // Next expected Section should be zero
                                //
                                pStream->bExpectedSection = 0;
                                pFilter->Stats.ulTotalInvalidIPSnapHeaders += 1;

                                //
                                // Since we're discarding the data at this point, we'll re-queue the output
                                // SRB and re-use it when we get re-synched.
                                //
                                if (pOutSrb)
                                {
                                    //$REVIEW - Can this cause out of order completion of sections.
                                    //
                                    QueuePush (pOutSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                                }
                                pStream->pOut = NULL;
                                pOutSrb = NULL;

                                TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Bad Snap Type", pSrb));
                                break;
                            }

                            pIn = pSnap->Data;

                        }

                        ulLength = sizeof (MAC_Address);
                    }

                    //
                    // pOut should be NULL unless we've found the 1st section.
                    //
                    if (pStream->pOut)
                    {
                        ULONG ulTmp = 0;
                        PKSSTREAM_HEADER  pOutStreamHdr;

                        //
                        // Update the datasize field of the Output SRB
                        //
                        pOutStreamHdr = (PKSSTREAM_HEADER) pOutSrb->CommandData.DataBufferArray;


                        //
                        // Copy data from transform section to output SRB buffer
                        //
                        // Compute the number of bytes to copy.  We subtract of 9 bytes
                        // only if this is a LLSNAP packet.
                        //
                        ulTmp  = pSection->section_length;
                        ulTmp -= ulSkip;

                        RtlCopyMemory (pStream->pOut, pIn, ulTmp);

                        ulLength += ulTmp;

                        pOutStreamHdr->DataUsed += ulLength;

                        ulLength = 0;
                    }

                    if (pSection->section_number == pSection->last_section_number)
                    {

                        pFilter->Stats.ulTotalIPPacketsWritten += 1;

                        pOutSrb->Status = STATUS_SUCCESS;
                        StreamClassStreamNotification (StreamRequestComplete, pOutSrb->StreamObject, pOutSrb);
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n", pSrb));

                        pOutSrb = NULL;
                        pStream->pOut    = NULL;
                        ulSize  = 0;
                    }


                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG( TEST_DBG_SRB, ("MPE 20Completed SRB %08X\n - Packet Sent", pSrb));

                }
                break;


                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - SRB_WRITE - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;

                    //
                    // Update stats for Unkown packet count
                    //
                    pFilter->Stats.ulTotalUnknownPacketsWritten += 1;

                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: DEFAULT SRB Status returned: %08X\n", pSrb->Status));

                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG( TEST_DBG_SRB, ("MPE 22Completed SRB %08X\n", pSrb));

                    break;
            }
            break;


        case SRB_READ_DATA:

            if (pStream->KSState == KSSTATE_STOP)
            {
                pSrb->Status = STATUS_SUCCESS;
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 23Completed SRB %08X\n", pSrb));

                break;
            }

            //
            // Update stats for Unkown packet count
            //
            pFilter->Stats.ulTotalPacketsRead += 1;

            switch (iStream)
            {
                #ifdef OLD

                case MPE_NET_CONTROL:
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - SRB_READ - STREAM_NET_CONTROL\n"));
                    pSrb->Status = STATUS_SUCCESS;
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: MPE_NET_CONTROL SRB Status returned: %08X\n", pSrb->Status));
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG( TEST_DBG_SRB, ("MPE 24Completed SRB %08X\n", pSrb));
                    break;

                #endif

                case MPE_IPV4:
                {
                    ULONG             ulBuffers       = pSrb->NumberOfBuffers;

                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - SRB_READ - MPE_IPV4\n"));

                    if (pSrb->CommandData.DataBufferArray->FrameExtent < pKSDataFormat->SampleSize)
                    {
                        pSrb->Status = STATUS_BUFFER_TOO_SMALL;
                        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: MPE_IPV4 SRB Buffer too small.... Status returned: %08X\n", pSrb->Status));
                        StreamClassStreamNotification(StreamRequestComplete, pSrb->StreamObject, pSrb);
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE 25Completed SRB %08X\n", pSrb));
                    }
                    else
                    {
                        //
                        // Take the SRB we get and  queue it up.  These Queued SRB's will be filled with data on a WRITE_DATA
                        // request, at which point they will be completed.
                        //
                        QueueAdd (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue);
                        TEST_DEBUG( TEST_DBG_SRB, ("MPE Queuing IPv4 SRB %08X\n", pSrb));


                        //
                        // Since the stream state may have changed while we were adding the SRB to the queue
                        // we'll check it again, and cancel it if necessary
                        //
                        if (pStream->KSState == KSSTATE_STOP)
                        {
                            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB_READ STOP SRB Status returned: %08X\n", pSrb->Status));

                            if (QueueRemoveSpecific (pSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
                            {
                                pSrb->Status = STATUS_CANCELLED;
                                StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb );
                                TEST_DEBUG( TEST_DBG_SRB, ("MPE 26Completed SRB %08X\n", pSrb));
                                return;
                            }
                            break;
                        }
                    }
                }
                break;


                default:
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - SRB_READ - Default\n"));
                    pSrb->Status = STATUS_NOT_IMPLEMENTED;
                    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: DEFAULT SRB Status returned: %08X\n", pSrb->Status));
                    StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
                    TEST_DEBUG( TEST_DBG_SRB, ("MPE 27Completed SRB %08X\n", pSrb));
                    break;

            }
            break;

        default:

            //
            // invalid / unsupported command. Fail it as such
            //
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called - Unsupported Command\n"));
            pSrb->Status = STATUS_NOT_IMPLEMENTED;
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: DEFAULT SRB Status returned: %08X\n", pSrb->Status));
            StreamClassStreamNotification( StreamRequestComplete, pSrb->StreamObject, pSrb );
            TEST_DEBUG( TEST_DBG_SRB, ("MPE 28Completed SRB %08X\n", pSrb));
            ASSERT (FALSE);
            break;

    }


    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Data packet handler called...status: %08X\n", pSrb->Status));

    return;
}



//////////////////////////////////////////////////////////////////////////////
VOID
MpeGetProperty (
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM_PROPERTY_DESCRIPTOR pSPD = pSrb->CommandData.PropertyInfo;

    pSrb->Status = STATUS_SUCCESS;

    if (IsEqualGUID (&KSPROPSETID_Connection, &pSPD->Property->Set))
    {
        MpeGetConnectionProperty (pSrb);
    }
    else
    {
        pSrb->Status = STATUS_NOT_IMPLEMENTED;
    }

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: MpeGetProperty Status: %08X\n", pSrb->Status));

    return;
}


//////////////////////////////////////////////////////////////////////////////
VOID
IndicateMasterClock(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    pStream->hClock = pSrb->CommandData.MasterClockHandle;
}

//////////////////////////////////////////////////////////////////////////////
VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PMPE_FILTER pFilter = (PMPE_FILTER) pSrb->HwDeviceExtension;
    PSTREAM pStream = (PSTREAM) pSrb->StreamObject->HwStreamExtension;

    TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler called\n"));

    pSrb->Status = STATUS_SUCCESS;

    QueueAdd (pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue);
    TEST_DEBUG( TEST_DBG_SRB, ("MPE Queuing Control Packet SRB %08X\n", pSrb));

    while (QueueRemove (&pSrb, &pFilter->StreamControlSpinLock, &pFilter->StreamControlQueue))
    {
        //
        // determine the type of packet.
        //
        switch (pSrb->Command)
        {
            case SRB_PROPOSE_DATA_FORMAT:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Propose data format\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_SET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Set Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                MpeSetState (pSrb);
                break;

            case SRB_GET_STREAM_STATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Get Stream State\n"));
                pSrb->Status = STATUS_SUCCESS;
                pSrb->CommandData.StreamState = pStream->KSState;
                pSrb->ActualBytesTransferred = sizeof (KSSTATE);
                break;

            case SRB_GET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Get Stream Property\n"));
                MpeGetProperty(pSrb);
                break;

            case SRB_SET_STREAM_PROPERTY:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Set Stream Property\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

            case SRB_INDICATE_MASTER_CLOCK:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Indicate Master Clock\n"));
                pSrb->Status = STATUS_SUCCESS;
                IndicateMasterClock (pSrb);
                break;

            case SRB_SET_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Set Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            case SRB_PROPOSE_STREAM_RATE:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Propose Stream Rate\n"));
                pSrb->Status = STATUS_SUCCESS;
                break;

            default:
                TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Receive Control packet handler - Default case\n"));
                pSrb->Status = STATUS_NOT_IMPLEMENTED;
                break;

        }

        TEST_DEBUG (TEST_DBG_TRACE, ("MPE: SRB Status returned: %08X\n", pSrb->Status));

        StreamClassStreamNotification (StreamRequestComplete, pSrb->StreamObject, pSrb);
        TEST_DEBUG( TEST_DBG_SRB, ("MPE 29Completed SRB %08X\n", pSrb));

    }

}



//////////////////////////////////////////////////////////////////////////////
VOID
MpeSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    )
//////////////////////////////////////////////////////////////////////////////
{
    PMPE_FILTER pFilter                 = ((PMPE_FILTER) pSrb->HwDeviceExtension);
    PSTREAM pStream                      = (PSTREAM) pSrb->StreamObject->HwStreamExtension;
    PHW_STREAM_REQUEST_BLOCK pCurrentSrb = NULL;

    //
    // For each stream, the following states are used:
    //
    // Stop:    Absolute minimum resources are used.  No outstanding IRPs.
    // Acquire: KS only state that has no DirectShow correpondence
    //          Acquire needed resources.
    // Pause:   Getting ready to run.  Allocate needed resources so that
    //          the eventual transition to Run is as fast as possible.
    //          Read SRBs will be queued at either the Stream class
    //          or in your driver (depending on when you send "ReadyForNext")
    // Run:     Streaming.
    //
    // Moving to Stop to Run always transitions through Pause.
    //
    // But since a client app could crash unexpectedly, drivers should handle
    // the situation of having outstanding IRPs cancelled and open streams
    // being closed WHILE THEY ARE STREAMING!
    //
    // Note that it is quite possible to transition repeatedly between states:
    // Stop -> Pause -> Stop -> Pause -> Run -> Pause -> Run -> Pause -> Stop
    //
    switch (pSrb->CommandData.StreamState)
    {
        case KSSTATE_STOP:

            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Set Stream State KSSTATE_STOP\n"));

            //
            // If transitioning to STOP state, then complete any outstanding IRPs
            //
            while (QueueRemove(&pCurrentSrb, &pFilter->IpV4StreamDataSpinLock, &pFilter->IpV4StreamDataQueue))
            {
                pCurrentSrb->Status = STATUS_CANCELLED;
                pCurrentSrb->CommandData.DataBufferArray->DataUsed = 0;

                StreamClassStreamNotification(StreamRequestComplete, pCurrentSrb->StreamObject, pCurrentSrb);
                TEST_DEBUG( TEST_DBG_SRB, ("MPE 30Completed SRB %08X\n", pCurrentSrb));
            }

            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;


        case KSSTATE_ACQUIRE:
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Set Stream State KSSTATE_ACQUIRE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_PAUSE:
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Set Stream State KSSTATE_PAUSE\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

        case KSSTATE_RUN:
            TEST_DEBUG (TEST_DBG_TRACE, ("MPE: Set Stream State KSSTATE_RUN\n"));
            pStream->KSState = pSrb->CommandData.StreamState;
            pSrb->Status = STATUS_SUCCESS;
            break;

    } // end switch (pSrb->CommandData.StreamState)

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\mpemedia.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MY_MEDIA_H__
#define __MY_MEDIA_H__


#ifdef DEFINE_GUIDEX
#undef DEFINE_GUIDEX
#include <ksguid.h>
#endif

//===========================================================================
//
// IPSink PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_IPSINK_INPUT \
    0x3fdffa70L, 0xac9a, 0x11d2, 0x8f, 0x17, 0x00, 0xc0, 0x4f, 0x79, 0x71, 0xe2
DEFINE_GUIDSTRUCT("3fdffa70-ac9a-11d2-8f17-00c04f7971e2", PINNAME_IPSINK_INPUT);
#define PINNAME_IPSINK_INPUT   DEFINE_GUIDNAMED(PINNAME_IPSINK_INPUT)


//===========================================================================
//
// MPE PINNAME GUID
//
//===========================================================================

#define STATIC_PINNAME_MPE \
    0xc1b06d73L, 0x1dbb, 0x11d3, 0x8f, 0x46, 0x00, 0xC0, 0x4f, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("C1B06D73-1DBB-11d3-8F46-00C04F7971E2", PINNAME_MPE);
#define PINNAME_MPE   DEFINE_GUIDNAMED(PINNAME_MPE)


/////////////////////////////////////////////////////////////
//
// Mpe Data Format structure
//
typedef struct tagKS_DATAFORMAT_MPE
{
   KSDATAFORMAT                 DataFormat;

} KS_DATAFORMAT_MPE, *PKS_DATAFORMAT_MPE;




#endif // __MY_MEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\mpe.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      Mpe.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _MPE_H_
#define _MPE_H_

#define ENTRIES(a)  (sizeof(a)/sizeof(*(a)))

///////////////////////////////////////////////////////////////////////////////
//
//
#define MPENAME            "MPE"
#define MPENAMEUNICODE    L"MPE"

///////////////////////////////////////////////////////////////////////////////
//
// This defines the name of the WMI device that manages service IOCTLS
//
#define CodecDeviceName   (L"\\\\.\\" MPENAMEUNICODE)
#define CodecSymbolicName (L"\\DosDevices\\" MPENAMEUNICODE)


///////////////////////////////////////////////////////////////////////////////
//
//
typedef struct
{
    ULONG ulSize;
    UCHAR data;

} MPE_BUFFER, *PMPE_BUFFER;


///////////////////////////////////////////////////////////////////////////////
//
//
typedef enum
{
    MPE_STREAM = 0,
    MPE_IPV4

} MPE_STREAMS;

///////////////////////////////////////////////////////////////////////////////
//
// The MAX_STREAM_COUNT value must be equal to DRIVER_STREAM_COUNT
// This particular value must be defined here to avoid circular references
//
#define MAX_STREAM_COUNT    DRIVER_STREAM_COUNT

///////////////////////////////////////////////////////////////////////////////
//
// We manage multiple instances of each pin up to this limit
//
#define MAX_PIN_INSTANCES   8
#define BIT(n)              (1L<<(n))
#define BITSIZE(v)          (sizeof(v)*8)
#define SETBIT(array,n)     (array[n/BITSIZE(*array)] |= BIT(n%BITSIZE(*array)))
#define CLEARBIT(array,n)   (array[n/BITSIZE(*array)] &= ~BIT(n%BITSIZE(*array)))



/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef NTSTATUS (*QUERY_INTERFACE) (PVOID pvContext);
typedef ULONG    (*ADD_REF) (PVOID pvContext);
typedef ULONG    (*RELEASE) (PVOID pvContext);



/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _STATS_
{
    ULONG ulTotalSectionsWritten;
    ULONG ulTotalPacketsRead;

    ULONG ulTotalInvalidSections;
    ULONG ulTotalUnexpectedSections;
    ULONG ulTotalUnavailableOutputBuffers;
    ULONG ulTotalOutputBuffersTooSmall;
    ULONG ulTotalInvalidIPSnapHeaders;
    ULONG ulTotalIPPacketsWritten;

    ULONG ulTotalIPBytesWritten;
    ULONG ulTotalIPFrameBytesWritten;

    ULONG ulTotalNetPacketsWritten;
    ULONG ulTotalUnknownPacketsWritten;

} STATS, *PSTATS;


/////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct
{
    QUERY_INTERFACE          QueryInterface;
    ADD_REF                  AddRef;
    RELEASE                  Release;

} FILTER_VTABLE, *PFILTER_VTABLE;


/////////////////////////////////////////////////////////////////////////////
//
//
// definition of the full HW device extension structure This is the structure
// that will be allocated in HW_INITIALIZATION by the stream class driver
// Any information that is used in processing a device request (as opposed to
// a STREAM based request) should be in this structure.  A pointer to this
// structure will be passed in all requests to the minidriver. (See
// HW_STREAM_REQUEST_BLOCK in STRMINI.H)
//
typedef struct _MPE_FILTER_
{

    LIST_ENTRY                          AdapterSRBQueue;
    KSPIN_LOCK                          AdapterSRBSpinLock;
    BOOLEAN                             bAdapterQueueInitialized;

    //
    //
    //
    BOOLEAN                             bInitializationComplete;

    //
    // Statistics
    //
    STATS                               Stats;

    //
    //
    //
    PDEVICE_OBJECT                      DeviceObject;

    //
    //
    //
    PDRIVER_OBJECT                      DriverObject;

    //
    //
    //
    PFILTER_VTABLE                      lpVTable;

    //
    //
    //
    ULONG                               ulRefCount;

    //
    //
    //
    PVOID                               pStream [2][1];

    //
    //
    //
    ULONG                               ulActualInstances [2];   // Count of instances per stream

    //
    //
    //
    KSPIN_LOCK                          IpV4StreamDataSpinLock; // Data queue spin lock
    LIST_ENTRY                          IpV4StreamDataQueue;    // Stream data queue

    KSPIN_LOCK                          StreamControlSpinLock;  // Command queue spin lock
    LIST_ENTRY                          StreamControlQueue;     // Stream command queue

    KSPIN_LOCK                          StreamDataSpinLock;     // Data queue spin lock
    LIST_ENTRY                          StreamDataQueue;        // Stream data queue

    //
    //
    //
    KSPIN_LOCK                          StreamUserSpinLock;
    LIST_ENTRY                          StreamContxList;
    LARGE_INTEGER                       liLastTimeChecked;

    BOOLEAN                             bDiscontinuity;


} MPE_FILTER, *PMPE_FILTER;

/////////////////////////////////////////////////////////////////////////////
//
// this structure is our per stream extension structure.  This stores
// information that is relevant on a per stream basis.  Whenever a new stream
// is opened, the stream class driver will allocate whatever extension size
// is specified in the HwInitData.PerStreamExtensionSize.
//

typedef struct _STREAM_
{
    PMPE_FILTER                         pFilter;
    PHW_STREAM_OBJECT                   pStreamObject;          // For timer use
    KSSTATE                             KSState;                // Run, Stop, Pause
    HANDLE                              hMasterClock;
    HANDLE                              hClock;
    ULONG                               ulStreamInstance;       // 0..NumberOfPossibleInstances-1
    KSDATAFORMAT                        OpenedFormat;           // Based on the actual open request.

    KSDATARANGE                         MatchedFormat;

    ULONG                               Type;                   // type of this structure
    ULONG                               Size;                   // size of this structure

    PUCHAR                              pTransformBuffer;       // temp buffer used for translating MPE to IP
    PUCHAR                              pOut;                   // pointer to next insertion point in output buffer

    BYTE                                bExpectedSection;       // expected section number

} STREAM, *PSTREAM;

///////////////////////////////////////////////////////////////////////////////
//
// This structure is our per SRB extension, and carries the forward and backward
// links for the pending SRB queue.
//
typedef struct _SRB_EXTENSION
{
    LIST_ENTRY                      ListEntry;
    PHW_STREAM_REQUEST_BLOCK        pSrb;

} SRB_EXTENSION, *PSRB_EXTENSION;


//////////////////////////////////////////////////////////////////////////////
//
// the following section defines prototypes for the minidriver initialization
// routines
//

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOLEAN
CodecUnInitialize(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOLEAN
CodecQueryUnload (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );      // Not implemented currently

BOOLEAN
HwInterrupt (
    IN PMPE_FILTER pFilter
    );

VOID
CodecStreamInfo(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CodecOpenStream(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CodecCloseStream(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecCancelPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecTimeoutPacket(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecGetProperty(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

VOID STREAMAPI
CodecSetProperty(
    IN PHW_STREAM_REQUEST_BLOCK Srb
    );

BOOL
CodecVerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

BOOL
CodecFormatFromRange(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

void
CompleteStreamSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType1,
    BOOL fUseNotification2,
    STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType2
    );

void
CompleteDeviceSRB (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
    BOOL fReadyForNext
    );

/////////////////////////////////////////////////////////////////////////////////////
//
// SRB Queue Management functions
//
BOOL STREAMAPI
QueueAddIfNotEmpty(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueAdd(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueRemove(
    IN OUT PHW_STREAM_REQUEST_BLOCK *,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueuePush (
    IN PHW_STREAM_REQUEST_BLOCK pSrb,
    IN PKSPIN_LOCK pQueueSpinLock,
    IN PLIST_ENTRY pQueue
    );

BOOL STREAMAPI
QueueRemoveSpecific(
    IN PHW_STREAM_REQUEST_BLOCK,
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

BOOL STREAMAPI
QueueEmpty(
    IN PKSPIN_LOCK,
    IN PLIST_ENTRY
    );

VOID
STREAMAPI
CodecReceivePacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
CodecInitialize (
    IN OUT PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecCancelPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
CodecTimeoutPacket(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


BOOL
CompareGUIDsAndFormatSize(
    IN PKSDATARANGE pDataRange1,
    IN PKSDATARANGE pDataRange2,
    BOOLEAN bCheckSize
    );

BOOL
CompareStreamFormat (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

BOOLEAN
VerifyFormat(
    IN KSDATAFORMAT *pKSDataFormat,
    UINT StreamNumber,
    PKSDATARANGE pMatchedFormat
    );

VOID
OpenStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
CloseStream (
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveDataPacket (
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
STREAMAPI
ReceiveCtrlPacket(
    IN PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
MpeSetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
MpeGetState(
    PHW_STREAM_REQUEST_BLOCK pSrb
    );


#endif  // _MPE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\recv.c ===
////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      recv.c
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#include <wdm.h>
#include <strmini.h>
#include <ksmedia.h>

#include "Mpe.h"
#include "main.h"
#include "recv.h"


#ifdef DBG

//////////////////////////////////////////////////////////////////////////////
VOID
DumpData (
    PUCHAR pData,
    ULONG  ulSize
    )
//////////////////////////////////////////////////////////////////////////////
{
  ULONG  ulCount;
  ULONG  ul;
  UCHAR  uc;

  while (ulSize)
  {
      ulCount = 16 < ulSize ? 16 : ulSize;

      for (ul = 0; ul < ulCount; ul++)
      {
          uc = *pData;

          TEST_DEBUG (TEST_DBG_RECV, ("%02X ", uc));
          ulSize -= 1;
          pData  += 1;
      }

      TEST_DEBUG (TEST_DBG_RECV, ("\n"));
  }

}

#endif   //DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\recv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//
// Copyright (c) 1996, 1997  Microsoft Corporation
//
//
// Module Name:
//      recv.h
//
// Abstract:
//
//
// Author:
//
//      P Porzuczek
//
// Environment:
//
// Revision History:
//
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _RECV_H_
#define _RECV_H_


///////////////////////////////////////////////////////////////////////////////////////
//
// NabtsIp Stream Context.
//

#define MAX_IP_STREAMS 128

typedef struct _MPE_STREAM_DATA
{
    ULONG       ulType;
    ULONG       ulSize;

} MPE_STREAM_DATA, *PMPE_STREAM_DATA;


///////////////////////////////////////////////////////////////////////////////////////
//
//
// Prototypes
//
//
VOID
vCheckNabStreamLife (
    PMPE_FILTER pFilter
    );


NTSTATUS
ntCreateNabStreamContext(
    PMPE_FILTER pFilter,
    ULONG groupID,
    PMPE_STREAM_DATA *ppNabStream
    );


NTSTATUS
ntGetNdisPacketForStream (
    PMPE_FILTER pFilter,
    PMPE_STREAM_DATA pNabStream
    );

VOID
vDestroyNabStreamContext(
   PMPE_FILTER pUser,
   PMPE_STREAM_DATA pNabStream,
   BOOLEAN fRemoveFromList
   );

NTSTATUS
ntAllocateNabStreamContext(
    PMPE_STREAM_DATA *ppNabStream
    );

NTSTATUS
ntNabtsRecv(
    PMPE_FILTER pFilter,
    PMPE_BUFFER pNabData
    );

VOID
CancelNabStreamSrb (
    PMPE_FILTER pFilter,
    PHW_STREAM_REQUEST_BLOCK pSrb
    );

VOID
DeleteNabStreamQueue (
    PMPE_FILTER pFilter
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\mpe\mpestream.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//==========================================================================;

#ifndef __MPE_STREAM_H__
#define __MPE_STREAM_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// ------------------------------------------------------------------------
// Property set for all video capture streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_TABLE(MpeConnectionProperties)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
        TRUE,                                   // GetSupported or Handler
        sizeof(KSPROPERTY),                     // MinProperty
        sizeof(KSALLOCATOR_FRAMING),            // MinData
        FALSE,                                  // SetSupported or Handler
        NULL,                                   // Values
        0,                                      // RelationsCount
        NULL,                                   // Relations
        NULL,                                   // SupportHandler
        sizeof(ULONG)                           // SerializedSize
    )
};

// ------------------------------------------------------------------------
// Array of all of the property sets supported by video streams
// ------------------------------------------------------------------------

DEFINE_KSPROPERTY_SET_TABLE(MpeStreamProperties)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Connection,                        // Set
        SIZEOF_ARRAY(MpeConnectionProperties),       // PropertiesCount
        MpeConnectionProperties,                     // PropertyItems
        0,                                              // FastIoCount
        NULL                                            // FastIoTable
    ),
};


#define NUMBER_MPE_STREAM_PROPERTIES (SIZEOF_ARRAY(MpeStreamProperties))

//---------------------------------------------------------------------------
// All of the video and vbi data formats we might use
//---------------------------------------------------------------------------

KSDATARANGE StreamFormatIPv4 =
{
    //
    // KSDATARANGE
    //
    sizeof (KSDATAFORMAT),
    0,
    4096,               // sizeof a IPv4 Packet
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SUBTYPE_BDA_IP },
    { STATIC_KSDATAFORMAT_SPECIFIER_BDA_IP }
};


KSDATARANGE StreamFormatMPE =
{
    sizeof (KSDATARANGE),
    0,
    4093, //max sizeof (MPE_BUFFER),
    0,                  // Reserved
    { STATIC_KSDATAFORMAT_TYPE_MPE },
    { STATIC_KSDATAFORMAT_SUBTYPE_NONE },
    { STATIC_KSDATAFORMAT_SPECIFIER_NONE }
};


//---------------------------------------------------------------------------
//  STREAM_Input Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream0Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatMPE


    // Add more formats here for to mirror output formats for "passthrough" mode
    // The idea is that upstream capture drivers may have done some decoding already
    // or downstream drivers may wish to have the raw data without any decoding at all.
    // In that case all we need to do is copy the data(if there is a pending SRB) OR
    // forward the SRB to the downstream client.
};

#define NUM_STREAM_0_FORMATS (SIZEOF_ARRAY(Stream0Formats))


//---------------------------------------------------------------------------
//  STREAM_Output Formats
//---------------------------------------------------------------------------

static PKSDATAFORMAT Stream1Formats[] =
{
    (PKSDATAFORMAT) &StreamFormatIPv4,

    //
    // Add more formats here for whatever output formats are supported.
    //
};
#define NUM_STREAM_1_FORMATS (SIZEOF_ARRAY (Stream1Formats))

//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Create an array that holds the list of all of the streams supported
//---------------------------------------------------------------------------

typedef struct _ALL_STREAM_INFO
{
    HW_STREAM_INFORMATION   hwStreamInfo;
    HW_STREAM_OBJECT        hwStreamObject;

} ALL_STREAM_INFO, *PALL_STREAM_INFO;

static ALL_STREAM_INFO Streams [] =
{
    //
    // MPE Input Stream
    //

    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                        // NumberOfPossibleInstances
            KSPIN_DATAFLOW_IN,                        // DataFlow
            TRUE,                                     // DataAccessible
            NUM_STREAM_0_FORMATS,                     // NumberOfFormatArrayEntries
            Stream0Formats,                           // StreamFormatsArray
            0,                                        // ClassReserved[0]
            0,                                        // ClassReserved[1]
            0,                                        // ClassReserved[2]
            0,                                        // ClassReserved[3]
            NUMBER_MPE_STREAM_PROPERTIES,             // Number of stream properties
            (PKSPROPERTY_SET) MpeStreamProperties,    // Stream Property Array
            0,                                        // NumStreamEventArrayEntries
            0,                                        // StreamEventsArray
            NULL,                                     // Category
            (GUID *)&PINNAME_MPE,                     // Name
            0,                                        // MediumsCount
            NULL,                                     // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,
            ReceiveCtrlPacket,
            {                                       // HW_CLOCK_OBJECT
                NULL,                               // .HWClockFunction
                0,                                  // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            TRUE,                                   // Allocator
            NULL,                                   // HwEventRoutine
        },
    },

    //
    // IPv4 Control Interface Pin
    //
    {
        // HW_STREAM_INFORMATION -------------------------------------------
        {
            1,                                      // NumberOfPossibleInstances
            KSPIN_DATAFLOW_OUT,                     // DataFlow
            TRUE,                                   // DataAccessible
            NUM_STREAM_1_FORMATS,                   // NumberOfFormatArrayEntries
            Stream1Formats,                         // StreamFormatsArray
            0,                                      // ClassReserved[0]
            0,                                      // ClassReserved[1]
            0,                                      // ClassReserved[2]
            0,                                      // ClassReserved[3]
            NUMBER_MPE_STREAM_PROPERTIES,           // Number of stream properties
            (PKSPROPERTY_SET) MpeStreamProperties,  // Stream Property Array
            0,                                      // NumStreamEventArrayEntries
            0,                                      // StreamEventsArray
            NULL,                                   // Category
            (GUID *)&PINNAME_IPSINK_INPUT,          // Name
            0,                                      // MediumsCount
            NULL,                                   // Mediums
        },

        // HW_STREAM_OBJECT ------------------------------------------------
        {
            sizeof (HW_STREAM_OBJECT),              // SizeOfThisPacket
            0,                                      // StreamNumber
            (PVOID)NULL,                            // HwStreamExtension
            ReceiveDataPacket,                      // HwReceiveDataPacket Handler
            ReceiveCtrlPacket,                      // HwReceiveControlPacket Handler
            {                                       // HW_CLOCK_OBJECT
                NULL,                                // .HWClockFunction
                0,                                   // .ClockSupportFlags
            },
            FALSE,                                  // Dma
            TRUE,                                   // Pio
            (PVOID)NULL,                            // HwDeviceExtension
            0,                                      // StreamHeaderMediaSpecific
            0,                                      // StreamHeaderWorkspace
            TRUE,                                   // Allocator
            NULL,                                   // HwEventRoutine
        },
    }

};

#define DRIVER_STREAM_COUNT (SIZEOF_ARRAY (Streams))


//---------------------------------------------------------------------------
// Topology
//---------------------------------------------------------------------------

// Topology connections

KSTOPOLOGY_CONNECTION   rgConnections[] =
{
    {-1, 0, -1, 1}
};

// Categories define what the device does.

static GUID Categories[] =
{
    STATIC_KSCATEGORY_BDA_RECEIVER_COMPONENT
};

#define NUMBER_OF_CATEGORIES  SIZEOF_ARRAY (Categories)

static KSTOPOLOGY Topology = {
    NUMBER_OF_CATEGORIES,
    (GUID*) &Categories,
    0,
    (GUID*) NULL,
    1,
    rgConnections,
    NULL,
    0
};


//---------------------------------------------------------------------------
// The Main stream header
//---------------------------------------------------------------------------

static HW_STREAM_HEADER StreamHeader =
{
    DRIVER_STREAM_COUNT,                // NumberOfStreams
    sizeof (HW_STREAM_INFORMATION),     // Future proofing
    0,                                  // NumDevPropArrayEntries set at init time
    NULL,                               // DevicePropertiesArray  set at init time
    0,                                  // NumDevEventArrayEntries;
    NULL,                               // DeviceEventsArray;
    &Topology                           // Pointer to Device Topology
};

#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //  __MPE_STREAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\common.h ===
#ifndef _COMMON_H
#define _COMMON_H_

extern "C" {
#include <wdm.h>
#include "wdmdebug.h"
}

// #include <limits.h>
#include <winerror.h>
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>
#include <bdamedia.h>
#include <atsmedia.h>
#include <bdasup.h>

//#include "medguid.h"
#include <kcom.h>
#include <ksdebug.h>

#undef INTERFACE



#endif //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\inpin.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    inpin.cpp

Abstract:

    Transport input pin code.

--*/

#include "casamp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

NTSTATUS
CTransportInputPin::PinCreate(
    IN OUT PKSPIN pKSPin,
    IN PIRP Irp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CTransportInputPin*      pPin;
    CFilter*            pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportInputPin::PinCreate"));

    ASSERT(pKSPin);
    ASSERT(Irp);

    //  Get a pointer to our filter instance that this pin is being
    //  created for.  Remember it for later.
    //
    pFilter = reinterpret_cast<CFilter*>(KsGetFilterFromIrp(Irp)->Context);

    //  Create our transport pin object.
    //
    pPin = new(PagedPool,'IFsK') CTransportInputPin;
    if (!pPin)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //  Link our pin context to our filter context.
    //
    pPin->SetFilter( pFilter);

    //  Link our context to the KSPIN structure.
    //
    pKSPin->Context = pPin;

exit:
    return Status;
}


NTSTATUS
CTransportInputPin::PinClose(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("PinClose"));

    ASSERT(Pin);
    ASSERT(Irp);

    CTransportInputPin* pin = reinterpret_cast<CTransportInputPin*>(Pin->Context);

    ASSERT(pin);

    delete pin;

    return STATUS_SUCCESS;
}

NTSTATUS
CTransportInputPin::IntersectDataFormat(
	    IN PVOID pContext,
		IN PIRP pIrp,
		IN PKSP_PIN Pin,
		IN PKSDATARANGE DataRange,
		IN PKSDATARANGE MatchingDataRange,
		IN ULONG DataBufferSize,
		OUT PVOID Data OPTIONAL,
		OUT PULONG DataSize
     )
{
	if ( DataBufferSize < sizeof(KS_DATARANGE_BDA_TRANSPORT) )
	{
		*DataSize = sizeof( KS_DATARANGE_BDA_TRANSPORT );
		return STATUS_BUFFER_OVERFLOW;
	}
	else
	{
		ASSERT(DataBufferSize == sizeof(KS_DATARANGE_BDA_TRANSPORT));

		*DataSize = sizeof( KS_DATARANGE_BDA_TRANSPORT );
		RtlCopyMemory( Data, (PVOID)DataRange, sizeof(KS_DATARANGE_BDA_TRANSPORT));

		return STATUS_SUCCESS;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    sources.inc

Abstract:

    Common makefile for ActiveMovie filters.

Revision History:

    06-Nov-1996 DonRyan
        Created.
    25-Nov-1996 TomOR
        Modified for Ks stuff.
    10-Oct-1999 Jaybo
    Added FILTER_DLL; define this in your environment to create separate
    DLLs instead of one massive ksproxy.ax.  This turns off the definition
    of FILTER_LIB in various sources files.

!ENDIF

###############################################################################
#                                                                             #
#  Private Definitions                                                        #
#                                                                             #
###############################################################################

!ifdef FILTER_LIB
TARGETTYPE=LIBRARY
#TARGETPATH=$(PROJECT_LIB_PATH) DOESN'T WORK HERE!  YOU GET i386\i386 TWICE!!!
C_DEFINES=$(C_DEFINES) -DFILTER_LIB
!else
TARGETTYPE=DYNLINK
TARGETEXT=ax
C_DEFINES=$(C_DEFINES) -DFILTER_DLL
!endif

###############################################################################
#                                                                             #
#  Debug Support                                                              #
#                                                                             #
###############################################################################
!IF ("$(NTDEBUG)" != "") && ("$(NTDEBUG)" != "ntsdnodbg") && ("$(NTDEBUG)" != "retail")
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

###############################################################################
#                                                                             #
#  Profile Support                                                            #
#                                                                             #
###############################################################################

!IF "$(NTPROFILE)" == ""
STRM_PROFILE_FLAG=
STRM_PROFILE_LIB=
!ELSE
!    IF "$NTPROFILE)" == "cap"
STRM_PROFILE_FLAG=-Gp
STRM_PROFILE_LIB=$(SDK_LIB_PATH)\cap.lib
!    ELSE
!        IF "$(NTPROFILE)" == "wst"
STRM_PROFILE_FLAG=-Gp
STRM_PROFILE_LIB=$(SDK_LIB_PATH)\wst.lib
!        ELSE
!            error NTPROFILE macro can be either "", "cap", or "wst"
!        ENDIF
!    ENDIF
!ENDIF

###############################################################################
#                                                                             #
#  Global Definitions                                                         #
#                                                                             #
###############################################################################

DLLENTRY=DllEntryPoint
MSC_WARNING_LEVEL=/W3 /WX
NOT_LEAN_AND_MEAN=1
USE_CRTDLL=1
386_FLAGS=$(STRM_PROFILE_FLAG)

#Compatibility with Memphis
SUBSYSTEM_VERSION=4.00

###############################################################################
#                                                                             #
#  Includes                                                                   #
#                                                                             #
###############################################################################

INCLUDES=\
    $(SDK_PATH)\amovie\inc

###############################################################################
#                                                                             #
#  Link Libraries                                                             #
#                                                                             #
###############################################################################

!if !$(FREEBUILD)
STRMBASE_LIB= $(SDK_LIB_PATH)\strmbasd.lib
!else
STRMBASE_LIB= $(SDK_LIB_PATH)\strmbase.lib
!endif

!IFNDEF FILTER_LIB

LINKLIBS=\
    $(STRMBASE_LIB)

###############################################################################
#                                                                             #
#  Target Libraries                                                           #
#                                                                             #
###############################################################################

TARGETLIBS= $(TARGETLIBS) \
    $(SDK_LIB_PATH)\vfw32.lib    \
    $(SDK_LIB_PATH)\winmm.lib    \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\version.lib  \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\ole32.lib    \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(STRM_PROFILE_LIB)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\casamp.h ===
#include "common.h"

#include "bdadebug.h"

#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

/**************************************************************/
/* Driver Name - Change this to reflect your executable name! */
/**************************************************************/

#define MODULENAME           "CASamp"
#define MODULENAMEUNICODE   L"CASamp"

#define STR_MODULENAME      MODULENAME

// This defines the name of the WMI device that manages service IOCTLS
#define DEVICENAME (L"\\\\.\\" MODULENAMEUNICODE)
#define SYMBOLICNAME (L"\\DosDevices\\" MODULENAMEUNICODE)


//  This structure represents what the underlying device can do.
//
//  Note -  It is possible to set conflicting settings.  In this case
//  it is the responsibilty of the CheckChanges code to return an
//  error.  Only a self-consistent tuner resource should be submitted to
//  the underlying device.
//
typedef struct _OUR_TUNER_RESOURCE
{
    ULONG               ulhzCarrierFrequency;//  The channel frequency
} OUR_TUNER_RESOURCE, * POUR_TUNER_RESOURCE;


extern const KSDEVICE_DESCRIPTOR DeviceDescriptor;


class CFilter {
public:

    //
    //  AVStream Filter Dispatch Functions
    //
    static
    STDMETHODIMP_(NTSTATUS)
    Create(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    FilterClose(
        IN OUT PKSFILTER Filter,
        IN PIRP Irp
        );

    static
    STDMETHODIMP
    Process(
        IN PKSFILTER Filter,
        IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
        );

    //
    //  KSMETHODSETID_BdaChangeSync - Filter change sync methods
    //
    static
    STDMETHODIMP_(NTSTATUS)
    StartChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    CheckChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    CommitChanges(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    static
    STDMETHODIMP_(NTSTATUS)
    GetChangeState(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OUT PULONG      pulChangeState
        );

    //
    //  KSMETHODSETID_BdaDeviceConfiguration - Methods to modify filter topology.
    //
    static
    STDMETHODIMP_(NTSTATUS)
    CreateTopology(
        IN PIRP         pIrp,
        IN PKSMETHOD    pKSMethod,
        OPTIONAL PVOID  pvIgnored
        );

    STDMETHODIMP_(BDA_CHANGE_STATE)
    ChangeState();

    STDMETHODIMP_(class CDevice *)
    GetDevice() { return m_pDevice;};

    STDMETHODIMP_(NTSTATUS)
    ChangeFrequency(
        IN ULONG        ulhzCarrierFrequency
        )
        {
            //$Review - Should we validate the frequency here?
            //
            m_NewTunerResource.ulhzCarrierFrequency = ulhzCarrierFrequency;
            m_BdaChangeState = BDA_CHANGES_PENDING;

            return STATUS_SUCCESS;
        };

    STDMETHODIMP_(NTSTATUS)
    SetDeviceState(
        KSSTATE     newKsState
        )
    {
        m_KsState = newKsState;
        return STATUS_SUCCESS;
    };

    STDMETHODIMP_(NTSTATUS)
    AcquireResources();

    STDMETHODIMP_(NTSTATUS)
    ReleaseResources();

private:
    class CDevice * m_pDevice;

    //  Filter Properties
    //

    //  Filter Resources
    //
    KSSTATE                 m_KsState;
    BDA_CHANGE_STATE        m_BdaChangeState;
    OUR_TUNER_RESOURCE      m_CurTunerResource;
    ULONG                   m_ulCurResourceID;
    OUR_TUNER_RESOURCE      m_NewTunerResource;
    ULONG                   m_ulNewResourceID;
};


class CDevice {
public:

    //
    //  AVStream Device Dispatch Functions
    //
    static
    STDMETHODIMP_(NTSTATUS)
    Create(
        IN PKSDEVICE    pKSDevice
        );

    static
    STDMETHODIMP_(NTSTATUS)
    Start(
        IN PKSDEVICE            pKSDevice,
        IN PIRP                 pIrp,
        IN PCM_RESOURCE_LIST    pTranslatedResourceList OPTIONAL,
        IN PCM_RESOURCE_LIST    pUntranslatedResourceList OPTIONAL
        );

    //
    //  Utility functions
    //
    NTSTATUS
    AcquireResources(
        POUR_TUNER_RESOURCE     pNewTunerResource,
        PULONG                  pulAquiredResourceID
        );

    NTSTATUS
    ReleaseResources(
        ULONG                   ulResourceID
        );


private:

    PKSDEVICE           m_pKSDevice;

    OUR_TUNER_RESOURCE  m_CurTunerResource;
};

class CTransportOutputPin
{
public:
    static
    STDMETHODIMP_(NTSTATUS)
    PinCreate(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PinClose(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );
	
	static
	STDMETHODIMP_(NTSTATUS)
	IntersectDataFormat(
	    IN PVOID pContext,
		IN PIRP pIrp,
		IN PKSP_PIN Pin,
		IN PKSDATARANGE DataRange,
		IN PKSDATARANGE MatchingDataRange,
		IN ULONG DataBufferSize,
		OUT PVOID Data OPTIONAL,
		OUT PULONG DataSize
		);

	static
    STDMETHODIMP_(NTSTATUS)
	GetECMMapStatus(
		IN PIRP			Irp,
		IN PKSPROPERTY	pKSProperty,
        IN PULONG       pulProperty
        );

	static
    STDMETHODIMP_(NTSTATUS)
	GetCAModuleStatus(
		IN PIRP			Irp,
		IN PKSPROPERTY	pKSProperty,
        IN PULONG       pulProperty
        );

	static
    STDMETHODIMP_(NTSTATUS)
	GetCASmartCardStatus(
		IN PIRP			Irp,
		IN PKSPROPERTY	pKSProperty,
        IN PULONG       pulProperty
        );

	static
    STDMETHODIMP_(NTSTATUS)
	GetCAModuleUI(
		IN PIRP					Irp,
		IN PKSPROPERTY			pKSProperty,
		IN PBDA_CA_MODULE_UI	pCAModuleUIProperty
        );

	static
    STDMETHODIMP_(NTSTATUS)
	PutECMMapEMMPID(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PULONG       pulProperty
        );

	static
    STDMETHODIMP_(NTSTATUS)
	GetECMMapList(
		IN PIRP			Irp,
		IN PKSPROPERTY	pKSProperty,
		IN PBDA_ECM_MAP	pECMMapProperty
        );

	static
    STDMETHODIMP_(NTSTATUS)
	PutECMMapUpdateMap(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PBDA_ECM_MAP pECMMapProperty
        );
	
	static
    STDMETHODIMP_(NTSTATUS)
	PutECMMapRemoveMap(
        IN PIRP         Irp,
        IN PKSPROPERTY  pKSProperty,
        IN PBDA_ECM_MAP pECMMapProperty
        );
	
	static
    STDMETHODIMP_(NTSTATUS)
	PutECMMapUpdateESDescriptor(
        IN PIRP				  Irp,
        IN PKSPROPERTY		  pKSProperty,
        IN PBDA_ES_DESCRIPTOR pESDescProperty
        );

	static
    STDMETHODIMP_(NTSTATUS)
	PutECMMapUpdateProgramDescriptor(
        IN PIRP				       Irp,
        IN PKSPROPERTY		       pKSProperty,
        IN PBDA_PROGRAM_DESCRIPTOR pProgramDescProperty
        );

    STDMETHODIMP_(class CFilter *)
    GetFilter() { return m_pFilter;};

    STDMETHODIMP_(void)
    SetFilter(class CFilter * pFilter) { m_pFilter = pFilter;};

private:
    CFilter *       m_pFilter;
};

class CTransportInputPin
{
public:
    static
    STDMETHODIMP_(NTSTATUS)
    PinCreate(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

    static
    STDMETHODIMP_(NTSTATUS)
    PinClose(
        IN OUT PKSPIN Pin,
        IN PIRP Irp
        );

	static
	STDMETHODIMP_(NTSTATUS)
	IntersectDataFormat(
	    IN PVOID pContext,
		IN PIRP pIrp,
		IN PKSP_PIN Pin,
		IN PKSDATARANGE DataRange,
		IN PKSDATARANGE MatchingDataRange,
		IN ULONG DataBufferSize,
		OUT PVOID Data OPTIONAL,
		OUT PULONG DataSize
		);

    STDMETHODIMP_(class CFilter *)
    GetFilter() { return m_pFilter;};

    STDMETHODIMP_(void)
    SetFilter(class CFilter * pFilter) { m_pFilter = pFilter;};

private:
    CFilter *       m_pFilter;
};


//
//  Helper routines
//

NTSTATUS
PinSetDeviceState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    );

//
//  Data declarations
//

extern const BDA_FILTER_TEMPLATE    TunerBdaFilterTemplate;
extern const KSFILTER_DESCRIPTOR    InitialTunerFilterDescriptor;
extern const KSFILTER_DESCRIPTOR    TemplateTunerFilterDescriptor;

//
// Some GUIDs for our use
//

#define STATIC_KSNODE_BDA_OUR_ECMMAPER \
    0xe1571834, 0xfff0, 0x45d5, 0x9e, 0x5b, 0x68, 0x75, 0x59, 0x17, 0xa6, 0xdc
DEFINE_GUIDSTRUCT("E1571834-FFF0-45d5-9E5B-68755917A6DC", KSNODE_BDA_OUR_ECMMAPER);
#define KSNODE_BDA_OUR_ECMMAPER DEFINE_GUIDNAMED(KSNODE_BDA_OUR_ECMMAPER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\bdaguid.c ===
#include <wdm.h>
#include <windef.h>
#include <ks.h>
#include <ksmedia.h>
#include <bdatypes.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_PRAGMA

//  KSGuid.h defines INITGUID and some other macros that are useful in the
//  the actual definition of GUIDs.
//  KSGuid.h should be included immediately before those include files that
//  contain the GUIDS that you need defined.  Do NOT put it before include
//  files like KSMedia.h.  If you need definitions of GUIDS that are declared
//  there, use KSGuid.lib.
//
#include <ksguid.h>

#include <bdamedia.h>
#include <atsmedia.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\device.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    device.cpp

Abstract:

    Device driver core, initialization, etc.

--*/

#define KSDEBUG_INIT

#include "casamp.h"
#include "wdmdebug.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA



extern "C"
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;

	_DbgPrintF(DEBUGLVL_VERBOSE,("DriverEntry"));

	// DEBUG_BREAK;

    Status = KsInitializeDriver( DriverObject,
                                 RegistryPathName,
                                 &DeviceDescriptor);

    // DEBUG_BREAK;

    return Status;
}

STDMETHODIMP_(NTSTATUS)
CDevice::
Create(
    IN PKSDEVICE Device
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    CDevice *   pDevice = NULL;

    // DEBUG_BREAK;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CDevice::Create"));

    ASSERT(Device);


    //  Allocate memory for the our device class.
    //
    pDevice = new(PagedPool,'IDsK') CDevice;
    if (pDevice)
    {
        Device->Context = pDevice;
    } else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto errExit;
    }

    //  Point back to the KSDEVICE.
    //
    pDevice->m_pKSDevice = Device;


errExit:
    return Status;
}


STDMETHODIMP_(NTSTATUS)
CDevice::
Start(
    IN PKSDEVICE            pKSDevice,
    IN PIRP                 pIrp,
    IN PCM_RESOURCE_LIST    pTranslatedResourceList OPTIONAL,
    IN PCM_RESOURCE_LIST    pUntranslatedResourceList OPTIONAL
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CDevice *       pDevice;


    // DEBUG_BREAK;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("CDevice::Start"));
    ASSERT( pKSDevice);

    // DEBUG_BREAK;

    pDevice = reinterpret_cast<CDevice *>(pKSDevice->Context);
    ASSERT(pDevice);

	// initialize private class variables in pDevice here

    /*
    //  Initialize the tuner hardware.
    //
    Status = pDevice->Initialize();
    if (Status != STATUS_SUCCESS)
    {
        goto errExit;
    }
    */

    //  Create the the Tuner Filter Factory.  This factory is used to
    //  create instances of the tuner filter.
    //
    Status = BdaCreateFilterFactory( pKSDevice,
                                     &InitialTunerFilterDescriptor,
                                     &TunerBdaFilterTemplate
                                   );
    if (!NT_SUCCESS(Status))
    {
        goto errExit;
    }

errExit:
    return Status;
}

NTSTATUS
CDevice::
AcquireResources(
    POUR_TUNER_RESOURCE     pNewTunerResource,
    PULONG                  pulAquiredResourceID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    //$Review - Add resource managment code here.

	//this is where a new frequency defined in pNewTunerResource
	//needs to be set as the frequency we are tuneing to
 
//errExit:
    return Status;
}


NTSTATUS
CDevice::
ReleaseResources(
    ULONG                   ulAquiredResourceID
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;

    //$REVIEW - Put Resource management code here.

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\filter.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    filter.cpp

Abstract:

    Filter core, initialization, etc.

--*/

#include "casamp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

STDMETHODIMP_(NTSTATUS)
CFilter::Create(
    IN OUT PKSFILTER pKSFilter,
    IN PIRP Irp
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       ulPinId;
    PKSDEVICE   pKSDevice = NULL;
    CDevice *   pDevice = NULL;

    _DbgPrintF(DEBUGLVL_VERBOSE,("FilterCreate"));

    ASSERT(pKSFilter);
    ASSERT(Irp);


    //  Create our filter object.
    //
    CFilter* pFilter = new(PagedPool,'IFsK') CFilter;
    if (!pFilter)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto errExit;
    }
    pKSFilter->Context = pFilter;

    //  Point to the KS device object for this filter.
    //
    pKSDevice = KsFilterGetDevice( pKSFilter);
    ASSERT( pKSDevice);
    if (!pKSDevice)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        goto errExit;
    }

    //  Get our device object.
    //
    pDevice = reinterpret_cast<CDevice *>(pKSDevice->Context);
    ASSERT( pDevice);
    if (!pDevice)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        goto errExit;
    }

    pFilter->m_pDevice = pDevice;

    //  Initialize member variables.
    //
    pFilter->m_KsState = KSSTATE_STOP;
    pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;
    pFilter->m_ulCurResourceID = 0;
    pFilter->m_ulNewResourceID = 0;

    //  Initialize this filter instance with the default template
    //  topology.
    //
    Status = BdaInitFilter( pKSFilter, &TunerBdaFilterTemplate);
    if (NT_ERROR( Status))
    {
        goto errExit;
    }

#ifdef NO_NETWORK_PROVIDER

    //  Create the transport output pin
    //
    Status = BdaCreatePin( pKSFilter, 1, &ulPinId);
    if (!NT_SUCCESS(Status))
    {
        goto errExit;
    }
    
    //  Create the topology between the antenna and transport pin.
    //
    //$REVIEW - Add topology for filters with no network provider.
    //

#endif // NO_NETWORK_PROVIDER

exit:
    return Status;

errExit:
    if (pFilter)
    {
        delete pFilter;
    }
    pKSFilter->Context = NULL;

    goto exit;
}


STDMETHODIMP_(NTSTATUS)
CFilter::FilterClose(
    IN OUT PKSFILTER Filter,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("FilterClose"));

    ASSERT(Filter);
    ASSERT(Irp);

    CFilter* filter = reinterpret_cast<CFilter*>(Filter->Context);
    ASSERT(filter);

    delete filter;

    return STATUS_SUCCESS;
}


BDA_CHANGE_STATE
CFilter::ChangeState()
{
    //  Add Resource Management code
    //

    return BDA_CHANGES_COMPLETE;
}



//
//  Device Specific Filter Properties
//



NTSTATUS
PinSetDeviceState(
    IN PKSPIN Pin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
{
    return STATUS_SUCCESS;
}



NTSTATUS
PinNullProcess(
    IN PKSPIN Pin
    )
{
    return STATUS_SUCCESS;
}

/*
** FilterStartChanges ()
**
**    Puts the filter into change state.  All changes to BDA topology
**    and properties changed after this will be in effect only after
**    CommitChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
StartChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);

    //  Reset any pending BDA topolgoy changes.
    //
    Status = BdaStartChanges( pIrp);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }

    //  Reset any pending resource changes.
    //
    pFilter->m_NewTunerResource = pFilter->m_CurTunerResource;
    pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;

errExit:
    return Status;
}


/*
** CheckChanges ()
**
**    Checks the changes to BDA interfaces that have occured since the
**    last StartChanges.  Returns the result that would have occurred if
**    CommitChanges had been called.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
CheckChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    BDA_CHANGE_STATE    topologyChangeState;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);

    //  Check if the BDA topology changes are good.
    //
    Status = BdaCheckChanges( pIrp);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }

    //  Validate the new resource list here.
    //  In this driver the new resource list is always valid.
    //

#ifdef RESOURCE_MANAGEMENT
    //  Reserve resources from the device.
    //
    Status = m_pDevice->ReserveReplacementResources(
                            &m_CurTunerResource
                            &m_NewTunerResource
                            );
    if (Status == STATUS_PENDING)
    {
        //  Status pending means that the resource is valid, but not
        //  currently available.
        //
        Status = STATUS_SUCCESS;
    }
#endif // RESOURCE_MANAGEMENT

errExit:
    return Status;
}


/*
** CommitChanges ()
**
**    Checks and commits the changes to BDA interfaces that have occured since the
**    last StartChanges.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
CommitChanges(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OPTIONAL PVOID  pvIgnored
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    CFilter *       pFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);


    //  Commit any BDA topology changes.
    //
    Status = BdaCommitChanges( pIrp);

    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }

    //  Mark the changes as having been made.
    //
    pFilter->m_CurTunerResource = pFilter->m_NewTunerResource;
    pFilter->m_BdaChangeState = BDA_CHANGES_COMPLETE;

    if (pFilter->m_KsState != KSSTATE_STOP)
    {
        //  Commit the resources on the underlying device
        //
        Status = pFilter->AcquireResources( );
    }

errExit:
    return Status;
}


/*
** AcquireResources ()
**
**    Acquires Resources from the underlying device.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
AcquireResources(
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;

    if (m_ulCurResourceID)
    {
        m_pDevice->ReleaseResources(
                       m_ulCurResourceID
                       );
        m_ulCurResourceID = 0;
    }

    //  Commit the resources on the underlying device
    //
    Status = m_pDevice->AcquireResources(
                            &m_CurTunerResource,
                            &m_ulCurResourceID
                            );
    return Status;
}


/*
** ReleaseResources ()
**
**    Acquires Resources from the underlying device.
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
ReleaseResources(
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;

    //  Release the resources on the underlying device
    //
    if (m_ulCurResourceID)
    {
        Status = m_pDevice->ReleaseResources(
                                m_ulCurResourceID
                                );
        m_ulCurResourceID = 0;
    }

    return Status;
}


/*
** GetChangeState ()
**
**    Returns the current BDA change state
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
GetChangeState(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    OUT PULONG      pulChangeState
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    BDA_CHANGE_STATE    topologyChangeState;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);


    //  See if any BDA topology changes are pending
    //
    Status = BdaGetChangeState( pIrp, &topologyChangeState);
    if (!NT_SUCCESS( Status))
    {
        goto errExit;
    }


    //  Figure out if there are changes pending.
    //
    if (   (topologyChangeState == BDA_CHANGES_PENDING)
        || (pFilter->m_BdaChangeState == BDA_CHANGES_PENDING)
       )
    {
        *pulChangeState = BDA_CHANGES_PENDING;
    }
    else
    {
        *pulChangeState = BDA_CHANGES_COMPLETE;
    }


errExit:
    return Status;
}


/*
** CreateTopology ()
**
**    Keeps track of the topology association between input and output pins
**
** Arguments:
**
**
** Returns:
**
** Side Effects:  none
*/
NTSTATUS
CFilter::
CreateTopology(
    IN PIRP         pIrp,
    IN PKSMETHOD    pKSMethod,
    PVOID           pvIgnored
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CFilter *           pFilter;
    ULONG               ulPinType;
    PKSFILTER           pKSFilter;

    ASSERT( pIrp);
    ASSERT( pKSMethod);

    //  Obtain a "this" pointer for the method.
    //
    //  Because this function is called directly from the property dispatch
    //  table, we must get our own pointer to the underlying object.
    //
    pFilter = reinterpret_cast<CFilter *>(KsGetFilterFromIrp(pIrp)->Context);
    ASSERT( pFilter);

    //  Let the BDA topology DLL create the standard topology.
    //  It will also validate the method, instance count, etc.
    //
    Status = BdaMethodCreateTopology( pIrp, pKSMethod, pvIgnored);
    if (Status != STATUS_SUCCESS)
    {
        goto errExit;
    }

    //  This is where our filter can keep track of associated pins.
    //




errExit:
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\objdesc.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ObjDesc.cpp

Abstract:

    Static object description data structures.

    This file includes initial descriptors for all filter, pin, and node
    objects exposed by this driver.  It also include descriptors for the
    properties, methods, and events on those objects.

--*/

#include "casamp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


//===========================================================================
//
//  Node  definitions
//
//  Nodes are special in that, though they are defined at the filter level,
//  they are actually associated with a pin type.  The filter's node
//  descriptor list is actually a list of node types.
//
//  You will notice that the dispatch routines actually point to
//  pin specific methods.  This is because the context data associated with
//  a node is stored in the pin context.
//
//  Node properties and methods should only be used on the appropriate
//  pin.
//
//===========================================================================

// This filter's node topology:
//
//                       |-------------|
//  Transport In Pin ----| ECMMap Node |---- Transport Out Pin
//                       |-------------|
//
//  This node is meant to follow a tuner/demod filter in a BDA topology



//===========================================================================
//
//  Our ECM Mapper Node  definitions
//
//  This structure defines the Properties, Methods, and Events
//  available on our ECM Mapper.
//
//  The properties are used to set the PIDs of the streams carrying the 
//  keys and the encrypted data that needs to be decrypted with those keys.
//
//  This node is associated with an transport output pin and thus the node
//  properties should be set/put using the transport output pin.
//
//===========================================================================


//
//  ECM Mapper
//
//  Defines the dispatch routines for the ECM Map Properties
//  on the ECM Mapper
//
DEFINE_KSPROPERTY_TABLE(OurECMMapperNodeECMMapProperties)
{
	DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_EMM_PID(
        NULL,
		CTransportOutputPin::PutECMMapEMMPID
        ),
	DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_MAP_LIST(
		CTransportOutputPin::GetECMMapList,
        NULL
        ),
	DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_UPDATE_MAP(
        NULL,
		CTransportOutputPin::PutECMMapUpdateMap
        ),
	DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_REMOVE_MAP(
        NULL,
		CTransportOutputPin::PutECMMapRemoveMap
        ),
	DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_UPDATE_ES_DESCRIPTOR(
        NULL,
		CTransportOutputPin::PutECMMapUpdateESDescriptor
        ),
	DEFINE_KSPROPERTY_ITEM_BDA_ECMMAP_UPDATE_PROGRAM_DESCRIPTOR(
        NULL,
		CTransportOutputPin::PutECMMapUpdateProgramDescriptor
        )
};


//
//  ECM Mapper
//
//  Defines the dispatch routines for the CA Properties
//  on the ECM Mapper
//
DEFINE_KSPROPERTY_TABLE(OurECMMapperNodeCAProperties)
{
	DEFINE_KSPROPERTY_ITEM_BDA_ECM_MAP_STATUS(
		CTransportOutputPin::GetECMMapStatus,
        NULL
        ),
	DEFINE_KSPROPERTY_ITEM_BDA_CA_MODULE_STATUS(
		CTransportOutputPin::GetCAModuleStatus,
        NULL
        ),
	DEFINE_KSPROPERTY_ITEM_BDA_CA_SMART_CARD_STATUS(
		CTransportOutputPin::GetCASmartCardStatus,
        NULL
        ),
	DEFINE_KSPROPERTY_ITEM_BDA_CA_MODULE_UI(
		CTransportOutputPin::GetCAModuleUI,
        NULL
        )
};


//
//  Our ECM Mapper Node Property Sets supported
//
//  This table defines all property sets supported by the
//  Our ECM Mapper Node associated with the transport output pin.
//
DEFINE_KSPROPERTY_SET_TABLE(OurECMMapperNodePropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaEcmMap,							// Set
        SIZEOF_ARRAY(OurECMMapperNodeECMMapProperties), // PropertiesCount
        OurECMMapperNodeECMMapProperties,               // PropertyItems
        0,												// FastIoCount
        NULL											// FastIoTable
    ),

    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaCA,								// Set
        SIZEOF_ARRAY(OurECMMapperNodeCAProperties),		// PropertiesCount
        OurECMMapperNodeCAProperties,	                // PropertyItems
        0,												// FastIoCount
        NULL											// FastIoTable
    )
};

DEFINE_KSEVENT_TABLE(OurECMMapperNodeCAEvents)
{
	DEFINE_KSEVENT_BDA_ECM_MAP_STATUS_CHANGED
	(
		NULL, NULL, NULL
	),
	DEFINE_KSEVENT_BDA_CA_MODULE_STATUS_CHANGED
	(
		NULL, NULL, NULL
	),
	DEFINE_KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED
	(
		NULL, NULL, NULL
	),
	DEFINE_KSEVENT_BDA_CA_MODULE_UI_REQUESTED
	(
		NULL, NULL, NULL
	)
};

DEFINE_KSEVENT_SET_TABLE(OurECMMapperNodeEventsSets)
{
	DEFINE_KSEVENT_SET
	(   
		&KSEVENTSETID_BdaCAEvent,
		SIZEOF_ARRAY(OurECMMapperNodeCAEvents),
        OurECMMapperNodeCAEvents
	)
};

//
//  Our ECM Mapper Node Automation Table
//
//
DEFINE_KSAUTOMATION_TABLE(OurECMMapperNodeAutomation) {
	//SHOULD BE:
	//
    //DEFINE_KSAUTOMATION_PROPERTIES(OurECMMapperNodePropertySets),
    //DEFINE_KSAUTOMATION_METHODS_NULL,
    //DEFINE_KSAUTOMATION_EVENTS(OurECMMapperNodeEventsSets)
	//
	//but KSPROXY does not yet aggregate node automation tables with pin
	//automation tables so we will do it manually, for now leaving no
	//automation on this node
    DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//===========================================================================
//
//  Transport Input Pin Definitions
//
//===========================================================================

//
//  Transport Input Pin Automation Table
//
//  Lists all Property, Method, and Event Set tables for the transport pin
//
DEFINE_KSAUTOMATION_TABLE(TransportInputAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  Dispatch Table for the ATSC transport Output pin.
//
//  Since data on the transport is actually delivered to the
//  PCI bridge in hardware, this pin does not need to process
//  data.
//
//  Connection of, and state transitions on, this pin help the
//  driver to determine when to allocate hardware resources for
//  the tuner and demodulator.
//
const
KSPIN_DISPATCH
TransportInputPinDispatch =
{
    CTransportInputPin::PinCreate,           // Create
    CTransportInputPin::PinClose,            // Close
    NULL,                               // Process
    NULL,                               // Reset
    NULL,                               // SetDataFormat
    PinSetDeviceState,					// SetDeviceState
    NULL,                               // Connect
    NULL,                               // Disconnect
    NULL,                               // Clock
    NULL                                // Allocator
};


//
//  Format of an ATSC Transport Stream Connection
//
//  Used to connect the Transport Stream output pin to the
//  Capture Filter.
//
#ifdef NEW_BDA_TRANSPORT_FORMAT
const KS_DATARANGE_BDA_TRANSPORT TransportInputPinRange =
{
   // KSDATARANGE
    {
        sizeof( KS_DATARANGE_BDA_TRANSPORT),               // FormatSize
        0,                                                 // Flags - (N/A)
        0,                                                 // SampleSize - (N/A)
        0,                                                 // Reserved
        { STATIC_KSDATAFORMAT_TYPE_STREAM },               // MajorFormat
        { STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT },      // SubFormat
        { STATIC_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT }    // Specifier
    },
    //  BDA_TRANSPORT_INFO
    {
        188,        //  ulcbPhyiscalPacket
        312 * 188,  //  ulcbPhyiscalFrame
        0,          //  ulcbPhyiscalFrameAlignment (no requirement)
        0           //  AvgTimePerFrame (not known)
    }

};
#else
const KS_DATARANGE_ANALOGVIDEO TransportInputPinRange =
{
    // KS_DATARANGE_ANALOGVIDEO
    {
        sizeof (KS_DATARANGE_ANALOGVIDEO),      // FormatSize
        0,                                      // Flags
        sizeof (KS_TVTUNER_CHANGE_INFO),        // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO,   // aka MEDIATYPE_AnalogVideo
        STATIC_KSDATAFORMAT_SUBTYPE_NONE,
        STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO, // aka FORMAT_AnalogVideo
    },
    // KS_ANALOGVIDEOINFO
    {
        0, 0, 720, 480,         // rcSource;
        0, 0, 720, 480,         // rcTarget;
        720,                    // dwActiveWidth;
        480,                    // dwActiveHeight;
        0,                      // REFERENCE_TIME  AvgTimePerFrame;
    }
};
#endif // NEW_BDA_TRANSPORT_FORMAT

//  Format Ranges of Transport Output Pin.
//
static PKSDATAFORMAT TransportInputPinRanges[] =
{
    (PKSDATAFORMAT) &TransportInputPinRange,

    // Add more formats here if additional transport formats are supported.
    //
};

//===========================================================================
//
//  Transport Output Pin Definitions
//
//===========================================================================

//
//  Transport Output Pin Automation Table
//
//  Lists all Property, Method, and Event Set tables for the transport pin
//
DEFINE_KSAUTOMATION_TABLE(TransportOutputAutomation) {
	//SHOULD BE:
	//
    //DEFINE_KSAUTOMATION_PROPERTIES_NULL,
    //DEFINE_KSAUTOMATION_METHODS_NULL,
    //DEFINE_KSAUTOMATION_EVENTS_NULL
	//
	//but KSPROXY does not yet aggregate node automation tables with pin
	//automation tables so we will do it manually, for now we will manually
	//move node automation to this pin
    DEFINE_KSAUTOMATION_PROPERTIES(OurECMMapperNodePropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS(OurECMMapperNodeEventsSets)
};

//
//  Dispatch Table for the ATSC transport Output pin.
//
//  Since data on the transport is actually delivered to the
//  PCI bridge in hardware, this pin does not need to process
//  data.
//
//  Connection of, and state transitions on, this pin help the
//  driver to determine when to allocate hardware resources for
//  the tuner and demodulator.
//
const
KSPIN_DISPATCH
TransportOutputPinDispatch =
{
    CTransportOutputPin::PinCreate,     // Create
    CTransportOutputPin::PinClose,      // Close
    NULL,                               // Process
    NULL,                               // Reset
    NULL,                               // SetDataFormat
    PinSetDeviceState,					// SetDeviceState
    NULL,                               // Connect
    NULL,                               // Disconnect
    NULL,                               // Clock
    NULL                                // Allocator
};


//
//  Format of an ATSC Transport Stream Connection
//
//  Used to connect the Transport Stream output pin to the
//  Capture Filter.
//
#ifdef NEW_BDA_TRANSPORT_FORMAT
const KS_DATARANGE_BDA_TRANSPORT TransportOutputPinRange =
{
   // KSDATARANGE
    {
        sizeof( KS_DATARANGE_BDA_TRANSPORT),               // FormatSize
        0,                                                 // Flags - (N/A)
        0,                                                 // SampleSize - (N/A)
        0,                                                 // Reserved
        { STATIC_KSDATAFORMAT_TYPE_STREAM },               // MajorFormat
        { STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT },      // SubFormat
        { STATIC_KSDATAFORMAT_SPECIFIER_BDA_TRANSPORT }    // Specifier
    },
    //  BDA_TRANSPORT_INFO
    {
        188,        //  ulcbPhyiscalPacket
        312 * 188,  //  ulcbPhyiscalFrame
        0,          //  ulcbPhyiscalFrameAlignment (no requirement)
        0           //  AvgTimePerFrame (not known)
    }

};
#else
const KS_DATARANGE_ANALOGVIDEO TransportOutputPinRange =
{
    // KS_DATARANGE_ANALOGVIDEO
    {
        sizeof (KS_DATARANGE_ANALOGVIDEO),      // FormatSize
        0,                                      // Flags
        sizeof (KS_TVTUNER_CHANGE_INFO),        // SampleSize
        0,                                      // Reserved

        STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO,   // aka MEDIATYPE_AnalogVideo
        STATIC_KSDATAFORMAT_SUBTYPE_NONE,
        STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO, // aka FORMAT_AnalogVideo
    },
    // KS_ANALOGVIDEOINFO
    {
        0, 0, 720, 480,         // rcSource;
        0, 0, 720, 480,         // rcTarget;
        720,                    // dwActiveWidth;
        480,                    // dwActiveHeight;
        0,                      // REFERENCE_TIME  AvgTimePerFrame;
    }
};
#endif // NEW_BDA_TRANSPORT_FORMAT

//  Format Ranges of Transport Output Pin.
//
static PKSDATAFORMAT TransportOutputPinRanges[] =
{
    (PKSDATAFORMAT) &TransportOutputPinRange,

    // Add more formats here if additional transport formats are supported.
    //
};


//===========================================================================
//
//  Filter  definitions
//
//===========================================================================

//
//  Template Node Descriptors
//
//  This array describes all Node Types available in the template
//  topology of the filter.
//
const
KSNODE_DESCRIPTOR
NodeDescriptors[] =
{
    {
        &OurECMMapperNodeAutomation,        // PKSAUTOMATION_TABLE AutomationTable;
        &KSNODE_BDA_OUR_ECMMAPER,			// Type
        NULL								// Name
    }
};


//
//  Initial Pin Descriptors
//
//  This data structure defines the pins that will appear on the filer
//  when it is first created.
//
const
KSPIN_DESCRIPTOR_EX
InitialPinDescriptors[] =
{
    //  Tranport Input Pin
    //
    {
        &TransportInputPinDispatch,
        &TransportInputAutomation,   // TransportPinAutomation
        {
            0,  // Interfaces
            NULL,
            0,  // Mediums
            NULL,
            SIZEOF_ARRAY(TransportInputPinRanges),
            TransportInputPinRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            (GUID *) &PINNAME_BDA_TRANSPORT,   // Name
            (GUID *) &PINNAME_BDA_TRANSPORT,   // Category
            0
        },
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | KSPIN_FLAG_FIXED_FORMAT,
        1,
        1,      // InstancesNecessary
        NULL,   // Allocator Framing
		CTransportInputPin::IntersectDataFormat    // PinIntersectHandler
    }
};


//
//  Template Pin Descriptors
//
//  This data structure defines the pin types available in the filters
//  template topology.  These structures will be used to create a
//  KSPinFactory for a pin type when BdaCreatePin is called.
//
const
KSPIN_DESCRIPTOR_EX
TemplatePinDescriptors[] =
{
    //  Tranport Input Pin
    //
    {
        &TransportInputPinDispatch,
        &TransportInputAutomation,   // TransportPinAutomation
        {
            0,  // Interfaces
            NULL,
            0,  // Mediums
            NULL,
            SIZEOF_ARRAY(TransportInputPinRanges),
            TransportInputPinRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            (GUID *) &PINNAME_BDA_TRANSPORT,   // Name
            (GUID *) &PINNAME_BDA_TRANSPORT,   // Category
            0
        },
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | KSPIN_FLAG_FIXED_FORMAT,
        1,
        1,      // InstancesNecessary
        NULL,   // Allocator Framing
        CTransportInputPin::IntersectDataFormat    // PinIntersectHandler
    },

    //  Tranport Output Pin
    //
    {
        &TransportOutputPinDispatch,
        &TransportOutputAutomation,   // TransportPinAutomation
        {
            0,  // Interfaces
            NULL,
            0,  // Mediums
            NULL,
            SIZEOF_ARRAY(TransportOutputPinRanges),
            TransportOutputPinRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            (GUID *) &PINNAME_BDA_TRANSPORT,   // Name
            (GUID *) &PINNAME_BDA_TRANSPORT,   // Category
            0
        },
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT | KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | KSPIN_FLAG_FIXED_FORMAT,
        1,
        0,      // InstancesNecessary
        NULL,   // Allocator Framing
        CTransportOutputPin::IntersectDataFormat    // PinIntersectHandler
    }
};


//
//  BDA Device Topology Property Set
//
//  Defines the dispatch routines for the filter level
//  topology properties
//
DEFINE_KSPROPERTY_TABLE(FilterTopologyProperties)
{
    DEFINE_KSPROPERTY_ITEM_BDA_NODE_TYPES(
        BdaPropertyNodeTypes,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_PIN_TYPES(
        BdaPropertyPinTypes,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_TEMPLATE_CONNECTIONS(
        BdaPropertyTemplateConnections,
        NULL
        ),
    DEFINE_KSPROPERTY_ITEM_BDA_CONTROLLING_PIN_ID(
        BdaPropertyGetControllingPinId,
        NULL
        )
};


//
//  Filter Level Property Sets supported
//
//  This table defines all property sets supported by the
//  tuner filter exposed by this driver.
//
DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_BdaTopology,                   // Set
        SIZEOF_ARRAY(FilterTopologyProperties),     // PropertiesCount
        FilterTopologyProperties,                   // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    )
};


//
//  BDA Change Sync Method Set
//
//  Defines the dispatch routines for the filter level
//  Change Sync methods
//
DEFINE_KSMETHOD_TABLE(BdaChangeSyncMethods)
{
    DEFINE_KSMETHOD_ITEM_BDA_START_CHANGES(
        CFilter::StartChanges,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_CHECK_CHANGES(
        CFilter::CheckChanges,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_COMMIT_CHANGES(
        CFilter::CommitChanges,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_GET_CHANGE_STATE(
        CFilter::GetChangeState,
        NULL
        )
};


//
//  BDA Device Configuration Method Set
//
//  Defines the dispatch routines for the filter level
//  Topology Configuration methods
//
DEFINE_KSMETHOD_TABLE(BdaDeviceConfigurationMethods)
{
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_PIN_FACTORY(
        BdaMethodCreatePin,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_DELETE_PIN_FACTORY(
        BdaMethodDeletePin,
        NULL
        ),
    DEFINE_KSMETHOD_ITEM_BDA_CREATE_TOPOLOGY(
        CFilter::CreateTopology,
        NULL
        )
};


//
//  Filter Level Method Sets supported
//
//  This table defines all method sets supported by the
//  tuner filter exposed by this driver.
//
DEFINE_KSMETHOD_SET_TABLE(FilterMethodSets)
{
    DEFINE_KSMETHOD_SET
    (
        &KSMETHODSETID_BdaChangeSync,               // Set
        SIZEOF_ARRAY(BdaChangeSyncMethods),         // PropertiesCount
        BdaChangeSyncMethods,                       // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

    DEFINE_KSMETHOD_SET
    (
        &KSMETHODSETID_BdaDeviceConfiguration,      // Set
        SIZEOF_ARRAY(BdaDeviceConfigurationMethods),// PropertiesCount
        BdaDeviceConfigurationMethods,              // PropertyItems
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    )
};


//
//  Filter Automation Table
//
//  Lists all Property, Method, and Event Set tables for the filter
//
DEFINE_KSAUTOMATION_TABLE(FilterAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(FilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS(FilterMethodSets),
    DEFINE_KSAUTOMATION_EVENTS_NULL
};


//
//  Filter Dispatch Table
//
//  Lists the dispatch routines for major events at the filter
//  level.
//
const
KSFILTER_DISPATCH
FilterDispatch =
{
    CFilter::Create,        // Create
    CFilter::FilterClose,   // Close
    NULL,                   // Process
    NULL                    // Reset
};

//
//  Filter Factory Descriptor for the tuner filter
//
//  This structure brings together all of the structures that define
//  the tuner filter as it appears when it is first instanciated.
//  Note that not all of the template pin and node types may be exposed as
//  pin and node factories when the filter is first instanciated.
//
DEFINE_KSFILTER_DESCRIPTOR(InitialTunerFilterDescriptor)
{
    &FilterDispatch,                                    // Dispatch
    &FilterAutomation,                                  // AutomationTable
    KSFILTER_DESCRIPTOR_VERSION,                        // Version
    0,                                                  // Flags
    &KSNAME_Filter,                                     // ReferenceGuid

    DEFINE_KSFILTER_PIN_DESCRIPTORS(InitialPinDescriptors), // PinDescriptorsCount
                                                            // PinDescriptorSize
                                                            // PinDescriptors


    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_BDA_RECEIVER_COMPONENT),// CategoriesCount
                                                                // Categories

    DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL,              // NodeDescriptorsCount
                                                        // NodeDescriptorSize
                                                        // NodeDescriptors

    DEFINE_KSFILTER_DEFAULT_CONNECTIONS,                // ConnectionsCount
                                                        // Connections

    NULL                                                // ComponentId
};


//===========================================================================
//
//  Filter Template Topology  definitions
//
//===========================================================================

//
//  Our Node index number (zero because its the only node)
//
#define OUR_ECMMAPPER_NODE_NUMBER 0


//
//  BDA Template Topology Connections
//
//  Lists the Connections that are possible between pin types and
//  node types.  This, together with the Template Filter Descriptor, and
//  the Pin Pairings, describe how topologies can be created in the filter.
//
const
KSTOPOLOGY_CONNECTION TemplateFilterConnections[] =
{
    { KSFILTER_NODE,  0,				OUR_ECMMAPPER_NODE_NUMBER,  0},
    { OUR_ECMMAPPER_NODE_NUMBER,  1,	KSFILTER_NODE, 1}
};


//
//  Template Joints between the Antenna and Transport Pin Types.
//
//  Lists the template joints between the Antenna Input Pin Type and
//  the Transport Output Pin Type.
//
const
ULONG   TransportJoints[] =
{
    0
};

//
//  Template Pin Parings.
//
//  These are indexes into the template connections structure that
//  are used to determine which nodes get duplicated when more than
//  one output pin type is connected to a single input pin type or when
//  more that one input pin type is connected to a single output pin
//  type.
//
const
BDA_PIN_PAIRING TemplateTunerPinPairings[] =
{
    //  Antenna to Transport Topology Joints
    //
    {
        0,  // ulInputPin
        1,  // ulOutputPin
        1,  // ulcMaxInputsPerOutput
        1,  // ulcMinInputsPerOutput
        1,  // ulcMaxOutputsPerInput
        1,  // ulcMinOutputsPerInput
        SIZEOF_ARRAY(TransportJoints),   // ulcTopologyJoints
        TransportJoints                  // pTopologyJoints
    }
};


//
//  Filter Factory Descriptor for the tuner filter template topology
//
//  This structure brings together all of the structures that define
//  the topologies that the tuner filter can assume as a result of
//  pin factory and topology creation methods.
//  Note that not all of the template pin and node types may be exposed as
//  pin and node factories when the filter is first instanciated.
//
DEFINE_KSFILTER_DESCRIPTOR(TemplateTunerFilterDescriptor)
{
    &FilterDispatch,                                    // Dispatch
    &FilterAutomation,                                  // AutomationTable
    KSFILTER_DESCRIPTOR_VERSION,                        // Version
    0,                                                  // Flags
    &KSNAME_Filter,                                     // ReferenceGuid

    DEFINE_KSFILTER_PIN_DESCRIPTORS(TemplatePinDescriptors),// PinDescriptorsCount
                                                            // PinDescriptorSize
                                                            // PinDescriptors


    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_BDA_RECEIVER_COMPONENT),// CategoriesCount
                                                                // Categories

    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),  // NodeDescriptorsCount
                                                        // NodeDescriptorSize
                                                        // NodeDescriptors

    DEFINE_KSFILTER_CONNECTIONS(TemplateFilterConnections), // ConnectionsCount
                                                            // Connections

    NULL                                                // ComponentId
};


//
//  BDA Template Topology Descriptor for the filter.
//
//  This structure define the pin and node types that may be created
//  on the filter.
//
const
BDA_FILTER_TEMPLATE
TunerBdaFilterTemplate =
{
    &TemplateTunerFilterDescriptor,
    SIZEOF_ARRAY(TemplateTunerPinPairings),
    TemplateTunerPinPairings
};


//===========================================================================
//
//  Device definitions
//
//===========================================================================


//
//  Array containing descriptors for all of the filter factories
//  that are available on the device.
//
//  Note!  This only used when dynamic topology is not desired.
//         (i.e. filters and pins are fixed, usually there is also no
//          network provider in this case)
//
DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{
    &TemplateTunerFilterDescriptor
};


//
//  Device Dispatch Table
//
//  Lists the dispatch routines for the major events in the life
//  of the underlying device.
//
extern
const
KSDEVICE_DISPATCH
DeviceDispatch =
{
    CDevice::Create,    // Add
    CDevice::Start,     // Start
    NULL,               // PostStart
    NULL,               // QueryStop
    NULL,               // CancelStop
    NULL,               // Stop
    NULL,               // QueryRemove
    NULL,               // CancelRemove
    NULL,               // Remove
    NULL,               // QueryCapabilities
    NULL,               // SurpriseRemoval
    NULL,               // QueryPower
    NULL                // SetPower
};


//
//  Device Descriptor
//
//  Brings together all data structures that define the device and
//  the intial filter factories that can be created on it.
//  Note that this structure does not include the template topology
//  structures as they are specific to BDA.
//
extern
const
KSDEVICE_DESCRIPTOR
DeviceDescriptor =
{
    &DeviceDispatch,    // Dispatch
#ifdef DYNAMIC_TOPOLOGY
    0,      // SIZEOF_ARRAY( FilterDescriptors),   // FilterDescriptorsCount
    NULL   // FilterDescriptors                   // FilterDescriptors
#else
    SIZEOF_ARRAY( FilterDescriptors),   // FilterDescriptorsCount
    FilterDescriptors                   // FilterDescriptors
#endif // DYNAMIC_TOPOLOGY
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\outpin.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    outpin.cpp

Abstract:

    Transport Ouput pin code.

--*/

#include "casamp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

NTSTATUS
CTransportOutputPin::PinCreate(
    IN OUT PKSPIN pKSPin,
    IN PIRP Irp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    CTransportOutputPin*      pPin;
    CFilter*            pFilter;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CTransportOutputPin::PinCreate"));

    ASSERT(pKSPin);
    ASSERT(Irp);

    //  Get a pointer to our filter instance that this pin is being
    //  created for.  Remember it for later.
    //
    pFilter = reinterpret_cast<CFilter*>(KsGetFilterFromIrp(Irp)->Context);

    //  Create our transport pin object.
    //
    pPin = new(PagedPool,'IFsK') CTransportOutputPin;
    if (!pPin)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //  Link our pin context to our filter context.
    //
    pPin->SetFilter( pFilter);

    //  Link our context to the KSPIN structure.
    //
    pKSPin->Context = pPin;

exit:
    return Status;
}


NTSTATUS
CTransportOutputPin::PinClose(
    IN OUT PKSPIN Pin,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("PinClose"));

    ASSERT(Pin);
    ASSERT(Irp);

    CTransportOutputPin* pin = reinterpret_cast<CTransportOutputPin*>(Pin->Context);

    ASSERT(pin);

    delete pin;

    return STATUS_SUCCESS;
}

NTSTATUS
CTransportOutputPin::GetECMMapStatus(
	IN PIRP			Irp,
	IN PKSPROPERTY	pKSProperty,
    IN PULONG       pulProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::GetCAModuleStatus(
	IN PIRP			Irp,
	IN PKSPROPERTY	pKSProperty,
    IN PULONG       pulProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::GetCASmartCardStatus(
	IN PIRP			Irp,
	IN PKSPROPERTY	pKSProperty,
    IN PULONG       pulProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::GetCAModuleUI(
	IN PIRP					Irp,
	IN PKSPROPERTY			pKSProperty,
	IN PBDA_CA_MODULE_UI	pCAModuleUIProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::PutECMMapEMMPID(
    IN PIRP         Irp,
    IN PKSPROPERTY  pKSProperty,
    IN PULONG       pulProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::GetECMMapList(
    IN PIRP			Irp,
    IN PKSPROPERTY	pKSProperty,
    IN PBDA_ECM_MAP	pECMMapProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::PutECMMapUpdateMap(
    IN PIRP         Irp,
    IN PKSPROPERTY  pKSProperty,
    IN PBDA_ECM_MAP pECMMapProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::PutECMMapRemoveMap(
    IN PIRP         Irp,
    IN PKSPROPERTY  pKSProperty,
    IN PBDA_ECM_MAP pECMMapProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::PutECMMapUpdateESDescriptor(
    IN PIRP				  Irp,
    IN PKSPROPERTY		  pKSProperty,
    IN PBDA_ES_DESCRIPTOR pESDescProperty
    )
{
	return E_NOTIMPL;
}

NTSTATUS
CTransportOutputPin::PutECMMapUpdateProgramDescriptor(
    IN PIRP				       Irp,
    IN PKSPROPERTY		       pKSProperty,
    IN PBDA_PROGRAM_DESCRIPTOR pProgramDescProperty
    )
{
	return E_NOTIMPL;
}


NTSTATUS
CTransportOutputPin::IntersectDataFormat(
	    IN PVOID pContext,
		IN PIRP pIrp,
		IN PKSP_PIN Pin,
		IN PKSDATARANGE DataRange,
		IN PKSDATARANGE MatchingDataRange,
		IN ULONG DataBufferSize,
		OUT PVOID Data OPTIONAL,
		OUT PULONG DataSize
     )
{
	if ( DataBufferSize < sizeof(KS_DATARANGE_BDA_TRANSPORT) )
	{
		*DataSize = sizeof( KS_DATARANGE_BDA_TRANSPORT );
		return STATUS_BUFFER_OVERFLOW;
	}
	else
	{
		ASSERT(DataBufferSize == sizeof(KS_DATARANGE_BDA_TRANSPORT));

		*DataSize = sizeof( KS_DATARANGE_BDA_TRANSPORT );
		RtlCopyMemory( Data, (PVOID)DataRange, sizeof(KS_DATARANGE_BDA_TRANSPORT));

		return STATUS_SUCCESS;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\inc\bdatypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  File: bdatypes.h
//
//  Typedefs and enums needed by both the wdm drivers and the
//  user mode com interfaces
//
//----------------------------------------------------------------------------

#ifndef _BDATYPES_

#define _BDATYPES_      1

/* Utility Macros */

#define MIN_DIMENSION   1
#define NATURAL     4
#define CACHE_LINE  128
#define PAGE        4096
#define ALIGN( pointer, size) (((ULONG)(pointer) + (ULONG)(size) - 1) & ~((ULONG)(size) - 1))
#define BDA_STRING_CONST(x)   {sizeof(L##x)-2, sizeof(L##x), L##x}



//===========================================================================
//
//  BDA Topology Structures
//
//===========================================================================

typedef struct _BDA_TEMPLATE_CONNECTION
{
    ULONG   FromNodeType;
    ULONG   FromNodePinType;
    ULONG   ToNodeType;
    ULONG   ToNodePinType;
}BDA_TEMPLATE_CONNECTION, *PBDA_TEMPLATE_CONNECTION;


typedef struct _BDA_TEMPLATE_PIN_JOINT
{
    ULONG   uliTemplateConnection;
    ULONG   ulcInstancesMax;
}BDA_TEMPLATE_PIN_JOINT, *PBDA_TEMPLATE_PIN_JOINT;



//===========================================================================
//
//  BDA Events
//
//===========================================================================

//  In-band Event IDs
//
typedef enum {
    BDA_EVENT_SIGNAL_LOSS = 0,
    BDA_EVENT_SIGNAL_LOCK,
    BDA_EVENT_DATA_START,
    BDA_EVENT_DATA_STOP,
    BDA_EVENT_CHANNEL_ACQUIRED,
    BDA_EVENT_CHANNEL_LOST,
    BDA_EVENT_CHANNEL_SOURCE_CHANGED,
    BDA_EVENT_CHANNEL_ACTIVATED,
    BDA_EVENT_CHANNEL_DEACTIVATED,
    BDA_EVENT_SUBCHANNEL_ACQUIRED,
    BDA_EVENT_SUBCHANNEL_LOST,
    BDA_EVENT_SUBCHANNEL_SOURCE_CHANGED,
    BDA_EVENT_SUBCHANNEL_ACTIVATED,
    BDA_EVENT_SUBCHANNEL_DEACTIVATED,
    BDA_EVENT_ACCESS_GRANTED,
    BDA_EVENT_ACCESS_DENIED,
    BDA_EVENT_OFFER_EXTENDED,
    BDA_EVENT_PURCHASE_COMPLETED,
    BDA_EVENT_SMART_CARD_INSERTED,
    BDA_EVENT_SMART_CARD_REMOVED
} BDA_EVENT_ID, *PBDA_EVENT_ID;



//===========================================================================
//
//  KSSTREAM_HEADER extensions for BDA
//
//===========================================================================

typedef struct tagKS_BDA_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  //
    ULONG                   ulEvent; //
    ULONG                   ulChannelNumber; //
    ULONG                   ulSubchannelNumber; //
    ULONG                   ulReason; //
} KS_BDA_FRAME_INFO, *PKS_BDA_FRAME_INFO;


//------------------------------------------------------------
//
//  BDA Network Ethernet Filter Property Set
//
// {71985F43-1CA1-11d3-9CC8-00C04F7971E0}
//
typedef struct _BDA_ETHERNET_ADDRESS {
    BYTE    rgbAddress[6];
} BDA_ETHERNET_ADDRESS, *PBDA_ETHERNET_ADDRESS;

typedef struct _BDA_ETHERNET_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_ETHERNET_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_ETHERNET_ADDRESS_LIST, * PBDA_ETHERNET_ADDRESS_LIST;

typedef enum {
    BDA_PROMISCUOUS_MULTICAST = 0,
    BDA_FILTERED_MULTICAST,
    BDA_NO_MULTICAST
} BDA_MULTICAST_MODE, *PBDA_MULTICAST_MODE;


//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {71985F44-1CA1-11d3-9CC8-00C04F7971E0}
//
typedef struct _BDA_IPv4_ADDRESS {
    BYTE    rgbAddress[4];
} BDA_IPv4_ADDRESS, *PBDA_IPv4_ADDRESS;

typedef struct _BDA_IPv4_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_IPv4_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_IPv4_ADDRESS_LIST, * PBDA_IPv4_ADDRESS_LIST;


//------------------------------------------------------------
//
//  BDA Network IPv4 Filter Property Set
//
// {E1785A74-2A23-4fb3-9245-A8F88017EF33}
//
typedef struct _BDA_IPv6_ADDRESS {
    BYTE    rgbAddress[6];
} BDA_IPv6_ADDRESS, *PBDA_IPv6_ADDRESS;

typedef struct _BDA_IPv6_ADDRESS_LIST {
    ULONG               ulcAddresses;
    BDA_IPv6_ADDRESS    rgAddressl[MIN_DIMENSION];
} BDA_IPv6_ADDRESS_LIST, * PBDA_IPv6_ADDRESS_LIST;


//------------------------------------------------------------
//
//
//  BDA Signal Property Set
//
//  {D2F1644B-B409-11d2-BC69-00A0C9EE9E16}
//
typedef enum {
    BDA_SIGNAL_UNAVAILABLE = 0,
    BDA_SIGNAL_INACTIVE,
    BDA_SIGNAL_ACTIVE
} BDA_SIGNAL_STATE, * PBDA_SIGNAL_STATE;


//------------------------------------------------------------
//
//
//  BDA Change Sync Method Set
//
// {FD0A5AF3-B41D-11d2-9C95-00C04F7971E0}
//
typedef enum
{
    BDA_CHANGES_COMPLETE = 0,
    BDA_CHANGES_PENDING

} BDA_CHANGE_STATE, * PBDA_CHANGE_STATE;


//------------------------------------------------------------
//
//
//  BDA Device Configuration Method Set
//
// {71985F45-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Topology Property Set
//
// {A14EE835-0A23-11d3-9CC7-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Void Transform Property Set
//
// {71985F46-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Null Transform Property Set
//
// {DDF15B0D-BD25-11d2-9CA0-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Frequency Filter Property Set
//
// {71985F47-1CA1-11d3-9CC8-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA Autodemodulate Property Set
//
// {DDF15B12-BD25-11d2-9CA0-00C04F7971E0}
//


//------------------------------------------------------------
//
//
//  BDA EcmMap Property Set
//
// {FA14A8B3-6068-48ef-96DD-53010B985A7D}
//
typedef enum
{
    ECM_MAP_STATE_GOOD_FLOW = 0,
    ECM_MAP_STATE_NO_CONTENT,
    ECM_MAP_STATE_NO_ECM,
    ECM_MAP_STATE_BAD_MAP
} BDA_ECM_MAP_STATE, *PBDA_ECM_MAP_STATE;

typedef struct _BDA_ECM_MAP
{
    ULONG               ulContentPID;
    ULONG               ulEcmPID;
	ULONG               ulProgramNum;
	ULONG               ulStreamType;
    BDA_ECM_MAP_STATE   mapState;
} BDA_ECM_MAP, *PBDA_ECM_MAP;

typedef struct _BDA_ES_DESCRIPTOR
{
    ULONG               ulContentPID;
    ULONG				ulTag;
	ULONG				ulCASystemID;
    ULONG				ulcbPrivateData;
    ULONG				argbPrivateData[MIN_DIMENSION];
} BDA_ES_DESCRIPTOR, *PBDA_ES_DESCRIPTOR;

typedef struct _BDA_PROGRAM_DESCRIPTOR
{
    ULONG               ulProgramNum;
    ULONG				ulTag;
	ULONG				ulCASystemID;
    ULONG				ulcbPrivateData;
    ULONG				argbPrivateData[MIN_DIMENSION];
} BDA_PROGRAM_DESCRIPTOR, *PBDA_PROGRAM_DESCRIPTOR;

//------------------------------------------------------------
//
//
//  BDA PID Filter Property Set
//
// {D0A67D65-08DF-4fec-8533-E5B550410B85}
//
typedef struct _BDA_PID_MAP
{
    ULONG               ulMediaSampleContent;
    ULONG               ulcPIDs;
	ULONG               aulPIDs[MIN_DIMENSION];
} BDA_PID_MAP, *PBDA_PID_MAP;

typedef struct _BDA_PID_UNMAP
{
    ULONG               ulcPIDs;
	ULONG               aulPIDs[MIN_DIMENSION];
} BDA_PID_UNMAP, *PBDA_PID_UNMAP;

//KSPROPERTY_BDA_PIDFILTER_LIST_PIDS should return an array of:
typedef struct _BDA_PID_SINGLE_MAPING
{
    ULONG               ulMediaSampleContent;
    ULONG               ulcPID;
} BDA_PID_SINGLE_MAPING, *PBDA_PID_SINGLE_MAPING;

//------------------------------------------------------------
//
//
//  BDA CA Property Set
//
// {B0693766-5278-4ec6-B9E1-3CE40560EF5A}
//
typedef struct _BDA_CA_MODULE_UI
{
    ULONG	ulFormat;
	ULONG   ulbcDesc;
	ULONG   ulDesc[MIN_DIMENSION];
} BDA_CA_MODULE_UI, *PBDA_CA_MODULE_UI;


//------------------------------------------------------------
//
//
//  BDA CA Event Set
//
// {488C4CCC-B768-4129-8EB1-B00A071F9068}
//



//=============================================================
//
//
//  BDA Tuning Model enumerations
//
//
//=============================================================

// system type for particular DVB Tuning Space instance
typedef enum DVBSystemType {
    DVB_Cable,
    DVB_Terrestrial,
    DVB_Satellite,
} DVBSystemType;

//------------------------------------------------------------
//
//  BDA Channel Tune Request

enum {
    BDA_UNDEFINED_CHANNEL = -1,
};


//------------------------------------------------------------
//
//  BDA Component(substream)
//

typedef enum ComponentCategory
{
    CategoryNotSet = -1,
    CategoryOther = 0,
    CategoryVideo,
    CategoryAudio,
    CategoryText,
    CategoryData,
} ComponentCategory;

// Component Status
typedef enum ComponentStatus
{
    StatusActive,
    StatusInactive,
    StatusUnavailable,
} ComponentStatus;


//------------------------------------------------------------
//
//  BDA MPEG2 Component Type
//
// from the MPEG2 specification
typedef enum MPEG2StreamType {
    BDA_UNITIALIZED_MPEG2STREAMTYPE = -1,
    Reserved1 = 0x0,
    ISO_IEC_11172_2_VIDEO   = Reserved1 + 1,
    ISO_IEC_13818_2_VIDEO   = ISO_IEC_11172_2_VIDEO + 1,
    ISO_IEC_11172_3_AUDIO   = ISO_IEC_13818_2_VIDEO + 1,
    ISO_IEC_13818_3_AUDIO   = ISO_IEC_11172_3_AUDIO + 1,
    ISO_IEC_13818_1_PRIVATE_SECTION = ISO_IEC_13818_3_AUDIO + 1,
    ISO_IEC_13818_1_PES     = ISO_IEC_13818_1_PRIVATE_SECTION + 1,
    ISO_IEC_13522_MHEG      = ISO_IEC_13818_1_PES + 1,
    ANNEX_A_DSM_CC          = ISO_IEC_13522_MHEG + 1,
    ITU_T_REC_H_222_1       = ANNEX_A_DSM_CC + 1,
    ISO_IEC_13818_6_TYPE_A  = ITU_T_REC_H_222_1 + 1,
    ISO_IEC_13818_6_TYPE_B  = ISO_IEC_13818_6_TYPE_A + 1,
    ISO_IEC_13818_6_TYPE_C  = ISO_IEC_13818_6_TYPE_B + 1,
    ISO_IEC_13818_6_TYPE_D  = ISO_IEC_13818_6_TYPE_C + 1,
    ISO_IEC_13818_1_AUXILIARY = ISO_IEC_13818_6_TYPE_D + 1,
    ISO_IEC_13818_1_RESERVED = ISO_IEC_13818_1_AUXILIARY + 1,
    USER_PRIVATE            = ISO_IEC_13818_1_RESERVED + 1
} MPEG2StreamType;


//------------------------------------------------------------
//
//  BDA ATSC Component Type
//
//
// ATSC made AC3 Audio a descriptor instead of
// defining a user private stream type.
typedef enum ATSCComponentTypeFlags {
    // bit flags for various component type properties
    ATSCCT_AC3 = 0x00000001,
} ATSCComponentTypeFlags;


//------------------------------------------------------------
//
//  BDA Locators
//


typedef enum BinaryConvolutionCodeRate {
    BDA_BCC_RATE_NOT_SET = -1,
    BDA_BCC_RATE_NOT_DEFINED = 0,
    BDA_BCC_RATE_1_2 = 1,   // 1/2
    BDA_BCC_RATE_2_3,   // 2/3
    BDA_BCC_RATE_3_4,   // 3/4
    BDA_BCC_RATE_3_5,
    BDA_BCC_RATE_4_5,
    BDA_BCC_RATE_5_6,   // 5/6
    BDA_BCC_RATE_5_11,
    BDA_BCC_RATE_7_8,   // 7/8
    BDA_BCC_RATE_MAX,
} BinaryConvolutionCodeRate;

typedef enum FECMethod {
    BDA_FEC_METHOD_NOT_SET = -1,
    BDA_FEC_METHOD_NOT_DEFINED = 0,
    BDA_FEC_VITERBI = 1,          // FEC is a Viterbi Binary Convolution.
    BDA_FEC_RS_204_188,       // The FEC is Reed-Solomon 204/188 (outer FEC)
    BDA_FEC_MAX,
} FECMethod;

typedef enum ModulationType {
    BDA_MOD_NOT_SET = -1,
    BDA_MOD_NOT_DEFINED = 0,
    BDA_MOD_16QAM = 1,
    BDA_MOD_32QAM,
    BDA_MOD_64QAM,
    BDA_MOD_80QAM,
    BDA_MOD_96QAM,
    BDA_MOD_112QAM,
    BDA_MOD_128QAM,
    BDA_MOD_160QAM,
    BDA_MOD_192QAM,
    BDA_MOD_224QAM,
    BDA_MOD_256QAM,
    BDA_MOD_320QAM,
    BDA_MOD_384QAM,
    BDA_MOD_448QAM,
    BDA_MOD_512QAM,
    BDA_MOD_640QAM,
    BDA_MOD_768QAM,
    BDA_MOD_896QAM,
    BDA_MOD_1024QAM,
    BDA_MOD_QPSK,
    BDA_MOD_BPSK,
    BDA_MOD_OQPSK,
    BDA_MOD_8VSB,
    BDA_MOD_16VSB,
    BDA_MOD_ANALOG_AMPLITUDE,  // std am
    BDA_MOD_ANALOG_FREQUENCY,  // std fm
    BDA_MOD_MAX,
} ModulationType;

typedef enum SpectralInversion {
    BDA_SPECTRAL_INVERSION_NOT_SET = -1,
    BDA_SPECTRAL_INVERSION_NOT_DEFINED = 0,
    BDA_SPECTRAL_INVERSION_AUTOMATIC = 1,
    BDA_SPECTRAL_INVERSION_NORMAL,
    BDA_SPECTRAL_INVERSION_INVERTED,
    BDA_SPECTRAL_INVERSION_MAX
} SpectralInversion;

typedef enum Polarisation {
    BDA_POLARISATION_NOT_SET = -1,
    BDA_POLARISATION_NOT_DEFINED = 0,
    BDA_POLARISATION_LINEAR_H = 1, // Linear horizontal polarisation
    BDA_POLARISATION_LINEAR_V, // Linear vertical polarisation
    BDA_POLARISATION_CIRCULAR_L, // Circular left polarisation
    BDA_POLARISATION_CIRCULAR_R, // Circular right polarisation
    BDA_POLARISATION_MAX,
} Polarisation;

typedef enum GuardInterval {
    BDA_GUARD_NOT_SET = -1,
    BDA_GUARD_NOT_DEFINED = 0,
    BDA_GUARD_1_32 = 1, // Guard interval is 1/32
    BDA_GUARD_1_16, // Guard interval is 1/16
    BDA_GUARD_1_8, // Guard interval is 1/8
    BDA_GUARD_1_4, // Guard interval is 1/4
    BDA_GUARD_MAX,
} GuardInterval;

typedef enum HierarchyAlpha {
    BDA_HALPHA_NOT_SET = -1,
    BDA_HALPHA_NOT_DEFINED = 0,
    BDA_HALPHA_1 = 1, // Hierarchy alpha is 1.
    BDA_HALPHA_2, // Hierarchy alpha is 2.
    BDA_HALPHA_4, // Hierarchy alpha is 4.
    BDA_HALPHA_MAX,
} HierarchyAlpha;

typedef enum TransmissionMode {
    BDA_XMIT_MODE_NOT_SET = -1,
    BDA_XMIT_MODE_NOT_DEFINED = 0,
    BDA_XMIT_MODE_2K = 1, // Transmission uses 1705 carriers (use a 2K FFT)
    BDA_XMIT_MODE_8K, // Transmission uses 6817 carriers (use an 8K FFT)
    BDA_XMIT_MODE_MAX,
} TransmissionMode;

#endif // not defined _BDATYPES_

// end of file -- bdatypes.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\capolicy.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: capolicy.cpp
//
//  Abstract:
//
//    Implements ICAPolicy interface
//    Also handles registration of the plugin DLL and communication
//    with the filter driver.
//
//
////////////////////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "capolicy.h"
#include "podprotocol.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(__uuidof(PODProtocol), CPODProtocol)
END_OBJECT_MAP()

////////////////////////////////////////////////////////////////////////////////////////////
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] =
{
    {L"caplugin", &KSPROPSETID_BdaCA, CBdaECMMapInterfaceHandler::CreateInstance, NULL, NULL}
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI AMovieDllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

extern "C"
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_POD);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return AMovieDllEntryPoint(hInstance, dwReason, lpReserved);
}


///////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI
DllRegisterServer (
    void
    )
{
    HRESULT hr;
#ifdef _MERGE_PROXYSTUB
    hr = PrxDllRegisterServer();
    if (FAILED(hr))
        return hr;
#endif
    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer(TRUE);
    if (FAILED(hr))
        return hr;
    return AMovieDllRegisterServer2( TRUE );

}


///////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer (
    void
    )
///////////////////////////////////////////////////////////////////////////////
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    HRESULT hr = _Module.UnregisterServer(TRUE);
    if (FAILED(hr))
        return hr;
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    HRESULT AMovieDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
    hr = AMovieDllGetClassObject(rclsid, riid, ppv);
    if (SUCCEEDED(hr))
        return hr;

#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  CreateInstance
//
// create a new instance of our class
//
CUnknown*
CALLBACK
CBdaECMMapInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CUnknown *Unknown;

    Unknown = (CUnknown *)new CBdaECMMapInterfaceHandler(UnkOuter, NAME("IBDA_ECMMap"), hr);

    if (!Unknown)
        *hr = E_OUTOFMEMORY;
    
    return Unknown;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  NonDelegatingQueryInterface
//
// if they want an ICAPolicy or IBDA_ECMMap interface, just AddRef the parent
// with GetInterface and pass back a pointer to this.
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (riid ==  __uuidof(ICAPolicy))
    {
        return GetInterface(static_cast<ICAPolicy*>(this), ppv);
    }
#ifdef IMPLEMENT_IBDA_ECMMap
    if (riid ==  __uuidof(IBDA_ECMMap))
    {
        return GetInterface(static_cast<IBDA_ECMMap*>(this), ppv);
    }
#endif

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  CBdaECMMapInterfaceHandler
//
// class constructor, gets handle to underlying CA driver and starts thread
//
CBdaECMMapInterfaceHandler::CBdaECMMapInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) :
    CUnknown( Name, UnkOuter, hr)
{
    m_pCAMan = NULL;
    m_UnkOuter = UnkOuter;
    m_ppodprot = NULL;
        
    if (SUCCEEDED(*hr))
    {
        if (UnkOuter)
        {
#if IMPLEMENT_PODPROTOCOL
            //BUGBUG - Hack to make sure pod protocol knows how to talk to us.
            *hr = CoCreateInstance(__uuidof(PODProtocol), NULL, CLSCTX_ALL,
                    __uuidof(IPODProtocol), (void **)&m_ppodprot);
            if (FAILED(*hr))
                return;
            
            *hr = m_ppodprot->put_CAPod((ICAPod *) this);
            if (FAILED(*hr))
                return;
#endif

            IKsObject*   Object = NULL;

            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
            if (FAILED (*hr))
                return;

            m_ObjectHandle = Object->KsGetObjectHandle ();

            if (!m_ObjectHandle)
            {
                *hr = E_UNEXPECTED;
                return;
            }

            Object->Release();


            //init thread handle and event handles to NULL
            m_ThreadHandle = NULL;

            for (int ul = 0; ul < EVENT_COUNT; ul++)
                m_EventHandle [ul] = NULL;

            //now start thread
            *hr = CreateThread ();

            if(FAILED(*hr))
                return;
        }
        else
            *hr = VFW_E_NEED_OWNER;
    }

}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  ConnectToCAManager
//
//
HRESULT CBdaECMMapInterfaceHandler::ConnectToCAManager()
{
    HRESULT     hr = NOERROR;


    //  Find the CA Manager on the graph and add our policy.
    //
    if (!m_pGraph)
    {
        //  Find the Graph
    }

    if (m_pGraph)
    {
        CComPtr<IServiceProvider> pQS;

        hr = m_pGraph->QueryInterface( 
                            __uuidof( IServiceProvider), 
                            (void **) &pQS
                            );
        if (FAILED(hr))
        {
            goto errExit;
        }

        hr = pQS->QueryService(__uuidof(CAManager),
                       __uuidof( ICAManager), 
                       (void **) &m_pCAMan
                       );
        if (FAILED(hr))
        {
            goto errExit;
        }

        CComPtr<ICAPolicies> ppolicies;
        hr = m_pCAMan->get_Policies(&ppolicies);
        if (FAILED(hr))
            goto errExit;

        hr = ppolicies->Add(this);
        if (FAILED(hr))
            goto errExit;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

errExit:
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  ~CBdaECMMapInterfaceHandler
//
// destructor, terminates thread
//
CBdaECMMapInterfaceHandler::~CBdaECMMapInterfaceHandler()
{
    ULONG ul = 0;

    //
    // Make sure we kill any threads we have running and
    // close the thread handle
    //
    if (m_ThreadHandle)
    {
        TerminateThread (m_ThreadHandle, 0);
        CloseHandle(m_ThreadHandle);
        m_ThreadHandle = NULL;
    }


    //
    // Close the event handle
    //
    for (ul = 0; ul < EVENT_COUNT; ul++)
    {
        if (m_EventHandle [ul])
        {
            CloseHandle(m_EventHandle [ul]);
            m_EventHandle [ul] = NULL;
        }
    }

    if (m_ppodprot != NULL)
        m_ppodprot->Release();
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  get_Name
//
// ICAPolicy interface function, returns policy name
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::get_Name(BSTR * pbstr)
{   
    if (pbstr == NULL)
        return E_POINTER;
    
    *pbstr = SysAllocString(L"CA Policy Object");

    if ((*pbstr) == NULL)
        return E_OUTOFMEMORY;
    
    return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  get_OkToRemove
//
// ICAPolicy interface function, returns whether or not it is alright to remove this policy
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::get_OkToRemove(BOOL * pfOkToRemove)
{
    if (pfOkToRemove == NULL)
        return E_POINTER;

    *pfOkToRemove = false;
        
    return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  CheckRequest
//
// ICAPolicy interface function, checks a tuneing request
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::CheckRequest(ICARequest * preq)
{
    //TO DO: if you want to check individual requests, this is the place to do it
    
    return NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  NavigateURL
//
// ICAPolicy interface function
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::NavigateURL(BSTR bstrURL)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  get_OkToRemoveDenial
//
// ICAPolicy interface function, checks whether it is ok to remove a denial
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::get_OkToRemoveDenial(ICADenial * pdenial, BOOL * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
        
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  Set
//      pProp    = description of the property item to set
//      pvBuffer = pointer to data to set
//      ulcbSize = size of data to set
//
// set a KSPROPERTY item's data
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::Set(PKSPROPERTY pProp, PVOID  pvBuffer, ULONG *ulcbSize)
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pProp,
                sizeof(KSPROPERTY),
                pvBuffer,
                *ulcbSize,
                &BytesReturned);

    *ulcbSize = BytesReturned;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  Get
//      pProp = description of the property item to get
//      pvBuffer = place to put data once retrieved
//      pulcbSize = size of data retrieved
//
// get a KSPROPERTY item's data
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::Get(PKSPROPERTY pProp, PVOID  pvBuffer, PULONG pulcbSize)
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pProp,
                sizeof(KSPROPERTY),
                pvBuffer,
                *pulcbSize,
                &BytesReturned);

    *pulcbSize = BytesReturned;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  CreateThread
//
// create the thread to catch events from the driver
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::CreateThread()
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = NOERROR;

    if (m_ThreadHandle == NULL)
    {
        DWORD  ThreadId;

        m_ThreadHandle = ::CreateThread (
                               NULL,
                               0,
                               ThreadFunctionWrapper,
                               (LPVOID) this,
                               0,
                               (LPDWORD) &ThreadId
                               );
        if (m_ThreadHandle == NULL)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  GetCAModuleUI
//      ulFormat = format of the required data
//      ppUI = pointer to a pointer to the UI data
//      pulcbUI = pointer to ULONG to store UI data size in
//
// Get UI data from CA Module via driver
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::GetCAModuleUI(ULONG ulFormat, PBDA_CA_MODULE_UI *ppUI, unsigned long *pulcbUI)
///////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  Prop = {0};
    HRESULT hr       = NOERROR;
    unsigned long ulcbUIAllocated;

    if(ppUI == NULL)
        return E_POINTER;
    if(pulcbUI == NULL)
        return E_POINTER;

    //
    // Initialize KSPROPERTY structure
    //
    Prop.Set   = KSPROPSETID_BdaCA;
    Prop.Id    = KSPROPERTY_BDA_CA_MODULE_UI;
    Prop.Flags = KSPROPERTY_TYPE_GET;

    *ppUI = new BDA_CA_MODULE_UI;
    *pulcbUI = ulcbUIAllocated = sizeof(BDA_CA_MODULE_UI);

    do

    {
        (*ppUI)->ulFormat = ulFormat; //BUGBUG : tcpr review... is this really in/out?
        hr = this->Get (&Prop, *ppUI, pulcbUI);

        if (HRESULT_CODE (hr) == ERROR_MORE_DATA)
        {
            if ( (*pulcbUI) > ulcbUIAllocated)
            {
                if ( (*ppUI) )
                {
                    delete ( (*ppUI) );
                }

                ulcbUIAllocated  = (*pulcbUI);
                (*ppUI) = (PBDA_CA_MODULE_UI) new BYTE [ulcbUIAllocated];

                if ( (*ppUI) == NULL)
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ret;
                }
            }
        }

    } while (HRESULT_CODE (hr) == ERROR_MORE_DATA);

ret:

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  SetGetCAModuleUI
//      ulFormat = format of the required data
//      pbDataIn = data to send to the driver.
//      ppUI = pointer to a pointer to the UI data
//      pulcbUI = pointer to ULONG to store UI data size in
//
// Get UI data from CA Module via driver
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::SetGetCAModuleUI(ULONG ulFormat, BYTE *pbDataIn, long cbDataIn, PBDA_CA_MODULE_UI *ppUI, unsigned long *pulcbUI)
///////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  Prop = {0};
    HRESULT hr       = NOERROR;
    unsigned long ulcbUIAllocated;

    if(ppUI == NULL)
        return E_POINTER;
    if(pulcbUI == NULL)
        return E_POINTER;

    //
    // Initialize KSPROPERTY structure
    //
    Prop.Set   = KSPROPSETID_BdaCA;
    Prop.Id    = KSPROPERTY_BDA_CA_MODULE_UI;
    Prop.Flags = KSPROPERTY_TYPE_GET;

    *ppUI = new BDA_CA_MODULE_UI;
    *pulcbUI = ulcbUIAllocated = sizeof(BDA_CA_MODULE_UI) + cbDataIn;

    do

    {
        (*ppUI)->ulFormat = ulFormat;
        memcpy((*ppUI)->ulDesc, pbDataIn, cbDataIn);
        hr = this->Get (&Prop, *ppUI, pulcbUI);

        if (HRESULT_CODE (hr) == ERROR_MORE_DATA)
        {
            if ( (*pulcbUI) > ulcbUIAllocated)
            {
                if ( (*ppUI) )
                {
                    delete ( (*ppUI) );
                }

                ulcbUIAllocated  = (*pulcbUI);
                (*ppUI) = (PBDA_CA_MODULE_UI) new BYTE [ulcbUIAllocated];

                if ( (*ppUI) == NULL)
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ret;
                }
            }
        }

    } while (HRESULT_CODE (hr) == ERROR_MORE_DATA);

ret:

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  GetECMMapStatus
//      pStatus = ULONG to store status in once retrieved
//
// Gets the ECMMap status from the driver
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::GetECMMapStatus(unsigned long *pStatus)
////////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  Prop = {0};
    unsigned long ulcbJunk;

    if(pStatus == NULL)
        return E_POINTER;

    //
    // Initialize KSPROPERTY structure
    //
    Prop.Set   = KSPROPSETID_BdaCA;
    Prop.Id    = KSPROPERTY_BDA_ECM_MAP_STATUS;
    Prop.Flags = KSPROPERTY_TYPE_GET;

    return this->Get (&Prop, pStatus, &ulcbJunk);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  GetCAModuleStatus
//      pStatus = ULONG to store status in once retrieved
//
// Gets the CA Module status from the driver
//
STDMETHODIMP CBdaECMMapInterfaceHandler::GetCAModuleStatus (unsigned long *pStatus)
////////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  Prop = {0};
    unsigned long ulcbJunk;

    if(pStatus == NULL)
        return E_POINTER;

    //
    // Initialize KSPROPERTY structure
    //
    Prop.Set   = KSPROPSETID_BdaCA;
    Prop.Id    = KSPROPERTY_BDA_CA_MODULE_STATUS;
    Prop.Flags = KSPROPERTY_TYPE_GET;

    return this->Get (&Prop, pStatus, &ulcbJunk);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  GetCASmartCardStatus
//      pStatus = ULONG to store status in once retrieved
//
// Gets the CA SmartCard status from the driver
//
STDMETHODIMP CBdaECMMapInterfaceHandler::GetCASmartCardStatus (unsigned long *pStatus)
////////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  Prop = {0};
    unsigned long ulcbJunk;

    if(pStatus == NULL)
        return E_POINTER;

    //
    // Initialize KSPROPERTY structure
    //
    Prop.Set   = KSPROPSETID_BdaCA;
    Prop.Id    = KSPROPERTY_BDA_CA_SMART_CARD_STATUS;
    Prop.Flags = KSPROPERTY_TYPE_GET;

    return this->Get (&Prop, pStatus, &ulcbJunk);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  ThreadFunction
//
// thread function to initialize and handle the thread that catches
// events generated by the CA driver
//
STDMETHODIMP CBdaECMMapInterfaceHandler::ThreadFunction ()
////////////////////////////////////////////////////////////////////////////////////////////
{
    DWORD  dwWaitResult       = WAIT_OBJECT_0;
    HRESULT hr                = NOERROR;
    HANDLE hEvent             = NULL;


    //
    //  this code enables each of the four CA events we will be catching by calling
    //  EnableEvent specifying the individual event id's
    //
#if 0
    if ((hr = EnableEvent (&KSEVENTSETID_BdaCAEvent, KSEVENT_BDA_ECM_MAP_STATUS_CHANGED)) != NOERROR)
    {
        goto ret;
    }
#endif
    if ((hr = EnableEvent (&KSEVENTSETID_BdaCAEvent, KSEVENT_BDA_CA_MODULE_STATUS_CHANGED)) != NOERROR)
    {
        CloseHandle (m_EventHandle [KSEVENT_BDA_ECM_MAP_STATUS_CHANGED]);   // Close this event since we got an error.
        goto ret;
    }
    if ((hr = EnableEvent (&KSEVENTSETID_BdaCAEvent, KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED)) != NOERROR)
    {
        CloseHandle (m_EventHandle [KSEVENT_BDA_ECM_MAP_STATUS_CHANGED]);   // Close this event since we got an error.
        CloseHandle (m_EventHandle [KSEVENT_BDA_CA_MODULE_STATUS_CHANGED]);   // Close this event since we got an error.
        goto ret;
    }
    if ((hr = EnableEvent (&KSEVENTSETID_BdaCAEvent, KSEVENT_BDA_CA_MODULE_UI_REQUESTED)) != NOERROR)
    {
        CloseHandle (m_EventHandle [KSEVENT_BDA_ECM_MAP_STATUS_CHANGED]);   // Close this event since we got an error.
        CloseHandle (m_EventHandle [KSEVENT_BDA_CA_MODULE_STATUS_CHANGED]);   // Close this event since we got an error.
        CloseHandle (m_EventHandle [KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED]);   // Close this event since we got an error.
        goto ret;
    }


    // the following infinite loop waits for events and responds to recieved ones
    do
    {
        //wait for the next event...
        dwWaitResult = WaitForMultipleObjects (
                            EVENT_COUNT,                  // number of handles in the handle array
                            this->m_EventHandle,          // pointer to the object-handle array
                            FALSE,                        // wait flag
                            INFINITE
                            );

        //if something went ary, get the error and return
        if (dwWaitResult == WAIT_FAILED)
        {
            dwWaitResult = GetLastError ();
            hr = E_FAIL;
            goto ret;
        }

        //get a pointer to the event so we can reset it later
        hEvent = this->m_EventHandle [dwWaitResult - WAIT_OBJECT_0];

        //depending on the type of event, respond accordingly
        switch (dwWaitResult - WAIT_OBJECT_0)
        {
#if 0
            case KSEVENT_BDA_ECM_MAP_STATUS_CHANGED:

                //update the local status variable with the new status
                hr = GetECMMapStatus(&m_ECMMapStatus);

                break;
#endif

            case KSEVENT_BDA_CA_MODULE_STATUS_CHANGED:

                //update the local status variable with the new status
                hr = GetCAModuleStatus(&m_CAModuleStatus);

                break;

            case KSEVENT_BDA_CA_SMART_CARD_STATUS_CHANGED:

                //update the local status variable with the new status
                hr = GetCASmartCardStatus(&m_CASmartCardStatus);

                break;

            case KSEVENT_BDA_CA_MODULE_UI_REQUESTED:

                //the CA module wants to display a UI, so let it do so
                hr = ProcessCAModuleUI();

                break;

            default:    //in case of unknown event, return
                goto ret;
                break;
        }


        //
        // Reset and get ready for the next event
        //

        if (ResetEvent (hEvent) == FALSE)
        {
            //
            // ERROR detected resetting event
            //
            hr = GetLastError ();
            goto ret;
        }

    } while (TRUE);


ret:

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  ThreadFunctionWrapper
//
// global thread wrapping function
//
DWORD
WINAPI
CBdaECMMapInterfaceHandler::ThreadFunctionWrapper (
    LPVOID pvParam
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CBdaECMMapInterfaceHandler *pThread;

    pThread = (CBdaECMMapInterfaceHandler *) pvParam;

    return pThread->ThreadFunction ();
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  EnableEvent
//      pInterfaceGuid = the GUID of the event set which contains the event
//      ulId = the ID of the event in the event set
//
// enable a particular event
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::EnableEvent (const GUID *pInterfaceGuid, ULONG ulId)
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = NOERROR;
    KSEVENT Event;
    KSEVENTDATA EventData;
    DWORD BytesReturned;

    if (m_ObjectHandle && m_EventHandle [ulId] == NULL)
    {
        this->m_EventHandle [ulId] = CreateEvent (
                                NULL,           // no security attributes
                                TRUE,           // manual reset
                                FALSE,          // initial state not signaled
                                NULL            // no object name
                                );

        if (this->m_EventHandle [ulId])
        {
            //
            // Set the event information into some KS structures which will
            // get passed to KS and Streaming class
            //
            EventData.NotificationType        = KSEVENTF_EVENT_HANDLE;
            EventData.EventHandle.Event       = this->m_EventHandle [ulId];
            EventData.EventHandle.Reserved[0] = 0;
            EventData.EventHandle.Reserved[1] = 0;

            Event.Set   = *pInterfaceGuid; //IID_ICAPolicy;
            Event.Id    = ulId;
            Event.Flags = KSEVENT_TYPE_ENABLE;

            hr = ::KsSynchronousDeviceControl (
                m_ObjectHandle,
                IOCTL_KS_ENABLE_EVENT,
                &Event,
                sizeof(Event),
                &EventData,
                sizeof(EventData),
                &BytesReturned
                );

        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//  ExitThread
//
// kill the event catching thread
//
void
CBdaECMMapInterfaceHandler::ExitThread()
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG ul = 0;

    if (m_ThreadHandle)
    {

        for (ul = 0; ul < EVENT_COUNT; ul++)
        {
            //
            // Tell the thread to exit
            //
            if (SetEvent(m_EventHandle [ul]))
            {
                //
                // Synchronize with thread termination.
                //
                WaitForSingleObjectEx(m_ThreadHandle, INFINITE, FALSE);
            }

            if (m_EventHandle [ul] != NULL)
            {
                CloseHandle(m_EventHandle [ul]), m_EventHandle [ul] = NULL;
            }
        }

        CloseHandle(m_ThreadHandle),   m_ThreadHandle   = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//  ProcessCAModuleUI
//
// get the UI from the CA Module and display it
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::ProcessCAModuleUI()
{
    PBDA_CA_MODULE_UI pUI;
    unsigned long ulcbUI;
    HRESULT hr;

    //TO DO: this function is just a simple dump of the UI
    //more code is needed here for the particular UI desired
    //for example if HTML is to be displayed something needs
    //to be done here.
    
    //get UI from CA Module 
    hr = GetCAModuleUI(1, &pUI, &ulcbUI); //BUGBUG tcpr review... ulFormat== 1 means URL
    
    if(FAILED(hr))
        return hr;
    
    return RegisterDenial((char *)pUI->ulDesc);
}


/////////////////////////////////////////////////////////////////////////////
//
//  RegisterDenial
//
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::RegisterDenial(char *szURL)
{
    ICARequest *pActiveRequest        = NULL;
    ICADenials *pActiveRequestDenials = NULL;
    ICADenial  *pDenial               = NULL;
#ifdef IMPLEMENT_TOLL
    ICATolls   *pDenialTolls          = NULL;
    CMyToll    *pOurToll              = NULL;
#endif
    HRESULT     hr                    = NOERROR;

    if(m_pCAMan == NULL)
        return E_FAIL;

    //get the active request from the CA manager
    hr = m_pCAMan->get_ActiveRequest(&pActiveRequest);

    if(FAILED(hr))
        return hr;

    if(pActiveRequest == NULL)
        return E_FAIL;

    //get the list of denials from the CA manager
    hr = pActiveRequest->get_Denials(&pActiveRequestDenials);

    if(FAILED(hr))
        return hr;
 
    if(pActiveRequestDenials == NULL)
        return E_FAIL;

    //add a new denial
    BSTR bstrDesc;
    
    bstrDesc = SysAllocString(L"Access denied");

    hr = pActiveRequestDenials->get_AddNew((ICAPolicy *)this, bstrDesc, pActiveRequest, 0,  &pDenial);

    if(FAILED(hr))
        return hr;

    if(pDenial == NULL)
        return E_FAIL;

    CComBSTR bstrURL(szURL);
    
    pDenial->put_Description(URL, bstrURL);

#ifdef IMPLEMENT_TOLL
    //get the list of tolls associated with the denial 
    hr = pDenial->get_Tolls(&pDenialTolls);

    if(FAILED(hr))
        return hr;

    if(pDenialTolls == NULL)
        return E_FAIL;

    pOurToll = new CMyToll(m_UnkOuter,
                           NAME("ICAToll"),
                           &hr);
    
    if(FAILED(hr))
        return hr;

    if(pOurToll == NULL)
        return E_FAIL;

    //set the associated policy to ourselves
    hr = pOurToll->set_Policy((ICAPolicy *)this);
    
    if(FAILED(hr))
        return hr;

    //set the associated request to the active one
    hr = pOurToll->set_Request(pActiveRequest);
    
    if(FAILED(hr))
        return hr;

    //add our toll to the list on the denial
    return pDenialTolls->Add((ICAToll *)pOurToll);
#else
    return S_OK;
#endif
}

#ifdef IMPLEMENT_IBDA_ECMMap
////////////////////////////////////////////////////////////////////////////////////////////
//
//  SetEmmPid
//
// maps through to KSProperty item
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::SetEmmPid(ULONG Pid)
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspECMMap;
    ULONG           ulcbReturned = 0;

    kspECMMap.Set = KSPROPSETID_BdaEcmMap;
    kspECMMap.Id = KSPROPERTY_BDA_ECMMAP_EMM_PID;
    kspECMMap.Flags = KSPROPERTY_TYPE_SET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspECMMap,
                     sizeof( KSPROPERTY),
                     (PVOID) &Pid,
                     sizeof( ULONG),
                     &ulcbReturned
                     );

    return hrStatus;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  GetEcmMapList
//
// maps through to KSProperty item
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::GetEcmMapList(PBDA_ECM_MAP *ppList, ULONG *pulcbReturned)
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspECMMap;
    ULONG           ulcbAllocated = 0;

    if(ppList == NULL)
        return E_POINTER;
    if(pulcbReturned == NULL)
        return E_POINTER;
    
    //
    // Initialize KSPROPERTY structure
    //
    kspECMMap.Set = KSPROPSETID_BdaEcmMap;
    kspECMMap.Id = KSPROPERTY_BDA_ECMMAP_MAP_LIST;
    kspECMMap.Flags = KSPROPERTY_TYPE_GET;

    *ppList = new BDA_ECM_MAP;
    *pulcbReturned = ulcbAllocated = sizeof(BDA_ECM_MAP);

    do

    {
        hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspECMMap,
                     sizeof( KSPROPERTY),
                     (PVOID) *ppList,
                     *pulcbReturned,
                     pulcbReturned
                     );
        
        if (HRESULT_CODE (hrStatus) == ERROR_MORE_DATA)
        {
            if ( (*pulcbReturned) > ulcbAllocated)
            {
                if ( (*ppList) )
                {
                    delete ( (*ppList) );
                }

                ulcbAllocated  = (*pulcbReturned);
                (*ppList) = (PBDA_ECM_MAP) new BYTE [ulcbAllocated];

                if ( (*ppList) == NULL)
                {
                    hrStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto ret;
                }
            }
        }

    } while (HRESULT_CODE (hrStatus) == ERROR_MORE_DATA);

ret:

    return hrStatus;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  UpdateEcmMap
//
// maps through to KSProperty item
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::UpdateEcmMap(PBDA_ECM_MAP pMap)
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspECMMap;
    ULONG           ulcbReturned = 0;

    kspECMMap.Set = KSPROPSETID_BdaEcmMap;
    kspECMMap.Id = KSPROPERTY_BDA_ECMMAP_UPDATE_MAP;
    kspECMMap.Flags = KSPROPERTY_TYPE_SET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspECMMap,
                     sizeof( KSPROPERTY),
                     (PVOID) pMap,
                     sizeof( BDA_ECM_MAP),
                     &ulcbReturned
                     );

    return hrStatus;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  RemoveMap
//
// maps through to KSProperty item
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::RemoveMap(PBDA_ECM_MAP pMap)
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspECMMap;
    ULONG           ulcbReturned = 0;

    kspECMMap.Set = KSPROPSETID_BdaEcmMap;
    kspECMMap.Id = KSPROPERTY_BDA_ECMMAP_REMOVE_MAP;
    kspECMMap.Flags = KSPROPERTY_TYPE_SET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspECMMap,
                     sizeof( KSPROPERTY),
                     (PVOID) pMap,
                     sizeof( BDA_ECM_MAP),
                     &ulcbReturned
                     );

    return hrStatus;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  UpdateESDescriptor
//
// maps through to KSProperty item
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::UpdateESDescriptor(PBDA_ES_DESCRIPTOR pDesc)
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspECMMap;
    ULONG           ulcbReturned = 0;

    kspECMMap.Set = KSPROPSETID_BdaEcmMap;
    kspECMMap.Id = KSPROPERTY_BDA_ECMMAP_UPDATE_ES_DESCRIPTOR;
    kspECMMap.Flags = KSPROPERTY_TYPE_SET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspECMMap,
                     sizeof( KSPROPERTY),
                     (PVOID) pDesc,
                     sizeof( BDA_ES_DESCRIPTOR),
                     &ulcbReturned
                     );

    return hrStatus;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//  UpdateProgramDescriptor
//
// maps through to KSProperty item
//
STDMETHODIMP
CBdaECMMapInterfaceHandler::UpdateProgramDescriptor(PBDA_PROGRAM_DESCRIPTOR pDesc)
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspECMMap;
    ULONG           ulcbReturned = 0;

    kspECMMap.Set = KSPROPSETID_BdaEcmMap;
    kspECMMap.Id = KSPROPERTY_BDA_ECMMAP_UPDATE_PROGRAM_DESCRIPTOR;
    kspECMMap.Flags = KSPROPERTY_TYPE_SET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspECMMap,
                     sizeof( KSPROPERTY),
                     (PVOID) pDesc,
                     sizeof( BDA_PROGRAM_DESCRIPTOR),
                     &ulcbReturned
                     );

    return hrStatus;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\plugin\capolicy.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: capolicy.h
//
//  Abstract:
//
//    Implements ICAPolicy and IBDA_ECMMap interfaces
//    Also handles registration of the plugin DLL and communication
//    with the filter driver.
//
//
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
#ifdef IMPLEMENT_TOLL
#include "catoll.h"
#endif

#include "pod.h"

#define EVENT_COUNT 4

class CBdaECMMapInterfaceHandler :
    public CUnknown,
    public ICAPolicy,
    public ICAPod
{

public:

    DECLARE_IUNKNOWN;

    HRESULT ConnectToCAManager();

    //ICAPolicy functions:
    STDMETHODIMP get_Name(
        BSTR *pbstr
        );
        
    STDMETHOD(get_CAManager)(ICAManager **ppcaman)
        {
        *ppcaman = m_pCAMan;
        if (*ppcaman != NULL)
            (*ppcaman)->AddRef();
        return S_OK;
        }
    STDMETHOD(put_CAManager)(ICAManager *pcaman)
        {
        m_pCAMan = pcaman;
        return S_OK;
        }
        
    STDMETHODIMP get_OkToRemove( 
        BOOL *pfOkToRemove
        );
        
    STDMETHODIMP CheckRequest( 
        ICARequest *preq
        );
        
    STDMETHODIMP NavigateURL(
        BSTR bstrURL
        );

    STDMETHODIMP get_OkToRemoveDenial(
        ICADenial * pdenial,
        BOOL * pVal
        );

    STDMETHOD(get_OkToRemoveOffer)(ICAOffer * poffer, BOOL * pVal)
        {
        *pVal = TRUE;
        return S_OK;
        }
    STDMETHOD(get_OkToPersist)(BOOL * pVal)
        {
        *pVal = FALSE;
        return S_OK;
        }

    // ICAPod -  This is how the POD: protocol handler talks to us.

    STDMETHOD(get_HTML)(char * szURL, long *plCount, char  *szHTML)
        {
        HRESULT hr;
        PBDA_CA_MODULE_UI pUI;
        ULONG cb;

        hr = SetGetCAModuleUI(2, (BYTE *)szURL, strlen(szURL) + 1, &pUI, &cb);
        if (FAILED(hr))
            return hr;

        cb -= sizeof(BDA_CA_MODULE_UI) + sizeof(ULONG);
        if (*plCount >= (long) cb)
            memcpy(szHTML, pUI->ulDesc, cb);

        return S_OK;
        }

#ifdef IMPLEMENT_IBDA_ECMMap
    //IBDA_ECMMap functions:
    STDMETHODIMP SetEmmPid( 
            ULONG Pid
            );
        
    STDMETHODIMP GetEcmMapList( 
            PBDA_ECM_MAP __RPC_FAR *ppList,
            ULONG __RPC_FAR *pulcbReturned
            );
        
    STDMETHODIMP UpdateEcmMap( 
            PBDA_ECM_MAP pMap
            );
        
    STDMETHODIMP RemoveMap( 
            PBDA_ECM_MAP pMap
            );
        
    STDMETHODIMP UpdateESDescriptor( 
            PBDA_ES_DESCRIPTOR pDesc
            );
        
    STDMETHODIMP UpdateProgramDescriptor( 
            PBDA_PROGRAM_DESCRIPTOR pDesc
            );
#endif


    //class instance creation
    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr
        );

private:

    //the folling four functions provide easy access to the
    //properties of the KSPROPSETID_BdaCA property set
    STDMETHODIMP GetECMMapStatus (
            unsigned long *pStatus
            );
    STDMETHODIMP GetCAModuleStatus (
            unsigned long *pStatus
            );
    STDMETHODIMP GetCASmartCardStatus (
            unsigned long *pStatus
            );
    STDMETHODIMP GetCAModuleUI (
            ULONG ulFormat,
            PBDA_CA_MODULE_UI *ppUI,
            unsigned long *pulcbUI
            );
    STDMETHODIMP SetGetCAModuleUI (
            ULONG ulFormat,
            BYTE *pbDataIn,
            long cbDataIn,
            PBDA_CA_MODULE_UI *ppUI,
            unsigned long *pulcbUI
            );

    //get the UI from the CA Module and display it
    STDMETHOD(ProcessCAModuleUI)();

    STDMETHOD(RegisterDenial)(char *szURL);

    static DWORD WINAPI ThreadFunctionWrapper (LPVOID pvParam);

    CBdaECMMapInterfaceHandler(
            LPUNKNOWN UnkOuter,
            TCHAR* Name,
            HRESULT* hr
            );

    ~CBdaECMMapInterfaceHandler (
            void
            );

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID riid,
            PVOID* ppv
            );

    STDMETHODIMP EnableEvent (
            const GUID *pInterfaceGuid,
            ULONG ulId
            );

    STDMETHODIMP ThreadFunction (
            void
            );

    STDMETHODIMP Set (
            IN  PKSPROPERTY  pProperty,
            IN  PVOID pvBuffer,
            IN  PULONG ulcbSize
            );

    STDMETHODIMP Get (
            IN  PKSPROPERTY pProperty,
            OUT PVOID  pvBuffer,
            OUT PULONG pulcbSize
            );

    STDMETHODIMP CreateThread (
            void
            );

    void ExitThread (
            void
            );

    //handle to the underlying CA driver
    HANDLE m_ObjectHandle;

    //handle to each of the events we are catching
    HANDLE m_EventHandle [EVENT_COUNT];

    //handle of the thread to catch events
    HANDLE m_ThreadHandle;

    IUnknown *m_pGraph;

    //pointer to the CA manager that owns us
    ICAManager *m_pCAMan;

    IPODProtocol *m_ppodprot;

    //outer unknown interface pointer
    IUnknown *m_UnkOuter;

    //current driver status
    unsigned long m_ECMMapStatus;
    unsigned long m_CAModuleStatus;
    unsigned long m_CASmartCardStatus;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\bda\samples\casamp\driver\inc\bdadebug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyri