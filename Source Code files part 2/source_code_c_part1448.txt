BSTR strUsername )
{
	_ASSERT ( strUsername );
	_ASSERT ( IS_VALID_STRING ( strUsername ) );

	if ( strUsername == NULL ) {
		return E_POINTER;
	}

	if ( lstrcmp ( strUsername, _T("") ) == 0 ) {
		m_strUsername.Empty();

		return NOERROR;
	}
	else {
		return StdPropertyPut ( &m_strUsername, strUsername );
	}
}

STDMETHODIMP CNntpAdminSessions::get_IpAddress ( BSTR * pstrIpAddress )
{
	return StdPropertyGet ( m_strIpAddress, pstrIpAddress );
}

STDMETHODIMP CNntpAdminSessions::put_IpAddress ( BSTR strIpAddress )
{
	_ASSERT ( strIpAddress );
	_ASSERT ( IS_VALID_STRING ( strIpAddress ) );

	if ( strIpAddress == NULL ) {
		return E_POINTER;
	}

	if ( lstrcmp ( strIpAddress, _T("") ) == 0 ) {
		m_strIpAddress.Empty();
		m_dwIpAddress	= 0;

		return NOERROR;
	}
	else {
		// The IP Address value has two properties, so keep them in sync.
	
		StringToInetAddress ( strIpAddress, &m_dwIpAddress );

		return StdPropertyPut ( &m_strIpAddress, strIpAddress );
	}
}

STDMETHODIMP CNntpAdminSessions::get_IntegerIpAddress ( long * plIpAddress )
{
	return StdPropertyGet ( m_dwIpAddress, plIpAddress );
}

STDMETHODIMP CNntpAdminSessions::put_IntegerIpAddress ( long lIpAddress )
{
	HRESULT		hr					= NOERROR;
	WCHAR		wszAddress[100];
	DWORD		dwOldIpAddress		= m_dwIpAddress;

	hr = StdPropertyPut ( &m_dwIpAddress, lIpAddress );

	if ( FAILED (hr) ) {
		goto Exit;
	}

	// The IP Address value has two properties, so keep them in sync.

	if ( !InetAddressToString ( lIpAddress, wszAddress, 100 ) ) {
		hr = E_FAIL;
		goto Exit;
	}

	m_strIpAddress = wszAddress;

	if ( m_strIpAddress == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:

	if ( FAILED (hr) ) {
		// We failed, so put back the old IP address:

		m_dwIpAddress = dwOldIpAddress;
	}

	return hr;
}

STDMETHODIMP CNntpAdminSessions::get_Port ( long * plPort )
{
	CHECK_FOR_SET_CURSOR ( m_pSessionInfo != NULL, m_fSetCursor );

	return StdPropertyGet ( m_dwPort, plPort );
}

STDMETHODIMP CNntpAdminSessions::get_AuthenticationType ( long * plAuthenticationType )
{
	CHECK_FOR_SET_CURSOR ( m_pSessionInfo != NULL, m_fSetCursor );

	return StdPropertyGet ( m_dwAuthenticationType, plAuthenticationType );
}

STDMETHODIMP CNntpAdminSessions::get_IsAnonymous ( BOOL * pfAnonymous )
{
	CHECK_FOR_SET_CURSOR ( m_pSessionInfo != NULL, m_fSetCursor );

	return StdPropertyGet ( m_fIsAnonymous, pfAnonymous );
}

STDMETHODIMP CNntpAdminSessions::get_StartTime ( DATE * pdateStart )
{
	CHECK_FOR_SET_CURSOR ( m_pSessionInfo != NULL, m_fSetCursor );

	return StdPropertyGet ( m_dateStartTime, pdateStart );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpAdminSessions::Enumerate ( )
{
	TraceFunctEnter ( "CNntpAdminSessions::Enumerate" );

	// Variables:
	HRESULT					hr			= NOERROR;
	NET_API_STATUS			err;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Enumerating loses the cursor:
	m_fSetCursor = FALSE;

	if ( m_pSessionInfo ) {
		NetApiBufferFree ( m_pSessionInfo );
	}

	// Call the enumerate sessions RPC:

	err = NntpEnumerateSessions (
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
		&m_cCount,
		&m_pSessionInfo
		);

	if ( err != NOERROR ) {
		hr = RETURNCODETOHRESULT ( err );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminSessions::GetNth ( long lIndex )
{
	TraceFunctEnter ( "CNntpAdminSessions::GetNth" );

	HRESULT		hr	= NOERROR;
    FILETIME    ftLocal;
	SYSTEMTIME	st;
	WCHAR		wszUsername[MAX_USER_NAME_LENGTH + 1];
	WCHAR		wszIpAddress[256];
	DWORD		cchCopied;

	*wszUsername = NULL;

	// Did we enumerate first?
	if ( m_pSessionInfo == NULL ) {

		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
	}
	
	// Is the index valid?
	if ( lIndex < 0 || (DWORD) lIndex >= m_cCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	//
	// Copy the properties from m_pSessionInfo [ lIndex ] to member variables:
	//

	// ( CComBSTR handles free-ing of old properties )

    FileTimeToLocalFileTime ( &m_pSessionInfo[ lIndex ].SessionStartTime, &ftLocal );
	FileTimeToSystemTime 	( &ftLocal, &st );
	SystemTimeToVariantTime	( &st, &m_dateStartTime );

	m_dwIpAddress			= m_pSessionInfo[ lIndex ].IPAddress;
	m_dwAuthenticationType	= m_pSessionInfo[ lIndex ].AuthenticationType;
	m_dwPort				= m_pSessionInfo[ lIndex ].PortConnected;
	m_fIsAnonymous			= m_pSessionInfo[ lIndex ].fAnonymous;

	cchCopied = MultiByteToWideChar ( 
		CP_ACP, 
		MB_PRECOMPOSED | MB_USEGLYPHCHARS,
		m_pSessionInfo[ lIndex ].UserName,
		-1,
		wszUsername,
		MAX_USER_NAME_LENGTH
		);

	m_strUsername = wszUsername;

	if ( m_strUsername == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	InetAddressToString ( m_dwIpAddress, wszIpAddress, 256 );

	m_strIpAddress = wszIpAddress;

	if ( m_strIpAddress == NULL ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// GetNth sets the cursor:
	m_fSetCursor = TRUE;

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminSessions::Terminate ( )
{
	TraceFunctEnter ( "CNntpAdminSessions::Terminate" );

	HRESULT	hr = NOERROR;
	DWORD	err = NOERROR;
	char	szAnsiUsername[ MAX_USER_NAME_LENGTH + 1];
	char	szAnsiIpAddress[ 50 ];
	DWORD	cchCopied;

	szAnsiUsername[0]	= NULL;
	szAnsiIpAddress[0]	= NULL;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

	// Check Username & IpAddress parameters:
	if ( m_strUsername == NULL && m_strIpAddress == NULL ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_MUST_SUPPLY_USERNAME_OR_IPADDRESS );
	}

	// Translate the username & ipaddress to ANSI.
	if ( m_strUsername != NULL ) {
		cchCopied = WideCharToMultiByte ( 
			CP_ACP,
			0, 
			m_strUsername,
			-1,
			szAnsiUsername,
			MAX_USER_NAME_LENGTH,
			NULL,
			NULL
			);
	}

	if ( m_strIpAddress != NULL ) {
		cchCopied = WideCharToMultiByte ( 
			CP_ACP,
			0, 
			m_strIpAddress,
			-1,
			szAnsiIpAddress,
			50,
			NULL,
			NULL
			);
	}

	// Call the TerminateSession RPC:
	err = NntpTerminateSession ( 
        m_iadsImpl.QueryComputer(),
        m_iadsImpl.QueryInstance(),
		m_strUsername ? szAnsiUsername : NULL,
		m_strIpAddress ? szAnsiIpAddress : NULL
		);

	if ( err != NOERROR ) {
		hr = RETURNCODETOHRESULT ( err );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpAdminSessions::TerminateAll ( )
{
	TraceFunctEnter ( "CNntpAdminSessions::TerminateAll" );

	// Did we enumerate first?

	HRESULT				hr			= NOERROR;
	DWORD				ErrResult 	= NOERROR;
	DWORD				Err			= NOERROR;
	DWORD				i;

	// Validate Server & Service Instance:
	if ( m_iadsImpl.QueryInstance() == 0 ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_SERVICE_INSTANCE_CANT_BE_ZERO );
	}

#if 0
	// Make sure the user has enumerated:
	if ( m_pSessionInfo == NULL ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_DIDNT_ENUMERATE );
	}
#endif

	// For Each Session:
	for ( i = 0; i < m_cCount; i++ ) {

		// Call the terminate session RPC:
		Err = NntpTerminateSession ( 
            m_iadsImpl.QueryComputer(),
            m_iadsImpl.QueryInstance(),
			m_pSessionInfo[ i ].UserName,
			NULL
			);

		if ( Err != 0 && ErrResult == 0 ) {
			ErrResult = Err;
		}
	}

	if ( ErrResult != NOERROR ) {
		hr = RETURNCODETOHRESULT ( ErrResult );
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\vroots.cpp ===
// VirtualRoot.cpp : Implementation of CNntpVirtualRoot & CNntpVirtualRoots.

#include "stdafx.h"
#include "nntpcmn.h"
#include "cmultisz.h"
#include "vroots.h"
#include "oleutil.h"
#include "metautil.h"
#include "metakey.h"

#define THIS_FILE_HELP_CONTEXT      0
#define THIS_FILE_PROG_ID           _T("Nntpadm.VirtualServer.1")
#define THIS_FILE_IID               IID_INntpVirtualServer

#define DEFAULT_ACCESS_PERM		( 0 )

CVRoot::CVRoot () :
	m_dwWin32Error		( 0 ),
	m_bvAccess			( 0 ),
	m_bvSslAccess		( 0 ),
	m_fLogAccess		( TRUE ),
	m_fIndexContent		( TRUE ),
	m_dwUseAccount      ( 0 ),
	m_fDoExpire         ( FALSE ),
	m_fOwnModerator     ( FALSE )
{ 
}

HRESULT	CVRoot::SetProperties ( 
	BSTR	strNewsgroupSubtree, 
	BSTR	strDirectory,
	DWORD	dwWin32Error,
	DWORD	bvAccess,
	DWORD	bvSslAccess,
	BOOL	fLogAccess,
	BOOL	fIndexContent,
	BSTR	strUNCUsername,
	BSTR	strUNCPassword,
	BSTR    strDriverProgId,
	BSTR    strGroupPropFile,
	DWORD   dwUseAccount,
	BOOL    fDoExpire,
	BOOL    fOwnModerator,
	BSTR    strMdbGuid
	)
{
	_ASSERT ( IS_VALID_STRING ( strNewsgroupSubtree ) );
	_ASSERT ( IS_VALID_STRING ( strDirectory ) );
	_ASSERT ( IS_VALID_STRING ( strUNCUsername ) );
	_ASSERT ( IS_VALID_STRING ( strUNCPassword ) );
	_ASSERT ( IS_VALID_STRING ( strDriverProgId ) );
	_ASSERT ( IS_VALID_STRING ( strGroupPropFile ) );
	_ASSERT ( IS_VALID_STRING ( strMdbGuid ) );

	m_strNewsgroupSubtree	= strNewsgroupSubtree;
	m_strDirectory		= strDirectory;
	m_dwWin32Error		= dwWin32Error;
	m_bvAccess			= bvAccess;
	m_bvSslAccess		= bvSslAccess;
	m_fLogAccess		= fLogAccess;
	m_fIndexContent		= fIndexContent;
	m_strUNCUsername	= strUNCUsername;
	m_strUNCPassword	= strUNCPassword;
	m_strDriverProgId   = strDriverProgId;
	m_strGroupPropFile  = strGroupPropFile;
	m_dwUseAccount      = dwUseAccount;
	m_fDoExpire         = fDoExpire;
	m_fOwnModerator     = fOwnModerator,
	m_strMdbGuid        = strMdbGuid;

	if ( !m_strNewsgroupSubtree || !m_strDirectory || !m_strUNCUsername || !m_strUNCPassword ) {
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

HRESULT	CVRoot::SetProperties ( INntpVirtualRoot * pVirtualRoot )
{
	HRESULT		hr;

	BOOL		fAllowPosting;
	BOOL		fRestrictVisibility;
	BOOL		fRequireSsl;
	BOOL		fRequire128BitSsl;

	m_strDirectory.Empty ();
	m_strUNCUsername.Empty ();
	m_strUNCPassword.Empty ();
	m_strDriverProgId.Empty();
	m_strGroupPropFile.Empty();
	m_strMdbGuid.Empty();

	hr = pVirtualRoot->get_NewsgroupSubtree ( &m_strNewsgroupSubtree );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_Directory ( &m_strDirectory );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_Win32Error ( (long *) &m_dwWin32Error );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_UNCUsername ( &m_strUNCUsername );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_UNCPassword ( &m_strUNCPassword );
	BAIL_ON_FAILURE(hr);

	hr = pVirtualRoot->get_DriverProgId ( &m_strDriverProgId );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_GroupPropFile ( &m_strGroupPropFile );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_MdbGuid ( &m_strMdbGuid );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_UseAccount( &m_dwUseAccount );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_OwnExpire( &m_fDoExpire );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_OwnModerator( &m_fOwnModerator );
	BAIL_ON_FAILURE( hr );

	hr = pVirtualRoot->get_LogAccess ( &m_fLogAccess );
	_ASSERT ( SUCCEEDED(hr) );

	hr = pVirtualRoot->get_IndexContent ( &m_fIndexContent );
	_ASSERT ( SUCCEEDED(hr) );


	hr = pVirtualRoot->get_AllowPosting ( &fAllowPosting );
	_ASSERT ( SUCCEEDED(hr) );

	hr = pVirtualRoot->get_RestrictGroupVisibility ( &fRestrictVisibility );
	_ASSERT ( SUCCEEDED(hr) );

	hr = pVirtualRoot->get_RequireSsl ( &fRequireSsl );
	_ASSERT ( SUCCEEDED(hr) );

	hr = pVirtualRoot->get_Require128BitSsl ( &fRequire128BitSsl );
	_ASSERT ( SUCCEEDED(hr) );

	SetBitFlag ( &m_bvAccess, MD_ACCESS_ALLOW_POSTING, fAllowPosting );
	SetBitFlag ( &m_bvAccess, MD_ACCESS_RESTRICT_VISIBILITY, fRestrictVisibility );

	SetBitFlag ( &m_bvSslAccess, MD_ACCESS_SSL, fRequireSsl );
	SetBitFlag ( &m_bvSslAccess, MD_ACCESS_SSL128, fRequire128BitSsl );

Exit:
	return hr;
}

HRESULT CVRoot::GetFromMetabase (   CMetabaseKey * pMB, 
                                    LPCWSTR     wszName,
                                    DWORD       dwInstanceId,
                                    LPWSTR      wszServerName )
{
	HRESULT		hr	= NOERROR;
	DWORD		dwDontLog		= TRUE;

	m_strDirectory.Empty();
	m_strUNCUsername.Empty();
	m_strUNCPassword.Empty();

	StdGetMetabaseProp ( pMB, MD_ACCESS_PERM, 0, &m_bvAccess, wszName );
	StdGetMetabaseProp ( pMB, MD_SSL_ACCESS_PERM, 0, &m_bvSslAccess, wszName );
	StdGetMetabaseProp ( pMB, MD_DONT_LOG, FALSE, &dwDontLog, wszName );
	StdGetMetabaseProp ( pMB, MD_IS_CONTENT_INDEXED, FALSE, &m_fIndexContent, wszName, IIS_MD_UT_FILE);
	StdGetMetabaseProp ( pMB, MD_VR_PATH, _T(""), &m_strDirectory, wszName );
	//StdGetMetabaseProp ( pMB, MD_WIN32_ERROR, 0, &m_dwWin32Error, wszName, IIS_MD_UT_FILE, METADATA_NO_ATTRIBUTES );
	StdGetMetabaseProp ( pMB, MD_VR_USERNAME, _T(""), &m_strUNCUsername, wszName );
	StdGetMetabaseProp ( pMB, MD_VR_PASSWORD, _T(""), &m_strUNCPassword, wszName, IIS_MD_UT_SERVER, METADATA_SECURE );
	StdGetMetabaseProp ( pMB, MD_VR_USE_ACCOUNT, 0,	&m_dwUseAccount, wszName );
	StdGetMetabaseProp ( pMB, MD_VR_DO_EXPIRE, FALSE, &m_fDoExpire, wszName );
	StdGetMetabaseProp ( pMB, MD_VR_OWN_MODERATOR, FALSE, &m_fOwnModerator, wszName );
	StdGetMetabaseProp ( pMB, MD_VR_DRIVER_PROGID, _T("NNTP.FSPrepare"), &m_strDriverProgId, wszName );
	StdGetMetabaseProp ( pMB, MD_FS_PROPERTY_PATH, m_strDirectory, &m_strGroupPropFile, wszName );
	StdGetMetabaseProp ( pMB, MD_EX_MDB_GUID, _T(""), &m_strMdbGuid, wszName );

	//
	// Get the win32 error code from RPC
	//
	DWORD dw = NntpGetVRootWin32Error( (LPWSTR)wszServerName, dwInstanceId, (LPWSTR)wszName, (LPDWORD)&m_dwWin32Error );
	switch (dw) {
	case ERROR_SERVICE_NOT_ACTIVE:
		m_dwWin32Error = dw;
		break;

	case NOERROR:
		break;

	default:
    	hr = HRESULT_FROM_WIN32( dw );
    	goto Exit;
	}

	m_strNewsgroupSubtree	= wszName;
	m_fLogAccess			= !dwDontLog;

	if ( !m_strNewsgroupSubtree || !m_strDirectory || !m_strUNCUsername || !m_strUNCPassword ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	return hr;
}

HRESULT CVRoot::SendToMetabase ( CMetabaseKey * pMB, LPCWSTR wszName ) 
{
	HRESULT		hr	= NOERROR;

    hr = pMB->SetString ( wszName, MD_KEY_TYPE, _T("IIsNntpVirtualDir"), METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER );
	BAIL_ON_FAILURE(hr);

	hr = pMB->SetString ( wszName, MD_VR_PATH, m_strDirectory, METADATA_INHERIT, IIS_MD_UT_FILE );
	BAIL_ON_FAILURE(hr);

	StdPutMetabaseProp ( pMB, MD_ACCESS_PERM, m_bvAccess, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_SSL_ACCESS_PERM, m_bvSslAccess, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_DONT_LOG, !m_fLogAccess, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_IS_CONTENT_INDEXED, m_fIndexContent, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_WIN32_ERROR, m_dwWin32Error, wszName, IIS_MD_UT_SERVER, METADATA_VOLATILE );
	StdPutMetabaseProp ( pMB, MD_VR_USERNAME, m_strUNCUsername, wszName, IIS_MD_UT_FILE );
	StdPutMetabaseProp ( pMB, MD_VR_PASSWORD, m_strUNCPassword, wszName, IIS_MD_UT_FILE, METADATA_SECURE | METADATA_INHERIT );
	StdPutMetabaseProp ( pMB, MD_VR_USE_ACCOUNT, m_dwUseAccount, wszName, IIS_MD_UT_SERVER );
	StdPutMetabaseProp ( pMB, MD_VR_DO_EXPIRE, m_fDoExpire, wszName, IIS_MD_UT_SERVER );
	StdPutMetabaseProp ( pMB, MD_VR_OWN_MODERATOR, m_fOwnModerator, wszName, IIS_MD_UT_SERVER );
	StdPutMetabaseProp ( pMB, MD_VR_DRIVER_PROGID, m_strDriverProgId, wszName, IIS_MD_UT_SERVER );
    StdPutMetabaseProp ( pMB, MD_FS_PROPERTY_PATH, m_strGroupPropFile, wszName, IIS_MD_UT_SERVER );	
    StdPutMetabaseProp ( pMB, MD_EX_MDB_GUID, m_strMdbGuid, wszName, IIS_MD_UT_SERVER );

Exit:
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpVirtualRoot::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpVirtualRoot,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpVirtualRoot::CNntpVirtualRoot ()
	// CComBSTR's are initialized to NULL by default.
{
}

CNntpVirtualRoot::~CNntpVirtualRoot ()
{
	// All CComBSTR's are freed automatically.
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpVirtualRoot::get_NewsgroupSubtree ( BSTR * pstrNewsgroupSubtree )
{
	return StdPropertyGet ( m_vroot.m_strNewsgroupSubtree, pstrNewsgroupSubtree );
}

STDMETHODIMP CNntpVirtualRoot::put_NewsgroupSubtree ( BSTR strNewsgroupSubtree )
{
    if ( wcslen( strNewsgroupSubtree ) > METADATA_MAX_NAME_LEN - 20 ) return CO_E_PATHTOOLONG;
	return StdPropertyPut ( &m_vroot.m_strNewsgroupSubtree, strNewsgroupSubtree );
}

STDMETHODIMP CNntpVirtualRoot::get_Directory ( BSTR * pstrDirectory )
{
	return StdPropertyGet ( m_vroot.m_strDirectory, pstrDirectory );
}

STDMETHODIMP CNntpVirtualRoot::put_Directory ( BSTR strDirectory )
{
	return StdPropertyPut ( &m_vroot.m_strDirectory, strDirectory );
}

STDMETHODIMP CNntpVirtualRoot::get_Win32Error ( long * plWin32Error )
{
	return StdPropertyGet ( m_vroot.m_dwWin32Error, plWin32Error );
}

STDMETHODIMP CNntpVirtualRoot::get_LogAccess ( BOOL * pfLogAccess )
{
	return StdPropertyGet ( m_vroot.m_fLogAccess, pfLogAccess );
}

STDMETHODIMP CNntpVirtualRoot::put_LogAccess ( BOOL fLogAccess )
{
	return StdPropertyPut ( &m_vroot.m_fLogAccess, fLogAccess );
}

STDMETHODIMP CNntpVirtualRoot::get_IndexContent ( BOOL * pfIndexContent )
{
	return StdPropertyGet ( m_vroot.m_fIndexContent, pfIndexContent );
}

STDMETHODIMP CNntpVirtualRoot::put_IndexContent ( BOOL fIndexContent )
{
	return StdPropertyPut ( &m_vroot.m_fIndexContent, fIndexContent );
}

STDMETHODIMP CNntpVirtualRoot::get_AllowPosting ( BOOL * pfAllowPosting )
{
	return StdPropertyGetBit ( m_vroot.m_bvAccess, MD_ACCESS_ALLOW_POSTING, pfAllowPosting );
}

STDMETHODIMP CNntpVirtualRoot::put_AllowPosting ( BOOL fAllowPosting )
{
	return StdPropertyPutBit ( &m_vroot.m_bvAccess, MD_ACCESS_ALLOW_POSTING, fAllowPosting );
}

STDMETHODIMP CNntpVirtualRoot::get_RestrictGroupVisibility ( BOOL * pfRestrictGroupVisibility )
{
	return StdPropertyGetBit ( m_vroot.m_bvAccess, MD_ACCESS_RESTRICT_VISIBILITY, pfRestrictGroupVisibility );
}

STDMETHODIMP CNntpVirtualRoot::put_RestrictGroupVisibility ( BOOL fRestrictGroupVisibility )
{
	return StdPropertyPutBit ( &m_vroot.m_bvAccess, MD_ACCESS_RESTRICT_VISIBILITY, fRestrictGroupVisibility );
}

	STDMETHODIMP	SSLNegotiateCert	( BOOL * pfSSLNegotiateCert );
	STDMETHODIMP	SSLNegotiateCert	( BOOL fSSLNegotiateCert );

	STDMETHODIMP	SSLRequireCert	( BOOL * pfSSLRequireCert );
	STDMETHODIMP	SSLRequireCert	( BOOL fSSLRequireCert );

	STDMETHODIMP	SSLMapCert	( BOOL * pfSSLMapCert );
	STDMETHODIMP	SSLMapCert	( BOOL fSSLMapCert );

STDMETHODIMP CNntpVirtualRoot::get_RequireSsl ( BOOL * pfRequireSsl )
{
	return StdPropertyGetBit ( m_vroot.m_bvSslAccess, MD_ACCESS_SSL, pfRequireSsl );
}

STDMETHODIMP CNntpVirtualRoot::put_RequireSsl ( BOOL fRequireSsl )
{
	return StdPropertyPutBit ( &m_vroot.m_bvSslAccess, MD_ACCESS_SSL, fRequireSsl );
}

STDMETHODIMP CNntpVirtualRoot::get_Require128BitSsl ( BOOL * pfRequire128BitSsl )
{
	return StdPropertyGetBit ( m_vroot.m_bvSslAccess, MD_ACCESS_SSL128, pfRequire128BitSsl );
}

STDMETHODIMP CNntpVirtualRoot::put_Require128BitSsl ( BOOL fRequire128BitSsl )
{
	return StdPropertyPutBit ( &m_vroot.m_bvSslAccess, MD_ACCESS_SSL128, fRequire128BitSsl );
}

STDMETHODIMP CNntpVirtualRoot::get_UNCUsername ( BSTR * pstrUNCUsername )
{
	return StdPropertyGet ( m_vroot.m_strUNCUsername, pstrUNCUsername );
}

STDMETHODIMP CNntpVirtualRoot::put_UNCUsername ( BSTR strUNCUsername )
{
	return StdPropertyPut ( &m_vroot.m_strUNCUsername, strUNCUsername );
}

STDMETHODIMP CNntpVirtualRoot::get_UNCPassword ( BSTR * pstrUNCPassword )
{
	return StdPropertyGet ( m_vroot.m_strUNCPassword, pstrUNCPassword );
}

STDMETHODIMP CNntpVirtualRoot::put_UNCPassword ( BSTR strUNCPassword )
{
	return StdPropertyPut ( &m_vroot.m_strUNCPassword, strUNCPassword );
}

STDMETHODIMP CNntpVirtualRoot::get_DriverProgId( BSTR *pstrDriverProgId )
{
    return StdPropertyGet( m_vroot.m_strDriverProgId, pstrDriverProgId );
}

STDMETHODIMP CNntpVirtualRoot::put_DriverProgId( BSTR strDriverProgId )
{
    return StdPropertyPut( &m_vroot.m_strDriverProgId, strDriverProgId );
}

STDMETHODIMP CNntpVirtualRoot::get_GroupPropFile( BSTR *pstrGroupPropFile )
{
    return StdPropertyGet( m_vroot.m_strGroupPropFile, pstrGroupPropFile );
}

STDMETHODIMP CNntpVirtualRoot::put_GroupPropFile( BSTR strGroupPropFile )
{
    return StdPropertyPut( &m_vroot.m_strGroupPropFile, strGroupPropFile );
}

STDMETHODIMP CNntpVirtualRoot::get_MdbGuid( BSTR *pstrMdbGuid )
{
    return StdPropertyGet( m_vroot.m_strMdbGuid, pstrMdbGuid );
}

STDMETHODIMP CNntpVirtualRoot::put_MdbGuid( BSTR strMdbGuid )
{
    return StdPropertyPut( &m_vroot.m_strMdbGuid, strMdbGuid );
}

STDMETHODIMP CNntpVirtualRoot::get_UseAccount( DWORD *pdwUseAccount )
{
    return StdPropertyGet( m_vroot.m_dwUseAccount, pdwUseAccount );
}

STDMETHODIMP CNntpVirtualRoot::put_UseAccount( DWORD dwUseAccount )
{
    return StdPropertyPut( &m_vroot.m_dwUseAccount, dwUseAccount );
}

STDMETHODIMP CNntpVirtualRoot::get_OwnExpire( BOOL *pfOwnExpire )
{
    return StdPropertyGet( m_vroot.m_fDoExpire, pfOwnExpire );
}

STDMETHODIMP CNntpVirtualRoot::put_OwnExpire( BOOL fOwnExpire )
{
    return StdPropertyPut( &m_vroot.m_fDoExpire, fOwnExpire );
}

STDMETHODIMP CNntpVirtualRoot::get_OwnModerator( BOOL *pfOwnModerator )
{
    return StdPropertyGet( m_vroot.m_fOwnModerator, pfOwnModerator );
}

STDMETHODIMP CNntpVirtualRoot::put_OwnModerator( BOOL fOwnModerator )
{
    return StdPropertyPut( &m_vroot.m_fOwnModerator, fOwnModerator );
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CNntpVirtualRoots::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_INntpVirtualRoots,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CNntpVirtualRoots::CNntpVirtualRoots () :
	m_dwCount			( 0 ),
	m_rgVRoots			( NULL ),
	m_dwServiceInstance	( 0 )
	// CComBSTR's are initialized to NULL by default.
{
}

CNntpVirtualRoots::~CNntpVirtualRoots ()
{
	// All CComBSTR's are freed automatically.

	delete [] m_rgVRoots;
}

HRESULT CNntpVirtualRoots::Init ( BSTR strServer, DWORD dwServiceInstance )
{
	m_strServer				= strServer;
	m_dwServiceInstance		= dwServiceInstance;

	if ( !m_strServer ) {
		return E_OUTOFMEMORY;
	}

	return NOERROR;
}

//////////////////////////////////////////////////////////////////////
// Properties:
//////////////////////////////////////////////////////////////////////

// Which service to configure:
	
STDMETHODIMP CNntpVirtualRoots::get_Server ( BSTR * pstrServer )
{
	return StdPropertyGet ( m_strServer, pstrServer );
}

STDMETHODIMP CNntpVirtualRoots::put_Server ( BSTR strServer )
{
	_ASSERT ( strServer );
	_ASSERT ( IS_VALID_STRING ( strServer ) );

	if ( strServer == NULL ) {
		return E_POINTER;
	}

	if ( lstrcmp ( strServer, _T("") ) == 0 ) {
		m_strServer.Empty();

		return NOERROR;
	}
	else {
		return StdPropertyPutServerName ( &m_strServer, strServer );
	}
}

STDMETHODIMP CNntpVirtualRoots::get_ServiceInstance ( long * plServiceInstance )
{
	return StdPropertyGet ( m_dwServiceInstance, plServiceInstance );
}

STDMETHODIMP CNntpVirtualRoots::put_ServiceInstance ( long lServiceInstance )
{
	return StdPropertyPut ( &m_dwServiceInstance, lServiceInstance );
}

STDMETHODIMP CNntpVirtualRoots::get_Count ( long * pdwCount )
{
	return StdPropertyGet ( m_dwCount, pdwCount );
}

//////////////////////////////////////////////////////////////////////
// Methods:
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CNntpVirtualRoots::Enumerate ( )
{
	TraceFunctEnter ( "CNntpVirtualRoots::Enumerate" );

	HRESULT					hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;

	// Clear the old enumeration:
	delete [] m_rgVRoots;
	m_rgVRoots	= NULL;
	m_dwCount	= 0;

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = GetVRootsFromMetabase ( pMetabase );
	if ( FAILED(hr) ) {
		goto Exit;
	}

Exit:
	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Item ( 
	long index, 
	INntpVirtualRoot ** ppVirtualRoot 
	)
{
	TraceFunctEnter ( "CNntpVirtualRoots::Item" );

	_ASSERT ( IS_VALID_OUT_PARAM ( ppVirtualRoot ) );

	*ppVirtualRoot = NULL;

	HRESULT							hr			= NOERROR;
	CComObject<CNntpVirtualRoot> *	pVirtualRoot	= NULL;

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = CComObject<CNntpVirtualRoot>::CreateInstance ( &pVirtualRoot );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( pVirtualRoot );
	hr = pVirtualRoot->SetProperties ( m_rgVRoots[index] );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = pVirtualRoot->QueryInterface ( IID_INntpVirtualRoot, (void **) ppVirtualRoot );
	_ASSERT ( SUCCEEDED(hr) );

Exit:
	if ( FAILED(hr) ) {
		delete pVirtualRoot;
	}

	TRACE_HRESULT(hr);
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Add ( 
	INntpVirtualRoot	* pVirtualRoot
	)
{
	TraceFunctEnter ( "CNntpVirtualRoots::Add" );

	_ASSERT ( IS_VALID_IN_PARAM ( pVirtualRoot ) );

	HRESULT					hr	= NOERROR;
	CVRoot *				rgNewVirtualRoots	= NULL;
	long					i;
	CComPtr<IMSAdminBase>	pMetabase;
	CVRoot					newVroot;
    WCHAR					wszName [ 2*METADATA_MAX_NAME_LEN ];
    WCHAR					wszVRootPath [ 2*METADATA_MAX_NAME_LEN ];

	//	Validate the new Virtual Root:
	hr = newVroot.SetProperties ( pVirtualRoot );
	if ( FAILED(hr) ) {
		return hr;
	}

	if ( !newVroot.m_strNewsgroupSubtree ||
		!newVroot.m_strNewsgroupSubtree[0] ) {

		return RETURNCODETOHRESULT ( ERROR_INVALID_PARAMETER );
	}

	//	Add the new virtual root to the metabase:
	GetVRootName ( newVroot.m_strNewsgroupSubtree, wszName );

	//
	// The sub tree itself should not exceed length METADATA_MAX_NAME_LEN
	//
	_ASSERT( wcslen( wszName ) <= METADATA_MAX_NAME_LEN );
	if ( wcslen( wszName ) > METADATA_MAX_NAME_LEN ) {
	    return CO_E_PATHTOOLONG;
	}

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey mb ( pMetabase );
	
	GetMDVRootPath ( wszVRootPath );

    //
	// I trust wszVRootPath, it's shorter than METADATA_MAX_NAME_LEN
	//

    //
    //  Test to see if this item exists already:
    //

    WCHAR	wszTempPath [ 2 * METADATA_MAX_NAME_LEN + 1];

    wsprintf ( wszTempPath, _T("%s%s"), wszVRootPath, wszName );
    if ( wcslen( wszTempPath ) > METADATA_MAX_NAME_LEN ) {

        //
        // I can't handle it either
        //
        return CO_E_PATHTOOLONG;
    }

	hr = mb.Open ( wszTempPath );
	if ( SUCCEEDED(hr) ) {
        DWORD   cbVrootDir;

        if ( SUCCEEDED ( mb.GetDataSize (
                _T(""),
                MD_VR_PATH,
                STRING_METADATA,
                &cbVrootDir,
                METADATA_NO_ATTRIBUTES )
                ) ) {

            mb.Close();

		    hr = NntpCreateException ( IDS_NNTPEXCEPTION_VROOT_ALREADY_EXISTS );
            goto Exit;
        }
    }

	hr = mb.Open ( wszVRootPath, METADATA_PERMISSION_WRITE );
	BAIL_ON_FAILURE(hr);

/*
	hr = mb.CreateChild ( wszName );
	BAIL_ON_FAILURE(hr);
*/

	hr = newVroot.SendToMetabase ( &mb, wszName );
	BAIL_ON_FAILURE(hr);

	hr = mb.Save ();
	BAIL_ON_FAILURE(hr);

	//	Allocate the new VirtualRoot array:
	rgNewVirtualRoots	= new CVRoot [ m_dwCount + 1 ];
	if ( !rgNewVirtualRoots ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	//	Copy the old VirtualRoots to the new array:
	for ( i = 0; i < m_dwCount; i++ ) {
		hr = rgNewVirtualRoots[i].SetProperties ( m_rgVRoots[i] );
		if ( FAILED (hr) ) {
			goto Exit;
		}
	}

	//	Add the new VirtualRoot to the end of the array:
	hr = rgNewVirtualRoots[m_dwCount].SetProperties ( pVirtualRoot );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	_ASSERT ( SUCCEEDED(hr) );
	delete [] m_rgVRoots;
	m_rgVRoots = rgNewVirtualRoots;
	m_dwCount++;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Set ( 
	long index, 
	INntpVirtualRoot * pVirtualRoot 
	)
{
	TraceFunctEnter ( "CNntpVirtualRoots::ChangeVirtualRoot" );

	HRESULT		hr	= NOERROR;

	CComBSTR	strNewsgroupSubtree;
	CComBSTR	strDirectory;
	CVRoot		temp;
	CComPtr<IMSAdminBase>	pMetabase;
	WCHAR		wszVRootPath [ METADATA_MAX_NAME_LEN ];
	WCHAR		wszName [ METADATA_MAX_NAME_LEN ];

	// Send the new virtual root to the metabase:
	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey	mb ( pMetabase );

	if ( index < 0 || index >= m_dwCount ) {
		hr = NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
		goto Exit;
	}

	hr = temp.SetProperties ( pVirtualRoot );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	GetMDVRootPath ( wszVRootPath );

	hr = mb.Open ( wszVRootPath, METADATA_PERMISSION_WRITE );
	BAIL_ON_FAILURE(hr);

	GetVRootName ( temp.m_strNewsgroupSubtree, wszName );

	hr = temp.SendToMetabase ( &mb, wszName );
	BAIL_ON_FAILURE(hr);

	hr = m_rgVRoots[index].SetProperties ( pVirtualRoot );
	BAIL_ON_FAILURE(hr);

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Remove ( long index )
{
	TraceFunctEnter ( "CNntpVirtualRoots::Remove" );

	HRESULT		hr	= NOERROR;
	CVRoot	temp;
	long		cPositionsToSlide;
	CComPtr<IMSAdminBase>	pMetabase;
    WCHAR		wszName [ METADATA_MAX_NAME_LEN ];
    WCHAR		wszVRootPath [ METADATA_MAX_NAME_LEN ];

	if ( index < 0 || index >= m_dwCount ) {
		return NntpCreateException ( IDS_NNTPEXCEPTION_INVALID_INDEX );
	}

	// Delete the virtual root from the metabase:

	hr = m_mbFactory.GetMetabaseObject ( m_strServer, &pMetabase );
	if ( FAILED(hr) ) {
		return hr;
	}

	CMetabaseKey	mb ( pMetabase );
	
	GetMDVRootPath ( wszVRootPath );

	hr = mb.Open ( wszVRootPath, METADATA_PERMISSION_WRITE );
	BAIL_ON_FAILURE(hr);

	GetVRootName ( m_rgVRoots[index].m_strNewsgroupSubtree, wszName );

    hr = mb.DeleteAllData ( wszName );
	BAIL_ON_FAILURE(hr);

/*
	hr = mb.DestroyChild ( wszName );
	BAIL_ON_FAILURE(hr);
*/

	hr = mb.Save ();
	BAIL_ON_FAILURE(hr);

	mb.Close ();

	//	Slide the array down by one position:

	_ASSERT ( m_rgVRoots );

	cPositionsToSlide	= (m_dwCount - 1) - index;

	_ASSERT ( cPositionsToSlide < m_dwCount );

	if ( cPositionsToSlide > 0 ) {
		// Save the deleted VirtualRoot in temp:
		CopyMemory ( &temp, &m_rgVRoots[index], sizeof ( CVRoot ) );

		// Move the array down one:
		MoveMemory ( &m_rgVRoots[index], &m_rgVRoots[index + 1], sizeof ( CVRoot ) * cPositionsToSlide );

		// Put the deleted VirtualRoot on the end (so it gets destructed):
		CopyMemory ( &m_rgVRoots[m_dwCount - 1], &temp, sizeof ( CVRoot ) );

		// Zero out the temp VirtualRoot:
		ZeroMemory ( &temp, sizeof ( CVRoot ) );
	}

	m_dwCount--;

Exit:
	TraceFunctLeave ();
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::Find ( BSTR strNewsgroupSubtree, long * pIndex )
{
	HRESULT		hr	= NOERROR;
	long		i;

	_ASSERT ( pIndex );
	*pIndex = -1;

	for ( i = 0; i < m_dwCount; i++ ) {

		if ( lstrcmp ( m_rgVRoots[i].m_strNewsgroupSubtree, strNewsgroupSubtree ) == 0 ) {
			*pIndex = i;
		}
	}

	return NOERROR;
}

static HRESULT CountVrootsIterator (
	CMetabaseKey * pMB,
	LPCWSTR wszVrootPath,
	LPARAM lParam
	)
{
	DWORD * pcVroots	= (DWORD *) lParam;

	(*pcVroots)++;

	return NOERROR;
}

typedef struct tagAddVrootsParms
{
	DWORD		cCount;
	CVRoot *	rgVroots;
	DWORD		dwCurrentIndex;
	LPWSTR      wszServerName;
	DWORD       dwInstanceId;
} ADD_VROOTS_PARMS;

static HRESULT AddVrootsIterator (
	CMetabaseKey * pMB,
	LPCWSTR wszVrootPath,
	LPARAM lParam
	)
{
	_ASSERT ( pMB );
	_ASSERT ( wszVrootPath );
	_ASSERT ( lParam );

	HRESULT				hr;
	ADD_VROOTS_PARMS *	pParms = (ADD_VROOTS_PARMS *) lParam;
	LPWSTR              wszServerName = pParms->wszServerName;
	DWORD               dwInstanceId = pParms->dwInstanceId;

	_ASSERT ( pParms->dwCurrentIndex < pParms->cCount );

	hr = pParms->rgVroots[pParms->dwCurrentIndex].GetFromMetabase (
		pMB,
		wszVrootPath,
		dwInstanceId,
		wszServerName
		);
	BAIL_ON_FAILURE(hr);

	pParms->dwCurrentIndex++;

Exit:
	return hr;
}

HRESULT CNntpVirtualRoots::GetVRootsFromMetabase ( IMSAdminBase * pMetabase )
{
	HRESULT				hr	= NOERROR;
	CMetabaseKey		mb ( pMetabase );
    WCHAR				wszVRootPath [ METADATA_MAX_NAME_LEN ];
    DWORD				cCount		= 0;
    CVRoot *			rgVroots	= NULL;
    ADD_VROOTS_PARMS	parms;

	//
	//	Initialize the metabase:
	//

	GetMDVRootPath ( wszVRootPath );

	hr = mb.Open ( wszVRootPath );
	BAIL_ON_FAILURE(hr);

	//
	//	Count the virtual roots:
	//

	hr = IterateOverVroots ( &mb, CountVrootsIterator, (LPARAM) &cCount );
	BAIL_ON_FAILURE(hr);

	//
	//	Create the virtual roots array:
	//

	rgVroots	= new CVRoot [ cCount ];
	if ( !rgVroots ) {
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	//
	//	Add the virtual roots to the array:
	//

	parms.cCount			= cCount;
	parms.rgVroots			= rgVroots;
	parms.dwCurrentIndex	= 0;
	parms.wszServerName     = m_strServer;
	parms.dwInstanceId      = m_dwServiceInstance;

	hr = IterateOverVroots ( &mb, AddVrootsIterator, (LPARAM) &parms );
	BAIL_ON_FAILURE(hr);

	_ASSERT ( SUCCEEDED(hr) );
	_ASSERT ( m_rgVRoots == NULL );
	m_rgVRoots 	= rgVroots;
	m_dwCount	= cCount;

Exit:
	if ( FAILED(hr) ) {
		delete [] rgVroots;
	}

	return hr;
}

HRESULT CNntpVirtualRoots::IterateOverVroots (
	CMetabaseKey *	pMB, 
	VROOT_ITERATOR	fpIterator,
	LPARAM			lParam,
	LPCWSTR			wszPath		// = _T("")
	)
{
	HRESULT		hr;
	WCHAR		wszSubKey[ METADATA_MAX_NAME_LEN ];
	WCHAR		wszSubPath[ METADATA_MAX_NAME_LEN ];
    BOOL        fRealVroot;
	DWORD		cbVrootDir;
	DWORD		i;

    //
	//	Is this a real vroot?
    //

    fRealVroot  =
        !*wszPath ||	// Always count the home directory
		SUCCEEDED ( pMB->GetDataSize ( 
				wszPath, 
				MD_VR_PATH, 
				STRING_METADATA, 
				&cbVrootDir, 
				METADATA_NO_ATTRIBUTES ) 
				);

    if ( fRealVroot ) {
		//	Call the iterator on this key:

		hr = (*fpIterator) ( pMB, wszPath, lParam );
		BAIL_ON_FAILURE(hr);
	}

	//
	//	Recurse down the tree:
	//

	for ( i = 0; ; ) {
		hr = pMB->EnumObjects ( wszPath, wszSubKey, i );

		if ( HRESULTTOWIN32(hr) == ERROR_NO_MORE_ITEMS ) {
			// This is expected, end the loop:

            if ( !fRealVroot && i == 0 ) {
                //
                //  This key isn't a vroot and has no children, so delete it.
                //

                hr = pMB->ChangePermissions ( METADATA_PERMISSION_WRITE );
                if ( SUCCEEDED(hr) ) {
                    hr = pMB->DeleteKey ( wszPath );
                }

                pMB->ChangePermissions ( METADATA_PERMISSION_READ );
                if ( SUCCEEDED(hr) ) {
                    hr = pMB->Save ();
                }

				if ( SUCCEEDED(hr) ) {
					//
					//	Tell our parent that this key was deleted.
					//

					hr = S_FALSE;
				}
				else {
					//
					//	Ignore any deleting problems:
					//

					hr = NOERROR;
				}
            }
			else {
				hr = NOERROR;
			}
			break;
		}
		BAIL_ON_FAILURE(hr);

		if ( *wszPath ) {
			wsprintf ( wszSubPath, _T("%s/%s"), wszPath, wszSubKey );
		}
		else {
			wcscpy ( wszSubPath, wszSubKey );
		}

		hr = IterateOverVroots ( pMB, fpIterator, lParam, wszSubPath );
		BAIL_ON_FAILURE(hr);

		if ( hr != S_FALSE ) {
			//
			//	This means the child key still exists, so increment
			//	the counter and go on to the next one.
			//

			i++;
		}
		//
		//	Else the return code is S_FALSE, which means the current key
		//	has been deleted, shifting all indicies down by one.  Therefore,
		//	there is no need to increment i.
		//
	}

Exit:
	return hr;
}

void CNntpVirtualRoots::GetVRootName ( LPWSTR wszDisplayName, LPWSTR wszPathName )
{
	wcscpy ( wszPathName, wszDisplayName );
}

void CNntpVirtualRoots::GetMDVRootPath ( LPWSTR wszPath )
{
	GetMDInstancePath ( wszPath, m_dwServiceInstance );

	wcscat ( wszPath, _T("Root/") );
}

STDMETHODIMP CNntpVirtualRoots::ItemDispatch ( long index, IDispatch ** ppDispatch )
{
	HRESULT				hr;
	CComPtr<INntpVirtualRoot>	pVirtualRoot;

	hr = Item ( index, &pVirtualRoot );
	BAIL_ON_FAILURE ( hr );

	hr = pVirtualRoot->QueryInterface ( IID_IDispatch, (void **) ppDispatch );
	BAIL_ON_FAILURE ( hr );

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::AddDispatch ( IDispatch * pVirtualRoot )
{
	HRESULT				hr;
	CComPtr<INntpVirtualRoot>	pINntpVirtualRoot;

	hr = pVirtualRoot->QueryInterface ( IID_INntpVirtualRoot, (void **) &pINntpVirtualRoot );
	BAIL_ON_FAILURE(hr);

	hr = Add ( pINntpVirtualRoot );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}

STDMETHODIMP CNntpVirtualRoots::SetDispatch ( long lIndex, IDispatch * pVirtualRoot )
{
	HRESULT				hr;
	CComPtr<INntpVirtualRoot>	pINntpVirtualRoot;

	hr = pVirtualRoot->QueryInterface ( IID_INntpVirtualRoot, (void **) &pINntpVirtualRoot );
	BAIL_ON_FAILURE(hr);

	hr = Set ( lIndex, pINntpVirtualRoot );
	BAIL_ON_FAILURE(hr);

Exit:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\adminsso\vroots.h ===
// vroots.h : Declaration of the CNntpVirtualRoot & CNntpVirtualRoots classes.

#ifndef _VROOTS_INCLUDED_
#define _VROOTS_INCLUDED_

//
//	Dependencies:
//

#include "nntptype.h"
#include "nntpapi.h"
#include "metafact.h"
class CMetabaseKey;

//
//	A simple VRoot class:
//

class CVRoot
{
public:
	CVRoot ();

	CComBSTR	m_strNewsgroupSubtree;
	CComBSTR	m_strDirectory;
	DWORD		m_dwWin32Error;
	DWORD		m_bvAccess;
	DWORD		m_bvSslAccess;
	BOOL		m_fLogAccess;
	BOOL		m_fIndexContent;
	CComBSTR	m_strUNCUsername;
	CComBSTR	m_strUNCPassword;
	CComBSTR    m_strDriverProgId;
	CComBSTR    m_strGroupPropFile;
	CComBSTR    m_strMdbGuid;
	DWORD       m_dwUseAccount;
	BOOL        m_fDoExpire;
	BOOL        m_fOwnModerator;

	HRESULT	SetProperties ( INntpVirtualRoot * pVirtualRoot );
	inline HRESULT	SetProperties ( const CVRoot & VRoot )
	{
		return SetProperties ( 
			VRoot.m_strNewsgroupSubtree, 
			VRoot.m_strDirectory,
			VRoot.m_dwWin32Error,
			VRoot.m_bvAccess,
			VRoot.m_bvSslAccess,
			VRoot.m_fLogAccess,
			VRoot.m_fIndexContent,
			VRoot.m_strUNCUsername,
			VRoot.m_strUNCPassword,
			VRoot.m_strDriverProgId,
			VRoot.m_strGroupPropFile,
			VRoot.m_dwUseAccount,
			VRoot.m_fDoExpire,
			VRoot.m_fOwnModerator,
			VRoot.m_strMdbGuid
			);
	}

	HRESULT	GetFromMetabase ( CMetabaseKey * pMB, LPCWSTR wszKey, DWORD dwInstanceId, LPWSTR wszVRootPath );
	HRESULT SendToMetabase ( CMetabaseKey * pMB, LPCWSTR wszKey );

private:
	HRESULT	SetProperties ( 
		BSTR	strNewsgroupSubtree, 
		BSTR	strDirectory,
		DWORD	dwWin32Error,
		DWORD	bvAccess,
		DWORD	bvSslAccess,
		BOOL	fLogAcccess,
		BOOL	fIndexContent,
		BSTR	strUNCUsername,
		BSTR	strUNCPassword,
		BSTR    strDriverProgId,
		BSTR    strGroupPropFile,
		DWORD   dwUseAccount,
		BOOL    fDoExpire,
		BOOL    fOwnModerator,
		BSTR    strMdbGuid
		);

	// Don't call this:
	const CVRoot & operator= ( const CVRoot & );
};

/////////////////////////////////////////////////////////////////////////////
// The VRoot Object

class CNntpVirtualRoot : 
	public CComDualImpl<INntpVirtualRoot, &IID_INntpVirtualRoot, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CNntpVirtualRoot,&CLSID_CNntpVirtualRoot>
{
	friend class CNntpVirtualRoots;
	friend class CNntpVirtualServer;

public:
	CNntpVirtualRoot();
	virtual ~CNntpVirtualRoot ();
BEGIN_COM_MAP(CNntpVirtualRoot)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpVirtualRoot)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpVirtualRoot) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

DECLARE_REGISTRY(CNntpVirtualRoot, _T("Nntpadm.VirtualRoot.1"), _T("Nntpadm.VirtualRoot"), IDS_NNTPVIRTUALROOT_DESC, THREADFLAGS_BOTH)
// INntpVirtualRoot
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_NewsgroupSubtree	( BSTR * pstrNewsgroupSubtree );
	STDMETHODIMP	put_NewsgroupSubtree	( BSTR strNewsgroupSubtree );

	STDMETHODIMP	get_Directory	( BSTR * pstrDirectory );
	STDMETHODIMP	put_Directory	( BSTR strDirectory );

	STDMETHODIMP	get_Win32Error	( long * plWin32Error );

	STDMETHODIMP	get_AllowPosting	( BOOL * pfAllowPosting );
	STDMETHODIMP	put_AllowPosting	( BOOL fAllowPosting );

	STDMETHODIMP	get_RestrictGroupVisibility	( BOOL * pfRestrictGroupVisibility );
	STDMETHODIMP	put_RestrictGroupVisibility	( BOOL fRestrictGroupVisibility );

	STDMETHODIMP	get_LogAccess	( BOOL * pfLogAccess );
	STDMETHODIMP	put_LogAccess	( BOOL fLogAccess );

	STDMETHODIMP	get_IndexContent	( BOOL * pfIndexContent );
	STDMETHODIMP	put_IndexContent	( BOOL fIndexContent );

	STDMETHODIMP	get_RequireSsl	( BOOL * pfRequireSsl );
	STDMETHODIMP	put_RequireSsl	( BOOL fRequireSsl );

	STDMETHODIMP	get_Require128BitSsl	( BOOL * pfRequire128BitSsl );
	STDMETHODIMP	put_Require128BitSsl	( BOOL fRequire128BitSsl );

	STDMETHODIMP	get_UNCUsername	( BSTR * pstrUNCUsername );
	STDMETHODIMP	put_UNCUsername	( BSTR strUNCUsername );

	STDMETHODIMP	get_UNCPassword	( BSTR * pstrUNCPassword );
	STDMETHODIMP	put_UNCPassword	( BSTR strUNCPassword );

	STDMETHODIMP    get_DriverProgId( BSTR *pstrDriverProgId );
	STDMETHODIMP    put_DriverProgId( BSTR strDriverProgId );

	STDMETHODIMP    get_GroupPropFile( BSTR *pstrGRoupPropFile );
	STDMETHODIMP    put_GroupPropFile( BSTR strGroupPropFile );

	STDMETHODIMP    get_MdbGuid( BSTR *pstrMdbGuid );
	STDMETHODIMP    put_MdbGuid( BSTR strMdbGuid );

	STDMETHODIMP    get_UseAccount( DWORD *pdwUseAccount );
	STDMETHODIMP    put_UseAccount( DWORD dwUseAccount );

	STDMETHODIMP    get_OwnExpire( BOOL *fOwnExpire );
	STDMETHODIMP    put_OwnExpire( BOOL fOwnExpire );

	STDMETHODIMP    get_OwnModerator( BOOL *fOwnModerator );
	STDMETHODIMP    put_OwnModerator( BOOL fOwnModerator );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

/*
	inline HRESULT	SetProperties	( BSTR strNewsgroupSubtree, BSTR strDirectory )
	{
		return m_vroot.SetProperties ( strNewsgroupSubtree, strDirectory );
	}
*/

	inline HRESULT	SetProperties	( const CVRoot & VRoot )
	{
		return m_vroot.SetProperties ( VRoot );
	}

	// Property variables:
	CVRoot	m_vroot;
};

/////////////////////////////////////////////////////////////////////////////
// The VRoots Object

typedef HRESULT (* VROOT_ITERATOR) (
	CMetabaseKey *	pMB,
	LPCWSTR			wszPath,
	LPARAM			lParam
	);

class CNntpVirtualRoots : 
	public CComDualImpl<INntpVirtualRoots, &IID_INntpVirtualRoots, &LIBID_NNTPADMLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
	friend class CNntpVirtualRoot;
	friend class CNntpVirtualServer;

public:
	CNntpVirtualRoots();
	virtual ~CNntpVirtualRoots ();
BEGIN_COM_MAP(CNntpVirtualRoots)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(INntpVirtualRoots)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNntpVirtualRoots) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INntpVirtualRoots
public:

	//////////////////////////////////////////////////////////////////////
	// Properties:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	get_Server			( BSTR * pstrServer );
	STDMETHODIMP	put_Server			( BSTR strServer );

	STDMETHODIMP	get_ServiceInstance	( long * plServiceInstance );
	STDMETHODIMP	put_ServiceInstance	( long lServiceInstance );

	STDMETHODIMP	get_Count	( long * pdwCount );

	//////////////////////////////////////////////////////////////////////
	// Methods:
	//////////////////////////////////////////////////////////////////////

	STDMETHODIMP	Enumerate	( );
	STDMETHODIMP	Item	( long index, INntpVirtualRoot ** ppVRoot );
	STDMETHODIMP	ItemDispatch	( long index, IDispatch ** ppVRoot );
	STDMETHODIMP	Add		( INntpVirtualRoot * pVRoot );
	STDMETHODIMP	AddDispatch	( IDispatch * pVRoot );
	STDMETHODIMP	Set		( long index, INntpVirtualRoot * pVRoot );
	STDMETHODIMP	SetDispatch	( long index, IDispatch * pVRoot );
	STDMETHODIMP	Remove	( long index );
	STDMETHODIMP	Find	( BSTR strNewsgroupSubtree, long * pIndex );

private:
	HRESULT		Init ( BSTR strServer, DWORD dwServiceInstance );

	//////////////////////////////////////////////////////////////////////
	// Data:
	//////////////////////////////////////////////////////////////////////
private:

	// Property variables:
	long			m_dwCount;
	CVRoot *		m_rgVRoots;

	// Which service are we talking to:
	CComBSTR		m_strServer;
	DWORD			m_dwServiceInstance;

	// Metabase values:
	CMetabaseFactory	m_mbFactory;

	HRESULT GetVRootsFromMetabase ( IMSAdminBase * pMetabase );

	static HRESULT	IterateOverVroots (
		CMetabaseKey *	pMB,
		VROOT_ITERATOR	fpIterator,
		LPARAM			lParam,
		LPCWSTR			wszPath = _T("")
		);

	void GetMDVRootPath ( LPWSTR wszPath );
	void GetVRootName	( LPWSTR wszDisplayName, LPWSTR wszPathName );
};

#endif // _VROOTS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\fixprop\src\stdinc.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\fixprop\src\makefile.inc ===
$(O)\mailmsg.h : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\fixprop\src\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
};
#endif

#include <malloc.h>
#include <nntptype.h>
#include <nntps.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <nntpmeta.h>

#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"
#include "crchash.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include "instwpex.h"
#include "nntpvr.h"
#include "group.h"
#include <instwpex.h>
#include "nwstree.h"
#include "nntpbag.h"
#include <rwnew.h>

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\fixprop\utest\stdinc.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\fixprop\src\fixprop.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    fixprop.cpp

Abstract:

    This module contains class declarations/definitions for

        CFixPropPersist

    **** Overview ****

    The class is the implementation of a fixed sized property
    storage.  It is mainly used for news group's fixed sized
    property.

	It's MT safe, except that group property consistency can
	not be guaranteed if two threads work on the same group.
	This is because this object assumes that group write/read
	access lock has already been implemented in group object
	and newstree.

Author:

    Kangrong Yan    ( KangYan )     7-5-1998

Revision History:

--*/
#include "stdinc.h"
#include "fixprop.h"
#include <time.h>


#define FLAG_WITH_ID_HIGH   0x00000001  // whether the file has id high
#define FLAG_IN_ORDER       0x00000002  // whether the file is in order
#define ID_HIGH_INIT        256

CPool   CFreeInfo::g_FreeInfoPool(FREEINFO_SIGNATURE);
LONG    CFixPropPersist::m_lRef = 0;
CShareLockNH  CFixPropPersist::m_sLock;

//
// Used to determine when we should update start hints.
//
void StartHintFunction(void);
static DWORD g_dwHintCounter=0;
static time_t g_tNextHint=0;

/*
LPWSTR CopyAsciiStringIntoUnicode( LPWSTR, LPSTR );
LPWSTR CopyAsciiStringIntoUnicode( LPWSTR, LPSTR );
*/

////////////////////////////////////////////////////////////////////
// Async I/O completion function
/* Replaced by wait for event
static void    WINAPI
FileIOCompletionRoutine(	DWORD   dwError,
				        	DWORD   cbBytes,
						    LPOVERLAPPED    povl)
{
    OVERLAPPED_EXT * povlExt = (OVERLAPPED_EXT*)povl;

    if( dwError == ERROR_SUCCESS &&
        cbBytes == povlExt->dwIoSize ) {
        (povlExt->ovl).hEvent = (HANDLE)TRUE ;
    }   else    {
        (povlExt->ovl).hEvent = (HANDLE)FALSE ;
	}
}
*/

//
// Compare function for qsort
//

int __cdecl
CompareDataBlock(const void *pElem1, const void *pElem2) {

	// Update our hints roughly every five seconds.  We only check the
	// time every 100 compares or so..
	if( g_dwHintCounter++ % 100 == 0 ) {
		time_t now = time(NULL);
		if (now > g_tNextHint) {
			StartHintFunction();
			g_tNextHint = now + 5;
		}
	}

    return lstrcmp(
        (*(DATA_BLOCK**)pElem1)->szGroupName,
        (*(DATA_BLOCK**)pElem2)->szGroupName);

}

////////////////////////////////////////////////////////////////////
// CFreeInfo CPool Related methods
BOOL
CFreeInfo::InitClass()
{ return g_FreeInfoPool.ReserveMemory( MAX_FREEINFO_OBJECTS, MAX_FREEINFO_SIZE ); }

BOOL
CFreeInfo::TermClass()
{
	_ASSERT( g_FreeInfoPool.GetAllocCount() == 0 );
	return g_FreeInfoPool.ReleaseMemory();
}

//
// Constrcutor, destructor
//
CFixPropPersist::CFixPropPersist( 	IN LPSTR szStorageFile ) :
	m_FreeList( &CFreeInfo::m_pPrev, &CFreeInfo::m_pNext ),
	m_cCurrentMaxBlocks( 0 ),
	m_hStorageFile( INVALID_HANDLE_VALUE ),
	m_hBackupFile( INVALID_HANDLE_VALUE ),
	m_pvContext( NULL ),
	m_dwIdHigh( ID_HIGH_INVALID )
{
	TraceFunctEnter( "CFixPropPersist::CFixPropPersist" );
	_ASSERT( lstrlen( szStorageFile ) <= GROUPNAME_LEN_MAX  );
	lstrcpy( m_szStorageFile, szStorageFile );
	TraceFunctLeave();
}

CFixPropPersist::~CFixPropPersist()
{}

////////////////////////////////////////////////////////////////////
// Debug related methods
#ifdef DEBUG
VOID CFixPropPersist::DumpFreeList()
{
	CFreeInfo *pifFreeInfo = NULL;
	TFListEx<CFreeInfo>::Iterator it(&m_FreeList);

	while ( !it.AtEnd() ) {
		pifFreeInfo = it.Current();
		_ASSERT( pifFreeInfo );
		printf( "Offset: %d\n", pifFreeInfo->m_dwOffset );
		it.Next();
	}
}

VOID CFixPropPersist::Validate()
{
	CFreeInfo *pfiFreeInfo;
	TFListEx<CFreeInfo>::Iterator it(&m_FreeList, TRUE );

	// Validate Free List elements
	while ( !it.AtEnd() ) {
		pfiFreeInfo = it.Current();
		_ASSERT( pfiFreeInfo );
		_ASSERT( pfiFreeInfo->m_dwOffset < m_cCurrentMaxBlocks );
		it.Next();
	}
}

#endif

/////////////////////////////////////////////////////////////////
// Initialization, Termination
BOOL CFixPropPersist::Init( IN BOOL bCreateIfNonExist,
							IN PVOID pvContext,
							OUT PDWORD pdwIdHigh,
							IN PFNENUMCALLBACK pfnEnumCallback )
/*++
Routine description:

	Initialization:
		If the storage file exists, try to load its free block info;
		else if asked to create a new storage file, create a file
		with ALLOC_GRANURALITY blocks and pre-set them to be free,
		link them into free list.  If not asked to create a new file
		but the file doesn't already exist, I'll fail. :(

	It can only be called once,by one thread, before using all other
	interfaces.

Arguments:

	IN BOOL bCreateIfNonExist - Shall I create a new file if it doesn't exist ?
	IN PVOID pvContext - Context passed in by user
	OUT PDWORD pdwIdHigh - The group id high; if 0xffffffff, the file is with old
	                        format
	IN PFNENUMCALLBACK pfnEnumCallback - What to do with enumerated group info?

Return value:

	TRUE on success, FALES otherwise, check LastError for detailed
	error info.
--*/
{
	TraceFunctEnter( "CFixPropPersist::Init" );

	DATA_BLOCK	dbBuffer;
	DWORD		dwBytesRead = 0;
	DWORD		dwBytesWritten = 0;
	DWORD		i;
	BOOL		bIsFreeBlock = FALSE;
	BOOL		bSuccess = FALSE;
	CFreeInfo	*pfiFreeInfo = NULL;
	HANDLE		hStorageFile = INVALID_HANDLE_VALUE;
	LARGE_INTEGER liLeadingDwords;
	BOOL        bSucceeded = FALSE;
	BOOL        bInOrder = FALSE;

	DWORD       dwHeaderLength = 0;
	HANDLE      hMap = NULL;
	LPVOID      pMap = NULL;
	DWORD       *pdwHeader;
	DATA_BLOCK  **pInUseBlocks = NULL;

	SetLastError( NO_ERROR );

	if (pdwIdHigh) *pdwIdHigh = ID_HIGH_INIT + 1;

	m_sLock.ExclusiveLock();

	// Init CPool stuff first
	if ( InterlockedIncrement( &m_lRef ) == 1 ) {
    	if ( !CFreeInfo::InitClass() ) {
	    	ErrorTrace(0, "Init cpool fail" );
		    if ( GetLastError() == NO_ERROR )
			    SetLastError( ERROR_OUTOFMEMORY );
    		goto Exit;
	    }
	}

	// Set Context pointer
	m_pvContext = pvContext;

	// Detect if we are going to use the ordered group.lst or
	// the non-ordered
	if ( !ProbeForOrder( bInOrder ) ) {
	    ErrorTrace( 0, "Probe for order failed %d", GetLastError() );
	    goto Exit;
	}

	// Open storage file to scan and build free list
	_ASSERT( hStorageFile == INVALID_HANDLE_VALUE );
	_ASSERT( lstrlen( m_szStorageFile ) <= GROUPNAME_LEN_MAX );
	hStorageFile = CreateFile(
	    m_szStorageFile,
	    GENERIC_READ,
	    FILE_SHARE_READ,	// no one else can write
	    NULL,
	    OPEN_EXISTING,
	    bInOrder ? FILE_FLAG_SEQUENTIAL_SCAN : FILE_FLAG_RANDOM_ACCESS,
	    NULL );

	if ( hStorageFile == INVALID_HANDLE_VALUE ) { // then I create it
		if ( bCreateIfNonExist ) {
			hStorageFile = CreateFile(	m_szStorageFile,
											GENERIC_WRITE,
											FILE_SHARE_READ, // no one else can write
											NULL,
											CREATE_ALWAYS,
											FILE_FLAG_SEQUENTIAL_SCAN,
											NULL );
			if ( hStorageFile != INVALID_HANDLE_VALUE ) {

				// Put two DWORD's into the file first:
				// One is the signature, the other
				// reserved - no use for now
				dwBytesWritten = 0;
				liLeadingDwords.LowPart = FIXPROP_SIGNATURE;
				liLeadingDwords.HighPart = FLAG_WITH_ID_HIGH;	// reserved
				if( !::WriteFile( 	hStorageFile,
									&liLeadingDwords,
									sizeof( LARGE_INTEGER ),
									&dwBytesWritten,
									NULL ) ||
						dwBytesWritten != sizeof( LARGE_INTEGER ) ) {
					ErrorTrace(0, "Write leading integer fail %d",
								GetLastError() );
					if ( GetLastError() == NO_ERROR )
						SetLastError( ERROR_WRITE_FAULT );
					goto Exit;
				}

				// Now write the idhigh
				m_dwIdHigh = ID_HIGH_INIT;
                if ( !::WriteFile(  hStorageFile,
                                    &m_dwIdHigh,
                                    sizeof( DWORD ),
                                    &dwBytesWritten,
                                    NULL ) ||
                        dwBytesWritten != sizeof( DWORD ) ) {
                    ErrorTrace( 0, "Write id high failed %d",
                                    GetLastError() );
                    if ( GetLastError() == NO_ERROR )
                        SetLastError( ERROR_WRITE_FAULT );
                    goto Exit;
                }

				// Every time pre-alloc ALLOC_GRANURALITY blocks
				// Prepare the init value for block
				*(dbBuffer.szGroupName) = 0;

				// Scan, write, and put to free list
				for ( i = 0; i < ALLOC_GRANURALITY; i++ ) {
					dwBytesWritten = 0;
					if ( ::WriteFile (	hStorageFile,
										&dbBuffer,
										sizeof( DATA_BLOCK ),
										&dwBytesWritten,
										NULL ) &&
						 dwBytesWritten == sizeof( DATA_BLOCK ) ) {

						// link it to free list
						pfiFreeInfo = new CFreeInfo;
						if ( pfiFreeInfo ) {
							pfiFreeInfo->m_dwOffset = i ;
							m_FreeList.PushFront( pfiFreeInfo );
							m_cCurrentMaxBlocks++;
							pfiFreeInfo = NULL;
						} else { // pfiFreeInfo == NULL
							SetLastError( ERROR_OUTOFMEMORY );
							ErrorTrace(	0,
										"Create Free Info fail %d",
										GetLastError() );
							break;
						}
					} else { // Write file fail
						ErrorTrace(0, "Write file fail %d", GetLastError() );
						if ( GetLastError() == NO_ERROR )
							SetLastError( ERROR_WRITE_FAULT );
						break;
					}
				}

			} else { // Create file fail
				ErrorTrace(0, "Create new storage file fail %d", GetLastError());
				if ( GetLastError() == NO_ERROR )
					SetLastError( ERROR_OPEN_FILES );
			    goto Exit;
			}
		} else { // !bCreateIfNonExist
			ErrorTrace(0, "Storage file not found %d", GetLastError() );
			if ( GetLastError() == NO_ERROR )
				SetLastError( ERROR_OPEN_FILES );
		    goto Exit;
		}
	} else { // File already exists and open succeeded

		_ASSERT( m_cCurrentMaxBlocks == 0 );	// not set yet

        DWORD dwFileSizeLow;
		DWORD dwFileSizeHigh;

		dwFileSizeLow = GetFileSize(hStorageFile, &dwFileSizeHigh);
		if (dwFileSizeLow == 0 || dwFileSizeHigh != 0) {
			ErrorTrace(0, "Bad group.lst size");
			SetLastError(ERROR_INVALID_DATA);
			goto Exit;
		}

		hMap = CreateFileMapping(
		  hStorageFile,                 // handle to file to map
		  NULL,                         // optional security attributes
		  PAGE_READONLY | SEC_COMMIT,   // protection for mapping object
		  0,                            // high-order 32 bits of object size
		  0,                            // low-order 32 bits of object size
		  NULL                          // name of file-mapping object
		);

        if (hMap == NULL) {
            ErrorTrace(0, "Couldn't map group.lst, err %d", GetLastError());
            goto Exit;
        }

		pMap = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
		if (pMap == NULL) {
		    ErrorTrace(0, "Couldn't map group.lst, err %d", GetLastError());
		    goto Exit;
		}

        pdwHeader = (DWORD*)pMap;
		dwHeaderLength = 2*sizeof(DWORD);

		// Check file signature
        if (FIXPROP_SIGNATURE != pdwHeader[0]) {
			ErrorTrace(0, "Loading file fail %d", GetLastError() );
			SetLastError( ERROR_OLD_WIN_VERSION ); // BUGBUG: fake err code, just used
			                                       // internally
            goto Exit;
        }

		// For files that has id high, load it
		if (pdwHeader[1] & FLAG_WITH_ID_HIGH ) {
		    m_dwIdHigh = pdwHeader[2];
		    dwHeaderLength += sizeof(DWORD);
        }

        _ASSERT( m_dwIdHigh >= ID_HIGH_INIT );

        if ( pdwIdHigh ) *pdwIdHigh = m_dwIdHigh + 1;

        //
        // Determine how many data blocks are in the file and allocate an
        // array of pointers for use by qsort
        //

		dwFileSizeLow -= dwHeaderLength;
		if ((dwFileSizeLow % sizeof(DATA_BLOCK)) != 0) {
		    ErrorTrace(0, "Filesize(%d) not multiple of DATA_BLOCK(%d)",
		        dwFileSizeLow, sizeof(DATA_BLOCK));
		    SetLastError(ERROR_INVALID_DATA);
		    goto Exit;
		}
		DWORD cDataBlocks = dwFileSizeLow / sizeof(DATA_BLOCK);
		DATA_BLOCK* pBlock = (DATA_BLOCK*)((char*)pMap + dwHeaderLength);

		pInUseBlocks = XNEW DATA_BLOCK* [cDataBlocks];
		if (pInUseBlocks == NULL) {
		    goto Exit;
		}

		DWORD cInUseBlocks = 0;

		for (DWORD i2=0; i2<cDataBlocks; i2++) {

	        // Update our hints roughly every five seconds.  We only check the
	        // time every 100 groups or so..
	        if( (i2 % 100) == 0 ) {
		        time_t now = time(NULL);
		        if (now > g_tNextHint) {
			        StartHintFunction();
			        g_tNextHint = now + 5;
		        }
	        }

			if (pBlock[i2].szGroupName[0] == 0) {
                // Free block
				pfiFreeInfo = new CFreeInfo;
				if ( pfiFreeInfo ) {
					pfiFreeInfo->m_dwOffset = i2;
					m_FreeList.PushFront( pfiFreeInfo );
					pfiFreeInfo = NULL;
				} else { // new fail
					ErrorTrace(0, "Alloc CFreeInfo fail" );
					SetLastError( ERROR_OUTOFMEMORY );
					break;	// no point continuing
				}
			} else {
				// In use block
				pInUseBlocks[cInUseBlocks++] = &pBlock[i2];
			}

		}

        // Sort the array
        if (!bInOrder) {
    		qsort(pInUseBlocks, cInUseBlocks, sizeof(DATA_BLOCK*), CompareDataBlock);
        }

        //
        // Now call the callback if one is provided.  We let it know that
        // the data's in order to speed up the insertions.
        //
		if ( pfnEnumCallback ) {
		    for (i=0; i<cInUseBlocks; i++) {
		        DWORD idx = (DWORD)(pInUseBlocks[i] - &pBlock[0]);

			    if ( !pfnEnumCallback( pBlock[idx], m_pvContext, idx, TRUE ) &&
				        GetLastError() != ERROR_INVALID_NAME &&
						GetLastError() != ERROR_ALREADY_EXISTS  ) {
					ErrorTrace(0, "Enumerate call back fail" );
					if ( GetLastError() == NO_ERROR ) {
						SetLastError( ERROR_INVALID_FUNCTION );
					}
					goto Exit;
				}
			}
		}

        m_cCurrentMaxBlocks = cDataBlocks;

	}

	_VERIFY( CloseHandle( hStorageFile ) );
	hStorageFile = INVALID_HANDLE_VALUE;

	// Last thing to do: Create the member handle for future async use
	_ASSERT( INVALID_HANDLE_VALUE == hStorageFile );
	_ASSERT( INVALID_HANDLE_VALUE == m_hStorageFile );

	m_hStorageFile = CreateFile(    m_szStorageFile,
		                            GENERIC_WRITE | GENERIC_READ,
									FILE_SHARE_READ, // no one else
													 // can write
									NULL,
									OPEN_EXISTING,
									FILE_FLAG_OVERLAPPED,
									NULL );
	if ( INVALID_HANDLE_VALUE == m_hStorageFile ) {
		if ( GetLastError() ==  NO_ERROR )
			SetLastError( ERROR_OPEN_FILES );
			goto Exit;
	}

	bSucceeded = TRUE;

Exit:

    DWORD gle = GetLastError();

    if (pMap != NULL) {
        _VERIFY(UnmapViewOfFile(pMap));
    }

    if (hMap != NULL) {
        _VERIFY(CloseHandle(hMap));
    }

    if (hStorageFile != INVALID_HANDLE_VALUE) {
        _VERIFY(CloseHandle(hStorageFile));
    }

    if (pInUseBlocks) {
        XDELETE [] pInUseBlocks;
    }

    if ( !bSucceeded ) {

        CleanFreeList();

        if ( InterlockedDecrement( &m_lRef ) == 0 ) {
            CFreeInfo::TermClass();
        }

    }

    m_sLock.ExclusiveUnlock();

	// Now we are done, return if we have been successful
	TraceFunctLeave();
	SetLastError(gle);
	return bSucceeded;
}

void
CFixPropPersist::CleanFreeList()
{
    CFreeInfo *pfiPtr = NULL;

    while( !m_FreeList.IsEmpty() ) {
        pfiPtr = m_FreeList.PopBack();
        _ASSERT( pfiPtr );
        delete pfiPtr;
    }
}

BOOL CFixPropPersist::Term()
{
	CFreeInfo *pfiPtr = NULL;
	BOOL    b = TRUE;

    m_sLock.ExclusiveLock();
#if defined( DEBUG )
	Validate();
#endif

	SetLastError( NO_ERROR );

	// Close file handle
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_VERIFY( CloseHandle( m_hStorageFile ) );

	// Cleanup Free list
    CleanFreeList();

	// Terminate CPool stuff
	if ( InterlockedDecrement( &m_lRef ) == 0 ) {
	    b = CFreeInfo::TermClass();
	}

	m_sLock.ExclusiveUnlock();
	return b;
}

///////////////////////////////////////////////////////////////
// File read / write
BOOL CFixPropPersist::ReadFile( IN OUT PBYTE pbBuffer,
								IN DWORD	dwOffset,
								IN DWORD    dwSize,
								IN BOOL     bReadBlock )
/*++
Routine description:

	Read block from specified offset.

Arguments:

	IN DWORD dwOffset - Where into the file to read from ?
						If it's 0, then no seek is needed.
	IN OUT DATA_BLOCK& dbBuffer - Where to read the stuff into ?

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::ReadFile" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_ASSERT( dwOffset < m_cCurrentMaxBlocks );
#if defined( DEBUG )
	Validate();
#endif

	DWORD dwErr = 0;
	LARGE_INTEGER	liOffset;
	BOOL	bSuccess = FALSE;
	DWORD   dwBytesRead = 0;

	SetLastError( NO_ERROR );

    if ( !bReadBlock ) {
        liOffset.QuadPart = sizeof( LARGE_INTEGER );
    } else {
        if ( ID_HIGH_INVALID != m_dwIdHigh ) {
            liOffset.QuadPart = sizeof( LARGE_INTEGER)
                                    + sizeof( DWORD ) +
                                    dwOffset * sizeof( DATA_BLOCK );
        } else {
        	liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
		    					dwOffset * sizeof( DATA_BLOCK );
        }
    }

    if ( AsyncRead( pbBuffer, liOffset, dwSize ) )
        bSuccess = TRUE;

	TraceFunctLeave();
	return bSuccess;
}

BOOL CFixPropPersist::WriteFile(	IN PBYTE    pbBuffer,
									IN DWORD	dwOffset,
									IN DWORD    dwSize,
									IN BOOL     bWriteBlock )
/*++
Routine description:

	Write block from specified offset.

Arguments:

	IN DWORD dwOffset - Where into the file to write from ?
						If it's 0, then no pre-seek is needed
	IN DATA_BLOCK& dbBuffer - Where to write the stuff from ?

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::WriteFile" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_ASSERT( dwOffset < m_cCurrentMaxBlocks );
#if defined ( DEBUG )
	Validate();
#endif

	DWORD dwErr = 0;
	LARGE_INTEGER   liOffset;
	BOOL    bSuccess;

	SetLastError( NO_ERROR );

    if ( !bWriteBlock ) {
        liOffset.QuadPart = sizeof( LARGE_INTEGER );
    } else {
        if ( ID_HIGH_INVALID != m_dwIdHigh  ) {
            liOffset.QuadPart = sizeof( LARGE_INTEGER)
                                    + sizeof( DWORD ) +
                                    dwOffset * sizeof( DATA_BLOCK );
        } else {
        	liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
		    					dwOffset * sizeof( DATA_BLOCK );
        }
    }

	bSuccess = FALSE;
	if ( AsyncWrite( pbBuffer, liOffset, dwSize ) ) {
	    bSuccess = TRUE ;
	}

	TraceFunctLeave();
	return bSuccess;
}

BOOL
CFixPropPersist::AsyncRead( PBYTE           pbBuffer,
                            LARGE_INTEGER   liOffset,
                            DWORD           dwSize )
/*++
Routine description:

    Does an async read and event wait on the file

Arguments:

    LPSTR   pbBuffer -      Buffer for read
    LARGE_INTEGER liOffset -    Read offset
    DWORD   dwSize - Size to read

Return value:

    TRUE - Succeeded
    FALSE - Failed
--*/
{
    TraceFunctEnter( "CFixPropPersist::AsyncRead" );
    _ASSERT( pbBuffer );

    OVERLAPPED  ovl;
    BOOL        bSuccess = FALSE;
    DWORD       dwBytesRead = 0;

    ZeroMemory( &ovl, sizeof( ovl ) );

   	ovl.Offset = liOffset.LowPart;
	ovl.OffsetHigh = liOffset.HighPart;
	ovl.hEvent = GetPerThreadEvent();
	if ( NULL == ovl.hEvent ) {
	    _ASSERT( FALSE && "Event NULL" );
	    ErrorTrace( 0, "CreateEvent failed %d", GetLastError() );
	    return FALSE;
	}

	bSuccess = FALSE;
	if ( ::ReadFile(	m_hStorageFile,
					pbBuffer,
					dwSize,
					NULL,
					&ovl ) ||
		GetLastError() == ERROR_IO_PENDING ) {
		WaitForSingleObject( ovl.hEvent, INFINITE );
		if ( GetOverlappedResult(  m_hStorageFile,
		                            &ovl,
		                            &dwBytesRead,
		                            FALSE ) ) {
		    // bytes read should be the same as we specified
		    if ( dwBytesRead == dwSize ) {
                bSuccess = TRUE;
            }
        }
    } else {
        _VERIFY( ResetEvent( ovl.hEvent ) );
    }

	_ASSERT( ovl.hEvent );
	//_VERIFY( CloseHandle( ovl.hEvent ) );

    TraceFunctLeave();
	return bSuccess;
}

BOOL
CFixPropPersist::AsyncWrite( PBYTE           pbBuffer,
                             LARGE_INTEGER   liOffset,
                             DWORD           dwSize )
/*++
Routine description:

    Does an async write and event wait on the file

Arguments:

    LPSTR   pbBuffer -      Buffer for write
    LARGE_INTEGER liOffset -    Write offset
    DWORD   dwSize - Size to write

Return value:

    TRUE - Succeeded
    FALSE - Failed
--*/
{
    TraceFunctEnter( "CFixPropPersist::AsyncRead" );
    _ASSERT( pbBuffer );

    OVERLAPPED  ovl;
    BOOL        bSuccess = FALSE;
    DWORD       dwBytesWritten = 0;

    ZeroMemory( &ovl, sizeof( ovl ) );

   	ovl.Offset = liOffset.LowPart;
	ovl.OffsetHigh = liOffset.HighPart;
	ovl.hEvent = GetPerThreadEvent();
	if ( NULL == ovl.hEvent ) {
	    _ASSERT( FALSE && "Thread event NULL" );
	    ErrorTrace( 0, "CreateEvent failed %d", GetLastError() );
	    return FALSE;
	}

	bSuccess = FALSE;
	if ( ::WriteFile(	m_hStorageFile,
					pbBuffer,
					dwSize,
					NULL,
					&ovl ) ||
		    GetLastError() == ERROR_IO_PENDING ) {
		WaitForSingleObject( ovl.hEvent, INFINITE );
		if ( GetOverlappedResult(  m_hStorageFile,
		                            &ovl,
		                            &dwBytesWritten,
		                            FALSE ) ) {
		    // bytes read should be the same as we specified
		    if ( dwBytesWritten == dwSize ) {
                bSuccess = TRUE;
            }
        } else {
            _ASSERT( 0 );
        }
    }  else {
        _VERIFY( ResetEvent( ovl.hEvent ) );
    }

	_ASSERT( ovl.hEvent );
	//_VERIFY( CloseHandle( ovl.hEvent ) );

    TraceFunctLeave();
	return bSuccess;
}


BOOL CFixPropPersist::ExtendFile( 	IN DWORD cBlocks )
/*++
Routine description:

	Extend the file.

Arguments:

	IN DWORD cBlocks - Number of blocks to extend

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::ExtendFile" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_ASSERT( cBlocks > 0 );
#if defined( DEBUG )
	Validate();
#endif

	DATA_BLOCK 	dbBuffer;
	DWORD		i;
	LARGE_INTEGER   liOffset;
	BOOL    bSuccess = TRUE;

	SetLastError( NO_ERROR );

	// Fill up overlapped structure
	*(dbBuffer.szGroupName) = 0;	// set it to free

	for( i = 0; i < cBlocks && bSuccess; i++ ) {

		if ( m_dwIdHigh != ID_HIGH_INVALID ) {
    		liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
    		                        + sizeof( DWORD ) +
	    	                        ( i + m_cCurrentMaxBlocks ) *
								sizeof( DATA_BLOCK );
		} else {
		    liOffset.QuadPart = sizeof( LARGE_INTEGER ) +
		                            ( i + m_cCurrentMaxBlocks ) *
		                            sizeof( DATA_BLOCK );
		}

		bSuccess = FALSE;
		if ( AsyncWrite(    PBYTE(&dbBuffer),
		                    liOffset,
		                    sizeof( DATA_BLOCK ) ) ){
		    bSuccess = TRUE ;
		    m_cCurrentMaxBlocks++;
		}
	}

	TraceFunctLeave();
	return bSuccess;
}

/////////////////////////////////////////////////////////////////
// File seek methods
DWORD CFixPropPersist::SeekByName( 	IN LPSTR szGroupName )
/*++
Routine description:

	Seek the file pointer associated with the handle by group name.
	This is used when the group property bag doesn't have offset
	information.

Arguments:

	IN LPSTR szGroupName - The name to match and find.

Return value:

	Offset, on success, 0xffffffff if failed
--*/
{
	TraceFunctEnter( "CFixPropPersist::SeekByName" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
	_ASSERT( szGroupName );
	_ASSERT( lstrlen( szGroupName ) < GROUPNAME_LEN_MAX );
#if defined( DEBUG )
	Validate();
#endif

	DWORD 		i;
	DATA_BLOCK	dbBuffer;
	LARGE_INTEGER   liOffset;
	DWORD           bSuccess = TRUE;

	SetLastError( NO_ERROR );

	for ( i = 0; i < m_cCurrentMaxBlocks && bSuccess; i++ ) {

        if ( m_dwIdHigh != ID_HIGH_INVALID ) {
    		liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
    		                        sizeof( DWORD ) +
	    	                        i * sizeof( DATA_BLOCK );
	    } else {
	        liOffset.QuadPart = sizeof( LARGE_INTEGER ) +
	                                i * sizeof( DATA_BLOCK );
	    }

        bSuccess = FALSE;
		if ( AsyncRead( PBYTE(&dbBuffer), liOffset, sizeof( DATA_BLOCK ) ) ) {
		    bSuccess = TRUE;
			if ( strcmp( dbBuffer.szGroupName, szGroupName ) == 0 ) {
				return i;
			}
		}
	}

	// Unfortunately, not found
	TraceFunctLeave();
	return 0xffffffff;
}

DWORD CFixPropPersist::SeekByGroupId( 	IN DWORD dwGroupId,
										IN LPSTR szGroupName)
/*++
Routine description:

	Seek the file pointer associated with the handle by group id.
	This is used when the group property bag doesn't have offset
	information.

Arguments:

	IN DWORD dwGroupId - The group id to match and find.
	IN LPSTR szGroupName - The group name to verify with

Return value:

	Offset, on success, 0xffffffff if failed
--*/
{
	TraceFunctEnter( "CFixPropPersist::SeekByGroupId" );
	_ASSERT( INVALID_HANDLE_VALUE != m_hStorageFile );
#if defined( DEBUG )
	Validate();
#endif

	DWORD 		i;
	DATA_BLOCK	dbBuffer;
	LARGE_INTEGER   liOffset;
	BOOL            bSuccess = TRUE;

	SetLastError( NO_ERROR );

	for ( i = 0; i < m_cCurrentMaxBlocks && bSuccess; i++ ) {

	    if ( m_dwIdHigh != ID_HIGH_INVALID ) {
    	    liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
    	                            sizeof( DWORD ) +
	                                i * sizeof( DATA_BLOCK );
	    } else {
	        liOffset.QuadPart = sizeof( LARGE_INTEGER ) +
	                                i * sizeof( DATA_BLOCK );
	    }

        bSuccess = FALSE;
        if ( AsyncRead( PBYTE(&dbBuffer), liOffset, sizeof( DATA_BLOCK ) ) ) {
            bSuccess = TRUE;
	        if ( dbBuffer.dwGroupId == dwGroupId ) {
				if ( strcmp( dbBuffer.szGroupName, szGroupName ) == 0 )
	            	return i;
	        }
	    }
	}

	// Unfortunately, not found
	TraceFunctLeave();
	return 0xffffffff;
}

DWORD	CFixPropPersist::SeekByBest( 	IN INNTPPropertyBag *pPropBag )
/*++
Routine description:

	Seek the file pointer by best methods:

Arguments:

	IN INNTPPropertyBag *pPropBag - Group's property bag.

Return value:

	Offset, if succeeded, 0xffffffff otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::SeekByBest" );
	_ASSERT( m_hStorageFile );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	DWORD 	dwOffset = 0;
	DWORD	dwGroupId;
	HRESULT	hr;
	BOOL	bFound = FALSE;
	DWORD	dwErr = 0xffffffff;
	DATA_BLOCK	dbBuffer;
	CHAR	szGroupName[GROUPNAME_LEN_MAX+1];
	DWORD	dwNameLen = GROUPNAME_LEN_MAX;
	DWORD	dwBytesRead = 0;
	LARGE_INTEGER   liOffset;

	SetLastError( NO_ERROR );

    //
	// Get group id, we'll use group id to check if the group property
	// we got back is what we want, since group id is the only key to
	// uniquely identify a group
	//

	hr = pPropBag->GetDWord( NEWSGRP_PROP_GROUPID, &dwGroupId );
	if ( FAILED( hr ) ) {	// fatal
		ErrorTrace(0, "Group without id %x", hr );
		SetLastError( ERROR_INVALID_DATA );
		return 0xffffffff;
	}

	// Try to get offset from the bag
	dwOffset = GetGroupOffset( pPropBag );
	if ( dwOffset != 0xffffffff ) {	// use offset to seek

		if ( m_dwIdHigh != ID_HIGH_INVALID ) {
    		liOffset.QuadPart =  sizeof( LARGE_INTEGER ) +
    		                        sizeof( DWORD ) +
		                        dwOffset * sizeof( DATA_BLOCK );
		} else {
		    liOffset.QuadPart = sizeof( LARGE_INTEGER ) +
		                            dwOffset * sizeof( DATA_BLOCK );
		}

        if ( AsyncRead( PBYTE(&dbBuffer), liOffset, sizeof( DATA_BLOCK ) ) ) {
			if ( dwGroupId == dbBuffer.dwGroupId ) {
				// We found it, set file pointer back one block
				bFound = TRUE;
			}
		}
	}	// offset property exists

#if 0
	if ( !bFound ) {	// we have to use method 2

		// try to get group id
		hr = pPropBag->GetDWord( NEWSGRP_PROP_GROUPID, &dwGroupId );

		if ( SUCCEEDED( hr ) && dwGroupId != 0 ) 	{ // use seek by group id
			dwOffset = SeekByGroupId( dwGroupId, szGroupName );
			if ( 0xffffffff != dwOffset ) {	// found

				// Load offset into property bag
				hr = pPropBag->PutDWord( NEWSGRP_PROP_FIXOFFSET, dwOffset );
				if ( FAILED( hr ) ) {	// fatal
					ErrorTrace(0, "Load offset fail %x", hr );
					SetLastError( ERROR_INVALID_DATA );
					return 0xffffffff;
				}

				// I am done
				bFound = TRUE;
			}	// Seek by group succeeded
		}	// Group Id available

		if ( !bFound ) {	// Use seek method 3
			dwOffset = SeekByName(	szGroupName );
			if ( 0xffffffff != dwOffset ) { // found

				// Load offset
				hr = pPropBag->PutDWord( NEWSGRP_PROP_FIXOFFSET, dwOffset );
				if ( FAILED( hr ) ) {	// fatal
					ErrorTrace(0, "Put offset fail %x", hr );
					SetLastError( ERROR_INVALID_DATA );
					return 0xffffffff;
				} // load offset fail

				bFound = TRUE;
			} // seek by name OK
		} // Used mehtod 3
	}	// method 1 not found
#endif

	if ( bFound )
		return dwOffset;
	else return 0xffffffff;
}

BOOL
CFixPropPersist::ProbeForOrder( BOOL& bInOrder )
/*++
Routine description:

    Probe the group.lst.ord to see if it's a good one ( in order and
    not corrupted ).  If it is, move it to group.lst, otherwise ,
    delete it.

Arguments:

    BOOL& bInOrder - Is the group.lst.ord good ?

Return value:

    TRUE succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CFixPropPersist::ProbeForOrder" );

    CHAR    szBackupFile[MAX_PATH+1];
    /*
    WCHAR   wszBackupFile[MAX_PATH+1];
    WCHAR   wszStorageFile[MAX_PATH+1];
    */
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    LARGE_INTEGER   lFlags;
    DWORD   dwRead = 0;

    // Try open the backup file
    strcpy( szBackupFile, m_szStorageFile );
    strcat( szBackupFile, ".ord" );
    _ASSERT( strlen( szBackupFile ) < MAX_PATH + 1 );

    hFile = ::CreateFile(   szBackupFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL );
    if ( INVALID_HANDLE_VALUE == hFile ) {

        // No order
        bInOrder = FALSE;
        goto Exit;
    }

    // Probe the flag to see if it's in good shape
    if ( !::ReadFile(   hFile,
                        &lFlags,
                        sizeof( LARGE_INTEGER ),
                        &dwRead,
                        NULL )  ||
        sizeof( LARGE_INTEGER ) != dwRead ) {

        // No order
        bInOrder = FALSE;
        goto Exit;
    }

    if ( lFlags.HighPart & FLAG_IN_ORDER )
        bInOrder = TRUE;
    else bInOrder = FALSE;

Exit:

    // Close the file handle, if necessary
    if ( INVALID_HANDLE_VALUE != hFile )
        _VERIFY( CloseHandle( hFile ) );

    // If in order, we do move file
    if ( bInOrder ) {

        /*
        // We use CopyFileW, since bug 77906
        CopyAsciiStringIntoUnicode( wszBackupFile, szBackupFile );
        CopyAsciiStringIntoUnicode( wszStorageFile, m_szStorageFile );
        */
        if ( CopyFile( szBackupFile, m_szStorageFile, FALSE ) ) {
            DeleteFile( szBackupFile );
            TraceFunctLeave();
            return TRUE;
        }
    }

    // Either in order and move file failed or not in order
    // Delete the back up file, failure is fine
    DeleteFile( szBackupFile );

    bInOrder = FALSE;

    return TRUE;
}

///////////////////////////////////////////////////////////////
// Public methods
BOOL CFixPropPersist::AddGroup( IN INNTPPropertyBag* pPropBag )
/*++
Routine description:

	Add a group's fixed sized properties into storage.

Arguments:

	IN INNTPPropertyBag* pPropBag - The group's property bag.

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::AddGroup" );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	DWORD		i;
	DATA_BLOCK	dbBuffer;
	CFreeInfo	*pfiFreeInfo = NULL;
	DWORD		cOldMaxBlocks;
	HRESULT 	hr;
	DWORD       dwGroupId;

	// Clear error flag
	SetLastError( NO_ERROR );

	// prepare the buffer
	Group2Buffer( dbBuffer, pPropBag, ALL_FIX_PROPERTIES );
	dwGroupId = dbBuffer.dwGroupId;
	//_ASSERT( dwGroupId >= ID_HIGH_INIT );

	// Try to pop one free block from free list
	ExclusiveLockFreeList();
	pfiFreeInfo = m_FreeList.PopBack();
	ExclusiveUnlockFreeList();
	if ( NULL == pfiFreeInfo ) {	// I have got to extend the file
		//
		// Try to grab expanding lock - we don't want more than one
		// guy expanding the file
		//
		m_FileExpandLock.ExclusiveLock();

		//
		// Do I really need to extend the file ?
		//
		ExclusiveLockFreeList();
		pfiFreeInfo = m_FreeList.PopBack();
		ExclusiveUnlockFreeList();
		if( NULL == pfiFreeInfo ) {	// I must do it and only I am doint it

			// Extend it
			cOldMaxBlocks = m_cCurrentMaxBlocks;	// save it
			if ( !ExtendFile( ALLOC_GRANURALITY ) ) {
				ErrorTrace( 0, "Extend file fail %d", GetLastError() );
				m_FileExpandLock.ExclusiveUnlock();
				return FALSE;
			}

			// consume the first block for myself
			if ( !WriteFile( PBYTE(&dbBuffer), cOldMaxBlocks ) ) {
				ErrorTrace( 0, "Write file fail %d", GetLastError() );
				m_FileExpandLock.ExclusiveUnlock();
				return FALSE;
			}

			// Set offset info into propeerty bag
			hr = pPropBag->PutDWord( 	NEWSGRP_PROP_FIXOFFSET,
										cOldMaxBlocks );
			if ( FAILED( hr ) ) {
				ErrorTrace(0, "Set group property fail %x", hr );
				m_FileExpandLock.ExclusiveUnlock();
				return FALSE;
			}

			// Link all other free blocks into free list
			for ( i = 1; i < ALLOC_GRANURALITY; i++ ) {
				pfiFreeInfo = new CFreeInfo;
				if( NULL == pfiFreeInfo ) {
					ErrorTrace(0, "Out of memory" );
					SetLastError( ERROR_OUTOFMEMORY );
					m_FileExpandLock.ExclusiveUnlock();
					return FALSE;
				}

				pfiFreeInfo->m_dwOffset = cOldMaxBlocks + i ;
				ExclusiveLockFreeList();
				m_FreeList.PushFront( pfiFreeInfo );
				ExclusiveUnlockFreeList();
				pfiFreeInfo = NULL;
			}

			// Ok, now it's time to release the lock
			m_FileExpandLock.ExclusiveUnlock();
		} else
			m_FileExpandLock.ExclusiveUnlock();
	} // if

	if ( NULL != pfiFreeInfo ) { // I didn't expand it

		// write the block
		if ( !WriteFile( PBYTE(&dbBuffer), pfiFreeInfo->m_dwOffset ) ) {
			ErrorTrace(0, "Write file fail %d", GetLastError() );
			return FALSE;
		}

		// Load offset into bag
		hr = pPropBag->PutDWord(    NEWSGRP_PROP_FIXOFFSET,
									pfiFreeInfo->m_dwOffset );
		if ( FAILED( hr ) ) {
   			ErrorTrace(0, "Set group property fail %x", hr );
			return FALSE;
		}

		// Free the free info node
		delete pfiFreeInfo;

		// I am done
	}

    // If the file has id high, we adjust it
    if ( ID_HIGH_INVALID != m_dwIdHigh ) {
        ExclusiveLockIdHigh();
        if ( m_dwIdHigh < dwGroupId ) {
            if ( !WriteFile( PBYTE( &dwGroupId ), 0, sizeof( DWORD ), FALSE ) ){
                ErrorTrace( 0, "Write id high failed %d", GetLastError() );
                ExclusiveUnlockIdHigh();
                return FALSE;
            }
            m_dwIdHigh = dwGroupId;
        }
        ExclusiveUnlockIdHigh();
    }

	TraceFunctLeave();
	return TRUE;
}

BOOL CFixPropPersist::RemoveGroup(	IN INNTPPropertyBag *pPropBag )
/*++
Routine description:

	Remove the group from the property file.

Arguments:

	IN INNTPPropertyBag *pPropBag - The group's property bag.

Return value:

	TRUE if succeeded, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::RemoveGroup" );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	DWORD	dwOffset = 0xffffffff;
	DWORD   dwLockOffset = 0xffffffff;
	DATA_BLOCK dbBuffer;
	CFreeInfo *pfiFreeInfo = NULL;

	SetLastError( NO_ERROR );

	//
	// Grab the exclusive lock to the offset to remove
	//

	dwLockOffset = ExclusiveLock( pPropBag );
	if ( 0xffffffff == dwLockOffset ) {

	    //
	    // Somehow we failed in grabbing the exclusive lock
	    //

	    ErrorTrace( 0, "Grab offset exclusive lock failed" );
	    return FALSE;
	}

	// Seek by best
	dwOffset = SeekByBest( pPropBag );
	if ( 0xffffffff == dwOffset ) {	// fatal
		ErrorTrace(0, "Seek by best fail %d", GetLastError() );
		ExclusiveUnlock( dwLockOffset );
		return FALSE;
	}

	_ASSERT( dwOffset == dwLockOffset );

	// Should set it free in file first
	*(dbBuffer.szGroupName) = 0;
	if ( !WriteFile( PBYTE(&dbBuffer), dwOffset ) ) {	// fatal
		ErrorTrace( 0, "Write file fail %d" , GetLastError() );
		ExclusiveUnlock( dwLockOffset );
		return FALSE;
	}

	ExclusiveUnlock( dwLockOffset );

	// Add it to free list
	pfiFreeInfo = new CFreeInfo;
	if ( NULL == pfiFreeInfo ) {
		ErrorTrace( 0, "Alloc free info fail" );
		SetLastError( ERROR_OUTOFMEMORY );
		return FALSE;
	}
	pfiFreeInfo->m_dwOffset = dwOffset;
	ExclusiveLockFreeList();
	m_FreeList.PushFront( pfiFreeInfo );
	ExclusiveUnlockFreeList();

	// Done.
	TraceFunctLeave();
	return TRUE;
}

BOOL CFixPropPersist::GetGroup( IN INNTPPropertyBag *pPropBag, IN DWORD dwFlag )
/*++
Routine description:

	Get group properties from the property file.

Arguments:

	IN INNTPPropertyBag *pPropBag - Where to put the properties into
	IN DWORD dwFlag - Bit mask of what property to get

Return value:

	TRUE if succeeded, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::GetGroup" );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	SetLastError ( NO_ERROR );

	DWORD	dwOffset = 0xffffffff;
	DWORD   dwLockOffset = 0xffffffff;
	DATA_BLOCK dbBuffer;

    //
    // Lock the offset for read access
    //

    dwLockOffset = ShareLock( pPropBag );
    if ( 0xffffffff == dwLockOffset ) {
        ErrorTrace( 0, "Grabbing share lock for group offset failed" );
        return FALSE;
    }

	// Seek by best
	dwOffset = SeekByBest( pPropBag );
	if ( 0xffffffff == dwOffset )  {
		ErrorTrace( 0, "Seek by best fail" );
		ShareUnlock( dwLockOffset );
		return FALSE;
	}

	_ASSERT( dwLockOffset == dwOffset );

	// Read the whole block
	if( !ReadFile( PBYTE(&dbBuffer), dwOffset ) ) {
		ErrorTrace( 0, "Read file fail %d", GetLastError() );
		ShareUnlock( dwLockOffset );
		return FALSE;
	}

	ShareUnlock( dwLockOffset );

	_ASSERT( *(dbBuffer.szGroupName) );

	// Load into group property bag based on flag
	Buffer2Group( dbBuffer, pPropBag, dwFlag );

	// Done
	TraceFunctLeave();
	return TRUE;
}

BOOL CFixPropPersist::SetGroup( IN INNTPPropertyBag *pPropBag, IN DWORD dwFlag)
/*++
Routine description:

	Set group properties into the file.

Arguments:

	IN INNTPPropertyBag *pProgBag - The group's property bag
	IN DWORD dwFlag - Bit mask of properties to set

Return value:

	TRUE if succeeded, FALSE otherwise
--*/
{
	TraceFunctEnter( "CFixPropPersist::SetGroup" );
	_ASSERT( pPropBag );
#if defined( DEBUG )
	Validate();
#endif

	SetLastError ( NO_ERROR );

	DWORD	dwOffset = 0xffffffff;
	DWORD   dwLockOffset = 0xffffffff;
	DATA_BLOCK dbBuffer;
	DWORD   dwIdGroup;

	//
	// Grab write lock for access the offset in group.lst
	//

	dwLockOffset = ExclusiveLock( pPropBag );
	if ( 0xffffffff == dwLockOffset ) {
	    ErrorTrace( 0, "Grab exlcusive lock for offset failed" );
	    return FALSE;
	}

	// Seek by best
	dwOffset = SeekByBest( pPropBag );
	if ( 0xffffffff == dwOffset )  {
		ErrorTrace( 0, "Seek by best fail" );
		ExclusiveUnlock( dwLockOffset );
		return FALSE;
	}

	_ASSERT( dwOffset == dwLockOffset );

	// Read the whole block
	if ( dwFlag != ALL_FIX_PROPERTIES ) {
		if( !ReadFile( PBYTE(&dbBuffer), dwOffset ) ) {
			ErrorTrace( 0, "Read file fail %d", GetLastError() );
			ExclusiveUnlock( dwLockOffset );
			return FALSE;
		}
		_ASSERT( *(dbBuffer.szGroupName) );
	}

	// Set the block
	Group2Buffer( dbBuffer, pPropBag, dwFlag );
	dwIdGroup = dbBuffer.dwGroupId;

	// Write the block back
	if ( !WriteFile( PBYTE(&dbBuffer), dwOffset ) ) {
		ErrorTrace(0, "Write file fail %d", GetLastError() );
		ExclusiveUnlock( dwLockOffset );
		return FALSE;
	}

	ExclusiveUnlock( dwLockOffset );

    // If the file has id high, we maintain it
    if ( ID_HIGH_INVALID != m_dwIdHigh ) {
        ExclusiveLockIdHigh();
        if ( m_dwIdHigh < dwIdGroup ) {
            if ( !WriteFile( PBYTE( &dwIdGroup ), 0, sizeof( DWORD ), FALSE ) ) {
                ErrorTrace( 0, "Write id high failed %d", GetLastError() );
                ExclusiveUnlockIdHigh();
                return FALSE;
            }
            m_dwIdHigh = dwIdGroup;
        }
        ExclusiveUnlockIdHigh();
    }

	// done
	TraceFunctLeave();
	return TRUE;
}

BOOL
CFixPropPersist::SaveTreeInit()
/*++
Routine description:

    This method gets called when the newstree tries to shutdown.  It asks
    CFixPropPersist to get prepared to save the whole tree to a backup
    file ( groups are added into this backup file in order ).  On next
    startup, if the ordered file is good, we'll notify the newstree to
    do "AppendList" instead of "InsertList" so that we can load the whole
    tree much faster.

Arguments:

    None.

Return value:

    TRUE, succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CFixPropPersist::SaveTreeInit" );
    CHAR    szBackupFile[MAX_PATH+1];
    DWORD   rgdw[3];
    DWORD   dwWritten = 0;

    // Nobody should have called this before
    _ASSERT( INVALID_HANDLE_VALUE == m_hBackupFile );
    if ( INVALID_HANDLE_VALUE != m_hBackupFile ) {
        ErrorTrace( 0, "SaveTreeInit already initialized" );
        SetLastError( ERROR_ALREADY_INITIALIZED );
        return FALSE;
    }

    // Create the backfile
    strcpy( szBackupFile, m_szStorageFile );
    strcat( szBackupFile, ".ord" );
    _ASSERT( strlen( szBackupFile ) < MAX_PATH+1 );
    m_hBackupFile = ::CreateFile( szBackupFile,
                                GENERIC_WRITE,
                                0,      // not shared by anybody else
                                NULL,
                                CREATE_ALWAYS,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL );
    if ( INVALID_HANDLE_VALUE == m_hBackupFile ) {
        ErrorTrace( 0, "Creating backup file failed %d", GetLastError() );
        return FALSE;
    }

    // Write the three dwords - signature ( 2 ) and id-high ( 1 )
    // they are all zero now, these values will be set on SaveTreeClose
    ZeroMemory( rgdw, 3 * sizeof( DWORD ) );
    if ( !::WriteFile(    m_hBackupFile,
                        rgdw,
                        3 * sizeof( DWORD ),
                        &dwWritten,
                        NULL ) ||
         dwWritten != sizeof( DWORD ) * 3 ) {
         ErrorTrace( 0, "Write group.lst.ord header failed %d", GetLastError() );
         _VERIFY( CloseHandle( m_hBackupFile ) );
         return FALSE;
     }

     // OK, now it's ready, leave the handle open
     TraceFunctLeave();
     return TRUE;
}

BOOL
CFixPropPersist::SaveGroup( INNTPPropertyBag *pPropBag )
/*++
Routine Description:

    Save the group into the back up.   This function only gets called
    when shutting down a newstree

    The convention for fixprop is fixprop never has to release
    the property bag itself.

Arguments:

    INNTPPropertyBag *pPropBag - The group to be saved.

Return value:

    TRUE - Success, FALSE otherwise
--*/
{
    TraceQuietEnter( "CFixPropPersist::SaveGroup" );
    _ASSERT( pPropBag );

    DATA_BLOCK  dbBuffer;
    DWORD       dwWritten = 0;

    // Make sure we have been initialized
    _ASSERT( m_hBackupFile != INVALID_HANDLE_VALUE );
    if ( INVALID_HANDLE_VALUE == m_hBackupFile ) {
        ErrorTrace( 0, "Try to save group before init savetree" );
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    // Convert the bag to buffer
    Group2Buffer( dbBuffer, pPropBag, ALL_FIX_PROPERTIES );

    // Do a writefile to save the
    if ( !::WriteFile(  m_hBackupFile,
                        &dbBuffer,
                        sizeof( DATA_BLOCK ),
                        &dwWritten,
                        NULL ) ||
         dwWritten != sizeof( DATA_BLOCK ) ) {
         ErrorTrace( 0, "Write file in savegroup failed %d", GetLastError() );
         return FALSE;
    }

    // that's it
    return TRUE;
}

BOOL
CFixPropPersist::SaveTreeClose( BOOL bEffective )
/*++
Routine description:

    Terminate the save tree operation.  Things done in this function:
    1. Set signature 2. Set flags 3. Set id high 4. Close handle

Arguments:

    None.

Return value:

    TRUE, if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CFixPropPersist::SaveTreeClose" );

    // Still, we should already have been initialized
    _ASSERT( INVALID_HANDLE_VALUE != m_hBackupFile );
    if ( INVALID_HANDLE_VALUE == m_hBackupFile ) {
        ErrorTrace( 0, "Try to close Save tree before initialized" );
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }

    // If effective is false, we only need to close the handle
    // it must be without good order flag, so that next
    // time the server is up, it won't be picked up as the group
    // list file
    if ( !bEffective ) {
        CloseHandle( m_hBackupFile );
        return TRUE;
    }

    DWORD   rgdw[3];
    DWORD   dwMoved = 0xffffffff;
    DWORD   dwWritten = 0;

    // Set signature
    PLARGE_INTEGER(rgdw)->LowPart = FIXPROP_SIGNATURE;
    PLARGE_INTEGER(rgdw)->HighPart = FLAG_WITH_ID_HIGH | FLAG_IN_ORDER;
    rgdw[2] = m_dwIdHigh;

    // Reset the file pointer
    dwMoved = SetFilePointer(   m_hBackupFile,
                                0,
                                0,
                                FILE_BEGIN );
    if ( dwMoved == 0 ) {   // Succeeded

        if ( ::WriteFile(   m_hBackupFile,
                            rgdw,
                            sizeof( DWORD ) * 3,
                            &dwWritten,
                            NULL ) &&
             dwWritten == sizeof( DWORD ) * 3 ) {

             // Close the handle and return
             _VERIFY( CloseHandle( m_hBackupFile ) );
             m_hBackupFile = INVALID_HANDLE_VALUE;
             return TRUE;

        }
    }

    ErrorTrace( 0, "Write flags failed %d", GetLastError() );
    _VERIFY( CloseHandle( m_hBackupFile ) );
    m_hBackupFile = INVALID_HANDLE_VALUE;
    return FALSE;
}

DWORD
CFixPropPersist::GetGroupOffset(    INNTPPropertyBag *pPropBag )
/*++
Routine description:

    Get the offset in group.lst for the given group.  The offset
    should be the property bag already.

Arguments:

    INNTPPropertyBag *pPropBag - The newsgroup's property bag

Return value:

    The offset.  0xffffffff if the offset is missing from the property
    bag ( in dbg this is going to cause assert ).
--*/
{
    TraceFunctEnter( "CFixPropPersist::GetGroupOffset" );
    _ASSERT( pPropBag );

    HRESULT hr = S_OK;
    DWORD   dwOffset = 0xffffffff;

    hr = pPropBag->GetDWord(    NEWSGRP_PROP_FIXOFFSET, &dwOffset );
    if ( FAILED( hr ) ) {
        _ASSERT( FALSE && "Group should have offset" );
        return 0xffffffff;
    } else
        return dwOffset;
}

DWORD
CFixPropPersist::ShareLock(    INNTPPropertyBag *pPropBag )
/*++
Routine description:

    Lock the read access to the group's offset in group.lst

Arguments:

    pPropBag - The group's property bag

Return value:

    Group's offset if succeeded, 0xffffffff if failed
--*/
{
    TraceFunctEnter( "CFixPropPersist::ShareLock" );
    _ASSERT( pPropBag );

    DWORD   dwOffset = GetGroupOffset( pPropBag );
    if ( dwOffset != 0xffffffff ) {
        m_rgLockArray[dwOffset%GROUP_LOCK_ARRAY_SIZE].ShareLock();
    }

    TraceFunctLeave();
    return dwOffset;
}

void
CFixPropPersist::ShareUnlock( DWORD dwOffset )
/*++
Routine description:

    Unlock the read access to the offset in group.lst

Arguments:

    dwOffset - The offset to unlock

Return value:

    None
--*/
{
    TraceFunctEnter( "CFixPropPersist::ShareUnlock" );
    _ASSERT( 0xffffffff != dwOffset );

    m_rgLockArray[dwOffset%GROUP_LOCK_ARRAY_SIZE].ShareUnlock();
    TraceFunctLeave();
}

DWORD
CFixPropPersist::ExclusiveLock(    INNTPPropertyBag *pPropBag )
/*++
Routine description:

    Lock the write access to the group's offset in group.lst

Arguments:

    pPropBag - The group's property bag

Return value:

    Group's offset if succeeded, 0xffffffff if failed
--*/
{
    TraceFunctEnter( "CFixPropPersist::ExclusiveLock" );
    _ASSERT( pPropBag );

    DWORD   dwOffset = GetGroupOffset( pPropBag );
    if ( dwOffset != 0xffffffff ) {
        m_rgLockArray[dwOffset%GROUP_LOCK_ARRAY_SIZE].ExclusiveLock();
    }

    TraceFunctLeave();
    return dwOffset;
}

void
CFixPropPersist::ExclusiveUnlock( DWORD dwOffset )
/*++
Routine description:

    Unlock the write access to the offset in group.lst

Arguments:

    dwOffset - The offset to unlock

Return value:

    None
--*/
{
    TraceFunctEnter( "CFixPropPersist::ExclusiveUnlock" );
    _ASSERT( 0xffffffff != dwOffset );

    m_rgLockArray[dwOffset%GROUP_LOCK_ARRAY_SIZE].ExclusiveUnlock();
    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\fixprop\utest\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\fixprop\utest\main.cpp ===
#include "stdinc.h"
#include <conio.h>

//#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include <atlimpl.cpp>

#define __TESTFF_CPP__
#include <fixprop.h>

GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName = NULL;
HANDLE  g_hProcessImpersonationToken = NULL;

#define	KEY_STORAGEFILE	"StorageFileName"
#define KEY_MAXBLOCKS	"MaxBlocks"
#define KEY_GROUPNAME	"GroupName"
#define KEY_NAMELEN		"GroupNameLen"
#define KEY_LOWMARK		"LowWaterMark"
#define KEY_HIGHMARK	"HighWaterMark"
#define KEY_ARTICLECOUNT "ArticleCount"
#define KEY_GROUPID		"GroupId"
#define KEY_CREATELOW	"CreateLow"
#define KEY_CREATEHIGH 	"CreateHigh"
#define KEY_ISSPECIAL	"IsSpecial"
#define KEY_READONLY	"ReadOnly"
#define KEY_LOOP		"Loop"

#define PROGID_NO_DRIVER L"TestNT.NoDriver"
#define VRPATH L""

CHAR g_szStorageFile[MAX_PATH+1];
LPSTR g_lpstrSectionName = "testfix";
DWORD g_dwHandlePoolSize = 0xffffffff;
DWORD g_dwMaxBlocks = 0;
DWORD g_dwLoop = 0;
WCHAR g_wszMBPath[MAX_PATH+1];
CHAR g_szMBPath[MAX_PATH+1];
CHAR g_szGroupList[1024];
CHAR g_szVarGroupList[1024];

NNTPVROOTPTR g_pvroot;
CNNTPVRootTable *g_pVRTable;
CNewsTreeCore *g_pNewsTree;
// global count of errors
LONG g_cErrors;

void Verify(BOOL fTest, const char *szError, const char *szContext, DWORD dwLine) {
	if (fTest) return;
	InterlockedIncrement(&g_cErrors);
	printf("ERROR: line %i -- %s (%s)\n", dwLine, szError, szContext);
	_ASSERT(FALSE);
}


#define V(__f__, __szError__, __szContext__) Verify(__f__, __szError__, __szContext__, __LINE__)

void StartHintFunction( void )
{}

DWORD INNHash( PBYTE pb, DWORD )
{ return 0; }

BOOL fTestComponents( LPCSTR what )
{ return TRUE;
}

VOID
CopyUnicodeStringIntoAscii(
                IN LPSTR AsciiString,
                IN LPWSTR UnicodeString
            )
{
    while ( (*AsciiString++ = (CHAR)*UnicodeString++) != '\0');

} // CopyUnicodeStringIntoAscii

void Initialize(BOOL fDeleteGroupList) {
	HRESULT hr;
	BOOL fFatal;
	static IMSAdminBaseW *pMB;
	METADATA_HANDLE hmRoot;
	
	// initialize COM and the metabase
	printf("initializing metabase\n");
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	V(SUCCEEDED(hr), "CoInitializeEx", NULL);

	hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL, 
						  IID_IMSAdminBase_W, (LPVOID *) &pMB);
	V(hr == S_OK, "CoCreateInstance", NULL);

	// create a vroot entry for the root.  we don't have any other 
	// vroot entries
	printf("creating virtual root hierarchy\n");
	hr = pMB->OpenKey(METADATA_MASTER_ROOT_HANDLE, 
				      L"", 
				      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				      100,
				      &hmRoot);
	V(hr == S_OK, "metabase OpenKey(root)", NULL);

	// first we delete whatever exists in the metabase under this path,
	// then we create a new area to play in
	pMB->DeleteKey(hmRoot, g_wszMBPath);
	printf("creating key %s\n", g_wszMBPath);
	hr = pMB->AddKey(hmRoot, g_wszMBPath);
	V(hr == S_OK, "AddKey failed", g_szMBPath);
	// we configure one root vroot with parameters set to create no driver
	METADATA_RECORD mdrProgID = { 
		MD_VR_DRIVER_PROGID, 
		METADATA_INHERIT, 
		ALL_METADATA, 
		STRING_METADATA, 
		(lstrlenW(PROGID_NO_DRIVER)+1) * sizeof(WCHAR), 
		(BYTE *) PROGID_NO_DRIVER, 
		0 
	};
	printf("setting MD_VR_DRIVER_PROGID = \"%S\"\n", PROGID_NO_DRIVER);
	hr = pMB->SetData(hmRoot, g_wszMBPath, &mdrProgID);
	V(hr == S_OK, "SetData(MD_VR_DRIVER_PROGID) failed", g_szMBPath);

	METADATA_RECORD mdrVRPath = { 
		MD_VR_PATH, 
		METADATA_INHERIT, 
		ALL_METADATA, 
		STRING_METADATA, 
		(lstrlenW(VRPATH)+1) * sizeof(WCHAR), 
		(BYTE *) VRPATH, 
		0 
	};
	printf("setting MD_VR_PATH = \"%S\"\n", VRPATH);
	hr = pMB->SetData(hmRoot, g_wszMBPath, &mdrVRPath);
	V(hr == S_OK, "SetData(MD_VR_PATH) failed", g_szMBPath);

	pMB->CloseKey(hmRoot);
	pMB->Release();

	// initialize our news tree
	printf("initializing newstree object\n");
	g_pNewsTree = new CNewsTreeCore();
	g_pVRTable = new CNNTPVRootTable(g_pNewsTree->GetINewsTree(), 
						CNewsTreeCore::VRootRescanCallback);
	g_pNewsTree->Init(g_pVRTable, fFatal, 100, TRUE);

	// initialize the vroot table
	printf("initializing vroot table\n");
	hr = g_pVRTable->Initialize(g_szMBPath);
	printf("g_pVRTable->Initialize(\"%s\") returned %x\n", g_szMBPath, hr);
	V(hr == S_OK, "g_pVRTable->Initialize() failed", g_szMBPath);

	// load the newstree from disk
	// figure out a group.lst filename
	GetEnvironmentVariable("temp", g_szGroupList, 1024);
	lstrcat(g_szGroupList, "\\group.lst");
	printf("using group.lst path %s\n", g_szGroupList);
	if (fDeleteGroupList) DeleteFile(g_szGroupList);
	GetEnvironmentVariable("temp", g_szVarGroupList, 1024);
	lstrcat(g_szVarGroupList, "\\groupvar.lst");
	printf("using groupvar.lst path %s\n", g_szVarGroupList);
	if (fDeleteGroupList) DeleteFile(g_szVarGroupList);
	//g_pNewsTree->LoadTree(g_szGroupList, g_szVarGroupList);	
}



#ifdef DEBUG
BOOL EnumCallback( DATA_BLOCK& dbBuffer, PVOID pvContext, DWORD dw, BOOL b )
{
	printf ( "****************************\n" );
	printf ( "Enumerated: \n" );
	printf ( "Group name: %s\n", dbBuffer.szGroupName );
	printf ( "Group name len: %d\n", dbBuffer.dwGroupNameLen );
	printf ( "blah, blah ...\n" );

	return TRUE;
}

VOID ReadINI( LPSTR szINIFile )
{
	DWORD 	dw;
	CHAR	szFileName[MAX_PATH+1];
	CHAR	szTempPath[MAX_PATH+1];	

	// retrieve storage file name
	dw = GetPrivateProfileString(	g_lpstrSectionName,
									KEY_STORAGEFILE,
									"default",
									szFileName,
									MAX_PATH,
									szINIFile );
	_ASSERT( dw > 0 );

	// we'll always automatically put the file under temp dir
	dw = GetTempPath( MAX_PATH, szTempPath );
	_ASSERT( dw > 0 );
	sprintf( g_szStorageFile, "%s%s", szTempPath, szFileName );

	// read max blocks to expand to
	g_dwMaxBlocks = GetPrivateProfileInt( 	g_lpstrSectionName,
											KEY_MAXBLOCKS,
											64,
											szINIFile );
	_ASSERT( g_dwMaxBlocks > 0 );		

	// read loop number
	g_dwLoop = GetPrivateProfileInt( 	g_lpstrSectionName,
										KEY_LOOP,
										0,
										szINIFile );
	_ASSERT( g_dwLoop >= 0 );
}

VOID LoadProperty( CNewsGroupCore *pGroup, LPSTR szINIFile, LPSTR szSectionName )
{
	DWORD	dwBuffer=0xffffffff;
	CHAR	szGroupName[MAX_PATH+1];
	DWORD	dwLen = 0;
	FILETIME ft;

	// Load group name, group len is also set 
	dwBuffer = GetPrivateProfileString(	szSectionName,
										KEY_GROUPNAME,
										"microsoft.public.ins",
										szGroupName,
										MAX_PATH,
										szINIFile );

	dwBuffer = 0xffffffff;
	dwBuffer = GetPrivateProfileInt( 	szSectionName,
										KEY_GROUPID,
										0,
										szINIFile );
	_ASSERT( 0xffffffff != dwBuffer );

	pGroup->Init( 	szGroupName,
					NULL,
					dwBuffer,
					g_pvroot );
						
	dwBuffer = 0xffffffff;
	dwBuffer = GetPrivateProfileInt(	szSectionName,
										KEY_LOWMARK,
										0,
										szINIFile );
	_ASSERT( 0xffffffff != dwBuffer );

	pGroup->SetLowWatermark( dwBuffer );

	dwBuffer = 0xffffffff;
	dwBuffer = GetPrivateProfileInt(	szSectionName,
										KEY_HIGHMARK,
										0,
										szINIFile );
	_ASSERT( 0xffffffff != dwBuffer );

	pGroup->SetHighWatermark( dwBuffer );
	
	dwBuffer = 0xffffffff;
	dwBuffer = GetPrivateProfileInt(	szSectionName,
										KEY_ARTICLECOUNT,
										0,
										szINIFile );
	_ASSERT( 0xffffffff != dwBuffer );

	pGroup->SetMessageCount( dwBuffer );
	
	dwBuffer = 0xffffffff;
	dwBuffer = GetPrivateProfileInt(	szSectionName,
										KEY_CREATELOW,
										0,
										szINIFile );
	_ASSERT( 0xffffffff != dwBuffer );

	ft.dwLowDateTime = dwBuffer;

	dwBuffer = 0xffffffff;
	dwBuffer = GetPrivateProfileInt(	szSectionName,
										KEY_CREATEHIGH,
										0,
										szINIFile );
	_ASSERT( 0xffffffff != dwBuffer );

	ft.dwHighDateTime = dwBuffer;

	pGroup->SetCreateDate( ft );
	
	dwBuffer = 0xffffffff;
	dwBuffer = GetPrivateProfileInt(	szSectionName,
										KEY_ISSPECIAL,
										0,
										szINIFile );
//        _ASSERT( SUCCEEDED( hr ) );

	pGroup->SetSpecial( ( dwBuffer != 0 ) );
	
	dwBuffer = 0xffffffff;
	dwBuffer = GetPrivateProfileInt(	szSectionName,
										KEY_READONLY,
										0,
										szINIFile );
	_ASSERT( 0xffffffff != dwBuffer );

	pGroup->SetReadOnly( (dwBuffer != 0 ) );
}

VOID TestAdd( INNTPPropertyBag *pPropBag, CFixPropPersist& store )
{
	DWORD i;
	
	for ( i = 0; i < g_dwMaxBlocks; i++ ) {
		if ( !store.AddGroup( pPropBag ) ) {
			printf ( "Adding group fail %d\n", GetLastError() );
			exit( 1 );
		}
	}
}

VOID TestDelete( INNTPPropertyBag *pPropBag, CFixPropPersist& store )
{
	DWORD i;

	for ( i = 0; i < g_dwMaxBlocks; i++ ) {
		if ( !store.RemoveGroup( pPropBag ) ) {
			printf ( "Removing group fail %d\n", GetLastError() );
			exit( 1 );
		}
	}
}

VOID TestSet( INNTPPropertyBag *pPropBag, CFixPropPersist& store, DWORD dwFlag )
{

    if ( !store.SetGroup( pPropBag, dwFlag ) ) {
	    printf ( "Setting group fail %d\n", GetLastError() );
        exit( 1 );
   }
}

VOID TestGet( INNTPPropertyBag *pPropBag, CFixPropPersist& store, DWORD dwFlag )
{
	if( !store.GetGroup( pPropBag, dwFlag ) ) {
		printf ( "Getting group fail %d\n", GetLastError() );
		exit( 1 );
	}
}
#endif

void Shutdown() {
	g_pNewsTree->StopTree();
	//g_pNewsTree->TermTree();
	delete g_pVRTable;
	delete g_pNewsTree;
}

int __cdecl main( int argc, char **argv )
{
#ifdef DEBUG
	DWORD i;
	CNewsGroupCore *pGroup1, *pGroup2;
	INNTPPropertyBag *pPropBag1, *pPropBag2;
	DWORD	dwIdHigh = 0;

	InitAsyncTrace();

    // 
    // Initialize global heap
    //
    ExchMHeapCreate( NUM_EXCHMEM_HEAPS, 0, 100 * 1024, 0 ) ;


	if ( argc != 3 ) {
		printf( "[usage] testfix *.ini section\n" );
		goto FailExit;
	}

	printf( "CFixPropPersist unit test is starting ...\n" );

	// Read ini file parameters
	ReadINI( argv[1] );
	strcpy( g_szMBPath, "LM/testfix" );
	lstrcpyW( g_wszMBPath, L"LM/testfix" );

	CVRootTable::GlobalInitialize();

	_Module.Init(NULL, (HINSTANCE) INVALID_HANDLE_VALUE);

	Initialize( TRUE );

	g_pNewsTree = new CNewsTreeCore;
	if ( !g_pNewsTree ) {
		printf ( "Out of memory\n" );
        ExchMHeapDestroy();
		exit( 1 );
	}

	g_pvroot = new CNNTPVRoot;
	if ( !g_pvroot ) {
		printf ( "Out of memory\n" );
        ExchMHeapDestroy();
		exit( 1 );
	}

    g_pvroot->Init( NULL, "name", (CVRootTable*)g_pVRTable, L"name" );

	for ( i = 0; i < g_dwLoop; i++ ) {

		// If the file already exists, delete it
		DeleteFile( g_szStorageFile );

		// Initialize the store
		CFixPropPersist store( g_szStorageFile);
		printf( "Init handle %d\n", g_dwHandlePoolSize );
		if( !store.Init( 	TRUE, NULL, &dwIdHigh, EnumCallback )) {
			printf( "Store initialization failed with %d\n", GetLastError() );
			goto FailExit;		
		}

		pGroup1 = new CNewsGroupCore( g_pNewsTree ); // no newstree
		if ( NULL == pGroup1 ) {
			printf ( "Create group core instance fail %d\n", GetLastError() );
			goto FailExit;
		}

		LoadProperty( pGroup1, argv[1], "samplegroup" );

		pPropBag1 = pGroup1->GetPropertyBag();
		if ( NULL == pPropBag1 ) {
			printf  ( "Get property bag fail %d\n", GetLastError() );
			goto FailExit;
		}
	
		// Test adding groups with the same name
		TestAdd( pPropBag1, store );
	
		// Test remove all those groups by name
		pGroup2 = new CNewsGroupCore( g_pNewsTree ); 
		if ( NULL == pGroup2 ) {
			printf ( "Create group core fail %d\n", GetLastError() );
			goto FailExit;
		}

		pGroup2->Init( pGroup1->GetName(), NULL, pGroup1->GetGroupId(),
						g_pvroot );

		pPropBag2 = pGroup2->GetPropertyBag();
		if ( NULL == pPropBag2 ) {
			printf ("Get property bag fail %d\n", GetLastError() );
			goto FailExit;
		}
		
		TestDelete( pPropBag2, store );

		// Add one more group into it, after which there should be only
		// one group
		if ( !store.AddGroup( pPropBag1 ) ) {
			printf ( "Add group fail %d\n", GetLastError() );
			goto FailExit;
		}

		// Set this group with another bag
		LoadProperty( pGroup2, argv[1], "samplegroup2" );
		if ( !store.SetGroup( pPropBag2, ALL_BUT_NAME_AND_LEN ) ) {
			printf ( "Set group fail %d\n", GetLastError() );
			goto FailExit;
		}

		pPropBag1->Release();
		pPropBag2->Release();
		//if ( pGroup1 ) delete pGroup1;
		//if ( pGroup2 ) delete pGroup2;

		if ( !store.Term() ) {
			printf ( "Store termination failed with %d\n", GetLastError() );
			goto FailExit;
		}
	} // for

	_Module.Term();

	Shutdown();

    delete g_pvroot;
    ExchMHeapDestroy();
	TermAsyncTrace();
	return 0;

FailExit:

    delete g_pvroot;
    ExchMHeapDestroy();
	TermAsyncTrace();
	return -1;
	
#else
	printf("This test doesn't work in retail builds\n");
	return -1;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\fixprop\utest\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
};
#endif

#include <atlbase.h>
#include <malloc.h>
#include <nntptype.h>
#include <nntps.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <nntpmeta.h>

#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"
#include "crchash.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include "nntpvr.h"
#include "group.h"
#include "nwstree.h"
#include "nntpbag.h"
#include <xmemwrpr.h>

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\flatfile\utest\testff.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "dbgtrace.h"
#include "flatfile.h"
#include <tflist.h>
#include <xmemwrpr.h>

CFlatFile *g_pFF;
DWORD g_iRecordToDelete;
char g_szDatafile[1024];
char g_szInputfile[1024];
DWORD g_cRecords = 0;

#define MAX_BUF_SIZE (MAX_RECORD_SIZE - 12)

class CRecord {
	public:
		// the next three items are saved in the flatfile for usj
		CRecord *m_pThis;
		DWORD m_cBuf;
		DWORD m_iRecord;
		BYTE m_pBuf[MAX_BUF_SIZE];

		DWORD m_iOffset;
		BOOL m_fDelete;

		CRecord *m_pNext, *m_pPrev;

		CRecord(DWORD cBuf = 0, BYTE *pBuf = NULL) {
			m_cBuf = cBuf;
			if (cBuf > 0) memcpy(m_pBuf, pBuf, cBuf);
			m_iRecord = g_cRecords++;
			m_fDelete = FALSE;
			m_iOffset = 0;
			m_pThis = this;
			m_pNext = NULL;
			m_pPrev = NULL;
		}

};

TFList<CRecord> g_listRecords(&CRecord::m_pPrev, &CRecord::m_pNext);

void InsertUpdate(void *pNull, BYTE *pData, DWORD cData, DWORD iNewOffset) {
	CRecord *pRec = *((CRecord **) pData);
	DWORD i;

	printf("  record %lu has offset %i", pRec->m_iRecord, iNewOffset);
	pRec->m_iOffset = iNewOffset;
	if (pRec->m_cBuf >= 3) {
		// see if the buffer contains "the"
		for (i = 0; i < pRec->m_cBuf - 2; i++) {
			if (pRec->m_pBuf[i]   == 't' && 
				pRec->m_pBuf[i+1] == 'h' &&
				pRec->m_pBuf[i+2] == 'e') 
			{
				pRec->m_fDelete = TRUE;
				break;
			} 
		}
	}
	if (pRec->m_fDelete) {
		printf(" (marked for deletion)\n");
	} else {
		printf("\n");
	}
}

void ParseINIFile(char *pszINIFile, char *pszSectionName) {
	char szDefault[1024];

	GetTempPath(1024, szDefault);
	lstrcat(szDefault, "flatfile");

	GetPrivateProfileString(pszSectionName,
							"DataFile",
							szDefault,
							g_szDatafile,
							1024,
							pszINIFile);

	GetEnvironmentVariable("systemroot", szDefault, 1024);
	lstrcat(szDefault, "\\system32\\cmd.exe");

	GetPrivateProfileString(pszSectionName,
							"InputFile",
							szDefault,
							g_szInputfile,
							1024,
							pszINIFile);
}

void ReadInputFile(char *szFilename) {
	HANDLE hFile;

    hFile = CreateFile(szFilename, GENERIC_READ ,
                       FILE_SHARE_READ, NULL, OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("fatal: Could not open input file %s, gle = %lu\n", szFilename,
			GetLastError());
		exit(-1);
	}

	DWORD cToRead, cBuf;
	BYTE pBuf[MAX_BUF_SIZE];
	srand(GetTickCount());

	do {
		cToRead = (rand() % (MAX_BUF_SIZE - 1)) + 1;
		if (!ReadFile(hFile, pBuf, cToRead, &cBuf, NULL)) {
			printf("fatal: ReadFile failed with %lu\n", GetLastError());
			exit(-1);
		}

		if (cBuf > 0) {
			CRecord *pRecord = new CRecord(cBuf, pBuf);
			if (pRecord == NULL) {
				printf("fatal: not enough memory\n");
				exit(-1);
			}
			printf("  read record #%i of %lu bytes from %s\n", 
				pRecord->m_iRecord,
				pRecord->m_cBuf, 
				szFilename);
			g_listRecords.PushBack(pRecord);
		}
	} while (cBuf > 0);

	CloseHandle(hFile);
}

int __cdecl main(int argc, char **argv) {
	DWORD c;
	HRESULT hr;
	char *szINIFile;
	char szDefaultINISection[] = "testff", *szINISection = szDefaultINISection;

	if (argc < 2 || *(argv[1]) == '/') {
		printf("usage: testff <INI File> [<INI Section>]\n");
		printf("INI File parameters:\n");
		printf("  DataFile - flatfile base name to use for test.  Default is\n");
		printf("             %TEMP%\flatfile\n");
		printf("  InputFile - any file\n");
		printf("What it does:\n");
		printf("  This test builds up a flatfile with records corresponding\n");
		printf("  to blocks found in the input file.  It then deletes all\n");
		printf("  records from the flatfile that contain the word \"the\"\n");
		printf("  and enumerates the flatfile verifying that they were correctly deleted\n");
		return -1;
	} 

	_VERIFY( CreateGlobalHeap( 0, 0, 0, 0 ) );

	szINIFile = argv[1];
	if (argc > 2) szINISection = argv[2];

	ParseINIFile(szINIFile, szDefaultINISection);

	printf("-- reading from %s\n", g_szInputfile);
	ReadInputFile(g_szInputfile);

	printf("-- creating flatfile\n");
	g_pFF = new CFlatFile(g_szDatafile, ".dat", NULL, InsertUpdate);
	if (g_pFF == NULL) exit(-1);
	g_pFF->EnableWriteBuffer( 4096 );

	printf("-- emptying the file\n");
	g_pFF->DeleteAll();

	printf("-- inserting records\n");
	TFList<CRecord>::Iterator it(&g_listRecords);
	while (!it.AtEnd()) {
		CRecord *pRec = it.Current();
		hr = g_pFF->InsertRecord((BYTE *) pRec, pRec->m_cBuf + 12);
		if (FAILED(hr)) printf("-- InsertRecord returned 0x%x\n", hr);
		it.Next();
	}

	printf("-- deleting records containing the string \"the\"\n");
	it.Front();
	while (!it.AtEnd()) {
		CRecord *pRec = it.Current();
		_ASSERT(pRec->m_iOffset != 0);
		if (pRec->m_fDelete) {
			printf("deleting record %i at offset %i\n", 
				pRec->m_iRecord,
				pRec->m_iOffset);
			hr = g_pFF->DeleteRecord(pRec->m_iOffset);
			if (FAILED(hr)) printf("-- DeleteRecord returned 0x%x\n", hr);
		}
		it.Next();
	}	
	if (FAILED(hr)) printf("-- DeleteRecord return 0x%x\n", hr);

	printf("-- verifying that deleted records were properly deleted\n");
	CRecord rec;
	c = sizeof(CRecord);
	hr = g_pFF->GetFirstRecord((BYTE *) &rec, &c);
	it.Front();
	while (hr == S_OK) {
		CRecord *pCurrentInFile = rec.m_pThis;
		// skip deleted records
		while (it.Current()->m_fDelete) it.Next();
		CRecord *pCurrentInList = it.Current();
		printf("  current record: file = %i  list = %i\n", pCurrentInFile->m_iRecord, pCurrentInList->m_iRecord);
		_ASSERT(pCurrentInFile == pCurrentInList);

		c = sizeof(CRecord);
		hr = g_pFF->GetNextRecord((BYTE *) &rec, &c);
		it.Next();
	}
	if (FAILED(hr)) printf("-- GetFirstRecord/GetNextRecord returned 0x%x\n", hr);

	printf("-- compacting file\n");
	hr = g_pFF->Compact();
	if (FAILED(hr)) printf("-- Compact return 0x%x\n", hr);

	printf("-- verifying file after compact\n");
	c = sizeof(CRecord);
	hr = g_pFF->GetFirstRecord((BYTE *) &rec, &c);
	it.Front();
	while (hr == S_OK) {
		CRecord *pCurrentInFile = rec.m_pThis;
		// skip deleted records
		while (it.Current()->m_fDelete) it.Next();
		CRecord *pCurrentInList = it.Current();
		printf("  current record: file = %i  list = %i\n", pCurrentInFile->m_iRecord, pCurrentInList->m_iRecord);
		_ASSERT(pCurrentInFile == pCurrentInList);

		c = sizeof(CRecord);
		hr = g_pFF->GetNextRecord((BYTE *) &rec, &c);
		it.Next();
	}
	if (FAILED(hr)) printf("-- GetFirstRecord/GetNextRecord returned 0x%x\n", hr);

	// clean up the list
	while (!g_listRecords.IsEmpty()) {
		delete(g_listRecords.PopFront());
	}

	DestroyGlobalHeap();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\flatfile\src\flatfile.cpp ===
#include <windows.h>
#include <randfail.h>
#include <stdlib.h>
#include <string.h>
#include <search.h>
#include "abtype.h"
#include "dbgtrace.h"
#include "writebuf.h"
#include "flatfile.h"

//
// the constructor needs to save the filename into the objects memory, reset
// the variables used for buffered reading, and initialize the hash function
//

#pragma warning(disable:4355)

CFlatFile::CFlatFile(LPSTR szFilename,
					 LPSTR szExtension,
					 void *pContext,
					 PFN_OFFSET_UPDATE pfnOffsetUpdate,
					 DWORD dwSignature,
                     BOOL fClear,
					 DWORD dwFileFlags) : m_wbBuffer( this )
{
    TraceQuietEnter("CFlatFile::CFlatFile");

	_ASSERT(pfnOffsetUpdate != NULL);

    lstrcpy(m_szFilename, szFilename);
    lstrcat(m_szFilename, szExtension);
    lstrcpy(m_szBaseFilename, szFilename);

    m_cBuffer = 0;
    m_iBuffer = 0;
    m_iFile = sizeof(FLATFILE_HEADER);
    m_fClearOnOpen = fClear;
    m_dwFileFlags = dwFileFlags;
    m_cRecords = 0;
    m_cDeletedRecords = 0;
	m_hFile = INVALID_HANDLE_VALUE;
	m_pfnOffsetUpdate = pfnOffsetUpdate;
	m_dwSignature = dwSignature;
	m_pContext = pContext;
	m_fOpen = FALSE;
}

//
// free any allocated memory
//
CFlatFile::~CFlatFile(void) {
    TraceQuietEnter("CFlatFile::~CFlatFile");

	CloseFile();

}

//
// Enable the write buffer
//
VOID
CFlatFile::EnableWriteBuffer( DWORD cbBuffer )
{
    m_wbBuffer.Enable( cbBuffer );
}

//
// Check to see if the file has been opened
//
BOOL
CFlatFile::IsFileOpened()
{
    return m_fOpen;
}

//
// open a file.  assumes the lock is already held by the caller
//
HRESULT CFlatFile::OpenFile(LPSTR szFilename, DWORD dwOpenMode, DWORD dwFlags) {
    TraceFunctEnter("CFlatFile::OpenFile");

    LPSTR szFn = (szFilename == NULL) ? m_szFilename : szFilename;
    BOOL fDLFile = (lstrcmp(m_szFilename, szFn) == 0);
    FLATFILE_HEADER header;
	HRESULT hr;

    DebugTrace((DWORD_PTR) this, "OpenFile(%s, %lu, %lu)", szFilename, dwOpenMode, dwFlags);

	if (m_hFile != INVALID_HANDLE_VALUE) ret(S_OK);

    if (m_fClearOnOpen) {
    	dwOpenMode = CREATE_ALWAYS;
        m_fClearOnOpen = FALSE;
    }
    dwFlags |= m_dwFileFlags;

    SetLastError(NO_ERROR);

    m_hFile = CreateFile(szFn, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ, NULL, dwOpenMode,
                       FILE_ATTRIBUTE_NORMAL | dwFlags, NULL);
    if (m_hFile == INVALID_HANDLE_VALUE) {
        ErrorTrace((DWORD_PTR) this, "Couldn't open file %s, ec = 0x%08X\n", szFn, GetLastError());
		ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    _ASSERT(GetLastError() != ERROR_FILE_EXISTS);

    // see if we need to put a header record (if this is a new file)
    if (FAILED(GetFileHeader(&header))) {
        header.dwFlags = 0;
        header.dwSignature = m_dwSignature;
		hr = SetFileHeader(&header);
		if (FAILED(hr)) {
			DebugTrace((DWORD_PTR) this, "SetFileHandle failed with 0x%x", hr);
			ret(hr);
		}
    }

	if (header.dwSignature != m_dwSignature) {
		CloseFile();
		ret(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	}

    m_fOpen = TRUE;
    TraceFunctLeave();
    ret(S_OK);
}

void CFlatFile::CloseFile() {
    if ( m_wbBuffer.NeedFlush() ) m_wbBuffer.FlushFile();
	if (m_hFile != INVALID_HANDLE_VALUE) {
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
	m_fOpen = FALSE;
}

//
// add a new record to the current file
//
HRESULT CFlatFile::InsertRecord(LPBYTE pData, DWORD cData, DWORD *piOffset, DWORD dwVer ) {
    RECORD rec;
    DWORD cRec;
	HRESULT hr;

    TraceQuietEnter("CFlatFile::InsertRecord");

    // DebugTrace((DWORD_PTR) this, "adding a new record");
    // BinaryTrace((DWORD_PTR) this, pData, cData);

    // build a record and write to the data file
    // (note that we could do this more efficently with two writes (one
    // with the header and one with the record data), but it wouldn't
    // be atomic, so we could end up with an invalid file more easily.)
    cRec = RECORD_HEADER_SIZE + cData;

    //
    // Set header values
    //
    rec.fDeleted = FALSE;
    rec.cData = cData;

    //
    // OK, I'll use the high 16 bit of cData to set the version number
    //
    dwVer <<= 16;
    rec.cData |= dwVer;

    //
    // Now do the copy
    //
    memcpy(rec.pData, pData, cData);
	DWORD iOffset;
	hr = WriteNBytesTo((LPBYTE) &rec, cRec, &iOffset);
	if (SUCCEEDED(hr)) {
		m_pfnOffsetUpdate(m_pContext, pData, cData, iOffset);
		m_cRecords++;
		if (piOffset != NULL) *piOffset = iOffset;
	}
	ret(hr);
}

//
// mark a record for deletion given its offset (returned from GetNextRecord)
//
// assumes that the file lock is held
//
HRESULT CFlatFile::DeleteRecord(DWORD iOffset) {
    TraceQuietEnter("CFlatFile::DeleteRecord");

    RECORDHDR rec;
	HRESULT hr;

    //
    // read the record header
    //
    hr = ReadNBytesFrom((PBYTE) &rec, sizeof(rec), iOffset);
    if (FAILED(hr)) {
        ErrorTrace((DWORD_PTR) this, "Couldn't read record header, hr = 0x%08X", hr);
        ret(hr);
    }

    //
    // write out the header with the delete flat set
    //
    rec.fDeleted = TRUE;
    hr = WriteNBytesTo((PBYTE) &rec, sizeof(rec), NULL, iOffset);
	if (SUCCEEDED(hr)) m_cDeletedRecords++;
	ret(hr);
}

//
// update the file header
//
HRESULT CFlatFile::SetFileHeader(FLATFILE_HEADER *pHeader) {
    TraceQuietEnter("CFlatFile::SetFileHeader");

    ret(WriteNBytesTo((PBYTE) pHeader, sizeof(FLATFILE_HEADER), NULL, 0));
}

//
// read the file header
//
HRESULT CFlatFile::GetFileHeader(FLATFILE_HEADER *pHeader) {
    TraceQuietEnter("CFlatFile::GetFileHeader");

    ret(ReadNBytesFrom((PBYTE) pHeader, sizeof(FLATFILE_HEADER), 0));
}

//
// Dirty the integrity flag: we reuse the high 16bit of the flatfile's header
// flag.
//
HRESULT CFlatFile::DirtyIntegrityFlag()
{
    TraceQuietEnter( "CFlatFile::DirtyIntegrityFlag" );

    FLATFILE_HEADER ffHeader;
    HRESULT         hr = S_OK;

    //
    // Read the header first
    //
    hr = GetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Read header from flatfile failed %x", hr );
        return hr;
    }

    //
    // Now set the bad flag to the header
    //
    ffHeader.dwFlags |= FF_FILE_BAD;

    //
    // And set it back
    //
    hr = SetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set header into flatfile failed %x", hr );
        return hr;
    }

    return hr;
}

//
// Set the integrity flag, to indicate that the file is good.
//
HRESULT CFlatFile::SetIntegrityFlag()
{
    TraceQuietEnter( "CFlatFile::SetIntegrityFlag" );

    FLATFILE_HEADER ffHeader;
    HRESULT         hr = S_OK;

    //
    // Read the header first
    //
    hr = GetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Read header from flatfile failed %x", hr );
        return hr;
    }

    //
    // Now set the good flag to the header
    //
    ffHeader.dwFlags &= FF_FILE_GOOD;

    //
    // Set it back
    //
    hr = SetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set file header failed %x", hr );
        return hr;
    }

    return hr;
}

//
// Ask the flat file whether the file is in good integrity ?
//
BOOL
CFlatFile::FileInGoodShape()
{
    TraceQuietEnter( "CFlatFile::FileInGoodShape" );

    FLATFILE_HEADER ffHeader;
    HRESULT         hr = S_OK;
    DWORD           dwFlag;

    //
    // Read the header first, if read failed, the file is not
    // in good shape
    //
    hr = GetFileHeader( &ffHeader );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Header can not be read from flatfile %x", hr );
        return FALSE;
    }

    //
    // Now test the flag
    //
    dwFlag = ffHeader.dwFlags & FF_FILE_BAD;

    return 0 == dwFlag;
}

//
// get the first record from the file.
//
// arguments:
// 	pData - the data from the record
//  cData [in] - the size of pData
//  cData [out] - the amount of data put into pData
//  piByteOffset - the offset of this record in the file
// returns:
//  S_OK - retreived record
//  S_FALSE - end of file
//  else - error
//
HRESULT CFlatFile::GetFirstRecord(LPBYTE pData, DWORD *pcData, DWORD *piByteOffset, DWORD* pdwVer)
{
	HRESULT hr;

    TraceQuietEnter("CFlatFile::GetFirstRecord");

	// reset the read buffer
	m_cBuffer = 0;
	m_iBuffer = 0;

    // skip the file header
    m_iFile = sizeof(FLATFILE_HEADER);
    m_cRecords = 0;
    m_cDeletedRecords = 0;

    ret(GetNextRecord(pData, pcData, piByteOffset, pdwVer));
}

//
// get the next record from the file
//
// arguments are the same as GetFirstRecord()
//
HRESULT CFlatFile::GetNextRecord(LPBYTE pData, DWORD *pcData, DWORD *piByteOffset, DWORD* pdwVer) {
    RECORDHDR rec;
	HRESULT hr;
	DWORD   dwMaskLength = 0x0000FFFF;
	DWORD   dwMaskVer = 0xFFFF0000;
	DWORD   cRec;

    TraceQuietEnter("CFlatFile::GetNextRecord");

    //
    // look for the next undeleted record
    //
    do {
        if (piByteOffset != NULL) *piByteOffset = m_iFile + m_iBuffer;

        hr = ReadNextNBytes((LPBYTE) &rec, RECORD_HEADER_SIZE);
		if (hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF)) {
			ret(S_FALSE);
		} else if (FAILED(hr)) {
			ret(hr);
		}

        m_cRecords++;
        cRec = rec.cData & dwMaskLength;
        if (rec.fDeleted) {
            // DebugTrace((DWORD_PTR) this, "skipping deleted record");
            //
            // seek ahead of this record
            //
            m_iBuffer += cRec;
            m_cDeletedRecords++;
        } else {
            if (*pcData < cRec) {
				// BUGBUG - we'll skip the record if the user doesn't have
				// space
				_ASSERT(m_iBuffer >= sizeof(RECORDHDR));
                m_iBuffer -= sizeof(RECORDHDR);
				ret(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
            } else {

                //
                // Chop off the real data length
                //
                *pcData = cRec;

                //
                // Chop off the version number, if needed
                //
                if ( pdwVer )
                    *pdwVer = ( rec.cData & dwMaskVer ) >> 16;

                //
                // Get the actual record
                //
				hr = ReadNextNBytes(pData, *pcData);
                if (FAILED(hr)) {
                    _ASSERT(FALSE);
                    DebugTrace((DWORD_PTR) this, "file corrupt");
                    ret(hr);
                }
            }
        }
    } while (rec.fDeleted);

    ret(S_OK);
}

//
// read N bytes starting at an offset
//
// if pcDidRead is NULL then its an error to not read cData bytes, otherwise
// pcDidRead will have the number of bytes read
//
HRESULT CFlatFile::ReadNBytesFrom(LPBYTE pData,
								  DWORD cData,
								  DWORD iOffset,
								  DWORD *pcDidRead)
{
    TraceQuietEnter("CFlatFile::ReadNBytesFrom");

    DWORD cDidRead;
	HRESULT hr;

    // open the file
	if (m_hFile == INVALID_HANDLE_VALUE) {
	    hr = OpenFile();
		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR) this, "OpenFile() failed with 0x%x", hr);
			ret(hr);
		}
	}

	// If the write buffer needs flush, flush it
	if ( m_wbBuffer.NeedFlush() ) {
	    hr = m_wbBuffer.FlushFile();
	    if ( FAILED( hr ) ) {
	        ErrorTrace( 0, "FlusFile in ReadNBytesFrom failed %x", hr );
	        ret( hr );
	    }
	}

    // seek to the proper offset in the file
    if (SetFilePointer(m_hFile, iOffset, NULL, FILE_BEGIN) == 0xffffffff) {
		ErrorTrace((DWORD_PTR) this, "SetFilePointer failed, ec = %lu", GetLastError());
        ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    // read the next chunk from it
    if (!ReadFile(m_hFile, pData, cData, &cDidRead, NULL)) {
		ErrorTrace((DWORD_PTR) this, "ReadFile failed, ec = %lu", GetLastError());
        ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    if (pcDidRead == NULL) {
        ret((cData == cDidRead) ? S_OK : HRESULT_FROM_WIN32(ERROR_HANDLE_EOF));
    } else {
        *pcDidRead = cDidRead;
        ret(S_OK);
    }
}

//
// write N bytes starting at an offset
//
// if pcDidWrite is NULL then its an error to not written cData bytes,
// otherwise pcDidWrite will have the number of bytes writte
//
HRESULT CFlatFile::WriteNBytesTo(
                        LPBYTE pData,
                        DWORD cData,
                        DWORD *piOffset,
                        DWORD iOffset,
                        DWORD *pcDidWrite)
{
    return m_wbBuffer.WriteFileBuffer(
                    iOffset,
                    pData,
                    cData,
                    piOffset,
                    pcDidWrite );
}

//
// write N bytes starting at an offset
//
// if pcDidWrite is NULL then its an error to not written cData bytes,
// otherwise pcDidWrite will have the number of bytes writte
//
HRESULT CFlatFile::WriteNBytesToInternal(
                                 LPBYTE pData,
								 DWORD cData,
								 DWORD *piOffset,
                              	 DWORD iOffset,
								 DWORD *pcDidWrite)
{
    TraceQuietEnter("CFlatFile::WriteNBytesTo");

    DWORD cDidWrite;
	HRESULT hr;

    // open the file
	if (m_hFile == INVALID_HANDLE_VALUE) {
    	hr = OpenFile();
    	if (FAILED(hr)) ret(hr);
	}

    // seek to the proper offset in the file
    DWORD dwOffset;
    if (iOffset == INFINITE) {
        dwOffset = SetFilePointer(m_hFile, 0, NULL, FILE_END);
        if (piOffset != NULL) *piOffset = dwOffset;
    } else {
        dwOffset = SetFilePointer(m_hFile, iOffset, NULL, FILE_BEGIN);
        _ASSERT(piOffset == NULL);
    }
    if (dwOffset == 0xffffffff) {
		ErrorTrace((DWORD_PTR) this, "SetFilePointer failed, ec = %lu", GetLastError());
        ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    // write data to it
    if (!WriteFile(m_hFile, pData, cData, &cDidWrite, NULL)) {
		ErrorTrace((DWORD_PTR) this, "WriteFile failed, ec = %lu", GetLastError());
        ret(HRESULT_FROM_WIN32(GetLastError()));
    }

    if (pcDidWrite == NULL) {
        ret((cData == cDidWrite) ? S_OK : E_FAIL);
    } else {
        *pcDidWrite = cDidWrite;
        ret(S_OK);
    }
}

//
// Reload the read buffer
//
HRESULT
CFlatFile::ReloadReadBuffer()
{
    TraceQuietEnter( "CFlatFile::ReloadReadBuffer" );

    HRESULT hr = S_OK;

    m_cBuffer = 0;
    hr = ReadNBytesFrom( m_pBuffer, FF_BUFFER_SIZE, m_iFile, &m_cBuffer );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "ReadNBytesFrom in ReloadReadBuffer failed %x", hr );
        return hr;
    }

    if ( 0 == m_cBuffer ) {
        DebugTrace( 0, "Reaching end of file" );
        return HRESULT_FROM_WIN32( ERROR_HANDLE_EOF );
    }

    return S_OK;
}

//
// read the next chunk of the file into the temporary buffer
//
HRESULT CFlatFile::ReadNextNBytes(LPBYTE pData, DWORD cData) {
    TraceQuietEnter("CFlatFile::ReadNextNBytes");

    _ASSERT(cData < MAX_RECORD_SIZE);
	HRESULT hr;

    // DebugTrace((DWORD_PTR) this, "want %lu bytes of data", cData);

    //
    // If a read comes after writes, we'll flush anyway if write buffer
    // is enabled
    //
    if ( m_wbBuffer.NeedFlush() ) {
        hr = m_wbBuffer.FlushFile();
        if ( FAILED( hr ) ) {
            return hr;
        }

        if ( S_OK == hr ) {

            //
            // We need to reload the read buffer as well
            //

            hr = ReloadReadBuffer();
            if ( FAILED( hr ) ) {
                return hr;
            }
        }
    }

    // if they want to read more bytes then the buffer has remaining in
    // it then read into the buffer starting from the current location
    if (m_cBuffer > FF_BUFFER_SIZE ||
        m_iBuffer > m_cBuffer ||
        cData > (m_cBuffer - m_iBuffer))
    {
        m_iFile += m_iBuffer;
        hr = ReloadReadBuffer();
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "ReadLoadReadBuffer in ReadNextNBytes failed %x", hr );
            return hr;
        }
        m_iBuffer = 0;
    }

    // copy their data and return
    if (cData <= m_cBuffer - m_iBuffer) {
        memcpy(pData, m_pBuffer + m_iBuffer, cData);
        m_iBuffer += cData;
        ret(S_OK);
    } else {
		// this can only happen if cData > MAX_RECORD_SIZE
		_ASSERT(FALSE);
        ret(E_FAIL);
    }
}

//
// Make a new flatfile which doesn't have any space wasted due to deleted
// records.
//
// This is implemented by making a new file from scratch and copying
// undeleted records into the new file.  It would be possible to do this
// in place, but that wouldn't be as error-proof... the system could
// crash during the compaction and leave behind an invalid file.
//
HRESULT CFlatFile::Compact() {
    TraceQuietEnter("CFlatFile::Compact");

    BYTE pThisData[MAX_RECORD_SIZE];
    DWORD cThisData;
    char szNewFilename[FILENAME_MAX];
    char szBakFilename[FILENAME_MAX];
    CFlatFile newff(m_szBaseFilename,
                    NEW_FF_EXT,
                    m_pContext,
                    m_pfnOffsetUpdate,
                    FLATFILE_SIGNATURE,
                    TRUE,
                    FILE_FLAG_SEQUENTIAL_SCAN );

    FLATFILE_HEADER header;
	HRESULT hr;

    lstrcpy(szNewFilename, m_szBaseFilename);
    lstrcat(szNewFilename, NEW_FF_EXT);

    lstrcpy(szBakFilename, m_szBaseFilename);
    lstrcat(szBakFilename, BAK_FF_EXT);

    DebugTrace((DWORD_PTR) this, "Compacting flat file %s", m_szFilename);
    DebugTrace((DWORD_PTR) this, "szNewFilename = %s, szBakFilename = %s",
        szNewFilename, szBakFilename);

    //
    // Enable write buffer for the new header since I know that only
    // sequential writes will happen to this file
    //

    newff.EnableWriteBuffer( FF_BUFFER_SIZE );

    // write a file header (we need to make sure that the newff file
    // is actually created).
    header.dwFlags = 0;
    header.dwSignature = m_dwSignature;
	hr = newff.SetFileHeader(&header);
	if (FAILED(hr)) ret(hr);

    //
    // get each record from the current file and add it to the new one
    //
    cThisData = MAX_RECORD_SIZE;
	hr = GetFirstRecord(pThisData, &cThisData);
	DWORD cRecords = 0;
	while (hr == S_OK) {
		hr = newff.InsertRecord(pThisData, cThisData);
		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR) this, "out of disk space during compaction");
			newff.DeleteAll();
			ret(hr);		
		}

		cRecords++;

        cThisData = MAX_RECORD_SIZE;
		hr = GetNextRecord(pThisData, &cThisData);
	}

	m_cDeletedRecords = 0;
	m_cRecords = cRecords;

    //
    // before we move files around we need to make sure that we close
    // the current flatfile and new flatfile for sure.
    //
    CloseFile();
    newff.CloseFile();

    //
    // old -> bitbucket ; current -> old ; new -> current
    //
    DebugTrace((DWORD_PTR) this, "erasing %s", szBakFilename);
    if (DeleteFile(szBakFilename) || GetLastError() == ERROR_FILE_NOT_FOUND) {
        DebugTrace((DWORD_PTR) this, "moving %s to %s", m_szFilename, szBakFilename);
        if (MoveFile(m_szFilename, szBakFilename)) {
            DebugTrace((DWORD_PTR) this, "moving %s to %s", szNewFilename, m_szFilename);
            if (MoveFile(szNewFilename, m_szFilename)) {
                ret(S_OK);
            }
        }
    }

    newff.DeleteAll();

    ErrorTrace((DWORD_PTR) this, "Last operation failed, ec = %08X", GetLastError());
    _ASSERT(FALSE);
	ret(HRESULT_FROM_WIN32(GetLastError()));
}

//
// remove the flat file from disk (which removes all members)
//
void CFlatFile::DeleteAll(void) {
    TraceQuietEnter("CFlatFile::DeleteAll");

    CloseFile();
    DeleteFile(m_szFilename);

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\flatfile\src\writebuf.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    writebuf.cpp

Abstract:

    This module contains class declarations/definitions for

        CFlatFileWriteBuf
        
    **** Overview ****

    The write buffer that buffers up a batch of writes for flatfile.
    Using sequential scan is good for reads, but may not be sufficient
    for sequential writes.  This buffer is only enabled when data
    being written to the file is not critical ( meaning losing of data
    is OK if the system crashes ).
    
Author:

    Kangrong Yan    ( KangYan )     5-6-1999

Revision History:

--*/
#include <windows.h>
#include <xmemwrpr.h>
#include "writebuf.h"
#include "flatfile.h"

CFlatFileWriteBuf::CFlatFileWriteBuf( CFlatFile* pParentFile )
{
    m_pParentFile = pParentFile;
    m_pbBuffer = NULL;
    m_cbBuffer = 0;
    m_iStart = m_iEnd = 0;
}

CFlatFileWriteBuf::~CFlatFileWriteBuf()
{
    if ( m_pbBuffer )
        FreePv( m_pbBuffer );

    //
    // We must have been flushed
    //
    
    _ASSERT( m_iStart == m_iEnd );
}

VOID
CFlatFileWriteBuf::Enable( DWORD cbData )
{
    //
    // You cannot enable twice
    //

    _ASSERT( NULL == m_pbBuffer );
    _ASSERT( 0 == m_cbBuffer );
    _ASSERT( m_iStart == 0 );
    _ASSERT( m_iEnd == 0 );

    m_pbBuffer = (PBYTE)PvAlloc( cbData );
    if ( m_pbBuffer ) m_cbBuffer = cbData;
}

HRESULT
CFlatFileWriteBuf::WriteFileReal(
                    const DWORD dwOffset,
                    const PBYTE pbBuffer,
                    const DWORD cbBuffer,
                    PDWORD      pdwOffset,
                    PDWORD      pcbWritten
                    )
/*++
Routine description:

    Write the contents directly into the file

Arguments:

    dwOffset    - The offset into the flatfile where we want to write the bytes
    pbBuffer    - Pointer to the source buffer
    cbBuffer    - Number of bytes to be written
    pdwOffset   - If non-null, to return the real offset
    pcbWritten  - If non-null, to return bytes written

Return value:

    S_OK    - If succeeded
    Other error code otherwise
--*/
{
    TraceQuietEnter("CFlatFileWriteBuf::WriteFileReal");
    _ASSERT( pbBuffer );
    _ASSERT( m_pParentFile );

    HRESULT hr = S_OK;
    DWORD   dwOffsetWritten = dwOffset;

    //
    // Just let our parent handle it
    //
    hr = m_pParentFile->WriteNBytesToInternal(
                                 pbBuffer,
								 cbBuffer,
								 dwOffset == INFINITE ? &dwOffsetWritten : NULL,
                              	 dwOffset,
								 pcbWritten );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "WriteNBytesToInternal failed with 0x%x", hr );
    } else {

        //
        // We must have been flushed before directly writing to the file
        //

        _ASSERT( m_iStart == m_iEnd );

        //
        // Adjust m_iStart, m_iEnd to track offset
        //

        m_iStart = m_iEnd = dwOffsetWritten + cbBuffer;
        if ( pdwOffset ) *pdwOffset = dwOffsetWritten;
    }

    return hr;
}

//
// Compute the buffer available
//

DWORD
CFlatFileWriteBuf::BufferAvail() const
{
    return m_cbBuffer - ( m_iEnd - m_iStart );
}

BOOL
CFlatFileWriteBuf::NeedFlush( 
                    const DWORD dwOffset,
                    const DWORD cbData 
                    ) const
/*++
Routine description:

    Check to see if the request for writing ( dwOffset, cbData ) will
    cause the buffer to be flushed to file first

Arguments:

    dwOffset    - The offset in file we attempt to write to
    cbData      - The length of data we attempt to write to

Return value:

    TRUE if we do need to flush, FALSE otherwise
--*/
{
    if ( !NeedFlush() ) {

        //
        // If we are not enabled, or we are empty, no need to flush
        //

        return FALSE;
    }
    
    if (    dwOffset != INFINITE && dwOffset != m_iEnd || 
            BufferAvail() < cbData ) {

        //
        // If the offset we are writing to is not consecutive with
        // where we have written up to, or if the buffer remained is
        // too small, it must be flushed
        //

        return TRUE;
    }

    //
    // All other case, we don't need to flush
    //

    return FALSE;
}

BOOL
CFlatFileWriteBuf::NeedFlush() const
/*++
Routine description:

    Check to see if the request for writing ( dwOffset, cbData ) will
    cause the buffer to be flushed to file first

Arguments:

    dwOffset    - The offset in file we attempt to write to
    cbData      - The length of data we attempt to write to

Return value:

    TRUE if we do need to flush, FALSE otherwise
--*/
{
    if ( !IsEnabled() || m_iEnd == m_iStart ) {

        //
        // If we are not enabled, or we are empty, no need to flush
        //

        return FALSE;
    } else
        return TRUE;
}

HRESULT
CFlatFileWriteBuf::FlushFile()
/*++
Routine description:

    Flush the buffer into the file

Arguments:

    None.

Return value:

    S_OK if flushed, S_FALSE if no need to flush
    other error code if fatal
--*/
{
    TraceFunctEnter( "CFlatFileWriteBuf::FlushFile" );
    
    HRESULT     hr = S_OK;

    //
    // Let our parent handle it
    //
    
    _ASSERT( m_iEnd >= m_iStart );

    if ( m_iEnd > m_iStart ) {
        hr = m_pParentFile->WriteNBytesToInternal(
                                 m_pbBuffer,
								 m_iEnd - m_iStart,
								 NULL,
                              	 m_iStart,
								 NULL );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "WriteNBytesToInternal failed with 0x%x", hr );
        } else {
            m_iStart = m_iEnd;
        }
    } else 
        hr = S_FALSE;
    
    TraceFunctLeave();
    return hr;
}

BOOL
CFlatFileWriteBuf::IsEnabled() const
/*++
Routine description:

    Check to see if we are enabled

Arguments:

    None.

Return value:

    TRUE if we are enabled, FALSE otherwise
--*/
{
    if ( m_pbBuffer && m_pParentFile->IsFileOpened() ) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
CFlatFileWriteBuf::FillBuffer(
                    const DWORD     dwOffset,
                    const PBYTE     pbBuffer,
                    const DWORD     cbBuffer,
                    PDWORD          pdwOffset,
                    PDWORD          pcbWritten
                    )
/*++
Routine description:

    Fill the stuff into the buffer

Arguments:

    dwOffset    - The offset into the flatfile where we want to write the bytes
    pbBuffer    - Pointer to the source buffer
    cbBuffer    - Number of bytes to be written
    pdwOffset   - If non-null, to return the real offset
    pcbWritten  - If non-null, to return bytes written

Return value:

    S_OK    - If succeeded
    Other error code otherwise
--*/
{
    TraceQuietEnter( "CFlatFileWriteBuf::FillBuffer" );
    _ASSERT( pbBuffer );
    _ASSERT( IsEnabled() );
    _ASSERT( m_iEnd >= m_iStart );
    _ASSERT( m_iEnd == m_iStart || m_iEnd == dwOffset || dwOffset == INFINITE );
    _ASSERT( BufferAvail() >= cbBuffer );
    _ASSERT( m_cbBuffer > 0 );

    DWORD iStart = m_iEnd - m_iStart;

    CopyMemory( m_pbBuffer + iStart, pbBuffer, cbBuffer );

    if ( dwOffset != INFINITE && m_iEnd == m_iStart ) {
        m_iStart = m_iEnd = dwOffset;
    }

    if ( pdwOffset ) 
        *pdwOffset = ( dwOffset == INFINITE ) ? m_iEnd : dwOffset;
    if ( pcbWritten ) 
        *pcbWritten = cbBuffer;
    
    m_iEnd += cbBuffer;
    _ASSERT( m_iEnd - m_iStart <= m_cbBuffer );

}

HRESULT
CFlatFileWriteBuf::WriteFileBuffer( 
                    const DWORD     dwOffset,
                    const PBYTE     pbBuffer,
                    const DWORD     cbBuffer,
                    PDWORD          pdwOffset,
                    PDWORD          pcbWritten
                    )
/*++
Routine description:

    Write byte range into the flat file buffer, which could cause
    buffer flush first if need be

Arguments:

    dwOffset    - The offset into the flatfile where we want to write the bytes
    pbBuffer    - Pointer to the source buffer
    cbBuffer    - Number of bytes to be written
    pdwOffset   - If non-null, to return the real offset
    pcbWritten  - If non-null, to return bytes written

Return value:

    S_OK    - If succeeded
    Other error code otherwise
--*/
{
    TraceQuietEnter( "CFlatFileWriteBuf::WriteFile" );
    _ASSERT( pbBuffer );

    HRESULT hr = S_OK;

    if ( NeedFlush( dwOffset, cbBuffer ) ) {

        // 
        // If we need to flush the buffer first, we'll do so
        //

        hr = FlushFile();
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Flush file failed with 0x%x", hr );
            goto Exit;
        }
    }
        
    if ( !IsEnabled() || cbBuffer > m_cbBuffer ) {

        //
        // If we are not enabled, or our buffer is not big enough,
        // we'll write directly into the file
        //

        hr = WriteFileReal( dwOffset, pbBuffer, cbBuffer, pdwOffset, pcbWritten );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "WriteFileReal failed with 0x%x", hr );
        }
        goto Exit;
    }

    //
    // Now we can copy the content into our buffer
    //

    FillBuffer( dwOffset, pbBuffer, cbBuffer, pdwOffset, pcbWritten );

Exit:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\artglbs.h ===
extern DWORD numField;
extern DWORD numPCString;
extern DWORD numDateField;
extern DWORD numFromPeerArt;
extern DWORD ArticleTimeLimitSeconds;
extern DWORD numArticle;
extern DWORD numPCParse;
extern DWORD numMapFile;

extern const char szNLChars[];
extern const char szWSNullChars[];
extern const char szNLChars[];
extern const char szWSNLChars[];
extern const char szWSChars[];
extern const char StrNewLine[];
extern const char StrTermLine[];

extern DEBUG_PRINTS* g_pDebug;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\artutil.h ===
typedef char* CHARPTR;

BOOL ValidateFileBytes( HANDLE );
BOOL ValidateFileBytes( LPSTR, BOOL );
BOOL fMultiSzRemoveDupI(char * multiSz, DWORD & c, CAllocator * pAllocator);
VOID vStrCopyInc( char * , char* & );
BOOL FValidateMessageId( LPSTR );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\article.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    article.h

Abstract:

    This module contains class declarations/definitions for

		CArticle
        CField
			CDateField
			CFromField
			CMessageIDField
			CSubjectField
			CNewsgroupsField
			CPathField
			CXrefField
			CFollowupToField
			CReplyToField
			CApprovedField
			CSenderField
			CExpiresField
			COrganizationField
			CSummaryField
			CReferencesField
            CControlField
			CLinesField
			CDistributionField
			CKeywordsField
			CNNTPPostingHostField
			CXAuthLoginNameField
		CNAMEREFLIST


    **** Overview ****

    An CArticle object provides an software interface for viewing
	and editing a netnews article.
	
	An object is initialized by
	giving it a handle or filename for a file containing a Netnews
	article. During initialization the article is "preparsed".
	Preparsing consists of memory mapping the file and then
	finding the location of
	    1. The gap that may preceed the article in the file.
		2. The article in the file.
		3. The article's header
		4. The article's body.

	Also for every header line in the header, the preparsing creates an
	entry in an array that records the location of:
		1. The header line
		2. The keyword
		4. The value

	All these locations are represented with Pointer/Counter Strings (See
	CPCString in pcstring.h.) This representation has just to parts
		1. A char pointer to the start of the item in the memory mapped file..
		2. A dword containing the length of the item.


  **** Fields ****

	Each CArticle object can also have several CField subobjects. These
	subobjects specialize in parsing and editing specific types of fields.
	For example, the CNewsgroupsField object knows how to validate, get,
	and set the "Newsgroups: " field.

  **** Derivied Objects ****

	Every type of feed (e.g. FromClient, FromPeer, etc) defines its own CArticle
	object with the CField subobjects that it needs. For example, for FromClient
	feeds there is a CFromClientArticle (defined in fromclnt.h) with a
	CFromClientFromField (also defined in fromclnt.h) that does very strict
	parsing of the article's "From: " field.

  **** Editing an Article ****

	The header of an article can be edited by deleting old headers and adding
	new ones. Headers are deleted just may marking an field in the array of
	header values. Headers are added by adding a new entry to the array. This
	entry can't just point to the memory-mapped file, so it instead points
	to dynamically allocated memory.

	When an article is "saved" (or "flushed"), the actual image on disk is
	changed to reflected the changes made.



Author:

    Carl Kadie (CarlK)     10-Oct-1995

Revision History:

--*/

#ifndef	_ARTICLE_H_
#define	_ARTICLE_H_

#include <pcstring.h>
#include <artcore.h>

//
// CPool Signature
//

#define ARTICLE_SIGNATURE (DWORD)'2195'

class CNntpServerInstanceWrapper;

//
// CArticle now derives from CArticleCore.  CArticleCore has all the
// properties and methods that provide the basic article parse functionality.
// CArticleCore is instantiable because it has no pure virtual mehtods.
// CArticle defines interfaces to be implemented by different type of
// articles ( fromclnt, frompeer, etc ) by adding pure virtual functions
// and instance related members to CArticleCore.
//
class CArticle : public CArticleCore {

private :

	// Used for memory allocation
	static	CPool	gArticlePool ;

protected:

//
// Public Members
//
public :

	// Used for memory allocation
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;
	void*	operator	new(	size_t	size ) ;
	void	operator	delete( void *pv ) ;

	//
	//   Constructor
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects
    //
    // Lightweight Constructors -
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //
    CArticle();

   	//
   	//   Destructor
   	//

    virtual ~CArticle() ;



    //
    //  the virtual server instance for this article
    //
    CNntpServerInstanceWrapper *m_pInstance ;

    //
    //  If an incoming article was small enough to fit entirely into
    //  a memory buffer - call this function !
    //

    BOOL    fInit(
                char*       pchHead,
                DWORD       cbHead,
                DWORD       cbArticle,
                DWORD       cbBufferTotal,
                CAllocator* pAllocator,
                CNntpServerInstanceWrapper *pInstance,
                CNntpReturn&    nntpReturn
                ) {
        m_pInstance = pInstance;
        return CArticleCore::fInit(     pchHead,
                                        cbHead,
                                        cbArticle,
                                        cbBufferTotal,
                                        pAllocator,
                                        nntpReturn );
        }

    //
    //  If an incoming article was so large that it did not fit into
    //  a memory buffer call this initialization function !
    //

    BOOL    fInit(
            char*       pchHead,
            DWORD       cbHead,
            DWORD       cbArticle,
            DWORD       cbBufferTotal,
            HANDLE      hFile,
            LPSTR       lpstrFileName,
            DWORD       ibHeadOffset,
            CAllocator* pAllocator,
            CNntpServerInstanceWrapper *pInstance,
            CNntpReturn&    nntpReturn
            ) {
        m_pInstance = pInstance;
        return CArticleCore::fInit( pchHead,
                                    cbHead,
                                    cbArticle,
                                    cbBufferTotal,
                                    hFile,
                                    lpstrFileName,
                                    ibHeadOffset,
                                    pAllocator,
                                    nntpReturn );
    }

    //
    // Give either file name or file handle, initialize article object
    //
    BOOL fInit(
			const char * szFilename,
			CNntpReturn & nntpReturn,
			CAllocator * pAllocator,
			CNntpServerInstanceWrapper *pInstance,
			HANDLE hFile = INVALID_HANDLE_VALUE,
			DWORD	cBytesGapSize = cchUnknownGapSize,
			BOOL    fCacheCreate = FALSE
			) {
	    m_pInstance = pInstance;
	    return CArticleCore::fInit( szFilename,
	                                nntpReturn,
	                                pAllocator,
	                                hFile,
	                                cBytesGapSize,
	                                fCacheCreate );
	}

    //
    // Install an article into newstree
    //
    BOOL    fInstallArticle(
            class   CNewsGroupCore& group,
            ARTICLEID   articleid,
            class   CSecurityCtx*   pSecurity,
            BOOL    fIsSecure,
            void *pGrouplist,
            DWORD dwFeedId
            ) ;

    //
    //  Pass the article to a mail provider (for postings to moderated groups)
    //
    BOOL    fMailArticle(
            LPSTR   lpModerator
            //class CSecurityCtx*   pSecurity,
            //BOOL  fIsSecure
            ) ;

    //
    //   A virtual function for validating articles
    //

    virtual BOOL fValidate(
            CPCString& pcHub,
            const char * szCommand,
            CInFeed*    pInFeed,
            CNntpReturn & nntpr )   = 0;

    //
    // A virtual function for processing the arguments to
    // the Post, IHave, XReplic, etc line used to transfer
    // this article to this machine.
    //
    virtual BOOL fCheckCommandLine(
             char const * szCommand,
             CNntpReturn & nntpr
                ) = 0;

    //
    //   Depending on the type of the feed, modify the headers.
    // This includes deleting headers that we don't want (for example,
    // xref) and adding headers we do want Organization, PostingHost, Path,
    // MessageID as appropriate for the type of feed. It will leave space for
    // the XRef value.
    //

    virtual BOOL fMungeHeaders(
             CPCString& pcHub,
             CPCString& pcDNS,
             CNAMEREFLIST & namerefgrouplist,
             DWORD remoteIpAddress,
             CNntpReturn & nntpReturn,
             PDWORD pdwLinesOffset = NULL ) = 0;

    //
    // Returns the message id of the article if it is available
    //

    virtual const char * szMessageID(void) = 0;

    // Return the control message type in the control header of this article
    // Derived classes should redefine this to return the actual message type
    virtual CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
             _ASSERT(FALSE);
              return (CONTROL_MESSAGE_TYPE)MAX_CONTROL_MESSAGES;    // guaranteed to NOT be a control message
            };

    // Return the newsgroups listed in the article's Newsgroups field
    // in multisz form.
    // This function is redefined where needed by the derived classes.
    virtual const char * multiszNewsgroups(void) {
              _ASSERT(FALSE);
              return "";
            };

    // Return the newsgroups listed in the article's Newsgroups field
    // in CNAMEREFLIST form.
    // This function is redefined where needed by the derived classes.
    virtual CNAMEREFLIST * pNamereflistGet(void)    {
             _ASSERT(FALSE);
              return (CNAMEREFLIST *) NULL;
            };

    // the number of newsgroups listed in the article's Newsgroups field.
    virtual DWORD cNewsgroups(void) = 0;

    // Return the path items listed in the article's Path field
    // in multisz form.
    // This function is redefined where needed by the derived classes.
    virtual const char * multiszPath(void) {
          _ASSERT(FALSE);
          return "";
         };

    // the number of path items listed in the article's Path field.
    virtual DWORD cPath(void) = 0;

#if 0
    //  The content of the date header
    virtual const char* GetDate( DWORD  &cbDate ) = 0 ;
#endif

};

extern const unsigned cbMAX_ARTICLE_SIZE;

#ifndef	_NO_TEMPLATES_

#ifndef _ARTICLE_TEMPLATE_
#define _ARTICLE_TEMPLATE_
typedef CRefPtr< CArticle > CARTPTR ;
#endif

#else

DECLARE_TYPE( CArticle ) 

typedef	class	INVOKE_SMARTPTR( CArticle )	CARTPTR ;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\cbuffer.h ===
/*++

	buffer.h

	This file contains the class definitions for buffers in the NNTP server.

	A CBuffer is a reference counted buffer which is variable sized.
	CBuffer's will be created in one of several standard sizes, the size 
	stored in the m_cbTotal field.

--*/

#ifndef	_CBUFFER_H_
#define	_CBUFFER_H_

#include	"gcache.h"

class CSmallBufferCache;
class CMediumBufferCache;

//
//  The largest buffer we will use - must be big enough to hold
//  encrypted SSL blobs in contiguous chunks
//
extern  DWORD   cbLargeBufferSize ;

//
//  Medium size buffers - will be used for commands which generate large
//  responses, and when sending files through SSL
//
extern  DWORD   cbMediumBufferSize ;

//
//  Small buffers - used to read client commands and send small responses.
//
extern  DWORD   cbSmallBufferSize ;

//
//	Buffer management class - this class can represent buffers 
//	of various sizes.   The buffer is Ref counted, and contains the total
//	size of the buffer.
//
class	CBuffer	: public	CRefCount	{
public : 
	unsigned	m_cbTotal ;		//	Total size of the buffer
	char		m_rgBuff[1] ;		//	Variable size arrary
private : 

	//
	//	Related classes for memory management of CBuffer's
	//
	friend	class	CBufferAllocator ;
	static	BOOL				gTerminate ;
	static	CBufferAllocator	gAllocator ;

	//
	//	Not allowed to construct CBuffer's without providing a size for m_cbTotal - 
	//	hence this constructor is made private !
	//
	CBuffer() ;
public : 

	//
	//	Default cache's to allocate and release buffers to and from
	//
	static	CSmallBufferCache*	gpDefaultSmallCache ;	// small buffers
	static	CMediumBufferCache*	gpDefaultMediumCache ;	// medium buffers

	//
	//	When constructing a CBuffer - specify the actual size of the m_rgBuff area !
	//
	CBuffer( int cbTotal ) : m_cbTotal(cbTotal) {}

	//
	//	These functions set up and tear down the memory management structures for CBuffer's
	//
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;

	//
	//	The following functions handle memory management of CBuffer's.
	//	This version of new will do its best to get a cached buffer for us.
	//
	void*	operator	new( 
							size_t	size, 
							DWORD	cb, 
							DWORD	&cbOut,	
							CSmallBufferCache*	pCache = gpDefaultSmallCache,
							CMediumBufferCache*	pMedium = gpDefaultMediumCache
							) ;

	//
	//	Delete will release to our default cache's if possible
	//	other directly to the underlying allocator
	//
	void	operator	delete(	
							void *pv 
							) ;	

	//
	//
	//
	static	void		Destroy(	
							CBuffer*	pbuffer,	
							CSmallBufferCache*	pCache 
							) ;

} ;

class	CBufferAllocator	:	public	CClassAllocator	{
//
//	This class wraps up our calls to the general purpose 
//	CBuffer allocator.  We do this so that we can build CCache
//	derived allocation caches.  (CSmallBufferCache and CMediumBufferCache)
//
//	Basically, we will maintain 3 CPool objects from which we
//	will manage all allocations.  Buffers will come in one of 3 sizes
//	Small buffers - use these when getting client commands
//	Medium buffers - used fo receive client postings, send large command 
//		responses, transmit SSL encrypted files
//	Large buffers - used to handle worst case SSL encrypted blobs (32K)
//
private: 
	//
	//	Constant for the number of possible buffer sizes
	//
	enum	CBufferConstants	{
		MAX_BUFFER_SIZES = 3, 
	} ;

	//	
	//	Array of CPool's from which we allocate buffers
	//
	static	CPool	rgPool[MAX_BUFFER_SIZES] ;
	
	//
	//	Our constructor is private - because there is only one of us !
	//
	CBufferAllocator()	{}

	//
	//	CBuffer gets to be our friend
	//
	friend	class	CBuffer ;

	//
	//	CSmallBufferCache knows about our different CPools
	//
	friend	class	CSmallBufferCache ;

	//
	//	CMediumBufferCache knows about our different CPools
	//	
	friend	class	CMediumBufferCache ;

public : 
	//
	//	Array of sizes - tells us what size buffer we get from each CPool
	//
	static	DWORD	rgPoolSizes[MAX_BUFFER_SIZES] ;

	//
	//	Set up all of our CPools
	//
	static	BOOL	InitClass() ;

	//
	//	Release every bit of memory in our CPools
	//
	static	BOOL	TermClass() ;

	//
	//	Allocate a single buffer.
	//	cbOut gets the 'TRUE' size of the buffer allocated.
	//
	LPVOID	Allocate(	DWORD	cb, DWORD&	cbOut = CClassAllocator::cbJunk ) ;

	//
	//	Release an allocated buffer - automagically goes to correct CPool
	//
	void	Release( void *lpv ) ;

#if 1
	int		GetPoolIndex(	void*	lpv ) ;
	void	Erase(	void*	lpv ) ;
	BOOL	EraseCheck(	void*	lpv ) ;
	BOOL	RangeCheck( void*	lpv ) ;
	BOOL	SizeCheck(	DWORD	cb ) ;
#endif
} ;

class	CSmallBufferCache :	public	CCache	{
//
//	This class is used within CIODriver's and the like to keep
//	a cache of buffers around.  Mostly, we're trying to avoid
//	the synchronization costs it would take to put buffers on and
//	off of CPool Queues.
//
private : 
	//
	//	Pointer to the one and only BufferAllocator we will use to 
	//	allocate buffers.  This needs to be derived from CAllocator so 
	//	we can use CCache as a base class.
	//
	static	CBufferAllocator*	BufferAllocator ;

	//
	//	This is our storage space - hold pointers to SMALL buffers only here.
	//
	void*	lpv[4] ;
public : 
	//
	//	Initialize class globals - always succeeds !!
	//
	static	void	InitClass(	CBufferAllocator*	Allocator )	{	BufferAllocator = Allocator ; }

	//
	//	Initialize a CSmallBufferCache()
	//
	inline	CSmallBufferCache(	) :		CCache( lpv, 4 )	{} ;
	
	//
	//	Release anything we may have in the cache and then fall on our sword
	//
	inline	~CSmallBufferCache( ) {		Empty( BufferAllocator ) ;	}
	
	//
	//	Return a buffer to its origin
	//
	inline void	Free(	void*	lpv ) ; 

	//
	//	Allocate a small buffer
	//
	inline	void*	Alloc(	DWORD	size,	DWORD&	cbOut=CCache::cbJunk ) ; 
} ;

class	CMediumBufferCache : public	CCache	{
//
//	This class is just like CSmallBufferCache, except that we handle MEDIUM
//	sized buffers only !
//
private : 
	//
	//	The CBufferAllocator object from which we can get all our buffers
	//
	static	CBufferAllocator*	BufferAllocator ;

	//
	//	Storage space for cache.
	//
	void*	lpv[4] ;
public : 

	//
	//	Initialize class static members - easily done and always successfull
	//
	static	void	InitClass(	CBufferAllocator*	Allocator )	{	BufferAllocator = Allocator ; }

	//
	//	Initialize our Cache
	//
	inline	CMediumBufferCache(	) :		CCache( lpv, 4 )	{} ;

	//
	//	Release everything in our cache
	//
	inline	~CMediumBufferCache( ) {		Empty( BufferAllocator ) ;	}
	
	//
	//	Free memory back to the Allocator if our cache is full
	//
	inline void	Free(	void*	lpv ) ; 

	//
	//	Allocate from our cache preferably
	//
	inline	void*	Alloc(	DWORD	size,	DWORD&	cbOut=CCache::cbJunk ) ; 
} ;

void
CSmallBufferCache::Free(	
					void*	lpv 
					) {
/*++

Routine Description : 

	Return a previously allocated buffer either to our cache or the 
	general allocator.

Arguments : 

	lpv - the released memory

Return Value : 

	None.

--*/

	CPool**	pPool = (CPool**)lpv ;
	if( pPool[-1] == &CBufferAllocator::rgPool[0] ) {
		CCache::Free( lpv,	BufferAllocator ) ;
	}	else	{
		BufferAllocator->Release( lpv ) ;
	}
}

void*
CSmallBufferCache::Alloc(	
					DWORD	size,	
					DWORD&	cbOut 
					)		{
/*++

Routine Description : 

	Allocate out of our cache if possible a buffer of the requested minimum size.
	If this is larger than what we hold in our cache - go to the general allocator.

Arguments : 

	size - requested size
	cbOut - actual size of the block returned.

Return Value : 

	Pointer to allocated block (NULL on failure).

--*/
	if(	(size + sizeof( CPool*)) < CBufferAllocator::rgPoolSizes[0] ) {
		cbOut = CBufferAllocator::rgPoolSizes[0] - sizeof( CPool * ) ;
		return	CCache::Alloc( size, BufferAllocator ) ;
	}	
	return	BufferAllocator->Allocate( size, cbOut ) ;
}	

void
CMediumBufferCache::Free(	
					void*	lpv 
					) {
/*++

Routine Description : 

	Return a previously allocated buffer either to our cache or the 
	general allocator.

Arguments : 

	lpv - the released memory

Return Value : 

	None.

--*/

	CPool**	pPool = (CPool**)lpv ;
	if( pPool[-1] == &CBufferAllocator::rgPool[1] ) {
		CCache::Free( lpv,	BufferAllocator ) ;
	}	else	{
		BufferAllocator->Release( lpv ) ;
	}
}

void*
CMediumBufferCache::Alloc(	
					DWORD	size,	
					DWORD&	cbOut 
					)		{
/*++

Routine Description : 

	Allocate out of our cache if possible a buffer of the requested minimum size.
	If this is larger than what we hold in our cache - go to the general allocator.

Arguments : 

	size - requested size
	cbOut - actual size of the block returned.

Return Value : 

	Pointer to allocated block (NULL on failure).

--*/
	DWORD	cb = size + sizeof( CPool*) ;
	if(	cb < CBufferAllocator::rgPoolSizes[1] &&
		cb > CBufferAllocator::rgPoolSizes[0] ) {
		cbOut = CBufferAllocator::rgPoolSizes[1] - sizeof( CPool * ) ;
		return	CCache::Alloc( size, BufferAllocator ) ;
	}	
	return	BufferAllocator->Allocate( size, cbOut ) ;
}	

typedef    CRefPtr< CBuffer >      CBUFPTR;

#endif	//	_PACKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\cfeed.h ===
#ifndef	_CFEED_H_
#define	_CFEED_H_

//
// CPool Signature
//

#define FEED_SIGNATURE (DWORD)'3702'

//
// The states of an Feed object
//

typedef enum _FEED_STATE {
	ifsInitialized,
	ifsUninitialized,
} FEED_STATE;


class	CFeed 	{
private : 

	//
	// For memory allocation
	//

	static	CPool	gFeedPool ;

protected : 

	//
	//	The number of events logged on this session of this feed.
	//
	
	DWORD	m_cEventsLogged ;

//
//Public Members
//

public :

	//
	// For memory allocation
	//

#ifndef _UNIT_TEST_
	void*	operator	new(	size_t size ) ;
	void	operator	delete(	void*	pv ) ;
	static	BOOL	InitClass( ) ;
	static	BOOL	TermClass( ) ;
#endif


	//
	// Constructor
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects.
    //
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //
	CFeed():
			m_feedState(ifsUninitialized),
			m_cEventsLogged( 0 )
			{};

	// Destructor
	virtual ~CFeed(void) {};

	//
	// Access function that gives the completion context
	//

	PVOID	feedCompletionContext(void) {
			return m_feedCompletionContext;
			}


	//
	//	Log errors that occur associated with feed processing.
	//	we will put a cap on the number of errrs logged.
	//
	
	virtual	void	LogFeedEvent(
			DWORD	idMessage, 	
			LPSTR	lpstrMessageId,
			DWORD   dwInstanceId
			) ;

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	virtual	LPSTR	FeedType()	{
				return	"UNSUPPORTED" ;
				}

//
// Protected Members
//

protected :

	//
	// The state of the feed object.
	//

	FEED_STATE m_feedState;

	

    //
    // Feed manager completion context.  This is passed back
    // to the feed manager after a feed completes.
    //

    PVOID m_feedCompletionContext;



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\baseheap.h ===
#ifndef _BASEHEAP_H_
#define _BASEHEAP_H_

#define MAX_ARTHEAP_SIZE		5000
#define MAX_XIXHEAP_SIZE        5000

#define PARENT_NODE(i) ((((i)+1)>>1)-1)  // i/2
#define LEFT_NODE(i)   (((i)<<1)+1)
#define RIGHT_NODE(i)  (((i)<<1)+2)

#define HEAPSTATE_HEAP     0
#define HEAPSTATE_SORTED   1

//
//  Base heap class - implements basic heap functions like Heapify(),
//  BuildHeap() and SortHeap(). Derived classes need to store the 
//  actual data nodes and implement an Exchange() and CompareNodes()
//  function.
//

class CHeap
{
protected:

    int       HeapSize;
    int       HeapState;
    void Heapify( int i );
    void SortHeap( void );
    void BuildHeap( void );
    virtual void Exchange( int i, int j ) = 0;
    virtual BOOL CompareNodes( int iNode1, int iNode2 ) = 0;

public:

    CHeap(void);
    void ForgetAll( void );
    BOOL isEmpty( void );
};

//
//  CArticleHeap is a heap of ARTICLE_HEAP_NODES
//

typedef struct
{
    FILETIME  ft;
    GROUPID   GroupId;
    ARTICLEID ArticleId;
    DWORD     ArticleSize;
} ARTICLE_HEAP_NODE;

class CArticleHeap : public CHeap
{
private:

    ARTICLE_HEAP_NODE Heap[MAX_ARTHEAP_SIZE];
    virtual void Exchange( int i, int j );
    virtual BOOL CompareNodes( int iNode1, int iNode2 );

public:

    CArticleHeap(void);
    void Insert( FILETIME ft, GROUPID GroupId, ARTICLEID ArticleId, DWORD ArticleSize );
    BOOL ExtractOldest( FILETIME& ft, GROUPID& GroupId, ARTICLEID& ArticleId, DWORD& ArticleSize );
};

//
//  CXIXHeap is a heap of XIX_HEAP_NODES
//

typedef struct
{
    FILETIME  ft;
    GROUPID   GroupId;
    ARTICLEID ArticleIdBase;
} XIX_HEAP_NODE;

class CXIXHeap : public CHeap
{
private:

    XIX_HEAP_NODE Heap[MAX_XIXHEAP_SIZE];
    virtual void Exchange( int i, int j );
    virtual BOOL CompareNodes( int iNode1, int iNode2 );

public:

    CXIXHeap(void);
    void Insert( FILETIME ft, GROUPID GroupId, ARTICLEID ArticleIdBase );
    BOOL ExtractOldest( FILETIME& ft, GROUPID& GroupId, ARTICLEID& ArticleIdBase );
};

#endif  // _BASEHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\ddroplst.h ===
#ifndef __DDROPLST_H__
#define __DDROPLST_H__

#include "fhash.h"
#include "listmacr.h"
#include "dbgtrace.h"
#include <dbgutil.h>
#include <iiscnfgp.h>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <xmemwrpr.h>

class CDDropGroupSet;

//
// this class holds a group name and its position in a group list
//
class CDDropGroupName {
	public:
		CDDropGroupName(LPCSTR szNewsgroup) {
			strcpy(m_szNewsgroup, szNewsgroup);
		}
		~CDDropGroupName() {
		}
		PLIST_ENTRY GetListEntry() { 
			return &m_le; 
		}
		LPSTR GetNewsgroup() {
			return m_szNewsgroup;
		}
	private:
		CDDropGroupName() {
			_ASSERT(FALSE);
		}
		// the name of this newsgroup
		char		m_szNewsgroup[MAX_PATH];
		// all entries are in a linked list so that they can be enumerated
		LIST_ENTRY	m_le;

	friend class CDDropGroupSet;
};

// 
// this class wraps CDDropGroupName so that it may be saved into hash
// tables
//
class CDDropGroupNameHE {
	public:
		CDDropGroupNameHE() {
			m_pDDropGroupName = NULL;
		}
		CDDropGroupNameHE(CDDropGroupName *pDDropGroupName) {
			m_pDDropGroupName = pDDropGroupName;
		}
		CDDropGroupNameHE(CDDropGroupNameHE &src) {
			m_pDDropGroupName = src.m_pDDropGroupName;
		}		
		~CDDropGroupNameHE() {
		}
		CDDropGroupName *GetDDropGroupName() { 
			return m_pDDropGroupName; 
		}
		LPCSTR GetKey() {
			return m_pDDropGroupName->GetNewsgroup();
		}
		int MatchKey(LPCSTR szNewsgroup) {
			return (0 == lstrcmp(m_pDDropGroupName->GetNewsgroup(), szNewsgroup));
		}
	private:
		CDDropGroupName *m_pDDropGroupName;
};

typedef TFHash<CDDropGroupNameHE, LPCSTR> CHASH_DDROP_GROUPS, *PCHASH_DDROP_GROUPS;

//
// this class implements a set of newsgroups that should be dropped.  
//
// public methods:
//      AddGroup() - add a group to the set
//      RemoveGroup() - remove a group from the set
//      IsGroupMember() - is this group a member of the set?
//
class CDDropGroupSet {
	public:
		CDDropGroupSet() {
			InitializeListHead(&m_leHead);
			InitializeCriticalSection(&m_cs);
		}

		~CDDropGroupSet() {
			LIST_ENTRY *ple;				// the current newsgroup 
			CDDropGroupName *pGN;			
			EnterCriticalSection(&m_cs);
			//clear the CDDropGroupName object
			ple = m_leHead.Flink;
			while (ple != &m_leHead) {
				pGN = CONTAINING_RECORD(ple, CDDropGroupName, m_le);
				ple = ple->Flink;
				XDELETE pGN;
				pGN = NULL;
			}
			
			m_hash.Clear();
			LeaveCriticalSection(&m_cs);
			DeleteCriticalSection(&m_cs);
		}

		//
		// arguments:
		//  pfnHash - a pointer to the hash function, which takes a
		//            newsgroup as an argument and returns a DWORD
		//
		BOOL Init(DWORD (*pfnHash)(const LPCSTR &szNewsgroup)) {
			return m_hash.Init(20, 10, pfnHash);
		}

		//
		// arguments:
		//  pMB - a pointer to a class MB object which is pointing to
		//        the group load/save path in the metabase
		BOOL LoadDropGroupsFromMB(MB *pMB) {
			TraceFunctEnter("CDDropGroupSet::LoadDropGroupsFromMB");

			DWORD dwPropID = 0;
			BOOL fSuccessful = TRUE;

			DebugTrace(0, "starting to enum list of dropped groups");
			while (fSuccessful) {
				char szNewsgroup[MAX_PATH];
				DWORD cbNewsgroup = sizeof(szNewsgroup);

				if (!pMB->GetString("", dwPropID++, IIS_MD_UT_SERVER, szNewsgroup, &cbNewsgroup)) {
					DebugTrace(0, "done loading drop groups");
					break;
				}

				DebugTrace(0, "found group %s", szNewsgroup);
				if (!AddGroup(szNewsgroup)) fSuccessful = FALSE;
			}

			TraceFunctLeave();
			return fSuccessful;
		}

		//
		// arguments:
		//  pMB - a pointer to a class MB object which is pointing to
		//        the group load/save path in the metabase
		BOOL SaveDropGroupsToMB(MB *pMB) {
			TraceFunctEnter("CDDropGroupSet::SaveDropGroupsToMB");

			LIST_ENTRY *ple;				// the current newsgroup 
			DWORD dwPropID = 0;				// the current property ID
			BOOL fSuccessful = TRUE;

			while (1) {
				if (!pMB->DeleteData("", dwPropID++, IIS_MD_UT_SERVER, STRING_METADATA)) {
					break;
				}
			}

			dwPropID = 0;

			EnterCriticalSection(&m_cs);
			ple = m_leHead.Flink;
			DebugTrace(0, "saving groups to MB");
			while (ple != &m_leHead && fSuccessful) {
				CDDropGroupName *pGN;
				pGN = CONTAINING_RECORD(ple, CDDropGroupName, m_le);
				ple = ple->Flink;

				DebugTrace(0, "saving group %s", pGN->GetNewsgroup());

				fSuccessful = pMB->SetString("", dwPropID++, IIS_MD_UT_SERVER, 
									    pGN->GetNewsgroup());
			}
			DebugTrace(0, "Saved all groups");
			LeaveCriticalSection(&m_cs);
			if (fSuccessful) fSuccessful = pMB->Save();

			return fSuccessful;
		}

		BOOL AddGroup(LPCSTR szNewsgroup) {
			if (m_hash.SearchKey(szNewsgroup) == NULL) {
				CDDropGroupName *pGroupName = XNEW CDDropGroupName(szNewsgroup);
				CDDropGroupNameHE he(pGroupName);

				EnterCriticalSection(&m_cs);
				m_hash.Insert(he);
				InsertHeadList(&m_leHead, pGroupName->GetListEntry());
				LeaveCriticalSection(&m_cs);
				return TRUE;
			} else {
				return FALSE;
			}
		}

		BOOL RemoveGroup(LPCSTR szNewsgroup) {
			CDDropGroupNameHE *pHE;
			CDDropGroupName *pGroupName;

			pHE = m_hash.SearchKey(szNewsgroup);
			if (pHE != NULL) {
				pGroupName = pHE->GetDDropGroupName();
				if (pGroupName != NULL) {
					EnterCriticalSection(&m_cs);
					RemoveEntryList(pGroupName->GetListEntry());
					m_hash.Delete(szNewsgroup);
					LeaveCriticalSection(&m_cs);
					return TRUE;
				} else {
					return FALSE;
				}
			} else {
				return FALSE;
			}		
		}

		BOOL IsGroupMember(LPCSTR szNewsgroup) {
			CDDropGroupNameHE *pHE;

			pHE = m_hash.SearchKey(szNewsgroup);
			return (pHE != NULL);
		}

	private:
		CHASH_DDROP_GROUPS	m_hash;
		LIST_ENTRY			m_leHead;
		CRITICAL_SECTION	m_cs;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\drvid.h ===
///////////////////////////////////////////////////////////////////////////
// This file defines prop id's that drivers need ( FSDriver and EXDriver )
//

#include "mailmsgprops.h"

///////////////////////////////////////////////////////////////////////////
//  IMSG Store Driver ID's
//  Base: 0xc0000010
#define IMSG_SERIAL_ID          0xc0000010	// used for post across stores
#define IMSG_IFS_HANDLE         0xc0000011	// should go away eventually
#define IMSG_SECONDARY_GROUPS   IMMPID_NMP_SECONDARY_GROUPS
#define IMSG_SECONDARY_ARTNUM   IMMPID_NMP_SECONDARY_ARTNUM
#define	IMSG_PRIMARY_GROUP		IMMPID_NMP_PRIMARY_GROUP
#define IMSG_PRIMARY_ARTID		IMMPID_NMP_PRIMARY_ARTID
#define IMSG_POST_TOKEN         IMMPID_NMP_POST_TOKEN
#define IMSG_NEWSGROUP_LIST		IMMPID_NMP_NEWSGROUP_LIST
#define IMSG_HEADERS			IMMPID_NMP_HEADERS
#define IMSG_NNTP_PROCESSING	IMMPID_NMP_NNTP_PROCESSING

#define NNTP_PROCESS_POST		NMP_PROCESS_POST
#define NNTP_PROCESS_CONTROL	NMP_PROCESS_CONTROL
#define NNTP_PROCESS_MODERATOR	NMP_PROCESS_MODERATOR

///////////////////////////////////////////////////////////////////////////
// Common group property id's for both drivers
#define	NEWSGRP_PROP_SECDESC	0xc0002000	// group level security descriptor	

///////////////////////////////////////////////////////////////////////////
// FSDriver specific group property id's
#define NEWSGRP_PROP_FSOFFSET   0xc0001000	// offset into driver owned property file

///////////////////////////////////////////////////////////////////////////
// ExDriver specific group property id's
#define NEWSGRP_PROP_FID        0xc0000001	// Folder ID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\fixprop.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

	fixprop.h

Abstract:

	This module contains class declarations/definitions for

		CFixPropPersist

	**** Overview ****

	The class is the implementation of a fixed sized property
	storage.  It is mainly used for news group's fixed sized
	property.

Author:

	Kangrong Yan	( KangYan )		7-5-1998

Revision History:

--*/

#ifndef _FIXPROP_H_
#define _FIXPROP_H_

#include <tflistex.h>
#include <cpool.h>
#include <group.h>
#include <xmemwrpr.h>

#define GROUPNAME_LEN_MAX 512
#define ALLOC_GRANURALITY 64
#define ID_HIGH_INVALID     0xffffffff
#define FIXPROP_SIGNATURE DWORD('fixp' )
#define FREEINFO_SIGNATURE DWORD('free')

#define ALL_FIX_PROPERTIES	( 	FIX_PROP_NAME | 		\
								FIX_PROP_NAMELEN | 		\
								FIX_PROP_GROUPID |		\
								FIX_PROP_LASTARTICLE |	\
								FIX_PROP_FIRSTARTICLE |	\
								FIX_PROP_ARTICLECOUNT |	\
								FIX_PROP_READONLY |		\
								FIX_PROP_ISSPECIAL |	\
								FIX_PROP_DATELOW |		\
								FIX_PROP_DATEHIGH )		

#define ALL_BUT_NAME_AND_LEN ( 	ALL_FIX_PROPERTIES & 	\
								(~FIX_PROP_NAME) &	\
								(~FIX_PROP_NAMELEN ) )	

//
// Manage free list
//
class CFreeInfo { //fi
public:
	CFreeInfo 	*m_pNext;
	CFreeInfo 	*m_pPrev;
	CFreeInfo(): m_pNext( NULL ),
				 m_pPrev( NULL ),
				 m_dwOffset( 0 ) {}
	DWORD		m_dwOffset;

	// Used for memory allocation
	BOOL m_bFromPool;
	static BOOL InitClass();
	static BOOL TermClass();
	inline void* operator new( size_t size );
	inline void  operator delete( void *pv );

private:
	static CPool g_FreeInfoPool;
};

//
// Manage file handle pool
// It's not CPool'd, because the handle pool is very small
// and there are not many re-new operations
//
/*
class CFileHandle { //fh
public:
	CFileHandle	*m_pNext;
	CFileHandle *m_pPrev;
	CFileHandle(): 	m_pNext( NULL ),
					m_pPrev( NULL ),
					m_hFile( INVALID_HANDLE_VALUE ),
					m_bFromPool( TRUE ) {}
	HANDLE	m_hFile;	
	BOOL	m_bFromPool;
};
*/

#define MAX_FREEINFO_SIZE  sizeof( CFreeInfo )
#define MAX_FREEINFO_OBJECTS ALLOC_GRANURALITY // If exceed, use normal new

//
// Block for fixed group properties
//
struct DATA_BLOCK {	//db
	CHAR		szGroupName[GROUPNAME_LEN_MAX+1]; // Null means free
	DWORD		dwGroupNameLen;	
	DWORD		dwGroupId;
	DWORD		dwHighWaterMark;
	DWORD		dwLowWaterMark;
	DWORD		dwArtCount;
	BOOL		bReadOnly;
	BOOL		bSpecial;
	FILETIME	ftCreateDate;
};

//
//  Private overlapped struct for additional fields like IoSize
//

typedef struct _OVERLAPPED_EXT
{
		    OVERLAPPED  ovl;            // NT OVERLAPPED struct
			DWORD       dwIoSize;       // size of IO submitted
} OVERLAPPED_EXT;

//
// Callback function used by those who init me:
// I will call this function for every group property
// block that I have enumerated
//
typedef
BOOL (*PFNENUMCALLBACK)( DATA_BLOCK&, PVOID, DWORD, BOOL );

//
// This object is not multi-thread safe for group operations
// because it assumes that the mutual exclusion is done by
// the news group object
//
// It is mt safe for free list and file expansion operation.
//
class CFixPropPersist { //fp
public:

	//
	// Constructor, destructor
	//
	CFixPropPersist( IN LPSTR szStorageFile );
	~CFixPropPersist();

	//
	// Init, Term
	//
	BOOL Init( 	IN BOOL bCreateIfNonExist,
				IN PVOID pvContext,
				OUT PDWORD pdwIdHigh,
				IN PFNENUMCALLBACK = NULL );
	BOOL Term();

	//
	// Add, Remove, Get, Set operations
	//
	BOOL AddGroup( 	IN INNTPPropertyBag *pPropBag );
	BOOL RemoveGroup( IN INNTPPropertyBag *pPropBag );
	BOOL GetGroup( IN OUT INNTPPropertyBag *pPropBag, DWORD dwPropertyFlag );
	BOOL SetGroup( IN INNTPPropertyBag *pPropBag, DWORD dwPropertyFlag );
	BOOL SaveTreeInit();
	BOOL SaveGroup( INNTPPropertyBag *pPropBag );
	BOOL SaveTreeClose( BOOL bEffective );

#if defined(DEBUG)
#ifdef __TESTFF_CPP__
	friend int __cdecl main( int, char** );
#endif
	VOID Validate();	// assert on fail, no return value
	VOID DumpFreeList();
	VOID DumpGroups();
#endif	

private:

	// No default constructor allowed
	CFixPropPersist();

	CHAR	m_szStorageFile[MAX_PATH+1];	// file path for the storage
	HANDLE  m_hStorageFile;				// default file handle object
	HANDLE  m_hBackupFile;              // backup file that has ordered groups
	DWORD	m_cCurrentMaxBlocks;		// how many blocks are there
										// in the file ?
	PVOID	m_pvContext;				// Whatever context passed in
										// by init
	CShareLockNH m_FileExpandLock;		// only used for file expansion
	TFListEx<CFreeInfo> m_FreeList;		// Free list
	DWORD	m_dwIdHigh;					// Current max id high

	//
	// Lock array for read / write synchronization: we'll use
	// offset's modular as index into the array
	//

	CShareLockNH m_rgLockArray[GROUP_LOCK_ARRAY_SIZE];

	//
	// Lock/unlock wrappers for lock array
	//

	DWORD   ShareLock( INNTPPropertyBag *pPropBag );
	void    ShareUnlock( DWORD dwOffset );
	DWORD   ExclusiveLock( INNTPPropertyBag *pPropBag );
	void    ExclusiveUnlock( DWORD dwOffset );

	//
	// Free info list lock
	//

	CShareLockNH    m_FreeListLock;

	//
	// Wrappers for locking/unlocking free list
	//
	
	void ShareLockFreeList() { m_FreeListLock.ShareLock(); }
	void ShareUnlockFreeList() { m_FreeListLock.ShareUnlock(); }
	void ExclusiveLockFreeList() { m_FreeListLock.ExclusiveLock(); }
	void ExclusiveUnlockFreeList() { m_FreeListLock.ExclusiveUnlock(); }

	//
	// Id high lock
	//

    CShareLockNH    m_IdHighLock;

    //
    // Wrappers for locking/unlocking id high
    //

    void ShareLockIdHigh() { m_IdHighLock.ShareLock(); }
    void ShareUnlockIdHigh() { m_IdHighLock.ShareUnlock(); }
    void ExclusiveLockIdHigh() { m_IdHighLock.ExclusiveLock(); }
    void ExclusiveUnlockIdHigh() { m_IdHighLock.ExclusiveUnlock(); }

	//
	// Utility
	//
	inline static VOID Group2Buffer(DATA_BLOCK& dbBuffer,
									INNTPPropertyBag *pPropBag,
									DWORD	dwFlag );
	inline static VOID Buffer2Group(DATA_BLOCK& dbBuffer,
									INNTPPropertyBag *pPropBag,
									DWORD	dwFlag );
	BOOL ReadFile( PBYTE, DWORD dwOffset, DWORD dwSize = sizeof( DATA_BLOCK ), BOOL bReadBlock = TRUE );
	BOOL WriteFile( PBYTE, DWORD dwOffset, DWORD dwSize = sizeof( DATA_BLOCK ), BOOL bWriteBlock = TRUE);
	BOOL CFixPropPersist::AsyncRead( PBYTE pbBuffer, LARGE_INTEGER   liOffset, DWORD dwSize );
    BOOL CFixPropPersist::AsyncWrite( PBYTE pbBuffer, LARGE_INTEGER liOffset, DWORD dwSize );
	BOOL ExtendFile( DWORD cBlocks );
	DWORD SeekByName( LPSTR );
	DWORD SeekByGroupId( DWORD, LPSTR );
	DWORD SeekByBest( INNTPPropertyBag * );
	BOOL ProbeForOrder( BOOL& );
	DWORD GetGroupOffset( INNTPPropertyBag * );

	// Clean the free info list
	void CleanFreeList();

	// static ref count for initilization
	static LONG    m_lRef;

	// static lock for init / term synchronization
	static CShareLockNH m_sLock;
};

#include "fixprop.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\dirnot.h ===
#ifndef _DIRNOT_HXX_
#define _DIRNOT_HXX_

#include <atq.h>
#include <windows.h>
#include <wtypes.h>
#include <cpool.h>
#include <xmemwrpr.h>
#include <rwnew.h>

// forward 
class IDirectoryNotification;

// prototype completion function
typedef BOOL (*PDIRNOT_COMPLETE_FN)(PVOID pContext, WCHAR *pszFilename);
typedef HRESULT (*PDIRNOT_SECOND_COMPLETE_FN)( IDirectoryNotification *pDirNot );
typedef VOID (*PFN_SHUTDOWN_FN)(VOID);

class CRetryQ;

class IDirectoryNotification {
	public:
		static HRESULT GlobalInitialize(DWORD cRetryTimeout, 
										DWORD cMaxInstances, 
										DWORD cInstanceSize,
										PFN_SHUTDOWN_FN	pfnShutdown);
		static HRESULT GlobalShutdown(void);
		IDirectoryNotification();
		~IDirectoryNotification();
		HRESULT Initialize( WCHAR *pszDirectory, 
		                    PVOID pContext, 
		                    BOOL  bWatchSubTree,
		                    DWORD dwNotifyFilter,  
		                    DWORD dwChangeAction,
						    PDIRNOT_COMPLETE_FN pfnComplete,
						    PDIRNOT_SECOND_COMPLETE_FN pfnSecondComplete = DoFindFile,
						    BOOL bAppendStartRetry = TRUE
						    );
		static VOID DirNotCompletion(PVOID pAtqContext, DWORD cWritten,
									 DWORD dwCompletionStatus, 
									 OVERLAPPED *lpOverlapped);
		BOOL CallCompletionFn(PVOID pContext, WCHAR *pszFilename) {
			return m_pfnComplete(pContext, pszFilename);
		}
		BOOL CallSecondCompletionFn( IDirectoryNotification *pDirNot ) {
		    return m_pfnSecondComplete( pDirNot );
		}
		static HRESULT DoFindFile( IDirectoryNotification *pDirNot );
		HRESULT Shutdown(void);
		void CleanupQueue(void);
		BOOL IsShutdown(void) { return m_fShutdown; }
		PVOID GetInitializedContext() { return m_pContext; }
	private:
		HRESULT PostDirNotification();

		HANDLE m_hDir;						// handle to the directory
		PATQ_CONTEXT m_pAtqContext;			// ATQ context for directory
		LONG m_cPendingIo;					// the number of outstanding IOs
		PDIRNOT_COMPLETE_FN m_pfnComplete;	// pointer to completion function
		PDIRNOT_SECOND_COMPLETE_FN m_pfnSecondComplete; // function to call when FindFirst/FindNext
		static PFN_SHUTDOWN_FN	m_pfnShutdown;	// shutdown fn to be called for stop hints etc
		PVOID m_pContext;					// pointer to context
		WCHAR m_szPathname[MAX_PATH + 1];	// the path we are running against
		DWORD m_cPathname;					// the length of m_szPathname
		static CRetryQ *g_pRetryQ;			// the retry queue
		BOOL m_fShutdown;					// set to true when shutdown starts
		HANDLE m_heNoOutstandingIOs;		// set when the last IO completes
		CShareLockNH m_rwShutdown;			// r/w lock used to synch shutdown
		BOOL m_bWatchSubTree;               // Do we need to watch sub tree ?
		DWORD m_dwNotifyFilter;             // Notify filter
		DWORD m_dwChangeAction;             // Change action that I care about

		LONG IncPendingIoCount() { return InterlockedIncrement(&m_cPendingIo); }
		LONG DecPendingIoCount() { 
			TraceQuietEnter("IDirectoryNotification::DecPendingIoCount");
			LONG x = InterlockedDecrement(&m_cPendingIo); 
			if (x == 0) {
				DebugTrace(0, "no more outstanding IOs\n");
				SetEvent(m_heNoOutstandingIOs);
			}
			return x;
		}
};

class CDirNotBuffer;

typedef struct _DIRNOT_OVERLAPPED {
    OVERLAPPED Overlapped;
    CDirNotBuffer *pBuffer;
} DIRNOT_OVERLAPPED;

#define	DIRNOT_BUFFER_SIGNATURE		'tNrD'

class CDirNotBuffer {
    public:
		static CPool* g_pDirNotPool;

        CDirNotBuffer(IDirectoryNotification *pDirNot) {
			m_pDirNot = pDirNot;
			ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
			m_Overlapped.pBuffer = this;
		}

        ~CDirNotBuffer(void) {
		}

        //
        // override mem functions to use CPool functions
        //
        void* operator new(size_t cSize) { return g_pDirNotPool->Alloc(); }
        void operator delete(void *pInstance) { g_pDirNotPool->Free(pInstance); }

        //
        // get the max number of bytes in the buffer
        //
        DWORD GetMaxSize() { return g_pDirNotPool->GetInstanceSize(); }
        //
        // get a pointer to the buffers data area
        //
        LPBYTE GetData() { return (LPBYTE) &m_Buffer; }
		//
		// get the size of the buffer data area
        //
		DWORD GetMaxDataSize() { 
			return (GetMaxSize() - sizeof(CDirNotBuffer) + sizeof(m_Buffer)); 
		}
		// 
		// get the parent IDirectoryNotification class that created this
		//
		IDirectoryNotification *GetParent() {
			return m_pDirNot;
		}

		//
		// signature for the class
		//
		DWORD m_dwSignature;
        //
        // the extended IO overlap structure
        //      In order for the completion port to work, the overlap
        //       structure is extended to add one pointer to the 
        //       associated CBuffer object
        //
        DIRNOT_OVERLAPPED m_Overlapped;

    private:
		// 
		// pointer to the IDirectoryNotification that started this all
		//
		IDirectoryNotification *m_pDirNot;
		//
		// the buffer itself.  total size is set by reg key
		//
		WCHAR m_Buffer[1];

		friend IDirectoryNotification;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\frommstr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    frommstr.h

Abstract:

    This module contains class declarations/definitions for

	CFromMasterFeed
	CFromMasterArticle

	CFromMasterMessageIDField
	CFromMasterXrefField


    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used to process articles from masters. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_FROMMASTER_H_
#define	_FROMMASTER_H_

//
// Tells how to process the MessageID field in articles from the clients
//
// Just use the defaults.
//

class CFromMasterMessageIDField : public CMessageIDField {
};

//
// Tells how to process the Xref field in articles from the clients
//

class CFromMasterXrefField : public CXrefField {

	//
	// How to parse xref lines in articles from the master
	//

	virtual BOOL fParse(
		CArticleCore & article, 
		CNntpReturn & nntpReturn
		);


};

//
//
//
// CFromMasterArticle - class for manipulating articles from the master.
//

class	CFromMasterArticle  : public CArticle {
private: 

	DWORD	m_cNewsgroups ;

public:

	//
	// Parse the fields of the article that need parsing.
	//

	BOOL	fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpr
			);

	//
	// The function for validating articles from Masters
	//  Check for duplicate messageid, check that xref is right..
	//

	BOOL	fValidate(
			CPCString& pcHub,
			const char * szCommand,
			CInFeed*	pInFeed,
			CNntpReturn & nntpr
			);



	//
	// Modify the headers.
	// Do nothing.
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 CNAMEREFLIST & namerefgrouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpReturn,
             PDWORD pdwLinesOffset = NULL
			 );

	//
	// Check the arguments to the Xreplic command
	//

	BOOL	fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr
			);

	//
	// Returns the message id of the article if it is available
	//

	const char * szMessageID(void) {
			return m_fieldMessageID.szGet();
			};

    // Return the control message type in the control header of this article
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			return m_fieldControl.cmGetControlMessage();
			};

	//
	// Returns the list of newsgroups
	//

	CNAMEREFLIST * pNamereflistGet(void) {
			return m_fieldXref.pNamereflistGet();
			};

	//
	// Returns the number of newsgroups
	//

	DWORD cNewsgroups(void) {
			//return m_fieldXref.cGet();
			return	m_cNewsgroups ;
			};

	//
	// This function should not be called.
	//

	const char * multiszNewsgroups(void) {
#if 0
			//
			// dir drop calls this - needs to handle empty string
			//
			_ASSERT(FALSE);
#endif
			return "";
			};

	//
	// Return 0 (take anything), so we don't need to parse the Path line
	//

	const char * multiszPath(void) {
			return m_fieldPath.multiSzGet();
			};

#if 0 
	const char *	GetDate( DWORD	&cb ) {
			cb = 0 ;
			return	NULL ;
	}
#endif

	//
	// Return NULLNULL (take anything, so we don't need to parse the Path line
	//

	DWORD cPath(void) {
			return 0;
			};


protected :

	//
	// The fields that will be found, parsed, or set
	//

	CFromMasterMessageIDField		m_fieldMessageID;
	CFromMasterXrefField			m_fieldXref;
	CPathField						m_fieldPath ;
    CControlField                   m_fieldControl;

	//
	// The file should be opened in read/write mode
	//

	BOOL fReadWrite(void) {
			return TRUE;
			}

	//
	// Accept any length
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		};

	//
	// The character following "Field Name:" can be anything
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent) 
		{
			return TRUE;
		}

	//
	// For unit testing
	//

	friend int __cdecl main(int argc, char *argv[ ]);
};



//
//
//
// CFromMasterFeed - for processing incomming articles from the master.
//

class	CFromMasterFeed:	public CInFeed 	{

//
// Public Members
//

public :

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"From Master" ;
				}


	//
	// function that tells if this command is allowed.
	//

	BOOL fIsPostLegal(void) {
			return FALSE;
			};

	//
	// function that tells if this command is allowed.
	//

	BOOL fIsXReplicLegal(void) {
			return TRUE;
			};

		//
		// function that tells if this command is allowed.
		//

	BOOL fIsIHaveLegal(void) {
			return FALSE;
			};

	//
	// Init the feed.
	//

	BOOL fInit(
			CNntpReturn & nntpReturn
			);

	//
	// Returns a list of the newsgroups of the current article
	//

	CNAMEREFLIST * pNamereflistGet(void);

//
// Private Members
//

protected:

	//
	// Creates an article of the right type.
	//

	CARTPTR pArticleCreate(void){
			return new CFromMasterArticle();
			};

	//
	// Message ID's don't need to be recorded, so just return OK
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		}

	//
	// Given an article, returns lists of the newsgroups to post to.
	//

	BOOL fCreateGroupLists(
			CNewsTreeCore* pNewstree,
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			LPMULTISZ	multiszCommandLine,
            CPCString& pcHub,
			CNntpReturn & nntpReturn
			);

    //
	//	Do nothing - moderated checks are done by the MASTER
	//  or by the SLAVE on the client path.
    //
    BOOL    fModeratedCheck(
		CARTPTR & pArticle,
		CNEWSGROUPLIST & grouplist,
        BOOL fCheckApproved,
		CNntpReturn & nntpReturn
		)
	{
		return nntpReturn.fSetOK();
	}

    //
    //  Do nothing. Accept whatever the master sends
	//  An empty grouplist implies missing control.* groups
    //

    BOOL fAdjustGrouplist(
			CNewsTreeCore* pNewstree,
            CARTPTR & pArticle,
	        CNEWSGROUPLIST & grouplist,
		    CNAMEREFLIST * pNamereflist,
		    CNntpReturn & nntpReturn)
	{
		// grouplist should not be empty at this stage !
		if( grouplist.IsEmpty() ) {
		    nntpReturn.fSet(nrcControlNewsgroupMissing);
		}

		return nntpReturn.fIsOK();
	}

	//
	// Do nothing. This would have been created in fCreateGroupLists
    //

	BOOL fCreateNamerefLists(
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn)
	{
		return nntpReturn.fSetOK();
	}

	//
	// Says to return an error if the article doesn't have an newsgroups to post to.
	//

	NRC nrcNoGroups(void) {
			return nrcArticleNoSuchGroups;
			};

	//
	// The return code for accepting an article
	//

	NRC	nrcArticleAccepted(BOOL	fStandardPath) {
			return nrcArticleTransferredOK;
			};

	//
	// The return code for rejecting an article.
	//

	NRC	nrcArticleRejected(BOOL	fStandardPath) {
			return nrcTransferFailedGiveUp;
			};

	virtual void SortNameRefList( CNAMEREFLIST &namereflist ) {
	    namereflist.Sort( comparenamerefs );
	}

private:

    static int __cdecl comparenamerefs( const void *pvNameRef1, const void *pvNameRef2 ) {
        LPVOID pvKey1 = ((NAME_AND_ARTREF*)pvNameRef1)->artref.m_compareKey;
        LPVOID pvKey2 = ((NAME_AND_ARTREF*)pvNameRef2)->artref.m_compareKey;

        if ( pvKey1 < pvKey2 )
            return -1;
        else if ( pvKey1 == pvKey2 )
            return 0;
        else return 1;
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\gcache.h ===
#ifndef	_GCACHE_H_
#define	_GCACHE_H_


class	CClassAllocator	{
protected :
	static	DWORD	cbJunk ;
	CClassAllocator() ;
	virtual	~CClassAllocator() ;
public :
	virtual	LPVOID		Allocate(	DWORD	cb,	DWORD&	cbOut = cbJunk ) = 0 ;
	virtual	void		Release(	void*	lpv ) = 0 ;
#ifdef	DEBUG
	virtual	void		Erase( LPVOID	lpv ) ;
	virtual	BOOL		EraseCheck(	LPVOID	lpv ) ;
	virtual	BOOL		RangeCheck( LPVOID	lpv ) ;
	virtual	BOOL		SizeCheck(	DWORD	cb ) ;
#endif
} ;
	

class	CCache	{
private :
	void**	m_pCache ;
	DWORD	m_clpv ;

	void*	InternalFree(	void*	lpv ) ;
	void*	InternalAlloc() ;

protected :
	static	DWORD	cbJunk ;

	CCache(	void**	pCache,	DWORD	size ) ;
	~CCache() ;

	void	Free(	void*	lpv,	CClassAllocator*	pAllocator ) ;
	void*	Alloc(	DWORD	size,	CClassAllocator*	pAllocator,	DWORD&	cbOut = cbJunk ) ;
	void*	Empty( ) ;
	void	Empty(	CClassAllocator*	pAllocator ) ;
} ;


#ifdef	UNIT_TEST

class	CClientAllocator : public	CClassAllocator	{
public :
	LPVOID		Allocate(	DWORD	cb, DWORD	&cbOut = CClassAllocator::cbJunk ) ;
	void		Release(	void*	lpv ) ;
} ;

class	CClientCache : public	CCache	{
private :
	static	CClassAllocator*	gAllocator ;
public :
	static	BOOL	InitClass(	CClassAllocator*	gAllocator ) ;

	CClientCache(	void**	ppCache,	DWORD	size ) ;
   ~CClientCache() ;
	inline	void	Free(	void*	lpv )	{	CCache::Free( lpv, gAllocator ) ;	}
	inline	void*	Alloc(	DWORD	size )	{	return	CCache::Alloc(	size,	gAllocator ) ;}

} ;

class	CacheClient	{
private :
	static	CClientAllocator	MyAllocator ;
public :
	static	BOOL	InitClass() ;
	
	void*	operator	new(	size_t	size,	CClientCache&	pCache )	{	return	pCache.Alloc( size ) ; }
	static	void		Destroy(	CacheClient*	pClient, CClientCache&	pCache )	{	pClient->CacheClient::~CacheClient() ;	pCache.Free( pClient ) ; }

	char	*lpstr ;

	CacheClient(	LPSTR	lpstr ) ;
	~CacheClient() ;
} ;

#endif	// UNIT_TEST

#endif	// _GCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\frompeer.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    frompeer.h

Abstract:

    This module contains class declarations/definitions for

		CFromPeerFeed

		CFromPeerArticle

		CFromPeerDateField
		CFromPeerLinesField
		CFromPeerFromField
		CFromPeerMessageIDField
		CFromPeerSubjectField
		CFromPeerNewsgroupsField
		CFromPeerPathField
		CFromPeerXrefField



    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used to process articles from peers. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_FROMPEER_H_
#define	_FROMPEER_H_

//
// Tells how to process the Date field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerDateField : public CDateField {
};


//
// Tells how to process the Lines field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerLinesField : public CLinesField {
};

//
// Tells how to process the From field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerFromField : public CFromField {
};

//
// Tells how to process the MessageID field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerMessageIDField : public CMessageIDField {
};

//
// Tells how to process the Subject field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerSubjectField : public CSubjectField {
};

//
// Tells how to process the Newsgroups field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerNewsgroupsField : public CNewsgroupsField {
};


//
// Tells how to process the Distribution field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerDistributionField : public CDistributionField {
};

//
// Tells how to process the Path field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerPathField : public CPathField {
};

//
// Tells how to process the Xref field in articles from the clients
//
// Just use the defaults.
//

class CFromPeerXrefField : public CXrefField {
};


//
//
//
// CFromPeerArticle - class for manipulating articles from a peer.
//

class	CFromPeerArticle  : public CArticle {
public:

    CFromPeerArticle(void ) {
        numFromPeerArt++;
    }

    ~CFromPeerArticle(void ) {
        numFromPeerArt--;
    }


	//
	// The function for validating articles from Peers
	//  Required Headers: Newsgroups, From, Date, MessageID, Subject, ???
	//  Check for duplicate message.
	//

	BOOL fValidate(
			CPCString& pcHub,
			const char * szCommand,
			class	CInFeed*	pInFeed,
			CNntpReturn & nntpr
			);

	//
	// Modify the headers.
	// Add path. Remove xref and other unwanted headers.
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 CNAMEREFLIST & namerefgrouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpReturn,
             PDWORD pdwLinesOffset = NULL
			 );

	//
	// Check the argument to IHave command
	//

	BOOL fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr)
		{
			return nntpr.fSetOK(); //!!!FROMMASTER LATER may want to implement this
		}

	//
	// Returns the message id of the article if it is available
	//

	const char * szMessageID(void) {
			return m_fieldMessageID.szGet();
			};

    //
    // Return the control message type in the control header of this article
    //
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			return m_fieldControl.cmGetControlMessage();
			};

    //
	// Returns the article's newsgroups
	//
	const char * multiszNewsgroups(void) {
			return m_fieldNewsgroups.multiSzGet();
			};

	//
	// Returns the number of newsgroups the article will be posted to.
	//
	DWORD cNewsgroups(void) {
			return m_fieldNewsgroups.cGet();
			};

	//
	// Returns the article's distribution
	//
	const char * multiszDistribution(void) {
			return m_fieldDistribution.multiSzGet();
			};

	//
	// Returns the number of distribution the article will be posted to.
	//
	DWORD cDistribution(void) {
			return m_fieldDistribution.cGet();
			};

	//
	// Return the article's path items
	//

	const char * multiszPath(void) {
			return m_fieldPath.multiSzGet();
			};


	//
	// Return number of path items
	//

	DWORD cPath(void) {
			return m_fieldPath.cGet();
			};

#if 0 
	const char*	GetDate( DWORD&	cbDate )	{
			CPCString	string = m_fieldDate.pcGet() ;
			cbDate = string.m_cch ;
			return	string.m_pch ;
	}
#endif

protected :


	//
	// The fields that will be found, parsed, or set
	//

    CControlField               m_fieldControl;
	CFromPeerDateField			m_fieldDate;
	CFromPeerLinesField			m_fieldLines;
	CFromPeerFromField			m_fieldFrom;
	CFromPeerMessageIDField		m_fieldMessageID;
	CFromPeerSubjectField		m_fieldSubject;
	CFromPeerNewsgroupsField	m_fieldNewsgroups;
	CFromPeerDistributionField	m_fieldDistribution;
	CFromPeerPathField			m_fieldPath;
	CFromPeerXrefField			m_fieldXref;

	//
	// The file should be opened in read/write mode
	//

	BOOL fReadWrite(void) {
			return TRUE;
			}

	//
	// Accept any length
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		};

	//
	// The character following "Field Name:" can be anything
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent)
		{
			return TRUE;
		}

	//
	// For unit testing
	//

	friend int __cdecl main(int argc, char *argv[ ]);

    //
    // For hash table rebuild
    //

    friend BOOL ParseFile(
					CNewsTreeCore* pTree,
                    PCHAR FileName,
                    GROUPID GroupId,
                    ARTICLEID ArticleId,
                    PFILETIME CreationTime
                    );
};



//
//
//
// CFromPeerFeed - for processing incomming articles from a peer.
//


class	CFromPeerFeed:	public CInFeed 	{

	LPSTR	m_lpstrCurrentGroup ;


//
// Public Members
//

public :

	//
	//	function that preserves the current group string we want to work on in our
	//	MULTI_SZ newsgroup pattern
	//
	inline	void	SetCurrentGroupString(	LPSTR	lpstr )	{	m_lpstrCurrentGroup = lpstr ; }

	//
	//	Get the current group string as set by SetCurrentGroupString
	//
	inline	LPSTR	GetCurrentGroupString(	)	{	return	m_lpstrCurrentGroup ;	}

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	virtual	LPSTR	FeedType()	{
				return	"From Peer" ;
				}

	//
	// function that tells if this command is allowed.
	//

	BOOL fIsPostLegal(void) {
			return FALSE;
			};

	//
	// function that tells if this command is allowed.
	//

	BOOL fIsXReplicLegal(void) {
			return FALSE;
			};

		//
		// function that tells if this command is allowed.
		//

	BOOL fIsIHaveLegal(void) {
			return TRUE;
			};

//
// Private Members
//

protected:

	//
	// Create an article of the correct type.
	//

	CARTPTR pArticleCreate(void){
			return new CFromPeerArticle();
			};

	//
	// Don't need to record the message id because it will be
	// record when the message id field gets parsed.
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		}

	//
	// Following is from RFC 977:
	// The server may elect not to post or forward the article if after 
	// further examination of the article it deems it inappropriate to do so. 
	// The 436 or 437 error codes may be returned as appropriate to the situation. 
	// Reasons for such subsequent rejection of an article may include such problems as 
	// inappropriate newsgroups or distributions, disk space limitations, article lengths, 
	// garbled headers, and the like. 	
	//

	NRC	nrcNoGroups(void) {
			return nrcArticleNoSuchGroups;
			};

	//
	// The return code for accepted articles.
	//

	NRC	nrcArticleAccepted(BOOL	fStandardPath) {
			if( fStandardPath ) 
				return nrcArticleTransferredOK;
			else
				return	nrcSTransferredOK ;
			};

	//
	// The return code for rejected articles.
	//

	NRC	nrcArticleRejected(BOOL	fStandardPath) {
			if( fStandardPath ) 
				return nrcTransferFailedGiveUp;
			else
				return	nrcSArticleRejected ;
			};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\fromclnt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.h

Abstract:

    This module contains class declarations/definitions for

		CFromClientFeed

		CFromClientArticle

		CFromClientDateField
		CFromClientExpiresField
        CControlField
		CFromClientFromField
		CFromClientMessageIDField
		CFromClientSubjectField
		CFromClientNNTPPostingHostField
		CFromClientPathField
		CFromClientXrefField
		CFromClientFollowupToField
		CFromClientReplyToField
		CFromClientApprovedField
		CFromClientSenderField
		CFromClientXAuthLoginNameField
		CFromClientOrganizationField
		CFromClientSummaryField
		CFromClientNewsgroupsField
		CFromClientReferencesField
		CFromClientLinesField
		CFromClientDistributionField
		CFromClientKeywordsField


    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used to process articles from clients. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_FROMCLNT_H_
#define	_FROMCLNT_H_

//
//!!!CLIENT LATER - note: not supported yet: control messages
//!!!CLIENT LATER - note: not supported yet: length check (from peer or client)
//!!!CLIENT LATER - note: not supported yet:  character set check
//!!!CLIENT LATER - note: not supported yet: signiture check
//!!!CLIENT NEXT - need both uupc hub name (in lower case) for path and xref *and* local-machine domain name for message-id
//!!!CLIENT NEXT - are dups allowed of any fields?
//!!!CLIENT LATER - reorder lines on output to put more important lines (like message-id) first
//


//
// Forward defintion
//

class	CFromClientArticle;

//
// Tells how to process the Date field in articles from the clients
//

class CFromClientDateField : public CDateField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictDateParse(m_pc, FALSE, nntpReturn);
		};

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Expires field in articles from the clients
//

class CFromClientExpiresField : public CExpiresField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			// if this is not a strict RFC 822 date, check if it is a proper relative date
			if(!fStrictDateParse(m_pc, TRUE, nntpReturn))
				return fRelativeDateParse(m_pc, TRUE, nntpReturn);
			return TRUE;
		};

};

/*
 This header line, if presented, has the same format as "From".  Same set of test cases would apply.  Besides, Tigris server should use this header line to reply to poster/sender, if presented.  This test case should be handled by Server State Integrity Test.
 */
//
// Tells how to process the From field in articles from the clients
//

class CFromClientFromField : public CFromField {
public:

//
// commenting out becuase this code doesn't allow messages that meet
// rfc1468 to be parsed.  we want to just use the default.
//
#if 0
	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
	        CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fSimpleFromParse(m_pc, FALSE, nntpReturn);
		};
#endif

};

//
// Tells how to process the MessageID field in articles from the clients
//

class CFromClientMessageIDField : public CMessageIDField {
public:

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromClientArticle & article,
			CPCString & pcHub,
			CNntpReturn & nntpReturn
			);

	//
	// There should only be one such field in articles from clients.
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};


};

//
// Tells how to process the Subject field in articles from the clients
//

class CFromClientSubjectField : public CSubjectField {
public:

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};

	friend CArticleCore;
	friend CArticle;

};




//
// Tells how to process the NNTPPostingHost field in articles from the clients
//

class CFromClientNNTPPostingHostField : public CNNTPPostingHostField {
public:

	//
	//	NNTP-Posting-Host field should NOT be present in clients
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindNone(article, nntpReturn);
		};

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromClientArticle & article,
			DWORD remoteIpAddress,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Path field in articles from the clients
//

class CFromClientPathField : public CPathField {
public:


	//
	//	Path field need not be present from clients
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CPCString & pcHub, CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Xref field in articles from the clients
//
// Just use the defaults.
//

class CFromClientXrefField : public CXrefField {
public:
};


//
// Tells how to process the FollowupTo field in articles from the clients
//

class CFromClientFollowupToField : public CFollowupToField {

public:

	//
	// Constructor
	//

	CFromClientFollowupToField():
			m_multiSzFollowupTo(NULL),
			m_cFollowupTo((DWORD) -1),
			m_pAllocator(NULL)
			{};

	//
	// Destructor
	//


	virtual ~CFromClientFollowupToField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzFollowupTo);
				}
			};


	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse strictly
	//

	BOOL fParse(
		   CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fStrictNewsgroupsParse(TRUE, m_multiSzFollowupTo, 
						m_cFollowupTo, article, nntpReturn);
		};

private:

	//
	// Points to a list of path items to follow up to
	//

	char * m_multiSzFollowupTo;

	//
	// The number of path items in the FollowupTo value.
	//

	DWORD m_cFollowupTo;

	//
	// Where to allocate from
	//

	CAllocator * m_pAllocator;


};


/*
 This header line, if presented, has the same format as "From".
 */
//
// Tells how to process the ReplyTo field in articles from the clients
//

class CFromClientReplyToField : public CReplyToField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictFromParse(m_pc, TRUE, nntpReturn);
		};

};

//
// Tells how to process the Approved field in articles from the clients
//

class CFromClientApprovedField : public CApprovedField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(FALSE, m_pc, nntpReturn);
		};
};

/* This header line, if presented, has the format as "From" and "Reply-To".  It is presented only if the poster/sender manually enters "From" header line. */
//
// Tells how to process the Sender field in articles from the clients
//

class CFromClientSenderField	: public CSenderField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictFromParse(m_pc, TRUE, nntpReturn);
		};
};


//
// Tells how to process the XAuthLoginName field in articles from the clients
//

class CFromClientXAuthLoginNameField	: public CXAuthLoginNameField {
public:

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Organization field in articles from the clients
//

class CFromClientOrganizationField : public COrganizationField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Summary field in articles from the clients
//

class CFromClientSummaryField : public CSummaryField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};
};

//
// Tells how to process the Newsgroups field in articles from the clients
//

class CFromClientNewsgroupsField : public CNewsgroupsField {

public:

	//
	// Parse strictly
	//

	BOOL fParse(
					CArticleCore & article,
					CNntpReturn & nntpReturn)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fStrictNewsgroupsParse(FALSE, m_multiSzNewsgroups,
							m_cNewsgroups, article, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);

};



//
// Tells how to process the References field in articles from the clients
//

class CFromClientReferencesField : public CReferencesField {
public:

	//
	// Constructor
	//

	CFromClientReferencesField():
			m_multiSzReferences(NULL),
			m_cReferences((DWORD) -1),
			m_pAllocator(NULL)
			{};

	//
	//   Deconstructor
	//

	virtual ~CFromClientReferencesField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzReferences);
				}
			};


	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// How to parse
	//

	BOOL fParse(
	    CArticleCore & article, 
		CNntpReturn & nntpReturn
		);

private:

	//
	// A pointer to a list of the references
	//

	char * m_multiSzReferences;

	//
	// The number of references
	//

	DWORD m_cReferences;

	//
	// Where to allocate from
	//

	CAllocator * m_pAllocator;

};



//
// Tells how to process the Lines field in articles from the clients
//

class CFromClientLinesField : public CLinesField {
public:


	//
	// How to parse
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Distribution field in articles from the clients
//

class CFromClientDistributionField : public CDistributionField {

public:


	//
	// Parse strictly
	//

	BOOL fParse(
					CArticleCore & article,
					CNntpReturn & nntpReturn);

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromClientArticle & article,
			CNntpReturn & nntpReturn
			);

};


//
// Tells how to process the Keywords field in articles from the clients
//

class CFromClientKeywordsField : public CKeywordsField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};
};

//
//
//
// CFromClientArticle - class for manipulating articles from the client.
//

class	CFromClientArticle  : public CArticle {
public:

	//
	// Constructor
	//

	CFromClientArticle(
			char * szLoginName)
		{
			m_szLoginName = szLoginName;
		}

	//
	// Destructor
	//
	virtual ~CFromClientArticle(void) {};

	//
	// The function for validating articles from Clients
	// Check that required headers are there (Newsgroups, From)
	//  this will mean checking for necessary
	//  headers (Newsgroups, Subject, From, ???).
	//

	BOOL fValidate(
			CPCString& pcHub,
			const char * szCommand,
			class	CInFeed*	pInFeed,
			CNntpReturn & nntpReturn
			);

	//
	// Always returns TRUE
	//

	BOOL fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr)
		{
			return nntpr.fSetOK(); //!!!FROMMASTER NEXT may want to implement this
		} 

	//
	// Modify the headers.
	// Add MessageID, Organization (if necessary), NNTP-Posting-Host,
	// X-Authenticated-User, Modify path
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 CNAMEREFLIST & grouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpr,
			 PDWORD pdwLinesOffset = NULL
			 );

	//
	// Return the article's messageid
	//

	const char * szMessageID(void) {
			return m_fieldMessageID.szGet();
			};

    // Return the control message type in the control header of this article
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			return m_fieldControl.cmGetControlMessage();
			};

	//
	// Return the article's path items
	//

	const char * multiszNewsgroups(void) {
			return m_fieldNewsgroups.multiSzGet();
			};

	//
	// Return number of newsgroups
	//

	DWORD cNewsgroups(void) {
			return m_fieldNewsgroups.cGet();
			};

	//
	// Return the article's path items
	//

	const char * multiszPath(void) {
			return m_fieldPath.multiSzGet();
			};

	//
	// Return number of path items
	//

	DWORD cPath(void) {
			return m_fieldPath.cGet();
			};

#if 0 
	const char*	GetDate( DWORD&	cbDate )	{
			CPCString	string = m_fieldDate.pcGet() ;
			cbDate = string.m_cch ;
			return	string.m_pch ;
	}
#endif

	friend CFromClientXAuthLoginNameField;

	//
	// For unit testing
	//

	friend int __cdecl main(int argc, char *argv[ ]);

protected :

	//
	// The fields that will be found, parsed, or set
	//

	CFromClientDateField			m_fieldDate;
	CFromClientFromField			m_fieldFrom;
	CFromClientMessageIDField		m_fieldMessageID;
	CFromClientSubjectField			m_fieldSubject;
	CFromClientNewsgroupsField		m_fieldNewsgroups;
	CFromClientPathField			m_fieldPath;
	CFromClientXrefField			m_fieldXref;
	CFromClientFollowupToField		m_fieldFollowupTo;
	CFromClientReplyToField			m_fieldReplyTo;
	CFromClientApprovedField		m_fieldApproved;
	CFromClientSenderField			m_fieldSender;
	CFromClientOrganizationField	m_fieldOrganization;
	CFromClientNNTPPostingHostField	m_fieldNNTPPostingHost;
	CFromClientXAuthLoginNameField	m_fieldXAuthLoginName;
	CFromClientSummaryField			m_fieldSummary;
	CFromClientReferencesField		m_fieldReferences;
	CFromClientKeywordsField		m_fieldKeyword;
 	CFromClientDistributionField	m_fieldDistribution;
    CControlField                   m_fieldControl;
 	CFromClientLinesField			m_fieldLines;
 	CFromClientExpiresField			m_fieldExpires;
 
	//
	// Open the article's file in Read/Write mode.
	//

	BOOL fReadWrite(void) {
			return TRUE;
			}

	//
	// Check the length of the article body.
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn
			);

	//
	// Require that the character following "Field Name:" is a space
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent)
		{
			return ' ' == chCurrent;
		}

	//
	// A pointer to the poster's login name.
	//

	char * m_szLoginName;
};



//
//
//
// CFromClientFeed - for processing incomming articles from clients.
//

class	CFromClientFeed:	public CInFeed 	{

//
// Public Members
//

public :

	//
	// Constructor
	//

	CFromClientFeed(void){};

	//
	// Destructor
	//

	virtual ~CFromClientFeed(void) {};

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"From Client" ;
				}


	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsPostLegal(void) {
			return TRUE;
			};

	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsXReplicLegal(void) {
			return FALSE;
			};

	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsIHaveLegal(void) {
			return FALSE;
			};

	//
	// function that tells fPost path that we can email moderators !
	//

    BOOL fModeratorChecks(void )    {
            return  TRUE ;
            }

	BOOL	fAcceptPosts( CNntpServerInstanceWrapper *pInstance )	
	{	return	pInstance->AllowClientPosts() ;	}


	DWORD	cbHardLimit( CNntpServerInstanceWrapper *pInstance )	
	{	return	pInstance->ServerHardLimit() ;	}

	DWORD	cbSoftLimit( CNntpServerInstanceWrapper *pInstance )	
	{	return	pInstance->ServerSoftLimit() ;	}	

	BOOL	fAllowControlMessages( CNntpServerInstanceWrapper *pInstance )	
	{	return	pInstance->AllowControlMessages() ;	}

	//
	// static function which handles picking up files from the pickup
	// directory
	//
	static BOOL PickupFile(PVOID pServerInstance, WCHAR *wszFilename);

protected:

	//
	// Function to create an article of type CFromClientArticle
	//

	CARTPTR pArticleCreate(void) {
			_ASSERT(ifsInitialized == m_feedState);
			return new CFromClientArticle(m_szLoginName);
			};

	//
	// Records the mesage id in the hash table
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn
			);

	//
	// The return code for article's with no groups that we have.
	//

	NRC	nrcNoGroups(void) {
			return nrcArticleNoSuchGroups;
			};

	//
	// Return code for accepted articles
	//

	NRC	nrcArticleAccepted(BOOL	fStandardPath) {
			return nrcArticlePostedOK;
			};

	//
	// Return code for rejected articles.
	//

	NRC	nrcArticleRejected(BOOL	fStandardPath) {
			return nrcPostFailed;
			};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\frmstore.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.h

Abstract:

    This module contains class declarations/definitions for

		CFromStoreFeed

		CFromStoreArticle

		CFromStoreDateField
		CFromStoreExpiresField
        CControlField
		CFromStoreFromField
		CFromStoreMessageIDField
		CFromStoreSubjectField
		CFromStoreNNTPPostingHostField
		CFromStorePathField
		CFromStoreXrefField
		CFromStoreFollowupToField
		CFromStoreReplyToField
		CFromStoreApprovedField
		CFromStoreSenderField
		CFromStoreXAuthLoginNameField
		CFromStoreOrganizationField
		CFromStoreSummaryField
		CFromStoreNewsgroupsField
		CFromStoreReferencesField
		CFromStoreLinesField
		CFromStoreDistributionField
		CFromStoreKeywordsField


    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used to process articles from clients. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:


--*/

#ifndef	_FROMSTORE_H_
#define	_FROMSTORE_H_

//
//!!!CLIENT LATER - note: not supported yet: control messages
//!!!CLIENT LATER - note: not supported yet: length check (from peer or client)
//!!!CLIENT LATER - note: not supported yet:  character set check
//!!!CLIENT LATER - note: not supported yet: signiture check
//!!!CLIENT NEXT - need both uupc hub name (in lower case) for path and xref *and* local-machine domain name for message-id
//!!!CLIENT NEXT - are dups allowed of any fields?
//!!!CLIENT LATER - reorder lines on output to put more important lines (like message-id) first
//


//
// Forward defintion
//

class	CFromStoreArticle;

//
// Tells how to process the Date field in articles from the clients
//

class CFromStoreDateField : public CDateField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictDateParse(m_pc, FALSE, nntpReturn);
		};

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Expires field in articles from the clients
//

class CFromStoreExpiresField : public CExpiresField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			// if this is not a strict RFC 822 date, check if it is a proper relative date
			if(!fStrictDateParse(m_pc, TRUE, nntpReturn))
				return fRelativeDateParse(m_pc, TRUE, nntpReturn);
			return TRUE;
		};

};

/*
 This header line, if presented, has the same format as "From".  Same set of test cases would apply.  Besides, Tigris server should use this header line to reply to poster/sender, if presented.  This test case should be handled by Server State Integrity Test.
 */
//
// Tells how to process the From field in articles from the clients
//

class CFromStoreFromField : public CFromField {
public:

//
// commenting out becuase this code doesn't allow messages that meet
// rfc1468 to be parsed.  we want to just use the default.
//
#if 0
	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
	        CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fSimpleFromParse(m_pc, FALSE, nntpReturn);
		};
#endif

};

//
// Tells how to process the MessageID field in articles from the clients
//

class CFromStoreMessageIDField : public CMessageIDField {
public:

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromStoreArticle & article,
			CPCString & pcHub,
			CNntpReturn & nntpReturn
			);

	//
	// There should only be one such field in articles from clients.
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};


};

//
// Tells how to process the Subject field in articles from the clients
//

class CFromStoreSubjectField : public CSubjectField {
public:

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};

	friend CArticleCore;
	friend CArticle;

};




//
// Tells how to process the NNTPPostingHost field in articles from the clients
//

class CFromStoreNNTPPostingHostField : public CNNTPPostingHostField {
public:

	//
	//	NNTP-Posting-Host field should NOT be present in clients
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindNone(article, nntpReturn);
		};

	//
	// How to set the field.
	//

	BOOL fSet(
			CFromStoreArticle & article,
			DWORD remoteIpAddress,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Path field in articles from the clients
//

class CFromStorePathField : public CPathField {
public:


	//
	//	Path field need not be present from clients
	//
	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CPCString & pcHub, CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Xref field in articles from the clients
//
// Just use the defaults.
//

class CFromStoreXrefField : public CXrefField {
public:
};


//
// Tells how to process the FollowupTo field in articles from the clients
//

class CFromStoreFollowupToField : public CFollowupToField {

public:

	//
	// Constructor
	//

	CFromStoreFollowupToField():
			m_multiSzFollowupTo(NULL),
			m_cFollowupTo((DWORD) -1),
			m_pAllocator(NULL)
			{};

	//
	// Destructor
	//


	virtual ~CFromStoreFollowupToField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzFollowupTo);
				}
			};


	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse strictly
	//

	BOOL fParse(
		   CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fStrictNewsgroupsParse(TRUE, m_multiSzFollowupTo, 
						m_cFollowupTo, article, nntpReturn);
		};

private:

	//
	// Points to a list of path items to follow up to
	//

	char * m_multiSzFollowupTo;

	//
	// The number of path items in the FollowupTo value.
	//

	DWORD m_cFollowupTo;

	//
	// Where to allocate from
	//

	CAllocator * m_pAllocator;


};


/*
 This header line, if presented, has the same format as "From".
 */
//
// Tells how to process the ReplyTo field in articles from the clients
//

class CFromStoreReplyToField : public CReplyToField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictFromParse(m_pc, TRUE, nntpReturn);
		};

};

//
// Tells how to process the Approved field in articles from the clients
//

class CFromStoreApprovedField : public CApprovedField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(FALSE, m_pc, nntpReturn);
		};
};

/* This header line, if presented, has the format as "From" and "Reply-To".  It is presented only if the poster/sender manually enters "From" header line. */
//
// Tells how to process the Sender field in articles from the clients
//

class CFromStoreSenderField	: public CSenderField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// The field should be strictly parsed.
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fStrictFromParse(m_pc, TRUE, nntpReturn);
		};
};


//
// Tells how to process the XAuthLoginName field in articles from the clients
//

class CFromStoreXAuthLoginNameField	: public CXAuthLoginNameField {
public:

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Organization field in articles from the clients
//

class CFromStoreOrganizationField : public COrganizationField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Summary field in articles from the clients
//

class CFromStoreSummaryField : public CSummaryField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};
};

//
// Tells how to process the Newsgroups field in articles from the clients
//

class CFromStoreNewsgroupsField : public CNewsgroupsField {

public:

	//
	// Parse strictly
	//

	BOOL fParse(
					CArticleCore & article,
					CNntpReturn & nntpReturn)
		{
			//
			// Record the allocator
			//

			m_pAllocator = article.pAllocator();

			return fStrictNewsgroupsParse(FALSE, m_multiSzNewsgroups,
							m_cNewsgroups, article, nntpReturn);
		};

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);

};



//
// Tells how to process the References field in articles from the clients
//

class CFromStoreReferencesField : public CReferencesField {
public:

	//
	// Constructor
	//

	CFromStoreReferencesField():
			m_multiSzReferences(NULL),
			m_cReferences((DWORD) -1),
			m_pAllocator(NULL)
			{};

	//
	//   Deconstructor
	//

	virtual ~CFromStoreReferencesField(void){
				if (fsParsed == m_fieldState)
				{
					_ASSERT(m_pAllocator);
					m_pAllocator->Free(m_multiSzReferences);
				}
			};


	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// How to parse
	//

	BOOL fParse(
	    CArticleCore & article, 
		CNntpReturn & nntpReturn
		);

private:

	//
	// A pointer to a list of the references
	//

	char * m_multiSzReferences;

	//
	// The number of references
	//

	DWORD m_cReferences;

	//
	// Where to allocate from
	//

	CAllocator * m_pAllocator;

};



//
// Tells how to process the Lines field in articles from the clients
//

class CFromStoreLinesField : public CLinesField {
public:


	//
	// How to parse
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn
			);
};

//
// Tells how to process the Distribution field in articles from the clients
//

class CFromStoreDistributionField : public CDistributionField {

public:


	//
	// Parse strictly
	//

	BOOL fParse(
					CArticleCore & article,
					CNntpReturn & nntpReturn);

	//
	// How to set the field.
	//
	
	BOOL fSet(
			CFromStoreArticle & article,
			CNntpReturn & nntpReturn
			);

};


//
// Tells how to process the Keywords field in articles from the clients
//

class CFromStoreKeywordsField : public CKeywordsField {
public:

	//
	// There should only be one such field in articles from clients.
	//

	BOOL fFind(
			CArticleCore & article,
			CNntpReturn & nntpReturn)
		{
			return fFindOneOrNone(article, nntpReturn);
		};

	//
	// Parse with ParseSimple
	//

	BOOL fParse(
		    CArticleCore & article, 
			CNntpReturn & nntpReturn)
		{
			return fParseSimple(TRUE, m_pc, nntpReturn);
		};
};

//
//
//
// CFromStoreArticle - class for manipulating articles from the client.
//

class	CFromStoreArticle  : public CArticleCore {
private :

	// Used for memory allocation
	static	CPool	g_ArticlePool ;

public:

	// Used for memory allocation
	static	BOOL	InitClass() ;
	static	BOOL	TermClass() ;
	void*	operator	new(	size_t	size ) ;
	void	operator	delete( void *pv ) ;

	//
	//   Constructor
    //  Initialization Interface -
    //   The following functions are used to create & destroy newsgroup objects.
    //
    // Lightweight Constructors -
    // These constructors do very simple initialization.  The Init() functions
    // need to be called to get a functional newsgroup.
    //

	CFromStoreArticle(char *pszLoginName = NULL) : CArticleCore()
        {
            m_szLoginName = pszLoginName;
        }

	//
	// Destructor
	//
	virtual ~CFromStoreArticle(void) {}

	//
	// The function for validating articles from Stores
	// Check that required headers are there (Newsgroups, From)
	//  this will mean checking for necessary
	//  headers (Newsgroups, Subject, From, ???).
	//

	BOOL fValidate(
			//CPCString& pcHub,
			//const char * szCommand,
			//class	CInFeed*	pInFeed,
			CNntpReturn & nntpReturn
			);

	//
	// Always returns TRUE
	//

	BOOL fCheckCommandLine(
			char const * szCommand,
			CNntpReturn & nntpr)
		{
			return nntpr.fSetOK(); //!!!FROMMASTER NEXT may want to implement this
		} 

	//
	// Modify the headers.
	// Add MessageID, Organization (if necessary), NNTP-Posting-Host,
	// X-Authenticated-User, Modify path
	//

	BOOL fMungeHeaders(
			 CPCString& pcHub,
			 CPCString& pcDNS,
			 //CNAMEREFLIST & grouplist,
			 DWORD remoteIpAddress,
			 CNntpReturn & nntpr
			 );

	//
	// Return the article's messageid
	//

	const char * szMessageID(void) {
			return m_fieldMessageID.szGet();
			};

    // Return the control message type in the control header of this article
	CONTROL_MESSAGE_TYPE cmGetControlMessage(void) {
			return m_fieldControl.cmGetControlMessage();
			};

	//
	// Return the article's path items
	//

	const char * multiszNewsgroups(void) {
			return m_fieldNewsgroups.multiSzGet();
			};

	//
	// Return number of newsgroups
	//

	DWORD cNewsgroups(void) {
			return m_fieldNewsgroups.cGet();
			};

	//
	// Return the article's path items
	//

	const char * multiszPath(void) {
			return m_fieldPath.multiSzGet();
			};

	//
	// Return number of path items
	//

	DWORD cPath(void) {
			return m_fieldPath.cGet();
			};

#if 0 
	const char*	GetDate( DWORD&	cbDate )	{
			CPCString	string = m_fieldDate.pcGet() ;
			cbDate = string.m_cch ;
			return	string.m_pch ;
	}
#endif

	friend CFromStoreXAuthLoginNameField;

	//
	// For unit testing
	//

	friend int __cdecl main(int argc, char *argv[ ]);

protected :

	//
	// The fields that will be found, parsed, or set
	//

	CFromStoreDateField			m_fieldDate;
	CFromStoreFromField			m_fieldFrom;
	CFromStoreMessageIDField		m_fieldMessageID;
	CFromStoreSubjectField			m_fieldSubject;
	CFromStoreNewsgroupsField		m_fieldNewsgroups;
	CFromStorePathField			m_fieldPath;
	CFromStoreXrefField			m_fieldXref;
	CFromStoreFollowupToField		m_fieldFollowupTo;
	CFromStoreReplyToField			m_fieldReplyTo;
	CFromStoreApprovedField		m_fieldApproved;
	CFromStoreSenderField			m_fieldSender;
	CFromStoreOrganizationField	m_fieldOrganization;
	CFromStoreNNTPPostingHostField	m_fieldNNTPPostingHost;
	CFromStoreXAuthLoginNameField	m_fieldXAuthLoginName;
	CFromStoreSummaryField			m_fieldSummary;
	CFromStoreReferencesField		m_fieldReferences;
	CFromStoreKeywordsField		m_fieldKeyword;
 	CFromStoreDistributionField	m_fieldDistribution;
    CControlField                   m_fieldControl;
 	CFromStoreLinesField			m_fieldLines;
 	CFromStoreExpiresField			m_fieldExpires;
 
	//
	// Open the article's file in Read/Write mode.
	//

	BOOL fReadWrite(void) {
			return FALSE;
			}

	//
	// Check the length of the article body.
	//

	BOOL fCheckBodyLength(
			CNntpReturn & nntpReturn
			);

	//
	// Require that the character following "Field Name:" is a space
	//

	BOOL fCheckFieldFollowCharacter(
			char chCurrent)
		{
			return ' ' == chCurrent;
		}

	//
	// A pointer to the poster's login name.
	//

	char * m_szLoginName;
};


#if 0 // CFromStoreFeed

//
//
//
// CFromStoreFeed - for processing incomming articles from clients.
//

class	CFromStoreFeed:	public CInFeed 	{

//
// Public Members
//

public :

	//
	// Constructor
	//

	CFromStoreFeed(void){};

	//
	// Destructor
	//

	virtual ~CFromStoreFeed(void) {};

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"From Store" ;
				}


	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsPostLegal(void) {
			return TRUE;
			};

	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsXReplicLegal(void) {
			return FALSE;
			};

	//
	// virtual function that tells if this command is allowed.
	//

	BOOL fIsIHaveLegal(void) {
			return FALSE;
			};

	//
	// function that tells fPost path that we can email moderators !
	//

    BOOL fModeratorChecks(void )    {
            return  TRUE ;
            }

	BOOL	fAcceptPosts( CNntpServerInstanceWrapper *pInstance )	
#ifdef BUGBUG
	{	return	pInstance->FAllowStorePosts() ;	}
#else
	{ return TRUE; }
#endif


	DWORD	cbHardLimit( CNntpServerInstanceWrapper *pInstance )	
#ifdef BUGBUG
	{	return	pInstance->ServerHardLimit() ;	}
#else 
	{ return 1000000000; }
#endif

	DWORD	cbSoftLimit( CNntpServerInstanceWrapper *pInstance )	
#ifdef BUGBUG
	{	return	pInstance->ServerSoftLimit() ;	}	
#else 
	{ return 1000000000; }
#endif

	BOOL	fAllowControlMessages( CNntpServerInstanceWrapper *pInstance )	
#ifdef BUGBUG
	{	return	pInstance->FAllowControlMessages() ;	}
#else
	{ return TRUE; }
#endif

	//
	// static function which handles picking up files from the pickup
	// directory
	//
	static BOOL PickupFile(PVOID pServerInstance, WCHAR *wszFilename);

protected:

	//
	// Function to create an article of type CFromStoreArticle
	//

	CARTPTR pArticleCreate(void) {
			_ASSERT(ifsInitialized == m_feedState);
			return new CFromStoreArticle(m_szLoginName);
			};

	//
	// Records the mesage id in the hash table
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn
			);

	//
	// The return code for article's with no groups that we have.
	//

	NRC	nrcNoGroups(void) {
			return nrcArticleNoSuchGroups;
			};

	//
	// Return code for accepted articles
	//

	NRC	nrcArticleAccepted(BOOL	fStandardPath) {
			return nrcArticlePostedOK;
			};

	//
	// Return code for rejected articles.
	//

	NRC	nrcArticleRejected(BOOL	fStandardPath) {
			return nrcPostFailed;
			};

};

#endif // #if 0 CFromStoreFeed

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\fixprop.inl ===
////////////////////////////////////////////////////////
// Inline functions for CFreeInfo's new, delete
inline  void*
CFreeInfo::operator  new(    size_t  size )
{
    _ASSERT( size <= MAX_FREEINFO_SIZE ) ;

	CFreeInfo *ptr;

	ptr = (CFreeInfo*)g_FreeInfoPool.Alloc();
	if ( NULL == ptr )  {// use exchmem
		ptr = (CFreeInfo*)PvAlloc( size );
		if ( ptr ) ptr->m_bFromPool = FALSE;
	} else ptr->m_bFromPool = TRUE;
    return  ptr ;
}

inline  void
CFreeInfo::operator  delete( void*   pv )
{
	CFreeInfo *ptr = (CFreeInfo *)pv;

	if ( ptr->m_bFromPool )
    	g_FreeInfoPool.Free( pv ) ;
	else {
		FreePv( ptr );
	}
}

////////////////////////////////////////////////////////
// Inline functions for CFixPropPersist
inline VOID
CFixPropPersist::Group2Buffer(	IN DATA_BLOCK& dbBuffer,
								IN INNTPPropertyBag* pPropBag,
								IN DWORD dwFlag )
/*++
Routine description:

	Fill in the fixed property block with group property bag's
	values.  "dwFlag" tells me which properties to fill in.

Arguments:

	IN DATA_BLOCK& dbBuffer - Buffer to fill in
	IN INNTPPropertyBag* pPropBag - Property bag of the news group
	IN DWORD dwFlag - Bit mask that tells which properties to fill

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	_ASSERT( pPropBag );
	HRESULT hr;
	DWORD	dwBufferLen;

	if ( ( dwFlag & FIX_PROP_NAME ) != 0 ) {
		dwBufferLen = GROUPNAME_LEN_MAX;
		hr = pPropBag->GetBLOB( 	NEWSGRP_PROP_NAME, 
									(UCHAR*)dbBuffer.szGroupName, 
									&dwBufferLen );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_NAMELEN ) != 0 ) {
		hr = pPropBag->GetDWord( 	NEWSGRP_PROP_NAMELEN, 
									&dbBuffer.dwGroupNameLen );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_GROUPID ) != 0 ) {
		hr = pPropBag->GetDWord(	NEWSGRP_PROP_GROUPID,
									&dbBuffer.dwGroupId );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_LASTARTICLE ) != 0 ) {
		hr = pPropBag->GetDWord( 	NEWSGRP_PROP_LASTARTICLE, 
									&dbBuffer.dwHighWaterMark );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_FIRSTARTICLE ) != 0 ) {
		hr = pPropBag->GetDWord(	NEWSGRP_PROP_FIRSTARTICLE,
									&dbBuffer.dwLowWaterMark );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_ARTICLECOUNT ) != 0 ) {
		hr = pPropBag->GetDWord( 	NEWSGRP_PROP_ARTICLECOUNT,
									&dbBuffer.dwArtCount );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_READONLY ) != 0 ) {
		hr = pPropBag->GetBool(	NEWSGRP_PROP_READONLY,
								&dbBuffer.bReadOnly );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_ISSPECIAL ) != 0 ) {
		hr = pPropBag->GetBool( NEWSGRP_PROP_ISSPECIAL,
								&dbBuffer.bSpecial );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_DATELOW ) != 0 ) {
		hr = pPropBag->GetDWord(	NEWSGRP_PROP_DATELOW,
									&dbBuffer.ftCreateDate.dwLowDateTime );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_DATEHIGH ) != 0 ) {
		hr = pPropBag->GetDWord(	NEWSGRP_PROP_DATEHIGH,
									&dbBuffer.ftCreateDate.dwHighDateTime );
		_ASSERT( SUCCEEDED ( hr ) ) ;
	}
}

inline VOID
CFixPropPersist::Buffer2Group(	IN DATA_BLOCK& dbBuffer,
								IN INNTPPropertyBag* pPropBag,
								IN DWORD dwFlag )
/*++
Routine description:

	Load the properties from buffer into group.

Arguments:

	IN DATA_BLOCK& dbBuffer - Buffer to load property from
	IN INNTPPropertyBag* pPropBag - Property bag of the news group
	IN DWORD dwFlag - Bit mask that tells which properties to load

Return value:

	TRUE on success, FALSE otherwise
--*/
{
	_ASSERT( pPropBag );
	HRESULT hr;

	if ( ( dwFlag & FIX_PROP_NAME ) != 0 ) {
		_ASSERT( 0 ) ;	// not allowed
	}

	if ( ( dwFlag & FIX_PROP_NAMELEN ) != 0 ) {
		_ASSERT( 0 ) ;  // now allowed
	}

	if ( ( dwFlag & FIX_PROP_LASTARTICLE ) != 0 ) {
		hr = pPropBag->PutDWord( 	NEWSGRP_PROP_LASTARTICLE, 
									dbBuffer.dwHighWaterMark );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_FIRSTARTICLE ) != 0 ) {
		hr = pPropBag->PutDWord(	NEWSGRP_PROP_FIRSTARTICLE,
									dbBuffer.dwLowWaterMark );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_GROUPID ) != 0 ) {
		hr = pPropBag->PutDWord( 	NEWSGRP_PROP_GROUPID,
									dbBuffer.dwGroupId );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_ARTICLECOUNT ) != 0 ) {
		hr = pPropBag->PutDWord( 	NEWSGRP_PROP_ARTICLECOUNT,
									dbBuffer.dwArtCount );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_READONLY ) != 0 ) {
		hr = pPropBag->PutBool(	NEWSGRP_PROP_READONLY,
								dbBuffer.bReadOnly );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_ISSPECIAL ) != 0 ) {
		hr = pPropBag->PutBool( NEWSGRP_PROP_ISSPECIAL,
								dbBuffer.bSpecial );
		_ASSERT( SUCCEEDED( hr ) );
	}

	if ( ( dwFlag & FIX_PROP_DATELOW ) != 0 ) {
		hr = pPropBag->PutDWord(	NEWSGRP_PROP_DATELOW,
									dbBuffer.ftCreateDate.dwLowDateTime );
		_ASSERT( SUCCEEDED( hr ) ) ;
	}

	if ( ( dwFlag & FIX_PROP_DATEHIGH ) != 0 ) {
		hr = pPropBag->PutDWord(	NEWSGRP_PROP_DATEHIGH,
									dbBuffer.ftCreateDate.dwHighDateTime );
		_ASSERT( SUCCEEDED ( hr ) ) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\grouplst.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    grouplst.h

Abstract:

    This module contains class declarations/definitions for

		CGroupList




    **** Overview ****

	This defines list object using templates and object.
	This list will be used to represent list of newsgroup objects
	and lists of newsgroup information (name, groupid, article id).

    It is designed to be as much like the MPC List type as possible.

Author:

    Carl Kadie (CarlK)     29-Oct-1995

Revision History:


--*/

#ifndef	_GROUPLST_H_
#define	_GROUPLST_H_

#include <xmemwrpr.h>
#include "tigmem.h"

//
// The type of a position in the list.
//

typedef void * POSITION;

//
//
//
// CGroupList - template class defining a simple list.
//

#ifndef	_NO_TEMPLATES_

template<class ITEM>
class CGroupList {

public :

   //
   // Constructor - creates a null GroupList
   //

	CGroupList() ;

	//
	// Init - the maximum size of the list must be given
	//

	BOOL fInit(
			DWORD cMax,
			CAllocator * pAllocator
		) ;

	BOOL fAsBeenInited(void) ;
		   
    //
	// Destructor - the memory allocated for the list is freed.
	//

	~CGroupList(void) ;

	//
	// Returns the head position
	//

	POSITION GetHeadPosition() ;

	//
	// Get current item and move the POSITION to the next item
	//

	ITEM * GetNext(POSITION & pos);

	//
	// Get the current item.
	//

	ITEM * Get(POSITION & pos);

	//
	// Get the first item.
	//

	ITEM * GetHead();

	//
	// True if the list is empty
	//

	BOOL IsEmpty() ;

	//
	// Add an item to the end of the list.
	//

	POSITION AddTail(ITEM & item);

	//
	// sort the array of items.  fncmp should take two pointers to ITEMs 
	// and act like strcmp
	//

	void Sort(int (__cdecl *fncmp)(const void *, const void *));

	//
	// Remove all the items in the list
	//

	void RemoveAll() ;

	//
	// Remove the item from the list
	//

	void Remove(POSITION & pos) ;
	

	//
	// Return the size of the list
	//

	DWORD GetCount(void) ;

private:

	//
	// One more than the number of items allowed in the list
	//

	DWORD m_cMax;

	//
	// The index of the last item i the list
	//

	DWORD m_cLast;

	//
	// Pointer to the dynamically allocated array of items
	//

	ITEM * m_rgpItem;

	//
	// Pointer to the memory allocator
	//
	CAllocator * m_pAllocator;

	//
	// This stops call-by-value calls
	//

	CGroupList( CGroupList& ) ;
};

#else

#define	DECLARE_GROUPLST( ITEM )	\
class CGroupList ## ITEM {	\
public :	\
	CGroupList ## ITEM () ;	\
	BOOL fInit(	\
			DWORD cMax,	\
			CAllocator * pAllocator	\
		) ;	\
	BOOL fAsBeenInited(void) ;	\
	~CGroupList ## ITEM (void) ;	\
	POSITION GetHeadPosition() ;	\
	ITEM * GetNext(POSITION & pos);	\
	ITEM * Get(POSITION & pos);	\
	ITEM * GetHead();	\
	BOOL IsEmpty() ;	\
	POSITION AddTail(ITEM & item);	\
	POSITION Remove();	\
	void RemoveAll() ;	\
	DWORD GetCount(void);	\
private:	\
	DWORD m_cMax;	\
	DWORD m_cLast;	\
	ITEM * m_rgpItem;	\
	CAllocator * m_pAllocator;	\
	CGroupList ## ITEM ( CGroupList ## ITEM & ) ;	\
};

#define	INVOKE_GROUPLST( ITEM )	CGroupList ## ITEM


#endif

#include "grouplst.inl"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\instwpex.h ===
#ifndef __INSTWPEX_H__
#define __INSTWPEX_H__
//
// This class wraps up the important stuff in PNNTP_SERVER_INSTANCE for
// use by the newstree
//

class CNewsGroupCore;

class CNntpServerInstanceWrapperEx {
    public:
        virtual void AdjustWatermarkIfNec( CNewsGroupCore *pGroup ) = 0;
        virtual void SetWin32Error( LPSTR szVRootPath, DWORD dwErr ) = 0;
        virtual PCHAR PeerTempDirectory() = 0 ;
        virtual BOOL EnqueueRmgroup( CNewsGroupCore *pGroup ) = 0;
        virtual DWORD GetInstanceId() = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\group.h ===
#ifndef __GROUP_H__
#define __GROUP_H__

#include "nntpvr.h"
#include <refptr2.h>
#include "nntpbag.h"

class CNewsTreeCore;

#define GROUP_LOCK_ARRAY_SIZE 256
#define CACHE_HIT_THRESHOLD 16
#define CACHE_HIT_MAX       256

//
// reference counting works on this object as follows:
//
// In CNewsTreeCore there should be one reference for this object when it is
// in the linked list and hash tables.  This reference is the first reference
// on the object which is obtained when it is created.  This reference is
// removed when the object is no longer in the hash tables.  It will remove
// itself from the list when its reference count goes to 0.
//
// Other users of this object should use the CRefPtr2 class to manage the
// reference count.  The Property Bag also uses the same reference count,
// so the newsgroup won't be destroyed as long as someone has a reference
// to its property bag.
//

// signature for healthy group objects
#define CNEWSGROUPCORE_SIGNATURE		(DWORD) 'CprG'
// signature for deleted group objects
#define CNEWSGROUPCORE_SIGNATURE_DEL	(DWORD) 'GrpC'

class CNewsGroupCore : public CRefCount2 {
	public:

        friend class CNNTPPropertyBag;

        //
        // For debug version, we'll wrap its AddRef and Release
        // to spit out some dbg traces, since this guys is very
        // often leaked
        //

#ifdef NEVER
#error Why is NEVER defined?
        LONG AddRef()
        {
            TraceQuietEnter("CNewsGroupCore::AddRef");
            DebugTrace( 0,
                        "Group %s AddRef to %d", 
                        m_pszGroupName,
                        m_cRefs + 1 );
            return CRefCount2::AddRef();
        }

        void Release()
        {
            TraceQuietEnter("CNewsGroupCore::Release" );
            DebugTrace( 0, 
                        "Group %s Release to %d",
                        m_pszGroupName,
                        m_cRefs - 1 );
            CRefCount2::Release();
        }
#endif

		CNewsGroupCore(CNewsTreeCore *pNewsTree) {
			TraceQuietEnter("CNewsGroupCore::CNewsGroupCore");

			m_dwSignature = CNEWSGROUPCORE_SIGNATURE;
			m_pNewsTree = pNewsTree;
			m_pNext = NULL;
			m_pPrev = NULL;
			m_pVRoot = NULL;
			m_iLowWatermark = 1;
			m_iHighWatermark = 0;
			m_cMessages = 0;
			m_pszGroupName = NULL;
			m_cchGroupName = 0;
			m_pszNativeName = NULL;
			m_dwGroupId = 0;
			m_fReadOnly = FALSE;
			m_fDeleted = FALSE;
			m_fSpecial = FALSE;
			m_pNextByName = NULL;
			m_pNextById = NULL;
			m_dwHashId = 0;
			m_iOffset = 0;
			m_pszHelpText = NULL;
			m_pszModerator = NULL;
			m_pszPrettyName = NULL;
			m_cchHelpText = 0;
			m_cchModerator = 0;
			m_cchPrettyName = 0;
			m_iOffset = 0;
			m_fVarPropChanged = TRUE;
			m_fDecorateVisited = FALSE;
			m_fControlGroup = FALSE;
			m_dwCacheHit = 0;
            m_artXoverExpireLow = 0;
            m_fAllowExpire = FALSE;
            m_fAllowPost = FALSE;
            m_PropBag.Init( this, &m_cRefs );
		}

		virtual ~CNewsGroupCore();

#ifdef DEBUG
		void VerifyGroup() {
            _ASSERT( m_iLowWatermark >= 1 );
			_ASSERT(m_pNewsTree != NULL);
		}
#else
		void VerifyGroup() { }
#endif

		//
		// these classes grab the appropriate lock
		//
		void ShareLock() {
			VerifyGroup();
			m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ShareLock();
		}
		void ShareUnlock() {
			VerifyGroup();
			m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ShareUnlock();
		}
		void ExclusiveLock() {
			// we don't do a verify here because this is called before
			// Init has done its magic
			m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ExclusiveLock();
		}
		void ExclusiveUnlock() {
			VerifyGroup();
			m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ExclusiveUnlock();
		}
        void ExclusiveToShared() {
            VerifyGroup();
            m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].ExclusiveToShared();
        }
        BOOL SharedToExclusive() {
            VerifyGroup();
            return m_rglock[m_dwGroupId % GROUP_LOCK_ARRAY_SIZE].SharedToExclusive();
        }

		//
		// these two classes wrap the locking and unlocking process for us
		// when they are created on the stack in accessor methods
		//
		class CGrabShareLock {
			public:
				CGrabShareLock(CNewsGroupCore *pThis) {
					m_pThis = pThis;
					m_pThis->ShareLock();
				}
				~CGrabShareLock() {
					m_pThis->ShareUnlock();
				}
			private:
				CNewsGroupCore *m_pThis;
		};

		//
		// initialize with good values
		//
		BOOL Init(char *pszGroupName,
				  char *pszNativeName,
				  DWORD dwGroupId,
				  NNTPVROOTPTR pVRoot,
				  BOOL fSpecial = FALSE)
		{

			BOOL fOK = TRUE;
			m_dwGroupId = dwGroupId;

			ExclusiveLock();

			m_pVRoot = pVRoot;
			if (m_pVRoot) m_pVRoot->AddRef();

			_ASSERT(pszGroupName != NULL);
			m_cchGroupName = strlen(pszGroupName) + 1 ;
			m_pszGroupName = XNEW char[m_cchGroupName + 1];
			if (!m_pszGroupName) {
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				fOK = FALSE;
				goto Exit;
			}
			strcpy(m_pszGroupName, pszGroupName);

			// check to see if this is one of the three control groups
			if ((strcmp(m_pszGroupName, "control.cancel") == 0) ||
			    (strcmp(m_pszGroupName, "control.newgroup") == 0) ||
				(strcmp(m_pszGroupName, "control.rmgroup") == 0))
			{
				m_fControlGroup = TRUE;
			}

			// make sure that both names are the same except for case
			if (pszNativeName != NULL) {
				_ASSERT(_stricmp(pszNativeName, pszGroupName) == 0);
				m_pszNativeName = XNEW char[m_cchGroupName + 1];
				if (!m_pszNativeName) {
					SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					fOK = FALSE;
					goto Exit;
				}
				strcpy(m_pszNativeName, pszNativeName);
			} else {
				m_pszNativeName = NULL;
			}

		    m_dwHashId = CRCHash((BYTE *) m_pszGroupName, m_cchGroupName);

			m_fSpecial = fSpecial;

			GetSystemTimeAsFileTime(&m_ftCreateDate);

Exit:
			ExclusiveUnlock();

			return fOK;
		}

		//
		// update our vroot pointer.  takes place at vroot rescans
		//
		void UpdateVRoot(CNNTPVRoot *pVRoot) {
			ExclusiveLock();
			if (m_pVRoot) m_pVRoot->Release();
			m_pVRoot = pVRoot;
			if (m_pVRoot) m_pVRoot->AddRef();
			ExclusiveUnlock();
		}

		//
		// save a group property bag into the fixed length file
		//
		void SaveFixedProperties();

        // accessor function for property bag interface
        INNTPPropertyBag* GetPropertyBag() {
			// no reason to grab lock here
            m_PropBag.AddRef();
            return &m_PropBag;
        }

		//
		// accessor functions to get group properties
		//
		CNewsTreeCore *GetTree() {
			// no lock necessary
			return m_pNewsTree;
		}

		DWORD GetLowWatermark() {
			CGrabShareLock lock(this);
#ifdef DEBUG
            VerifyGroup();
#endif
			return m_iLowWatermark;
		}

		DWORD GetHighWatermark() {
#ifdef DEBUG
            VerifyGroup();
#endif
			CGrabShareLock lock(this);
			return m_iHighWatermark;
		}

		DWORD GetMessageCount() {
			CGrabShareLock lock(this);
			return m_cMessages;
		}

		BOOL IsReadOnly() {
			CGrabShareLock lock(this);
			return m_fReadOnly;
		}

		BOOL IsAllowPost() {
		    CGrabShareLock lock(this);
		    return m_fAllowPost;
		}

		char *GetGroupName() {
			// this can't change, so locking isn't necessary
			return m_pszGroupName;
		}

		DWORD GetGroupNameLen() {
			// this can't change, so locking isn't necessary
			return m_cchGroupName;
		}

		char *&GetName() {
			// this can't change, so locking isn't necessary
			return m_pszGroupName;
		}

		char *GetNativeName() {
			// this can't change, so locking isn't necessary
			return (m_pszNativeName == NULL) ? m_pszGroupName : m_pszNativeName;
		}

		DWORD GetGroupId() {
			// this can't change, so locking isn't necessary
			return m_dwGroupId;
		}

		DWORD GetGroupNameHash() {
			// this can't change, so locking isn't necessary
			return m_dwHashId;
		}

		BOOL IsDeleted() {
			CGrabShareLock lock(this);
			return m_fDeleted;
		}

		BOOL IsSpecial() {
			CGrabShareLock lock(this);
			return m_fSpecial;
		}

		BOOL IsAllowExpire() {
		    CGrabShareLock lock(this);
		    return m_fAllowExpire;
		}

		DWORD GetRefCount() {
			CGrabShareLock lock(this);
			return m_cRefs;
		}

		FILETIME GetCreateDate() {
			CGrabShareLock lock(this);
			return m_ftCreateDate;
		}

		LPCSTR GetPrettyName(DWORD *pcch = NULL) {
			CGrabShareLock lock(this);
			if (pcch) *pcch = m_cchPrettyName;
			return m_pszPrettyName;
		}

		LPCSTR GetModerator(DWORD *pcch = NULL) {
			CGrabShareLock lock(this);
			if (pcch) *pcch = m_cchModerator;
			return m_pszModerator;
		}

		DWORD GetCacheHit() {
		    CGrabShareLock lock(this);
		    return m_dwCacheHit;
		}

		ARTICLEID GetExpireLow() {
		    CGrabShareLock lock(this);
		    return m_artXoverExpireLow;
		}

		BOOL
		IsModerated()	{
			CGrabShareLock	lock(this) ;
			return	m_pszModerator != 0 && *m_pszModerator != 0;
		}

		LPCSTR GetHelpText(DWORD *pcch = NULL) {
			CGrabShareLock lock(this);
			if (pcch) *pcch = m_cchHelpText;
			return m_pszHelpText;
		}

		BOOL DidVarPropsChange() {
			return m_fVarPropChanged;
		}

		DWORD GetVarOffset() {
			return m_iOffset;
		}

		BOOL GetDecorateVisitedFlag() {
			CGrabShareLock lock(this);
			return m_fDecorateVisited; // || m_fControlGroup;
		}

		CNNTPVRoot *GetVRoot() {
			CGrabShareLock lock(this);
			if (m_pVRoot) m_pVRoot->AddRef();
			return m_pVRoot;
		}

		CNNTPVRoot *GetVRootWithoutLock() {
		    if ( m_pVRoot ) m_pVRoot->AddRef();
		    return m_pVRoot;
		}

		CNNTPVRoot *GetVRootWithoutRef() {
		    CGrabShareLock lock(this);
		    return m_pVRoot;
		}

		//
		// accessors to set group properties
		//
		void SetSpecial( BOOL f ) {
			ExclusiveLock();
			m_fSpecial = f;
			ExclusiveUnlock();
		}

		void SetCreateDate( FILETIME ft ) {
			ExclusiveLock();
			m_ftCreateDate = ft;
			ExclusiveUnlock();
		}

		void SetLowWatermark(DWORD i) {
			ExclusiveLock();
			m_iLowWatermark = i;
#ifdef DEBUG
            VerifyGroup();
#endif
			ExclusiveUnlock();
		}

		void SetHighWatermark(DWORD i) {
			ExclusiveLock();
			m_iHighWatermark = i;
#ifdef DEBUG
            VerifyGroup();
#endif
			ExclusiveUnlock();
		}

		void SetMessageCount(DWORD c) {
			ExclusiveLock();
			m_cMessages = c;
			ExclusiveUnlock();
		}

		void BumpArticleCount( DWORD dwArtId ) {
		    ExclusiveLock();

		    //
		    // Update low watermark
		    //
            if ( m_cMessages == 0 ) {	
                m_iLowWatermark = dwArtId;
            } else {
                if ( dwArtId < m_iLowWatermark )
                    m_iLowWatermark = dwArtId;
            }

            //
            // Update high watermark: this is redundant
            // for most inbound but only useful for 
            // rebuild
            //
            if ( dwArtId > m_iHighWatermark )
                m_iHighWatermark = dwArtId;
                
		    m_cMessages++;
		    ExclusiveUnlock();
		    SaveFixedProperties();
		}

		void SetReadOnly(BOOL f) {
			ExclusiveLock();
			m_fReadOnly = f;
			ExclusiveUnlock();
		}

		void SetCacheHit( DWORD dwCacheHit ) {
		    ExclusiveLock();
		    m_dwCacheHit = dwCacheHit;
		    ExclusiveUnlock();
		}

		void SetExpireLow( ARTICLEID artExpireLow ) {
		    ExclusiveLock();
		    m_artXoverExpireLow = artExpireLow;
		    ExclusiveUnlock();
		}

		void SetAllowExpire( BOOL f) {
		    ExclusiveLock();
		    m_fAllowExpire = f;
		    ExclusiveUnlock();
		}
		
		void SetAllowPost( BOOL f) {
		    ExclusiveLock();
		    m_fAllowPost = f;
		    ExclusiveUnlock();
		}

		void MarkDeleted() {
			ExclusiveLock();
			m_fDeleted = TRUE;
			m_fVarPropChanged = TRUE;
			ExclusiveUnlock();
		}

		void SavedVarProps() {
			ExclusiveLock();
			m_fVarPropChanged = FALSE;
			ExclusiveUnlock();
		}

		void ChangedVarProps() {
		    ExclusiveLock();
		    m_fVarPropChanged = TRUE;
		    ExclusiveUnlock();
		}

		void SetVarOffset(DWORD dwOffset) {
			ExclusiveLock();
			m_iOffset = dwOffset;
			ExclusiveUnlock();
		}

		void SetDecorateVisitedFlag(BOOL f) {
			ExclusiveLock();
			m_fDecorateVisited = f;
			ExclusiveUnlock();
		}

		void HitCache() {
		    ExclusiveLock();
		    if ( m_dwCacheHit < CACHE_HIT_MAX ) m_dwCacheHit++;
		    ExclusiveUnlock();
		}

		void TouchCacheHit() {
		    ExclusiveLock();
		    if ( m_dwCacheHit > 0 ) m_dwCacheHit--;
		    ExclusiveUnlock();
		}

		BOOL
		ComputeXoverCacheDir(	char	(&szPath)[MAX_PATH*2],
								BOOL&	fFlatDir,
								BOOL	fLocksHeld = FALSE
								) ;

		BOOL ShouldCacheXover();

		// these can return an error if a memory allocation failed.  If you
		// pass in NULL as the string then the property will go away
		BOOL SetHelpText(LPCSTR szHelpText, int cch = -1);
		BOOL SetModerator(LPCSTR szModerator, int cch = -1);
		BOOL SetPrettyName(LPCSTR szPrettyName, int cch = -1);
		BOOL SetNativeName(LPCSTR szNativeName, int cch = -1);

		BOOL SetDriverStringProperty(   DWORD   cProperties,
		                                DWORD   rgidProperties[] );


		// accessor functions for vroot properties
		BOOL IsContentIndexed() {
			if (m_pVRoot) return m_pVRoot->IsContentIndexed();
			else return FALSE;
		}
		DWORD GetAccessMask() {
			if (m_pVRoot) return m_pVRoot->GetAccessMask();
			else return 0;
		}
		DWORD GetSSLAccessMask() {
			if (m_pVRoot) return m_pVRoot->GetSSLAccessMask();
			else return 0;
		}

		// these are used by the CNewsTree hash table
		int MatchKey(LPSTR lpstrMatch) { return (lstrcmp(lpstrMatch, m_pszGroupName) == 0); }
		int MatchKeyId(DWORD dwMatch) { return (dwMatch == m_dwGroupId); }
		LPSTR GetKey() { return m_pszGroupName; }
		DWORD GetKeyId() { return m_dwGroupId; }
		
		CNewsGroupCore	*m_pNextByName;
		CNewsGroupCore	*m_pNextById;

		// these are used for the linked list kept by the newstree
		CNewsGroupCore *m_pNext;
		CNewsGroupCore *m_pPrev;

		// hash the ID
		static DWORD ComputeIdHash(DWORD id) {
			return id;
		}

		// hash the name
		static DWORD ComputeNameHash(LPSTR lpstr) {
			return CRCHash((BYTE *) lpstr, lstrlen(lpstr));
		}

		void InsertArticleId(ARTICLEID artid) ;
		ARTICLEID AllocateArticleId();

		BOOL DeletePhysicalArticle(ARTICLEID artid) { return FALSE; }
		BOOL AddReferenceTo(ARTICLEID, CArticleRef&);

		BOOL IsGroupAccessible( HANDLE hClientToken,
		                        DWORD   dwAccessDesired );

		BOOL RebuildGroup(  HANDLE hClientToken );

		BOOL WatermarkConsistent()
		{
		    if ( m_cMessages > 0 ) {
		        if ( m_iHighWatermark - m_iLowWatermark < m_cMessages - 1 ) {
				    _ASSERT( FALSE && "Article count inconsistent" );
				    m_cMessages = m_iHighWatermark - m_iLowWatermark + 1;
			    }
		    }
		    return TRUE;
		}

	protected:
		DWORD			m_dwSignature;
		// our array of locks
		static	CShareLockNH	m_rglock[GROUP_LOCK_ARRAY_SIZE];
		// parent newstree
		CNewsTreeCore	*m_pNewsTree;
		// parent vroot
		CNNTPVRoot 		*m_pVRoot;
        // property bag
        CNNTPPropertyBag m_PropBag;
		// high, low, count
		ARTICLEID		m_iLowWatermark;
		ARTICLEID		m_iHighWatermark;
		DWORD   		m_cMessages;
		// group name
		LPSTR			m_pszGroupName;
		DWORD			m_cchGroupName;
		// group name, with capitalization
		LPSTR			m_pszNativeName;
		// group ID
		DWORD			m_dwGroupId;
		DWORD			m_dwHashId;		// should become dwGroupId
		// read only?
		BOOL			m_fReadOnly;
		// deleted?
		BOOL			m_fDeleted;
		// is special?
		BOOL			m_fSpecial;
		// Creation date
		FILETIME		m_ftCreateDate;

		// offset into the variable length file
		DWORD			m_iOffset;
		BOOL			m_fVarPropChanged;
		// prettyname
		LPSTR			m_pszPrettyName;
		DWORD			m_cchPrettyName;
		// moderator
		LPSTR			m_pszModerator;
		DWORD			m_cchModerator;
		// help text (description)
		LPSTR			m_pszHelpText;
		DWORD			m_cchHelpText;

		// Xover Cache Hit count
		DWORD           m_dwCacheHit;

		// Can we take expire ?
		BOOL            m_fAllowExpire;

		// non-persistent property to turn off posting
		BOOL            m_fAllowPost;

		// this BOOL is set to FALSE before doing a decorate newstree.  it
		// then is set to TRUE when the group is visited during a decorate
		// after the decorate all groups which have this set to FALSE are
		// removed
		BOOL			m_fDecorateVisited;

		// this is set if the group name is control.newgroup, control.rmgroup
		// or control.cancel.  it is used to force m_fDecorateVisited to
		// always be TRUE
		BOOL			m_fControlGroup;

        //
	    //	The articleid of the lowest Xover number Xover entry we may have
	    //	This should always be less than m_artLow, and if errors occurr deleting
	    //	files may be much lower.  We hang onto this number so that we can
	    //	retry expirations if we hit snags !
	    //	This member variable should only be accessed on the expiration thread !
	    //
	    ARTICLEID	m_artXoverExpireLow ;

		friend class CGrabShareLock;
		friend class CGrabExclusiveLock;

};

typedef CRefPtr2<CNewsGroupCore> CGRPCOREPTR;
typedef CRefPtr2HasRef<CNewsGroupCore> CGRPCOREPTRHASREF;

extern		BOOL	MatchGroup( LPMULTISZ	multiszPatterns,	LPSTR	lpstrGroup ) ;	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\grouplst.inl ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    grouplst.inl

Abstract:

	The inline code for the grouplst object.


Author:

    Carl Kadie (CarlK)     29-Oct-1995

Revision History:

--*/

template<class ITEM>
CGroupList< ITEM >::CGroupList(void	):
   m_cMax(0),
   m_cLast(0),
   m_pAllocator(NULL),
   m_rgpItem(NULL)
{};

template<class ITEM>
BOOL CGroupList<ITEM>::fInit(
		DWORD cMax,
		CAllocator * pAllocator
	)
{
   _ASSERT( cMax );
   m_cMax = cMax;
   m_cLast = 0;
   m_pAllocator = pAllocator;

   // If the list is re-initialized, delete the old list
   if (m_rgpItem && m_pAllocator)
		XDELETE[] m_rgpItem;

   m_rgpItem =  //!!!MEM(ITEM *) (m_pAllocator->Alloc(sizeof(ITEM) * cMax));
	   XNEW ITEM[cMax];

   return (m_rgpItem !=NULL);
};

template<class ITEM>
BOOL CGroupList<ITEM>::fAsBeenInited(void)
{
	return NULL != m_pAllocator;
}


//
// Destructor - the memory allocated for the list is freed.
//

template<class ITEM>
CGroupList<ITEM>::~CGroupList(void){
	if (m_rgpItem && m_pAllocator)
		XDELETE[] m_rgpItem;
		//!!!MEMm_pAllocator->Free((char *) m_rgpItem);
}

//
// Returns the head position
//

template<class ITEM>
POSITION CGroupList<ITEM>::GetHeadPosition()	{
	return (POSITION)(SIZE_T)(m_cLast?m_rgpItem:NULL);
};

template<class ITEM>
BOOL CGroupList<ITEM>::IsEmpty()	{
	return 0 == m_cLast;
};

//
// Remove all the items in the list
//

template<class ITEM>
void CGroupList<ITEM>::RemoveAll(){
	m_cLast = 0;
};

//
// Return the size of the list
//

template<class ITEM>
DWORD CGroupList<ITEM>::GetCount(void){
	return m_cLast;
}


template<class ITEM>
ITEM *
CGroupList<ITEM>::GetNext(
					POSITION & pos
					)
/*++

Routine Description:

	Returns the item at POSITION pos in the list and increments
	pos

Arguments:

	pos -- the current position


Return Value:

	The current item

--*/
{
	ITEM * pItem = (ITEM *) pos;
	ITEM *	pTemp = (ITEM *)pos ;
	pTemp ++ ;
	pos = (POSITION) pTemp ;
	if (pTemp >= m_rgpItem + m_cLast)
		pos = NULL;

	return pItem;
}


template<class ITEM>
ITEM *
CGroupList<ITEM>::GetHead(void)
/*++

Routine Description:

	Returns the first item

Arguments:

	None.


Return Value:

	The first item

--*/
{
	POSITION pos = GetHeadPosition();

	if (pos)
		return Get(pos);
	else
		return (ITEM *) 0;
};

/*++

Routine Description:

	Returns the item at POSITION pos

Arguments:

	pos -- the current position


Return Value:

	The current item

--*/
template<class ITEM>
ITEM *
CGroupList<ITEM>::Get(
					POSITION & pos
					)
{
	return  (ITEM *) pos;
}

/*++

Routine Description:

	Remove the item at POSITION pos

Arguments:

	pos -- the current position


Return Value:

	The current item

--*/
template<class ITEM>
void CGroupList<ITEM>::Remove(
					POSITION & pos
					)
{
	ITEM *	pTemp = (ITEM *)pos ;
	if (pTemp==NULL||m_cLast==0)
		return;
	pTemp++;
	while (pTemp<m_rgpItem + m_cLast)
	{
		*(pTemp-1) = *pTemp;
		pTemp++;
	}
	m_cLast--;
}
		
/*++

Routine Description:

	Adds an item to the tail of the list.

Arguments:

	item -- the item to add


Return Value:

	The position of the new last item.

--*/
template<class ITEM>
POSITION
CGroupList<ITEM>::AddTail(
    	ITEM & item
		)
{
	if (m_cLast >= m_cMax)
		return (POSITION) NULL;

	m_rgpItem[m_cLast++] = item;
	return (POSITION) &(m_rgpItem[m_cLast]);
}

template<class ITEM>
void
CGroupList<ITEM>::Sort(int (__cdecl *fncmp)(const void *, const void *)) {
	qsort(m_rgpItem, m_cLast, sizeof(ITEM), fncmp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\ihash.h ===
#ifndef	_IHASH_H_
#define	_IHASH_H_

#include <nntpdrv.h>

#ifndef	_HASHMAP_

typedef	void	(* HASH_FAILURE_PFN)(	LPVOID	lpv,
										BOOL	fRecoverable	) ;

#endif

#define     ART_HEAD_SIGNATURE          0xaaaaaaaa
#define     HIST_HEAD_SIGNATURE         0xbbbbbbbb
#define     XOVER_HEAD_SIGNATURE        0xcccccccc

#define     DEF_EXPIRE_INTERVAL         (3 * SEC_PER_WEEK) // 1 week

typedef enum
{
	stFileSystem,
	stJet
} StoreType;

class CStoreId : public STOREID {
	public:
		CStoreId() {
			cLen = 0;
#ifdef DEBUG
			ZeroMemory(pbStoreId, sizeof(pbStoreId));
#endif
		}
};


//
//		Initialize everything so that the NNTP Hash Library may run !
//		Call before anything else is called !!
//
BOOL
InitializeNNTPHashLibrary(DWORD dwCacheSize = 0) ;

//
//		Terminate the NNTP Hash Library
//
BOOL
TermNNTPHashLibrary() ;

//
//  Expose the function we use to compute hash values !!!
//
HASH_VALUE
INNHash(    LPBYTE  Key, 
            DWORD   Length ) ;  

//
//  Helper functions for when building nntpbld statistics !
//
//
DWORD 
GetArticleEntrySize( DWORD MsgIdLen ) ;

DWORD 
GetXoverEntrySize( DWORD VarLen ) ;


//
//	This class specifies the interface to the hash table 
//	which maps NNTP RFC 822 Message Id's to articles on the disk !
//
class	CMsgArtMap	{
public : 
	static CStoreId g_storeidDefault;

	//
	//	Destroy a CMsgArtMap object
	//
	virtual	~CMsgArtMap() = 0 ;

	//
	//	Delete a an entry in the hash table using the MessageID key
	//
	virtual	BOOL
	DeleteMapEntry(	
			LPCSTR	MessageID 
			) = 0 ;

	//
	//	Get all the info we have on a Message ID
	//
	virtual	BOOL
	GetEntryArticleId(
			LPCSTR	MessageID, 
			WORD&	HeaderOffset,
			WORD&	HeaderLength, 
			ARTICLEID&	ArticleId, 
			GROUPID&	GroupId,
			CStoreId	&storeid
			) = 0 ;
	
	//
	//	Initialize the hash table !
	//
	virtual	BOOL
	Initialize(			
			LPSTR	lpstrArticleFile, 
			HASH_FAILURE_PFN	pfn = 0, 
			BOOL	fNoBuffering = FALSE
			) = 0 ;

	//
	//	Insert an entry into the hash table
	//
	virtual	BOOL
	InsertMapEntry(
			LPCSTR		MessageID, 
			WORD		HeaderOffset = 0, 
			WORD		HeaderLength = 0,
			GROUPID		PrimaryGroup = INVALID_GROUPID,
			ARTICLEID	ArticleID = INVALID_ARTICLEID,
			CStoreId	&storeid = g_storeidDefault
			) = 0 ;

	//
	//	Modify an existing entry in the hash ttable
	//
	virtual	BOOL
	SetArticleNumber(
			LPCSTR	MessageID, 
			WORD	HeaderOffset, 
			WORD	HeaderLength, 
			GROUPID	Group, 
			ARTICLEID	AritlceId,
			CStoreId	&storeid = g_storeidDefault
			) = 0 ;

	//
	//	Check to see if a MessageID is present in the system !
	//
	virtual	BOOL
	SearchMapEntry(
			LPCSTR	MessageID
			) = 0 ;

	//
	//	Terminate everything 
	//
	virtual	void
	Shutdown(
			BOOL	fLocksHeld  = FALSE
			) = 0 ;

	//
	//	return the number of entries in the hash table
	//
	virtual	DWORD
	GetEntryCount() = 0 ;

	//
	//	Return TRUE if the table has been successfully initialized 
	//	and all interfaces should be working 
	//
	virtual	BOOL
	IsActive() = 0 ;

	//
	//	This creates an object conforming to this interface !
	//
	static	CMsgArtMap*	
	CreateMsgArtMap(StoreType st=stFileSystem) ;

} ;

#ifndef SEC_PER_WEEK
#define	SEC_PER_WEEK (60*60*24*7)
#endif

//
//	This class specifies the interface to the hash table which 
//	handles storing our history of Message-ID's which have been on 
//	the system!
//
class	CHistory	{
public : 

	//
	//	This function creates the threads which expire
	//	entries out of all the history tables which may 
	//	be created !
	//
	static	BOOL
	StartExpirationThreads(
				DWORD	CrawlerSleepTime = 30 		// Time to sleep between examining 
													// entries in seconds !
				) ;

	//
	//	This function terminates the threads which expire
	//	entries out of all the history tables which may be 
	//	created.
	//
	static	BOOL
	TermExpirationThreads() ;

	//
	//	Destroy the History table
	//
	virtual	~CHistory() = 0 ;

	//
	//	amount of time entries last in the history table
	//
	virtual	DWORD
	ExpireTimeInSec() = 0 ;


	//
	//	Delete a MessageID from this table
	//
	virtual	BOOL
	DeleteMapEntry(	
			LPSTR	MessageID 
			) = 0 ;

	//
	//	Initialize the Hash table
	//
	virtual	BOOL
	Initialize(			
			LPSTR	lpstrArticleFile, 
			BOOL	fCreateExpirationThread = FALSE,
			HASH_FAILURE_PFN	pfn = 0,
			DWORD	ExpireTimeInSec = DEF_EXPIRE_INTERVAL,	// how long entries live !
			DWORD	MaxPagesToCrawl = 4,					// Number of pages to examine
															// each time we run the expire thread !
			BOOL	fNoBuffering = FALSE
			) = 0 ;

	//
	//	Insert an entry into the hash table 
	//
	virtual	BOOL
	InsertMapEntry(
			LPCSTR	MessageID, 
			PFILETIME	BaseTime
			) = 0 ;

	//
	//	Check for the presence of a Message ID in the history table
	//
	virtual	BOOL
	SearchMapEntry(
			LPCSTR	MessageID
			) = 0 ;

	//
	//	Shutdown the hash table
	//
	virtual	void
	Shutdown(
			BOOL	fLocksHeld = FALSE
			) = 0 ;

	//
	//	Return the number of entries in the hash table
	//
	virtual	DWORD
	GetEntryCount() = 0 ;

	//
	//	Is the hash table initialized and functional ? 
	//
	virtual	BOOL
	IsActive() = 0 ;

	//
	//	Return a pointer to an object implementing this interface
	//
	static
	CHistory*	CreateCHistory(StoreType st=stFileSystem) ;
} ;


class	IExtractObject	{
public : 

	virtual	BOOL
	DoExtract(	GROUPID			PrimaryGroup,
				ARTICLEID		PrimaryArticle,
				PGROUP_ENTRY	pGroups,	
				DWORD			cGroups	
				) = 0 ;

} ;

//
//	Define a base class for the object that maintains our iteration state !
//
class	CXoverMapIterator	{
public : 
	virtual	~CXoverMapIterator()	{}
} ;


//
//	Specify the interface used to access data in the XOVER hash table
//
//
class	CXoverMap	{
public : 
	static CStoreId g_storeidDefault;

	//
	//	Destructor is virtual because most work done in a derived class
	//
	virtual
	~CXoverMap() = 0 ;

	//
	//	Create an entry for the primary article
	//
	virtual	BOOL
	CreatePrimaryNovEntry(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			WORD		HeaderOffset, 
			WORD		HeaderLength, 
			PFILETIME	FileTime, 
			LPCSTR		szMessageId, 
			DWORD		cbMessageId,
			DWORD		cEntries, 
			GROUP_ENTRY	*pEntries,
			DWORD 		cStoreEntries = 0,
			CStoreId	*pStoreIds = NULL,
			BYTE		*rgcCrossposts = NULL		
			) = 0 ;
			

	//
	//	Create a Cross Posting entry that references the 
	//	specified primary entry !
	//
	virtual	BOOL
	CreateXPostNovEntry(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			WORD		HeaderOffset, 
			WORD		HeaderLength,
			PFILETIME	FileTime,
			GROUPID		PrimaryGroupId, 
			ARTICLEID	PrimaryArticleId
			) = 0 ;

	//
	//	Delete an entry from the hash table!
	//
	virtual	BOOL
	DeleteNovEntry(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId
			) = 0 ;

	//
	//	Get all the information stored about an entry 
	//
	virtual	BOOL
	ExtractNovEntryInfo(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			BOOL		&fPrimary,
			WORD		&HeaderOffset, 
			WORD		&HeaderLength, 
			PFILETIME	FileTime,
			DWORD		&DataLen,
			PCHAR		MessageId, 
			DWORD 		&cStoreEntries,
			CStoreId	*pStoreIds,
			BYTE		*rgcCrossposts,
			IExtractObject*	pExtract = 0
			) = 0 ;	

	//
	//	Get the primary article and the message-id if necessary
	//
	virtual	BOOL
	GetPrimaryArticle(	
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			GROUPID&	GroupIdPrimary, 
			ARTICLEID&	ArticleIdPrimary, 
			DWORD		cbBuffer, 
			PCHAR		MessageId, 
			DWORD&		DataLen, 
			WORD&		HeaderOffset, 
			WORD&		HeaderLength,
			CStoreId	&storeid
			) = 0 ;

	//
	//	Check to see whether the specified entry exists - 
	//	don't care about its contents !
	//
	virtual	BOOL
	Contains(	
			GROUPID		GroupId, 
			ARTICLEID	ArticleId
			) = 0 ;

	//
	//	Get all the cross-posting information related to an article !
	//
	virtual	BOOL
	GetArticleXPosts(
			GROUPID		GroupId, 
			ARTICLEID	AritlceId, 
			BOOL		PrimaryOnly, 
			PGROUP_ENTRY	GroupList, 
			DWORD		&GroupListSize, 
			DWORD		&NumberOfGroups,
			PBYTE		rgcStoreCrossposts = NULL
			) = 0 ;

	//
	//	Initialize the hash table
	//
	virtual	BOOL
	Initialize(	
			LPSTR		lpstrXoverFile, 
			HASH_FAILURE_PFN	pfnHint = 0,
			BOOL	fNoBuffering = FALSE
			) = 0 ;

	virtual	BOOL
	SearchNovEntry(
			GROUPID		GroupId, 
			ARTICLEID	ArticleId, 
			PCHAR		XoverData, 
			PDWORD		DataLen,
            BOOL        fDeleteOrphans = FALSE
			) = 0 ;

	//
	//	Signal the hash table to shutdown
	//
	virtual	void
	Shutdown( ) = 0 ;

	//
	//	Return the number of entries in the hash table !
	//
	virtual	DWORD
	GetEntryCount() = 0 ;

	//
	//	Returns TRUE if the hash table is successfully 
	//	initialized and ready to do interesting stuff !!!
	//
	virtual	BOOL
	IsActive() = 0 ;

	//
	//	Define the interface for iterating over XOVER entries !
	//
	//	NOTE : This function returns 2 important items independently !
	//	The BOOL return value indicates whether the function
	//	successfully copied the requested data into the users 
	//	buffers.  
	//	pIterator returns the Iterator context to be used in future
	//	calls to GetNextNovEntry().  This can come back as 
	//	NON NULL even if the function returns FALSE.  This should 
	//	only occur if GetLastError() == ERROR_INSUFFICIENT_BUFFER.
	//	if this occurs, allocate larger buffers and call GetNextNovEntry().
	//
	//	If GetLastError() == ERROR_NO_MORE_ITEMS than there is nothing in the hashtable.
	//
	virtual
	BOOL
	GetFirstNovEntry(
				OUT	CXoverMapIterator*	&pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary, 
				IN	DWORD		cbBuffer, 
				OUT	PCHAR	MessageId, 
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				) = 0 ;


	//
	//	If this returns FALSE and GetLastError() == ERROR_INSUFFICIENT_BUFFER
	//	then the out buffers were too small to hold the requested items.
	//
	//	if GetLastError() == ERROR_NO_MORE_ITEMS there is nothing left to iterate.
	//	The user should delete the pIterator.
	//
	virtual
	BOOL
	GetNextNovEntry(		
				IN	CXoverMapIterator*	pIterator,
				OUT	GROUPID&	GroupId,
				OUT ARTICLEID&	ArticleId,
				OUT	BOOL&		fIsPrimary,
				IN	DWORD		cbBuffer, 
				OUT	PCHAR	MessageId, 
				OUT	CStoreId&	storeid,
				IN	DWORD		cGroupBuffer,
				OUT	GROUP_ENTRY*	pGroupList,
				OUT	DWORD&		cGroups
				) = 0 ;

	static	
	CXoverMap*	CreateXoverMap(StoreType st=stFileSystem) ;

} ;

// this is the maximum number of crossposts that we could possibly store
// in the xover hash table
#define MAX_NNTPHASH_CROSSPOSTS (4096 / (sizeof(DWORD) + sizeof(DWORD)))

// this is the maximum number of store ids that we could store.  it is
// 256 because we only use a BYTE to keep the count
#define MAX_NNTPHASH_STOREIDS 256

#endif	// _IHASH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\instwrap.h ===
#ifndef __INSTWRAP_H__
#define __INSTWRAP_H__
//
// This class wraps up the important stuff in PNNTP_SERVER_INSTANCE for
// use by the posting path
//

class CMsgArtMap;
class CHistory;
class CXoverMap;
class CNewsTreeCore;

#include "nntpret.h"
#include "seo.h"

class CNntpServerInstanceWrapper {
	public:
		virtual BOOL AllowClientPosts() = 0;
		virtual BOOL AllowControlMessages() = 0;
		virtual DWORD FeedHardLimit() = 0;
		virtual DWORD FeedSoftLimit() = 0;
		virtual DWORD ServerHardLimit() = 0;
		virtual DWORD ServerSoftLimit() = 0;
		virtual void EnterRPCCritSec() = 0;
		virtual void LeaveRPCCritSet() = 0;
		virtual void EnterNewsgroupCritSec() = 0;
		virtual void LeaveNewsgroupCritSec() = 0;
		virtual CMsgArtMap *ArticleTable() = 0;
		virtual CHistory *HistoryTable() = 0;
		virtual CXoverMap *XoverTable() = 0;
		virtual char *NntpHubName() = 0;
		virtual DWORD HubNameSize() = 0;
		virtual char *NntpDNSName() = 0;
		virtual DWORD NntpDNSNameSize() = 0;
		virtual CNewsTreeCore *GetTree() = 0;
		virtual void BumpCounterControlMessagesFailed() = 0;
		virtual void BumpCounterArticlesReceived() = 0;
		virtual void BumpCounterArticlesPosted() = 0;
		virtual void BumpCounterModeratedPostingsSent() = 0;
		virtual void BumpCounterControlMessagesIn() = 0;
		virtual void IncrementFeedCounter(void *feedcompcontext, DWORD nrc) = 0;
		virtual BOOL ExpireArticle(ARTICLEID artid, GROUPID groupid, STOREID *pStoreId, CNntpReturn &nntpreturn, HANDLE hToken, BOOL fMust, BOOL fAnonymous ) = 0;
		virtual BOOL DeletePhysicalArticle(ARTICLEID artid, GROUPID groupid, STOREID *pStoreId, HANDLE hToken, BOOL fAnonymous ) = 0;
		virtual BOOL GetDefaultModerator(LPSTR pszNewsgroup, LPSTR pszDefaultModerator, PDWORD pcbDefaultModerator) = 0;
		virtual BOOL AddArticleToPushFeeds(CNEWSGROUPLIST &newsgroups, CArticleRef artrefFirst, char *multiszPath, CNntpReturn &nntpReturn) = 0;
		virtual BOOL GetSmtpAddress( LPSTR pszAddress, PDWORD pcbAddress ) = 0;
		virtual PCHAR PeerTempDirectory() = 0;
		virtual LPSTR QueryAdminEmail() = 0;
		virtual DWORD QueryAdminEmailLen() = 0;
		virtual DWORD QueryInstanceId() = 0;
		virtual IEventRouter *GetEventRouter() = 0;
		virtual HRESULT CreateMailMsgObject( IMailMsgProperties ** ppv) = 0;
		virtual BOOL MailArticle( CNewsGroupCore *, ARTICLEID, LPSTR ) = 0;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\infeed.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    infeed.h

Abstract:

    This module contains class declarations/definitions for

		CInFeed

    **** Overview ****

	A CInFeed object accepts articles, processes them using CArticle,
	and then posts them to the newstree.


Author:

    Carl Kadie (CarlK)     25-Oct-1995

Revision History:


--*/


#ifndef	_INFEED_H_
#define	_INFEED_H_

#include	"grouplst.h"
#include	"artcore.h"
#include	"article.h"

extern       BOOL    gHonorClientMessageIDs;
extern       BOOL    gHonorApprovedHeaders;
extern       BOOL    gEnableNntpPostingHost;

//
// CPool Signature
//

#define FEED_SIGNATURE (DWORD)'3702'

//
// Defines the longest login name a user can have.
//

const DWORD cMaxLoginName = MAX_PATH; //!!!CLIENT NEXT what is the longest allowed?


//
// Define the type of smart pointers to newsgroup objects.
//
class CPostContext;

//
// the CGroupList holds an array of these objects.  the array has a
// group pointer and the store driver for that pointer for each of the
// groups that we are crossposting to.
//
class CPostGroupPtr {
	public:
		CPostGroupPtr(CGRPCOREPTR pGroup = NULL) : m_pGroup(pGroup) {
			if (m_pGroup != NULL) {
				// this does an AddRef for us
				m_pVRoot = pGroup->GetVRoot();
				m_pStoreDriver = m_pVRoot->GetStoreDriver();
				_ASSERT(m_pVRoot != NULL);
			} else {
				m_pVRoot = NULL;
				m_pStoreDriver = NULL;
			}
		}

		CPostGroupPtr &operator=(CPostGroupPtr &rhs) {
			CNNTPVRoot *pTempRoot = m_pVRoot;
			IMailMsgStoreDriver *pTempDriver = m_pStoreDriver;
			m_pGroup = rhs.m_pGroup;
			m_pVRoot = rhs.m_pVRoot;
			m_pStoreDriver = rhs.m_pStoreDriver;
			if (m_pVRoot) m_pVRoot->AddRef();
			if (m_pStoreDriver) m_pStoreDriver->AddRef();
			if (pTempRoot) pTempRoot->Release();
			if (pTempDriver) pTempDriver->Release();
			return *this;
		}

		~CPostGroupPtr() {
		    Cleanup();
		}

		void Cleanup() {
		    if ( m_pVRoot ) {
		        m_pVRoot->Release();
		        m_pVRoot = NULL;
		    }
		    if ( m_pStoreDriver ) {
		        m_pStoreDriver->Release();
		        m_pStoreDriver = NULL;
		    }

		    //
		    // don't worry about m_pGroup, he is a smart pointer
		    //
		}

		IMailMsgStoreDriver *GetStoreDriver() {
		    if ( m_pStoreDriver ) {
    			m_pStoreDriver->AddRef();
    	    }
			return m_pStoreDriver;
		}

		CGRPCOREPTR	m_pGroup;
		IMailMsgStoreDriver *m_pStoreDriver;
		CNNTPVRoot *m_pVRoot;
};

typedef CGroupList< CPostGroupPtr > CNEWSGROUPLIST;


#include "instwrap.h"


//
//	Utility function - used to save logging information !
//
void	SaveGroupList(	char*	pchGroups,	DWORD	cbGroups,	CNEWSGROUPLIST&	grouplist ) ;

void SelectToken(
	CSecurityCtx *pSecurityCtx,
	CEncryptCtx *pEncryptCtx,
	HANDLE *phToken,
	BOOL *pfNeedsClosed);

class	CInFeed:	public CFeed 	{

protected :
	//
	// This is the function that creates an article of the approprate type
	// for this feed.
	//

	virtual CARTPTR pArticleCreate(void) = 0;

	//
	// A multisz containing the newnews pattern
	//

	LPSTR m_multiszNewnewsPattern;

	//
	// True if the newnews feed should automatically create all
	// newsgroups available on the peer server.
	//

	BOOL m_fCreateAutomatically;

    //
    // newnews time/date
    //

    CHAR m_newNewsTime[7];
    CHAR m_newNewsDate[7];

	//
	// The directory into which articles should be placed pending
	// processing.
	//

	LPSTR m_szTempDirectory;

	//
	// The size of the gap in the file before the article for incomming articles.
	//

	DWORD	m_cInitialBytesGapSize;

	//
	//	Should we do impersonations etc... when articles arrive on this
	//	feed ?
	//

	BOOL	m_fDoSecurityChecks ;

	//
	//	Should we apply control messages that arrive on this feed ?
	//

	BOOL	m_fAllowControlMessages ;

	//
	//	A Timestamp computed when the feed is started that is used
	//	so pull feeds can get appropriate overlap of pull times !
	//
	
	FILETIME	m_NextTime ;

	//
	// the feed ID from the feedmgr
	//
	DWORD		m_dwFeedId;

//
// Public Members
//

public :


	//
	// Constructor
	//

	CInFeed(void) : m_cInitialBytesGapSize( 0 ),
					m_fDoSecurityChecks( FALSE )
	       {
				m_szLoginName[cMaxLoginName-1] = '\0';
				ZeroMemory( &m_NextTime, sizeof( m_NextTime ) ) ;
			};


	//
	// Destructor
	//

	virtual ~CInFeed(void) {};


	//
	// This will generally be called by a session.
	// FeedTypes are: FromClient, FromMaster, FromSlave, FromPeer
	// UserID is only for FromClient
	//

	//
	// This is called by a session. All but one of the CFeed's
	// will be NULL. The domain name and security information can be
	// retrieved from the socket. Internally this calls
	// feedman's fInitPassiveInFeed to find the type.
	//
	// OR
	// This will generally be called by the feedman for active infeeds
	//
	
	BOOL fInit(
			PVOID feedCompletionContext,
			const char * szTempDirectory,
			const char * multiszNewnewsPattern,
			DWORD cInitialBytesGapSize,
			BOOL fCreateAutomatically,
			BOOL fDoSecurityCheck,
			BOOL fAllowControlMessages,
			DWORD dwFeedId
			);


	//
	// Access function that tells the pattern for newnews queries
	//

	char *	multiszNewnewsPattern(void)	{
			return	m_multiszNewnewsPattern;
			}

	//
	// Function that tells session where to put incoming articles
	//

	char *	szTempDirectory(void);

		//
	// Access function that tells if newsgroups should be created automatically
	// if the newnews host has them.
	//

	BOOL	fCreateAutomatically()		{
			return	m_fCreateAutomatically;
			}

	//
	//	Save a time stamp
	//
	void
	SubmitFileTime(	FILETIME&	filetime ) {
		m_NextTime = filetime ;
	}

	//
	//
	//
	FILETIME
	GetSubmittedFileTime() {
		return	m_NextTime ;
	}

	//
	// function that tells session how must of a gap to leave in files.
	//

	DWORD	cInitialBytesGapSize(void);
	//
	// Access function that tells the time of the last newnews, xreplic, ihave, etc
	//

	char * newNewsTime(void) {
			return m_newNewsTime;
			}

	//
	// Access function that tells the date of the last newnews, xreplic, ihave, etc
	//

	char * newNewsDate(void) {
			return m_newNewsDate;
			}

	//
	// Use to set the LoginName of the user
	//

	BOOL SetLoginName(
		   char * szLoginName
		   );

	//
	//	Return a string that can be used to log errors indicating
	//	what type of feed was processing the articles etc...
	//
	LPSTR	FeedType()	{
				return	"Inbound Feed" ;
				}

	DWORD	FeedId() {
				return m_dwFeedId;
	}


	//
	// virtual function that tells if this command is allowed.
	//

	virtual BOOL	fIsPostLegal(void) = 0;

	//
	// virtual function that tells if this command is allowed.
	//

	virtual BOOL	fIsXReplicLegal(void) = 0;

	//
	// virtual function that tells if this command is allowed.
	//

	virtual BOOL	fIsIHaveLegal(void)  = 0;

    //
    // virtual function that tells whether we do moderated stuff - default don't
    //
    virtual BOOL    fModeratorChecks(void )     { return    FALSE ; }

	//
	//	virtual function that tells whether we should be doing
	//	access checks for incoming articles on this feed
	//
	virtual	BOOL	fDoSecurityChecks(void) {	return	m_fDoSecurityChecks ; }

	//
	//	virtual function that tells if this feed accepts posts !
	//
	virtual	BOOL	fAcceptPosts( CNntpServerInstanceWrapper * pInstance )	
#ifdef BUGBUG
	{	return	pInstance->FAllowFeedPosts() ;	}
#else
	{	return	TRUE;	}
#endif

	//
	//	virtual function that tells if this feed allows control messages !
	//
	virtual	BOOL	fAllowControlMessages( CNntpServerInstanceWrapper * pInstance )	
	{	return	m_fAllowControlMessages ;	}

	//
	//	virtual function that get the feed size limits on posts
	//
	virtual	DWORD	cbHardLimit(  CNntpServerInstanceWrapper * pInstance  )	
#ifdef BUGBUG
	{	return	pInstance->FeedHardLimit() ;		}
#else
	{ return 10000000; }
#endif

	virtual	DWORD	cbSoftLimit(  CNntpServerInstanceWrapper * pInstance  )	
#ifdef BUGBUG
	{	return	pInstance->FeedSoftLimit() ;		}
#else
	{ return 10000000; }
#endif

	//
	// PostEarly - this is called by the protocol when the headers have been
	// 			   received.
	//
	// arguments:
	//   pInstance - a pointer to the instance wrapper
	//   pSecurityContext - the security context of the client
	//   fAnonymous - is the client anonymous?
	//   szCommandLine - the command line used to generate this post
	//   pbufHeaders - pointer to a CBuffer containing the headers.  the posting
	//                 path will reformat the headers and put them back into
	//                 this buffer.  it also keeps a reference on the buffer.
	//   cbHeaders - the size of pbufHeaders when the call is made
	//   pcbHeadersOut - the size of pbufHeaders when the call is complete
	//   phFile - a returned file handle which the headers and article can be
	//            written
	//   ppvContext - a context pointer for the protocol to give to us when
	//                the rest of the article is received.
	//

	BOOL PostEarly(
		CNntpServerInstanceWrapper			*pInstance,
		CSecurityCtx                        *pSecurityCtx,
		CEncryptCtx                         *pEncryptCtx,
		BOOL								fAnonymous,
		const LPMULTISZ						szCommandLine,
		CBUFPTR								&pbufHeaders,
		DWORD								iHeaderOffset,
		DWORD								cbHeaders,
		DWORD								*piHeadersOutOffset,
		DWORD								*pcbHeadersOut,
		PFIO_CONTEXT						*ppFIOContext,
		void								**ppvContext,
		DWORD								&dwSecondary,
		DWORD								dwRemoteIP,
		CNntpReturn							&nntpreturn,
		char								*pNewsgroups,
		DWORD								cbNewsgroups,
		BOOL								fStandardPath = TRUE,
		BOOL								fPostToStore = TRUE);
	
	//
	// This is called by the server when the remained of the article has
	// been received.  It passes in the same ppvContext.
	//
	BOOL PostCommit(CNntpServerInstanceWrapper *pInstance,
	                void *pvContext,
	                HANDLE hToken,
	                DWORD &dwSecondary,
	                CNntpReturn &nntpReturn,
					BOOL fAnonymous,
					INntpComplete*	pComplete=0
					);

	//
	// Apply moderator
	//
	void    ApplyModerator( CPostContext   *pContext,
                             CNntpReturn    &nntpReturn );

	
	//
	// This is called by the server if the post was aborted for any
	// reason
	//
	BOOL PostCancel(void *pvContext,
					DWORD &dwSecondary,
					CNntpReturn &nntpReturn);

	//
	// This calls down to PostEarly/PostCommit and is used for directory
	// pickup articles and feed articles
	//
	BOOL PostPickup(CNntpServerInstanceWrapper			*pInstance,
					CSecurityCtx                        *pSecurityCtx,
					CEncryptCtx                         *pEncryptCtx,
					BOOL								fAnonymous,
					HANDLE								hArticle,
					DWORD								&dwSecondary,
					CNntpReturn							&nntpreturn,
					BOOL								fPostToStore = TRUE);

	//
	// These are the functions that we give the mail message for binding
	// ATQ, etc
	//
	static BOOL MailMsgAddAsyncHandle(struct _ATQ_CONTEXT_PUBLIC	**ppatqContext,
								 	  PVOID							pEndpointObject,
								 	  PVOID							pClientContext,
								 	  ATQ_COMPLETION 				pfnCompletion,
								 	  DWORD							cTimeout,
								 	  HANDLE						hAsyncIO);

	static void MailMsgFreeContext(struct _ATQ_CONTEXT_PUBLIC		*pAtqContext,
							  	   BOOL								fReuseContext);

	static void MailMsgCompletionFn(PVOID		pContext,
									DWORD		cBytesWritten,
									DWORD		dwComplStatus,
									OVERLAPPED 	*lpo)
	{
		_ASSERT(FALSE);
	}

	//	
	//	Log errors that occur processing articles
	//
	
	void	LogFeedEvent(
			DWORD	idMessage, 	
			LPSTR	lpstrMessageId,
			DWORD   dwInstanceId
			) ;


	//
	// bump up the counters in the feed block
	//
	virtual void IncrementFeedCounter(CNntpServerInstanceWrapper *pInstance, DWORD nrc) {
		pInstance->IncrementFeedCounter(m_feedCompletionContext, nrc);
	}

    //
    // Cancel an article given the message id
    //
    virtual BOOL fApplyCancelArticle(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
			CNntpReturn & nntpReturn
			)
	{
		return fApplyCancelArticleInternal( pInstance, pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, TRUE, nntpReturn );
	}

	virtual void CommitPostToStores(CPostContext *pContext, CNntpServerInstanceWrapper *pInstance);
	BOOL WriteMapEntries(HRESULT hr,
						 CPostContext *pContext,
	                	 DWORD &dwSecondary,
	                	 CNntpReturn &nntpReturn);

protected:

	//
	// Does post of the work of processing an article.
	//

	virtual BOOL fPostInternal (
			CNntpServerInstanceWrapper *  pInstance,
			const LPMULTISZ szCommandLine,
			CSecurityCtx    *pSecurityCtx,
			CEncryptCtx     *pEncryptCtx,
			BOOL fAnonymous,
			CARTPTR	& pArticle,
			CNEWSGROUPLIST &grouplist,
			CNAMEREFLIST &namereflist,
			IMailMsgProperties *pMsg,
			CAllocator & allocator,
			char * & multiszPath,
			char*	pchMessageId,
			DWORD	cbMessageId,
			char*	pchGroups,
			DWORD	cbGroups,
			DWORD	remoteIpAddress,
			CNntpReturn & nntpReturn,
			PFIO_CONTEXT *ppFIOContext,
			BOOL *pfBoundToStore,
			DWORD* pdwOperations,
			BOOL *pfPostToMod,
			LPSTR   szModerator
			);

	HRESULT FillInMailMsg(IMailMsgProperties *pMsg,
						  CNNTPVRoot *pVRoot,
						  CNEWSGROUPLIST *pGrouplist,
						  CNAMEREFLIST *pNamereflist,
						  HANDLE    hToken,
                          char*     pszApprovedHeader);

	HRESULT SyncCommitPost(CNNTPVRoot *pVRoot,
						   IUnknown *punkMessage,
						   HANDLE hToken,
						   STOREID *pStoreId,
						   BOOL fAnonymous);

	HRESULT FillMailMsg(IMailMsgProperties *pMsg,
                        DWORD *rgArticleIds,
                        INNTPPropertyBag **rgpGroupBags,
                        DWORD cCrossposts,
                        HANDLE hToken,
                        char*     pszApprovedHeader);


    //
    //  Calculate the amount of space available for xover data
    //

    virtual DWORD CalculateXoverAvail(
            CARTPTR & pArticle,
            CPCString& pcHub
			);

	//
	// Given an article, this creats lists of the newsgroups to post to.
	//

	virtual	BOOL fCreateGroupLists(
			CNewsTreeCore* pNewstree,
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			LPMULTISZ	multiszCommandLine,
            CPCString& pcHub,
			CNntpReturn & nntpReturn
			);

	//
	// Given an article, this creates the nameref lists
	//

	virtual	BOOL fCreateNamerefLists(
			CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
			);

    //
    // Given an article and a newsgroup list, this checks for moderated attributes
    // and sends the article (via a defined interface - default SMTP) to a moderator
    //
    virtual BOOL    fModeratedCheck(
            CNntpServerInstanceWrapper *pInstance,
            CARTPTR & pArticle,
			CNEWSGROUPLIST & grouplist,
            BOOL fCheckApproved,
			CNntpReturn & nntpReturn,
			LPSTR   szModerator
			);

    //
    // Given an article with the Control: header, applies the control message.
    // Derived classes that dont need to apply control messages, should override
    // this to do nothing.
    //
    virtual BOOL    fApplyControlMessage(
            CARTPTR & pArticle,
		    CSecurityCtx *pSecurityCtx,
		    CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
		    CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
			);

    //  Following two functions are splitted from fApplyControlMessage().
    //  Used by PostEarly() and CommitPost().
    virtual BOOL    fApplyControlMessageEarly(
            CARTPTR & pArticle,
		    CSecurityCtx *pSecurityCtx,
		    CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
		    CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
			);
    virtual BOOL    fApplyControlMessageCommit(
            CARTPTR & pArticle,
		    CSecurityCtx *pSecurityCtx,
		    CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
		    CNEWSGROUPLIST & grouplist,
			CNAMEREFLIST * pNamereflist,
			CNntpReturn & nntpReturn
			);
    //
    //  Adjust the grouplist to include control.* groups only
    //
    virtual BOOL fAdjustGrouplist(
		CNewsTreeCore* pTree,
        CARTPTR & pArticle,
	    CNEWSGROUPLIST & grouplist,
		CNAMEREFLIST * pNamereflist,
		CNntpReturn & nntpReturn
		);

    //
    // Add a new newsgroup in response to a newgroup control message
    //
    virtual BOOL fApplyNewgroup(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
            CPCString & pcBody,
			CNntpReturn & nntpReturn
			)
	{
		BOOL fRet ;
		pInstance->EnterNewsgroupCritSec() ;
		fRet = fApplyNewgroupInternal( pInstance, pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, pcBody, TRUE, nntpReturn );
		pInstance->LeaveNewsgroupCritSec();
		return fRet ;
	}

    //
    // Remove a newsgroup in response to a rmgroup control message
    //
    virtual BOOL fApplyRmgroup(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
            CPCString & pcValue,
			CNntpReturn & nntpReturn
			)
	{
		BOOL fRet ;
		pInstance->EnterNewsgroupCritSec() ;
		fRet = fApplyRmgroupInternal( pInstance, pSecurityCtx, pEncryptCtx, pcValue, TRUE, nntpReturn );
		pInstance->LeaveNewsgroupCritSec() ;
		return fRet ;
	}

    //
    // Cancel an article given the message id - internal
    //
    virtual BOOL fApplyCancelArticleInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
			BOOL fApply,					// FALSE for SlaveFromClient feeds, TRUE otherwise
			CNntpReturn & nntpReturn
			);

    //
    // Add a new newsgroup in response to a newgroup control message - internal
    //
    virtual BOOL fApplyNewgroupInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
            CPCString & pcBody,
			BOOL fApply,					// FALSE for SlaveFromClient feeds, TRUE otherwise
			CNntpReturn & nntpReturn
			);

    //
    // Remove a newsgroup in response to a rmgroup control message - internal
    //
    virtual BOOL fApplyRmgroupInternal(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
            CPCString & pcValue,
			BOOL fApply,					// FALSE for SlaveFromClient feeds, TRUE otherwise
			CNntpReturn & nntpReturn
			);

	//
	//	Given a newsgroup list, and a ClientContext, check that the poster has
	//	the necessary access to all of the newsgroups.
	//
	virtual	BOOL	fSecurityCheck(
		    CSecurityCtx *pSecurityCtx,
		    CEncryptCtx *pEncryptCtx,
			CNEWSGROUPLIST&	grouplist,
			CNntpReturn&	nntpReturn
			) ;

	//
	// Move a message id from the Article Table to the History Table
	// (if neccessary)
	//

	BOOL fMoveMessageIDIfNecc(
			CNntpServerInstanceWrapper *	pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn,
			HANDLE  hToken,
			BOOL	fAnonymous
			);


    //
	// If it is necessary ot record the message id, this function
	// will do it.
	//

	virtual BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn
			) = 0;

	//
	// Tells if it is OK to have none of the groups we carry in the
	// Newsgroups: field.
	//

	virtual NRC		nrcNoGroups(void) = 0;

	//
	// Tells what the return code is for accepting an article.
	//

	virtual NRC		nrcArticleAccepted(BOOL	fStandardPath) = 0;

	//
	// Tells what the return code is for rejecting an article
	//

	virtual NRC		nrcArticleRejected(BOOL	fStandardPath) = 0;

	//
	// sort the group list
	//
	virtual void SortNameRefList( CNAMEREFLIST &namereflist ) {
	    //
	    // For other than from master, we do nothing here
	    //
	}

    //
    // Check to see if a post was made to a moderated group
    //
	BOOL ShouldBeSentToModerator(   CNntpServerInstanceWrapper *pInstance,
                                    CPostContext *pContext );

    //
    // Send the article to the moderator
    //
    BOOL SendToModerator(   CNntpServerInstanceWrapper *pInstance,
                            CPostContext *pContext );

	//
	// The user's login name
	//

	char m_szLoginName[cMaxLoginName];
};

//
// we pass this back to the protocol as our context pointer.
//
#define ARTICLE_BUF_SIZE 8192
class CPostContext : public CRefCount2 {
	public:
		class CPostComplete : public CNntpComplete {
			public:
			    friend class CSlaveFromClientFeed;
				CPostComplete(CInFeed *pInFeed,
							  CPostContext *pContext,
							  INntpComplete *pPostCompletion,
							  BOOL fAnonymous,
							  DWORD &dwSecondary,
							  CNntpReturn &nntpReturn);
				void Destroy();

				// Do i need to write map entries
				BOOL m_fWriteMapEntries;

			private:
				// pointer to the post context which owns us
				CPostContext *m_pContext;

				// pointer to our feed object
				CInFeed *m_pInFeed;

				// the completion object which we will release when
				// everything is done
				INntpComplete *m_pPostCompletion;

				// is this coming through an anonymous client?
				BOOL m_fAnonymous;

				// references to our return code variables
				DWORD &m_dwSecondary;
				CNntpReturn &m_nntpReturn;

			friend CInFeed::PostCommit(CNntpServerInstanceWrapper *, void *, HANDLE, DWORD &, CNntpReturn &, BOOL, INntpComplete*);
		};

		char 							m_rgchBuffer[ARTICLE_BUF_SIZE];
		CHAR                            m_szModerator[MAX_MODERATOR_NAME+1];
		CAllocator						m_allocator;

		class CSecurityCtx				*m_pSecurityContext;
		class CEncryptCtx				*m_pEncryptContext;
		BOOL							m_fAnonymous;
		CNntpServerInstanceWrapper		*m_pInstance;
		CBUFPTR							m_pbufHeaders;
		DWORD							m_cbHeaders;
		PFIO_CONTEXT					m_pFIOContext;
		CARTPTR							m_pArticle;
		CNEWSGROUPLIST					m_grouplist;
		CNAMEREFLIST 					m_namereflist;
		CPostGroupPtr					*m_pPostGroupPtr;
		NAME_AND_ARTREF					*m_pNameref;
		BOOL							m_fStandardPath;
		BOOL							m_fBound;
		char							*m_multiszPath;
		DWORD							m_dwOperations;

		IMailMsgProperties				*m_pMsg;

		CStoreId 						*m_rgStoreIds;
		BYTE 							*m_rgcCrossposts;
		// the number of entries in m_rgStoreIds (so its the count of stores
		// that we've commited against).
		DWORD 							m_cStoreIds;
		// the total number of stores which this message should go into
		DWORD							m_cStores;
		HANDLE							m_hToken;

		POSITION 						m_posGrouplist;
		POSITION						m_posNamereflist;

		// the completion object which we hand off to drivers
		CPostComplete					m_completion;

		// Whether I was posted to a moderated group
		BOOL                            m_fPostToMod;

		CPostContext(
			CInFeed						*pInFeed,
			INntpComplete				*pCompletion,
			CNntpServerInstanceWrapper	*pInstance,
			CSecurityCtx				*pSecurityContext,
			CEncryptCtx					*pEncryptContext,
			BOOL						fAnonymous,
			CBUFPTR						&pbufHeaders,
			DWORD						cbHeaders,
			BOOL						fStandardPath,
			DWORD						&dwSecondary,
			CNntpReturn					&nntpReturn
			) : m_pArticle(NULL),
			  	m_pInstance(pInstance),
				m_pSecurityContext(pSecurityContext),
				m_pEncryptContext(pEncryptContext),
				m_fAnonymous(fAnonymous),
			  	m_pbufHeaders(pbufHeaders),
			  	m_cbHeaders(cbHeaders),
			  	m_pFIOContext(NULL),
			  	m_allocator(m_rgchBuffer, ARTICLE_BUF_SIZE),
				m_pMsg(NULL),
				m_fStandardPath(fStandardPath),
				m_fBound(FALSE),
				m_multiszPath(NULL),
				m_rgStoreIds(NULL),
				m_rgcCrossposts(NULL),

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4355)

				m_completion(pInFeed, this, pCompletion, fAnonymous, dwSecondary, nntpReturn),

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif

				m_pPostGroupPtr(NULL),
				m_pNameref(NULL),
				m_dwOperations(0xffffffff),
				m_fPostToMod( FALSE )
		{
		}

		~CPostContext() {
			if (m_rgStoreIds) {
				m_allocator.Free((char *) m_rgStoreIds);
				m_rgStoreIds = NULL;
			}
			if (m_rgcCrossposts) {
				m_allocator.Free((char *) m_rgcCrossposts);
				m_rgcCrossposts = NULL;
			}
			if (m_multiszPath) {
				m_allocator.Free(m_multiszPath);
				m_multiszPath = NULL;
			}
			CleanupMailMsgObject();
		}

		void CleanupMailMsgObject() {
		    if (m_pMsg) {
				if (m_fBound) {
					IMailMsgQueueMgmt *pQueueMgmt;
					HRESULT hr;
					hr = m_pMsg->QueryInterface(IID_IMailMsgQueueMgmt,
												(void **)&pQueueMgmt);
					if (SUCCEEDED(hr)) {
						pQueueMgmt->ReleaseUsage();
						/// pQueueMgmt->Release();
					}
				}
				m_pMsg->Release();
				m_pMsg = NULL;
			}
	    }
};

//
//	Puts an article in the news tree.
//

BOOL gFeedManfPost(
			CNntpServerInstanceWrapper *pInstance,
			CNEWSGROUPLIST& newsgroups,
			CNAMEREFLIST& namerefgroups,
			class	CSecurityCtx*	pSecurity,
			BOOL	fIsSecureSession,
			CArticle* pArticle,
			CStoreId *rgStoreIds,
			BYTE *rgcCrossposts,
			DWORD cStoreIds,
			const CPCString & pcXOver,
			CNntpReturn & nntpReturn,
			DWORD dwFeedId,
			char *pszMessageId = NULL,
			WORD HeaderLength = 0
			);


//
// Does most of gFeedManfPost's work
//

BOOL gFeedManfPostInternal(
			CNntpServerInstanceWrapper * pInstance,
			CNEWSGROUPLIST& newsgroups,
			CNAMEREFLIST& namerefgroups,
			const CPCString & pcXOver,
			POSITION & pos1,
			POSITION & pos2,
			CGRPCOREPTR * ppGroup,
			NAME_AND_ARTREF * pNameRef,
			CArticleRef * pArtrefFirst,
			const char * szMessageID,
			GROUPID * rgGroupID,
			WORD	HeaderOffset,
			WORD	HeaderLength,
			FILETIME FileTime,
			CNntpReturn & nntpReturn
			);

class CDummyMailMsgPropertyStream : public IMailMsgPropertyStream {
	public:
		CDummyMailMsgPropertyStream() : m_cRef(1) {}

		//
		// Implementation of IMailMsgPropertyStream
		//
		HRESULT __stdcall GetSize(IMailMsgProperties *pMsg, DWORD *pcSize, IMailMsgNotify *pNotify) {
			*pcSize = 0;
			return S_OK;
		}

		HRESULT __stdcall ReadBlocks(IMailMsgProperties *pMsg,
									 DWORD cCount,
									 DWORD *rgiData,
									 DWORD *rgcData,
									 BYTE **rgpbData,
									 IMailMsgNotify *pNotify)
		{
			_ASSERT(FALSE);
			return E_NOTIMPL;
		}

		HRESULT __stdcall WriteBlocks(IMailMsgProperties *pMsg,
									  DWORD cCount,
									  DWORD *rgiData,
									  DWORD *rgcData,
									  BYTE **rgpbData,
									  IMailMsgNotify *pNotify)
		{
			//_ASSERT(FALSE);
			return S_OK;
		}

	    //
	    // Implementation of IUnknown
	    //
	    HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
	    {
	        if ( iid == IID_IUnknown ) {
	            *ppv = static_cast<IUnknown*>(this);
	        } else if ( iid == IID_IMailMsgPropertyStream ) {
	            *ppv = static_cast<IMailMsgPropertyStream*>(this);
	        } else {
	            *ppv = NULL;
	            return E_NOINTERFACE;
	        }
	        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	        return S_OK;
	    }
	
	    ULONG __stdcall AddRef()
	    {
	        return InterlockedIncrement( &m_cRef );
	    }
	
	    ULONG __stdcall Release()
	    {
			ULONG x = InterlockedDecrement(&m_cRef);
	        if (x == 0) XDELETE this;
	        return x;
	    }

        HRESULT __stdcall CancelWriteBlocks(IMailMsgProperties *pMsg) { return S_OK; }
		HRESULT __stdcall StartWriteBlocks(IMailMsgProperties *pMsg, DWORD x, DWORD y) { return S_OK; }
		HRESULT __stdcall EndWriteBlocks(IMailMsgProperties *pMsg) { return S_OK; }

	private:
		long m_cRef;
};

//
// This is the type of a smart pointer to a feed object.
//

#if 0
#ifndef	_NO_TEMPLATES_

typedef CRefPtr< CFeed >  CFEEDPTR ;

#else

DECLARE_TYPE( CFeed )
typedef	class INVOKE_SMARTPTR( CFeed )	CFEEDPTR ;

#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\hashentr.h ===
// if this is 1 then this is a secondary XOVER entry, otherwise its
// a primary XOVER entry
#define FL_SECONDARYENTRY	0x01

// there is only one copy of this message (so cCrossposts == 0 and 
// cStoreEntries == 0).  This saves us four bytes by not having to 
// save these counters into the persisted format plus another 8 bytes
// by not having to have anything in the crosspost array.
#define	FL_NOXPOSTS		 	0x02

// there is only one store entry (the article isn't crossposted across
// stores).  This saves us two bytes in the persisted format.
#define	FL_ONESTOREENTRY 	0x04

// all of the Store IDs in this message are 0 bytes long.  this saves
// us 2 * cStoreEntries bytes when set.  
#define	FL_NOSTOREID	 	0x08

// there is no header offset in the article because the headers start
// at byte 0.  saves us two bytes.
#define FL_NOHEADEROFFSET	0x10

// the XRef header isn't at the front of the file, so we didn't store it
// offset.  this means that the server can't dynamically replace it.
#define FL_NOXREFLEN		0x20

// the XRef: header in the article reflects reality
#define FL_XREFVALID	 	0x40

// there is another byte of flags following this one
#define FL_MOREFLAGS		0x80

// this structure contains the store ID's which we give to the driver
// when requesting articles
typedef struct {
	WORD	cData;
	BYTE	*pbData;
} STOREID;

typedef struct {
	DWORD	dwArticleID;
	DWORD	dwGroupID;
} NNTPID;

typedef struct {
	STOREID	storeid;
	WORD	cCrossposts;
	NNTPID	rgnntpidCrossposts;
} STOREENTRY;

class CPrimaryXOverEntry {
	// the key
	NNTPID		nntpidPrimary;

	// bitmask flags listed above
	BYTE		Flags;

	// length of the headers (to the CRLFCRLF)
	WORD		cHeaderLength;	

	// creation date of the message
	TIMEDATE	timeCreationDate;

	// number of bytes of junk at the beginning of the article, before the
	// headers start
	WORD 		iHeaderOffset;

	// length of the XRef header
	WORD		cXRefHeader;

	// message ID of the article
	LPSTR		pszMessageID;

	// the number of entries in the store entries array
	DWORD		cStoreEntries;
	// the array of store entries
	STOREENTRY	*rgStoreEntries;
};

class CSecondaryXOverEntry {
	NNTPID		nntpidSecondary;
	BYTE		Flags;
	NNTPID		nntpidPrimary;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\isrpcexp.h ===
//
//  Dll initialization and termination
//

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

dllexp
BOOL
InitializeServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

dllexp
BOOL
CleanupServiceRpc(
               VOID
               );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntpbld.h ===
#ifndef _NNTPBLD_H_

//
//	Cancel states - redefined for rootscan lib !
//
#define NNTPBLD_CMD_NOCANCEL		0
#define NNTPBLD_CMD_CANCEL_PENDING	1
#define NNTPBLD_CMD_CANCEL			2

#define NNTPBLD_DEGREE_THOROUGH                 0x00000000
#define NNTPBLD_DEGREE_STANDARD                 0x00000001
#define NNTPBLD_DEGREE_MEDIUM                   0x00000010

typedef struct _NNTPBLD_PARAMS
{
	IIS_VROOT_TABLE*	pTable;
	LPSTR				szFile;
	HANDLE				hOutputFile;
	BOOL				fRejectEmpties;
	//BOOL				DeleteIndexFiles;
	DWORD				ReuseIndexFiles;
	LPDWORD 			pdwTotalFiles;
	LPDWORD 			pdwCancelState;
	LPSTR				szErrString;
	
} NNTPBLD_PARAMS, *PNNTPBLD_PARAMS;

BOOL
ScanRoot(	
    PVOID          pvContext,
    MB *           pmb,
    VIRTUAL_ROOT * pvr
    );

#endif	// _NNTPBLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntperr.h ===
/************************************************************************
*                                                                       *
*   nntperr.h -- HRESULT  code definitions for NNTP  					*
*                                                                       *
*   Copyright (c) 1991-1998, Microsoft Corp. All rights reserved.       *
*                                                                       * 
*   Facility code: 0x20 ( for NNTP )	                                *
*                                                                       *
************************************************************************/
#ifndef _NNTPERR_H_
#define _NNTPERR_H_
#include <winerror.h>

//
// MessageId: NNTP_E_CREATE_DRIVER	
//
// MessageText:
//
// Create store driver failed.
//
#define NNTP_E_CREATE_DRIVER		_HRESULT_TYPEDEF_(0x80200001L)

//
// MessageId: NNTP_E_DRIVER_ALREADY_INITIALIZED
//
// MessageText:
//
// Driver has already been initialized.
//
#define NNTP_E_DRIVER_ALREADY_INITIALIZED	_HRESULT_TYPEDEF_(0x80200002L)

//
// MessageId: NNTP_E_DRIVER_NOT_INITIALIZED
//
// MessageText:
//
// Driver has not been initialized yet.
//
#define NNTP_E_DRIVER_NOT_INITIALIZED	_HRESULT_TYPEDEF_(0x80200003L)

//
// MessageId: NNTP_E_REMOTE_STORE_DOWN
//
// MessageText:
//
// The remote store has been shutdown
//
#define NNTP_E_REMOTE_STORE_DOWN	_HRESULT_TYPEDEF_(0x80200004L)

//
// MessageId: NNTP_E_GROUP_CORRUPT
//
// MessageText:
//
// The group properties are corrupted
//
#define NNTP_E_GROUP_CORRUPT		_HRESULT_TYPEDEF_(0x80200005)

//
// MessageId: NNTP_E_PARTIAL_COMPLETE
//
// Message Text:
//
// Only part of the operation succeeded
//
#define NNTP_E_PARTIAL_COMPLETE		_HRESULT_TYPEDEF_(0x80200006)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntpbag.h ===
// NNTPPropertyBag.h : Declaration of the CNNTPPropertyBag

#ifndef __NNTPPROPERTYBAG_H_
#define __NNTPPROPERTYBAG_H_

#include "nntpdrv.h"
#include <propbag.h>

#define MAX_GROUP_PROPERTIES 64

/////////////////////////////////////////////////////////////////////////////
// Bag ID Definitions:  
// 
// Properties on the newsgroup object
#define NEWSGRP_PROP_NATIVENAME         0x00000001
#define NEWSGRP_PROP_NAME               0x00000002
#define NEWSGRP_PROP_GROUPID            0x00000004
#define NEWSGRP_PROP_LASTARTICLE        0x00000008
#define NEWSGRP_PROP_FIRSTARTICLE       0x00000010
#define NEWSGRP_PROP_ARTICLECOUNT       0x00000020
#define NEWSGRP_PROP_READONLY           0x00000040
#define NEWSGRP_PROP_NAMELEN			0x00000080
#define NEWSGRP_PROP_ISSPECIAL			0x00000100
#define NEWSGRP_PROP_DATELOW			0x00000200
#define NEWSGRP_PROP_DATEHIGH			0x00000400
#define NEWSGRP_PROP_PRETTYNAME			0x00002000
#define NEWSGRP_PROP_DESC				0x00004000
#define NEWSGRP_PROP_MODERATOR			0x00008000

// Properties that are in the bag
#define NEWSGRP_PROP_FIXOFFSET			0x80000001

#define FIX_PROP_NAME			0x00000001
#define FIX_PROP_GROUPID		0x00000002
#define FIX_PROP_LASTARTICLE	0x00000004
#define FIX_PROP_FIRSTARTICLE	0x00000008
#define FIX_PROP_ARTICLECOUNT	0x00000010
#define FIX_PROP_READONLY		0x00000020
#define FIX_PROP_NAMELEN		0x00000040
#define FIX_PROP_ISSPECIAL		0x00000080
#define FIX_PROP_DATELOW		0x00000100
#define FIX_PROP_DATEHIGH		0x00000200
#define FIX_PROP_FIXOFFSET		0x00000400

#define DRIVER_OWNED_MASK	0x80000000

#define DRIVER_OWNED( propid ) (( DRIVER_OWNED_MASK & propid ) != 0 )

class CNewsGroupCore;

/////////////////////////////////////////////////////////////////////////////
// CNNTPPropertyBag
class CNNTPPropertyBag :   public INNTPPropertyBag
{
	enum STRING_COMP_RESULTS {
		SAME = 0,
		DIFFER_IN_CASE,
		DIFFER 
	};

private:
    //
    // Pointer to the newsgroup object
    //
    CNewsGroupCore* m_pParentGroup;

    //
    // Reference counting.  we use our parent objects reference count, so
	// that it won't get deleted out from under us.
    //
    LONG   *m_pcRef;

	// 
	// The property bag for driver related properties
	//
    CPropBag m_PropBag;

	//
	// Have any properties changed?
	// 
	BOOL	m_fPropChanges;

	//
	// Static utility functions
	//
	static STRING_COMP_RESULTS ComplexStringCompare( LPCSTR sz1, LPCSTR sz2, DWORD dwLen );

public:
    //
    // Constructors
    //
    CNNTPPropertyBag( CNewsGroupCore* pParent = NULL , LONG *pcRef = NULL) 
    {
        m_pParentGroup = pParent;
		if (pParent != NULL) {
			_ASSERT(pcRef != NULL);
			m_pcRef = pcRef;
		}
		m_pcRef = NULL;
		m_fPropChanges = FALSE;
    }

    //
    // Initialization function
    //
    VOID Init( CNewsGroupCore* pParent, LONG *pcRef  ) {
        m_pParentGroup = pParent;
		_ASSERT(pcRef != NULL);
		m_pcRef = pcRef;
    }

	CNewsGroupCore *GetGroup() { return m_pParentGroup; }

// INNTPPropertyBag
public:
    STDMETHOD(Validate)();
	STDMETHOD(RemoveProperty)(IN DWORD dwID);
    STDMETHOD(GetBool)(IN DWORD dwID, OUT PBOOL pfValue );
    STDMETHOD(PutBool)(IN DWORD dwID, IN BOOL fValue );
	STDMETHOD(GetInterface)(IN DWORD dwID, IN OUT IUnknown** ppunkValue);
	STDMETHOD(PutInterface)(IN DWORD dwID, IN IUnknown* punkValue);
	STDMETHOD(GetDWord)(IN DWORD dwID, OUT PDWORD pdwValue);
	STDMETHOD(PutDWord)(IN DWORD dwID, IN DWORD dwValue);
	STDMETHOD(GetBLOB)(IN DWORD dwID, OUT PBYTE pbValue, OUT PDWORD pcbValue);
	STDMETHOD(PutBLOB)(IN DWORD dwID,  IN DWORD cbValue, IN PBYTE pbValue);

    //
    // Implementation of IUnknown
    //
    HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    {
		_ASSERT(m_pcRef != NULL);
        if ( iid == IID_IUnknown ) {
            *ppv = static_cast<INNTPPropertyBag*>(this);
        } else if ( iid == IID_INNTPPropertyBag ) {
            *ppv = static_cast<INNTPPropertyBag*>(this);
        } else {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    ULONG __stdcall AddRef()
    {
		_ASSERT(m_pcRef != NULL);
        return InterlockedIncrement( m_pcRef );
    }

    ULONG __stdcall Release();
};

#endif //__NNTPPROPERTYBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntpcons.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpcons.h

Abstract:

    This module contains global constants for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPCONS_
#define _NNTPCONS_

//
// manifest constants
//

#define     KB                          1024
#define     MEG                         (KB * KB)
#define     MAX_NNTP_LINE               512
//
// convert to seconds
//

#define     SEC_PER_MIN                 (60)
#define     SEC_PER_HOUR                (60* SEC_PER_MIN)
#define     SEC_PER_DAY                 (24* SEC_PER_HOUR)
#define     SEC_PER_WEEK                (7 * SEC_PER_DAY)

//
// Port numbers
//

#define     NNTP_PORT                   119
#define     NNTP_SSL_PORT               563

//
// Id values
//

#define     GROUPID_INVALID             0xffffffff
#define     GROUPID_DELETED             0xfffffffe

#define     ARTICLEID_INVALID           0xffffffff

//
// Secret data name
//

#define NNTP_SSL_CERT_SECRET    L"NNTP_CERTIFICATE"
#define NNTP_SSL_PKEY_SECRET    L"NNTP_PRIVATE_KEY"
#define NNTP_SSL_PWD_SECRET     L"NNTP_SSL_PASSWORD"

//
// Default pull date/time
//

#define DEF_PULL_TIME           "000000"

//
// Maximum xover reference
//

#define MAX_REFERENCES_FIELD             512

//
//	Newsgroup constants
//
//

const   DWORD   MAX_NEWSGROUP_NAME = 512 ;
const	DWORD	MAX_DESCRIPTIVE_TEXT = 512 ;
const	DWORD	MAX_MODERATOR_NAME = 512 ;
const	DWORD	MAX_VOLUMES = 1;
const	DWORD	MAX_PRETTYNAME_TEXT = 72 ;

//
//  Maximmum number of CSessionSocket objects !
//
#define MAX_SESSIONS    15000

//
//  Maximum number of CPacket derived objects
//
#define MAX_PACKETS     (20 * MAX_SESSIONS)

//
//  Maximum number of Buffers
//
#define MAX_BUFFERS     (MAX_SESSIONS * 8)

//
//  Maximum number of CChannel derived objects
//
#define MAX_CHANNELS    (8 * MAX_SESSIONS)

//
//  Maximum number of CInFeed derived objects
//
#define MAX_FEEDS   MAX_SESSIONS

//
//  Maximum number of CSessionState Derived Objects !
//
#define MAX_STATES      (3 * MAX_SESSIONS)

#endif // _NNTPCONS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntptype.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntptype.h

Abstract:

    This file contains information about the MSN Replication Service Admin
        APIs.

Author:

    Johnson Apacible (johnsona)         10-Sept-1995

--*/


#ifndef _NNTPTYPE_
#define _NNTPTYPE_

#ifdef __cplusplus
extern "C" {
#endif

typedef DWORD FEED_TYPE;

#define FEED_TYPE_INVALID           0xffffffff

//
// Function types
//
typedef
BOOL
(*GET_DEFAULT_DOMAIN_NAME_FN)(PCHAR,DWORD);

//
// Type of feed we are managing
//

#define FEED_TYPE_PULL              0x00000000
#define FEED_TYPE_PUSH              0x00000001
#define FEED_TYPE_PASSIVE           0x00000002
#define FEED_ACTION_MASK            0x0000000f

//
// Type of server we are talking to
//

#define FEED_TYPE_PEER              0x00000000
#define FEED_TYPE_MASTER            0x00000010
#define FEED_TYPE_SLAVE             0x00000020
#define FEED_REMOTE_MASK            0x000000f0

//
// Should this go through a secure channel like SSL?
//

#define FEED_TYPE_SSL               0x00000100

//
// Valid bits
//

#define FEED_TYPE_MASK              (FEED_TYPE_PULL | FEED_TYPE_PUSH | \
                                    FEED_TYPE_PASSIVE | FEED_TYPE_PEER | \
                                    FEED_TYPE_MASTER | FEED_TYPE_SLAVE | \
                                    FEED_TYPE_SSL)


//
// Macros
//

#define FEED_IS_SSL( _x )           (((_x) & FEED_TYPE_SSL) != 0)
#define FEED_IS_SLAVE( _x )         (((_x) & FEED_TYPE_SLAVE) != 0)
#define FEED_IS_MASTER( _x )        (((_x) & FEED_TYPE_MASTER) != 0)
#define FEED_IS_PEER( _x )          (((_x) & 0x000000f0) == 0)
#define FEED_IS_PULL( _x )          (((_x) & 0x0000000f) == 0)
#define FEED_IS_PUSH( _x )          (((_x) & FEED_TYPE_PUSH) != 0)
#define FEED_IS_PASSIVE( _x )       (((_x) & FEED_TYPE_PASSIVE) != 0)

//
//  Simple types.
//

#define CHAR char                       // For consitency with other typedefs.

typedef DWORD APIERR;                   // An error code from a Win32 API.
typedef INT SOCKERR;                    // An error code from WinSock.

#ifdef __cplusplus
}
#endif

#endif _NNTPTYPE_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntpmacr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpmacr.h

Abstract:

    This module contains macross for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPMACR_
#define _NNTPMACR_


#define ALLOCATE_HEAP( nBytes ) LocalAlloc( 0, nBytes )
#define FREE_HEAP( _heap )      LocalFree( (PVOID)(_heap) )

//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

//
// Convert FILETIME TO LIs
//

#define LI_FROM_FILETIME( _pLi, _pFt ) {               \
            (_pLi)->LowPart = (_pFt)->dwLowDateTime;   \
            (_pLi)->HighPart = (_pFt)->dwHighDateTime; \
            }

#define FILETIME_FROM_LI( _pFt, _pLi ) {               \
            (_pFt)->dwLowDateTime = (_pLi)->LowPart;   \
            (_pFt)->dwHighDateTime = (_pLi)->HighPart; \
            }

//
// LockStatistics
//

#define LockStatistics( pInst )						ACQUIRE_LOCK( &pInst->m_StatLock );
#define UnlockStatistics( pInst )					RELEASE_LOCK( &pInst->m_StatLock );
#define IncrementStat( pInst, _x )					((pInst->m_NntpStats). ## _x)++;
#define DecrementStat( pInst, _x )					((pInst->m_NntpStats). ## _x)--;
#define InterlockedIncrementStat( pInst, _x )		InterlockedIncrement((LPLONG)&((pInst->m_NntpStats). ## _x));
#define InterlockedDecrementStat( pInst, _x )		InterlockedDecrement((LPLONG)&((pInst->m_NntpStats). ## _x));
#define InterlockedExchangeAddStat( pInst, _x, _y )	InterlockedExchangeAdd( (PLONG)&((pInst->m_NntpStats). ## _x), (LONG)(_y) )
#define AddByteStat( pInst, _x, _y ) \
        if( (ULONG)InterlockedExchangeAdd( (PLONG)&(((pInst->m_NntpStats). ## _x).LowPart), (LONG)(_y)) \
			> ( ULONG_MAX - (ULONG)(_y) ) ) InterlockedIncrement( (LPLONG)&(((pInst->m_NntpStats). ## _x).HighPart) );

//
// debug constants\macros
//

#define  NNTP_DEBUG_REGISTRY        0x00000004
#define  NNTP_DEBUG_EXPIRE          0x00000008
#define  NNTP_DEBUG_LOCKS           0x00000010
#define  NNTP_DEBUG_ARTMAP          0x00000020
#define  NNTP_DEBUG_HISTORY         0x00000040
#define  NNTP_DEBUG_HEAP            0x00000080
#define  NNTP_DEBUG_HASH            0x00000100
#define  NNTP_DEBUG_SECURITY        0x00000200
#define  NNTP_DEBUG_FEEDMGR         0x00000400
#define  NNTP_DEBUG_FEEDBLOCK       0x00000800

extern DWORD DebugLevel;
#define DO_DEBUG( flag ) \
    if ( DebugLevel & (NNTP_DEBUG_ ## flag) )

//
// on debug build define all inline functions as regular functions.
// copied from msndef.h
//

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

//
// from extcmk2.h
//

#define fCharInSet(ch, set) (NULL !=strchr(set, ch))
#define STRLEN(sz) (sizeof(sz)-1)
#define	fWhitespace(ch) fCharInSet(ch, szWSChars)
#define	fWhitespaceNull(ch) fCharInSet(ch, szWSNullChars)
#define	fWhitespaceNewLine(ch) fCharInSet(ch, szWSNLChars)
#define	fNewLine(ch) ( ( ch != '\0' ) && fCharInSet(ch, szNLChars) )

#ifndef	Assert
#define Assert _ASSERT
#endif

//
//	Virtual Server scoping macros
//
#define XOVER_TABLE(   pTree )		((pTree->GetVirtualServer())->XoverTable())
#define ARTICLE_TABLE( pTree )		((pTree->GetVirtualServer())->ArticleTable())
#define HISTORY_TABLE( pTree )		((pTree->GetVirtualServer())->HistoryTable())
#define XOVER_CACHE( pTree )		((pTree->GetVirtualServer())->XoverCache())
#define EXPIRE_OBJECT( pTree )		((pTree->GetVirtualServer())->ExpireObject())
#define INST( pS )					((pS->m_context).m_pInstance)

//
//	Delete macros
//
#define DELETE_CHK( ptr )	if( ptr ) { delete ptr ; ptr = NULL ; }

#endif // _NNTPMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\jetobj.h ===
// Jetobj.h
// Low level jet object.

#ifndef	_JETOBJ_H_
#define	_JETOBJ_H_

#include "jet.h"

#ifdef __cplusplus
extern "C"
{
#endif

#define Call( fn )	{								\
						if ( ( err = fn ) < 0 )		\
							goto Exit;				\
					}

// We need to come up with some way of overriding these values.
#define JP_RECOVERY			"on"
#define JP_SYSPATH			"c:\\mcisdb\\"
#define JP_TMPPATH			"c:\\mcisdb\\"
#define JP_LOGPATH			"c:\\mcisdb\\"
#define JP_DBNAME_MAIN		"d:\\mcisdb\\main"
#define JP_DBNAME_ROOT		"d:\\mcisdb\\root"
#define JP_BASENAME			"mdb"
#define JP_NUMSESS			64
#define JP_MAXOPENTABLES	5*64
#define JP_MAXCURSORS		5*64
#define JP_MAXVERPAGES		250
#define JP_STARTTHRESH		60
#define JP_STOPTHRESH		120
#define JP_MINCACHE         1000
#define JP_MAXCACHE			2000
#define JP_LOGBUFS			84
#define JP_LOGPERIOD		1000
#define JP_LOGCIRCULAR		1
#define JP_USER				"admin"
#define JP_PSWD				"\0"

#define TAG_COUNT			9999999

#define CF_NONE				0
#define CF_APPEND			JET_bitSetAppendLV;
#define CF_LVHANDLE			JET_bitRetrieveLVToFile;

typedef JET_COLUMNID ColumnId;

typedef enum ReadType
{
	rtNext,
	rtPrev,
	rtFirst,
	rtLast,
	rtExact,
	rtGreaterOrEqual,
	rtLessOrEqual,
	rtGreater,
	rtLess
};

typedef struct
{
	char szRecovery[5];
	char szSysPath[256];
	char szTmpPath[256];
	char szLogPath[256];
	char szBaseName[5];
	char szDBMain[256];
	char szDBRoot[256];
	DWORD dwMaxSessions;
	DWORD dwMaxOpenTables;
	DWORD dwMaxCursors;
	DWORD dwMaxVerPages;
	DWORD dwStartThresh;
	DWORD dwStopThresh;
	DWORD dwMinCache;
	DWORD dwMaxCache;
	DWORD dwLogBufs;
	DWORD dwLogPeriod;
	DWORD dwCircularLog;
	char szUser[50];
	char szPswd[50];
} JetSystemParameters;

typedef struct
{ 
	char *pszName;
	ColumnId cid;
	DWORD dwTag;
	DWORD cbData;
	void *pvData;
	DWORD dwFlags;
	DWORD cbOffset;
} Column;

typedef struct 
{
	DWORD dwOffset;
	DWORD dwOffsetHigh;
	DWORD dwLength;
} ScatterListEntry;

typedef struct
{
	DWORD dwEntries;
	ScatterListEntry sle[1];
} ScatterList;

BOOL InitializeNNTPJetLibrary(JetSystemParameters *pjsp = NULL);
BOOL TermNNTPJetLibrary();
void SetJetDefaults(JetSystemParameters *pjsp);

__declspec(dllexport) BOOL __stdcall InitializeJetLibrary(JetSystemParameters *pjsp = NULL);
__declspec(dllexport) BOOL __stdcall TermJetLibrary();
__declspec(dllexport) void* __stdcall GetJetObject(char *pszObjName);

typedef BOOL (__stdcall FN_INITIALIZEJETLIBRARY)(JetSystemParameters *pjsp = NULL);
typedef BOOL (__stdcall FN_TERMJETLIBRARY)();
typedef void* (__stdcall FN_GETJETOBJ)(char *psz);

class CJetDatabaseImp;
class CJetTableImp;
class CJetTransactionImp;
class CJetSession;
class CJetDatabase;

extern __declspec(thread) CJetSession * g_pjsess;
extern __declspec(thread) CJetDatabase * g_pjdb;
extern HINSTANCE g_hInst;
extern FN_GETJETOBJ *g_pfnGetObj;
extern JET_INSTANCE g_instance;

class CJetSession
{
public:
	virtual void Close() = 0;
	virtual BOOL Open() = 0;
};

class CJetDatabase
{
public:
	virtual void Close() = 0;
	virtual BOOL Open(CJetSession *pjsess,char *pszDBName) = 0;
};

class CJetTable
{
public:
	virtual void Close() = 0;
	virtual BOOL GetColumnIds(Column *pcol,DWORD ccol) = 0;
	virtual BOOL Open(CJetSession *pjsess,CJetDatabase *pjdb,
		char *pszTableName) = 0;
	virtual void SetDefaultIndex(char *pszIndex) = 0; 
	virtual BOOL Delete(void *pvIndex) = 0; 
	virtual BOOL Delete(void *pvIndex,DWORD dwLen) = 0; 
	virtual BOOL Delete(char *pszIndex,void *pvIndex) = 0;
	virtual BOOL Delete(char *pszIndex,void *pvIndex,DWORD dwLen) = 0;
	virtual BOOL FreeHandle(HANDLE hFile) = 0;
	virtual DWORD GetEntryCount() = 0;
	virtual BOOL Read(void *pvIndex,Column *pcol,DWORD ccol,
		ReadType rt) = 0;
	virtual BOOL Read(void *pvIndex,DWORD dwLen,Column *pcol,DWORD ccol,
		ReadType rt) = 0;
	virtual BOOL Read(char *pszIndex,void *pvIndex,Column *pcol,
		DWORD ccol,ReadType rt) = 0;
	virtual BOOL Read(char *pszIndex,void *pvIndex,DWORD dwLen,Column *pcol,
		DWORD ccol,ReadType rt) = 0;
	virtual BOOL Transmit(void *pvIndex,ColumnId cid,HANDLE hSocket) = 0;
	virtual BOOL Transmit(void *pvIndex,DWORD dwLen,ColumnId cid,HANDLE hSocket) = 0;
	virtual BOOL Transmit(char *pszIndex,void *pvIndex,ColumnId cid,HANDLE hSocket) = 0;
	virtual BOOL Transmit(char *pszIndex,void *pvIndex,DWORD dwLen,ColumnId cid,HANDLE hSocket) = 0;
	virtual BOOL Update(void *pvIndex,Column *pcol,DWORD ccol,
		BOOL fEscrow = FALSE) = 0;
	virtual BOOL Update(void *pvIndex,DWORD dwLen,Column *pcol,DWORD ccol,
		BOOL fEscrow = FALSE) = 0;
	virtual BOOL Update(char *pszIndex,void *pvIndex,Column *pcol,
		DWORD ccol,BOOL fEscrow = FALSE) = 0;
	virtual BOOL Update(char *pszIndex,void *pvIndex,DWORD dwLen,
		Column *pcol,DWORD ccol,BOOL fEscrow = FALSE) = 0;
	virtual BOOL Write(Column *pcol,DWORD ccol) = 0;
};

class CJetTransaction
{
public:
	virtual BOOL Begin(CJetSession *pjsess) = 0;
	virtual BOOL Commit() = 0;
	virtual BOOL Rollback() = 0;
};


class CJetSessionImp : public CJetSession
{
public:
	CJetSessionImp();
	~CJetSessionImp();

	void Close();
	BOOL Open();

protected:
	JET_INSTANCE m_instance;
	JET_SESID m_sesid;

	friend class CJetDatabaseImp;
	friend class CJetTableImp;
	friend class CJetTransactionImp;
};

class CJetDatabaseImp : public CJetDatabase
{
public:
	CJetDatabaseImp();
	~CJetDatabaseImp();

	void Close();
	BOOL Open(CJetSession *pjsess,char *pszDBName);

protected:
	CJetSessionImp *m_pjsess;
	JET_DBID m_dbid;

	friend class CJetTableImp;
};

class CJetTableImp : public CJetTable
{
public:
	CJetTableImp();
	~CJetTableImp() {Close();};

	void Close();
	BOOL GetColumnIds(Column *pcol,DWORD ccol);
	BOOL Open(CJetSession *pjsess,CJetDatabase *pjdb,char *pszTableName);
	void SetDefaultIndex(char *pszIndex) {strcpy(m_szIndexDefault,pszIndex);};

	BOOL Delete(void *pvIndex) 
	{
		return Delete(m_szIndexDefault,pvIndex,0);
	};
	BOOL Delete(void *pvIndex,DWORD dwLen) 
	{
		return Delete(m_szIndexDefault,pvIndex,dwLen);
	};
	BOOL Delete(char *pszIndex,void *pvIndex)
	{
		return Delete(pszIndex,pvIndex,0);
	};
	BOOL Delete(char *pszIndex,void *pvIndex,DWORD dwLen);

	BOOL FreeHandle(HANDLE hFile);
	
	DWORD GetEntryCount();

	BOOL Read(void *pvIndex,Column *pcol,DWORD ccol,ReadType rt)
	{
		return Read(m_szIndexDefault,pvIndex,0,pcol,ccol,rt);
	};
	BOOL Read(void *pvIndex,DWORD dwLen,Column *pcol,DWORD ccol,
		ReadType rt)
	{
		return Read(m_szIndexDefault,pvIndex,dwLen,pcol,ccol,rt); 
	};
	BOOL Read(char *pszIndex,void *pvIndex,Column *pcol,DWORD ccol,ReadType rt)
	{
		return Read(pszIndex,pvIndex,0,pcol,ccol,rt);
	};
	BOOL Read(char *pszIndex,void *pvIndex,DWORD dwLen,Column *pcol,
		DWORD ccol,ReadType rt);

	BOOL Transmit(void *pvIndex,ColumnId cid,HANDLE hSocket)
	{
		return Transmit(m_szIndexDefault,pvIndex,0,cid,hSocket);
	};
	BOOL Transmit(void *pvIndex,DWORD dwLen,ColumnId cid,HANDLE hSocket)
	{
		return Transmit(m_szIndexDefault,pvIndex,dwLen,cid,hSocket); 
	};
	BOOL Transmit(char *pszIndex,void *pvIndex,ColumnId cid,HANDLE hSocket)
	{
		return Transmit(pszIndex,pvIndex,0,cid,hSocket);
	};
	BOOL Transmit(char *pszIndex,void *pvIndex,DWORD dwLen,ColumnId cid,HANDLE hSocket);

	BOOL Update(void *pvIndex,Column *pcol,DWORD ccol,
		BOOL fEscrow = FALSE)
	{
		return Update(m_szIndexDefault,pvIndex,0,pcol,ccol,fEscrow);
	};
	BOOL Update(void *pvIndex,DWORD dwLen,Column *pcol,DWORD ccol,
		BOOL fEscrow = FALSE)
	{
		return Update(m_szIndexDefault,pvIndex,dwLen,pcol,ccol,fEscrow);
	};
	BOOL Update(char *pszIndex,void *pvIndex,Column *pcol,
		DWORD ccol,BOOL fEscrow = FALSE)
	{
		return Update(pszIndex,pvIndex,0,pcol,ccol,fEscrow);
	};
	BOOL Update(char *pszIndex,void *pvIndex,DWORD dwLen,
		Column *pcol,DWORD ccol,BOOL fEscrow = FALSE);

	BOOL Write(Column *pcol,DWORD ccol);

protected:
	CJetSessionImp *m_pjsess;
	CJetDatabaseImp *m_pjdb;
	JET_TABLEID m_tid;
	char m_szIndexDefault[255];
	char m_szIndexCurr[255];
};

class CJetTransactionImp : public CJetTransaction
{
public:
	CJetTransactionImp();
	~CJetTransactionImp();

	BOOL Begin(CJetSession *pjsess);
	BOOL Commit();
	BOOL Rollback();

protected:
	CJetSessionImp *m_pjsess;
	BOOL m_fInTransaction;
};

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntpret.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpret.h

Abstract:

    This module contains class declarations/definitions for

		CNntpReturn

    **** Overview ****

	This defines an object for setting, passing around, and
	viewing NNTP-style return codes. Each object has a
	return code number and a return code string.

	It is designed to be efficient in the average case by
	not requiring copying or lookup of the most common
	codes (like nrcOK).

	!!! This should eventually be merged with the standard
	Microsoft Message Compiler so that localization would be
	possible.

Author:

    Carl Kadie (CarlK)     29-Oct-1995

Revision History:


--*/

#ifndef	_NNTPRET_H_
#define	_NNTPRET_H_

//
// The maximum size of a nntp return message
//
//	By default we send buffers of 512 characters, so make this
//	constant small enough to fit in that, and leave leg room for 
//	encryption, and other stuff.
//
const DWORD maxCchNntpLine = 400;

//
// The message for when the object as not yet been set.
//

const char szNotSet[] = "<return code not set>";

//
// The return message for when all is OK.
//

const char szOK[] = "All OK";

//
// The return codes. Some of these are defined by the
// NNTP spec.
//

typedef enum {

	nrcHelpFollows						= 100,
	nrcDateFollows						= 111,

	nrcServerReady						= 200,
	nrcServerReadyNoPosts				= 201,
	nrcSlaveStatusNoted					= 202,
	nrcExtensionsFollow					= 202,	// List extension data follows
	nrcModeStreamSupported				= 203,
	nrcGoodBye							= 205,

	nrcGroupSelected					= 211,

	nrcListGroupsFollows				= 215,

	nrcArticleFollows					= 220,
	nrcHeadFollows						= 221,
	nrcBodyFollows						= 222,
	nrcHeadFollowsRequestBody			= 223,	/* what the does this mean ? */
	nrcXoverFollows						= 224,

	nrcNewnewsFollows					= 230,
	nrcNewgroupsFollow					= 231,

	nrcSWantArticle						= 238, 
	nrcSTransferredOK					= 239,
	
	nrcArticleTransferredOK				= 235,
	nrcArticlePostedOK					= 240,

	nrcPostOK							= 340,
	nrcXReplicOK						= 341,
	nrcIHaveOK							= 335,

	nrcPassRequired						= 381,
	nrcLoggedOn							= 281,

	//
	// 4xx - Command was correct, but couldnt be performed for some reason.
	//

	nrcSNotAccepting					= 400,

	nrcNoSuchGroup						= 411,
	nrcNoGroupSelected					= 412,
	nrcNoCurArticle						= 420,
	nrcNoNextArticle					= 421, 
	nrcNoPrevArticle					= 422,
	nrcNoArticleNumber					= 423,
	nrcNoSuchArticle					= 430,
	nrcSTryAgainLater					= 431,
	nrcNotWanted						= 435,
	nrcTransferFailedTryAgain			= 436,
	nrcTransferFailedGiveUp				= 437,
	nrcSAlreadyHaveIt					= 438,
	nrcSArticleRejected					= 439,
	nrcPostingNotAllowed				= 440,
	nrcPostFailed						= 441,
    nrcPostModeratedFailed              = 442,
	nrcLogonFailure						= 451,
	nrcNoMatchesFound					= 460,
	nrcErrorPerformingSearch			= 462,
	nrcLogonRequired					= 480,
	nrcNoListgroupSelected				= 481,

	nrcSupportedProtocols				= 485,

	//
	// 5xx - Problem with command
	//

	nrcNotRecognized					= 500,
	nrcSyntaxError						= 501,
	nrcNoAccess							= 502,
	nrcServerFault						= 503,

	//
	// 6xx - Used here for internal error codes that should never be
	// shown to the outside
	//

	nrcOK								= 600,
	nrcArticleTooManyFieldOccurances	= 602,
	nrcArticleMissingField				= 603,
	nrcArticleBadField					= 604,
	nrcArticleIncompleteHeader			= 605,
	nrcArticleMissingHeader				= 606,
	nrcArticleFieldZeroValues			= 607,
	nrcArticleFieldMessIdNeedsBrack		= 608,
	nrcArticleFieldMissingValue			= 609,
	nrcArticleFieldIllegalNewsgroup		= 610,
	nrcArticleTooManyFields				= 611,
	nrcMemAllocationFailed				= 612,
	nrcArticleFieldMessIdTooLong		= 613,
	nrcErrorReadingReg					= 614,
	nrcArticleDupMessID					= 615,
	nrcArticleMappingFailed				= 616,
	nrcArticleAddLineBadEnding			= 617,
	nrcPathLoop							= 618,
	nrcArticleInitFailed				= 619,
	nrcNewsgroupInsertFailed			= 620,
	nrcNewsgroupAddRefToFailed			= 621,
	nrcHashSetArtNumSetFailed			= 622,
	nrcHashSetXrefFailed				= 623,
	nrcOpenFile							= 624,
	nrcArticleBadFieldFollowChar		= 625,
	nrcArticleBadChar					= 626,
	nrcDuplicateComponents				= 627,
	nrcArticleFieldIllegalComponent		= 628,
	nrcArticleBadMessageID				= 629,
	nrcArticleFieldBadChar				= 630,
	nrcArticleFieldDateIllegalValue		= 631,
	nrcArticleFieldDate4DigitYear		= 632,
	nrcArticleFieldAddressBad			= 633,
	nrcArticleXoverTooBig				= 634,
	nrcCreateNovEntryFailed				= 635,
	nrcArticleXrefBadHub				= 637,
	nrcArticleNoSuchGroups				= 638,
	nrcHashSetFailed					= 639,
	nrcArticleTableCantDel				= 640,
	nrcArticleTableError				= 641,
	nrcArticleTableDup					= 642,
	nrcCantAddToQueue					= 643,
	nrcSlaveGroupMissing				= 644,
	nrcInconsistentMasterIds			= 645,
	nrcInconsistentXref					= 646,
	nrcArticleDateTooOld				= 647,
	nrcArticleTooLarge					= 648,
    nrcIllegalControlMessage            = 649,
    nrcNotYetImplemented                = 650,
    nrcControlNewsgroupMissing          = 651,
    nrcBadNewsgroupNameLen              = 652,
    nrcNewsgroupDescriptionTooLong      = 653,
    nrcCreateNewsgroupFailed            = 654,
    nrcGetGroupFailed                   = 655,
    nrcControlMessagesNotAllowed        = 656,
	nrcHeaderTooLarge					= 657,
	nrcServerEventCancelledPost			= 658,

	nrcMsgIDInHistory					= 660,
	nrcMsgIDInArticle					= 661,
	nrcSystemHeaderPresent				= 662,

	//
	// Special value
	//

	nrcNotSet							= -1

} NNTP_RETURN_CODE;

// this macro takes an NNTP return code and checks to see if its an error
// code.  
#define NNTPRET_IS_ERROR(__dwErrorCode__) (__dwErrorCode__ >= 400 && __dwErrorCode__ < 600)

typedef NNTP_RETURN_CODE NRC;

//
//	Gets the NNTP Return code from a string. used for newnews feeds.
//

BOOL	ResultCode(
				   char*	szCode,
				   NRC&	nrcOut
				   ) ;

//
//
//
// CNntpReturn - class a return code (and message) object.
//

class CNntpReturn
{
public:

	//
	// Constructor
	//

	CNntpReturn(void) :
		  m_nrc(nrcNotSet),
		  m_sz(szNotSet)
		  {}

	//
	// Set the record code, while giving arguments to the message.
	//

	BOOL fSet(
			NRC nrc,
			...
			);

	//
	// fSetEx is a faster version of fSet (it lazy evaluates the
	// _vsnprintf that is in fSet).  This can _only_ be used if it
	// can be guaranteed that szArg is a string literal or a global
	// with an unchanging value (it saves this pointer).
	//
	BOOL fSetEx(
			NRC nrc,
			char const *szArg);

	//
	// Test if object is clear of if it has been set
	//

	BOOL fIsClear(void){
			return nrcNotSet == m_nrc;
			}

	//
	// Test if the object has the value nrcOK
	//

	BOOL fIsOK(void){
			_ASSERT(!fIsClear());
			return nrcOK == m_nrc;
			}

	//
	// Test if the object has any specified return code.
	//

	BOOL fIs(NRC nrc){
		return nrc == m_nrc;
		}

	//
	// Return FALSE while asserting that the return code is not OK.
	//

	BOOL fFalse(void){
		_ASSERT(!fIsOK());
		return FALSE;
		}

	//
	// Set the return code to be OK
	//

	BOOL fSetOK(void);

	//
	// Set the return code not to be set.
	//

	BOOL fSetClear(void);

	//
	// The return code
	//

	NNTP_RETURN_CODE	m_nrc;

	//
	// get the return string
	const char *szReturn();

protected:

	//
	// Format the message with the arguments given by fSet
	//

	void vSzFormat(char const * & szFormat, BOOL &fHasFormatCodes);

	//
	// The buffer used to hold message when necessary.
	//

	char	m_szBuf[maxCchNntpLine];

	//
	// The return message.  if this is set to NULL then we are in lazy
	// evaluation mode, and nrc and m_szArg should be used to build
	// m_sz only when it is required
	//

	char	const *		m_sz;

	//
	// the argument for lazy evaluation where the only argument is %s
	//
	char	const *		m_szArg;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntpmeta.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	nntpmeta.h

Abstract:

	Defines the metabase IDs used by the NNTP service.

	See iiscnfg.h for IIS metabase IDs.
	See the metabase spreadsheet (on \\isbu\tigris) for parameter 
	ranges, and     descriptions of these properties.

Author:

	Magnus Hedlund (MagnusH)                --

Revision History:

	Kangrong Yan ( KangYan )  Feb 18, 1998	Added feed admin related property id's.
	AWetmore - Mar 24, 1998 - Added VRoot keys
	KangYan - May 16, 1998 - Added FS Driver related VRoot keys
	SNeely	12/28/2000 - Cleaned up definitions, removed unnecessary keys


NOTE:  WHEN UPDATING THIS FILE, BE SURE TO ALSO UPDATE THE SCHEMA IN
		ADMIN\ADSI\ADSIIS\GLOBDATA.CXX.

--*/

#ifndef _NNTPMETA_INCLUDED_
#define _NNTPMETA_INCLUDED_

//
// Pickup IIS values:
//

#include "iiscnfg.h"

//--------------------------------------------------------------------
//
//              Reserved Ranges:
//
//      See the iiscnfg.h file for IIS IDs.
//
//      IIS has reserved the range of IDs for news.
//
//--------------------------------------------------------------------

#ifndef NNTP_MD_ID_BEGIN_RESERVED
#define NNTP_MD_ID_BEGIN_RESERVED   0x0000b000
#endif

#ifndef NNTP_MD_ID_END_RESERVED
#define NNTP_MD_ID_END_RESERVED     0x0000bfff
#endif

//--------------------------------------------------------------------
// NNTP Server properties           (45056 -> 45155)
// NNTP Instance properties         (45156 -> 46155)
// NNTP Virtual root properties     (46156 -> 47155)
// NNTP File properties             (47156 -> 49151)
//--------------------------------------------------------------------

#define NNTP_MD_SERVER_BASE                (NNTP_MD_ID_BEGIN_RESERVED)
#define NNTP_MD_SERVICE_INSTANCE_BASE      (NNTP_MD_SERVER_BASE + 100)
#define NNTP_MD_VIRTUAL_ROOT_BASE          (NNTP_MD_SERVICE_INSTANCE_BASE + 1000)
#define NNTP_MD_FILE_BASE                  (NNTP_MD_VIRTUAL_ROOT_BASE + 1000)

//--------------------------------------------------------------------
//
//      User Types:
//
//--------------------------------------------------------------------

//
//      NNTP should use IIS_MD_UT_SERVER for all of its server properties,
//      and IIS_MD_UT_FILE for file properties.
//

//--------------------------------------------------------------------
//
//      Metabase Path Strings
//
//--------------------------------------------------------------------

#ifdef UNICODE

#define NNTP_MD_ROOT_PATH                       _T("/LM/NntpSvc/")
#define NNTP_MD_FEED_PATH                       _T("Feeds/")
#define NNTP_MD_EXPIRES_PATH                    _T("Expires/")

#else

#define NNTP_MD_ROOT_PATH                       "/LM/NntpSvc/"
#define NNTP_MD_FEED_PATH                       "Feeds/"
#define NNTP_MD_EXPIRES_PATH                    "Expires/"

#endif // UNICODE

//--------------------------------------------------------------------
//
//      Metabase IDs
//
//--------------------------------------------------------------------

//
//      Server (/LM/NntpSvc/) Properties:
//

// IIS Property identifiers that NNTP reuses:

// #define MD_HOSTNAME                     (IIS_MD_SERVER_BASE+10 )
// #define MD_IP_ADDRESS                   (IIS_MD_SERVER_BASE+11 )
// #define MD_PORT                         (IIS_MD_SERVER_BASE+12 )
// #define MD_CONNECTION_TIMEOUT           (IIS_MD_SERVER_BASE+13 )
// #define MD_MAX_CONNECTIONS              (IIS_MD_SERVER_BASE+14 )
// #define MD_SERVER_COMMENT               (IIS_MD_SERVER_BASE+15 )
// #define MD_AUTHORIZATION                (IIS_MD_FILE_PROP_BASE )
// #define MD_NTAUTHENTICATION_PROVIDERS   (IIS_MD_HTTP_BASE+21 )

// All of these properties are overridable on the service instance level.
// These properties should be added with MD_IIS_UT_SERVER type and 
// METADATA_INHERIT flags.

#define MD_ARTICLE_TIME_LIMIT                   (NNTP_MD_SERVER_BASE +   0)	// not impl	// 45056
#define MD_HISTORY_EXPIRATION                   (NNTP_MD_SERVER_BASE +   1)	// not impl
#define MD_HONOR_CLIENT_MSGIDS                  (NNTP_MD_SERVER_BASE +   2)	// not impl
#define MD_SMTP_SERVER                          (NNTP_MD_SERVER_BASE +   3)
#define MD_ADMIN_EMAIL                          (NNTP_MD_SERVER_BASE +   4)
#define MD_ADMIN_NAME                           (NNTP_MD_SERVER_BASE +   5)	// not impl
#define MD_ALLOW_CLIENT_POSTS                   (NNTP_MD_SERVER_BASE +   6)
#define MD_ALLOW_FEED_POSTS                     (NNTP_MD_SERVER_BASE +   7)
#define MD_ALLOW_CONTROL_MSGS                   (NNTP_MD_SERVER_BASE +   8)
#define MD_DEFAULT_MODERATOR                    (NNTP_MD_SERVER_BASE +   9)
//#define MD_ANONYMOUS_USERNAME                   (NNTP_MD_SERVER_BASE +  10)
#define MD_NNTP_COMMAND_LOG_MASK                (NNTP_MD_SERVER_BASE +  11)	// not impl
#define MD_DISABLE_NEWNEWS                      (NNTP_MD_SERVER_BASE +  12)
#define MD_NEWS_CRAWLER_TIME                    (NNTP_MD_SERVER_BASE +  13)	// not impl
#define MD_SHUTDOWN_LATENCY                     (NNTP_MD_SERVER_BASE +  14)	// not impl
//#define MD_ALLOW_ANONYMOUS                   (NNTP_MD_SERVER_BASE +  15)
//#define MD_QUERY_IDQ_PATH                       (NNTP_MD_SERVER_BASE +  16)

//
//      Service Instance (/LM/NntpSvc/{Instance}/) Properties:
//

// IIS Property identifiers that NNTP reuses:

// IIS Logging properties:
// #define MD_LOG_TYPE                     (IIS_MD_LOG_BASE+0  )
// #define MD_LOGFILE_DIRECTORY            (IIS_MD_LOG_BASE+1  )
// #define MD_LOGFILE_NAME                 (IIS_MD_LOG_BASE+2  )
// #define MD_LOGFILE_PERIOD               (IIS_MD_LOG_BASE+3  )
// #define MD_LOGFILE_TRUNCATE_SIZE        (IIS_MD_LOG_BASE+4  )
// #define MD_LOGFILE_BATCH_SIZE           (IIS_MD_LOG_BASE+5  )
// #define MD_LOGFILE_FIELD_MASK           (IIS_MD_LOG_BASE+6  )
// #define MD_LOGSQL_DATA_SOURCES          (IIS_MD_LOG_BASE+7  )
// #define MD_LOGSQL_TABLE_NAME            (IIS_MD_LOG_BASE+8  )
// #define MD_LOGSQL_USER_NAME             (IIS_MD_LOG_BASE+9  )
// #define MD_LOGSQL_PASSWORD              (IIS_MD_LOG_BASE+10 )
// #define MD_LOG_PLUGIN_ORDER             (IIS_MD_LOG_BASE+11 )
// #define MD_LOG_STATE                    (IIS_MD_LOG_BASE+12 )
// #define MD_LOG_FIELD_MASK               (IIS_MD_LOG_BASE+13 )
// #define MD_LOG_FORMAT                   (IIS_MD_LOG_BASE+14 )

#define MD_GROUP_HELP_FILE                      (NNTP_MD_SERVICE_INSTANCE_BASE +   0)		// 45156
#define MD_GROUP_LIST_FILE                      (NNTP_MD_SERVICE_INSTANCE_BASE +   1)
#define MD_ARTICLE_TABLE_FILE                   (NNTP_MD_SERVICE_INSTANCE_BASE +   2)
#define MD_HISTORY_TABLE_FILE                   (NNTP_MD_SERVICE_INSTANCE_BASE +   3)
#define MD_MODERATOR_FILE                       (NNTP_MD_SERVICE_INSTANCE_BASE +   4)
#define MD_XOVER_TABLE_FILE                     (NNTP_MD_SERVICE_INSTANCE_BASE +   5)
//#define MD_DISPLAY_NAME                         (NNTP_MD_SERVICE_INSTANCE_BASE +   6)
//#define MD_ERROR_CONTROL                        (NNTP_MD_SERVICE_INSTANCE_BASE +   7)
//#define MD_SERVER_UUCP_NAME                     (NNTP_MD_SERVICE_INSTANCE_BASE +   8)
#define MD_CLIENT_POST_HARD_LIMIT               (NNTP_MD_SERVICE_INSTANCE_BASE +   9)
#define MD_CLIENT_POST_SOFT_LIMIT               (NNTP_MD_SERVICE_INSTANCE_BASE +  10)
#define MD_FEED_POST_HARD_LIMIT                 (NNTP_MD_SERVICE_INSTANCE_BASE +  11)
#define MD_FEED_POST_SOFT_LIMIT                 (NNTP_MD_SERVICE_INSTANCE_BASE +  12)
//#define MD_CLEAN_BOOT                           (NNTP_MD_SERVICE_INSTANCE_BASE +  13)
#define MD_NNTP_UUCP_NAME               		(NNTP_MD_SERVICE_INSTANCE_BASE +  14)
#define MD_NNTP_ORGANIZATION            		(NNTP_MD_SERVICE_INSTANCE_BASE +  15)	// not impl
#define MD_LIST_FILE                            (NNTP_MD_SERVICE_INSTANCE_BASE +  16)
#define MD_PICKUP_DIRECTORY                     (NNTP_MD_SERVICE_INSTANCE_BASE +  17)
#define MD_FAILED_PICKUP_DIRECTORY              (NNTP_MD_SERVICE_INSTANCE_BASE +  18)
#define MD_NNTP_SERVICE_VERSION                 (NNTP_MD_SERVICE_INSTANCE_BASE +  19)
#define MD_DROP_DIRECTORY                       (NNTP_MD_SERVICE_INSTANCE_BASE +  20)
//#define MD_X_SENDER                             (NNTP_MD_SERVICE_INSTANCE_BASE +  21)
#define MD_PRETTYNAMES_FILE                     (NNTP_MD_SERVICE_INSTANCE_BASE +  22)
#define MD_NNTP_CLEARTEXT_AUTH_PROVIDER         (NNTP_MD_SERVICE_INSTANCE_BASE +  23)
#define MD_FEED_REPORT_PERIOD					(NNTP_MD_SERVICE_INSTANCE_BASE +  24)
#define MD_MAX_SEARCH_RESULTS					(NNTP_MD_SERVICE_INSTANCE_BASE +  25)
#define MD_GROUPVAR_LIST_FILE                   (NNTP_MD_SERVICE_INSTANCE_BASE +  26)

//
//      Feed (/LM/NntpSvc/{Instance}/Feeds/{FeedID}/) Properties:
//

#define MD_FEED_SERVER_NAME                     (NNTP_MD_SERVICE_INSTANCE_BASE + 300)		// 45456
#define MD_FEED_TYPE                            (NNTP_MD_SERVICE_INSTANCE_BASE + 301)
#define MD_FEED_NEWSGROUPS                      (NNTP_MD_SERVICE_INSTANCE_BASE + 302)
#define MD_FEED_SECURITY_TYPE                   (NNTP_MD_SERVICE_INSTANCE_BASE + 303)
#define MD_FEED_AUTHENTICATION_TYPE             (NNTP_MD_SERVICE_INSTANCE_BASE + 304)
#define MD_FEED_ACCOUNT_NAME                    (NNTP_MD_SERVICE_INSTANCE_BASE + 305)
#define MD_FEED_PASSWORD                        (NNTP_MD_SERVICE_INSTANCE_BASE + 306)
#define MD_FEED_START_TIME_HIGH                 (NNTP_MD_SERVICE_INSTANCE_BASE + 307)
#define MD_FEED_START_TIME_LOW                  (NNTP_MD_SERVICE_INSTANCE_BASE + 308)
#define MD_FEED_INTERVAL                        (NNTP_MD_SERVICE_INSTANCE_BASE + 309)
#define MD_FEED_ALLOW_CONTROL_MSGS              (NNTP_MD_SERVICE_INSTANCE_BASE + 310)
#define MD_FEED_CREATE_AUTOMATICALLY            (NNTP_MD_SERVICE_INSTANCE_BASE + 311)
#define MD_FEED_DISABLED                        (NNTP_MD_SERVICE_INSTANCE_BASE + 312)
#define MD_FEED_DISTRIBUTION                    (NNTP_MD_SERVICE_INSTANCE_BASE + 313)
#define MD_FEED_CONCURRENT_SESSIONS             (NNTP_MD_SERVICE_INSTANCE_BASE + 314)
#define MD_FEED_MAX_CONNECTION_ATTEMPTS         (NNTP_MD_SERVICE_INSTANCE_BASE + 315)
#define MD_FEED_UUCP_NAME                       (NNTP_MD_SERVICE_INSTANCE_BASE + 316)
#define MD_FEED_TEMP_DIRECTORY                  (NNTP_MD_SERVICE_INSTANCE_BASE + 317)
#define MD_FEED_NEXT_PULL_HIGH                  (NNTP_MD_SERVICE_INSTANCE_BASE + 318)
#define MD_FEED_NEXT_PULL_LOW                   (NNTP_MD_SERVICE_INSTANCE_BASE + 319)
#define MD_FEED_PEER_TEMP_DIRECTORY             (NNTP_MD_SERVICE_INSTANCE_BASE + 320)
#define MD_FEED_PEER_GAP_SIZE                   (NNTP_MD_SERVICE_INSTANCE_BASE + 321)
#define MD_FEED_OUTGOING_PORT                   (NNTP_MD_SERVICE_INSTANCE_BASE + 322)
#define MD_FEED_FEEDPAIR_ID                     (NNTP_MD_SERVICE_INSTANCE_BASE + 323)
#define MD_FEED_HANDSHAKE						(NNTP_MD_SERVICE_INSTANCE_BASE + 324)
#define MD_FEED_ADMIN_ERROR						(NNTP_MD_SERVICE_INSTANCE_BASE + 325)
#define MD_FEED_ERR_PARM_MASK					(NNTP_MD_SERVICE_INSTANCE_BASE + 326)

//
//      Expiration (/LM/NntpSvc/{Instance}/Expires/{ExpireID}/) Properties:
//

#define MD_EXPIRE_SPACE                 (NNTP_MD_SERVICE_INSTANCE_BASE + 500)		// 45656
#define MD_EXPIRE_TIME                  (NNTP_MD_SERVICE_INSTANCE_BASE + 501)
#define MD_EXPIRE_NEWSGROUPS            (NNTP_MD_SERVICE_INSTANCE_BASE + 502)
#define MD_EXPIRE_POLICY_NAME           (NNTP_MD_SERVICE_INSTANCE_BASE + 503)

//
//      Virtual Root Properties:
//

// IIS Property identifiers that NNTP reuses:

#define MD_ACCESS_ALLOW_POSTING             (MD_ACCESS_WRITE)
#define MD_ACCESS_RESTRICT_VISIBILITY       (MD_ACCESS_EXECUTE)
#define	MD_VR_DRIVER_CLSID					(NNTP_MD_VIRTUAL_ROOT_BASE + 0)			// 46156
#define	MD_VR_DRIVER_PROGID					(NNTP_MD_VIRTUAL_ROOT_BASE + 1)
#define MD_FS_PROPERTY_PATH					(NNTP_MD_VIRTUAL_ROOT_BASE + 2)
//#define MD_FS_TEST_SERVER					(NNTP_MD_VIRTUAL_ROOT_BASE + 3)
#define MD_FS_VROOT_PATH					(MD_VR_PATH)
// MD_VR_USE_ACCOUNT:
//    0 - Don't use the account in vroot, use whatever the server passes in;
//    1 - Use the vroot account
#define MD_VR_USE_ACCOUNT                  (NNTP_MD_VIRTUAL_ROOT_BASE + 4)
#define MD_VR_DO_EXPIRE                     (NNTP_MD_VIRTUAL_ROOT_BASE + 5)
#define MD_EX_MDB_GUID                      (NNTP_MD_VIRTUAL_ROOT_BASE + 6)
#define MD_VR_OWN_MODERATOR               (NNTP_MD_VIRTUAL_ROOT_BASE + 7)

//#define MD_VR_USERNAME                      (IIS_MD_VR_BASE+2 )
//#define MD_VR_PASSWORD                      (IIS_MD_VR_BASE+3 )

//
//      Files Properties:
//

//
//		ADSI object names
//

#define NNTP_ADSI_OBJECT_FEEDS			"IIsNntpFeeds"
#define NNTP_ADSI_OBJECT_FEED			"IIsNntpFeed"
#define NNTP_ADSI_OBJECT_EXPIRES		"IIsNntpExpiration"
#define NNTP_ADSI_OBJECT_EXPIRE			"IIsNntpExpire"
#define NNTP_ADSI_OBJECT_GROUPS			"IIsNntpGroups"
#define NNTP_ADSI_OBJECT_SESSIONS		"IIsNntpSessions"
#define NNTP_ADSI_OBJECT_REBUILD		"IIsNntpRebuild"

#endif // _NNTPMETA_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\pcparse.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pcparse.h

Abstract:

    This module contains class declarations/definitions for

		CPCParse

    **** Overview ****

	This defines an object for parsing RFC1036 items,
	specifically the From: and related lines. It works
	by treating each grammer rule as a function.

Author:

    Carl Kadie (CarlK)     29-Oct-1995

Revision History:


--*/

#ifndef	_PCPARSE_H_
#define	_PCPARSE_H_

//
// forward class def
//

class CPCParse;

//
//
//
// CPCParse - Parse a CPCString.
//

class CPCParse : public CPCString {
public :

	//
	// Constructor -- no string yet.
	//

	CPCParse(void)
		{ numPCParse++; };

	//
	// Constructor -- give pointer to string and length.
	//

	CPCParse(char * pch, DWORD cch):
		CPCString(pch, cch)
		{ numPCParse++; }

	~CPCParse() { numPCParse--; }

	//
	// Implement this grammer rule:
	//  From-content  = address [ space "(" paren-phrase ")" ] EOL
    //         /  [ plain-phrase space ] "<" address ">" EOL
    //

	BOOL fFromContent(void);


protected:

    //
    // address       = local-part "@" domain
	//      OR JUST  local-part
	// !!!X LATER - do we want a flag that tells if just local-part is acceptable?
	//

	BOOL fAddress(void);
	BOOL fStrictAddress(void);

	//
	// These functions accept one or more of tokens
	//

	BOOL fAtLeast1QuotedChar(void);
	BOOL fAtLeast1UnquotedChar(void);
	BOOL fAtLeast1UnquotedDotChar(void);
	BOOL fAtLeast1Space(void);
	BOOL fAtLeast1ParenChar(void);
	BOOL fAtLeast1CodeChar(void);
	BOOL fAtLeast1TagChar(void);
	BOOL fAtLeast1QuotedCharOrSpace(void);

    //
    // unquoted-word = 1*unquoted-char
    //

	BOOL fUnquotedWord(BOOL fAllowDots=FALSE)	{
			if( !fAllowDots ) 
				return fAtLeast1UnquotedChar();
			else
				return	fAtLeast1UnquotedDotChar() ;
			};


   //
   // quoted-word   = quote 1*( quoted-char / space ) quote
   //

	BOOL fQuotedWord(void);

	//
	// local-part    = unquoted-word *( "." unquoted-word )
	//

	BOOL fLocalPart(void);

	//
	//  domain        = unquoted-word *( "." unquoted-word )
	//

	BOOL fDomain(void) {
			return fLocalPart();
			}

    //
    // plain-word    = unquoted-word / quoted-word / encoded-word
    //

	BOOL fPlainWord(void) {
			return fUnquotedWord(TRUE) || fQuotedWord() || fEncodedWord();
			};

    //
    // plain-phrase  = plain-word *( space plain-word )
    //

	BOOL fPlainPhrase(void);

	//
	// one or more spaces (including tabs) or newlines
	//

	BOOL fSpace(void) {
			return fAtLeast1Space();
			};
	
    //
    // paren-char    = <ASCII printable character except ()<>\>
    //

	BOOL fParenChar(void);
	
	//
	// paren-phrase  = 1*( paren-char / space / encoded-word )
	//

	BOOL fParenPhrase(void);


	//
	// code-char     = <ASCII printable character except ?>
	// codes         = 1*code-char
	//

	BOOL fCodes(void)	{
			return fAtLeast1CodeChar();
			};

	//
	//  charset       = 1*tag-char
	//

	BOOL fCharset(void)		{
			return fAtLeast1TagChar();
			};

	//
	//   encoding      = 1*tag-char
	//

	BOOL fEncoding(void)	{
			return fCharset();
			};

	//
	//  encoded-word  = "=?" charset "?" encoding "?" codes "?="
	//

	BOOL fEncodedWord(void);

    //
    //  Looks at current char to see if it matches ch.
    //  Does not advance current ptr.
    //

    BOOL fIsChar(char ch);

	//
	// Parses a single character class
	//

	BOOL fParseSingleChar(char ch);

	//
	//  quoted-char   = <ASCII printable character except "()<>\>
	//

	BOOL fQuotedCharTest(char ch) {
			return isgraph(ch) && !fCharInSet(ch, "\"()<>\\");
			};

	//
	//  paren-char    = <ASCII printable character except ()<>\>
	//

	BOOL fParenCharTest(char ch) {

			// bugbug ... isgraph rejects spaces - which we want to include !
			return (isgraph(ch) || ch == ' ') && !fCharInSet(ch, "()<>\\");
			};

	//
	// unquoted-char = <ASCII printable character except !()<>@,;:\".[]>
	// bugbug: isgraph rejects spaces - this rejects certain from: headers
	// that INN accepts against the RFC.
	//

	BOOL fUnquotedCharTest(char ch) {
			return isgraph(ch) && !fCharInSet(ch, "!()<>@,;:\\\".[]");
			};

	//
	// unquoted-dot-char = <ASCII printable character except !()<>@,;:\"[]>
	//

	BOOL fUnquotedDotCharTest(char ch) {
			return isgraph(ch) && !fCharInSet(ch, "()<>@\\\"[]");
			};

	//
	// quoted-char / space
	//

	BOOL fQuotedCharOrSpaceTest(char ch) {
			return (fSpaceTest(ch) || fQuotedCharTest(ch));
			};

	BOOL fSpaceTest(char ch) {
			return fCharInSet(ch, " \t\n\r");
			};

	//
	// code-char     = <ASCII printable character except ?>
	//

	BOOL fCodeCharTest(char ch) {
			return isgraph(ch) && (ch != '?');
			};

	//
	// tag-char      = <ASCII printable character except !()<>@,;:\"[]/?=>
	//

	BOOL fTagCharTest(char ch) {
			return isgraph(ch) && !fCharInSet(ch, "!()<>@,;:\\\"[]/?=");
			};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\parse.h ===
#ifndef __PARSE_H__
#define __PARSE_H__

#include <windows.h>

//
// this type is used to convert headers (in XPAT and NNTP SEARCH) and 
// search keys (in NNTP SEARCH) into the appopriate Tripoli query strings.
//
typedef const struct SKEY_INFO_st {
	char *pszSearchKey;					// the HEADER name or IMAP search key
	char *pszPropertyName;				// the corresponding property name
										//   for the index server.  this should
										//   include the relationship operator
	char *pszRegexName;					// just like pszPropertyName, used for
										// regular expressions (will be NULL
										//   for search keys)
	DWORD eOperandType;					// the type of operand
	BOOL fSpecifiedNewsgroup;			// if this is TRUE then this header
										//   specifies a newsgroup
} SKEY_INFO;

typedef const struct MONTH_INFO_st MONTH_INFO;

// 
// This is the base class which all translator's inherit from
//
class CQueryLanguageTranslator {
	public:
		//
		// Translate the input language (which must be in 7-bit ASCII) into 
		// the Index Server's language (in Unicode).
		//
		// Returns a BOOL and GetLastError() style error code
		//
		virtual BOOL Translate(
			char *pszStatement, 		// the query statement
			char *pszCurrentNewsgroup,	// the currently selected group
			WCHAR *pwszOutput,			// a buffer to write the result into
			DWORD cOutput) = 0;			// the size of that buffer
	protected:
		//
		// make sure that a string only contains numeric digits
		//
		BOOL IsNumber(char *pszString);

		//
		// find information about a search key.  returns NULL on error
		//
		// EC is ERROR_FILE_NOT_FOUND if search key doesn't exist
		//
		SKEY_INFO *GetSearchKeyInfo(char *pszSearchKey, DWORD cSKInfo, 
			SKEY_INFO *pSKInfo);

		//
		// add text to the output string.  at start *pcOutput is the number
		// of bytes in *ppwszOutput, at exit its the number of bytes remaining
		// after adding pszText.
		//
		BOOL WriteOutput(char *pszText, WCHAR **ppwszOutput, DWORD *pcOutput);

		//
		// add text to the output string.  at start *pcOutput is the number
		// of bytes in *ppwszOutput, at exit its the number of bytes remaining
		// after adding pszText.
		//
		// the source string is encoded in MIME-2 format.  output is written
		// in Unicode
		//
		BOOL WriteOutputM2(char *pszM2String, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		//
		// move ppszStatement to point past characters found in pszSkiplist
		//
		// EC is ERROR_INVALID_DATA if the end of the string is reached
		//
		BOOL SkipChars(char **ppszStatement, char *pszSkiplist, 
			BOOL fEndOfStringOkay = FALSE);

		//
		// get bytes in ppszStatement until we get to a character in the
		// endlist.  pchEndChar will get a copy of the end character that
		// was found.  ppszStatement will point one character past the end
		// character.
		//
		// EC is ERROR_INVALID_DATA if the end of the string is reached
		//
		char *GetCharsTill(char **ppszStatement, char *pszEndlist, 
			BOOL fEndOfStringOkay = TRUE, char *pchEndChar = NULL);

		//
		// NULL terminated list of searchable HEADERs
		//
		static SKEY_INFO m_rgHeaders[];		
		//
		// number of headers in the above list
		//
		static const DWORD m_cHeaders;

		//
		// translates a number from IMAP form to IS form
		//
		BOOL TranslateNumber(char **ppszStatement, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		//
		// translates an IMAP AString from IMAP to IS query language
		//
		BOOL TranslateAString(char **ppszStatement, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		//
		// NULL terminated table to convert IMAP months to IS months
		//
		static MONTH_INFO m_rgMonthTable[];

		//
		// gets and translates a date from a statement.  converts it
		// to Indexing Server's notation from the IMAP notation
		//
		BOOL TranslateDate(char **ppszStatement, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		BOOL TranslateDateDay(char *pszField, char **ppszStatement, 
			WCHAR **ppwszOutput, DWORD *pcOutput);

		//
		// he needs to get to the searchable headers
		//
		friend char *GetSearchHeader(DWORD iIndex);
};

//
// this class converts 
//
class CXpatTranslator : public CQueryLanguageTranslator {
	public:
		//
		// translate an XPAT query into Tripoli
		//
		virtual BOOL Translate(
			char *pszStatement, 		// the query statement
			char *pszCurrentNewsgroup,	// the currently selected group
			WCHAR *pwszOutput,			// a buffer to write the result into
			DWORD cOutput);				// the size of that buffer

		DWORD GetLowArticleID(void) { return m_iLowArticleID; }
		DWORD GetHighArticleID(void) { return m_iHighArticleID; }
	private:
		//
		// currently Tripoli and our mime filter don't index the article
		// id.  using these methods the caller can figure out which article
		// ids the client was interested in and filter them out.
		//
#define ARTICLEID_INFINITE (DWORD) -1
		DWORD m_iLowArticleID;
		DWORD m_iHighArticleID;

};

//
// this class converts the NNTP SEARCH command into a Tripoli query
//
class CNntpSearchTranslator : public CQueryLanguageTranslator {
	public:
		//
		// translate from the IMAP/NNTP query language to the Indexing
		// Server's query language
		//
		// input is in 7-bit ASCII, output is in Unicode
		//
		virtual BOOL Translate(char *pszStatement, char *pszCurrentNewsgroup,
			WCHAR *pwszOutput, DWORD cOutput);
	private:
		//
		// translate a search key from the input statement.  the part to 
		// start translating is passed in via ppszStatement.  this will 
		// be updated to point past the part that has been translated.  it 
		// point to a 0 byte string if there is nothing left to parse
		//
		BOOL TranslateSearchKey(char **ppszStatement, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		//
		// translate a HEADER <header> <value> command.
		//
		BOOL TranslateHeader(char **ppszStatement, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		//
		// translate an OR search key from the input statement.
		// *ppszStatement starts pointing after the OR, returns pointing
		// after the operands of the OR.
		//
		BOOL TranslateOR(char **ppszStatement, WCHAR **ppwszOutput, DWORD *pcOutput);

		//
		// translate a parenthesized list of terms to be anded from the 
		// input statement
		//
		// *ppszStatement should point at the open paren.  when done it will 
		// point to the character after the closing paren
		//
		BOOL TranslateAndList(char **ppszStatement, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		//
		// translate a parenthesized list article IDs from the input statement
		//
		// *ppszStatement should point at the open paren.  when done it will 
		// point to the character after the closing paren
		//
		BOOL TranslateSet(char **ppszStatement, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		//
		// translate newsgroup info in the form IN alt.*,comp.* to IS
		//
		BOOL TranslateIN(char **ppszStatement, WCHAR **ppwszOutput, 
			DWORD *pcOutput);

		//
		// NULL terminated list of search keys
		//
		static SKEY_INFO m_rgSearchKeys[];
		
		//
		// the current newsgroup
		//
		char *m_pszNewsgroup;
		//
		// was a group ever specified?
		//
		BOOL m_fSpecifiedNewsgroup;
		//
		// should the current term be anded with the last?
		//
		BOOL m_fAndWithLast;
};

//
// returns the ith searchd header.  NULL if past limit
//
char *GetSearchHeader(DWORD iIndex);

// possible error codes
#define ERROR_SEARCH_P_BASE 				0xe0150000
// internal error (shouldn't ever occur)
#define ERROR_SEARCH_P_INTERNAL				ERROR_SEARCH_P_BASE + 0
// general syntax error
#define ERROR_SEARCH_P_SYNTAX_ERROR			ERROR_SEARCH_P_BASE + 1
// requires newsgroup
#define ERROR_SEARCH_P_NO_GROUP				ERROR_SEARCH_P_BASE + 2
// unsupported key/header passed in
#define ERROR_SEARCH_P_UNSUPPORTED_KEY		ERROR_SEARCH_P_BASE + 3

//
// the index server's words and special characters 
//
#define IS_AND " & "
#define IS_OR " | "
#define IS_QUOTE "\""
#define IS_OPEN_PAREN "("
#define IS_CLOSE_PAREN ")"
#define IS_OPERATOR_GE ">="
#define IS_OPERATOR_LE "<="
#define IS_OPERATOR_EQ "="
#define IS_SPACE " "
#define IS_ARTICLE_ID "@NewsArticleID"
#define IS_MESSAGE_ID "@NewsMsgID"
#define IS_NEWSGROUP "@Newsgroups"
#define IS_NEWSGROUP_WILDMAT "#Newsgroups"
#define IS_REGEX "#"
#define IS_REGEX_CHAR '#'
#define IS_WILDMAT "*"
#define IS_ARTICLE_ID_EQ IS_ARTICLE_ID IS_OPERATOR_EQ
#define IS_ARTICLE_ID_LE IS_ARTICLE_ID IS_OPERATOR_LE
#define IS_ARTICLE_ID_GE IS_ARTICLE_ID IS_OPERATOR_GE
#define IS_MESSAGE_ID_EQ IS_MESSAGE_ID IS_SPACE
#define IS_NEWSGROUP_EQ IS_NEWSGROUP IS_SPACE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntps.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nntps.h

    This file contains constants & type definitions shared between the
    NNTP Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.

*/


#ifndef _NNTPS_H_
#define _NNTPS_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
#include <winsock.h>
#endif

#define IPPORT_NNTP                     119

//
//  Name of the log file, used for logging file accesses.
//

#define NNTP_LOG_FILE                  TEXT("NNTPSVC.LOG")


//
//  Configuration parameters registry key.
//

#define	NNTP_PARAMETERS_KEY_A   "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters"
#define	NNTP_PARAMETERS_KEY_W   L"System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters"
#define NNTP_PARAMETERS_KEY \
            TEXT("System\\CurrentControlSet\\Services\\NntpSvc\\Parameters")


//
//  Performance key.
//

#define NNTP_PERFORMANCE_KEY \
            TEXT("System\\CurrentControlSet\\Services\\NntpSvc\\Performance")

#if 0
//
//  Configuration value names.
//

#define W3_CHECK_FOR_WAISDB            TEXT("CheckForWAISDB")
#define W3_DEBUG_FLAGS                 TEXT("DebugFlags")
#define W3_DIR_BROWSE_CONTROL          TEXT("Dir Browse Control")
#define W3_DIR_ICON                    TEXT("Folder Image")
#define W3_DIR_ICON_W                  L"Folder Image"
#define W3_DEFAULT_FILE                TEXT("Default Load File")
#define W3_DEFAULT_FILE_W              L"Default Load File"
#define W3_SERVER_AS_PROXY             TEXT("ServerAsProxy")
#define W3_CATAPULT_USER               TEXT("CatapultUser")
#define W3_CATAPULT_USER_W             L"CatapultUser"
#define W3_SCRIPT_TIMEOUT              "ScriptTimeout"
#define W3_CACHE_EXTENSIONS            "CacheExtensions"
#define W3_SSI_ENABLED                 "ServerSideIncludesEnabled"
#define W3_SSI_EXTENSION               "ServerSideIncludesExtension"
#define W3_SSI_EXTENSION_W             L"ServerSideIncludesExtension"
#define W3_GLOBAL_EXPIRE               "GlobalExpire"
#define W3_PROVIDER_LIST               "NTAuthenticationProviders"
#endif

//
//  Name of the LSA Secret Object containing the password for
//  anonymous logon.
//

#define NNTP_ANONYMOUS_SECRET         TEXT("NNTP_ANONYMOUS_DATA")
#define NNTP_ANONYMOUS_SECRET_A       "NNTP_ANONYMOUS_DATA"
#define NNTP_ANONYMOUS_SECRET_W       L"NNTP_ANONYMOUS_DATA"

//
//  The set of password/virtual root pairs
//

#define NNTP_ROOT_SECRET_W            L"NNTP_ROOT_DATA"

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _NNTPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\propbag.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	propbag.h

Abstract:

	This module contains the definition of the property bag class.  
	Property bag is a dynamically extendable container for different
	types of properties.  

Author:

	Kangrong Yan ( KangYan )
	
Revision History:

	kangyan	05/31/98	created

--*/
#if !defined( _PROPBAG_H_ )
#define _PROPBAG_H_
#include <windows.h>
#include <dbgtrace.h>
#include <fhashex.h>
#include <unknwn.h>
#include <rwnew.h>
#include <stdio.h>
#include <xmemwrpr.h>

// Data object used for property hash table
class CProperty { // pr
public:

	CProperty() 
	{
		m_pNext = NULL;
		m_dwPropId = 0;

		ZeroMemory( &m_prop, sizeof( DATA ) );
		m_type = Invalid;

		m_cbProp = 0;
	}
	
	~CProperty() {
		if ( m_type == Blob ) {
			_ASSERT( m_cbProp > 0 );
			_ASSERT( m_prop.pbProp );
			XDELETE[] m_prop.pbProp;
		}
	}

	VOID
	Validate()
	{
		if ( Bool == m_type ) {
			if ( TRUE != m_prop.bProp && FALSE != m_prop.bProp )
			_ASSERT( FALSE );
		}

		if ( Blob == m_type ) {
			_ASSERT( NULL != m_prop.pbProp );
			_ASSERT( m_cbProp > 0 );
		}

		if ( Interface == m_type ) {
			_ASSERT ( NULL != m_prop.punkProp );
		}
	}
	
    CProperty *m_pNext;
    DWORD GetKey() { return m_dwPropId; }
    int MatchKey( DWORD dwOther ) { return ( dwOther == m_dwPropId ); }
    static DWORD HashFunc( DWORD k ) { return k; }

    DWORD m_dwPropId;
    union DATA {
        DWORD   	dwProp;
        BOOL    	bProp;
        IUnknown *	punkProp;
        PBYTE   	pbProp;
    } m_prop;
    enum TYPE {
    	Invalid = 0,
        Dword,
        Bool,
        Blob,
        Interface
    } m_type;
    DWORD m_cbProp;	// in case of BLOB
};

typedef TFHashEx< CProperty, DWORD, DWORD >  PROPERTYTABLE ;	//pt

// Class CPropBag
class CPropBag {	//bg
public:
	CPropBag( int cInitialSize = 16, int cIncrement = 8);
	~CPropBag();
	
	HRESULT PutDWord( DWORD dwPropId, DWORD dwVal );
	HRESULT GetDWord( DWORD dwPropId, PDWORD pdwVal );
	HRESULT PutBool( DWORD dwPropId, BOOL bVal );
	HRESULT GetBool( DWORD dwPropId, PBOOL pbVal );
	HRESULT PutBLOB( DWORD dwPropId, PBYTE pbVal, DWORD cbVal );
	HRESULT GetBLOB( DWORD dwPropId, PBYTE pbVal, PDWORD pcbVal );
	HRESULT PutInterface( DWORD dwPropId, IUnknown *punkVal ) { return E_NOTIMPL; }
	HRESULT GetInterface( DWORD dwPropId, IUnknown **ppunkVal ) { return E_NOTIMPL; }
	HRESULT RemoveProperty( DWORD dwPropId );
	VOID Validate() { 
#ifdef DEBUG
	    m_Lock.ShareLock();
		_ASSERT( m_ptTable.IsValid( TRUE ) );
		m_Lock.ShareUnlock();
#endif
	}
		
private:
	PROPERTYTABLE	m_ptTable;
	CShareLockNH    m_Lock; // synchronize reads / writes
	HRESULT         m_hr;   // reflects the property bag status
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntputil.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    nnprocs.h

Abstract:

    This module contains function prototypes used by the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     12-Sept-1995

Revision History:

    Kangrong Yan ( KangYan )    28-Feb-1998
        Added one prototype for fixed length Unicode-Ascii convertion func.

--*/

#ifndef	_NNUTIL_
#define	_NNUTIL_

//
// svcsupp.cpp
//

DWORD
multiszLength(
      char const * multisz
      );

const char *
multiszCopy(
    char const * multiszTo,
    const char * multiszFrom,
    DWORD dwCount
    );

char *
szDownCase(
           char * sz,
           char * szBuf
           );


DWORD
MultiListSize(
    LPSTR *List
    );

VOID
CopyStringToBuffer (
    IN PCHAR String,
    IN PCHAR FixedStructure,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

BOOL
VerifyMultiSzListW(
    LPBYTE List,
    DWORD ListSize
    );

LPSTR *
AllocateMultiSzTable(
                IN PCHAR List,
                IN DWORD cbList,
                IN BOOL IsUnicode
                );

LPSTR	*
ReverseMultiSzTable(
	IN	LPSTR*	plpstr
	) ;

LPSTR*
CopyMultiList(	
	IN LPSTR*	List 
	) ;

LPSTR*
MultiSzTableFromStrA(	
	LPCSTR	lpstr 
	) ;

LPSTR*
MultiSzTableFromStrW(	
	LPWSTR	lpwstr 
	) ;

LPSTR
LpstrFromMultiSzTableA(	
	LPSTR*	plpstr 
	) ;

LPWSTR
LpwstrFromMultiSzTableA( 
	LPSTR*	plpstr 
	) ;

BOOL
MultiSzIntersect(	
	LPSTR*	plpstr,	
	LPSTR	szmulti 
	) ;

VOID
CopyUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString
        );
VOID
CopyNUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPWSTR UnicodeString,
		IN DWORD dwUnicodeLen,
		IN DWORD dwAsciiLen
		);

LPWSTR
CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR AsciiString
        );

VOID
CopyNAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPSTR AsciiString,
        IN DWORD dwAsciiLen,
        IN DWORD dwUnicodeLen);

void
FillLpwstrFromMultiSzTable(
	LPSTR*	plpstr,
	LPWSTR	lpwstr 
	) ;

void
FillLpstrFromMultiSzTable(
	LPSTR*	plpstr,
	LPSTR	lpstrFill
	) ;

BOOL 
OperatorAccessCheck( 
    LPCSTR lpMBPath, 
    DWORD Access 
    ) ;

#define TsApiAccessCheckEx( x, y, z ) (OperatorAccessCheck( (x), y ) ? NO_ERROR : TsApiAccessCheck( z ) );

//
// svcstat.c
//


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\pcstring.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pcstring.h

Abstract:

    This module contains class declarations/definitions for

		CPCString

    **** Overview ****

	A string data type defined with an object.
	Strings are represented by
	    1. A pointer to a character
		2. A length.

    No memory is allocated so this is compact and efficient.

Author:

    Carl Kadie (CarlK)     25-Oct-1995

Revision History:


--*/

#ifndef	_PCSTRING_H_
#define	_PCSTRING_H_

#include "artglbs.h"

//
//
//
// CPCString - A pointer/counter string.
//

class CPCString {
public :
	//
	// Constructor -- no string yet.
	//

	CPCString(void):
			m_pch(NULL),
			m_cch(0) {
            numPCString++;
            };

	//
	// Constructor -- give pointer to string and length.
	//

	CPCString(char * pch, DWORD cch):
			m_pch(pch),
			m_cch(cch) {
            numPCString++;
            };

	//
	// Constructor -- build on top of a sz string.
	//

	CPCString(char * sz):
			m_pch(sz),
			m_cch(lstrlen(sz)) {
            numPCString++;
            };

	virtual ~CPCString( ) { numPCString--; };

	//
	// The pointer to the start of the string	
	//

	char *	m_pch;

	//
	// The length of the string.
	//

	DWORD m_cch;

	//
	// A pointer to one character past the end of the string
	//

	char *	pchMax(void);

	//
	// Set the length of the string of a pointer one past the end of the string.
	//

	BOOL fSetCch(const char * pchMax);

	//
	// The the start of the string from the length and a pchMax
	//

	BOOL fSetPch(char * pchMax);

	//
	// Make the string the Null string.
	//

	void vSetNull() {
			m_pch=NULL;
			m_cch=0;
			};

	//
	// Test if the string is the null string.
	//

	BOOL fIsNull() {
			return NULL==m_pch && 0== m_cch;
			};

	//
	// Trim characters from the frount
	//

	DWORD dwTrimStart(const char * szSet);

	//
	// Trim characters from the end.
	//

	DWORD dwTrimEnd(const char * szSet);

	//
	// Compare to a sz string (ignoring case)
	//

	BOOL fEqualIgnoringCase(const char * sz);

	//
	// Check existence in a set of strings (ignoring case)
	//

	BOOL fExistsInSet(char ** rgsz, DWORD dwNumStrings);

	//
	// Create a multisz list by spliting the string.
	//

	void vSplitLine(const char * szDelimSet, char * multisz, DWORD	&	dwCount);	

	//
	// Append another CPCString
	//

	CPCString& operator << (const CPCString & pcNew);

	//
	// Append a sz string.
	//

	CPCString& operator << (const char * szNew);

	//
	// Append a character
	//

	CPCString& operator << (const char cNew);

	//
	// Append a number
	//

	CPCString& operator << (const DWORD cNew);

	//
	// Compare two CPCStrings.
	//

	BOOL operator == (const CPCString & pcNew)	{
			return m_pch == pcNew.m_pch && m_cch == pcNew.m_cch;
			};

	//
	// See if two CPCStrings are different
	//

	BOOL operator != (const CPCString & pcNew)	{
			return !(*this == pcNew);
			};
	
	//
	// Copy from a CPCString
	//

	void vCopy(CPCString & pcNew);

	//
	// Move (safe copy) from a CPCString)
	//

	void vMove(CPCString & pcNew);

	//
	// Copy to a sz
	//

	void vCopyToSz(char* sz);

	//
	// Copy to an sz of length cchMax
	//

	void vCopyToSz(char* sz, DWORD cchMax);

	//
	// Assert that this string is null terminated and return it
	//

	char *  sz(void);

	//
	// Null terminate this string (the null doesn't count toward length)
	//

	void vMakeSz(void);

	//
	// Check if this string is just plain ascii, if not return the 8-bit or null character
	//

	BOOL fCheckTextOrSpace(char & chBad);

	//
	// Shorten the string by skipping dwSkip characters in the front.
	//

	void vSkipStart(const DWORD dwSkip)	{
			m_pch += dwSkip;
			m_cch -= dwSkip;
			};

	//
	// Shorten the string by skipping dwSkip characters in the back.
	//

	void vSkipEnd(const DWORD dwSkip){
			m_cch -= dwSkip;
			};

	//
	// Shorten the string by skipping a CRLF terminated line
	//

	void vSkipLine(void);

	//
	// Append a CPCString, but not if too long.
	//

	BOOL fAppendCheck(const CPCString & pcNew, DWORD cchLast);

	//
	// Append a character, but not if too long
	//

	BOOL fAppendCheck(char ch, DWORD cchLast);

	//
	// Replace a set of characters to a single character
	//

	void vTr(const char * szFrom, char chTo);

	//
	// Get the next token, shorten the string
	//

	void vGetToken(const char *	szDelimSet, CPCString & pcToken);

	//
	// Get the next word, shorten the string
	//

	void vGetWord(CPCString & pcWord);

	//
	// Attach this string to a sz string.
	//

	void vInsert(char * sz)				{
			m_pch = sz;
			m_cch = lstrlen(m_pch);
			};

	//
	// Count the ocurrance of a character.
	//

	DWORD dwCountChar(
			char ch
			);

	//
	// Replace the current string with an sz of exactly
	// the same length.
	//

	void vReplace(
		   const char * sz
		   );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nwstree.h ===
#ifndef _NWSTREE_H_
#define _NWSTREE_H_

#include        "nntpvr.h"
#include        "group.h"
#include        "fhashex.h"
#include        "fhash.h"
#include        "rwnew.h"
#include        "fixprop.h"
#include        "flatfile.h"

class CNewsTreeCore;

typedef TFHashEx<CNewsGroupCore, LPSTR, LPSTR> CHASHLPSTR;
typedef TFHashEx<CNewsGroupCore, GROUPID, GROUPID> CHASHGROUPID;

#define FIRST_RESERVED_GROUPID  1
#define LAST_RESERVED_GROUPID   256
#define FIRST_GROUPID                   257
#define MAX_HIGHMARK_GAP                100000

//
//      The CGroupIterator object is used to enumerate all newsgroups which match a specified pattern.
//
//      The CGroupIterator object is given an array of strings which contain 'wildmat' strings as specified
//      in RFC 977 for NNTP.
//      wildmat strings have the following pattern matching elements :
//              Range of characters ie:  com[p-z]
//              Asterisk ie:    comp.*   (matches all newsgroups descended from 'comp')
//              Negations ie:   !comp.*  (excludes all newsgroups descended from 'comp' )
//
//      The CGroupIterator will implement these semantics in the following way :
//
//              All newsgroups are held in the CNewsTree object in a doubly linked list in alphabetical order.
//              The CGroupIterator will hold onto a CRefPtr<> for the current newsgroup.
//              Because the CNewsGroup objects are reference counted, the current newsgroup can never be destroyed from
//              underneath the iterator.
//
//              When the user calls the Iterator's Next() or Prev() functions, we will simply follow next pointers
//              untill we find another newsgroup which matches the pattern and to which the user has access.
//
//              In order to determine whether the any given newsgroup matches the specified pattern, we will use the
//              wildmat() function that is part of the INN source.  We will have to call the wildmat() function for each
//              pattern string until we get a succesfull match.
//

class   CGroupIteratorCore : public INewsTreeIterator {
protected:
        CNewsTreeCore*  m_pTree ;                               // The newstree on which to iterate !
        LONG                    m_cRef;
        LPMULTISZ               m_multiszPatterns ;
        BOOL                    m_fIncludeSpecial ;

        CGRPCOREPTR             m_pCurrentGroup ;
        //
        //      Both m_fPastEnd and m_fPastBegin will be true if the list is empty !!
        //
        BOOL                    m_fPastEnd ;    // User advanced past the end of the list !!
        BOOL                    m_fPastBegin ;  // User advanced past beginning of list !!
        

        //
        //      Only the CNewsTreeCore Class can create CGroupIterator objects.
        //
        friend  class   CNewsTreeCore ;
        //
        //      Constructor
        //      
        //      The CGroupIterator constructor does no memory allocation - all of the arguments
        //      passed are allocated by the caller.  CGroupIterator will destroy the arguments within
        //      its destructor.
        //
        CGroupIteratorCore(     
                                CNewsTreeCore*  pTree,
                                LPMULTISZ               lpPatterns, 
                                CGRPCOREPTR&    pFirst, 
                                BOOL                    fIncludeSpecial
                                ) ;

        CGroupIteratorCore( 
                                CNewsTreeCore   *pTree,
                                CGRPCOREPTR             &pFirst
                                ) ;             

        void    NextInternal() ;

public :
        //
        //      Destructor
        //
        //      We will release all the objects passed to our constructor in here.
        //
        virtual ~CGroupIteratorCore( ) ;

        BOOL                    __stdcall IsBegin() ;
        BOOL                    __stdcall IsEnd() ;

        CGRPCOREPTRHASREF Current() { return (CNewsGroupCore *)m_pCurrentGroup; }

        HRESULT __stdcall Current(INNTPPropertyBag **ppGroup, INntpComplete *pProtocolComplete = NULL );
        
        // these can be overridden so that the server can do security checking
        // on groups while iterating
        virtual void    __stdcall Next() ;
        virtual void    __stdcall Prev() ;

    //
    // Implementation of IUnknown
    //
    HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    {
        if ( iid == IID_IUnknown ) {
            *ppv = static_cast<IUnknown*>(this);
        } else if ( iid == IID_INewsTreeIterator ) {
            *ppv = static_cast<INewsTreeIterator*>(this);
        } else {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    ULONG __stdcall AddRef()
    {
        return InterlockedIncrement( &m_cRef );
    }

    ULONG __stdcall Release()
    {
                ULONG x = InterlockedDecrement(&m_cRef);
        if ( x == 0 ) XDELETE this;
        return x;
    }
} ;

class   CNewsCompare    {
public :
    virtual BOOL    IsMatch( CNewsGroupCore * ) = 0 ;
    virtual DWORD   ComputeHash( ) = 0 ;
} ;

class   CNewsCompareId : public CNewsCompare    {
private :
    GROUPID m_id ;
public :
    CNewsCompareId( GROUPID ) ;
    CNewsCompareId( CNewsGroupCore * ) ;
    int     IsMatch( CNewsGroupCore * ) ;
    DWORD   ComputeHash( ) ;
} ;

class   CNewsCompareName : public   CNewsCompare    {
private :
    LPSTR   m_lpstr ;
public :
    CNewsCompareName( LPSTR ) ;
    CNewsCompareName( CNewsGroupCore * ) ;
    BOOL    IsMatch( CNewsGroupCore * ) ;
    DWORD   ComputeHash( ) ;
} ;

//
// this class implements the COM wrapper for CNewsTreeCore
//
class CINewsTree : public INewsTree
{
private:
    //
    // Pointer to the newsgroup object
    //
    CNewsTreeCore* m_pParentTree;

    //
    // Reference counting
    //
    LONG   m_cRef;

public:
    //
    // Constructors
    //
    CINewsTree(CNewsTreeCore *pParent = NULL) {
        m_pParentTree = pParent;
        m_cRef = 0;
    }

        HRESULT Init(CNewsTreeCore *pParent) {
        m_pParentTree = pParent;
                return S_OK;
        }

        CNewsTreeCore *GetTree() {
                return m_pParentTree;
        }


// INNTPPropertyBag
public:
        //
        // given a group ID find the matching group
        //
        HRESULT __stdcall FindGroupByID(
                DWORD                           dwGroupID,
                INNTPPropertyBag        **ppNewsgroupProps,
                INntpComplete       *pProtocolComplete = NULL           );

        // 
        // given a group name find the matching group.  if the group doesn't
        // exist and fCreateIfNotExist is set then a new group will be created.
        // the new group won't be available until CommitGroup() is called.
        // if the group is Release'd before CommitGroup was called then it
        // won't be added.
        //
        HRESULT __stdcall FindOrCreateGroupByName(
                LPSTR                           pszGroupName,
                BOOL                            fCreateIfNotExist,
                INNTPPropertyBag        **ppNewsgroupProps,
                INntpComplete       *pProtocolComplete = NULL,
                GROUPID             groupid = 0xffffffff,
                BOOL                fSetGroupId = FALSE
                );

        //
        // add a new group to the newstree
        //
        HRESULT __stdcall CommitGroup(INNTPPropertyBag *pNewsgroupProps);

        //
        // remove an entry
        //
        HRESULT __stdcall RemoveGroupByID(DWORD dwGroupID);
        HRESULT __stdcall RemoveGroupByName(LPSTR pszGroupName, LPVOID lpContext);


        //
        // enumerate across the list of keys.  
        //
        HRESULT __stdcall GetIterator(INewsTreeIterator **pIterator);

        //
        // get a pointer to the owning server object
        //
        HRESULT __stdcall GetNntpServer(INntpServer **ppNntpServer);

        //
        // this function will be used by drivers to make sure that they
        // are adding newsgroups that they properly own.
        //
        HRESULT __stdcall LookupVRoot(LPSTR pszGroup, INntpDriver **ppDriver);

    //
    // Implementation of IUnknown
    //
    HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    {
        if ( iid == IID_IUnknown ) {
            *ppv = static_cast<IUnknown*>(this);
        } else if ( iid == IID_INewsTree ) {
            *ppv = static_cast<INewsTree*>(this);
        } else {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    ULONG __stdcall AddRef()
    {
        return InterlockedIncrement( &m_cRef );
    }

    ULONG __stdcall Release()
    {
        if ( InterlockedDecrement( &m_cRef ) == 0 ) {
            _ASSERT( 0 );
        }

        return m_cRef;
    }
};

//-----------------------------------------------------------
//
// This class is used to find CNewsGroup objects.   There should only
// ever exist one object of this class.
//
// Group's can be found through two means :
//   1) Use the name of the group as it appears in an article
//       2) Using a Group ID number
//
// Group ID Numbers are used in Article Links.  A link from one article to another
// will contain a Group ID Number and Article Number to represent the link.
//
// We will maintain a Hash Table to find CNewsGroup objects based on newsgroup name.
// We will also maintain a Hash Table to find CNewsGroup objects based on Group ID.
//
// Finally, we will maintain a doubly linked list of CNewsGroups which is sorted by
//      name.  This linked list will be used to support pattern matching iterators.
//
class   CNewsTreeCore   {
protected :
        friend  class   CGroupIteratorCore;
        // this guy removes itself from the list of newsgroups
        friend  CNewsGroupCore::~CNewsGroupCore();
        friend  CNewsGroupCore::ComputeXoverCacheDir(   char    (&szPath)[MAX_PATH*2], BOOL &fFlatDir, BOOL ) ;

        friend  VOID DbgPrintNewstree(CNewsTreeCore* ptree, DWORD nGroups);
        friend class CNNTPVRoot::CPrepareComplete;
        friend class CNNTPVRoot::CDecorateComplete;

        //
        // Instance wrapper to access instance stuff
        //
        CNntpServerInstanceWrapperEx *m_pInstWrapper;

        //
        //      C++ WARNING -- m_LockTables and m_LockHelpText are declared FIRST because
        //      we want them to be destroyed LAST (C++ says that members are destroyed in the
        //      reverse order they appear in the class declaration.)
        //
        //
        //      Reader/Writer lock for accessing hash tables
        //
        CShareLockNH m_LockTables;

        CINewsTree m_inewstree;

        //
        //      The first GROUPID reserved for 'special' newsgroups
        //      speciall == not visible to clients
        //
        GROUPID m_idStartSpecial;

        //
        //      The last GROUPID reserved for 'special' newsgroups
        //
        GROUPID m_idLastSpecial;

        //
        //      The GROUPID     reserved for 'slaves' to hold postings untill sent to the master
        //
        GROUPID m_idSlaveGroup;

        //
        //      The highest 'sepcial' GROUPID seen to date !
        //
        GROUPID m_idSpecialHigh;

        //
        //      The first GROUPID for use for newsgroups
        //      (must be larger than m_idLastSpecial)
        //
        GROUPID m_idStart;
        
        //
        //      The highest GROUPID we have to date 
        //
        GROUPID m_idHigh;

        //
        //      Newsgroups hashed by their name
        //
        CHASHLPSTR m_HashNames;

        //
        //      Newsgroups heashed by their ID
        //
        CHASHGROUPID m_HashGroupId;

        //
        //      Start of alphabetically sorted linked list !
        //
    CNewsGroupCore *m_pFirst;

        //
        //      Tail of alphabetically sorted linked list of newsgroups
        //
    CNewsGroupCore *m_pLast;
        
        //
        //      Number of newsgroups
        //
    int m_cGroups;

        //
        // Number of changes to the list of newsgroups since last visit
        //
        long m_cDeltas; 

        // 
        // our vroot table
        //
        CNNTPVRootTable *m_pVRTable;

        // 
        // the tree is stopping?
        //
        BOOL m_fStoppingTree;

        // 
        // should we reject invalid group names?
        //
        BOOL m_fRejectGenomeGroups;

        //
        // the file that we saved fixed size properties into
        //
        CFixPropPersist *m_pFixedPropsFile;

        //
        // the file that we saved variable sized properties into
        //
        CFlatFile *m_pVarPropsFile;

        //
        // pointer to the server object which we will pass into drivers
        //
        INntpServer *m_pServerObject;

        //
        // has the vroot table been initialized yet?
        //
        BOOL m_fVRTableInit;

        //
        //      Linked list manipulation functions
        //
    void InsertList(CNewsGroupCore *pGroup, CNewsGroupCore *pParent);
        void AppendList(CNewsGroupCore *pGroup);
    void RemoveList(CNewsGroupCore *pGroup);

        //
        //      These functions handle inserts into all lists and hash tables simultaneously !
        //
        BOOL Append(CNewsGroupCore      *pGroup);
    BOOL Insert(CNewsGroupCore *pGroup, CNewsGroupCore *pParent = NULL);
    BOOL InsertEx(CNewsGroupCore *pGroup);
    BOOL Remove(CNewsGroupCore *pGroup, BOOL fHaveExLock = FALSE);

        //
        // [in] szGroup = group name
        // [in] szNativeGroup = the native name
        // [out] groupid = set to the group id of the new group
        // [in] groupid = if fSetGroupId == TRUE then make this the group id
        // [in] fSpecial = create a special group
        // [out] ppGroup = contains the new group 
        // [in] fAddToGroupFiles = add this to the group files?
        // [in] fSetGroupId = if this is set then the group's ID will be groupid
        //
        BOOL    CreateGroupInternal(char *szGroup, 
                                                                char *szNativeGroup, 
                                                                GROUPID& groupid,
                                                                BOOL fAnonymous,
                                                                HANDLE hToken,
                                                                BOOL fSpecial = FALSE, 
                                                                CGRPCOREPTR *ppGroup = NULL,
                                                                BOOL fAddToGroupFiles = TRUE,
                                                                BOOL fSetGroupId = FALSE,
                                                                BOOL fCreateInStore = TRUE,
                                                                BOOL fAppend = FALSE );

    BOOL    CreateGroupInternalEx(LPSTR lpstrGroupName, 
                                                                  LPSTR lpstrNativeGroupName, 
                                                                  BOOL fSpecial = FALSE);

        BOOL    CreateSpecialGroups();

        // this is the callback used by DecorateNewsTree
        static void DropDriverCallback(void *pEnumContext,
                                                               CVRoot *pVRoot);

        //
        // this function is called for each group loaded from the fixed-record
        // file
        //
        static BOOL LoadTreeEnumCallback(DATA_BLOCK &block, void *pThis, DWORD dwOffset, BOOL bInOrder );

        //
        // this function is called when a group's entry in the variable
        // length file changes
        //
        static void FlatFileOffsetCallback(void *, BYTE *, DWORD, DWORD);

        //
        // read a record from the flatfile and update a group with the properties
        //
        HRESULT ParseFFRecord(BYTE *pData, DWORD cData, DWORD iOffset, DWORD dwVer);

        //
        // save a group into a flatfile record
        //
        HRESULT BuildFFRecord(CNewsGroupCore *pGroup, BYTE *pData, DWORD *pcData);

        // 
        // Parse the group properties from old group.lst entry
        //
        BOOL    ParseGroupParam(            char*, 
                                                DWORD, 
                                                DWORD&, 
                                                LPSTR,
                                                LPSTR,
                                                DWORD&,
                                                BOOL&,
                                                DWORD&,
                                                DWORD&,
                                                DWORD&,
                                                BOOL&,
                                                BOOL&,
                                                FILETIME& ) ;

protected:
        virtual CNewsGroupCore *AllocateGroup() {
                return new CNewsGroupCore(this);
        }

public :

    CNewsTreeCore(INntpServer *pServerObject = NULL);
        CNewsTreeCore(CNewsTreeCore&);
        virtual ~CNewsTreeCore();
        
    CNewsTreeCore *GetTree() { return this; }

        INewsTree *GetINewsTree() { 
                m_inewstree.AddRef(); 
                return &m_inewstree;
        }

    BOOL Init(CNNTPVRootTable *pVRTable, 
              CNntpServerInstanceWrapperEx *pInstWrapper,
                          BOOL& fFatal, 
                          DWORD cNumLocks, 
                          BOOL fRejectGenomeGroups);

        //
        // Load the newstree from disk
        //
        BOOL LoadTree(char *szFix, char *szVar, BOOL& fUpgrade, DWORD dwInsance = 0, BOOL fVerify = TRUE );

        // 
        // Load the newstree from old format group.lst
        BOOL OpenTree( LPSTR, DWORD, BOOL, BOOL&, BOOL );

        // 
        // save the newstree to disk
        //
        BOOL SaveTree( BOOL fTerminate = TRUE );

        //
        // save the properties in one group to disk
        //
        BOOL SaveGroup(INNTPPropertyBag *pBag);

        //
        //      this releases our references on the group objects
        //
        void TermTree();

        // this callback is called when the vroots are rescanned
        static void VRootRescanCallback(void *pThis);

        //
        //      Stop all background processing - kill any threads we started etc...
        //
    BOOL StopTree();

        //
        //      InitClass must be called before any CNewsGroup object is created or manipulated.
        //
        BOOL InitNewsgroupGlobals(DWORD cNumLocks);

        //
        //      Call after all article id allocation is complete
        //
        void TermNewsgroupGlobals();

        //
        //      Copy the file containing newsgroups to a backup
        //
        void RenameGroupFile();

        //
        // get a pointer to the server object
        //
        INntpServer *GetNntpServer() { return m_pServerObject; }

        // One critical section used for allocating article id's !!
        //CRITICAL_SECTION m_critLowAllocator;
        CRITICAL_SECTION m_critIdAllocator;

        //
        //      Number of Locks we are using to protect access to 
        //      our m_lpstrPath and fields
        //
        DWORD m_NumberOfLocks;

        //
        //      Pointer to array of locks - reference by computing
        //      modulus of m_groupId by gNumberOfLocks
        //
        CShareLockNH* m_LockPathInfo;

        //
        //      Indicate to background threads that the newstree has changed and needs to be saved.
        //
        void Dirty(); // mark the tree as needing to be saved !!


        //
        //      Used during bootup to figure out what the range of GROUPID's in the 
        //      group file is.
        //
        void ReportGroupId(GROUPID groupid);
        
        
        //---------------------------------
        // Group Location Interface - find a news Group for an article
        //
        
        // Find an article based on a string and its length
        CGRPCOREPTRHASREF GetGroup(const char *szGroupName, int cch ) ;
        CGRPCOREPTRHASREF GetGroupPreserveBuffer(const char     *szGroupName, int cch ) ;
        
        // Find a newsgroup given an CArticleRef
        CGRPCOREPTRHASREF GetGroup( CArticleRef& ) ;
        
        // Find a newsgroup based on its GROUPID
        CGRPCOREPTRHASREF GetGroupById( GROUPID groupid, BOOL fFirm = FALSE ) ;
        
        GROUPID GetSlaveGroupid() ;

        // Find the parent of a newsgroup
        CGRPCOREPTRHASREF GetParent( 
                                           IN  char* lpGroupName,
                                           IN  DWORD cbGroup,
                                           OUT DWORD& cbConsumed
                                           );
    //
    // The following function takes a list of strings which are
        // terminated by a double NULL and builds an iterator object
        // which can be used examine all the group objects.
    //
    CGroupIteratorCore *GetIterator(LPMULTISZ lpstrPattern,     
                                                                BOOL fIncludeSpecialGroups = FALSE);

        //----------------------------------
        //      Active NewsGroup Interface - Specify an interface for generating a
        //  list of active newsgroups and estimates of their contents.
        //
    CGroupIteratorCore *ActiveGroups(BOOL fReverse = FALSE);    

        //----------------------------------
    // Group Control interface - These functions can be used to remove
    // and add newsgroups.

    //
    // RemoveGroup is called once we've parsed an article that kills
    // a newsgroup or the Admin GUI decides to destroy an article.
    //
    virtual BOOL RemoveGroup(CNewsGroupCore *pGroup );

    //
    // Remove group from newstree only
    //
    BOOL RemoveGroupFromTreeOnly( CNewsGroupCore *pGroup );
    
        //
        // RemoveDriverGroup is called by the expire thread in the server
        // to physically remove a group from a driver
        //
        BOOL RemoveDriverGroup(CNewsGroupCore *pGroup );

    //
    // CreateGroup is called with the name of a new newsgroup which we've
    // gotten through a feed or from Admin. We are given only the name
    // of the new newsgroup.  We will find the parent group by removing
    // trailing ".Group" strings from the string we are passed.
    // We will clone the properties of this newsgroup to create our new
    // newsgroup.
    //
    BOOL CreateGroup(   LPSTR lpstrGroupName, 
                        BOOL fIsAllLowerCase,
                        HANDLE hToken,
                        BOOL fAnonymous ) {
                HRESULT hr;
                hr = FindOrCreateGroup( lpstrGroupName, 
                                        fIsAllLowerCase, 
                                        TRUE, 
                                        TRUE, 
                                        NULL,
                                        hToken,
                                        fAnonymous );
                if (hr == S_OK) {
                        return TRUE;
                } else {
                        if (hr == S_FALSE) {
                                SetLastError(ERROR_GROUP_EXISTS);
                        } else {
                                SetLastError(HRESULT_CODE(hr));
                        }
                        return FALSE;
                }
        }

        //
        // this function can find or create a group atomically.  
        //
        // parameters:
        //   lpstrGroupName - the name of the group to create
        //   fIsAllLowerCase - is the group name lower case?
        //   fCreateIfNotExist - should we create it if the group doesn't exist?
        //   ppExistingGroup - a pointer to get the existing group if it exists.
        //
        // return codes: S_OK = group was found.  S_FALSE = group was created.
        //               else = error.
        //
        HRESULT FindOrCreateGroup(LPSTR lpstrGroupName, 
                                                          BOOL fIsAllLowerCase,
                                                          BOOL fCreateIfNotExist,
                                                          BOOL fCreateInStore,
                                                          CGRPCOREPTR *ppExistingGroup,
                                                          HANDLE hToken,
                                                          BOOL fAnonymous,
                                                          GROUPID groupid = 0xffffffff,
                                                          BOOL fSetGroupId = FALSE );

    BOOL    HashGroupId(CNewsGroupCore *pGroup);

        //
        //      Check whether a GROUPID is in the 'special' range
        //

        BOOL IsSpecial(GROUPID groupid) {
                return  groupid >= m_idStartSpecial && groupid <= m_idLastSpecial;
        }

    int GetGroupCount( void ) { return m_cGroups; };
    void RemoveEx( CNewsGroupCore *pGroup ) ;

        //
        // find the controlling driver for a group and return it
        //
        HRESULT LookupVRoot(char *pszGroup, INntpDriver **ppDriver);

        //
        // Is the tree being stopped ?
        //
        BOOL IsStopping() { return m_fStoppingTree; }

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\nntpvr.h ===
#ifndef __TESTVR_H__
#define __TESTVR_H__

#include <iiscnfg.h>
#include <vroot.h>
#include <stdio.h>
#include <nntpdrv.h>
#include <filehc.h>
#include "mailmsg.h"

class CNNTPVRoot;
class CNewsGroupCore;

extern GET_DEFAULT_DOMAIN_NAME_FN pfnGetDefaultDomainName;
extern HANDLE   g_hProcessImpersonationToken;

//
// The base implementation of the completion object.  It implements the 
// following:
//  * AddRef
//  * Release
//  * QueryInterface
//  * SetResult
//
class CNntpComplete : public INntpComplete {
	public:
		// IUnknown:
		ULONG __stdcall AddRef();
		ULONG __stdcall Release();
	    HRESULT __stdcall QueryInterface(const IID& iid, VOID** ppv);

		// INntpComplete:
		void __stdcall SetResult(HRESULT hr);

		// non COM methods
		//
		//	Retrieve the HRESULT the Driver deposited for us !
		//
		HRESULT GetResult();
		//
		//	Get the VRoot this completion is bound to !
		//
		CNNTPVRoot *GetVRoot();
		//
		//	Construct us - we may be constructed bound to a particular
		//	vroot!
		//
		CNntpComplete(CNNTPVRoot *pVRoot = NULL);
		//
		//	Bind us to a particular Vroot - we'll hold a reference
		//	on the VRoot object as long as we're pending !
		//
		void SetVRoot(CNNTPVRoot *pVRoot);

		// 
		//  Wraps releasing property bag, to do some bookkeeping
		//
		void _stdcall ReleaseBag( INNTPPropertyBag *pPropBag )
		{
		    DecGroupCounter();
		    pPropBag->Release();
		}

        //
		// Inc, Dec group counter
		//
		void BumpGroupCounter()
		{
#ifdef DEBUG
            m_cGroups++;
#endif
        }

        void DecGroupCounter()
        {
#ifdef DEBUG
            _ASSERT( m_cGroups > 0 );
            m_cGroups--;
#endif
        }

		virtual ~CNntpComplete();
		//
		//	Derived classes may handle our allocation and destruction
		//	differently - i.e. a CNntpComplete object may be used several
		//	times, being re-used instead of destroyed when the ref count 
		//	reaches 0 !
		//
		virtual void Destroy();
		//
		//	This should only be called when our refcount has reached zero - 
		//	we will reset the Completion object to its fresh after construction
		//	state so that we can be re-used for another store operation !
		//
		virtual	void	Reset() ;

	protected:
		LONG m_cRef;
		HRESULT m_hr;
		CNNTPVRoot *m_pVRoot;

		// A counter that helps find out property bag leaks, dbg build only
#ifdef DEBUG
		LONG m_cGroups;
#endif
};

// the completion object for newstree decoration
/*
class CNntpSyncCompleteEx : public CNntpComplete {
	public:
		CNntpSyncComplete(    CNNTPVRoot *pVR, 	// the current vroot
							  HRESULT *phr );	// signalled when done
		~CNntpSyncComplete();
	private:
		// we write the value in GetResult() into this pointer
		HRESULT *m_phr;
		// we signal this handle when the create group is complete
		HANDLE m_heDone;
};
*/

// Class definition for the completion object.
// It derives INntpComplete, but implements a blocking completion
class CNntpSyncComplete : public CNntpComplete {  //sc
private:
	HANDLE 	m_hEvent;

#if defined( DEBUG )
	//
	// for debugging purpose, assert user should call IsGood
	//
	BOOL    m_bIsGoodCalled;
#endif
	
	//
	//	These objects can only be made on the stack !
	//
	void*	operator	new( size_t size ) ;
	void	operator	delete( void* )	{}
public:
    // Constructor and destructors
	CNntpSyncComplete::CNntpSyncComplete(	CNNTPVRoot*	pVRoot = 0 ) : 
    	CNntpComplete( pVRoot )	{
    	AddRef() ;
    	_VERIFY( m_hEvent = GetPerThreadEvent() );
    	//m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
#if defined( DEBUG )
        m_bIsGoodCalled = FALSE;
#endif
	    TraceQuietEnter( "CDriverSyncComplete::CDriverSyncComplete" );
    }

	CNntpSyncComplete::~CNntpSyncComplete()    {
        //_VERIFY( CloseHandle( m_hEvent ) );
    }

    // Reset the completion object
    VOID
    Reset()
    {
    	CNntpComplete::Reset() ;
    	_ASSERT( m_hEvent != 0 ) ;
    	AddRef() ;
	}

	BOOL
	IsGood()	{
#if defined( DEBUG )
        m_bIsGoodCalled = TRUE;
#endif
		return	m_hEvent != 0 ;
	}

	void
	Destroy()	{
		//
		//	Do Nothing !
		//
		SetEvent( m_hEvent ) ;
	}

    // Wait for the completion 
	HRESULT
    WaitForCompletion()
    {
		_ASSERT( m_hEvent );
		_ASSERT( m_bIsGoodCalled );
		LONG    lRef;
		if ( ( lRef = InterlockedDecrement( &m_cRef ) ) == 0 ) {
			// It has been completed, I don't need to wait,
		} else if ( lRef == 1 ) {   
			if( m_hEvent == NULL ) 
				return	E_FAIL ;
			// still waiting for completion
			DWORD dw = WaitForSingleObject( m_hEvent, INFINITE );
		} else {
			_ASSERT( 0 );
			return	E_FAIL ;
		}
		return	GetResult() ;
	}
};

//
// Our implementation of the VRoot object.  
//
class CNNTPVRoot : public CIISVRootTmpl<INewsTree *> {
	public:

	    enum DRIVERSTATE {
			VROOT_STATE_UNINIT,
			VROOT_STATE_CONNECTING,
			VROOT_STATE_CONNECTED,
		};

	    enum LOGON_INFO {
            VROOT_LOGON_DEFAULT,
            VROOT_LOGON_UNC,
            VROOT_LOGON_EX
        };
        
		CNNTPVRoot();
		~CNNTPVRoot();

		//
		// drop references to any drivers that we have loaded and put the
		// vroot into the VROOT_STATE_UNINIT state
		//
		void DropDriver();

		//
		// read our parameters out of the metabase and put the driver into
		// VROOT_STATE_CONNECTING
		//
		virtual HRESULT ReadParameters(IMSAdminBase *pMB, METADATA_HANDLE hmb);

		//
		// Virtual function for handling orphan VRoot during VRootRescan/VRootDelete
		//
		void DispatchDropVRoot();

		//
		// Drop our connection to the driver so that we can cancel async
		// calls
		//
		virtual void CancelAsyncCalls() { DropDriver(); }

		//
		// given a group name figure out the path to the newsgroup.  
		//
		HRESULT MapGroupToPath(const char *pszGroup, 
							   char *pszPath, 
							   DWORD cchPath,
							   PDWORD pcchDirRoot,
							   PDWORD pcchVRoot);

		//
		// access the directory name
		//
		const char *GetDirectory(void) { return m_szDirectory; }

		// Get the vroot impersonation token
		HANDLE GetImpersonationHandle() { return m_hImpersonation; }

		// Get the logon info, or vroot type
		LOGON_INFO GetLogonInfo() { return m_eLogonInfo; }

		// Check if the vroot does expiration itself
		BOOL    HasOwnExpire() {
		    return m_bExpire;
		}

		// Logon the user configured in vroot
        HANDLE LogonUser( LPSTR, LPSTR );		
        BOOL CNNTPVRoot::CrackUserAndDomain(
            CHAR *   pszDomainAndUser,
            CHAR * * ppszUser,
            CHAR * * ppszDomain
            );

		//
		// Set the vroot's errorcode in the metabase
		//
		void SetVRootErrorCode(DWORD dwErrorCode);

		//
		// the next set of functions are just wrappers for the driver's
		// functions
		//
		void DecorateNewsTreeObject(CNntpComplete *punkCompletion);
		void CreateGroup(INNTPPropertyBag *pGroup, 
		                    CNntpComplete *punkCompletion, 
		                    HANDLE hToken,
		                    BOOL    fAnonymous );
		void RemoveGroup(INNTPPropertyBag *pGroup, CNntpComplete *punkCompletion);
		void SetGroup(  INNTPPropertyBag    *pGroup, 
                            DWORD       cProperties,
                            DWORD       idProperties[],
                            CNntpComplete *pCompletion );
        void CheckGroupAccess(  INNTPPropertyBag *pGroup,
                                HANDLE  hToken,
                                DWORD   dwAccessDesired,
                                CNntpComplete *pCompletion );

		//
		//	Wrap calls to Drivers to get Articles !
		//
		void GetArticle(CNewsGroupCore  *pPrimaryGroup,
						CNewsGroupCore  *pCurrentGroup,
						ARTICLEID		idPrimary,
						ARTICLEID		idCurrent,
						STOREID			storeid,
						FIO_CONTEXT		**ppfioContext,
						HANDLE          hImpersonate,
						CNntpComplete	*punkComplete,
                        BOOL            fAnonymous
						);

		//
		//	Wrap calls to Drivers to get XOVER information !
		//
		void	GetXover(	IN	CNewsGroupCore	*pGroup,
							IN	ARTICLEID		idMinArticle,
							IN	ARTICLEID		idMaxArticle,
							OUT	ARTICLEID		*pidLastArticle,
							OUT	char*			pBuffer, 
							IN	DWORD			cbIn,
							OUT	DWORD*			pcbOut,
							IN	HANDLE			hToken,
							IN	CNntpComplete*	punkComplete,
                            IN  BOOL            fAnonymous
							) ;

		//
		//	Wrap calls to the drivers to get the path for XOVER caching !
		//
		BOOL	GetXoverCacheDir(	
							IN	CNewsGroupCore*	pGroup,
							OUT	char*	pBuffer, 
							IN	DWORD	cbIn,
							OUT	DWORD*	pcbOut, 
							OUT	BOOL*	pfFlatDir
							) ;

        //
        // Wrap calls to Drivers to Get xhdr information
        //
        void	GetXhdr(	IN	CNewsGroupCore	*pGroup,
				    		IN	ARTICLEID		idMinArticle,
					    	IN	ARTICLEID		idMaxArticle,
    						OUT	ARTICLEID		*pidLastArticle,
    						LPSTR               szHeader,
	    					OUT	char*			pBuffer, 
		    				IN	DWORD			cbIn,
			    			OUT	DWORD*			pcbOut,
				    		IN	HANDLE			hToken,
					    	IN	CNntpComplete*	pComplete,
                            IN  BOOL            fAnonymous
    						);
        //
        // Wrap calls to Drivers to delete article
        //
		void DeleteArticle( INNTPPropertyBag    *pPropBag,
                            DWORD               cArticles,
                            ARTICLEID           rgidArt[],
                            STOREID             rgidStore[],
                            HANDLE              hClientToken,
                            PDWORD              piFailed,
                            CNntpComplete       *pComplete,
                            BOOL                fAnonymous );

        //
        // Wrap calls to drivers to rebuild a group
        //
        void RebuildGroup(  INNTPPropertyBag *pPropBag,
                            HANDLE          hClientToken,
                            CNntpComplete   *pComplete );

        //
        // Wrap calls to drivers to commit post
        //
		void CommitPost(IUnknown					*punkMessage,
					    STOREID						*pStoreId,
						STOREID						*rgOtherStoreIds,
						HANDLE                      hClientToken,
						CNntpComplete				*pComplete,
                        BOOL                        fAnonymous );

		//
		// get the store driver so that the protocol can do alloc message
		//
		IMailMsgStoreDriver *GetStoreDriver() {
			INntpDriver *pDriver;
			if ((pDriver = GetDriverHR()) != NULL) {
				IMailMsgStoreDriver *pStoreDriver = NULL;
				if (FAILED(pDriver->QueryInterface(IID_IMailMsgStoreDriver, 
											       (void**) &pStoreDriver)))
				{
					pStoreDriver = NULL;
				}
				pDriver->Release();
				return pStoreDriver;
			}
			return NULL;
		}

		//
		// get a pointer to the driver.  this should not be used for
		// driver operations... they should go through the wrapper functions
		// provided at the vroot level
		//
		INntpDriver *GetDriver() { return m_pDriver; }

		//
		// check to see if this vroot is configured with a driver.  mostly
		// here to make operations work even if the unit tests are configured
		// without a driver
		//
		BOOL IsDriver() { return m_clsidDriverPrepare != GUID_NULL; }

		//
		// Get and set methods for impersonation token
		void SetImpersonationToken( HANDLE hToken ) {
		    m_hImpersonation = hToken;
		}

		HANDLE  GetImpersonationToken() {
		    return m_hImpersonation;
		}

		BOOL InStableState()
		{ return ( m_eState == VROOT_STATE_CONNECTED || m_eState == VROOT_STATE_UNINIT); } 

		//
		// return TRUE if we are in the connected state, FALSE otherwise.
		// 
		BOOL CheckState();

		//
		// check if it's connected
		//
		BOOL IsConnected() { return m_eState == VROOT_STATE_CONNECTED; }

		//
		// Set decorate completed flag
		//
        void SetDecCompleted()
        { InterlockedExchange( &m_lDecCompleted, 1 ); }

        //
        // Set decorate is not completed
        //
        void SetDecStarted()
        { InterlockedExchange( &m_lDecCompleted, 0 ); }

        //
        // Test if dec is completed ?
        //
        BOOL DecCompleted()
        { 
            LONG l = InterlockedCompareExchange( &m_lDecCompleted,
                                                 TRUE,
                                                 TRUE );
            return ( l == 1 );
        }

        //
		// Get connection status win32 error code, called by rpc
		//
		DWORD   GetVRootWin32Error( PDWORD pdwWin32Error )
		{
		    //
		    // if connected, return OK
		    //
		    if ( m_eState == VROOT_STATE_CONNECTED )
		        *pdwWin32Error = NOERROR;
		    else {
		        // init it to be PIPE_NOT_CONNECTED
		        *pdwWin32Error = ERROR_PIPE_NOT_CONNECTED;

		        // Lets see if it's going to be overwritten by the real
		        // win32 error code
		        if ( m_dwWin32Error != NOERROR ) *pdwWin32Error = m_dwWin32Error;
		    }

		    return NOERROR;
		}

        
	private:
		// 
		// do a bunch of ASSERTs which verify that we are in a valid state
		//
#ifdef DEBUG
		void Verify();
#else 
		void Verify() { }
#endif

		//
		// check to see if the HRESULT is due to a driver going down.  if
		// so drop our connection to the driver and update our state
		//
		void UpdateState(HRESULT hr);

		//
		// start the connection process
		//
		HRESULT StartConnecting();

		//
		// this is inlined into the top of each driver function wrapper.
		// it verifies that we are in a correct state.  if we are in
		// a correct state then it returns TRUE.  if we aren't then
		// it sends an error to the completion object and returns FALSE.
		//
		INntpDriver *GetDriver( INntpComplete * pCompletion ) {
			INntpDriver *pDriver;
			m_lock.ShareLock();
			if (!CheckState()) {
				pDriver = NULL;
			} else {
				pDriver = m_pDriver;
				pDriver->AddRef();
			}
		    m_lock.ShareUnlock();
		    /*
			if (pDriver == NULL) {
			    pCompletion->SetResult(E_UNEXPECTED);
			    pCompletion->Release();
			}*/
			return pDriver;
		}

		INntpDriver *GetDriverHR(HRESULT *phr = NULL) {
			INntpDriver *pDriver;
			m_lock.ShareLock();
			if (!CheckState()) {
				pDriver = NULL;
			} else {
				pDriver = m_pDriver;
				pDriver->AddRef();
			}
		    m_lock.ShareUnlock();
			if (pDriver == NULL && phr != NULL) *phr = E_UNEXPECTED;
			return pDriver;
		}

#ifdef DEBUG
		// pointer to the driver for this vroot
		INntpDriver *m_pDriverBackup;
#endif

		// the metabase object
		IMSAdminBase *m_pMB;

		// the directory that contains this vroot
		char m_szDirectory[MAX_PATH];

		// the length of the directory string
		DWORD m_cchDirectory;

		// pointer to the connection interface for the driver
		INntpDriverPrepare *m_pDriverPrepare;

		// pointer to the driver for this vroot
		INntpDriver *m_pDriver;

		// the current state of the driver
		DRIVERSTATE m_eState;

		// Why is it not connected ?
		DWORD       m_dwWin32Error;

		// this lock is used to lock the driver pointers and the state
		CShareLockNH m_lock;

		// class id for the driver prepare interface
		CLSID m_clsidDriverPrepare;

        // Impersonation token, logged on to access UNC vroots
        HANDLE  m_hImpersonation;

        // Do I handle expiration ?
        BOOL    m_bExpire;

        // What type the vroot is ?
        LOGON_INFO  m_eLogonInfo;

        // is decorate completed ?
        LONG m_lDecCompleted;

	public:
		// the completion object for driver connection
		class CPrepareComplete : public CNntpComplete {
			public:
				CPrepareComplete(CNNTPVRoot *pVR) : 
					CNntpComplete(pVR), m_pDriver(NULL) {}
				~CPrepareComplete();
				INntpDriver *m_pDriver;
		};

		friend class CNntpComplete;
		friend class CNNTPVRoot::CPrepareComplete;

		// the completion object for newstree decoration
		class CDecorateComplete : public CNntpComplete {
			public:
				CDecorateComplete(CNNTPVRoot *pVR) : CNntpComplete(pVR) {}
				~CDecorateComplete();
                void CreateControlGroups( INntpDriver *pDriver );
                void CreateSpecialGroups( INntpDriver *pDriver );
		};

		friend class CNNTPVRoot::CDecorateComplete;
};

//
// we need to do this instead of a typedef so that we can forward declare
// the class in nntpinst.hxx
//
class CNNTPVRootTable : public CIISVRootTable<CNNTPVRoot, INewsTree *> {
	public:
		CNNTPVRootTable(INewsTree *pNewsTree, PFN_VRTABLE_SCAN_NOTIFY pfnNotify) : 
			CIISVRootTable<CNNTPVRoot, INewsTree *>(pNewsTree, pfnNotify) 
		{
		}

        //
        // Block until all the vroots are finished with connect
        //
        BOOL BlockUntilStable( DWORD dwWaitSeconds );

        //
        // check to see if all the vroots are connected
        //
        BOOL AllConnected();

        //
        // Call back function to check if a vroot is in stable state
        //
        static void BlockEnumerateCallback( PVOID pvContext, CVRoot *pVRoot );

        //
        // Call back function to check if a vroot is connected
        //
        static void CheckEnumerateCallback( PVOID pvContext, CVRoot *pVRoot );

        //
        // Call back function to check if vroot newstree decoration is completed
        //
        static void DecCompleteEnumCallback(   PVOID   pvContext, CVRoot  *pVRoot );

        //
        // Get instance wrapper
        //
        class	CNntpServerInstanceWrapperEx *GetInstWrapper() { 
		    return m_pInstWrapper;
		}

		//
		// Get the win32 error code for vroot connection
		//
		DWORD   GetVRootWin32Error( LPWSTR wszVRootPath, PDWORD pdwWin32Error );

		//
		// Initialization
		//
		HRESULT Initialize( LPCSTR pszMBPath, 
		                    class CNntpServerInstanceWrapperEx *pInstWrapper,
		                    BOOL fUpgrade ) {
            m_pInstWrapper = pInstWrapper;
            return CIISVRootTable<CNNTPVRoot, INewsTree*>::Initialize( pszMBPath, fUpgrade );
        }
        
	private:

	    //
	    // Server instance wrapper
	    //
	    class	CNntpServerInstanceWrapperEx *m_pInstWrapper;

};

typedef CRefPtr2<CNNTPVRoot> NNTPVROOTPTR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\ptable.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	ptable.h

Abstract:

	This module contains the export of the property table

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/05/97	created

--*/

#ifndef _PTABLE_H_
#define _PTABLE_H_

#include "props.h"

// Enumerated type for HP access of individual properties.  needs to be
// in the same sorted order as the property table.
typedef enum _PTABLE_ITEMS
{
	_PI_NEWSGROUPS = 0,
	_PI_MESSAGE_STREAM,
	_PI_HEADER,
	_PI_POST,
	_PI_PROCESS_CONTROL,
	_PI_PROCESS_MODERATOR,
	_PI_FILENAME,
	_PI_FEEDID,
#if SECURITY_CONTEXT_PROPERTY
	_PI_SECURITY_CONTEXT,
#endif
	_PI_NO_ITEM				// for the count below
} PTABLE_ITEMS;

#define PTABLE_SIZE ((DWORD) _PI_NO_ITEM)

extern PROPERTY_ITEM g_rgpiPropertyTable[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\rtscan.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:		

    rtscan.h

Abstract:

    This implements a generic root scan class.  Its difference from rootscan:
    1. Rootscan is not multi-thread safe, using SetCurrentDir; rtscan is;
    2. Rootscan has too much nntp specific stuff; rtscan doesn't;
    
Author:

    Kangrong Yan ( KangYan )    23-Oct-1998

Revision History:

--*/
#if !defined( _RTSCAN_H_ )
#define _RTSCAN_H_

//
// Interface that tells the root scan to stop before complete
//
class CCancelHint {

public:

    virtual BOOL IShallContinue() = 0;
};

//
// Base class to be derived by any one who wants to implement what he wants
// to do at certain points of directory scan.  This class will report the
// directories found in alphabetical order, but doesn't know whether the 
// directory found is a leaf or not.  If a derived class wants to know if
// the dir found is a leaf, he should do it himself.
//
class CRootScan {

public:

    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////
    //
    // Constructor, destructors
    //
    CRootScan(  LPSTR       szRoot,
                CCancelHint *pCancelHint = NULL ) :
         m_pCancelHint( pCancelHint )
    {
        _ASSERT( strlen( szRoot ) <= MAX_PATH );
        strcpy( m_szRoot, szRoot );
    }

    //
    // Start the scan
    //
    BOOL DoScan();

protected:

    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////
    //
    // Interface function to be called to notify derived class that a 
    // directory has been found
    //
    virtual BOOL NotifyDir( LPSTR   szFullPath ) = 0;

private:

    //////////////////////////////////////////////////////////////////////////
    // Private variables
    //////////////////////////////////////////////////////////////////////////
    //
    // Root directory to scan from
    //
    CHAR    m_szRoot[MAX_PATH+1];

    //
    // Pointer to cancel hint interface
    //
    CCancelHint *m_pCancelHint;

    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////
    BOOL IsChildDir( IN WIN32_FIND_DATA& FindData );
    BOOL MakeChildDirPath(  IN LPSTR    szPath,
                            IN LPSTR    szFileName,
                            OUT LPSTR   szOutBuffer,
                            IN DWORD    dwBufferSize );
    HANDLE FindFirstDir(    IN LPSTR                szRoot,
                            IN WIN32_FIND_DATA&     FindData );
    BOOL FindNextDir(    IN HANDLE           hFindHandle,
                         IN WIN32_FIND_DATA& FindData );
    BOOL RecursiveWalk( LPSTR szRoot );
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\syncomp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:		

    syncomp.h

Abstract:

    This file defines and implements a synchronous completion object,
    which derives from INntpComplete.  It should be used on stack.
    
Author:

    Kangrong Yan ( KangYan )    12-July-1998

Revision History:

--*/
#ifndef _SYNCOMP_H_
#define _SYNCOMP_H_
#include <nntpdrv.h>

// Class definition for the completion object.
// It derives INntpComplete, but implements a blocking completion
class CDriverSyncComplete : public INntpComplete {  //sc

public:
    // Constructor and destructors
    CDriverSyncComplete::CDriverSyncComplete()
    {
	    TraceFunctEnter( "CDriverSyncComplete::CDriverSyncComplete" );
	    m_cRef = 0; 
	    m_hr = E_FAIL;
	    _VERIFY( m_hEvent = GetPerThreadEvent() );
	    TraceFunctLeave();
    }

    CDriverSyncComplete::~CDriverSyncComplete()
    {
    	_ASSERT( m_cRef == 0 );
    }

    // Set the result to completion object
    VOID STDMETHODCALLTYPE
    CDriverSyncComplete::SetResult( HRESULT hr )
    {
        _ASSERT( m_hEvent );
	    m_hr = hr;
    }

    // Reset the completion object
    VOID
    CDriverSyncComplete::Reset()
    {
        _ASSERT( m_hEvent );
    	m_hr = E_FAIL;
    }

    // Get the result from the completion object
    HRESULT 
    CDriverSyncComplete::GetResult()
    {
        _ASSERT( m_hEvent );
    	return m_hr;
    }

    // Wait for the completion 
    VOID
    CDriverSyncComplete::WaitForCompletion()
    {
	    _ASSERT( m_hEvent );
	    LONG    lRef;
	    
	    if ( ( lRef = InterlockedDecrement( &m_cRef ) ) == 0 ) {
	        // It has been completed, I don't need to wait,
	    } else if ( lRef == 1 ) {   
	        // still waiting for completion
	        WaitForSingleObject( m_hEvent, INFINITE );
	    } else {
	        _ASSERT( 0 );
	    }
    }

    VOID __stdcall
    ReleaseBag( INNTPPropertyBag *pPropBag )
    {}

	// IUnknown implementations
	HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    {
        _ASSERT( m_hEvent );
        
        if ( iid == IID_IUnknown ) {
            *ppv = static_cast<INntpComplete*>(this);
        } else if ( iid == IID_INntpComplete ) {
            *ppv = static_cast<INntpComplete*>(this);
        } else {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    ULONG __stdcall AddRef()
    {
        _ASSERT( m_hEvent );
        return InterlockedIncrement( &m_cRef );
    }
	
	ULONG __stdcall Release()
	{
		TraceFunctEnter( "CDriverSyncComplete::Complete" );
		_ASSERT( m_hEvent );
		
		LONG lRef;

		if ( ( lRef = InterlockedDecrement( &m_cRef ) ) == 0 ) {
		    // object owner gets there first and is waiting, we
		    // need to set event
			if ( !SetEvent( m_hEvent ) ) {
				FatalTrace( 0, "Set event failed %d", GetLastError() );
				_ASSERT( FALSE );
			}
		} else if ( lRef == 1 ) {
		    // We get there first, object owner will not wait for
		    // event, no need to set
		} else {
		    _ASSERT( 0 );
		}
		
	    TraceFunctLeave();
	    return m_cRef;
	}

	// This function is for debugging purpose
	ULONG   GetRef() 
	{ return m_cRef; }

private:
	HRESULT m_hr;
	LONG	m_cRef;
	HANDLE 	m_hEvent;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\smtpdll.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fpost.h

Abstract:

	Definitions of the fPost interface

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

#ifndef _SMTPDLL_H_
#define _SMTPDLL_H_

// Initialize the moderated provider interface
BOOL InitModeratedProvider();

// Terminate the moderated provider interface
BOOL TerminateModeratedProvider();

// Signal a change in the SMTP server
VOID SignalSmtpServerChange();

// Post an article to the moderator
BOOL fPostArticleEx(
		IN HANDLE	hFile,
        IN LPSTR	lpFileName,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpTempDirectory,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		);

// Post an article via SMTP persistent connection interface
BOOL fPostArticle(
		IN HANDLE	hFile,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		);

#endif	// _SMTPDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\sfromcl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sfromcl.h

Abstract:

    This module contains class declarations/definitions for

!!!

    **** Overview ****

	This derives classes from CInFeed, CArticle, and CField
	that will be used by slaves to process articles from clients. Mostly,
	it just defines various CField-derived objects.

Author:

    Carl Kadie (CarlK)     07-Jan-1996

Revision History:


--*/

#ifndef	_SFROMCL_H_
#define	_SFROMCL_H_

#include "fromclnt.h"

//
//
//
// CSlaveFromClientArticle - class for manipulating articles.
// Note it is baded on CFromClientArticle not (directly) on CArticle.
//

class	CSlaveFromClientArticle  : public CFromClientArticle {
public:

	// Constructor
	CSlaveFromClientArticle(
		char * szLoginName):
		CFromClientArticle(szLoginName)
		{}

	// Modify the headers.
	// Add MessageID, Organization (if necessary), NNTP-Posting-Host,
	// X-Authenticated-User, Modify path, but don't add Xref
	BOOL fMungeHeaders(
		 CPCString& pcHub,
		 CPCString& pcDNS,
		 CNAMEREFLIST & grouplist,
		 DWORD remoteIpAddress,
		 CNntpReturn & nntpr,
         PDWORD pdwLinesOffset = NULL
		 );

	//
	// Message ID's don't need to be recorded, so just return OK
	//

	BOOL fRecordMessageIDIfNecc(
			CNntpServerInstanceWrapper * pInstance,
			const char * szMessageID,
			CNntpReturn & nntpReturn)
		{
			return nntpReturn.fSetOK();
		}

protected :

	//
	// Uses CFromClientArticle's field members
	//
};



// For slaves processing incoming articles from Clients
class	CSlaveFromClientFeed:	public CFromClientFeed 	{
// Public Members
public :

protected:

	// Create an article
	CARTPTR pArticleCreate(void) {
		Assert(ifsInitialized == m_feedState);
		return new CSlaveFromClientArticle(m_szLoginName);
		};

	// This verion of fPostInternal is different from
	// the standard one because
	//      1. Article numbers are not assigned
	//		2. The message id is not recorded
	//		3. The article is not put in the tree.
	//		4. Control messages are not applied
	virtual BOOL fPostInternal (
		CNntpServerInstanceWrapper * pInstance,
		const	LPMULTISZ	szCommandLine,
		CSecurityCtx *pSecurityCtx,
		CEncryptCtx *pEncryptCtx,
		BOOL fAnonymous,
		CARTPTR	& pArticle,
        CNEWSGROUPLIST &grouplist,
        CNAMEREFLIST &namereflist,
        IMailMsgProperties *pMsg,
		CAllocator & allocator,
		char *&	multiszPath,
		char*	pchMessageId,
		DWORD	cbMessageId,
		char*	pchGroups,
		DWORD	cbGroups,
		DWORD	remoteIpAddress,
		CNntpReturn & nntpReturn,
        PFIO_CONTEXT *ppFIOContext,
        BOOL *pfBoundToStore,
        DWORD *pdwOperations,
        BOOL *fPostToMod,
        LPSTR szModerator
		);

	HRESULT FillInMailMsg(  IMailMsgProperties *pMsg, 
							CNewsGroupCore *pGroup, 
							ARTICLEID   articleId,
							HANDLE       hToken,
                            char*       pszApprovedHeader );

	virtual void CommitPostToStores(CPostContext *pContext,
	                        CNntpServerInstanceWrapper *pInstance );

    //
    // Cancel an article given the message id
    //
    virtual BOOL fApplyCancelArticle(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
			CNntpReturn & nntpReturn
			)
	{
		return fApplyCancelArticleInternal( pInstance, pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, FALSE, nntpReturn );
	}

    //
    // Add a new newsgroup in response to a newgroup control message
    //
    virtual BOOL fApplyNewgroup(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
			BOOL fAnonymous,
            CPCString & pcValue,
            CPCString & pcBody,
			CNntpReturn & nntpReturn
			)
	{
		BOOL fRet ;
		pInstance->EnterNewsgroupCritSec() ;
		fRet = fApplyNewgroupInternal( pInstance, pSecurityCtx, pEncryptCtx, fAnonymous, pcValue, pcBody, FALSE, nntpReturn );
		pInstance->LeaveNewsgroupCritSec() ;
		return fRet ;
	}

    //
    // Remove a newsgroup in response to a rmgroup control message
    //
    virtual BOOL fApplyRmgroup(
			CNntpServerInstanceWrapper * pInstance,
			CSecurityCtx *pSecurityCtx,
			CEncryptCtx *pEncryptCtx,
            CPCString & pcValue,
			CNntpReturn & nntpReturn
			)
	{
		BOOL fRet ;
		pInstance->EnterNewsgroupCritSec();
		fRet = fApplyRmgroupInternal( pInstance, pSecurityCtx, pEncryptCtx, pcValue, FALSE, nntpReturn );
		pInstance->LeaveNewsgroupCritSec() ;
		return fRet ;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\seostrm.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	stream.h

Abstract:

	This module contains the definition for the Server
	Extension Object Stream class.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/29/97	created

--*/


// stream.h : Declaration of the CSEOStream

/////////////////////////////////////////////////////////////////////////////
// CStream
class /* ATL_NO_VTABLE */ CSEOStream : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IStream
//	, public CComCoClass<CSEOStream, &CLSID_CSEOStream>
{
	public:

		CSEOStream()
		{
			m_hFile = NULL;
			m_pszFile = NULL;
			m_hEvent = NULL;
			m_pSubStream = NULL;
			m_cRef = 0;
		}

		~CSEOStream()
		{
			Cleanup();
		}

		// IUnknown 
		STDMETHODIMP QueryInterface(REFIID, void**);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);

		// HRESULT FinalConstruct();
		// void FinalRelease();
		void Cleanup();
		HRESULT Init(HANDLE hFile, LPCSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Init(HANDLE hFile, LPCWSTR pszFile, ULARGE_INTEGER libOffset, CSEOStream *pSubStream);
		HRESULT Open();
		HRESULT ReadOffset(void *pv, ULONG cb, ULONG *pcbRead, ULARGE_INTEGER *plibOffset);
		HRESULT WriteOffset(void const* pv, ULONG cb, ULONG *pcbWritten, ULARGE_INTEGER *plibOffset);
		HRESULT GetSize(ULARGE_INTEGER *plibSize);
		HRESULT CopyToOffset(IStream *pstm, ULARGE_INTEGER libOffset, ULARGE_INTEGER *plibRead, ULARGE_INTEGER *plibWritten, ULARGE_INTEGER *plibOffset);
		HRESULT CloneOffset(IStream **pstm, ULARGE_INTEGER libOffset);

	// DECLARE_PROTECT_FINAL_CONSTRUCT();

	/*
	DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx,
								   L"SEOStream Class",
								   L"SEO.Stream.1",
								   L"SEO.Stream");

	DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CSEOStream)
		COM_INTERFACE_ENTRY(IStream)
		// COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()
	*/

	// IStream
	public:
		HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);
		HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG *pcbWritten);
		HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *pdlibNewPosition);
		HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize);
		HRESULT STDMETHODCALLTYPE CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
		HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags);
		HRESULT STDMETHODCALLTYPE Revert(void);
		HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
		HRESULT STDMETHODCALLTYPE Stat(STATSTG * pstatstg, DWORD grfStatFlag);
		HRESULT STDMETHODCALLTYPE Clone(IStream **pstm);
 
	private:
		HANDLE m_hFile;
		LPSTR m_pszFile;
		ULARGE_INTEGER m_libOffset;
		HANDLE m_hEvent;
		CSEOStream *m_pSubStream;

		long	m_cRef;
		// CComPtr<IUnknown> m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\props.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	props.h

Abstract:

	This module contains the definition of the property search class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	07/05/97	created

--*/

#ifndef _PROPS_H_
#define _PROPS_H_

// Define a generic accessor function to access properties
typedef HRESULT (*GET_ACCESSOR_FUNCTION)(	LPSTR	pszName, 
											LPVOID	pContext, 
											LPVOID	pCacheData,
											LPVOID	pvBuffer, 
											LPDWORD	pdwBufferLen);

typedef HRESULT (*SET_ACCESSOR_FUNCTION)(	LPSTR	pszName, 
											LPVOID	pContext,
											LPVOID	pCacheData, 
											LPVOID	pvBuffer, 
											DWORD	dwBufferLen,
											DWORD	ptPropertyType);

typedef HRESULT (*COMMIT_ACCESSOR_FUNCTION)(LPSTR	pszName, 
											LPVOID	pContext, 
											LPVOID	pCacheData);

typedef HRESULT (*INVALIDATE_ACCESSOR_FUNCTION)(LPSTR	pszName, 
											LPVOID	pCacheData,
											DWORD	ptPropertyType);

// Define the property item structure. We can hash this if
// we want in the future
typedef struct _PROPERTY_ITEM
{
	// the name of the property
	LPSTR							pszName;
	// how many characters of the name we care about for comparisons.  set
	// to 0 to require a full comparison.  this is useful for property
	// families where you want a bunch of properties to use the same
	// accessor functions.
	DWORD							cCharsToCompare;
	// the type of the property.  a list of possibilities is below
	DWORD							ptBaseType;
	// access control for this property
	DWORD							fAccess;
	// the context for this item
	LPVOID							pContext;
	// the cache data for this property for this item
	LPVOID							pCacheData;
	// the function that implements Get
	GET_ACCESSOR_FUNCTION			pfnGetAccessor;
	// the function that implements Set
	SET_ACCESSOR_FUNCTION			pfnSetAccessor;
	// the function that implements Commit
	COMMIT_ACCESSOR_FUNCTION		pfnCommitAccessor;
	// the function that implements Invalidate
	INVALIDATE_ACCESSOR_FUNCTION	pfnInvalidateAccessor;
} PROPERTY_ITEM, *LPPROPERTY_ITEM;

// Define a property context
typedef struct _PROP_CTXT
{
	LPPROPERTY_ITEM	pItem;
	BOOL			fIsWideStr;

} PROP_CTXT, *LPPROP_CTXT;

// =================================================================
// Definition of an in-house string structure
//
typedef struct _STRING_ATTR
{
	LPSTR	pszValue;
	DWORD	dwMaxLen;

} STRING_ATTR, *LPSTRING_ATTR;

// Enumerated types representing type of access on property
typedef enum _PROPERTY_ACCESS
{
	PA_READ = 1,
	PA_WRITE = 2,
	PA_READ_WRITE = 3

} _PROPERTY_ACCESS;

// Enumerated types representing property types
typedef enum _PROPERTY_TYPES
{
	PT_NONE = 0,
	PT_STRING,
	PT_DWORD,
	PT_INTERFACE,
	PT_MAXPT

} PROPERTY_TYPES;

class CPropertyValue {
	public:
		CPropertyValue() {
			m_dwSignature = (DWORD) ' rPC';
			m_fChanged = FALSE;
		}

		~CPropertyValue() {
			Validate();
			Invalidate();
		}

		// is its changed flag set?
		BOOL HasChanged() {
			Validate();
			return m_fChanged;
		}

		// invalidate the data
		virtual void Invalidate() {
			Validate();
			m_fChanged = FALSE;
		}

		// internally check the data
		virtual void Validate() {
			_ASSERT(m_fChanged == FALSE || m_fChanged == TRUE);
		}

		// set the changed flag
		void SetChanged(BOOL fChanged) {
#ifdef DEBUG
			if (fChanged) m_fChanged = TRUE; else m_fChanged = FALSE;
#else
			m_fChanged = fChanged;
#endif
		}

	protected:
		DWORD	m_dwSignature;
		BOOL	m_fChanged;
};

class CPropertyValueString : public CPropertyValue {
	public:
		CPropertyValueString() { 
			m_dwSignature = (DWORD) 'SrPC';
			m_pszValue = NULL; 
			m_dwLength = 0;
			m_dwMaxLen = 0; 
		}
	
		HRESULT Set(LPSTR szSource, BOOL fChanged = FALSE, 
					DWORD dwLength = (DWORD) -1) 
		{
			Validate();

			if (szSource == NULL) Invalidate();
			if (dwLength == (DWORD) -1) {
                dwLength = lstrlenA(szSource) + 1;
            }
			if (dwLength > m_dwMaxLen) {
				Invalidate();
				m_pszValue = XNEW char[dwLength];
				if (m_pszValue == NULL) return E_OUTOFMEMORY;
				m_dwMaxLen = dwLength;
			}
			m_dwLength = dwLength;
			memcpy(m_pszValue, szSource, dwLength);
			SetChanged(fChanged);

			Validate();
			return S_OK;
		}

		LPSTR Get(DWORD *pcValue = NULL) {
			Validate();
			if (pcValue != NULL) *pcValue = m_dwLength;
			return m_pszValue;
		}

		DWORD IsValid(void) {
			CPropertyValue::Validate();
			Validate();
			return (m_pszValue != NULL);
		}

		void Invalidate() {
			CPropertyValue::Invalidate();
			if (m_pszValue) XDELETE[] m_pszValue;
			m_pszValue = NULL; 
			m_dwLength = 0;
			m_dwMaxLen = 0;
		}

#ifdef DEBUG
		void Validate() {
			CPropertyValue::Validate();
			_ASSERT(m_pszValue == NULL || m_dwLength >= 0);
			_ASSERT(m_dwMaxLen >= m_dwLength);
		}
#else
		void Validate() {}
#endif

	private:
		LPSTR	m_pszValue;
		DWORD	m_dwLength;
		DWORD	m_dwMaxLen;
};

class CPropertyValueDWORD : public CPropertyValue {
	public:
		CPropertyValueDWORD() { 
			m_dwSignature = (DWORD) 'DrPC';
			m_dwValue = 0; 
			m_fInit = FALSE;
		}

		HRESULT Set(DWORD dwValue, BOOL fChanged) {
			Validate();
			m_dwValue = dwValue;
			m_fInit = TRUE;
			SetChanged(fChanged);

			return S_OK;
		}

		DWORD Get(void) {
			Validate();
			return m_dwValue;
		}

		DWORD IsValid(void) {
			Validate();
			return m_fInit;
		}

		void Invalidate()
		{
			CPropertyValue::Invalidate();
			m_fInit = FALSE;
			m_dwValue = 0;
		}

#ifdef DEBUG
		void Validate() {
			CPropertyValue::Validate();
			// if not init then m_dwValue should be 0
			_ASSERT(m_fInit || m_dwValue == 0);
			// only these constants should be used
			_ASSERT(m_fInit == FALSE || m_fInit == TRUE);
		}
#else
		void Validate() {}
#endif

	private:
		DWORD	m_dwValue;
		BOOL	m_fInit;
};

class CPropertyValueInterface : public CPropertyValue {
	public:
		CPropertyValueInterface() { 
			m_dwSignature = (DWORD) 'IrPC';
			m_pInterface = NULL; 
		}

		HRESULT Set(IUnknown *pInterface, BOOL fChanged) {
			Validate();
			m_pInterface = pInterface;
			SetChanged(fChanged);

			return S_OK;
		}

		IUnknown *Get(void) {
			Validate();
			// add a reference, since the receiver will Release this.
			m_pInterface->AddRef();
			return m_pInterface;
		}

		DWORD IsValid(void) {
			Validate();
			return (m_pInterface != NULL);
		}

		void Invalidate()
		{
			CPropertyValue::Invalidate();
			if (m_pInterface != NULL) m_pInterface->Release();
			m_pInterface = NULL;
		}

#ifdef DEBUG
		void Validate() {
			CPropertyValue::Validate();
			if (m_fChanged) _ASSERT(m_pInterface != NULL);
		}
#else
		void Validate() {}
#endif

	private:
		IUnknown *m_pInterface;
};

// Size of default scratch buffer
#define DEFAULT_SCRATCH_BUFFER_SIZE		1024

// =================================================================
// class for searching properties
//
class CPropertyTable
{
  public:

	CPropertyTable(	LPPROPERTY_ITEM	pProperties,
					DWORD			dwcProperties) :
		m_pProperties(pProperties),
		m_dwProperties(dwcProperties)
	{
		// Set up the default scratch pad
		m_szBuffer = m_rgcBuffer;
		m_cBuffer = DEFAULT_SCRATCH_BUFFER_SIZE;
	}

	~CPropertyTable()
	{
		// Wipe out members
		m_pProperties = NULL;
		m_dwProperties = 0;

		// Free the scratch buffer, if not equal to default
		if (m_szBuffer != m_rgcBuffer)
		{
			LocalFree((HLOCAL)m_szBuffer);
		}
	}

	// Method to get the property type given the property name
	HRESULT GetPropertyType(LPCSTR	szPropertyName,
						LPDWORD		pptPropertyType,
						LPPROP_CTXT	pPropertyContext);

#if 0
	HRESULT GetPropertyType(LPCWSTR	wszPropertyName,
						LPDWORD		pptPropertyType,
						LPPROP_CTXT	pPropertyContext);
#endif

	// Method to retrieve the associated property item
	HRESULT GetProperty(LPPROP_CTXT	pPropertyContext,
						LPCSTR		pszPropertyName,
						LPVOID		pvBuffer,
						LPDWORD		pdwBufferLen);

#if 0
	// Method to retrieve the associated property item
	HRESULT GetProperty(LPPROP_CTXT	pPropertyContext,
						LPCWSTR		wszPropertyName,
						LPVOID		pvBuffer,
						LPDWORD		pdwBufferLen);
#endif

	// Method to set the associated property item
	HRESULT SetProperty(LPCSTR	szPropertyName,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen,
						DWORD	ptPropertyType);

#if 0
	HRESULT SetProperty(LPCWSTR	wszPropertyName,
						LPVOID	pvBuffer,
						DWORD	dwBufferLen,
						DWORD	ptPropertyType);
#endif

	HRESULT SetProperty(LPCSTR szPropertyname, VARIANT *pvarProperty);
#if 0
	HRESULT SetProperty(LPCWSTR szPropertyname, VARIANT *pvarProperty);
#endif

	// Method to commit all changes. This must be called or
	// all the changes will be lost
	HRESULT CommitChanges();

	// Method to rollback changes to the initial state or the
	// state after the last commit, whichever is more recent
	HRESULT Invalidate();

  private:
  
	// Method to obtain a scratch buffer of the desired size,
	// will allocate new one if insufficient. Size in bytes.
	LPVOID GetScratchBuffer(DWORD dwSizeDesired);

	// Method to search the property table and return the associated
	// property item, if found
	LPPROPERTY_ITEM SearchForProperty(LPCSTR szPropertyName);

	// Pointer to property table and count of items
	LPPROPERTY_ITEM		m_pProperties;
	DWORD				m_dwProperties;

	// Default scratch buffer, used for wide string to LPSTR
	// conversion
	CHAR				m_rgcBuffer[DEFAULT_SCRATCH_BUFFER_SIZE];

	// Pointer to current scratch buffer, will be freed by 
	// destructor if not equal to m_rgcBuffer
	LPSTR				m_szBuffer;
	DWORD				m_cBuffer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\tigdflts.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tigdflts.h

Abstract:

    Defines the defaults for metabase values used by the NNTP service.

    See nntpmeta.h for metabase IDs.
    See the metabase spreadsheet (on \\isbu\tigris) for parameter
    ranges, and descriptions of these properties.

Author:

    Magnus Hedlund (MagnusH)        --

Revision History:

--*/

#ifndef _TIGRIS_DEFAULTS_INCLUDED_
#define _TIGRIS_DEFAULTS_INCLUDED_

#define ONE_K		( 1024 )
#define ONE_MEG		( ONE_K * ONE_K )

#define NNTP_DEF_ARTICLETIMELIMIT		( 1138 )
#define NNTP_DEF_HISTORYEXPIRATION		( 1138 )
#define NNTP_DEF_NEWSCRAWLERTIME		( 1138 )
#define NNTP_DEF_SHUTDOWNLATENCY		( 1138 )

#define NNTP_DEF_HONORCLIENTMSGIDS		( TRUE )
#define NNTP_DEF_DISABLENEWNEWS			( FALSE )
#define NNTP_DEF_COMMANDLOGMASK			( (DWORD) -1 )
#define NNTP_DEF_ALLOWCLIENTPOSTS		( TRUE )
#define NNTP_DEF_ALLOWFEEDPOSTS			( TRUE )
#define NNTP_DEF_ALLOWCONTROLMSGS		( TRUE )

#define NNTP_DEF_CLIENTPOSTSOFTLIMIT	( 1000 * ONE_K )	// In bytes
#define NNTP_DEF_CLIENTPOSTHARDLIMIT	( 20 * ONE_MEG )	// In bytes
#define NNTP_DEF_FEEDPOSTSOFTLIMIT		( 1500 * ONE_K )	// In bytes
#define NNTP_DEF_FEEDPOSTHARDLIMIT		( 40 * ONE_MEG )	// In bytes

#define NNTP_DEF_AUTOSTART				( TRUE )
#define NNTP_DEF_BINDINGS				_T( ":119:\0" )
#define NNTP_DEF_SECUREPORT				( 563 )
#define NNTP_DEF_MAXCONNECTIONS			( 5000 )
#define NNTP_DEF_CONNECTIONTIMEOUT		( 600 )
#define NNTP_DEF_FEED_REPORT_PERIOD		( 60 * 24)			// One hour
#define NNTP_DEF_MAX_SEARCH_RESULTS		( 1000 )
#define NNTP_DEF_CLUSTERENABLED                 ( FALSE )

/*

From nntpstr.cpp:

StrArtMapFile = "nntpfile\\article.hsh";
StrHisMapFile = "nntpfile\\history.hsh";
StrXoverMapFile = "nntpfile\\xover.hsh";
StrGrpHelpFile = "nntpfile\\descrip.txt" ;
StrGrpListFile = "nntpfile\\group.lst" ;
StrDefHashFile = "c:\\hash.hsh";
StrDefListFile = "c:\\listfile.txt";

*/

#define NNTP_DEF_ARTICLETABLEFILE		_T( "nntpfile\\article.hsh" )
#define NNTP_DEF_HISTORYTABLEFILE		_T( "nntpfile\\history.hsh" )
#define NNTP_DEF_XOVERTABLEFILE			_T( "nntpfile\\xover.hsh" )
#define NNTP_DEF_GROUPHELPFILE			_T( "nntpfile\\descrip.txt" )
#define NNTP_DEF_GROUPLISTFILE			_T( "nntpfile\\group.lst" )
#define NNTP_DEF_GROUPVARLISTFILE		_T( "nntpfile\\groupvar.lst" )
#define NNTP_DEF_MODERATORFILE			_T( "nntpfile\\moderatr.txt" )
#define NNTP_DEF_PRETTYNAMESFILE		_T( "nntpfile\\prettynm.txt" )
#define NNTP_DEF_LISTFILE				_T( "nntpfile\\listfile.txt" )
#define NNTP_DEF_DROPDIRECTORY			_T( "nntpfile\\drop" )

#define NNTP_DEF_ANONYMOUSUSERNAME		_T( "" )
#define NNTP_DEF_ANONYMOUSUSERPASS		_T( "" )
#define NNTP_DEF_DEFAULTMODERATORDOMAIN	_T( "" )
#define NNTP_DEF_SMTPSERVER				_T( "" )
#define NNTP_DEF_UUCPNAME				_T( "" )
#define NNTP_DEF_ORGANIZATION			_T( "" )
#define NNTP_DEF_COMMENT				_T( "" )
#define NNTP_DEF_PICKUPDIRECTORY		_T( "" )
#define NNTP_DEF_FAILEDPICKUPDIRECTORY	_T( "" )

#endif /* _TIGRIS_DEFAULTS_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\tigmem.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tigmem.h

Abstract:

    This module contains class declarations/definitions for

		CAllocator


    **** Overview ****

	This defines object that allocates (and deallocates)
	memory from a fixed buffer.

Author:

    Carl Kadie (CarlK)     12-Jan-1995

Revision History:


--*/

#ifndef	_TIGMEM_H_
#define	_TIGMEM_H_



class	CAllocator	{
private : 

	//
	//
	//


	char * m_pchPrivateBytes;


	DWORD m_cchMaxPrivateBytes;

	//
	// The offset to the next place to allocate from
	//

	DWORD	m_ichLastAlloc ;

	//
	// The number of allocations at the current moment
	//

	DWORD	m_cNumberOfAllocs ;

	//
	//!!! next could add this stuff
	//

#ifdef	DEBUG
	DWORD	m_cbAllocated ;

	static	DWORD	m_cbMaxBytesEver ;
	static	DWORD	m_cbAverage ;
	static	DWORD	m_cbStdDeviation ;
#endif

public : 

	CAllocator(
					   char * rgchBuffer,
					   DWORD cchMaxPrivateBytes
					   ):
		m_cNumberOfAllocs(0),
		m_ichLastAlloc(0),
		m_cchMaxPrivateBytes(cchMaxPrivateBytes),
		m_pchPrivateBytes(rgchBuffer)
		{};


	~CAllocator(void);

	DWORD	cNumberOfAllocs(void)
		{ 
			return m_cNumberOfAllocs;
		};

	char*	Alloc( size_t size );

	void	Free( char *pv );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\wildmat.h ===
//---[ wildmat.h ]-------------------------------------------------------------
//
//  Description:
//      Provides support for the "wildmat" wildcard matching standard. Info
//      on this standard comes from the internet draft:
//
//      draft-barber-nntp-imp-03.txt
//      S. Barber
//      April, 1996
//
//  Copyright (C) Microsoft Corp. 1996.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

#ifndef _WILDMAT_H_
#define _WILDMAT_H_

//---[ Prototypes ]------------------------------------------------------------

HRESULT HrMatchWildmat( const char *pszText, const char *pszPattern );

#endif // _WILDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\tigtypes.h ===
/*++

    tigtypes.h

    This file contains the definitions of very basic types
    used within NNTPSVC.

--*/

#ifndef _TIGTYPES_H_
#define _TIGTYPES_H_


typedef DWORD   ARTICLEID ;
typedef DWORD   GROUPID ;
typedef DWORD   SERVERID ;

typedef DWORD   HASH_VALUE ;

#define	INVALID_ARTICLEID	((ARTICLEID)(~0))
#define INVALID_GROUPID     ((GROUPID)(~0))

//	
//	Structure used in some places to describe a article !
//
class   CArticleRef {
public : 
	CArticleRef(GROUPID group=INVALID_GROUPID, ARTICLEID article=INVALID_ARTICLEID):
		m_groupId(group),
		m_articleId(article)
		{};
	LPVOID      m_compareKey;
    GROUPID     m_groupId ;
    ARTICLEID   m_articleId ;
} ;

const CArticleRef NullArticleRef(INVALID_GROUPID, INVALID_ARTICLEID);


//
//
//
// list of posted groups
//
typedef struct _GROUP_ENTRY {

    GROUPID     GroupId;
    ARTICLEID   ArticleId;

} GROUP_ENTRY, *PGROUP_ENTRY;


//
//  This constant is used throughout the server to represent the longest Message Id we will process !
//
#define MAX_MSGID_LEN   255

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\xover.h ===
/*++

  XOVER.H

	This file defines the interfaces used to cache XOVER information.


--*/


#ifndef	_XOVER_H_
#define	_XOVER_H_

#include	"tfdlist.h"

// This callback function is used to issue a stop hint during a
// long spin while shutting down so that the shutdown won't time
// out.
typedef void (*PSTOPHINT_FN)();

//
//	Initialization and termination functions - call before anything else in here !!
//
extern	BOOL	XoverCacheLibraryInit(DWORD cNumXixObjectsPerTable = 0) ;
extern	BOOL	XoverCacheLibraryTerm() ;



//
//	Maximum number of 'handles' we will have open !
//	This refers to the maximum number of CXoverIndex's
//	we will let clients keep open.
//
#ifndef	DEBUG
#define	MAX_HANDLES			512
#else
#define	MAX_HANDLES			32
#endif


class	CXoverIndex ;

//
//	For external users they should treat CXIDXPTR's as handles
//	AND never dereference them !!
//
class	HXOVER	{
private : 
	//
	//	Our friends can access this stuff !
	//
	friend	class	CXoverIndex ;
	friend	class	CXoverCacheImplementation ;

	class	CXoverIndex*	m_pIndex ;
	
	//
	//	Only two mechanisms for setting the CXoverIndex object pointer !
	//
	HXOVER(	class	CXoverIndex*	pIndex ) : 
		m_pIndex( pIndex ) {}

	//
	//	and we will support the assignment operator !
	//
	HXOVER&	operator=( class	CXoverIndex*	pIndex ) ;

	//
	//	let internal users dereference us !
	//
	class	CXoverIndex*	operator->()	const	{	
		return	m_pIndex ;
	}

	//
	//	When we need to call member function pointers use this : 
	//
	class	CXoverIndex*	Pointer()	const	{
		return	m_pIndex ;
	}

	BOOL	operator==(	class	CXoverIndex*	pRight )	const	{
		return	m_pIndex == pRight ;
	}

	BOOL	operator!=(	class	CXoverIndex*	pRight )	const	{
		return	m_pIndex != pRight ;
	}

public : 
	//
	//	Only default constructor is available to external users !
	//
	HXOVER() : m_pIndex( 0 )	{}

	//
	//	outside users don't get to do anything but declare and destroy !
	//
	~HXOVER() ;
} ;


class	CXoverCacheCompletion	{
private : 

	friend	class	CXoverCacheImplementation ;
	friend	class	CXoverIndex ;

	//
	//	this lets us keep track of all of these guys !
	//		
	DLIST_ENTRY		m_list ;

public : 

	//
	//	Helper function for internal use only !
	//
	inline	static
	DLIST_ENTRY*
	PendDLIST(	CXoverCacheCompletion*	p ) {
		return	&p->m_list ;
	}

	typedef		DLIST_ENTRY*	(*PFNDLIST)( class	CXoverCacheCompletion* pComplete ) ; 

	//
	//	Provide the XOVER Cache a way to do the real XOVER operation !
	//
	virtual	
	void
	DoXover(	ARTICLEID	articleIdLow,
				ARTICLEID	articleIdHigh,
				ARTICLEID*	particleIdNext, 
				LPBYTE		lpb, 
				DWORD		cb,
				DWORD*		pcbTransfer, 
				class	CNntpComplete*	pComplete
				) = 0 ;

	//
	//	this function is called when the operation completes !
	//
	virtual
	void
	Complete(	BOOL		fSuccess, 
				DWORD		cbTransferred, 
				ARTICLEID	articleIdNext
				) = 0 ;

	//
	//	Get the arguments for this XOVER operation !
	//
	virtual
	void
	GetArguments(	OUT	ARTICLEID&	articleIdLow, 
					OUT	ARTICLEID&	articleIdHigh,
					OUT	ARTICLEID&	articleIdGroupHigh,
					OUT	LPBYTE&		lpbBuffer, 
					OUT	DWORD&		cbBuffer
					) = 0 ;	

	//
	//	Get only the range of articles requested for this XOVER op !
	//
	virtual
	void
	GetRange(	OUT	GROUPID&	groupId,
				OUT	ARTICLEID&	articleIdLow,
				OUT	ARTICLEID&	articleIdHigh,
				OUT	ARTICLEID&	articleIdGroupHigh
				) = 0 ;

} ;
		


class	CXoverCache	{
public : 

	//
	//	Destructor
	//
	virtual ~CXoverCache() {}

	//
	//	Canonicalize the Article id 
	//
	virtual	ARTICLEID	
	Canonicalize(	
			ARTICLEID	artid 
			) = 0 ;

	//
	//	Initialize the Xover Cache
	//
	virtual	BOOL
	Init(		
#ifndef	DEBUG
		long	cMaxHandles = MAX_HANDLES,
#else
		long	cMaxHandles = 5,
#endif
		PSTOPHINT_FN pfnStopHint = NULL
		) = 0 ;

	//
	//	Shutdown the background thread and kill everything !
	//
	virtual	BOOL
	Term() = 0 ;

#if 0 
	//
	//	Add an Xover entry to the appropriate file !
	//
	virtual	BOOL
	AppendEntry(		
				IN	GROUPID	group,
				IN	LPSTR	szPath,
				IN	ARTICLEID	article,
				IN	LPBYTE	lpbEntry,
				IN	DWORD	Entry
				) = 0 ;
	//
	//	Given a buffer fill it up with the specified xover data !
	//
	virtual	DWORD
	FillBuffer(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	DWORD		groupid,
			IN	LPSTR		szPath,
			IN	BOOL		fFlatDir,
			IN	ARTICLEID	artidStart, 
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast,
			OUT	HXOVER		&hXover
			) = 0 ;

	//
	//	Given a buffer fill it up with the specified 
	//	Listgroup data !
	//
	virtual	DWORD
	ListgroupFillBuffer(	
			IN	BYTE*		lpb,
			IN	DWORD		cb,
			IN	DWORD		groupid,
			IN	LPSTR		szPath,
			IN	BOOL		fFlatDir,
			IN	ARTICLEID	artidStart, 
			IN	ARTICLEID	artidFinish,
			OUT	ARTICLEID	&artidLast,
			OUT	HXOVER		&hXover
			) = 0 ;
#endif

	//
	//	This issues the asynchronous version of the XOVER request !
	//
	virtual	BOOL
	FillBuffer(
			IN	CXoverCacheCompletion*	pRequest,
			IN	LPSTR	szPath, 
			IN	BOOL	fFlatDir, 
			OUT	HXOVER&	hXover
			) = 0 ;	

	//
	//	Dump everything out of the cache !
	//
	virtual	BOOL	
	EmptyCache() = 0 ;

	//
	//	Dump all Cache entries for specified group from the cache !
	//	Note : when articleTop is 0 ALL cache entries are dropped, 
	//	whereas when its something else we will drop only cache entries
	//	which fall below articleTop
	//
	virtual	BOOL	
	FlushGroup(	
			IN	GROUPID	group,
			IN	ARTICLEID	articleTop = 0,
			IN	BOOL	fCheckInUse = TRUE
			) = 0 ;

	//
	//	Delete all Xover index files for the specified group
	//	to the specified article -id
	//
	virtual	BOOL	
	ExpireRange(
			IN	GROUPID	group,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			IN	ARTICLEID	articleLow, 
			IN	ARTICLEID	articleHigh,
			OUT	ARTICLEID&	articleNewLow
			) = 0 ;

	//
	//	Remove an Xover entry !
	//
	virtual	BOOL
	RemoveEntry(
			IN	GROUPID	group,
			IN	LPSTR	szPath,
			IN	BOOL	fFlatDir,
			IN	ARTICLEID	article
			) = 0 ;
	

	//
	//	This function creates an object which implements this interface !!
	//
	static	CXoverCache*	
	CreateXoverCache() ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\watchci.h ===
#ifndef __WATCHCI_H__
#define __WATCHCI_H__

//
// this the function prototype for the callback function.  
//
// this is called during ReadCIRegistry() and CheckForChanges() as follows:
// If there are registry changes then:
//	 fn(WATCHCI_FIRST_CHANGE, NULL)
//   for (each catalog that is tied to an nntp instance)
//		fn(nntp instance, catalog path)
//   end
//   fn(WATCHCI_LAST_CHANGE, NULL)
//
// if there are no registry changes then nothing is called.
//
// the first call to the callback is used to clear any state information
// that service has about tripoli catalogs (so that if an nntp instance
// isn't being indexed anymore it won't try and call against old catalogs)
//
typedef void (*PWATCHCI_NOT_FN)(DWORD iNNTPInstance, WCHAR *pwszCatalog);
#define WATCHCI_FIRST_CHANGE 0x0
#define WATCHCI_LAST_CHANGE 0xffffffff

struct CCIRoot {
	CCIRoot *m_pNext;
	CCIRoot *m_pPrev;
	DWORD m_dwInstance;
	WCHAR *m_pwszPath;

	CCIRoot(DWORD dwInstance, WCHAR *pwszPath) : 
		m_pNext(NULL), m_pPrev(NULL), 
		m_dwInstance(dwInstance), m_pwszPath(pwszPath) {
	}

	~CCIRoot() {}
};


class CWatchCIRoots {
	public:
		CWatchCIRoots();
		// pszCIRoots is the path in the registry where Tripoli stores
		// its information.
		// it is probably TEXT("System\CurrentControlSet\ContentIndex")
		HRESULT	Initialize(WCHAR *pwszCIRoots);
		HRESULT Terminate();
		HRESULT CheckForChanges(DWORD dwTimeout = 0);
		HRESULT GetCatalogName(DWORD dwInstance, DWORD cbSize, WCHAR *pwszBuffer);
		~CWatchCIRoots();

	private:
		HANDLE m_heRegNot;		// event handle triggered when registry changes
		HKEY m_hkCI;			// registry handle to tripoli
		TFList<CCIRoot> m_CIRootList;
		CShareLockNH m_Lock;
		long m_dwUpdateLock;
		DWORD m_dwTicksLastUpdate;

		HRESULT QueryCIValue(HKEY hkPrimary, HKEY hkSecondary, 
							 LPCTSTR szValueName, LPDWORD pResultType,
							 LPBYTE pbResult, LPDWORD pcbResult);
		HRESULT QueryCIValueDW(HKEY hkPrimary, HKEY hkSecondary, 
		                       LPCTSTR szValueName, LPDWORD pdwResult);
		HRESULT QueryCIValueSTR(HKEY hkPrimary, HKEY hkSecondary, 
								LPCTSTR szValueName, LPCTSTR pszResult,
								PDWORD pchResult);
		HRESULT ReadCIRegistry(void);
		void UpdateCatalogInfo(void);
		void EmptyList();
};

#define REGCI_CATALOGS TEXT("Catalogs")
#define REGCI_ISINDEXED TEXT("IsIndexingNNTPSvc")
#define REGCI_LOCATION TEXT("Location")
#define REGCI_NNTPINSTANCE TEXT("NNTPSvcInstance")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\include\timeconv.h ===
/*-------------------------------------------------------------------------
  timeconv.h
  	Function prototypes for time conversion functions.
  

  Copyright (C) 1994  Microsoft Corporation.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:08 on Wed 20 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	First version, now that there are 2 time functions!

  --------------------------------------------------------------------------*/

#if  !defined( _TIMECONV_H )

#define	_TIMECONV_H


/*
 *  Convert an ARPA/Internet time/date string to time_t format.  Used when
 *  generating the index data for Usenet news feed.
 */

DWORD   dwConvertAsciiTime( char * );


const DWORD cMaxArpaDate = 33;
/*
 *  Generate an ARPA/Internet time format string for current time.
 *  You must pass in a buffer of type char [cMaxArpaDate]
 */

char  *
GetArpaDate( char rgBuf[ cMaxArpaDate ] );

const DWORD cMaxMessageIDDate = 12;	// (64 / 6) + 2
/*
 *  Generate a time format string for current time that
 *  can be used to generate part of a message id.
 *  You must pass in a buffer of type char [cMaxMessageIDDate]
 */

char  *
GetMessageIDDate( DWORD GroupId, DWORD ArticleId, char rgBuf[ cMaxMessageIDDate ] );

/*
 *  Convert a structure of type SYSTEMTIME to a time_t value.
 *  Returns 0 if the date is before 1970.
 */

time_t SystemTimeToTime_T(SYSTEMTIME & st);

/*
 *  Convert from a time_t value to a structure of type SYSTEMTIME to a time_t value.
 */

void Time_TToSystemTime(time_t tt, SYSTEMTIME & st);

/*
 *  Generate an ARPA/Internet time format string a time_t or FILETIME input.
 */

char * Time_TToArpaDate( time_t tt, char * achReturn );
char  * FileTimeToArpaDate(const FILETIME & ft, char * achReturn );
char  * FileTimeToLocalArpaDate(const FILETIME & ft, char * achReturn );
char  * FileTimeToLocalArpaDateEx(const FILETIME & ft, char * achReturn );


/*
 * Convert between changes in FILETIMEs and changes in time_t's (and visa versa)
 */

FILETIME dFiletimeFromDTime_t(time_t tt);
time_t dTime_tFromDFiletime(const FILETIME & li);

/*
 * Return the current time in FILETIME or time_t formats
 */

void vFiletimeCurrent(FILETIME & ft);
time_t time_tCurrent();

/*
 *   Add, Subtract, and Compare FILETIMES
 */

FILETIME filetimeAdd(const FILETIME & ft1, const FILETIME & ft2);
FILETIME filetimeSubtract(const FILETIME & ft1, const FILETIME & ft2);
BOOL filetimeGreaterThan(const FILETIME & ft1, const FILETIME & ft2);

#endif		// _TIMECONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\propbag\utest\testprop.cpp ===
// Utest program for property bag
#include <windows.h>
#include <dbgtrace.h>
#include <stdio.h>
#include <stdlib.h>
#include <propbag.h>

#define KEY_TOTALPROPS "TotalProps"
#define KEY_LOOP "loop"
#define KEY_MAXSTRING "MaxString"

DWORD g_cTestProperties;	// total test properties
DWORD g_cMaxStringLen;	// max string length
DWORD g_cLoop;

CPropBag	*g_pPropBag;

struct PROPERTY {
	DWORD dwPropId;
	enum TYPE {
		Bool = 0,
		Dword,
		Blob
	} type;
	union DATA {
		BOOL bProp;
		DWORD dwProp;
		PBYTE pbProp;
	} prop;
	DWORD cString;
};

PROPERTY *g_pPropList = 0;

// Function to generate random properties
VOID GenTestProps( BOOL bChangeType )
{
	PROPERTY::TYPE type;
	BOOL	cStringLen;
	DWORD 	j;

	// assign properties randomly
	for ( DWORD i = 0;i < g_cTestProperties; i++ ) {

		// assign propert id
		g_pPropList[i].dwPropId = i;

		// assign type
		if ( bChangeType ) {
			type = PROPERTY::TYPE(rand() % 3);
			g_pPropList[i].type = type;
		} else type = g_pPropList[i].type;

		// assign value
		switch( type ) {
			case PROPERTY::Bool:
				g_pPropList[i].prop.bProp = rand() % 2;
				break;
			case PROPERTY::Dword:
				g_pPropList[i].prop.dwProp = rand();
				break;
			case PROPERTY::Blob:
				// gen string len
				cStringLen = rand() % g_cMaxStringLen;
				// I don't allow empty strings
				if ( cStringLen == 0 ) cStringLen = 1;
				if ( !bChangeType ) {
					_ASSERT( g_pPropList[i].prop.pbProp );
					delete[] g_pPropList[i].prop.pbProp;
				}
				g_pPropList[i].prop.pbProp = new BYTE[cStringLen+1];
				//write cStringLen 'a' into it
				for ( j = 0; j < (DWORD)cStringLen; j++ )
					g_pPropList[i].prop.pbProp[j] = 'a';
				g_pPropList[i].prop.pbProp[cStringLen] = 0;
				// assign string len
				g_pPropList[i].cString = cStringLen;
				break;
			default:
				_ASSERT( FALSE );
		}
	}
}

VOID InsertProperties( BOOL bSecondRound )
{
	HRESULT hr;

	for ( DWORD i = 0; i < g_cTestProperties; i++ ) {
		switch( g_pPropList[i].type ) {
			case PROPERTY::Bool:
				hr = g_pPropBag->PutBool( 	g_pPropList[i].dwPropId,
											g_pPropList[i].prop.bProp );
				break;
			case PROPERTY::Dword:
				hr = g_pPropBag->PutDWord( 	g_pPropList[i].dwPropId,
											g_pPropList[i].prop.dwProp );
				break;
			case PROPERTY::Blob:
				hr = g_pPropBag->PutBLOB(	g_pPropList[i].dwPropId,
										g_pPropList[i].prop.pbProp,
										g_pPropList[i].cString );
				break;
		}
		if ( !bSecondRound ) _ASSERT( S_FALSE == hr ); 	// shouldn't have existed
		else _ASSERT( S_OK == hr );
	}
}

VOID
Verify()
{
	DWORD i;
	HRESULT hr;
	DWORD dwVal;
	BOOL bVal;
	PBYTE pbBuffer;
	DWORD dwLen = g_cMaxStringLen;

	// allocate string buffer
	pbBuffer = new BYTE[g_cMaxStringLen+1];

	for ( i = 0; i < g_cTestProperties; i++ ) {
		switch( g_pPropList[i].type ) {
			case PROPERTY::Dword:
				hr = g_pPropBag->GetDWord( 	g_pPropList[i].dwPropId,
											&dwVal );
				_ASSERT( S_OK == hr );
				_ASSERT( dwVal == g_pPropList[i].prop.dwProp );
				break;
			case PROPERTY::Bool:
				hr = g_pPropBag->GetBool(	g_pPropList[i].dwPropId,
										&bVal );
				_ASSERT( S_OK == hr );
				_ASSERT( bVal == g_pPropList[i].prop.bProp );
				break;
			case PROPERTY::Blob:
				dwLen = g_cMaxStringLen;
				hr = g_pPropBag->GetBLOB( g_pPropList[i].dwPropId,
										pbBuffer,
										&dwLen );
				_ASSERT( S_OK == hr );
				_ASSERT( dwLen == g_pPropList[i].cString );
				*(pbBuffer+dwLen) = 0;
				_ASSERT( strcmp( LPCSTR(pbBuffer), LPCSTR(g_pPropList[i].prop.pbProp) ) == 0 );
				break;
		}
	}

	delete[] pbBuffer;
}

VOID
ClearList()
{
	for( DWORD i = 0; i < g_cTestProperties; i++ ) {
		_ASSERT( S_OK == g_pPropBag->RemoveProperty( g_pPropList[i].dwPropId ) );
		if ( g_pPropList[i].type == PROPERTY::Blob ) {
			_ASSERT( g_pPropList[i].prop.pbProp );
			delete[] g_pPropList[i].prop.pbProp;
		}
	}

	delete[] g_pPropList;
}

VOID ReadINI( LPSTR szINIFile, LPSTR szSectionName )
{

	// read max properties to test against
	g_cTestProperties = GetPrivateProfileInt( 	szSectionName,												KEY_TOTALPROPS,
												1000,
												szINIFile );
	_ASSERT( g_cTestProperties > 0 );

	// read loop number
	g_cLoop = GetPrivateProfileInt( 	szSectionName,										KEY_LOOP,
										1,
										szINIFile );
	g_cMaxStringLen = GetPrivateProfileInt( 	szSectionName,												KEY_MAXSTRING,
												256,
												szINIFile );
	_ASSERT( g_cMaxStringLen > 0 );
}

int __cdecl main( int argc, char ** argv )
{

	if ( argc != 3 ) {
		printf( "testprop <INI FILE> <SECTION NAME>\n" );
		exit( 1 );
	}

    _VERIFY( ExchMHeapCreate( NUM_EXCHMEM_HEAPS, 0, 100 * 1024, 0 ) );
	ReadINI( argv[1], argv[2] );

    g_pPropBag = new CPropBag;
    _ASSERT( g_pPropBag );

	for ( DWORD i = 0; i < g_cLoop; i++ ) {

		// allocate an array of  properties, randomly
		g_pPropList = new PROPERTY[g_cTestProperties];
		if ( !g_pPropList ) {
			printf( "Out of memory\n" );
            delete( g_pPropBag );
            _VERIFY( ExchMHeapDestroy() );
			exit( 1 );
		}
		GenTestProps( TRUE );
		InsertProperties( FALSE );
		Verify();
		GenTestProps( FALSE );
		InsertProperties( TRUE );
		Verify();
		ClearList();
	}

    delete g_pPropBag;
    _VERIFY( ExchMHeapDestroy() );
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\propbag\src\propbag.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	propbag.cpp

Abstract:

	This module contains the implementation of the property bag class.  
	Property bag is a dynamically extendable container for different
	types of properties.  

	It's not MT safe.  Proper synchronization should be done at a 
	higher level.

Author:

	Kangrong Yan ( KangYan )
	
Revision History:

	kangyan	05/31/98	created

--*/
#include <propbag.h>
#include <randfail.h>

// Constructor, destructor
CPropBag::CPropBag( int cInitialSize,	int cIncrement )
{
	_ASSERT( cInitialSize > 0 );
	_ASSERT( cIncrement > 0 );

	BOOL bSuccess;
	
	m_hr = S_OK;

	// Initialize the property hash table
	bSuccess = m_ptTable.Init(	&CProperty::m_pNext,
								cInitialSize,
								cIncrement,
								CProperty::HashFunc,
                                2,
                                CProperty::GetKey,
                                CProperty::MatchKey );
	_ASSERT( bSuccess );
	if ( !bSuccess ) {
	    if ( NO_ERROR != GetLastError() )
	        m_hr = HRESULT_FROM_WIN32( GetLastError() );
	    else m_hr = E_OUTOFMEMORY;
	}
}

CPropBag::~CPropBag()
{}

HRESULT
CPropBag::PutDWord( DWORD dwPropId, DWORD dwVal )
/*++
Routine Description:

	Set DWORD in the property bag.

Arguments:

	DWORD dwPropId - Property Id
	DWORD dwVal - Value to be set

Return value:

	S_OK - Success and property already exists
	S_FALSE - Success but property didn't exist 
--*/
{
	TraceQuietEnter( "CPropBag::PutDWord" );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ExclusiveLock();

	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( pprProp ) {	// Found, so set it
		_ASSERT( CProperty::Dword == pprProp->m_type );
		pprProp->Validate();
		_ASSERT( dwPropId == pprProp->m_dwPropId );
		if( CProperty::Dword == pprProp->m_type ) {
			hr = S_OK;
			(pprProp->m_prop).dwProp = dwVal;
		} else {
			hr = E_INVALIDARG;
			goto Exit;
		}
	} else { 	// we need to insert an entry
		hr = S_FALSE;
		pprProp = XNEW CProperty;
		if ( !pprProp ) {
			FatalTrace( 0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		pprProp->m_dwPropId = dwPropId;
		pprProp->m_type = CProperty::Dword;
		(pprProp->m_prop).dwProp = dwVal;

		if ( NULL == m_ptTable.InsertDataHash( dwPropId, *pprProp ) ) {
			ErrorTrace( 0, "Insert hash failed %d", GetLastError() );
			hr = HRESULT_FROM_WIN32( GetLastError() );
		}
	}

Exit:

    m_Lock.ExclusiveUnlock();
	return hr;
}

HRESULT
CPropBag::GetDWord( DWORD dwPropId, PDWORD pdwVal )
/*++
Routine Description:

	Get DWORD from the property bag.

Arguments:

	DWORD dwPropId - Property Id
	PDWORD pdwVal - Buffer to set the value
	
Return value:

	S_OK - Success and property already exists
	E_INVALIDARG - if the property doesn't exist
--*/
{
	TraceQuietEnter( "CPropBag::GetDWord" );
	_ASSERT( pdwVal );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ShareLock();

	// Search for the entry in the hash table
	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( NULL == pprProp ) {	// doesn't exist
		DebugTrace( 0, "Property deosn't exist" );
		hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
		goto Exit;
	}

	// Retrieve value
	pprProp->Validate();
	_ASSERT( pprProp->m_type == CProperty::Dword );
	*pdwVal = (pprProp->m_prop).dwProp;
	
Exit:

    m_Lock.ShareUnlock();
	return hr;
}

HRESULT
CPropBag::PutBool( DWORD dwPropId, BOOL bVal )
/*++
Routine Description:

	Set a boolean in the property bag.

Arguments:

	DWORD dwPropId - Property Id
	BOOL bVal - The boolean value to be set
	
Return value:

	S_OK - Success and property already exists
	S_FALSE - Success but property didn't exist 
--*/
{
	TraceQuietEnter( "CPropBag::PutBool" );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ExclusiveLock();

	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( pprProp ) {	// Found, so set it
		_ASSERT( CProperty::Bool == pprProp->m_type );
		_ASSERT( dwPropId == pprProp->m_dwPropId );
		if( CProperty::Bool == pprProp->m_type ) {
			hr = S_OK;
			(pprProp->m_prop).bProp = bVal;
		} else {
			hr = E_INVALIDARG;
			goto Exit;
		}
	} else { 	// we need to insert an entry
		hr = S_FALSE;
		pprProp = XNEW CProperty;
		if ( !pprProp ) {
			FatalTrace( 0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		pprProp->m_dwPropId = dwPropId;
		pprProp->m_type = CProperty::Bool;
		(pprProp->m_prop).bProp = bVal;

		if ( NULL == m_ptTable.InsertDataHash( dwPropId, *pprProp ) ) {
			ErrorTrace( 0, "Insert hash failed %d", GetLastError() );
			hr = HRESULT_FROM_WIN32( GetLastError() );
		}
	}

Exit:

    m_Lock.ExclusiveUnlock();
	return hr;
}

HRESULT
CPropBag::GetBool( DWORD dwPropId, PBOOL pbVal )
/*++
Routine Description:

	Get boolean from the property bag.

Arguments:

	DWORD dwPropId - Property Id
	pbVal - Buffer to set the value
	
Return value:

	S_OK - Success and property already exists
	E_INVALIDARG - if the property doesn't exist
--*/
{
	TraceQuietEnter( "CPropBag::GetBool" );
	_ASSERT( pbVal );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ShareLock();

	// Search for the entry in the hash table
	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( NULL == pprProp ) {	// doesn't exist
		DebugTrace( 0, "Property deosn't exist" );
		hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
		goto Exit;
	}

	// Retrieve value
	pprProp->Validate();
	_ASSERT( pprProp->m_type == CProperty::Bool );
	*pbVal = (pprProp->m_prop).bProp;
	
Exit:

    m_Lock.ShareUnlock();
	return hr;
}

HRESULT
CPropBag::PutBLOB( DWORD dwPropId, PBYTE pbVal, DWORD cbVal )
/*++
Routine Description:

	Set a blob in the property bag.

Arguments:

	DWORD dwPropId - Property Id
	PBYTE pbVal - Pointer to the blob
	DWORD cbVal - length of the blob
	
Return value:

	S_OK - Success and property already exists
	S_FALSE - Success but property didn't exist 
--*/
{
	TraceQuietEnter( "CPropBag::PutBLOB" );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

    m_Lock.ExclusiveLock();	

	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( pprProp ) {	// Found, so set it
		_ASSERT( CProperty::Blob == pprProp->m_type );
		pprProp->Validate();
		_ASSERT( dwPropId == pprProp->m_dwPropId );

		if ( CProperty::Blob != pprProp->m_type ) {
			hr = E_INVALIDARG;
			goto Exit;
		}
		
		if ( pprProp->m_cbProp < cbVal ) { // can not use the old buffer
			XDELETE[] (pprProp->m_prop).pbProp;
			(pprProp->m_prop).pbProp = XNEW BYTE[cbVal];
			if ( NULL == (pprProp->m_prop).pbProp ) {
				ErrorTrace( 0, "Out of memory" );
				hr = E_OUTOFMEMORY;
				goto Exit;
			} 
		}
			// Copy the content over
		CopyMemory( (pprProp->m_prop).pbProp, pbVal, cbVal );
		pprProp->m_cbProp = cbVal;
	} else { 	// we need to insert an entry
		hr = S_FALSE;
		pprProp = XNEW CProperty;
		if ( !pprProp ) {
			FatalTrace( 0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		pprProp->m_dwPropId = dwPropId;
		pprProp->m_type = CProperty::Blob;
		(pprProp->m_prop).pbProp = XNEW BYTE[cbVal];
		if ((pprProp->m_prop).pbProp == NULL) {
		    XDELETE pprProp;
			FatalTrace( 0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		CopyMemory( (pprProp->m_prop).pbProp, pbVal, cbVal );
		pprProp->m_cbProp = cbVal;

		if ( NULL == m_ptTable.InsertDataHash( dwPropId, *pprProp ) ) {
			ErrorTrace( 0, "Insert hash failed %d", GetLastError() );
			hr = HRESULT_FROM_WIN32( GetLastError() );
		}
	}

Exit:

    m_Lock.ExclusiveUnlock();
	return hr;
}

HRESULT
CPropBag::GetBLOB( DWORD dwPropId, PBYTE pbVal, PDWORD pcbVal )
/*++
Routine Description:

	Get boolean from the property bag.

Arguments:

	DWORD dwPropId - Property Id
	pbVal - Buffer to Get the value
	pcbVal - IN: buffer size; OUT: actual length
	
Return value:

	S_OK - Success and property already exists
	E_INVALIDARG - if the property doesn't exist
	TYPE_E_BUFFERTOOSMALL - The buffer is not big enough
--*/
{
	TraceQuietEnter( "CPropBag::GetBLOB" );
	_ASSERT( pbVal );
	_ASSERT( pcbVal );

	CProperty *pprProp = NULL;
	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ShareLock();

	// Search for the entry in the hash table
	pprProp = m_ptTable.SearchKeyHash( dwPropId, dwPropId );
	if ( NULL == pprProp ) {	// doesn't exist
		DebugTrace( 0, "Property doesn't exist" );
		hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
		goto Exit;
	}

	// Retrieve value
	pprProp->Validate();
	_ASSERT( pprProp->m_type == CProperty::Blob );

	// check if buffer large enough
	if ( *pcbVal < pprProp->m_cbProp ) {
		DebugTrace( 0, "Property Buffer not large enough" );
		*pcbVal = pprProp->m_cbProp;
		hr = TYPE_E_BUFFERTOOSMALL;
		goto Exit;
	}

	// now large enough, do the copy
	*pcbVal = pprProp->m_cbProp;
	CopyMemory( pbVal, (pprProp->m_prop).pbProp, pprProp->m_cbProp );

Exit:

    m_Lock.ShareUnlock();
	return hr;
}

HRESULT
CPropBag::RemoveProperty( DWORD dwPropId )
/*++
Routine Description:

	Remove a property from the property bag

Arguments:

	DWORD dwPropId - The property to remove

Return value:

	S_OK - Removed
	ERROR_NOT_FOUND - Doesn't exist
--*/
{
	TraceQuietEnter( "CPropBag::RemoveProperty" );

	HRESULT hr = S_OK;

	if ( FAILED( m_hr ) ) return m_hr;

	m_Lock.ExclusiveLock();
	
	if ( m_ptTable.Delete( dwPropId ) ) hr = S_OK;
	else hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );

	m_Lock.ExclusiveUnlock();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\rtscan2\utest\tstscan.cpp ===
#include <windows.h>
#include <xmemwrpr.h>
#include <rtscan.h>
#include <stdio.h>

class CMyScan : public CRootScan {

public:

    CMyScan( LPSTR  szRoot ) :
        CRootScan( szRoot )
    {}

protected:

    virtual BOOL NotifyDir( LPSTR szDir ) {
        printf( "%s\n", szDir );
        return TRUE;
    }
};

int __cdecl main( int argc, char** argv)
{
    if ( argc != 2 ) {
        printf( "Usage: tstscan [Dir]\n" );
        return 1;
    }

    _VERIFY( CreateGlobalHeap( 0,0,0,0 ) );

    CMyScan *pScan = XNEW CMyScan( argv[1] );
    if ( NULL == pScan ) {
        printf( "Out of memory\n" );
        _VERIFY( DestroyGlobalHeap() );
        return 1;
    }

    pScan->DoScan();

    XDELETE pScan;
    _VERIFY( DestroyGlobalHeap() );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\admmacro.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	admmacro.h

Abstract:

	Useful macros used by all admin objects.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _ADMMACRO_INCLUDED_
#define _ADMMACRO_INCLUDED_

//
// Bit mask handling
//

#define IS_FLAG_SET(dw, flag) (((dw & flag) != 0) ? TRUE : FALSE)
#define SET_FLAG(dw, flag)    dw |= flag
#define RESET_FLAG(dw, flag)  dw &= ~(flag)
#define SET_FLAG_IF(cond, dw, flag)\
    if (cond)                      \
    {                              \
        SET_FLAG(dw, flag);        \
    }                              \
    else                           \
    {                              \
        RESET_FLAG(dw, flag);      \
    }


//
//	Error handling:
//

#define BAIL_ON_FAILURE(hr)	\
{							\
	if ( FAILED(hr) ) {		\
		goto Exit;			\
	}						\
}
#define BAIL_WITH_FAILURE(hr, hrFailureCode)	\
{							\
	(hr) = (hrFailureCode);	\
	goto Exit;				\
}

#define TRACE_HRESULT(hr)    \
{                           \
    if ( FAILED(hr) ) {     \
        DebugTrace ( 0, "Returning error: %x", hr );    \
    }                       \
}

//
//	Data validation macros:
//

#define IS_VALID_THIS_POINTER()			( !IsBadWritePtr ( (void *) this, sizeof (*this) ) )
#define IS_VALID_STRING(str)			( !IsBadStringPtr ( (str), (DWORD) -1 ) )
#define IS_VALID_STRING_LEN(str,len)	( !IsBadStringPtr ( (str), (len) ) )
#define IS_VALID_IN_PARAM(pIn)			( !IsBadReadPtr ( (pIn), sizeof ( *(pIn) ) ) )
#define IS_VALID_OUT_PARAM(pOut)		( !IsBadWritePtr ( (pOut), sizeof ( *(pOut) ) ) )

#define IS_VALID_READ_ARRAY(arr,cItems)		( !IsBadReadPtr ( (arr), (cItems) * sizeof ( *(arr) ) ) )
#define IS_VALID_WRITE_ARRAY(arr,cItems)	( !IsBadWritePtr ( (arr), (cItems) * sizeof ( *(arr) ) ) )

//
//	AssertValid for classes:
//

#ifdef DEBUG
	#define DECLARE_ASSERT_VALID()	void AssertValid ( ) const;
	#define DECLARE_VIRTUAL_ASSERT_VALID()	virtual void AssertValid ( ) const;
#else
	#define DECLARE_ASSERT_VALID()	inline void AssertValid ( ) const { }
	#define DECLARE_VIRTUAL_ASSERT_VALID()	inline void AssertValid ( ) const { }
#endif

//
//	Sizing macros:
//

inline DWORD STRING_BYTE_LENGTH ( LPWSTR wsz )
{
    if ( wsz == NULL ) {
        return 0;
    }

    return ( lstrlenW ( wsz ) + 1 ) * sizeof wsz[0];
}

//	Use only for statically sized arrays:
#define ARRAY_SIZE(arr)	( sizeof (arr) / sizeof ( (arr)[0] ) )

inline DWORD CB_TO_CCH ( DWORD cb )
{
	return cb / sizeof (WCHAR);
}

inline DWORD CCH_TO_CB ( DWORD cch )
{
	return cch * sizeof (WCHAR);
}

//
//	Bit macros:
//

inline void SetBitFlag ( DWORD * pbv, DWORD bit, BOOL fFlag )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pbv ) );
	_ASSERT ( bit != 0 );

	if ( fFlag ) {
		*pbv |= bit;
	}
	else {
		*pbv &= ~bit;
	}
}

inline BOOL GetBitFlag ( DWORD bv, DWORD bit )
{
	return !!(bv & bit);
}

//
//	Macros for ole types that aren't wrapped using ATL:
//

inline void SAFE_FREE_BSTR ( BSTR & str )
{
	if ( str != NULL ) {
		::SysFreeString ( str );
		str = NULL;
	}
}

#define SAFE_RELEASE(x) { if ( (x) ) { (x)->Release(); (x) = NULL; } }

#endif // _ADMMACRO_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\dllmain.cpp ===
#include "stdafx.h"
#include "resource.h"

#include "initguid.h"

#include "nntpdrv.h"
#include "nntpfs.h"
#include "fsdriver.h"
#include "fsthrd.h"

#define HEAP_INIT_SIZE (1024 * 1024)  // BUGBUG: this might be setable later 

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CNntpFSDriverPrepare, CNntpFSDriverPrepare)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

    BOOL    fSuccess = FALSE; 

	if (dwReason == DLL_PROCESS_ATTACH) {

        //
        // Create Global Heap - Add Ref to global heap, in fact
        //
        _VERIFY( fSuccess = CreateGlobalHeap(   NUM_EXCHMEM_HEAPS,
                                                    0,
                                                    HEAP_INIT_SIZE,
                                                    0 ) );
        if ( FALSE == fSuccess ) {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

         _Module.Init(ObjectMap, hInstance);
         DisableThreadLibraryCalls(hInstance);

        //
        // Initialize the global static lock
        //
		CNntpFSDriver::s_pStaticLock = XNEW CShareLockNH;
		if ( NULL == CNntpFSDriver::s_pStaticLock ) {
			SetLastError( ERROR_OUTOFMEMORY );
			return FALSE;
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH) {

        //
        // Clean up the global lock
        //
		_ASSERT( CNntpFSDriver::s_pStaticLock );
		XDELETE CNntpFSDriver::s_pStaticLock;
        CNntpFSDriver::s_pStaticLock = NULL;

		_Module.Term();

        //
        // Destroy global heap, Dec ref, in fact
        //
        _VERIFY( DestroyGlobalHeap() );
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer(TRUE);
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {
	_Module.UnregisterServer();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\core\rtscan2\src\rtscan.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:		

    rtscan.h

Abstract:

    This implements a generic root scan class.  Its difference from rootscan:
    1. Rootscan is not multi-thread safe, using SetCurrentDir; rtscan is;
    2. Rootscan has too much nntp specific stuff; rtscan doesn't;

Author:

    Kangrong Yan ( KangYan )    23-Oct-1998

Revision History:

--*/
#include <windows.h>
#include <dbgtrace.h>
#include <rtscan.h>

//////////////////////////////////////////////////////////////////////////////////
// Private Methods
//////////////////////////////////////////////////////////////////////////////////
BOOL
CRootScan::IsChildDir( IN WIN32_FIND_DATA& FindData )
/*++
Routine description:

    Is the found data of a child dir ? ( Stolen from Jeff Richter's book )

Arguments:

    IN WIN32_FIND_DATA& FindData    - The find data of a file or directory

Return value:

    TRUE - Yes;
    FALSE - No
--*/
{
    return(
        (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
        (FindData.cFileName[0] != '.') );
}

BOOL
CRootScan::MakeChildDirPath(   IN LPSTR    szPath,
                               IN LPSTR    szFileName,
                               OUT LPSTR   szOutBuffer,
                               IN DWORD    dwBufferSize )
/*++
Routine description:

    Append "szFileName" to "szPath" to make a full path.

Arguments:

    IN LPSTR    szPath  - The prefix to append
    IN LPSTR    szFileName - The suffix to append
    OUT LPSTR   szOutBuffer - The output buffer for the full path
    IN DWORD    dwBufferSize - The buffer size prepared

Return value:

    TRUE if success, FALSE otherwise

--*/
{
	_ASSERT( szPath );
	_ASSERT( strlen( szPath ) <= MAX_PATH );
	_ASSERT( szFileName );
	_ASSERT( strlen( szFileName ) <= MAX_PATH );
    _ASSERT( szOutBuffer );
    _ASSERT( dwBufferSize > 0 );

    LPSTR   lpstrPtr;

    if ( dwBufferSize < (DWORD)( lstrlen( szPath ) + lstrlen( szFileName ) + 2 ) ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    lstrcpy( szOutBuffer, szPath );
    lpstrPtr = szOutBuffer + lstrlen( szPath );
    if ( *( lpstrPtr - 1 )  == '\\' ) lpstrPtr--;
    *(lpstrPtr++) = '\\';

    lstrcpy( lpstrPtr, szFileName );    // trailing null should already be appended

    return TRUE;
}

HANDLE
CRootScan::FindFirstDir(    IN LPSTR                szRoot,
                            IN WIN32_FIND_DATA&     FindData )
/*++
Routine description:

    Find the first child directory under "szRoot".
    ( Stolen from Jeff Richter's book )

Arguments:

    IN LPSTR            szRoot  - Under which root to look for first child directory ?
    IN WIN32_FIND_DATA& FindData- Found results

Return value:

    HANDLE of first found directory.
--*/
{
	_ASSERT( szRoot );
	_ASSERT( strlen( szRoot ) <= MAX_PATH );
	
    CHAR    szPath[MAX_PATH+1];
    HANDLE  hFindHandle;
    BOOL    fFound;

    if ( !MakeChildDirPath( szRoot, "*", szPath, MAX_PATH )) {
        hFindHandle = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    hFindHandle = FindFirstFile( szPath, &FindData );
    if ( hFindHandle != INVALID_HANDLE_VALUE ) {
        fFound = IsChildDir( FindData );

        if ( !fFound )
            fFound = FindNextDir( hFindHandle, FindData );

        if ( !fFound ) {
            FindClose( hFindHandle );
            hFindHandle = INVALID_HANDLE_VALUE;
        }
    }

Exit:
    return hFindHandle;
}

BOOL
CRootScan::FindNextDir(      IN HANDLE           hFindHandle,
                             IN WIN32_FIND_DATA& FindData )
/*++
Routine description:

    Find the next child directory.
    ( Stolen from Jeff Richter's book )

Arguments:

    IN HANDLE hFindHandle           - Find handle returned by find first
    IN WIN32_FIND_DATA& FindData    - Found results

Return value:

    TRUE    - Found
    FALSE   - Not found
--*/
{
    BOOL    fFound = FALSE;

    do
        fFound = FindNextFile( hFindHandle, &FindData );
    while ( fFound && !IsChildDir( FindData ) );

    return fFound;
}

BOOL
CRootScan::RecursiveWalk( LPSTR szRoot )
/*++
Routine description:

    Recursively walk the whole directory tree, call the notify interface
    for every directory found.

Arguments:

    LPSTR szRoot - The root directory.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CRootScan::RecursiveWalk" );

    WIN32_FIND_DATA FindData;
    DWORD           err;

    //
    // Open the find handle
    //
    HANDLE hFind = FindFirstDir( szRoot, FindData );
    BOOL fFind = ( INVALID_HANDLE_VALUE != hFind );
    CHAR    szPath[MAX_PATH+1];

    while( fFind ) {

        //
        // Make up a full path to the found dir
        //
        if ( !MakeChildDirPath( szRoot,
                                FindData.cFileName,
                                szPath,
                                MAX_PATH ) ) {
            ErrorTrace( 0, "Make child dir failed %d", GetLastError() );
            _VERIFY( FindClose( hFind ) );
            return FALSE;
        }

        //
        // Call the notify interface
        //
        if ( !NotifyDir( szPath ) ) {

            //
            // Failed in notify dir, we should terminate the whole walk
            //
            ErrorTrace( 0, "Notify failed with %d", GetLastError() );
            _VERIFY( FindClose( hFind ) );
            return FALSE;
        }

        //
        // OK, we should ask cancel hint to see whether we should
        // continue
        //
        if ( m_pCancelHint && !m_pCancelHint->IShallContinue() ) {

            //
            // We should stop here
            //
            DebugTrace( 0, "We have been cancelled" );
            _VERIFY( FindClose( hFind ) );
            SetLastError( ERROR_OPERATION_ABORTED );
            return FALSE;
        }

        //
        // Dig into the found directory
        //
        if ( !RecursiveWalk( szPath ) ) {

            //
            // Relay the failure all the way out
            //
            err = GetLastError();
            ErrorTrace( 0, "RecusiveWalk failed at %s with %d",
                        FindData.cFileName, err );
            _VERIFY( FindClose( hFind ) );
            SetLastError( err );
            return FALSE;
        }

        //
        // We should  ask the cancel hint again
        //
        if ( m_pCancelHint && !m_pCancelHint->IShallContinue() ) {

            //
            // We should stop here
            //
            DebugTrace( 0, "We have been cancelled" );
            _VERIFY( FindClose( hFind ) );
            SetLastError( ERROR_OPERATION_ABORTED );
            return FALSE;
        }

        //
        // OK, we still need to find more child dirs
        //
        fFind = FindNextDir( hFind, FindData );
    }

    //
    // Now we are done with walk of our children
    //
    if ( hFind != INVALID_HANDLE_VALUE )
        _VERIFY( FindClose( hFind ) );
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////
// Public Methods
//////////////////////////////////////////////////////////////////////////////////
BOOL
CRootScan::DoScan()
{
    //
    // Let me notify myself first
    //
    if ( !NotifyDir( m_szRoot ) ) {
        return FALSE;
    }
    
    //
    // Call the recursive walk routine
    //
    return RecursiveWalk( m_szRoot );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsdirwlk.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:		

    fsdirwlk.cpp

Abstract:

    This is the implementation for the file system store driver's rootscan.
    The rootscan ( or dirwalk ) is used in rebuild.

Author:

    Kangrong Yan ( KangYan )    23-Oct-1998

Revision History:

--*/
#include "stdafx.h"
#include "resource.h"
#include "nntpdrv.h"
#include "nntpfs.h"
#include "fsdriver.h"

BOOL
CNntpFSDriverRootScan::HasPatternFile(  LPSTR szPath,
                                        LPSTR szPattern )
/*++
Routine description:

    Check the directory to see if he has the files in given pattern.

Arguments:

    LPSTR szPath    - The dir path to check.
    LPSTR szPattern - The pattern to look for

Arguments:

    TRUE if it has the pattern, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::HasPatternFile" );
    _ASSERT( szPath );
    _ASSERT( szPattern );

    CHAR    szFullPath[MAX_PATH+1];
    WIN32_FIND_DATA FindData;
    BOOL    fHasPattern = FALSE;

    //
    // Make up the final pattern - fully qualified
    //
    if ( SUCCEEDED( CNntpFSDriver::MakeChildDirPath(    szPath,
                                                        szPattern,
                                                        szFullPath,
                                                        MAX_PATH ) ) ){
        HANDLE hFind = INVALID_HANDLE_VALUE;
        hFind = FindFirstFile( szFullPath, &FindData );
        if ( INVALID_HANDLE_VALUE != hFind ) {

            /*
            //
            // If we are looking for "*", we should still skip "." and ".."
            //
            fHasPattern = TRUE;
            
            if ( strcmp( "*", szPattern ) == 0 ) {
                while( fHasPattern && FindData.cFileName[0] == '.' )
                    fHasPattern = FindNextFile( hFind, &FindData );
            }
            */
            fHasPattern = TRUE;
            
            _VERIFY( FindClose( hFind ) );
        }
    }

    //
    // Whether we had difficulty making full path or find first file failed,
    // we'll assume that the pattern is not found
    //
    TraceFunctLeave();
    return fHasPattern;
}

BOOL
CNntpFSDriverRootScan::HasSubDir( LPSTR szPath )
/*++
Routine description:

    Check the path to see if he has sub dir .

Arguments:

    LPSTR szPath - The path to check

Return value:

    TRUE if it does have sub dir, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::HasSubDir" );
    _ASSERT( szPath );

    WIN32_FIND_DATA FindData;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    CHAR            szPattern[MAX_PATH+1];
    BOOL            fHasSubDir = FALSE;
    BOOL            fFound = FALSE;

    if ( SUCCEEDED( CNntpFSDriver::MakeChildDirPath(    szPath,
                                                        "*",
                                                        szPattern,
                                                        MAX_PATH ) ) ) {
        hFind = FindFirstFile( szPattern, &FindData );
        fFound = ( INVALID_HANDLE_VALUE != hFind );

        while ( fFound && !fHasSubDir ) {
        
            fHasSubDir = CNntpFSDriver::IsChildDir( FindData );

            if ( !fHasSubDir ) fFound = FindNextFile( hFind, &FindData );
        }

        if ( INVALID_HANDLE_VALUE != hFind ) _VERIFY( FindClose( hFind ) );
    }

    TraceFunctLeave();
    return fHasSubDir;
}
        
BOOL
CNntpFSDriverRootScan::WeShouldSkipThisDir( LPSTR szPath )
/*++
Routine description:

    Check if we should skip this directory

Arguments:

    LPSTR szPath - The directory path

Return value:

    TRUE if we should skip this dir, FALSE if we shouldn't
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::WeShouldSkipThisDir" );
    _ASSERT( szPath );

    //
    // We should skip all directories that have _temp.files_ in it
    //
    if ( strstr( szPath, "_temp.files_" ) ) {
        return TRUE;
    }

    //
    // If we are asked not to skip any dir, we shouldn't skip it
    //
    if ( !m_fSkipEmpty ) {
        return FALSE;
    }

    //
    // If we are asked to skip empty directories, then we should
    // check if this directory has any news messages
    //
    BOOL fNoMessage = !HasPatternFile( szPath, "*.nws" );
    if ( fNoMessage ) {

        // 
        // We still don't want to skip leaves
        //
        if ( !HasSubDir( szPath) ) return FALSE;
        else return TRUE;
    } else
        return FALSE;
}

BOOL
CNntpFSDriverRootScan::CreateGroupInTree(   LPSTR               szPath,
                                            INNTPPropertyBag    **ppPropBag)
/*++
Routine description:

    Create the news group in newstree

Arguments:

    LPSTR szPath - The path to be converted into a newsgroup name

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::CreateGroupInTree" );
    _ASSERT( szPath );

    //
    // Lets ask the driver to do it, since he has better experience 
    // dealing with newstree
    //
    _ASSERT( m_pDriver );
    HRESULT hr = m_pDriver->CreateGroupInTree( szPath, ppPropBag );

    SetLastError( hr );
    return SUCCEEDED( hr );
}

BOOL
CNntpFSDriverRootScan::CreateGroupInVpp( INNTPPropertyBag *pPropBag )
/*++
Routine description;

    Create the group in vpp file

Arguments:

    INNTPPropertyBag *pPropBag - The group's property bag

Return Value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::CreateGroupInVpp" );
    _ASSERT( pPropBag );
    DWORD   dwOffset;

    //
    // Lets ask the driver to do it, since he has better experience
    // dealing with newstree
    //
    _ASSERT( m_pDriver );
    HRESULT hr = m_pDriver->CreateGroupInVpp( pPropBag, dwOffset );

    SetLastError( hr );
    return SUCCEEDED( hr );
}

BOOL
CNntpFSDriverRootScan::NotifyDir( LPSTR szPath )
/*++
Routine description:

    Handle the notification of each dir being found.  What we'll do 
    with this is to convert the path into group name and create it
    into newstree.  Notice that for those rebuilds that can use
    vpp file, when the vpp file is not corrupted, rootscan can be avoided.
    If we have to do rootscan, the only group property we have is group 
    name.  So we'll ask the newstree to assign group id, etc.  After
    the group has been created in the newstree, we'll set the properties
    into vpp file.

Arguments:

    LPSTR szPath - The path found

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriverRootScan::NotifyDir" );
    _ASSERT( szPath );

    INNTPPropertyBag    *pPropBag = NULL;
    HANDLE              hDir = INVALID_HANDLE_VALUE;
    HRESULT             hr1, hr2;

    //
    // Check to see if we should skip this dir because it's empty
    //
    if ( WeShouldSkipThisDir( szPath ) ) {
        DebugTrace( 0, "Dir %s skipped", szPath );
        return TRUE;
    }

    //
    // We ask the newstree to create this group
    //
    if ( !CreateGroupInTree( szPath, &pPropBag ) ) {
        ErrorTrace( 0, "Create group in newstree failed %x", GetLastError() );
        // special case, just skip the invalid name directories instead of failing the entire thing
        if (HRESULT_FROM_WIN32(ERROR_INVALID_NAME) == GetLastError())
        {
            DebugTrace( 0, "Dir %s invalid name skipped", szPath );
            return TRUE;
        }
        else
            return FALSE;
    }

    _ASSERT( pPropBag );

    //
    // Create time is something that we can not get from anywhere else,
    // so we'll use the directory creation time
    //
    hDir = CreateFile(  szPath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        0,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        0 );
    if (hDir != INVALID_HANDLE_VALUE)
    {
        // Get directory info
        BY_HANDLE_FILE_INFORMATION  bhfi;
        if (!GetFileInformationByHandle( hDir, &bhfi ))
        {
            // Can't get directory info
            ErrorTrace(0,"err:%d Can't get dir info %s",GetLastError(),szPath);
            _ASSERT(FALSE);
            _VERIFY( CloseHandle( hDir ) );
            pPropBag->Release();
            return FALSE;
        }
        else
        {
            // get the creation date
            hr1 = pPropBag->PutDWord( NEWSGRP_PROP_DATELOW, bhfi.ftCreationTime.dwLowDateTime );
            hr2 = pPropBag->PutDWord( NEWSGRP_PROP_DATEHIGH,bhfi.ftCreationTime.dwHighDateTime );
            if ( FAILED( hr1 ) || FAILED( hr2 ) ) {
                ErrorTrace( 0, "Put creation date properties failed %x %x", hr1, hr2 );
                _VERIFY( CloseHandle( hDir ) );
                pPropBag->Release();
                return FALSE;
            }
        }
        
        // close handle
        if (hDir != INVALID_HANDLE_VALUE)
        {    _VERIFY( CloseHandle(hDir) );
            hDir = INVALID_HANDLE_VALUE;
        }
    }

    //
    // Remember: we have one reference on this bag, we should release it
    //

    //
    // We ask the driver to create it in vpp file
    //
    if ( !CreateGroupInVpp( pPropBag ) ) {
        ErrorTrace( 0, "Create group in vpp file failed %x", GetLastError() );
        pPropBag->Release();
        return FALSE;        
    }

    //
    // Release bag and return
    //
    pPropBag->Release();
    TraceFunctLeave();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsprep.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fsprep.cpp

Abstract:

    This is the implementation for the file system store driver's 
	prepare interface.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include "nntpdrv.h"
#include "nntpfs.h"
#include "fsdriver.h"

#include <stdio.h>


//////////////////////////////////////////////////////////////////////////
// Interface Methods - CNntpFSDriverPrepare
//////////////////////////////////////////////////////////////////////////

HRESULT CNntpFSDriverPrepare::FinalConstruct() {
    return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(),
										  &m_pUnkMarshaler.p));
}

VOID CNntpFSDriverPrepare::FinalRelease() {
    m_pUnkMarshaler.Release();
}

void STDMETHODCALLTYPE
CNntpFSDriverPrepare::Connect(  LPCWSTR	wszVRootPath,
								LPCSTR szGroupPrefix,
								IUnknown *punkMetabase,
								INntpServer *pServer,
								INewsTree *pINewsTree,
								INntpDriver **pIGoodDriver,
								INntpComplete *pICompletion,
								HANDLE  hToken,
								DWORD   dwFlag )
{
	TraceFunctEnter( "CNntpFSDriverPrepare::Connect" );
	_ASSERT( wszVRootPath );
	_ASSERT( lstrlenW( wszVRootPath ) <= MAX_PATH );
	_ASSERT( pServer );	
	_ASSERT( pINewsTree );	
	_ASSERT( pIGoodDriver );
	_ASSERT( pICompletion );

	HRESULT hr;
	CONNECT_CONTEXT *pConnectContext;
	CNntpFSDriverConnectWorkItem *pConnectWorkItem = NULL;

	// Save all the parameters 
	wcscpy( m_wszVRootPath, wszVRootPath );
	strcpy( m_szGroupPrefix, szGroupPrefix );
	m_punkMetabase = punkMetabase;
	m_pServer = pServer;
	m_ppIGoodDriver = pIGoodDriver;
	m_pINewsTree = pINewsTree;
	m_hToken = hToken;
	m_dwConnectFlags = dwFlag;
	DWORD   dw;

	// Create the connect event, the connect thread uses this event
	// to notify that it's done with its work
    /*
	m_hConnect = CreateEvent( NULL, FALSE, FALSE, NULL );
	if ( NULL == m_hConnect ) {
	    hr = HRESULT_FROM_WIN32( GetLastError() );
	    ErrorTrace( 0, "Create connect event failed %x", hr );
	    punkMetabase->Release();
	    pServer->Release();
	    pINewsTree->Release();
	    pICompletion->SetResult( hr );
	    pICompletion->Release();
        return;
    }*/

    // Allocate the connect context
    pConnectContext = XNEW CONNECT_CONTEXT;
    _ASSERT( pConnectContext );
    if ( NULL == pConnectContext ) {
        hr = E_OUTOFMEMORY;
        ErrorTrace( 0, "Creating connect context out of memory" );
        punkMetabase->Release();
        pServer->Release();
        pINewsTree->Release();
        pICompletion->SetResult( hr );
        pICompletion->Release();
        //SetEvent( m_hConnect );
        return;
    }

    // else, set contexts
    pConnectContext->pPrepare = this;
    pConnectContext->pComplete = pICompletion;

    // Create the connect workitem to be queued to thread pool
    pConnectWorkItem = XNEW CNntpFSDriverConnectWorkItem( pConnectContext );
    if ( NULL == pConnectWorkItem ) {
        XDELETE pConnectContext;
        hr = E_OUTOFMEMORY;
        ErrorTrace( 0, "Allocate Connect workitem failed" );
        punkMetabase->Release();
        pServer->Release();
        pINewsTree->Release();
        pICompletion->SetResult( hr );
        pICompletion->Release();
        //SetEvent( m_hConnect );
        return;
    }

    // Now queue the work item to the thread pool
    _ASSERT( g_pNntpFSDriverThreadPool );
    AddRef();   // add ref to myself, connect internal will release it
    if ( !g_pNntpFSDriverThreadPool->PostWork( pConnectWorkItem ) ) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        hr = SUCCEEDED( hr ) ? E_UNEXPECTED : hr;
        ErrorTrace( 0, "Queue a connect work item failed %x", hr );
        XDELETE pConnectWorkItem;
        XDELETE pConnectContext;
        punkMetabase->Release();
        pServer->Release();
        pINewsTree->Release();
        pICompletion->SetResult( hr );
        pICompletion->Release();
        //SetEvent( m_hConnect );
        Release();
        return;
    }
 
	TraceFunctLeave();
	return;
}

DWORD WINAPI
CNntpFSDriverPrepare::ConnectInternal(	PVOID pvContext )
{
	TraceFunctEnter( "CNntpFSDriverPrepare::ConnectInternal" );
    _ASSERT( pvContext );
    CONNECT_CONTEXT *pConnectContext = (CONNECT_CONTEXT *)pvContext;
	CNntpFSDriverPrepare *pPrepare = pConnectContext->pPrepare;
	_ASSERT( pPrepare );
	INntpComplete *pComplete = pConnectContext->pComplete;
	_ASSERT( pComplete );

	_ASSERT( lstrlenW( pPrepare->m_wszVRootPath ) <= MAX_PATH );
	_ASSERT( pPrepare->m_pServer );	
	_ASSERT( pPrepare->m_pINewsTree );	
	_ASSERT( pPrepare->m_ppIGoodDriver );
	//_ASSERT( pPrepare->m_pICompletion );

	HRESULT 		hr = S_OK;
	INntpDriver 	*pIDriver = NULL;
	DWORD           cRetry = 0;
	INIT_CONTEXT    InitContext;

	// Create the driver instance
	IUnknown *pI = CreateDriverInstance();	// added one ref here
	if( NULL == pI ) {
	 	ErrorTrace(0, "Create driver instance fail" );
	 	hr = NNTP_E_CREATE_DRIVER;
		goto SetResult;
	}

	// QI: ref bumped again 
	hr = pI->QueryInterface( IID_INntpDriver, (void**)&pIDriver );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "QI failed %x", hr );
		pI->Release();
		goto SetResult;
	}

	// Release the IUnknown interface
	pI->Release();

    do {
        if ( FAILED( hr ) )  Sleep( INIT_RETRY_WAIT );
            
    	// Call the initialization
    	InitContext.m_dwFlag = pPrepare->m_dwConnectFlags;
	    hr = pIDriver->Initialize( 	pPrepare->m_wszVRootPath,
		    						pPrepare->m_szGroupPrefix,
			    					pPrepare->m_punkMetabase,
				    				pPrepare->m_pServer,
					    			pPrepare->m_pINewsTree,
						    		&InitContext,
						    		NULL,	// I don't use this flag yet 
								    pPrepare->m_hToken
    								);
    	    
    } while ( hr == HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )
                && !InterlockedCompareExchange( &pPrepare->m_lCancel, 0, 0 )
                && ++cRetry < MAX_RETRY );

    // This is a hack, should be taken out when the potential deadlock has
    // been resolved
#if 0
    if ( InterlockedCompareExchange( &pPrepare->m_lCancel, 1, 1 ) && SUCCEEDED( hr ) ) {

        // I should de-initialize the driver
        pIDriver->Terminate( NULL );

        // and I should set hr to be some fail code
        hr = HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION );
    }
#endif

	if ( FAILED( hr ) ) {
		    ErrorTrace( 0, "Driver initialization failed %x", hr );
    	   	goto SetResult;
    }

	// Prepare for return
	*pPrepare->m_ppIGoodDriver = pIDriver;	// now we only have one reference on the
								// good interface, which is owned by
								// the client - protocol
SetResult:

    // whether we failed or succeeded, we should release the metabase pointer
    pPrepare->m_punkMetabase->Release();

    // If we have failed, we should clean up a bunch of pointers
    if ( FAILED( hr ) ) {
        _ASSERT( pPrepare->m_pServer );
        pPrepare->m_pServer->Release();
        _ASSERT( pPrepare->m_pINewsTree );
        pPrepare->m_pINewsTree->Release();
        if ( pIDriver ) pIDriver->Release();
    }

	pComplete->SetResult( hr );

	// set event has to be here, otherwise could get around and wait on 
	// the event
	/*
	_VERIFY( SetEvent( pPrepare->m_hConnect ) );
	*/

	//
	// Prepare object can go away now
	//
	pPrepare->Release();

    //
    // BUGBUG: we'll use atq thread pool so that we don't have to do this
    // If it failed, we've got to use another thread ( outside the driver's
    // thread pool ) to complete it
    //
    /*
    DWORD  dwThreadId;
    HANDLE hThread = CreateThread(  NULL,
                                    0,
                                    FailRelease,
                                    pComplete,
                                    0,
                                    &dwThreadId );
    //
    // BUGBUG: what if we failed in create this thread ?
    //
    _ASSERT( hThread );
    _VERIFY( CloseHandle( hThread ) );
    */

    pComplete->Release();
	TraceFunctLeave();

	return 0;
}

/////////////////////////////////////////////////////////////////////////
// Private methods - CNntpFSDriverPrepare
/////////////////////////////////////////////////////////////////////////

//
// Create instance of good driver
//
IUnknown*
CNntpFSDriverPrepare::CreateDriverInstance()
{
	IUnknown *pI = static_cast<INntpDriver*>(XNEW CNntpFSDriver);
	pI->AddRef();
	return pI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsdriver.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fsdriver.h

Abstract:

    This is the definition for the file system store driver class.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/

#ifndef __FSDRIVER_H__
#define __FSDRIVER_H__

#include "nntpdrv.h"
#include <mailmsg.h>
#include <drvid.h>
#include "fsthrd.h"
#include <iadmw.h>
#include <artcore.h>
#include <rtscan.h>
#include <isquery.h>

//
// Macros for thread pool
//
#define POOL_MAX_THREADS 5      // BUGBUG: this might be setable from registry
#define POOL_START_THREADS 1    // BUGBUG: this might be setable later

//
// Macros
//
#define TERM_WAIT 500	
#define INIT_RETRY_WAIT 500
#define MAX_RETRY   10
#define MAX_GROUPNAME 1024
#define PROPBAG_BUFFERSIZE 516

//
// Variable lengthed group property record type
//
const DWORD HeaderSize =  10 * sizeof( USHORT ) + sizeof(DWORD) + sizeof(FILETIME);
const DWORD MaxRecordSize =   MAX_RECORD_SIZE - HeaderSize ;
const DWORD RecordContentOffset = HeaderSize;
const USHORT OffsetNone = 0;

#define RECORD_ACTUAL_LENGTH( _rec_ )		\
		( 	HeaderSize +					\
			(_rec_).cbGroupNameLen + 		\
			(_rec_).cbNativeNameLen +		\
			(_rec_).cbPrettyNameLen +		\
			(_rec_).cbDescLen +				\
			(_rec_).cbModeratorLen )
			
struct VAR_PROP_RECORD {	//vp
    DWORD   dwGroupId;
    FILETIME    ftCreateTime;
	USHORT	iGroupNameOffset;
	USHORT	cbGroupNameLen;
	USHORT	iNativeNameOffset;
	USHORT	cbNativeNameLen;
	USHORT	iPrettyNameOffset;
	USHORT	cbPrettyNameLen;
	USHORT	iDescOffset;
	USHORT	cbDescLen;
	USHORT	iModeratorOffset;
	USHORT	cbModeratorLen;
	BYTE	pData[MaxRecordSize];
};

// structure passed to CacheCreateFile callback function
// to tell the callback UNC identity and hToken
struct CREATE_FILE_ARG {
    BOOL    bUNC;
    HANDLE  hToken;
};

typedef struct {
    DWORD m_dwFlag;
} INIT_CONTEXT, *PINIT_CONTEXT;

//
// Extern variables
//
extern CNntpFSDriverThreadPool *g_pNntpFSDriverThreadPool;

//
// Implementation class for the driver's good interface.  The
// driver's good interface carries all the features that the
// protocol needs to talk to
//
class CNntpFSDriver :
	public INntpDriver,
	public IMailMsgStoreDriver,
	public INntpDriverSearch
{

    // INntpDriver
    public:

        enum InvalidateStatus {
    	    Invalidating,
    	    Invalidated
    	};

    	//
    	// Declare that CNntpFSDriverRootScan is our friend
    	//
    	friend class CNntpFSDriverRootScan;

    	//
    	// Static methods for the file system driver
    	//
    	static BOOL CreateThreadPool();
    	static VOID DestroyThreadPool();

		// Constructor, destructor
		CNntpFSDriver::CNntpFSDriver() :
				m_cRef(0),
				m_cUsages( 0 ),
				m_pffPropFile( NULL ),
				m_pINewsTree( NULL ),
				m_Status( DriverDown ),
				m_bUNC( FALSE ),
				m_dwFSType( FS_NTFS ),
				m_pDirNot( NULL ),
				m_lInvalidating( Invalidated ),
				m_fUpgrade( FALSE ),
				m_fIsSlaveGroup(FALSE)
				{ _Module.Lock(); }
		CNntpFSDriver::~CNntpFSDriver(){ _Module.Unlock(); }

		// Interface methods for IMailMsgStoreDriver
		HRESULT STDMETHODCALLTYPE
		AllocMessage(	IMailMsgProperties *pMsg,
						DWORD	dwFlags,
						IMailMsgPropertyStream **ppStream,
						PFIO_CONTEXT *ppFIOContentFile,
						IMailMsgNotify *pNotify );

		HRESULT STDMETHODCALLTYPE
		CloseContentFile(	IMailMsgProperties *pMsg,
							PFIO_CONTEXT pFIOContentFile );

		HRESULT STDMETHODCALLTYPE
		Delete(	IMailMsgProperties *pMsg,
				IMailMsgNotify *pNotify );

		HRESULT STDMETHODCALLTYPE
		EnumMessages( IMailMsgEnumMessages **ppEnum ) {
			return E_NOTIMPL;
		}

		HRESULT STDMETHODCALLTYPE
		ReAllocMessage( IMailMsgProperties *pOriginalMsg,
						IMailMsgProperties *pNewMsg,
						IMailMsgPropertyStream **ppStream,
						PFIO_CONTEXT *ppFIOContentFile,
						IMailMsgNotify *pNotify ) {
			return E_NOTIMPL;
		}

		HRESULT STDMETHODCALLTYPE
		ReOpen(	IMailMsgProperties *pMsg,
				IMailMsgPropertyStream **ppStream,
				PFIO_CONTEXT *ppFIOContentFile,
				IMailMsgNotify *pNotify ) {
			return E_NOTIMPL;
		}

		HRESULT STDMETHODCALLTYPE
		SupportWriteContent()
		{ return S_FALSE; }

		// Interface methods for INntpDriver
        HRESULT STDMETHODCALLTYPE
        Initialize( IN LPCWSTR pwszVRootPath,
        			IN LPCSTR pszGroupPrefix,
        			IN IUnknown *punkMetabase,
                    IN INntpServer *pServer,
                    IN INewsTree *pINewsTree,
                    IN PVOID	pvContext,
                    OUT DWORD *pdwNDS,
                    IN HANDLE   hToken );

        HRESULT STDMETHODCALLTYPE
        Terminate( OUT DWORD *pdwNDS );

        HRESULT STDMETHODCALLTYPE
        GetDriverStatus( DWORD *pdwNDS ) { return E_NOTIMPL; }

        HRESULT STDMETHODCALLTYPE
        StoreChangeNotify( IUnknown *punkSOCChangeList ) {return E_NOTIMPL;}

        void STDMETHODCALLTYPE
        CommitPost( IN IUnknown *punkMessage,  // IMsg pointer
                    IN STOREID *pStoreId,
                    IN STOREID *rgOtherStoreIDs,
                    IN HANDLE   hToken,
                    IN INntpComplete *pICompletion,
                    IN BOOL     fAnonymous );

        void STDMETHODCALLTYPE
        GetArticle( IN INNTPPropertyBag *pPrimaryGroup,
        			IN INNTPPropertyBag *pCurrentGroup,
        			IN ARTICLEID idPrimaryArt,
                    IN ARTICLEID idCurrentArt,
                    IN STOREID StoreId,
                    IN HANDLE   hToken,
                    void **pvFileHandleContext,
                    IN INntpComplete *pICompletion,
                    IN BOOL     fAnonymous );

        void STDMETHODCALLTYPE
        DeleteArticle( IN    INNTPPropertyBag *pGroupBag,
               IN    DWORD            cArticles,
               IN    ARTICLEID        rgidArt[],
               IN    STOREID          rgidStore[],
               IN    HANDLE           hToken,
               OUT   DWORD            *pdwLastSuccess,
               IN    INntpComplete    *pICompletion,
               IN    BOOL             fAnonymous );

        void STDMETHODCALLTYPE
        GetXover( IN INNTPPropertyBag *pPropBag,
                  IN ARTICLEID idMinArticle,
                  IN ARTICLEID idMaxArticle,
                  OUT ARTICLEID *idLastArticle,
                  OUT char* pBuffer,
                  IN DWORD cbin,
                  OUT DWORD *cbout,
                  HANDLE    hToken,
                  INntpComplete *pICompletion,
                  IN  BOOL  fAnonymous );

		HRESULT STDMETHODCALLTYPE
	    GetXoverCacheDirectory(
	    			IN	INNTPPropertyBag*	pPropBag,
					OUT	CHAR*	pBuffer,
					IN	DWORD	cbIn,
					OUT	DWORD	*pcbOut,
					OUT	BOOL*	fFlatDir
					) ;

        void STDMETHODCALLTYPE
        GetXhdr(	IN INNTPPropertyBag *punkPropBag,
        			IN ARTICLEID idMinArticle,
        			IN ARTICLEID idMaxArticle,
        			OUT ARTICLEID *idLastArticle,
        			IN char* pszHeader,
        			OUT char* pBuffer,
        			IN DWORD cbin,
        			OUT DWORD *cbout,
        			HANDLE  hToken,
        			INntpComplete *pICompletion,
        			IN  BOOL    fAnonymous );
        			
        void STDMETHODCALLTYPE
        RebuildGroup(   IN INNTPPropertyBag *pPropBag,
                        IN HANDLE           hToken,
                        IN INntpComplete *pComplete );

        HRESULT STDMETHODCALLTYPE
        SyncGroups( char **ppmtszGroup,
                    DWORD cGroup ) {return E_NOTIMPL;}

        void STDMETHODCALLTYPE
        DecorateNewsGroupObject( INNTPPropertyBag *pNewsGroup,
                                 DWORD  cProperties,
                                 DWORD *rgidProperties,
                                 INntpComplete *pICompletion )
        {}

        void STDMETHODCALLTYPE
        CheckGroupAccess(   IN    INNTPPropertyBag *pNewsGroup,
                    IN    HANDLE  hToken,
                    IN    DWORD   dwDesiredAccess,
                    IN    INntpComplete *pICompletion );

        void STDMETHODCALLTYPE
        SetGroupProperties( INNTPPropertyBag *pNewsGroup,
                            DWORD   cProperties,
                            DWORD   *rgidProperties,
                            HANDLE  hToken,
                            INntpComplete *pICompletion,
                            BOOL    fAnonymous );

        void STDMETHODCALLTYPE
        DecorateNewsTreeObject( IN HANDLE   hToken,
                                IN INntpComplete *pICompletion );
		
        void STDMETHODCALLTYPE
        CreateGroup( IN INNTPPropertyBag* punkPropBag,
                     IN HANDLE  hToken,
        			 IN INntpComplete* pICompletion,
        			 IN BOOL    fAnonymous );
        			
        void STDMETHODCALLTYPE
        RemoveGroup( IN INNTPPropertyBag *punkPropBag,
                     IN HANDLE  hToken,
        			 IN INntpComplete *pICompletion,
        			 IN BOOL    fAnonymous );

		// INntpDriverSearch
		void STDMETHODCALLTYPE
		MakeSearchQuery (
			IN	CHAR *pszSearchString,
			IN	INNTPPropertyBag *pGroupBag,
			IN	BOOL bDeepQuery,
			IN	WCHAR *pszColumns,
			IN	WCHAR *pszSortOrder,
			IN	LCID LocalID,
			IN	DWORD cMaxRows,
			IN	HANDLE hToken,
			IN	BOOL fAnonymous,
			IN	INntpComplete *pICompletion,
			OUT	INntpSearchResults **pINntpSearch,
			IN	LPVOID lpvContext
			);

		void STDMETHODCALLTYPE
		MakeXpatQuery (
			IN	CHAR *pszSearchString,
			IN	INNTPPropertyBag *pGroupBag,
			IN	BOOL bDeepQuery,
			IN	WCHAR *pszColumns,
			IN	WCHAR *pszSortOrder,
			IN	LCID LocalID,
			IN	DWORD cMaxRows,
			IN	HANDLE hToken,
			IN	BOOL fAnonymous,
			IN	INntpComplete *pICompletion,
			OUT	INntpSearchResults **pINntpSearch,
			OUT	DWORD *pLowArticleID,
			OUT	DWORD *pHighArticleID,
			IN	LPVOID lpvContext
			);

		BOOL STDMETHODCALLTYPE
		UsesSameSearchDatabase (
			IN	INntpDriverSearch *pDriver,
			IN	LPVOID lpvContext
			);

		void STDMETHODCALLTYPE
		GetDriverInfo(
			OUT	GUID *pDriverGUID,
			OUT	void **ppvDriverInfo,
			IN	LPVOID lpvContext
			);

		// Implementation of IUnknown interface
    	HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
    	{
    	    if ( iid == IID_IUnknown ) {
    	        *ppv = static_cast<INntpDriver*>(this);
    	    } else if ( iid == IID_INntpDriver ) {
    	        *ppv = static_cast<INntpDriver*>(this);
    	    } else if ( iid == IID_IMailMsgStoreDriver ) {
    	    	*ppv = static_cast<IMailMsgStoreDriver*>(this);
    	    } else if ( iid == IID_INntpDriverSearch ) {
    	    	*ppv = static_cast<INntpDriverSearch*>(this);
    	    } else {
    	        *ppv = NULL;
    	        return E_NOINTERFACE;
    	    }
    	    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    	    return S_OK;
    	}

    	ULONG __stdcall AddRef()
    	{
    	    return InterlockedIncrement( &m_cRef );
    	}
	
	    ULONG __stdcall Release()
	    {
	        if ( InterlockedDecrement( &m_cRef ) == 0 ) {
	        	Terminate( NULL );
				delete this;
				return 0;
	        }
	        return m_cRef;
	    }

	// public members:
		static CShareLockNH *s_pStaticLock;	
		static LONG    L_dwThreadPoolRef;

	// Private methods
	private:
		// static methods
		static HRESULT StaticInit();
		static VOID StaticTerm();
		static HRESULT MakeChildDirPath(   IN LPSTR    szPath,
                            IN LPSTR    szFileName,
                            OUT LPSTR   szOutBuffer,
                            IN DWORD    dwBufferSize );
        static VOID CopyAsciiStringIntoUnicode( LPWSTR, LPCSTR );
		static VOID CopyUnicodeStringIntoAscii( LPSTR, LPCWSTR );
		static BOOL IsChildDir( IN WIN32_FIND_DATA& FindData );
		static DWORD ByteSwapper(DWORD );
		static DWORD ArticleIdMapper( IN DWORD   dw );
		static BOOL DoesDriveExist( CHAR chDrive );
		static HRESULT GetString( 	IMSAdminBase *pMB,
                       		      	METADATA_HANDLE hmb,
		                          	DWORD dwId,
                             		LPWSTR szString,
                             		DWORD *pcString);

        // Flat file callback function
		static void OffsetUpdate( PVOID pvContext, BYTE* pData, DWORD cData, DWORD iNewOffset )
		{ printf ( "Offset %d\n", iNewOffset ) ;}

		// Callback function to create file handle
		static HANDLE CreateFileCallback(LPSTR, PVOID, PDWORD, PDWORD );

		// Callback for sec change notification
		static BOOL InvalidateGroupSec( PVOID pvContext, LPWSTR wszDir ) {
		    _ASSERT( pvContext );
		    return ((CNntpFSDriver *)pvContext)->InvalidateGroupSecInternal( wszDir );
		}

		// Callback when buffer for dirnot is too small
		static HRESULT InvalidateTreeSec( IDirectoryNotification *pDirNot ) {
		    _ASSERT( pDirNot );
		    CNntpFSDriver *pDriver = (CNntpFSDriver*)pDirNot->GetInitializedContext();
		    _ASSERT( pDriver );
		    return pDriver->InvalidateTreeSecInternal();
		}

        static BOOL AddTerminatedDot( HANDLE hFile );

        static void BackFillLinesHeader(    HANDLE  hFile,
                                            DWORD   dwHeaderLength,
                                            DWORD   dwLinesOffset );

		// non-static method to invalidate the secruity descriptor on newstree
		HRESULT InvalidateTreeSecInternal();

        // non-static method to invalidate the security descriptor on a group object
		BOOL InvalidateGroupSecInternal( LPWSTR wszDir );

		// non-static

        // Create all the directories in the path
        BOOL CreateDirRecursive( LPSTR szDir, HANDLE hToken = NULL );

		// Function that reads the vroot info from metabase
		HRESULT ReadVrootInfo( IUnknown *punkMetabase );

		// property conversion between property bag and
		// flatfile record
		HRESULT Group2Record( IN VAR_PROP_RECORD&, IN INNTPPropertyBag* );
		HRESULT Record2Group( IN VAR_PROP_RECORD&, IN INNTPPropertyBag* )
		{ return E_NOTIMPL; }

		// group name and physical fs path conversion
		VOID GroupName2Path( LPSTR szGroupName, LPSTR szFullPath );
		VOID Path2GroupName( LPSTR szGroupName, LPSTR szFullPath );

		// Convert group name, article id into full path of article file
        HRESULT ObtainFullPathOfArticleFile( IN LPSTR, IN DWORD, OUT LPSTR, IN OUT DWORD& );

        // Decorate news tree related methods
        HRESULT EnumCheckTree( INntpComplete * );
        HRESULT EnumCheckInternal( 	INNTPPropertyBag *, INntpComplete * );
        							
        HRESULT LoadGroupOffsets( INntpComplete * );

        // internal functions shared by both interfaces
        HRESULT AllocInternal(  IMailMsgProperties *pMsg,
                                PFIO_CONTEXT *ppFIOContentFile,
                                LPSTR   szFileName,
                                BOOL    b,
                                BOOL    fPrimaryStore,
                                HANDLE  hToken = NULL );
        HRESULT DeleteInternal( INNTPPropertyBag *, ARTICLEID );
        HRESULT	GetXoverInternal(   IN INNTPPropertyBag *pPropBag,
		                            IN ARTICLEID    idMinArticle,
        		                    IN ARTICLEID    idMaxArticle,
                		            OUT ARTICLEID   *pidLastArticle,
                		            IN LPSTR		szHeader,
                        		    OUT LPSTR       pcBuffer,
		                            IN DWORD        cbin,
        		                    OUT DWORD       *pcbout,
        		                    IN BOOL 		bIsXOver,
        		                    IN HANDLE       hToken,
        		                    IN INntpComplete *pComplete );

        // Load group's security descriptor
        HRESULT LoadGroupSecurityDescriptor(    INNTPPropertyBag    *pPropBag,
                                                LPSTR&              lpstrSecDesc,
                                                PDWORD              pcbSecDesc,
                                                BOOL                bSetProp,
                                                PBOOL               pbAllocated );

        // Get File system type and UNC vroot information
        DWORD GetFileSystemType(    IN  LPCSTR      pszRealPath,
                                    OUT LPDWORD     lpdwFileSystem,
                                    OUT PBOOL       pbUNC
                                );

        // Initialize the group property file
        HRESULT InitializeVppFile();

        // Terminate the group property file
        HRESULT TerminateVppFile();

        // Create a group in tree only, give the fs path
        HRESULT CreateGroupInTree( LPSTR szPath, INNTPPropertyBag **ppPropBag );

        // Create the group in vpp file only
        HRESULT CreateGroupInVpp( INNTPPropertyBag *pPropBag, DWORD& dwOffset );

        // Create all the relevant groups into vpp
        HRESULT CreateGroupsInVpp( INntpComplete *);

        // Load groups into the newstree, could be from root scan or vpp file
        HRESULT LoadGroups( INntpComplete *pComplete );

        // Load groups from vpp file
        HRESULT LoadGroupsFromVpp( INntpComplete *pComplete );

        // Post message into server hash tables
        HRESULT PostToServer(   LPSTR           szFileName,
                                LPSTR           szGroupName,
                                INntpComplete   *pProtocolComplete );

        // Parse xref line
        HRESULT ParseXRef(      HEADERS_STRINGS     *pHeaderXref,
                                LPSTR               szPrimaryName,
                                DWORD&              cCrossPosts,
                                INNTPPropertyBag    *rgpPropBag[],
                                ARTICLEID           rgArticleId[],
                                INntpComplete       *pProtocolComplete );

        // Get property bag from newstree, give "native name"
        INNTPPropertyBag * GetPropertyBag(  LPSTR   pchBegin,
                                            LPSTR   pchEnd,
                                            LPSTR   szGroupName,
                                            BOOL&   fIsNative,
                                            INntpComplete *pProtocolComplete );

        // Prepare for posting parameters
        HRESULT PreparePostParams(  LPSTR               szFileName,
                                    LPSTR               szGroupName,
                                    LPSTR               szMessageId,
                                    DWORD&              dwHeaderLen,
                                    DWORD&              cCrossPosts,
                                    INNTPPropertyBag    *rgpPropBag[],
                                    ARTICLEID           rgArticleId[],
                                    INntpComplete       *pProtocolComplete );

        // update group properties such as high/low watermark, article count
        HRESULT UpdateGroupProperties(  DWORD               cCrossPosts,
                                        INNTPPropertyBag    *rgpPropBag[],
                                        ARTICLEID           rgArticleId[] );

        /*
        // Check to see if this is a bad message id conflict
        BOOL IsBadMessageIdConflict(  LPSTR               szMessageId,
                                      INNTPPropertyBag    *pPropBag,
                                      LPSTR               szGroupName,
                                      ARTICLEID           articleid,
                                      INntpComplete       *pProtocolComplete );

        // Does the cross post include us ( the group )
        BOOL CrossPostIncludesUs(   LPSTR               szMessageId,
                                    INNTPPropertyBag    *pPropBag,
                                    ARTICLEID           articleid,
                                    INntpComplete       *pProtocolComplete );

        BOOL FromSameVroot(   LPSTR               szMessageId,
                              LPSTR               szGroupName,
                              BOOL&               fFromSame );
        */

        HRESULT
        SetMessageContext(
            IMailMsgProperties* pMsg,
            char*               pszGroupName,
            DWORD               cbGroupName,
            PFIO_CONTEXT        pfioContext
            );
        HRESULT
            GetMessageContext(
            IMailMsgProperties* pMsg,
            LPSTR               szFileName,
            BOOL *              pfIsMyMessage,
            PFIO_CONTEXT        *ppFIOContentFile
            );

		// For debugging purpose
		VOID DumpGroups();

		BOOL IsSlaveGroup() { return m_fIsSlaveGroup; }

    // Private members
    private:
    	// driver up/down status
    	enum DriverStatus {
    		DriverUp,
    		DriverDown
    	};
    	
        CComPtr<IUnknown> m_pUnkMarshaler;

		// Driver status
		DriverStatus m_Status;
		
        // The object's refcount
		LONG m_cRef;		

		// The usage count and lock are used to
		// handle graceful termination of the dirver:
		LONG m_cUsages;

		// Interface pointer to nntp server
		INntpServer *m_pNntpServer;

		//Termination lock:
		CShareLockNH m_TermLock;
		INewsTree* m_pINewsTree;

		// a bunch of static variables
		static LONG s_cDrivers;	// How may driver instances are up now ?
		static DWORD s_SerialDistributor;
		static LONG s_lThreadPoolRef;

        //
        // Our vroot path ( in MB ).  We may store and retrieve our
        // store driver related private info under that MB path, such
        // as the vroot ( FS directory )
        //
		WCHAR m_wszMBVrootPath[MAX_PATH+1];

        // Absolute path of the vroot directory, in file system
        CHAR m_szFSDir[MAX_PATH+1];

        // Absolute path of the vroot group property file
        CHAR m_szPropFile[MAX_PATH+1];

        // property file lock
        CShareLockNH m_PropFileLock;

        // Flat file object pointer
        CFlatFile *m_pffPropFile;

		// The vroot prefix, such as "alt" in "alt.*"
        CHAR m_szVrootPrefix[MAX_GROUPNAME+1];

        // File system type: fat, ntfs ...
        DWORD   m_dwFSType;

        // Am I a UNC Vroot ?
        BOOL    m_bUNC;

        // Directory notification object
        IDirectoryNotification	*m_pDirNot;

        // Are we in invalidating sec desc mode of the whole tree ?
        LONG    m_lInvalidating;

        // Whether this vroot is from upgrade
        BOOL    m_fUpgrade;

        // Is this _slavegroup?
        BOOL	m_fIsSlaveGroup;
};

////////////////////////////////////////////////////////////////////////

#define MAX_SEARCH_RESULTS 9

class CNntpSearchResults :
	public CIndexServerQuery,		// That's one way to expose MakeQuery..
	public INntpSearchResults {

public:
	CNntpSearchResults(INntpDriverSearch *pDriverSearch);
	~CNntpSearchResults();

public:
	void STDMETHODCALLTYPE
	GetResults (
		IN OUT DWORD *pcResults,
		OUT	BOOL *pfMore,
		OUT	WCHAR **pGroupName,
		OUT	DWORD *pdwArticleID,
		IN	INntpComplete *pICompletion,
		IN	HANDLE	hToken,
		IN	BOOL  fAnonymous,
		IN	LPVOID lpvContext);

	// Implementation of IUnknown interface
	HRESULT __stdcall QueryInterface( const IID& iid, VOID** ppv )
	{
	    if ( iid == IID_IUnknown ) {
			*ppv = static_cast<INntpSearchResults*>(this);
		} else {
			*ppv = NULL;
			return E_NOINTERFACE;
		}
		reinterpret_cast<IUnknown*>(*ppv)->AddRef();
		return S_OK;
	}

	ULONG __stdcall AddRef()
	{
		return InterlockedIncrement( &m_cRef );
	}
	
	ULONG __stdcall Release()
	{
		if ( InterlockedDecrement( &m_cRef ) == 0 ) {
			delete this;
			return 0;
		}
		return m_cRef;
	}

private:				// Not permitted:
	CNntpSearchResults();
	CNntpSearchResults(const CNntpSearchResults&);
	CNntpSearchResults& operator=(const CNntpSearchResults&);

private:
	// Back pointer to the driver search
	// (Also used to hold the refcount for the driver)
	INntpDriverSearch *m_pDriverSearch;
	LONG m_cRef;
};

////////////////////////////////////////////////////////////////////////

//
// Class definition for implementation of prepare interface:
// Prepare interface is used to accept the protocol's connection,
// create driver, and return driver's good interface to the
// protocol.  The driver's good interface has all the features
// that the protocol needs to talk to the file system store.
//
class ATL_NO_VTABLE CNntpFSDriverPrepare :
    public INntpDriverPrepare,
    public CComObjectRoot,
    public CComCoClass<CNntpFSDriverPrepare, &CLSID_CNntpFSDriverPrepare>
{
    // The structure is used to pass connect context into the connecting
    // thread.  the flag is used for synchronization of who should
    // release the completion object
    struct CONNECT_CONTEXT {
        CNntpFSDriverPrepare *pPrepare;
        INntpComplete        *pComplete;
    };

    public:
        HRESULT FinalConstruct();
        VOID    FinalRelease();

    DECLARE_PROTECT_FINAL_CONSTRUCT();

    DECLARE_REGISTRY_RESOURCEID_EX( IDR_StdAfx,
                                    L"NNTP File System Driver Prepare Class",
                                    L"NNTP.FSPrepare.1",
                                    L"NNTP.FSPrepare" );

    DECLARE_GET_CONTROLLING_UNKNOWN();

	BEGIN_COM_MAP(CNntpFSDriverPrepare)
		COM_INTERFACE_ENTRY(INntpDriverPrepare)
		COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
	END_COM_MAP()

	public:

	CNntpFSDriverPrepare() {
	    m_lCancel = 0;
        //m_hConnect = NULL;

        //
        // Create the global thread pool, if necessary
        //
        CNntpFSDriver::s_pStaticLock->ExclusiveLock();
        _VERIFY( CNntpFSDriver::CreateThreadPool() );
        CNntpFSDriver::s_pStaticLock->ExclusiveUnlock();
    }

    ~CNntpFSDriverPrepare() {
        CancelConnect();
        /*
        if ( m_hConnect ) {
            //WaitForSingleObject( m_hConnect, INFINITE );
            //CloseHandle( m_hConnect );
        }
        */

        //
        // We might the the person who is responsible for
        // shutdown the thread pool
        //
        CNntpFSDriver::s_pStaticLock->ExclusiveLock();
        CNntpFSDriver::DestroyThreadPool();
        CNntpFSDriver::s_pStaticLock->ExclusiveUnlock();
    }
	
	// Interfaces
	void STDMETHODCALLTYPE
	Connect( 	LPCWSTR pwszVRootPath,
				LPCSTR pszGroupPrefix,
				IUnknown *punkMetabase,
				INntpServer *pServer,
				INewsTree *pINewsTree,
				INntpDriver **pIGoodDriver,
				INntpComplete *pICompletion,
				HANDLE  hToken,
				DWORD   dwFlag );
				
	HRESULT STDMETHODCALLTYPE
	CancelConnect(){
	    // you can never turn it back to non-cancel, if
	    // it is already in cancel state
	    InterlockedCompareExchange( &m_lCancel, 1, 0 );
	    return S_OK;
	}

	static DWORD WINAPI ConnectInternal(  PVOID pvContext  );

    private:

	// Private methods
	static IUnknown *CreateDriverInstance();

	/*
    static DWORD WINAPI FailRelease( PVOID pvContext ) {
        INntpComplete *pComplete = (INntpComplete*)pvContext;
        pComplete->Release();
        return 0;
    }*/

	// Private members
	private:
		    CComPtr<IUnknown> m_pUnkMarshaler;

		    // Temporarily save the parameters, used by another thread
		    WCHAR   m_wszVRootPath[MAX_PATH+1];
		    CHAR    m_szGroupPrefix[MAX_NEWSGROUP_NAME+1];
		    IUnknown *m_punkMetabase;
		    INntpServer *m_pServer;
		    INewsTree *m_pINewsTree;
		    INntpDriver **m_ppIGoodDriver;
		    HANDLE  m_hToken;
		    DWORD   m_dwConnectFlags;
		
		
		    LONG    m_lCancel;      //1: to cancel, 0, not cancel
		    //HANDLE  m_hConnect;     // The connect event
};

//
// Class definition for CNntpFSDriverPrepare's connection work item
//
class CNntpFSDriverConnectWorkItem : public CNntpFSDriverWorkItem   //fc
{
public:
    CNntpFSDriverConnectWorkItem( PVOID pvContext ):CNntpFSDriverWorkItem( pvContext ) {};
    virtual ~CNntpFSDriverConnectWorkItem(){};

    virtual VOID Complete() {

        //
        // Call the prepare driver's static connect method
        //
        CNntpFSDriverPrepare::ConnectInternal( m_pvContext );

        delete m_pvContext;
        m_pvContext = NULL;
    }
};

//
// This class defines the cancel hint that we expose to root scan object.
//
class CNntpFSDriverCancelHint : public CCancelHint {

public:

    //
    // Constructor
    //
    CNntpFSDriverCancelHint( INntpServer *pServer )
        : m_pServer( pServer )
    {}

    virtual BOOL IShallContinue() {

        //
        // Ask the server whether we should continue
        //
        return m_pServer->ShouldContinueRebuild();
    }

private:

    //
    // Pointer to the server interface
    //
    INntpServer *m_pServer;
};

//
// Class that defines the root scan logic: what's the needs of root scan for
// the file system driver, whether we should skip the empty directories that
// has no messages in it ? ...
//
class CNntpFSDriverRootScan : public CRootScan {

public:

    CNntpFSDriverRootScan(  LPSTR           szRoot,
                            BOOL            fSkipEmpty,
                            CNntpFSDriver   *pDriver,
                            CCancelHint     *pCancelHint )
        : CRootScan( szRoot, pCancelHint ),
          m_fSkipEmpty( fSkipEmpty ),
          m_pDriver( pDriver )
    {}

protected:

    virtual BOOL NotifyDir( LPSTR szPath );

private:

    //////////////////////////////////////////////////////////////////////////
    // Private variables
    //////////////////////////////////////////////////////////////////////////
    //
    // Should I skip the empty directories ?
    //
    BOOL m_fSkipEmpty;

    //
    // Driver context
    //
    CNntpFSDriver *m_pDriver;

    //////////////////////////////////////////////////////////////////////////
    // Private methods
    //////////////////////////////////////////////////////////////////////////
    BOOL HasPatternFile(  LPSTR szPath, LPSTR szPattern );
    BOOL CNntpFSDriverRootScan::HasSubDir( LPSTR szPath );
    BOOL WeShouldSkipThisDir( LPSTR szPath );
    BOOL CreateGroupInTree( LPSTR szPath, INNTPPropertyBag **ppPropBag );
    BOOL CreateGroupInVpp( INNTPPropertyBag *pPropBag );
};

//
// Extern variables
//
extern CNntpFSDriverThreadPool *g_pNntpFSDriverThreadPool;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsthrd.h ===
/******************************************************************************

Copyright (c) 1998 Microsoft Corporation
All rights reserved.

Modula:

    fsthrd.h

Abstract:

    This thread pool object handles all FSDriver's thread pool works. 
    It derives from CThreadPool ( by RajeevR ).
    
Authors:

    KangYan      Kangrong Yan     Sept. 17, 1998

History:
    09/17/98    KangYan      Created

******************************************************************************/

#ifndef _FSTHRD_H_
#define _FSTHRD_H_
#include <thrdpl2.h>

//
// Class definition for file system driver's work item.
// Derived classes should implement what should be done
// by the thread
//
class CNntpFSDriverWorkItem   //fw
{
public:
    CNntpFSDriverWorkItem( PVOID pvContext ) : m_pvContext( pvContext ) {};
    virtual ~CNntpFSDriverWorkItem(){};
    virtual VOID Complete() = 0;

protected:

    PVOID   m_pvContext;
};


//
// Class definition for file system driver's thread pool
//
class CNntpFSDriverThreadPool : public CThreadPool  //fp
{
    
public:
    CNntpFSDriverThreadPool(){};
    ~CNntpFSDriverThreadPool(){};

protected:
    virtual VOID
    WorkCompletion( PVOID pvWorkContext) {
        //
        // I know that the WorkContext passed in must 
        // be CNntpFSDriverWorkItem
        //
        CNntpFSDriverWorkItem *pWorkItem = (CNntpFSDriverWorkItem*)pvWorkContext;
        _ASSERT( pWorkItem );

        pWorkItem->Complete();

        delete pWorkItem;
    }

    //
    // This function implements cleaning up of the thread pool
    //
    virtual VOID
    AutoShutdown() {

        //
        // Call the thread pool's terminate, notice that it should not wait for 
        // the handle of himself because thread pool's Terminate implementation
        // will skip our own thread handle
        //
        Terminate( FALSE, FALSE );

        //
        // Delete myself
        //
        XDELETE this;

        //
        // The pool is gone, decrement the module lock
        //
        _Module.Unlock();
    }
};

#endif // _FSTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\nntpfs.h $(O)\nntpfs_i.c : nntpfs.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpfs_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpfs_i.c \
    -header $@ \
    -tlb $(O)\nntpfs.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsutil.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fsutil.h

Abstract:

    Utility functions that doesn't logically fit in fsdriver object.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/
#ifndef _FSUTIL_H_
#define _FSUTIL_H_
DWORD ArticleIdMapper( DWORD );
HANDLE FindFirstDir( IN LPSTR szRoot, IN WIN32_FIND_DATA& FindData );
BOOL FindNextDir( IN HANDLE hFindHandle, IN WIN32_FIND_DATA& FindData );
HRESULT ObtainGroupNameFromPath(   IN LPSTR    szPath,
                                   OUT LPSTR   szBuffer,
                                   IN OUT DWORD&   cbSize );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\nntpfs.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    nntpfs.cpp

Abstract:

    This is the implementation for the file system store driver class.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include "nntpdrv.h"
#include "nntpfs.h"
#include "fsdriver.h"
#include "fsutil.h"
#include "nntpdrv_i.c"
#include "nntpfs_i.c"
#include "mailmsg_i.c"
#include "parse.h"
#include "tflist.h"
#include "watchci.h"
#include <stdio.h>

////////////////////////////////////////////////////////////////////////////
// Macros
////////////////////////////////////////////////////////////////////////////
#define MAX_FILE_SYSTEM_NAME_SIZE    ( MAX_PATH)
#define DIRNOT_RETRY_TIMEOUT            60
#define DIRNOT_INSTANCE_SIZE            1024
#define DIRNOT_MAX_INSTANCES            128     // BUGBUG: This makes very bad limit
                                                // of how many file system
                                                // vroots we can have

////////////////////////////////////////////////////////////////////////////
// Global variables
////////////////////////////////////////////////////////////////////////////
DWORD CNntpFSDriver::s_SerialDistributor = 0;
LONG CNntpFSDriver::s_cDrivers = 0;
CShareLockNH *CNntpFSDriver::s_pStaticLock = NULL;
LPCSTR g_szArticleFileExtension = ".nws";
LONG CNntpFSDriver::s_lThreadPoolRef = 0;
CNntpFSDriverThreadPool *g_pNntpFSDriverThreadPool = NULL;
BOOL    g_fBackFillLines = FALSE;   // dummy global var that is not used

static CWatchCIRoots s_TripoliInfo;

static const char g_szSlaveGroupPrefix[] = "_slavegroup";

// Max buffer size for xover
const DWORD cchMaxXover = 3400;
const CLSID CLSID_NntpFSDriver = {0xDEB58EBC,0x9CE2,0x11d1,{0x91,0x28,0x00,0xC0,0x4F,0xC3,0x0A,0x64}};

// Guid to uniquely identify the FS driver
// {E7EE82C6-7A8C-11d2-9F04-00C04F8EF2F1}
static const GUID GUID_NntpFSDriver =
	{0xe7ee82c6, 0x7a8c, 0x11d2, { 0x9f, 0x4, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xf1} };

//
// Function to convert LastError into hresult, taking a default value
// if the LastError was not set
//

HRESULT HresultFromWin32TakeDefault( DWORD  dwWin32ErrorDefault )
{
    DWORD   dwErr = GetLastError();
    return HRESULT_FROM_WIN32( (dwErr == NO_ERROR) ? dwWin32ErrorDefault : dwErr );
}

////////////////////////////////////////////////////////////////////////////
// interfaces INntpDriver implementation
////////////////////////////////////////////////////////////////////////////
//
// Static initialization for all driver instances
//
// Rule for all init, term functions:
// If init failed, init should roll back and term never gets
// called.
//
HRESULT
CNntpFSDriver::StaticInit()
{
	TraceFunctEnter( "CNntpFSDriver::StaticInit" );
	_ASSERT( CNntpFSDriver::s_cDrivers >= 0 );

	HRESULT hr = S_OK;
	DWORD	cchMacName = MAX_COMPUTERNAME_LENGTH;
	BOOL    bArtInited = FALSE;
	BOOL    bCacheInited = FALSE;
	BOOL    bDirNotInited = FALSE;

	s_pStaticLock->ExclusiveLock();	// I don't want two drivers'
									// init enter here at the
									// same time

	if ( InterlockedIncrement( &CNntpFSDriver::s_cDrivers ) > 1 ) {
		// we shouldn't proceed, it has already been initialized
		DebugTrace( 0, "I am not the first driver" );
		goto Exit;
	}

	//
	// The global thread pool should have already been created
	// at this point: it should always be created by the first
	// prepare driver
	//
	_ASSERT( g_pNntpFSDriverThreadPool );

	//
	// But we should still call CreateThreadPool to pair up the
	// thread pool ref count
	//
	if( !CreateThreadPool() ) {
	    _ASSERT( 0 );
	    FatalTrace( 0, "Can not create thread pool %d", GetLastError() );
	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
	    goto Exit;
	}

    // Initialize article class
    if ( ! CArticleCore::InitClass() ) {
    	FatalTrace( 0, "Can not initialze artcore class %d", GetLastError() );
    	hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
		goto Exit;
	}

    bArtInited = TRUE;

	// Initialize the file handle cache
	if ( !InitializeCache() ) {
	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
        FatalTrace( 0, "Can not init file handle cache %x", hr );
        goto Exit;
    }

    bCacheInited = TRUE;

    // Initialize global stuff for dirnot
    hr = IDirectoryNotification::GlobalInitialize(  DIRNOT_RETRY_TIMEOUT,
                                                    DIRNOT_MAX_INSTANCES * 2,
                                                    DIRNOT_INSTANCE_SIZE,
                                                    NULL    );
	if (FAILED(hr)) {
		ErrorTrace( 0, "Global initialization of DirNot failed %x", hr );
		goto Exit;
	}

	bDirNotInited = TRUE;

	// Initialize the index server query object
	hr = CIndexServerQuery::GlobalInitialize();
	if (FAILED(hr)) {
		ErrorTrace( 0, "Global initialization of CIndexServerQuery failed %x", hr );
		hr = S_OK;		// Silently fail
	}

	hr = s_TripoliInfo.Initialize(L"System\\CurrentControlSet\\Control\\ContentIndex");
	if (FAILED(hr)) {
		ErrorTrace( 0, "Initialization of CWatchCIRoots failed %x", hr );
		hr = S_OK;		// Silently fail
	}

Exit:
	//
	// If init failed, we should roll back to the old state, in
	// order not to confuse the termination work
	//
	if ( FAILED( hr ) ) {
		InterlockedDecrement( &s_cDrivers );
		_ASSERT( 0 == s_cDrivers );

		if ( bArtInited ) CArticleCore::TermClass();
		if ( bCacheInited ) TerminateCache();
		if ( bDirNotInited ) IDirectoryNotification::GlobalShutdown();
	}

	s_pStaticLock->ExclusiveUnlock();
	TraceFunctLeave();

	return hr;
}

//
// Static termination for all driver instances
//
VOID
CNntpFSDriver::StaticTerm()
{
	TraceFunctEnter( "CNntpFSDriver::StaticTerm" );
	_ASSERT( CNntpFSDriver::s_cDrivers >= 0 );

	s_pStaticLock->ExclusiveLock();	// I don't want two drivers'
									// Term enter here at the
									// same time
	if ( InterlockedDecrement( &CNntpFSDriver::s_cDrivers ) > 0 ) {
		// we shouldn't proceed, we are not the last guy
		DebugTrace( 0, "I am not the last driver" );
		goto Exit;
	}

    // Terminate article class
    CArticleCore::TermClass();

    // Terminate the file handle cache
    TerminateCache();

    // Shutdown dirnot
    IDirectoryNotification::GlobalShutdown();

    // Terminate the query object
    CIndexServerQuery::GlobalShutdown();

    // Get rid of the tripoli info
    s_TripoliInfo.Terminate();

    //
    // We might be the person to shutdown the global thread
    // pool, since Prepare driver could go away earlier than
    // we do.  The destroy method was ref-counted.
    //
    DestroyThreadPool();

Exit:
   	s_pStaticLock->ExclusiveUnlock();
	TraceFunctLeave();
}

BOOL
CNntpFSDriver::CreateThreadPool()
/*++
Routine Description:

    Create the global thread pool.

Arguments:

    None.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CreateThreadPool" );

    if ( InterlockedIncrement( &s_lThreadPoolRef ) == 1 ) {

        //
        // Increment the module ref count, it will be decremented when
        // we destroy the thread pool in the call back
        //
        _Module.Lock();

        g_pNntpFSDriverThreadPool = XNEW CNntpFSDriverThreadPool;
        if ( NULL == g_pNntpFSDriverThreadPool ) {
            _Module.Unlock();
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        if ( !g_pNntpFSDriverThreadPool->Initialize(    0, // as many as procs
                                                        POOL_MAX_THREADS,
                                                        POOL_START_THREADS ) ) {
            g_pNntpFSDriverThreadPool->Terminate( TRUE );
            XDELETE g_pNntpFSDriverThreadPool;
            g_pNntpFSDriverThreadPool = NULL;
            _Module.Unlock();
            return FALSE;
        }

        //
        // Call thread pool's beginjob here, don't know if there is
        // a better place to do this
        //
        g_pNntpFSDriverThreadPool->BeginJob( NULL );
    } else {

        _ASSERT( g_pNntpFSDriverThreadPool );
    }

    TraceFunctLeave();
    return TRUE;
}

VOID
CNntpFSDriver::DestroyThreadPool()
/*++
Routine Description:

    Destroy the global thread pool

Arguments:

    None.

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::DestroyThreadPool" );

    if ( InterlockedDecrement( &s_lThreadPoolRef ) == 0 ) {

#ifdef DEADLOCK
        //
        // Wait for the thread's job to complete
        //
        _ASSERT( g_pNntpFSDriverThreadPool );
        g_pNntpFSDriverThreadPool->WaitForJob( INFINITE );

        //
        // Terminate the global thread pool
        //
        g_pNntpFSDriverThreadPool->Terminate( FALSE );
        XDELETE g_pNntpFSDriverThreadPool;
#endif
        //
        // Get all the threads out of the loop
        //
        _ASSERT( g_pNntpFSDriverThreadPool );
        g_pNntpFSDriverThreadPool->ShrinkAll();

        //
        // The thread pool will shut itself down, no
        // need to destroy it
        //
        g_pNntpFSDriverThreadPool = NULL;
    }
}

HRESULT STDMETHODCALLTYPE
CNntpFSDriver::Initialize(  IN LPCWSTR     pwszVRootPath,
							IN LPCSTR		pszGroupPrefix,
							IN IUnknown	   *punkMetabase,
                            IN INntpServer *pServer,
                            IN INewsTree   *pINewsTree,
                            IN LPVOID		pvContext,
                            OUT DWORD      *pdwNDS,
                            IN HANDLE       hToken )
/*++
Routine Description:

    All the initiliazation work for the store driver.

Arguments:

    IN LPCWSTR pwszVRootPath    - The MD vroot path of this driver
    IN IUnknown *punkLookup     - Interface pointer to lookup service
    IN IUnknown *punkNewsTree   - Interface pointer to news tree
    OUT DWORD pdwNDS            - The store driver status to be returned

Return value:

    S_OK            - Initialization succeeded.
    NNTP_E_DRIVER_ALREADY_INITIALIZED - The store driver
						has already been initialized.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::Initialize" );
	_ASSERT( lstrlenW( pwszVRootPath ) <= MAX_PATH );
	_ASSERT( pINewsTree );
	_ASSERT( pServer );

	BOOL	bStaticInited = FALSE;
	VAR_PROP_RECORD vpRecord;
	DWORD           cData = 0;
	WCHAR           wszFSDir[MAX_PATH+1];
    PINIT_CONTEXT	pInitContext = (PINIT_CONTEXT)pvContext;

    HRESULT hr = S_OK;

	// Grab the usage exclusive lock, so that no one can enter
	// before we are done with initialization
	m_TermLock.ExclusiveLock();

	// Are we up already ?
	if ( DriverDown != m_Status ) {
	    DebugTrace(0, "Multiple init of store driver" );
        hr = NNTP_E_DRIVER_ALREADY_INITIALIZED;
        goto Exit;
    } else m_Status = DriverUp;	// no interlock needed

	// Do static initialization stuff
	hr = StaticInit();
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Driver static initialization failed %x", hr );
		goto Exit;	// no need to call StaticTerm
	}

	bStaticInited = TRUE;

	// Store the MB Path
	_ASSERT( pwszVRootPath );
	_ASSERT( lstrlenW( pwszVRootPath ) <= MAX_PATH );
	lstrcpyW( m_wszMBVrootPath, pwszVRootPath );

	hr = ReadVrootInfo( punkMetabase );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Read Vroot info failed %x", hr );
		goto Exit;
	}

	if ( m_bUNC ) {
	    if ( !ImpersonateLoggedOnUser( hToken ) ) {
	        hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
	        ErrorTrace( 0, "Impersonation failed %x", hr );
	        goto Exit;
	    }
	}

	// Create the dirs
	if ( !CreateDirRecursive( m_szFSDir ) ) {
    	FatalTrace(	0,
        			"Could not create directory %s  error %d",
            		m_szFSDir,
            		GetLastError());
        hr = HresultFromWin32TakeDefault( ERROR_ALREADY_EXISTS );
        if ( m_bUNC ) RevertToSelf();
	    goto Exit;
    }

    // remember the nntpserver / newstree interafce
	m_pNntpServer = pServer;
	m_pINewsTree = pINewsTree;

	// check if the vroot was upgraded
	if ( pInitContext->m_dwFlag & NNTP_CONNECT_UPGRADE ) m_fUpgrade = TRUE;

	// Create and initialize the flatfile object
	hr = InitializeVppFile();
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Initialize vpp file failed %x", hr );
	    if ( m_bUNC ) RevertToSelf();
	    goto Exit;
	}

	// Initialize dirnot
	CopyAsciiStringIntoUnicode( wszFSDir, m_szFSDir );
    if ( *wszFSDir && *(wszFSDir+wcslen(wszFSDir)-1) == L':' )
        wcscat( wszFSDir, L"\\" );
	m_pDirNot = new IDirectoryNotification;
	if ( NULL == m_pDirNot ) {
	    _ASSERT( 0 );
	    hr = E_OUTOFMEMORY;
	    if ( m_bUNC ) RevertToSelf();
	    ErrorTrace( 0, "Out of memory" );
	    goto Exit;
	}

	hr = m_pDirNot->Initialize( wszFSDir,   // root to watch
	                            this,       // context
	                            TRUE,       // watch sub tree
	                            FILE_NOTIFY_CHANGE_SECURITY,
	                            FILE_ACTION_MODIFIED,
	                            InvalidateGroupSec,
	                            InvalidateTreeSec,
	                            FALSE       // don't append startup entry
	                            );
	if ( FAILED( hr ) ) {
	    m_pDirNot = NULL;
	    if ( m_bUNC ) RevertToSelf();
	    ErrorTrace( 0, "Initialize dirnot failed %x", hr );
	    goto Exit;
	}

	if ( m_bUNC ) RevertToSelf();

	strcpy( m_szVrootPrefix, pszGroupPrefix );

	m_fIsSlaveGroup = (_stricmp(pszGroupPrefix, g_szSlaveGroupPrefix) == 0);

Exit:

	_ASSERT( punkMetabase );
	//punkMetabase->Release();
	// this should be released outside

	// If init failed, roll back
	if ( FAILED( hr ) && NNTP_E_DRIVER_ALREADY_INITIALIZED != hr ) {
		m_Status = DriverDown;
		if ( m_pffPropFile ) XDELETE m_pffPropFile;
		if ( m_pDirNot ) XDELETE m_pDirNot;
		if ( bStaticInited ) StaticTerm();
	}

	m_TermLock.ExclusiveUnlock();
    TraceFunctLeave();

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNntpFSDriver::Terminate( OUT DWORD *pdwNDS )
/*++
Routine description:

    Store driver termination.

Arguments:

    OUT DWORD   *pdwNDS - Store driver status

Return value:

    S_OK - Succeeded
    NNTP_E_DRIVER_NOT_INITIALIZED - Driver not initialized at all
--*/
{
    TraceFunctEnter( "CNntpFSDriver::Terminate" );

    HRESULT hr = S_OK;
    LONG 	lUsages;

	// Grab termination exclusive lock
	m_TermLock.ExclusiveLock();

	// Are we up ?
	if ( m_Status != DriverUp ) {
		ErrorTrace( 0, "Trying to shutdown someone not up" );
		m_TermLock.ExclusiveUnlock();
		return NNTP_E_DRIVER_NOT_INITIALIZED;
	} else m_Status = DriverDown;

	// wait for the usage count to drop to 1
	while ( ( lUsages = InterlockedCompareExchange( &m_cUsages, 0, 0 )) != 0 ) {
		Sleep( TERM_WAIT );	// else wait
	}

	// Shutdown dirnot and delete dirnot object
    if ( m_pDirNot ) {

        //
        // Should clean the retry queue first
        //
        m_pDirNot->CleanupQueue();

        _VERIFY( SUCCEEDED( m_pDirNot->Shutdown() ) );
        delete m_pDirNot;
        m_pDirNot = NULL;
    }

   	_ASSERT( m_pNntpServer );
   	if ( m_pNntpServer ) m_pNntpServer->Release();

   	_ASSERT( m_pINewsTree );
   	if ( m_pINewsTree ) m_pINewsTree->Release();

    // Delete flatfile object
    if ( m_pffPropFile ) {
    	TerminateVppFile();
    }

    // Throw away anything that might be in the file handle cache for this vroot
    CacheRemoveFiles( m_szFSDir, TRUE );

    // static terminate stuff
    StaticTerm();

	m_TermLock.ExclusiveUnlock();
    TraceFunctLeave();

	return hr;
}

void STDMETHODCALLTYPE
CNntpFSDriver::CreateGroup( 	IN INNTPPropertyBag *pPropBag,
                                IN HANDLE   hToken,
								IN INntpComplete *pICompletion,
								IN BOOL     fAnonymous )
/*++
Routine description:

	Create a news group.

Arguments:

	IN IUnknown *punkPropBag - IUnknown interface to the group's
								property bag
	IN HANDLE hToken - The client's access token.
	IN INntpComplete *pICompletion - Completion object's interface

Return value:

	S_OK on success, HRESULT error code otherwise
--*/
{
	TraceFunctEnter( "CNntpFSDriver::CreateGroup" );
	_ASSERT( pPropBag );
	_ASSERT( pICompletion );

	HRESULT				hr;
	CHAR				szGroupName[MAX_GROUPNAME+1];
	CHAR				szFullPath[MAX_PATH+1];
	DWORD				dwLen;
	VAR_PROP_RECORD		vpRecord;
	DWORD				dwOffset;
	BOOL                bImpersonated = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// Get directory path to create
	GroupName2Path( szGroupName, szFullPath );
	DebugTrace( 0, "The path converted is %s", szFullPath );

    hr = CreateGroupInVpp( pPropBag, dwOffset );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Create group into vpp file failed %x", hr );
        goto Exit;
    }

    // If I am UNC Vroot, impersonate here
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		    ErrorTrace( 0, "Impersonation failed %x", hr );
		    goto Exit;
		}
    }

    // Create the directory, if it doesn't exist
    if ( !CreateDirRecursive( szFullPath, hToken ) ) {

	    ErrorTrace( 0, "Create dir fail %d", GetLastError() );
	    hr = HresultFromWin32TakeDefault( ERROR_ALREADY_EXISTS );
        if ( m_bUNC ) RevertToSelf();

        // We need to remove the record in property file
		_ASSERT( dwOffset != 0xffffffff );

        // What do we do if we failed deletion ? still fail
        m_PropFileLock.ExclusiveLock();
        m_pffPropFile->DirtyIntegrityFlag();
		m_pffPropFile->DeleteRecord( dwOffset );
		m_pffPropFile->SetIntegrityFlag();
		m_PropFileLock.ExclusiveUnlock();

		goto Exit;
    }

    if ( m_bUNC ) RevertToSelf();

Exit:

	// Release the property bag interface
	if ( pPropBag ) {
		//pPropBag->Release();
		pICompletion->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	pICompletion->SetResult( hr );
	pICompletion->Release();

	// request completed, decrement the usage count
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void STDMETHODCALLTYPE
CNntpFSDriver::RemoveGroup(	IN INNTPPropertyBag *pPropBag,
                            IN HANDLE   hToken,
							IN INntpComplete *pICompletion,
							IN BOOL     fAnonymous )
/*++
Routine description:

	Remove a news group physically from file system

Arguments:

	IN INNTPPropertyBag *pPropBag - The news group's property bag
	IN HANDLE   hToken - The client's access token
	IN INntpComplete *pICompletion - Completion object

Return value:

	S_OK On success, HRESULT error code otherwise
--*/
{
	TraceFunctEnter( "CNntpFSDriver::RemoveGroup" );
	_ASSERT( pPropBag );
	_ASSERT( pICompletion );

	CHAR	szFullPath[MAX_PATH+1];
	CHAR	szGroupName[MAX_GROUPNAME+1];
	CHAR	szFileName[MAX_PATH+1];

	DWORD	dwLen;
	CHAR	szFindWildmat[MAX_PATH+1];
	HANDLE	hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA	findData;
	BOOL	bFound;
	DWORD	dwOffset;
	HRESULT hr;

	BOOL    bImpersonated = FALSE;


	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();


	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// Get directory path to remove
	GroupName2Path( szGroupName, szFullPath );
	DebugTrace( 0, "The path converted is %s", szFullPath );
	dwLen = strlen( szFullPath );
	_ASSERT( dwLen <= MAX_PATH );

	//
	// Clean up the diretory:
	// Protocol should have cleaned up all the messages under
	// the group directory.  But in case there is any junk
	// under the directory, we still do a findfirst/findnext and
	// remove those files before deleting the whole directory
	//
	strcpy( szFindWildmat, szFullPath );
	if ( *(szFindWildmat + dwLen - 1 ) != '\\' ) {
		*(szFindWildmat + dwLen) = '\\';
		*(szFindWildmat + dwLen + 1) = 0;
	}
	strcat( szFindWildmat, "*" );
	DebugTrace( 0, "Find wildmat is %s", szFindWildmat );
	_ASSERT( strlen( szFindWildmat ) <= MAX_PATH );

    // Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	hFind = FindFirstFile( szFindWildmat, &findData );
	bFound = ( hFind != INVALID_HANDLE_VALUE );
	while ( bFound ) {

		// The group dirctory shouldn't contain sub-dir
		if ( IsChildDir( findData ) ) {
			ErrorTrace( 0, "Group directory contain sub-dir" );
			hr = E_INVALIDARG;	// the group name is invalid
			goto Exit;
		}

		// If found "." or "..", continue finding
		if ( strcmp( findData.cFileName, "." ) == 0 ||
			 strcmp( findData.cFileName, ".." ) == 0 )
			 goto FindNext;

		hr = MakeChildDirPath(	szFullPath,
								findData.cFileName,
								szFileName,
								MAX_PATH );
		if ( FAILED( hr ) ) {
			ErrorTrace(0, "Make child dir fail %x", hr );
			goto Exit;
		}

		// Delete this file
		if ( !DeleteFile( szFileName ) ) {
			ErrorTrace(0, "File delete failed %d", GetLastError() );
			hr = HresultFromWin32TakeDefault( ERROR_PATH_NOT_FOUND );
			goto Exit;
		}

FindNext:
		// Find next file
		bFound = FindNextFile( hFind, &findData );
	}

	// Close the find handle
	FindClose( hFind );
	hFind = INVALID_HANDLE_VALUE;

	// Now delete the directory
	if ( !RemoveDirectory( szFullPath ) ) {
		ErrorTrace( 0, "Removing directory failed %d", GetLastError() );
		hr = HresultFromWin32TakeDefault( ERROR_PATH_NOT_FOUND );
		goto Exit;
	}

	// Revert to self, if necessary
	if ( bImpersonated ) {
	    RevertToSelf();
	    bImpersonated = FALSE;
	}

	// Delete the record in flat file, should retrieve offset
	// first
	hr = pPropBag->GetDWord( NEWSGRP_PROP_FSOFFSET, &dwOffset );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Get offset property failed %x", hr );
		goto Exit;
	}
	_ASSERT( 0xffffffff != dwOffset );
	m_PropFileLock.ExclusiveLock();

	//
	// Before vpp operation, dirty integrity
	//
	hr = m_pffPropFile->DirtyIntegrityFlag();
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Dirty integrity failed %x", hr );
	    m_PropFileLock.ExclusiveUnlock();
	    goto Exit;
	}

	hr = m_pffPropFile->DeleteRecord( dwOffset );
	if ( FAILED( hr ) ) {

	    //
	    // We should still set integrity flag
	    //
	    m_pffPropFile->SetIntegrityFlag();
		ErrorTrace( 0, "Delete record in flatfile failed %x" , hr );
		m_PropFileLock.ExclusiveUnlock();
		goto Exit;
	}

	//
	// After vpp operation, set integrity flag
	//
	hr = m_pffPropFile->SetIntegrityFlag();
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Set integrity flag failed %x", hr );
	    m_PropFileLock.ExclusiveUnlock();
	    goto Exit;
	}

	//
	// Unlock it
	//
	m_PropFileLock.ExclusiveUnlock();

	// Now reset offset, this may not be necessary.
	hr = pPropBag->PutDWord( NEWSGRP_PROP_FSOFFSET, 0xffffffff );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Put offset property fail %x", hr );
		goto Exit;
	}

Exit:

	if ( INVALID_HANDLE_VALUE != hFind ) {
		FindClose( hFind );
		hFind = INVALID_HANDLE_VALUE;
	}

	if ( bImpersonated ) RevertToSelf();

	if ( pPropBag ) {
		//pPropBag->Release();
		pICompletion->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	pICompletion->SetResult( hr );
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void STDMETHODCALLTYPE
CNntpFSDriver::SetGroupProperties( INNTPPropertyBag *pNewsGroup,
                                   DWORD   cProperties,
                                   DWORD   *rgidProperties,
                                   HANDLE   hToken,
                                   INntpComplete *pICompletion,
                                   BOOL fAnonymous )
/*++
Routine description:

    Set group properties into driver owned property file
    ( right now only helptext, prettyname, moderator can be
        set )

Arguments:

    INNTPPropertyBag *pNewsGroup - The newsgroup property bag
    DWORD cProperties - Number of properties to set
    DWORD *rgidProperties - Array of property id's to set
    HANDLE hToken - The client's access token
    INntpComplete *pICompletion - Completion object

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::SetGroupProperties" );
    _ASSERT( pNewsGroup );
    _ASSERT( rgidProperties );
    _ASSERT( pICompletion );

    HRESULT hr = S_OK;
    DWORD   dwOffset;
    VAR_PROP_RECORD vpRecord;
    BOOL    bImpersonated = FALSE;


    // Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

    // Get offset properties
    hr = pNewsGroup->GetDWord(  NEWSGRP_PROP_FSOFFSET,
                                &dwOffset );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Group doesn't have offset" );
        goto Exit;
    }

    // We ignore the property list here, and we'll always set
    // all the var properties again.  Because doing do is not
    // much more expensive than writing a particular property,
    // which is different than exchange store case
    hr = Group2Record(  vpRecord, pNewsGroup );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Group 2 record failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    // Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

    //
    // Before any vpp operation, dirty the integrity flag
    //
    m_PropFileLock.ExclusiveLock();
    hr = m_pffPropFile->DirtyIntegrityFlag();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Dirty vpp file's integrity failed %x", hr);
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    // Save the record back to the flatfile
    // Delete first and then insert
    hr = m_pffPropFile->DeleteRecord( dwOffset );
    if ( FAILED( hr ) ) {
        m_pffPropFile->SetIntegrityFlag();
        ErrorTrace(0, "Delete record failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    hr = m_pffPropFile->InsertRecord(   PBYTE(&vpRecord),
                                        RECORD_ACTUAL_LENGTH( vpRecord ),
                                        &dwOffset );
    if ( FAILED( hr ) ) {
        //m_pffPropFile->SetIntegrityFlag();
        ErrorTrace( 0, "Insert record failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    //
    // After vpp operation, set integrity flag
    //
    hr = m_pffPropFile->SetIntegrityFlag();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set vpp file's integrity failed %x", hr);
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    // Set offset back into the bag
    hr = pNewsGroup->PutDWord(  NEWSGRP_PROP_FSOFFSET,
                                dwOffset );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Put offset into bag failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    m_PropFileLock.ExclusiveUnlock();

Exit:

    if ( bImpersonated ) RevertToSelf();

	if ( pNewsGroup ) {
		//pNewsGroup->Release();
		pICompletion->ReleaseBag( pNewsGroup );
		pNewsGroup = NULL;
	}

	pICompletion->SetResult( hr );
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void
CNntpFSDriver::GetArticle(	IN INNTPPropertyBag *pPrimaryGroup,
                            IN INNTPPropertyBag *pCurrentGroup,
                            IN ARTICLEID    idPrimaryArt,
							IN ARTICLEID	idCurrentArt,
							IN STOREID		idStore,
							IN HANDLE       hToken,
							OUT VOID		**ppvFileHandleContext,
							IN INntpComplete	*pICompletion,
							IN BOOL         fAnonymous )
/*++
Routine description:

	Get an article from the driver

Arguments:

	IN IUnknown *punkPropBag - The property bag pointer
	IN ARTICLEID idArt - The article id to get
	IN STOREID idStore - I ignore  it
	IN HANDLE   hToken - The client's access token
	OUT HANDLE *phFile - Buffer for the opened handle
	IN INntpComplete *pICompletion - completion object
--*/
{
	TraceFunctEnter( "CNntpFSDriver::GetArticle" );
	_ASSERT( pPrimaryGroup );
	_ASSERT( ppvFileHandleContext );
	_ASSERT( pICompletion );

	HRESULT 			hr;
	DWORD				dwLen;
	CHAR				szGroupName[MAX_GROUPNAME+1];
	CHAR				szFullPath[MAX_PATH+1];
	PFIO_CONTEXT        phcFileHandleContext = NULL;
	CREATE_FILE_ARG     arg;
	BOOL                bImpersonated = FALSE;

	arg.bUNC = m_bUNC;
	arg.hToken = hToken;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPrimaryGroup->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		//pPrimaryGroup->Release();
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// I may release the property bag now
	//pPrimaryGroup->Release(); Moved to Exit

	// I should release the current bag anyway, even if I don't
	// need to use it
	//if ( pCurrentGroup ) pCurrentGroup->Release();    Moved to Exit

	// Make up the file name based on article id
	dwLen = MAX_PATH;
	hr = ObtainFullPathOfArticleFile(	szGroupName,
										idPrimaryArt,
										szFullPath,
										dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Failed to obtain article full path %x", hr );
		goto Exit;
	}

	// Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	// Open the file for read.  If this is an article in _slavegroup, then
	// we don't bother to put it in the cache.

	if (IsSlaveGroup()) {

        HANDLE hFile = CreateFileA(
                        szFullPath,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_READONLY |
                        FILE_FLAG_SEQUENTIAL_SCAN |
                        FILE_FLAG_OVERLAPPED,
                        NULL
                        ) ;
        if( hFile != INVALID_HANDLE_VALUE ) {
            phcFileHandleContext = AssociateFile(hFile);
        }

        if (hFile == INVALID_HANDLE_VALUE || phcFileHandleContext == NULL) {
            hr = HresultFromWin32TakeDefault( ERROR_FILE_NOT_FOUND );
            ErrorTrace( 0, "Failed to create file %x", hr );
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(hFile);
            }
            goto Exit;
        }


    } else {
	    phcFileHandleContext = CacheCreateFile( szFullPath,
                                                CreateFileCallback,
                                                PVOID(&arg),
                                                TRUE) ;
        if ( NULL == phcFileHandleContext ) {
            hr = HresultFromWin32TakeDefault( ERROR_FILE_NOT_FOUND );
            ErrorTrace( 0, "Failed to create file from handle cache %x", hr );
            goto Exit;
        }
    }

    //
    //  Outbound case here is how to handle terminated dot:
    //  1) Exchange store driver - set the bit in m_ppfcFileContext to "No dot"
    //  2) NNTP FS driver - set the bit in m_ppfcFileContext to "Has dot"
    //  Protocol will base on this flag to decide whether to add dot, or not during
    //  TransmitFile().
    //
    SetIsFileDotTerminated( phcFileHandleContext, TRUE );

    // Set this context
    *ppvFileHandleContext = phcFileHandleContext;

Exit:

    if ( bImpersonated ) RevertToSelf();

    // Releaes bags
    if ( pPrimaryGroup ) {
        //pPrimaryGroup->Release();
        pICompletion->ReleaseBag( pPrimaryGroup );
        pPrimaryGroup = NULL;
    }

    if ( pCurrentGroup ) {
        //pCurrentGroup->Release();
        pICompletion->ReleaseBag( pCurrentGroup );
        pCurrentGroup = NULL;
    }

	pICompletion->SetResult( hr );
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void
CNntpFSDriver::DeleteArticle(     INNTPPropertyBag *pPropBag,
                   DWORD            cArticles,
                   ARTICLEID        rgidArt[],
                   STOREID          rgidStore[],
                   HANDLE           hToken,
                   DWORD            *pdwLastSuccess,
                   INntpComplete    *pICompletion,
                   BOOL             fAnonymous )
/*++
Routine description:

	Delete an article, physically.

Arguments:

	IN INNTPPropertyBag *pGroupBag - Group's property bag
	IN ARTICLEID idArt - Article id to delete
	IN STOREID idStore - I don't care
	IN HANDLE   hToken - The client's access token
	IN INntpComplete *pICompletion - Completion object
--*/
{
	TraceFunctEnter( "CNntpFSDriver::DeleteArticle" );
	_ASSERT( pPropBag );
	_ASSERT( cArticles > 0 );
	_ASSERT( rgidArt );
	_ASSERT( pICompletion );

	HRESULT 			hr;
	DWORD               i = 0;


	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
    }

    for ( i = 0; i < cArticles; i ++ ) {
    	hr = DeleteInternal( pPropBag, rgidArt[i] );
    	if ( FAILED( hr ) ) {
    	    ErrorTrace( 0, "Deleting article %d failed", rgidArt[i] );
    	    break;
    	}
    	if ( pdwLastSuccess ) *pdwLastSuccess = i;
    }

    if ( m_bUNC ) RevertToSelf();

Exit:

	_ASSERT( pPropBag );
	if( pPropBag ) {
		//pPropBag->Release();
		pICompletion->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	if ( i > 0 && FAILED( hr ) ) {
	    hr = NNTP_E_PARTIAL_COMPLETE;
	}

	pICompletion->SetResult( hr );
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();

}

void
CNntpFSDriver::CommitPost(	IN IUnknown *punkMsg,
							IN STOREID	*pidStore,
							IN STOREID *pidOthers,
							IN HANDLE   hToken,
							IN INntpComplete *pICompletion,
							IN BOOL     fAnonymous )
/*++
Routine description:

	Commit the post:
		For the primary store, which AllocMessage'd, it needs
		to do nothing; for other backing stores, they need to
		copy the content file.

Arguments:

	IN IUnknown *punkMsg - Message object
	IN STOREID *pidStore, *pidOthers - I don't care
	IN HANDLE hToken - The client's access token
	IN INntpComplete *pIComplete - Completion object
--*/
{
	TraceFunctEnter( "CNntpFSDriver::CommitPost" );
	_ASSERT( punkMsg );
	_ASSERT( pICompletion );

	IMailMsgProperties *pMsg = NULL;
	HRESULT hr;
	DWORD	dwSerial;
	PFIO_CONTEXT pfioDest;
    BOOL    fIsMyMessage;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    CHAR    szFileName[MAX_PATH+1];
    DWORD   dwLinesOffset = INVALID_FILE_SIZE;
    DWORD   dwHeaderLength = INVALID_FILE_SIZE;
    BOOL    bImpersonated = FALSE;
    BOOL    fPrimary = TRUE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	// QI for the message object interface
	hr = punkMsg->QueryInterface( IID_IMailMsgProperties, (void**)&pMsg );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "QI for msg obj interface failed %x", hr );
		goto Exit;
	}

	// check to see if I am the owner of the handle
    hr = GetMessageContext( pMsg, szFileName, &fIsMyMessage, &pfioDest );
    if (FAILED(hr))
    {
        DebugTrace( (DWORD_PTR)this, "GetMessageContext failed - %x\n", hr );
        goto Exit;
    }
    _ASSERT( pfioDest );
    dwLinesOffset = pfioDest->m_dwLinesOffset;
    dwHeaderLength = pfioDest->m_dwHeaderLength;

    // Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	if ( S_FALSE == hr || !fIsMyMessage /*dwSerial != DWORD( this )*/ ) { // copy the content

		// Alloc a file handle in the local store
		hr = AllocInternal( pMsg, &pfioDest, szFileName, FALSE, FALSE, hToken );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Open local file failed %x", hr );
			goto Exit;
		}

		// copy the content
		hr = pMsg->CopyContentToFileEx( pfioDest, TRUE, NULL );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Copy content failed %x", hr );
			ReleaseContext( pfioDest );
			goto Exit;
		}

		fPrimary = FALSE;
    }

	//
	// We should insert the fio context into file handle cache and
	// release the reference, if we are primary store, then we shouldn't
	// release the context since we might be used for copying to other
	// stores.  But if we are secondary, then we can go ahead and release
	// the FIO_CONTEXT
	//
	// Note:  We only insert the file into the cache if we're not posting
	// to _slavegroup.
	//
	if (!IsSlaveGroup()) {
	    if ( !InsertFile( szFileName, pfioDest, fPrimary ) ) {
	        ErrorTrace( 0, "Insert file context into cache failed %d", GetLastError() );
            hr = HresultFromWin32TakeDefault( ERROR_ALREADY_EXISTS );

	        // At least I should release the context
	        if ( !fPrimary ) ReleaseContext( pfioDest );
	        goto Exit;
	    }
	}

    //  Here we need to handle the Terminated Dot.  The logic is:
    //  1) Check to see if pfioContext has the Terminated Dot
    //  2) If "Has dot", NNTP FS driver does nothing, Exchange Store driver:
    //     a) Strip the dot by SetFileSize()
    //     b) Set bit in pfioContext to "No dot"
    //  3) If "No dot", Exchange Store driver does nothing, NNTP FS driver:
    //     a) Add the dot by SetFileSize().
    //     b) Set bit in pfioContext to "Has dot"
    //
    if (!GetIsFileDotTerminated(pfioDest))
    {
        //  No dot, add it
        AddTerminatedDot( pfioDest->m_hFile );

        //  Set pfioContext to "Has dot"
        SetIsFileDotTerminated( pfioDest, TRUE );
    }

    //
    // Back fill the Lines information, if necessary
    //
    if ( dwLinesOffset != INVALID_FILE_SIZE ) {

        // then we'll have to back fill it
        BackFillLinesHeader(    pfioDest->m_hFile,
                                dwHeaderLength,
                                dwLinesOffset );
    }

Exit:

    if ( bImpersonated ) RevertToSelf();

	// Release the message interface
	if ( pMsg ) {
		pMsg->Release();
		pMsg = NULL;
	}

	_ASSERT( punkMsg );
	if( punkMsg ) {
		punkMsg->Release();
		punkMsg = NULL;
	}


	pICompletion->SetResult( hr );
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void STDMETHODCALLTYPE
CNntpFSDriver::GetXover(    IN INNTPPropertyBag *pPropBag,
                            IN ARTICLEID    idMinArticle,
                            IN ARTICLEID    idMaxArticle,
                            OUT ARTICLEID   *pidNextArticle,
                            OUT LPSTR       pcBuffer,
                            IN DWORD        cbin,
                            OUT DWORD       *pcbout,
                            IN HANDLE       hToken,
                            INntpComplete	*pICompletion,
                            IN BOOL         fAnonymous )
/*++
Routine Description:

    Get Xover information from the store driver.

Arguments:

    IN INNTPPropertyBag *pPropBag  - Interface pointer to the news group prop bag
    IN ARTICLEID idMinArticle   - The low range of article id to be retrieved from
    IN ARTICLEID idMaxArticle   - The high range of article id to be retrieved from
    OUT ARTICLEID *pidNextArticle - Buffer for actual last article id retrieved,
                                    0 if no article retrieved
    OUT LPSTR pcBuffer          - Header info retrieved
    IN DWORD cbin               - Size of pcBuffer
    IN HANDLE   hToken          - The client's access token
    OUT DWORD *pcbout             - Actual bytes written into pcBuffer

Return value:

    S_OK                    - Succeeded.
    NNTP_E_DRIVER_NOT_INITIALIZED - Driver not initialized
    S_FALSE   - The buffer provided is too small, but content still filled
--*/

{
	TraceFunctEnter( "CNntpFSDriver::GetXover" );
	_ASSERT( pPropBag );
	_ASSERT( idMinArticle <= idMaxArticle );
	_ASSERT( pidNextArticle );
	_ASSERT( cbin > 0 );
	_ASSERT( pcbout );
	_ASSERT( pICompletion );

	HRESULT	hr = S_OK;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	hr = GetXoverInternal( 	pPropBag,
							idMinArticle,
							idMaxArticle,
							pidNextArticle,
							NULL,
							pcBuffer,
							cbin,
							pcbout,
							TRUE,	// is xover
							hToken,
							pICompletion
						);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "GetXover failed %x", hr );
	}

Exit:

	pICompletion->SetResult( hr );
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();

}

void STDMETHODCALLTYPE
CNntpFSDriver::GetXhdr(    IN INNTPPropertyBag *pPropBag,
                           IN ARTICLEID    idMinArticle,
                           IN ARTICLEID    idMaxArticle,
                           OUT ARTICLEID   *pidNextArticle,
                           IN LPSTR		   szHeader,
                           OUT LPSTR       pcBuffer,
                           IN DWORD        cbin,
                           OUT DWORD       *pcbout,
                           IN HANDLE        hToken,
                           INntpComplete	*pICompletion,
                           IN BOOL          fAnonymous )
/*++
Routine Description:

    Get Xover information from the store driver.

Arguments:

    IN INNTPPropertyBag *pPropBag  - Interface pointer to the news group prop bag
    IN ARTICLEID idMinArticle   - The low range of article id to be retrieved from
    IN ARTICLEID idMaxArticle   - The high range of article id to be retrieved from
    OUT ARTICLEID *pidNextArticle - Buffer for actual last article id retrieved,
                                    0 if no article retrieved
    IN szHeader					- The header key word
    OUT LPSTR pcBuffer          - Header info retrieved
    IN DWORD cbin               - Size of pcBuffer
    IN HANDLE hToken            - The client's access token
    OUT DWORD *pcbout             - Actual bytes written into pcBuffer

Return value:

    S_OK                    - Succeeded.
    NNTP_E_DRIVER_NOT_INITIALIZED - Driver not initialized
    S_FALSE   - The buffer provided is too small, but content still filled
--*/

{
	TraceFunctEnter( "CNntpFSDriver::GetXhdr" );
	_ASSERT( pPropBag );
	_ASSERT( idMinArticle <= idMaxArticle );
	_ASSERT( pidNextArticle );
	_ASSERT( cbin > 0 );
	_ASSERT( pcbout );
	_ASSERT( szHeader );
	_ASSERT( pICompletion );

	HRESULT	hr = S_OK;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	hr = GetXoverInternal( 	pPropBag,
							idMinArticle,
							idMaxArticle,
							pidNextArticle,
							szHeader,
							pcBuffer,
							cbin,
							pcbout,
							FALSE,	// is xover
							hToken,
							pICompletion
						);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "GetXhdr failed %x", hr );
	}

Exit:

	pICompletion->SetResult( hr );
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();

}

void STDMETHODCALLTYPE
CNntpFSDriver::DecorateNewsTreeObject(  IN HANDLE hToken,
                                        IN INntpComplete *pICompletion )
/*++
Routine description:

	On driver start up, it does a sanity check of newstree, against
	driver owned property file and against hash tables

Arguments:

    IN HANDLE hToken - The client's access token
	IN INntpComplete *pICompletion - The completion object

Return value:

	S_OK - Success
--*/
{
	TraceFunctEnter( "CNntpFSDriver::DecorateNewsTreeObject" );
	_ASSERT( pICompletion );

	HRESULT hr = S_OK;
	BOOL                bImpersonated = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	// Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

    _ASSERT( m_pNntpServer );
    if ( m_pNntpServer->QueryServerMode() == NNTP_SERVER_NORMAL ) {

        //
        // If the server is being normally started up
        // we'll check the group object against hash table, as well
        // as load the group offset ( in vpp file ) into the
        // newsgroup object
        //
    	// Validate news tree against hsh table first
    	/*
	    hr = EnumCheckTree( pICompletion );
    	if ( FAILED( hr ) ) {
	    	ErrorTrace( 0, "EnumCheckTree failed %x", hr );
		    goto Exit;
    	}*/

    	//
    	// If it's upgraded, I'll create the groups into vpp file
    	//
    	if ( m_fUpgrade ) {
    	    hr = CreateGroupsInVpp( pICompletion );
    	    if ( FAILED( hr ) ) {
    	        ErrorTrace( 0, "Create groups in vpp failed %x", hr );
    	        goto Exit;
    	    }
    	}

	    // Load group offsets into
    	hr = LoadGroupOffsets( pICompletion );
	    if ( FAILED( hr ) ) {
		    ErrorTrace( 0, "Load group offsets failed %x", hr );
		    goto Exit;
    	}
    } else {

        //
        // The server is in rebuild mode, we'll skip the sanity
        // check since we got into rebuild because of data inconsistency.
        // And we'll also load groups into newstree
        //
        _ASSERT( m_pNntpServer->QueryServerMode() == NNTP_SERVER_STANDARD_REBUILD ||
                m_pNntpServer->QueryServerMode() == NNTP_SERVER_CLEAN_REBUILD );
        hr = LoadGroups( pICompletion );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Load groups during rebuild failed %x", hr );
            goto Exit;
        }

        //
        // Lets purge all our article left over in file handle cache, so
        // that if we want to parse them later, we don't hit sharing
        // violations
        //
        CacheRemoveFiles( m_szFSDir, TRUE );
    }

Exit:

    if ( bImpersonated ) RevertToSelf();

	pICompletion->SetResult( hr);
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void STDMETHODCALLTYPE
CNntpFSDriver::CheckGroupAccess(    IN    INNTPPropertyBag *pPropBag,
                                    IN    HANDLE            hToken,
                                    IN    DWORD             dwDesiredAccess,
                                    IN    INntpComplete     *pICompletion )
/*++
Routine description:

    Check group accessibility.

Arguments:

    INNTPPropertyBag *pNewsGroup - Property bag of the news group
    HANDLE  hToken - The client access token
    DWORD   dwDesiredAccess - The client's desired access
    INntpComplete *pIcompletion - The completion object

Return value:

    None.
    In completion object: S_OK  - Access allowed
                            E_ACCESSDENIED - Access is denied
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CheckGroupAccess" );

	_ASSERT( pICompletion );
	_ASSERT( pPropBag );

	HRESULT hr = S_OK;
	CHAR    pbSecDesc[512];
	DWORD   cbSecDesc = 512;
	LPSTR   lpstrSecDesc = NULL;
	BOOL    bAllocated = FALSE;

    // Generic mapping for file system
	GENERIC_MAPPING gmFile = {
        FILE_GENERIC_READ,
        FILE_GENERIC_WRITE,
        FILE_GENERIC_EXECUTE,
        FILE_ALL_ACCESS
    } ;

    BYTE    psFile[256] ;
    DWORD   dwPS = sizeof( psFile ) ;
    DWORD   dwGrantedAccess = 0;
    BOOL    bAccessStatus = FALSE;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	// If FAT, return S_OK
	if ( m_dwFSType == FS_FAT ) {
	    hr = S_OK;
	    goto Exit;
	}

	// Check if the group has security descriptor
	lpstrSecDesc = pbSecDesc;
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_SECDESC,
	                        PBYTE(lpstrSecDesc),
	                        &cbSecDesc );
	if ( FAILED( hr ) ) {

	    // If failed because of insufficient buffer, give it
	    // a retry
	    if ( TYPE_E_BUFFERTOOSMALL == hr ) {

	        // we hate "new", but this is fine since it doesn't
	        // happen quite often.  Normally 512 bytes for
	        // security descriptor would be enough
	        _ASSERT( cbSecDesc > 512 );
	        lpstrSecDesc = XNEW char[cbSecDesc];
	        if ( NULL == lpstrSecDesc ) {
	            ErrorTrace( 0, "Out of memory" );
	            hr = E_OUTOFMEMORY;
	            goto Exit;
	        }

	        bAllocated = TRUE;

	        // try to get it from property bag agin
	        hr = pPropBag->GetBLOB( NEWSGRP_PROP_SECDESC,
	                                PBYTE(lpstrSecDesc),
	                                &cbSecDesc );
	        if ( FAILED( hr ) ) {

	            // How come it failed again ?  this is fatal
	            ErrorTrace( 0, "Can not get sec descriptor from bag %x", hr );
	            goto Exit;
	        }

        } else if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == hr ) {

            cbSecDesc = 512;
            hr = LoadGroupSecurityDescriptor(   pPropBag,
                                                lpstrSecDesc,
                                                &cbSecDesc,
                                                TRUE,
                                                &bAllocated );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Load group security desc failed %x", hr );
                goto Exit;
            }
        } else {    // fatal error

            ErrorTrace( 0, "Get security descriptor from bag failed %x", hr );
            goto Exit;

        }
    }

    // Now we interpret dwDesiredAccess into the language of
    // GENERIC_READ, GENERIC_WRITE for NTFS
    dwDesiredAccess = ( dwDesiredAccess == NNTP_ACCESS_READ ) ? GENERIC_READ :
                        GENERIC_READ | GENERIC_WRITE;

    // Generic map
    MapGenericMask( &dwDesiredAccess, &gmFile );

    // Being here, we should already have a security descriptor
    // for the group in lpstrSecDesc and the length is cbSecDesc
    if ( !AccessCheck(  PSECURITY_DESCRIPTOR( lpstrSecDesc ),
                        hToken,
                        dwDesiredAccess,
                        &gmFile,
                        PPRIVILEGE_SET(psFile),
	                    &dwPS,
                        &dwGrantedAccess,
                        &bAccessStatus ) ) {
        //
        // If we failed because we were given a token that's not
        // impersonation token, we'll duplicate and give it a
        // try again
        //
        if ( GetLastError() == ERROR_NO_IMPERSONATION_TOKEN ) {

            HANDLE  hImpersonationToken = NULL;
            if ( !DuplicateToken(   hToken,
                                    SecurityImpersonation,
                                    &hImpersonationToken ) ) {
          	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
                ErrorTrace( 0, "Duplicate token failed %x", hr );
                goto Exit;
            } else {
                if ( !AccessCheck(  PSECURITY_DESCRIPTOR( lpstrSecDesc ),
                                    hImpersonationToken,
                                    dwDesiredAccess,
                                    &gmFile,
                                    PPRIVILEGE_SET(psFile),
	                                &dwPS,
                                    &dwGrantedAccess,
                                    &bAccessStatus ) ) {
                    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
                    _VERIFY( CloseHandle( hImpersonationToken ) );
                    ErrorTrace( 0, "Access checked failed with %x", hr );
                    goto Exit;
                }

                _VERIFY( CloseHandle( hImpersonationToken ) );

            }
        } else {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Access checked failed with %x", hr );
            goto Exit;
        }
    }

    hr = bAccessStatus ? S_OK : E_ACCESSDENIED;

Exit:

    // Release the property bag
    if ( pPropBag ) {
        //pPropBag->Release();
        pICompletion->ReleaseBag( pPropBag );
    }

    // If the security descriptor is dynamically allocated, free it
    if ( bAllocated ) XDELETE[] lpstrSecDesc;

	pICompletion->SetResult( hr);
	pICompletion->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

void
CNntpFSDriver::RebuildGroup(    IN INNTPPropertyBag *pPropBag,
                                IN HANDLE           hToken,
                                IN INntpComplete     *pComplete )
/*++
Routine description:

    Enumerate all the physical articles in the group, parse out
    the headers, post them into server using INntpServer ( asking
    the server not to re-assign article id ) and then update
    newsgroup properties ( for all the cross posted groups )

Arguments:

    IN INNTPPropertyBag *pPropBag   - The property bag of the group
    IN HANDLE hToken                - Client's hToken
    IN INntpComplete *pComplete     - Completion object

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::Rebuild" );
    _ASSERT( pPropBag );
    _ASSERT( pComplete );

    HRESULT         hr = S_OK;
    BOOL            f;
    INntpDriver      *pDriver = NULL;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    DWORD   dwLen = MAX_NEWSGROUP_NAME+1;


    //
    // Share lock for usage count
    //
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

    //
	// Increment the usage count
	//
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	//
	// Make up the pattern for findfirst/findnext
	//
	CHAR    szGroupName[MAX_NEWSGROUP_NAME+1];
	CHAR    szFullPath[2 * MAX_PATH];
	CHAR    szPattern[2 * MAX_PATH];
	CHAR    szFileName[MAX_PATH+1];
	CHAR    szBadFileName[MAX_PATH+1];
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME,
	                                PBYTE( szGroupName ),
	                                &dwLen );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Get group name failed %x", hr );
	    goto Exit;
	}
	_ASSERT( strlen( szGroupName ) <= MAX_PATH );

	//
	// Check to see if this group really belongs to me
	//
	hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
		DebugTrace(0, "I don't own this group %s", szGroupName );
		goto Exit;
	}

	GroupName2Path( szGroupName, szFullPath );
    _ASSERT( strlen( szFullPath ) <= MAX_PATH );

    hr = MakeChildDirPath(  szFullPath,
                            "*.nws",
                            szPattern,
                            MAX_PATH );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "makechilddirpath failed %x", hr );
        goto Exit;
    }
    _ASSERT( strlen( szPattern ) <= MAX_PATH );

    //
    // FindFirst/FindNext
    //
    WIN32_FIND_DATA FindData;

    //
    // If I am UNC Vroot, impersonate here
    //
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
            hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		    ErrorTrace( 0, "Impersonation failed %x", hr );
		    goto Exit;
		}
    }

    hFind = FindFirstFile( szPattern, &FindData );
    f = (INVALID_HANDLE_VALUE != hFind );
    while( f ) {

        //
        // If I am told to cancel, should not continue
        //
        if ( !m_pNntpServer->ShouldContinueRebuild() ) {
            DebugTrace( 0, "Rebuild cancelled" );
            if ( m_bUNC ) RevertToSelf();
            goto Exit;
        }

        //
        // Make a full path for the file name
        //
        hr = MakeChildDirPath(  szFullPath,
                                FindData.cFileName,
                                szFileName,
                                MAX_PATH );
        if( FAILED( hr ) ) {
            ErrorTrace( 0, "Make Childdir path failed %x", hr );
            if ( m_bUNC ) RevertToSelf();
            goto Exit;
        }

        //
        // Do all the work
        //
        hr = PostToServer(  szFileName,
                            szGroupName,
                            pComplete );
        if ( FAILED( hr ) ) {

            ErrorTrace( 0, "Post article to server failed %x", hr );
            if ( m_bUNC ) RevertToSelf();
            goto Exit;
        }

        //
        // If it's S_FALSE, we'll rename it to be *.bad
        //
        if ( S_FALSE == hr ) {
            strcpy( szBadFileName, szFileName );
            strcat( szBadFileName, ".bad" );
            _VERIFY( MoveFile( szFileName, szBadFileName ) );
        }

        f = FindNextFile( hFind, &FindData );
    }

    if ( m_bUNC ) RevertToSelf();

Exit:

    // Close the find handle
    if ( INVALID_HANDLE_VALUE != hFind )
        _VERIFY( FindClose( hFind ) );

    // Release the property bag
    if ( pPropBag ) {
        pComplete->ReleaseBag( pPropBag );
    }

	pComplete->SetResult( hr);
	pComplete->Release();
	InterlockedDecrement( &m_cUsages );

	TraceFunctLeave();
}

/////////////////////////////////////////////////////////////////
// IMailMsgStoreDriver interface implementation
/////////////////////////////////////////////////////////////////
HRESULT
CNntpFSDriver::AllocMessage(	IN IMailMsgProperties *pMsg,
								IN DWORD	dwFlags,
								OUT IMailMsgPropertyStream **ppStream,
								OUT PFIO_CONTEXT *ppFIOContentFile,
								IN IMailMsgNotify *pNotify )
/*++
Routine description:

	Allocate property stream and content file for a recipient (
	with async completion ).

Arguments:

	IN IMailMsgProperties *pMsg - Specifies the message.  This may
									not be NULL ( in smtp case, it
									may be NULL ).  But we want to
									have primary group information
									at this point before opening a
									destination file handle.  By
									doing that, we even don't need to
									"MoveFile".
	IN DWORD dwFlags - Currently not used, just to make interface happy
	OUT IMailMsgPropertyStream **ppStream - not used
	OUT HANDLE *phContentFile - To return file handle opened
	IN IMailMsgNotify *pNotify - Completion object

Return value:

	S_OK - Success, the operation completed synchronously.
	MAILMSG_S_PENDING - Success, but will be completed asynchronously,
						this will never happen to the NTFS driver
--*/
{
	TraceFunctEnter( "CNntpFSDriver::AllocMessage" );
	_ASSERT( pMsg );
	_ASSERT( ppFIOContentFile );
	// I don't care about other parameters

	HRESULT hr = S_OK;
	HANDLE  hToken = NULL;
	HANDLE  hFile = INVALID_HANDLE_VALUE;
	CHAR    szFileName[MAX_PATH+1];
	BOOL    bImpersonated = FALSE;
	DWORD	dwLengthRead;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );

	m_TermLock.ShareUnlock();

	// Get the client token from the message object
	// BUGBUG: we'll need to have a better way to do this
	hr = pMsg->GetProperty( IMSG_POST_TOKEN,
							sizeof(hToken),
							&dwLengthRead,
							(LPBYTE)&hToken );
	_ASSERT(dwLengthRead == sizeof(hToken));

	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Mail message doesn't have htoken" );
	    hr = E_INVALIDARG;
	    goto Exit;
	}

	// Before accessing the file system, impersonate
    if ( m_bUNC ) {
        if ( !ImpersonateLoggedOnUser( hToken ) ) {
    	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
                ErrorTrace( 0, "Impersonation failed %x", hr );
            goto Exit;
        }
        bImpersonated = TRUE;
    }

	hr = AllocInternal( pMsg, ppFIOContentFile, szFileName, TRUE, TRUE, hToken );
	if ( SUCCEEDED( hr ) ) {

	    _ASSERT( *ppFIOContentFile );

        /*
	    //
	    // I should stick the file name into mailmsg object, so
	    // that I can insert it into file handle cache later
	    //
	    hr = pMsg->PutProperty( IMSG_FILE_NAME, strlen( szFileName ), PBYTE(szFileName) );
	    if ( FAILED( hr ) ) {
	        ErrorTrace( 0, "Put file name into imsg failed %x", hr );
	        ReleaseContext( *ppFIOContentFile );
	        *ppFIOContentFile = NULL;
	        goto Exit;
	    }
	    */

	} else {

	    //
	    // I should also clean up the fio context, so that protocol
	    // doesn't get confused
	    //
	    *ppFIOContentFile = 0;
	}

Exit:

    if ( bImpersonated ) RevertToSelf();

	_ASSERT( pMsg );
	if ( pMsg ) {
		pMsg->Release();
	}
	InterlockedDecrement( &m_cUsages );
	TraceFunctLeave();

	// BUGBUG: if pNotify is not NULL, we should use pNotify
	// to complete it.  But our server always pass in NULL,
	// so this is not done yet.
	return hr;
}

HRESULT
CNntpFSDriver::CloseContentFile(	IN IMailMsgProperties *pMsg,
									IN PFIO_CONTEXT pFIOContentFile )
/*++
Routine description:

	Close the content file.

Arguments:

	IN IMailMsgProperties *pMsg - Specifies the message
	IN HANDLE hContentFile - Specifies the content handle

Return value:

	S_OK - I have closed it.
	S_FALSE - it's none of my business
--*/
{
	TraceFunctEnter( "CNntpFSDriver::CloseContentFile" );
	_ASSERT( pMsg );

	HRESULT hr;
	DWORD	dwSerial;

    BOOL    fIsMyMessage = FALSE;
    PFIO_CONTEXT pfioContext = NULL;
    CHAR    szFileName[MAX_PATH+1];
    DWORD   dwFileLen = MAX_PATH;

	// Verify the driver serial number on msg object
    hr = GetMessageContext( pMsg, szFileName, &fIsMyMessage, &pfioContext );
    if (FAILED(hr))
    {
        DebugTrace( (DWORD_PTR)this, "GetMessageContext failed - %x\n", hr );
        goto Exit;
    }

    _ASSERT( pFIOContentFile == pfioContext );

	// It should not be me to close it in the following cases
	if ( NULL == pfioContext ||
			S_FALSE == hr ||	// the serial number is missing
			/*dwSerial != DWORD(this)*/
            !fIsMyMessage ) {
		DebugTrace(0, "Let somebody else close the handle" );
		hr = S_FALSE;
		goto Exit;
	}

	// We should release the context's reference
	ReleaseContext( pFIOContentFile );

    /* this is done in CommitPost now
	if ( !InsertFile( szFileName, pFIOContentFile, FALSE ) ) {
	    ErrorTrace( 0, "Insert into file handle cache failed %d", GetLastError() );

        // We should releae the context anyway
    	ReleaseContext( pFIOContentFile );
    	goto Exit;
    }*/

Exit:

	_ASSERT( pMsg );
	if ( pMsg ) {
		pMsg->Release();
		pMsg = NULL;
	}
	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::Delete(	IMailMsgProperties *pMsg,
						IMailMsgNotify *pNotify )
/*++
Routine description:

	Delete the message given from store.

Arguments:

	IMailMsgProperties *pMsg - The message object
	IMailMsgNotify *pNotify - not used, always done synchronously

Return value:

	S_OK on success, other error code otherwise
--*/
{
	TraceFunctEnter( "CNntpFSDriver::Delete" );
	_ASSERT( pMsg );

	HRESULT hr = S_OK;
	DWORD	dwBLOBSize;
	DWORD	dwArtId;
	INNTPPropertyBag* pPropPrime;

	// Get property bag from msg object
	hr = pMsg->GetProperty(	IMSG_PRIMARY_GROUP,
							sizeof( INNTPPropertyBag* ),
							&dwBLOBSize,
							(PBYTE)&pPropPrime );
	if ( S_OK != hr ) {
		ErrorTrace( 0, "Property %d doesn't exist", IMSG_PRIMARY_GROUP );
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Get article id from pMsg object
	hr = pMsg->GetDWORD(	IMSG_PRIMARY_ARTID, &dwArtId );
	if ( S_OK != hr ) {
		ErrorTrace( 0, "Property %d doesn't exist", IMSG_PRIMARY_ARTID );
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Now delete it
	hr = DeleteInternal( pPropPrime, dwArtId );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Delete article failed %x", hr );
	}

Exit:

	TraceFunctLeave();
	return hr;
}

/////////////////////////////////////////////////////////////////
// Private methods
/////////////////////////////////////////////////////////////////
HRESULT
CNntpFSDriver::SetMessageContext(
    IMailMsgProperties* pMsg,
    char*               szFileName,
    DWORD               cbFileName,
    PFIO_CONTEXT        pfioContext
    )
/*++

Description:

    Set Message Context in mailmsg

Arguments:


Return:

    S_OK

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CNntpFSDriver::SetMessageContext()" );

    HRESULT hr = S_OK;
    BYTE    pbData[(MAX_PATH * 2) + sizeof(CLSID) + sizeof(void *)*2];
    DWORD   dwLen = 0;
    DWORD_PTR dwThisPointer = (DWORD_PTR)this;

    //  Use the standard way to putting the unique ID
    //  Just to makesure we have the unique ID, use GUID+this+newsgroup+handle
    MoveMemory(pbData, &CLSID_NntpFSDriver, sizeof(CLSID));
    MoveMemory(pbData+sizeof(CLSID), &dwThisPointer, sizeof(DWORD_PTR));
    MoveMemory(pbData+sizeof(CLSID)+sizeof(DWORD_PTR), &pfioContext, sizeof(PFIO_CONTEXT));
    MoveMemory(pbData+sizeof(CLSID)+sizeof(DWORD_PTR)+sizeof(PFIO_CONTEXT), szFileName, cbFileName);
    dwLen = sizeof(CLSID)+cbFileName+sizeof(PFIO_CONTEXT)+sizeof(DWORD_PTR);
    hr = pMsg->PutProperty( IMMPID_MPV_STORE_DRIVER_HANDLE, dwLen, pbData );
    if (FAILED(hr))
    {
        ErrorTrace((DWORD_PTR)this, "PutProperty on IMMPID_MPV_STORE_DRIVER_HANDLE failed %x\n", hr);
    }

    return hr;

} // CNntpFSDriver::SetMessageContext


HRESULT
CNntpFSDriver::GetMessageContext(
    IMailMsgProperties* pMsg,
    LPSTR               szFileName,
    BOOL *              pfIsMyMessage,
    PFIO_CONTEXT        *ppfioContext
    )
/*++

Description:

    Check this message to see if this is our message

Arguments:


Return:

    S_OK

--*/
{
    TraceFunctEnterEx( (LPARAM)this, "CNntpFSDriver::GetMessageContext()" );

    HRESULT hr = S_OK;
    BYTE    pbData[(MAX_PATH * 2) + sizeof(CLSID) + sizeof(DWORD)*2];
    DWORD   dwLen = sizeof(pbData);
    DWORD   dwLenOut = 0;
    DWORD_PTR dwThisPointer = 0;
    DWORD   dwHandle = 0;

    hr = pMsg->GetProperty( IMMPID_MPV_STORE_DRIVER_HANDLE, dwLen, &dwLenOut, pbData);
    if (FAILED(hr))
    {
        ErrorTrace((DWORD_PTR)this, "Failed on GetProperty IMMPID_MPV_STORE_DRIVER_HANDLE %x\n", hr);
        goto Exit;
    }

    //  We have this in the context info, use GUID+this+handle+newsgroup
    CopyMemory(&dwThisPointer, pbData+sizeof(CLSID), sizeof(DWORD_PTR));

    if ((DWORD_PTR)this == dwThisPointer)
        *pfIsMyMessage = TRUE;
    else
        *pfIsMyMessage = FALSE;

    //  Get the fio context
    CopyMemory(ppfioContext, pbData+sizeof(CLSID)+sizeof(DWORD_PTR), sizeof(PFIO_CONTEXT));

    //
    // Now get file name property if this is my message
    //
    if ( szFileName ) {
        dwLen = dwLenOut - sizeof(CLSID) - sizeof(DWORD_PTR) - sizeof( PFIO_CONTEXT );
        if (*pfIsMyMessage) {
        	_ASSERT( dwLen > 0 && dwLen <= MAX_PATH );
        	CopyMemory( szFileName,
                    pbData+sizeof(CLSID)+sizeof(DWORD_PTR)+sizeof(PFIO_CONTEXT),
                    dwLen );
        }
        *(szFileName + dwLen ) = 0;
    }

Exit:

    return hr;

} // CNntpFSDriver::GetMessageContext


HRESULT
CNntpFSDriver::Group2Record(	IN VAR_PROP_RECORD& vpRecord,
								IN INNTPPropertyBag *pPropBag )
/*++
Routine description:

	Convert the properties that the FS driver cares about
	from property bag into the flatfile record, in preparation
	for storing them into the flat file.  These properties
	are all variable lengthed, such as "pretty name", "description",
	etc.  FS driver doesn't care about the fixed lengthed properties,
	because all those properties can be dynamically figured out
	during a rebuild.

Arguments:

	IN VAR_PROP_RECORD& vpRecord - Destination to fill in properties;
	IN INntpPropertyBag *pPropBag - Group's property bag.

Return value:

	None.
--*/
{
	TraceFunctEnter( "CNntpFSDriver::Group2Record" );
	_ASSERT( pPropBag );

	HRESULT hr;
	DWORD	dwLen;
	SHORT	sLenAvail = MaxRecordSize;
	PBYTE	ptr;
	DWORD	dwOffset = 0;

	// Group Id
	hr = pPropBag->GetDWord(    NEWSGRP_PROP_GROUPID,
	                            &vpRecord.dwGroupId );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Get Group id failed %x", hr );
	    goto Exit;
	}

	// Create time
	hr = pPropBag->GetDWord(    NEWSGRP_PROP_DATELOW,
	                            &vpRecord.ftCreateTime.dwLowDateTime );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Get low date failed %x", hr);
	    goto Exit;
	}

	hr = pPropBag->GetDWord(    NEWSGRP_PROP_DATEHIGH,
	                            &vpRecord.ftCreateTime.dwHighDateTime );
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Get high date failed %x", hr );
	    goto Exit;
	}

	// Group name
	dwLen = sLenAvail;
	ptr = vpRecord.pData;
	hr = pPropBag->GetBLOB(		NEWSGRP_PROP_NAME,
								ptr,
								&dwLen );
	if ( FAILED( hr ) ) {	// this is fatal
		ErrorTrace( 0, "Get group name failed %x", hr );
		goto Exit;
	}

	sLenAvail -= USHORT(dwLen);
	_ASSERT( sLenAvail >= 0 );
	_ASSERT( 0 != *ptr );	// group name should exist

	// Fix up offsets
	vpRecord.iGroupNameOffset = 0;
	vpRecord.cbGroupNameLen = USHORT(dwLen);
	dwOffset = vpRecord.iGroupNameOffset + vpRecord.cbGroupNameLen;

	// Native name
	dwLen = sLenAvail;
	ptr = vpRecord.pData + dwOffset;
	hr = pPropBag->GetBLOB(		NEWSGRP_PROP_NATIVENAME,
								ptr,
								&dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group native name failed %x", hr );
		goto Exit;
	}

	sLenAvail -= USHORT(dwLen);
	_ASSERT( sLenAvail >= 0 );
	_ASSERT( 0 != *ptr );	// at least it should be the same as
							// group name
	_ASSERT( dwLen == vpRecord.cbGroupNameLen );

	// Fix up offsets
	if ( strncmp( LPCSTR(vpRecord.pData + vpRecord.iGroupNameOffset),
					LPCSTR(ptr), dwLen ) == 0 ) {	// share name
		vpRecord.iNativeNameOffset = vpRecord.iGroupNameOffset;
		vpRecord.cbNativeNameLen = vpRecord.cbGroupNameLen;
	} else {
		vpRecord.iNativeNameOffset = USHORT(dwOffset);
		vpRecord.cbNativeNameLen = vpRecord.cbGroupNameLen;
		dwOffset = vpRecord.iNativeNameOffset + vpRecord.cbNativeNameLen;
	}

	// Pretty name
	dwLen = sLenAvail;
	ptr =  vpRecord.pData + dwOffset;
	hr = pPropBag->GetBLOB(		NEWSGRP_PROP_PRETTYNAME,
								ptr,
								&dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get pretty name failed %x", hr );
		goto Exit;
	}

	sLenAvail -= (USHORT)dwLen;
	_ASSERT( sLenAvail >= 0 );

	// Fix up offsets
	if ( 0 == *ptr ) {	// have no pretty name
		vpRecord.iPrettyNameOffset = OffsetNone;
		vpRecord.cbPrettyNameLen = 0;
	} else {
		vpRecord.iPrettyNameOffset = USHORT(dwOffset);
		vpRecord.cbPrettyNameLen = USHORT(dwLen);
		dwOffset = vpRecord.iPrettyNameOffset + vpRecord.cbPrettyNameLen;
	}

	// Description
	dwLen = sLenAvail;
	ptr = vpRecord.pData + dwOffset;
	hr = pPropBag->GetBLOB(	NEWSGRP_PROP_DESC,
							ptr,
							&dwLen );
	if ( FAILED( hr )  ) {
		ErrorTrace( 0, "Get description failed %x", hr );
		goto Exit;
	}

	sLenAvail -= USHORT(dwLen);
	_ASSERT( sLenAvail >= 0 );

	// Fix up offsets
	if ( 0 == *ptr ) {
		vpRecord.iDescOffset = OffsetNone;
		vpRecord.cbDescLen = 0;
	} else {
		vpRecord.iDescOffset = USHORT(dwOffset);
		vpRecord.cbDescLen = USHORT(dwLen);
		dwOffset = vpRecord.iDescOffset + vpRecord.cbDescLen;
	}

	// Moderator
	dwLen = sLenAvail;
	ptr = vpRecord.pData + dwOffset;
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_MODERATOR,
							ptr,
							&dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get moderator failed %x", hr );
		goto Exit;
	}

	sLenAvail -= USHORT(dwLen );
	_ASSERT( sLenAvail >= 0 );

	// Fix up offsets
	if ( 0 == *ptr ) {
		vpRecord.iModeratorOffset = OffsetNone;
		vpRecord.cbModeratorLen = 0;
	} else {
		vpRecord.iModeratorOffset = USHORT( dwOffset );
		vpRecord.cbModeratorLen = USHORT( dwLen );
		dwOffset = vpRecord.iModeratorOffset + vpRecord.cbModeratorLen;
	}

Exit:

	TraceFunctLeave();
	return hr;
}

VOID
CNntpFSDriver::Path2GroupName(  LPSTR   szGroupName,
                                LPSTR   szFullPath )
/*++
Routine description:

    Convert the path into group name.

Arguments:

    LPSTR   szGroupName - Buffer for newsgroup name ( assume >= MAX_NEWSGROUP_NAME )
    LPSTR   szFullPath  - Full path of the group directory

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::Path2GroupName" );
    _ASSERT( szGroupName );
    _ASSERT( szFullPath );

    LPSTR   lpstrStart = NULL;
    LPSTR   lpstrAppend = NULL;

    // Skip the vroot part
    _ASSERT( strlen( szFullPath ) >= strlen( m_szFSDir ) );
    lpstrStart = szFullPath + strlen( m_szFSDir );

    // If it's pointing to '\\', skip it too
    if ( *lpstrStart == '\\' ) lpstrStart++;

    // Copy the vroot prefix to desitnation buffer first
    _ASSERT( strlen( m_szVrootPrefix ) <= MAX_NEWSGROUP_NAME );
    strcpy( szGroupName, m_szVrootPrefix );

    // Append the rest part from physical path, replacing \ with .
    _ASSERT( strlen( m_szVrootPrefix ) + strlen( szFullPath ) - strlen( m_szFSDir ) < MAX_NEWSGROUP_NAME );
    lpstrAppend = szGroupName + strlen( m_szVrootPrefix );
    if ( lpstrAppend > szGroupName && *lpstrStart ) {
        //if ( *(lpstrAppend-1) == '\\' ) *(lpstrAppend-1) = '.';
        /*else*/ *(lpstrAppend++) = '.';
    }
    while( *lpstrStart ) {
        *(lpstrAppend++) = ( *lpstrStart == '\\' ? '.' : *lpstrStart );
        lpstrStart++;
    }

    // Append last null
    *lpstrAppend = 0;

    // Done, validate again
    _ASSERT( strlen( szGroupName ) <= MAX_NEWSGROUP_NAME );
}

VOID
CNntpFSDriver::GroupName2Path(	LPSTR	szGroupName,
								LPSTR	szFullPath )
/*++
Routine description:

	Convert the news group name into the FS full path.

Arguments:

	LPSTR	szGroupName	- The news group name
	LPSTR	szFullPath - The FS full path ( assume buffer
							length MAX_PATH )

Return value:

	None.
--*/
{
	TraceFunctEnter( "CNntpFSDriver::GroupName2Path" );
	_ASSERT( szGroupName );
	_ASSERT( lstrlen( szGroupName ) <= MAX_GROUPNAME );
	_ASSERT( szFullPath );
	_ASSERT( lstrlen( szGroupName ) >= lstrlen( m_szVrootPrefix ) );

	LPSTR	pch, pch2;

	// Chop off group name's prefix based on our vroot prefix
	pch = szGroupName + lstrlen( m_szVrootPrefix );

	// If it's pointing to ".", skip it
	if ( '.' == *pch ) pch++;
	_ASSERT( pch - szGroupName <= lstrlen( szGroupName ) );

	// Put vroot path into return buffer first
	_ASSERT( lstrlen( m_szFSDir ) <= MAX_PATH );
	lstrcpy( szFullPath, m_szFSDir );

	// If there is no trailing '\\', add it
	pch2 = szFullPath + lstrlen( m_szFSDir );
	if ( pch2 == szFullPath || *(pch2-1) != '\\' ) {
		*(pch2++) = '\\';
	}

	// We should have enough space for the rest stuff
	_ASSERT( ( pch2 - szFullPath ) +
				(lstrlen( szGroupName ) - (pch - szGroupName)) <= MAX_PATH );

	// Copy the rest stuff, changing '.' to '\\'
	while ( *pch != 0 ) {
		if ( *pch == '.' ) *pch2 = '\\';
		else *pch2 = *pch;
		pch++, pch2++;
	}

	*pch2 = 0;

	_ASSERT( lstrlen( szFullPath ) <= MAX_PATH );
	TraceFunctLeave();
}

HRESULT
CNntpFSDriver::LoadGroupOffsets( INntpComplete *pComplete )
/*++
Routine description:

	Load group offset into the property file to the news tree

Arguments:

	None.

Return value:

	S_OK - Success
--*/
{
	TraceFunctEnter( "CNntpFSDriver::LoadGroupOffsets" );

	VAR_PROP_RECORD vpRec;
	DWORD			dwOffset;
	HRESULT			hr = S_OK;
	DWORD			dwSize;
	LPSTR			lpstrGroupName;
	INntpDriver 	*pDriver = NULL;
	INNTPPropertyBag *pPropBag = NULL;

	_ASSERT( m_pffPropFile );

	m_PropFileLock.ShareLock();

	//
	// check if the vpp file is in good shape
	//
	if ( !m_pffPropFile->FileInGoodShape() ) {
	    ErrorTrace( 0, "Vpp file corrupted" );
	    m_PropFileLock.ShareUnlock();
	    hr = HresultFromWin32TakeDefault( ERROR_FILE_CORRUPT );
	    return hr;
	}

	dwSize = sizeof( vpRec );
	hr = m_pffPropFile->GetFirstRecord( PBYTE(&vpRec), &dwSize, &dwOffset );
	m_PropFileLock.ShareUnlock();
	while ( S_OK == hr ) {
	    _ASSERT( RECORD_ACTUAL_LENGTH( vpRec ) < 0x10000 ); // our max record length
		_ASSERT( dwSize == RECORD_ACTUAL_LENGTH( vpRec ) );
		_ASSERT( dwOffset != 0xffffffff );
		lpstrGroupName = LPSTR(vpRec.pData + vpRec.iGroupNameOffset);
		_ASSERT( vpRec.cbGroupNameLen <= MAX_GROUPNAME );
		*(lpstrGroupName+vpRec.cbGroupNameLen) = 0;

		// check if I own this group
		hr = m_pINewsTree->LookupVRoot( lpstrGroupName, &pDriver );
		if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
			// skip this group
			// DebugTrace(0, "I don't own this group %s", lpstrGroupName );
			goto NextIteration;
		}

		// I own this group, i need to load offset property
		hr = m_pINewsTree->FindOrCreateGroupByName(	lpstrGroupName,
													FALSE,
													&pPropBag,
													pComplete,
													0xffffffff, // fake group id
													FALSE );    // I don't set groupid
		if ( FAILED( hr ) ) {
			DebugTrace( 0, "Can not find the group that I own %x" , hr );
			goto NextIteration;  // should fail it ?
		}

		// Set the offset
		hr = pPropBag->PutDWord( NEWSGRP_PROP_FSOFFSET, dwOffset );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Put offset failed %x", hr );
			goto Exit;
		}

		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;

NextIteration:

		dwSize = sizeof( vpRec );
		m_PropFileLock.ShareLock();
		hr = m_pffPropFile->GetNextRecord( PBYTE(&vpRec), &dwSize, &dwOffset );
		m_PropFileLock.ShareUnlock();
	}

Exit:

	if ( NULL != pPropBag ) {
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::EnumCheckTree( INntpComplete *pComplete )
/*++
Routine description:

	Enumerating the news tree and check group properties
	against hash table

Arguments:

	None.

Return value:

	S_OK	- Success
--*/
{
	TraceFunctEnter( "CNntpFSDriver::EnumCheckTree" );

	HRESULT hr;
	INewsTreeIterator *piter = NULL;
	INNTPPropertyBag *pPropBag = NULL;

	// Get the newstree iterator
	hr = m_pINewsTree->GetIterator( &piter );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get news tree iterator failed %x", hr );
		goto Exit;
	}

	// Enumerate all the groups
	_ASSERT( piter );
	while( !(piter->IsEnd()) ) {

		hr = piter->Current( &pPropBag, pComplete );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Enumerate group failed %x", hr );
			goto Exit;
		}
		_ASSERT( pPropBag );

		hr = EnumCheckInternal( pPropBag, pComplete );
		if ( FAILED( hr ) ) {
			DebugTrace( 0, "Check group property failed %x" , hr );
			goto Exit;
		}

		_ASSERT( pPropBag );
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;

		piter->Next();
	}

Exit:


	if ( pPropBag ) {
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	if ( piter ) {
		piter->Release();
		piter = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::CreateGroupsInVpp( INntpComplete *pComplete )
/*++
Routine description:

	Enumerating the news tree and check group properties
	against hash table

Arguments:

	None.

Return value:

	S_OK	- Success
--*/
{
	TraceFunctEnter( "CNntpFSDriver::EnumCheckTree" );

	HRESULT hr;
	INewsTreeIterator *piter = NULL;
	INNTPPropertyBag *pPropBag = NULL;
	DWORD   dwOffset;
	DWORD   dwLen;
	CHAR    szGroupName[MAX_GROUPNAME+1];
	INntpDriver *pDriver = NULL;

	// Get the newstree iterator
	hr = m_pINewsTree->GetIterator( &piter );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get news tree iterator failed %x", hr );
		goto Exit;
	}

	// Enumerate all the groups
	_ASSERT( piter );
	while( !(piter->IsEnd()) ) {

		hr = piter->Current( &pPropBag, pComplete );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Enumerate group failed %x", hr );
			goto Exit;
		}
		_ASSERT( pPropBag );

		//
		// Don't create groups that don't belong to me
		//
		dwLen = MAX_GROUPNAME;
	    hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (PBYTE)szGroupName, &dwLen );
	    if ( FAILED( hr ) ) {
		    ErrorTrace( 0, "Get group name failed %x", hr );
		    goto Exit;
	    }
	    _ASSERT( dwLen <= MAX_GROUPNAME && dwLen > 0);

	    hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	    if ( FAILED( hr ) ) {
		    ErrorTrace( 0, "Vroot lookup failed %x", hr );
		    goto Exit;
	    }

        //
	    // check if this is me ?
	    //
	    if ( (INntpDriver*)this != pDriver ) {
		    hr = S_OK;
		    DebugTrace( 0, "This group doesn't belong to me" );
		    goto Next;
	    }

		hr = CreateGroupInVpp( pPropBag, dwOffset );
		if ( FAILED( hr ) ) {
			DebugTrace( 0, "Check group property failed %x" , hr );
			goto Exit;
		}

Next:
		_ASSERT( pPropBag );
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;

		piter->Next();
	}

Exit:


	if ( pPropBag ) {
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	if ( piter ) {
		piter->Release();
		piter = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::AllocInternal(	IN IMailMsgProperties *pMsg,
								OUT PFIO_CONTEXT *ppFIOContentFile,
								IN LPSTR    szFileName,
								IN BOOL	bSetSerial,
								IN BOOL fPrimaryStore,
								HANDLE  hToken )
/*++
Routine description:

	Allocate property stream and content file for a recipient (
	with async completion ).

Arguments:

	IN IMailMsgProperties *pMsg - Specifies the message.  This may
									not be NULL ( in smtp case, it
									may be NULL ).  But we want to
									have primary group information
									at this point before opening a
									destination file handle.  By
									doing that, we even don't need to
									"MoveFile".
	OUT HANDLE *phContentFile - To return file handle opened
	IN BOOL bSetSerial - Whether the serial number should be set
	HANDLE  hToken - Client access token
Return value:

	S_OK - Success, the operation completed synchronously.
	MAILMSG_S_PENDING - Success, but will be completed asynchronously,
						this will never happen to the NTFS driver
--*/
{
	TraceFunctEnter( "CNntpFSDriver::AllocInternal" );
	_ASSERT( pMsg );
	_ASSERT( ppFIOContentFile );
	// I don't care about other parameters

	HRESULT hr = S_OK;
	DWORD	dwBLOBSize;
	DWORD	dwLen;
	DWORD	dwArtId;
	INNTPPropertyBag* pPropPrime;
	CHAR	szGroupName[MAX_GROUPNAME+1];
	CHAR	szFullPath[MAX_PATH+1];
	HANDLE  hFile;

	hr = pMsg->GetProperty(	IMSG_PRIMARY_GROUP,
							sizeof( INNTPPropertyBag* ),
							&dwBLOBSize,
							(PBYTE)&pPropPrime );
	if ( S_OK != hr ) {
		ErrorTrace( 0, "Property %d doesn't exist", IMSG_PRIMARY_GROUP );
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPropPrime->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// Get article id from pMsg object
	hr = pMsg->GetDWORD(	IMSG_PRIMARY_ARTID, &dwArtId );
	if ( S_OK != hr ) {
		ErrorTrace( 0, "Property %d doesn't exist", IMSG_PRIMARY_ARTID );
		hr = E_INVALIDARG;
		goto Exit;
	}

	// Map the group name and article id to file path
	dwLen = MAX_PATH;
	hr = ObtainFullPathOfArticleFile(	szGroupName,
										dwArtId,
										szFullPath,
										dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Failed to obtain article full path %x", hr );
		goto Exit;
	}

	// Open the file
	hFile = INVALID_HANDLE_VALUE;
	hFile = CreateFile(	szFullPath,
						GENERIC_READ | GENERIC_WRITE,
						FILE_SHARE_READ,
						NULL,
						CREATE_NEW,
						FILE_FLAG_OVERLAPPED |
						FILE_FLAG_SEQUENTIAL_SCAN,
						NULL );

	if ( INVALID_HANDLE_VALUE == hFile ) {
		ErrorTrace( 0, "Open destination file failed %d",
					GetLastError() );
		hr = HresultFromWin32TakeDefault( ERROR_ALREADY_EXISTS );
		goto Exit;
	}

	//if ( m_bUNC && hToken ) RevertToSelf();

	//
	// Now associate the file handle with a FIO_CONTEXT and
	// insert it into file handle cache
	//
	if ( *ppFIOContentFile = AssociateFileEx( hFile,
                                              TRUE,     //  fStoreWithDots
                                              TRUE ) )  //  fStoreWithTerminatingDots
    {
        //
        // But I'd like to copy the file name out, so that somebody else
        // can do an insertfile for us
        //
        _ASSERT( strlen( szFullPath ) <= MAX_PATH );
        strcpy( szFileName, szFullPath );

    } else {    // Associate file failed

	    hr = HresultFromWin32TakeDefault( ERROR_INVALID_HANDLE );
        ErrorTrace( 0, "AssociateFile failed with %x", hr );
        _VERIFY( CloseHandle( hFile ) );
        goto Exit;
    }

    if ( fPrimaryStore ) {

    	//
	    // Stick my serial number in the message object to mark
    	// that I am the owner of the file handle, if necessary
	    //
    	if ( bSetSerial ) {
            hr = SetMessageContext( pMsg, szFullPath, strlen( szFullPath ), *ppFIOContentFile );
            if (FAILED(hr))
            {
                DebugTrace((DWORD_PTR)this, "Failed to SetMessageContext %x\n", hr);
                goto Exit;
            }
	    }
	}

	hr = S_OK;	// it could be S_FALSE, which is OK

Exit:

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::DeleteInternal(	IN INNTPPropertyBag *pPropBag,
								IN ARTICLEID	idArt )
/*++
Routine description:

	Delete an article, physically.

Arguments:

	IN IUnknown *punkPropBag - Group's property bag
	IN ARTICLEID idArt - Article id to delete
--*/
{
	TraceFunctEnter( "CNntpFSDriver::DeleteInternal" );
	_ASSERT( pPropBag );

	HRESULT 			hr;
	DWORD				dwLen;
	CHAR				szGroupName[MAX_GROUPNAME+1];
	CHAR				szFullPath[MAX_PATH+1];


	// Get group name
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB(	NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr )) {
		ErrorTrace( 0, "Failed to get group name %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// Make up the file name based on article id
	dwLen = MAX_PATH;
	hr = ObtainFullPathOfArticleFile(	szGroupName,
										idArt,
										szFullPath,
										dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Failed to obtain article full path %x", hr );
		goto Exit;
	}

	CacheRemoveFiles( szFullPath, FALSE );

	// Delete the file
	if ( !DeleteFile( szFullPath ) ) {
		ErrorTrace( 0, "Delete file failed %d", GetLastError() );
	    hr = HresultFromWin32TakeDefault( ERROR_FILE_NOT_FOUND );
		goto Exit;
	}

Exit:

	TraceFunctLeave();
	return hr;
}

HRESULT STDMETHODCALLTYPE
CNntpFSDriver::GetXoverCacheDirectory(
			IN	INNTPPropertyBag*	pPropBag,
			OUT	CHAR*	pBuffer,
			IN	DWORD	cbIn,
			OUT	DWORD	*pcbOut,
			OUT	BOOL*	fFlatDir
			) 	{

	TraceFunctEnter( "CNntpFSDriver::GetXoverCacheDirectory" ) ;
	CHAR		szGroupName[MAX_GROUPNAME];
	DWORD	dwLen = sizeof( szGroupName ) ;

	if( pPropBag == 0 ||
		pBuffer == 0 ||
		pcbOut == 0 )	 {
		if( pPropBag )	pPropBag->Release() ;
		return	E_INVALIDARG ;
	}

	HRESULT hr = S_OK ;
	*fFlatDir = FALSE ;

	// Share lock for usage count
	m_TermLock.ShareLock();
	if ( DriverUp != m_Status  ) {
		ErrorTrace( 0, "Request before initialization" );
		hr = NNTP_E_DRIVER_NOT_INITIALIZED;
		m_TermLock.ShareUnlock();
		goto Exit;
	}

	// Increment the usage count
	InterlockedIncrement( &m_cUsages );
	m_TermLock.ShareUnlock();

	hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group name failed %x" , hr );
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

    // Get a rough length and make sure our buffer is big enough
	*pcbOut = dwLen + strlen( m_szFSDir ) + 1 ;
	if( *pcbOut > cbIn )	{
		hr = TYPE_E_BUFFERTOOSMALL ;
		goto Exit ;	}

	GroupName2Path( szGroupName,  pBuffer ) ;

    //  Here we get the exact length and return back to caller.  No ASSERT.
    *pcbOut = strlen(pBuffer)+1;
	//_ASSERT( strlen( pBuffer )+1 == *pcbOut ) ;

	hr = S_OK ;

Exit:
	if( pPropBag )
		pPropBag->Release() ;
	InterlockedDecrement( &m_cUsages );
	return	hr ;
}



HRESULT
CNntpFSDriver::GetXoverInternal(    IN INNTPPropertyBag *pPropBag,
		                            IN ARTICLEID    idMinArticle,
        		                    IN ARTICLEID    idMaxArticle,
                		            OUT ARTICLEID   *pidNextArticle,
                		            IN LPSTR		szHeader,
                        		    OUT LPSTR       pcBuffer,
		                            IN DWORD        cbin,
        		                    OUT DWORD       *pcbout,
        		                    IN BOOL 		bIsXOver,
        		                    HANDLE          hToken,
        		                    INntpComplete   *pComplete )
/*++
Routine Description:

    Get Xover information from the store driver.

Arguments:

    IN INNTPPropertyBag *pPropBag - Interface pointer to the news group prop bag
    IN ARTICLEID idMinArticle   - The low range of article id to be retrieved from
    IN ARTICLEID idMaxArticle   - The high range of article id to be retrieved from
    OUT ARTICLEID *pidNextArticle - Buffer for actual last article id retrieved,
                                    0 if no article retrieved
    OUT LPSTR pcBuffer          - Header info retrieved
    IN DWORD cbin               - Size of pcBuffer
    OUT DWORD *pcbout           - Actual bytes written into pcBuffer
    IN BOOL bIsXOver 			- Is it xover or xhdr ?
    HANDLE  hToken              - Client's access token

Return value:

    S_OK                    - Succeeded.
    NNTP_E_DRIVER_NOT_INITIALIZED - Driver not initialized
    S_FALSE   - The buffer provided is too small, but content still filled
--*/
{
	TraceFunctEnter( "CNntpFSDriver::GetXover" );
	_ASSERT( pPropBag );
	_ASSERT( idMinArticle <= idMaxArticle );
	_ASSERT( pidNextArticle );
	_ASSERT( cbin > 0 );
	_ASSERT( pcbout );

	DWORD 				i;
	DWORD				cbCount = 0;
	INNTPPropertyBag	*pPrimary = NULL;
	DWORD				idPrimary = 0xffffffff;
	INNTPPropertyBag    *pPrimaryNext = NULL;
	DWORD               idPrimaryNext = 0xffffffff;
	HRESULT				hr = S_OK;
	DWORD				idArt;
	DWORD				dwLen;
	DWORD				dwActualLen;
	CArticleCore		*pArticle = NULL;
	CNntpReturn     	nntpReturn;
	LPSTR				lpstrStart;
	BOOL                bImpersonated = FALSE;
	INntpDriver         *pDriver = NULL;
	BOOL                fSuccess = FALSE;

	//
    // Create allocator for storing parsed header values
    //
    const DWORD cchMaxBuffer = 8 * 1024; // this should be enough
    									 // for normal cases, if
    									 // it's not enough, CAllocator
    									 // will use "new"
    CHAR        pchBuffer[cchMaxBuffer];
    CAllocator  allocator(pchBuffer, cchMaxBuffer);

    //
    // Buffer for get xover from article object
    //
    CHAR        pchXoverBuf[cchMaxXover+1];
    CPCString   pcXOver( pchXoverBuf, cchMaxXover );

    CHAR		szGroupName[MAX_GROUPNAME];
    CHAR		szGroupName2[MAX_GROUPNAME];
    CHAR		szFullPath[MAX_PATH+1];
    LPSTR		lpstrGroupName;
    LPSTR		lpstrEntry = NULL;

    const 		cMaxNumber = 20;
    CHAR		szNumBuf[cMaxNumber+1];

    // Completion object for query hash table
    CDriverSyncComplete   scCompletion;

    BOOL        bCompletePending = FALSE;   // Are there any hash table lookup
                                            // opertions pending ?

   	// Get group name for the property bag passed in
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group name failed %x", hr);
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	// We issue a hash table look up first, to better use
	// the async completion of hash table look up
	pPrimaryNext = NULL;
	scCompletion.AddRef();    // for hash table's release
	scCompletion.AddRef();    // for my wait
	_ASSERT( scCompletion.GetRef() == 2 );
	m_pNntpServer->FindPrimaryArticle(	pPropBag,
										idMinArticle,
										&pPrimaryNext,
										&idPrimaryNext,
										TRUE,
										&scCompletion,
										pComplete );
	scCompletion.WaitForCompletion();
	// Now we should have no reference
	_ASSERT( scCompletion.GetRef() == 0 );
	hr = scCompletion.GetResult();

	// Initialize *pidNextArticle
	*pidNextArticle = idMinArticle;

	// Following operations involve file system, we need to
	// impersonate here, if necessary
	if ( m_bUNC ) {
	    if ( !ImpersonateLoggedOnUser( hToken ) ) {
	        hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
	        ErrorTrace( 0, "Impersonation failed %x", hr );
	        goto Exit;
	    }
	    bImpersonated = TRUE;
    }

	// Loop thru the article id's
	for ( i = idMinArticle ; i <= idMaxArticle; i++ ) {

	    // Save off the next to current
	    pPrimary = pPrimaryNext;
	    idPrimary = idPrimaryNext;
	    pPrimaryNext = NULL;
	    idPrimaryNext = 0xffffffff;

        // If we still have next look up, issue it now
        if ( i + 1 <= idMaxArticle ) {
    		pPrimaryNext = NULL;
	    	scCompletion.AddRef();
	    	_ASSERT( scCompletion.GetRef() == 1 );
	    	scCompletion.AddRef();
	    	_ASSERT( scCompletion.GetRef() == 2 );
	    	scCompletion.Reset();
		    m_pNntpServer->FindPrimaryArticle(	pPropBag,
			    								i + 1,
				    							&pPrimaryNext,
					    						&idPrimaryNext,
												TRUE,
						    					&scCompletion,
						    					pComplete );
		    bCompletePending = TRUE;
		}

		if ( FAILED( hr ) ) { // this is the current hr
            if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == hr ||
                    HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == hr ) {
                // should proceed with other articles
                hr = S_OK;
                *pidNextArticle = i + 1;
                goto CompleteNext;
            } else {
                _ASSERT( hr != ERROR_PATH_NOT_FOUND );  // this helps find other
                                                        // error codes
			    ErrorTrace( 0, "Find primary article failed %x", hr);
			    goto Exit;
            }
		}

		_ASSERT( pPrimary );

		// if I've already got the primary, I don't need to get
		// group name, just use the one that I have
		if ( S_OK == hr ) {
			lpstrGroupName = szGroupName;
			idArt = i;
		} else {

			dwLen = MAX_GROUPNAME;
			hr = pPrimary->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName2, &dwLen);
			if ( FAILED( hr ) ) {
				ErrorTrace( 0, "Get group name failed %x" , hr );
				goto Exit;
			}
			_ASSERT( dwLen > 0 );

            // now the primary group will always have a copy of the article
			// This could be a group in other store ( vroot ), if so, I should use
		    // the local copy
		    _ASSERT( m_pINewsTree );
		    hr = m_pINewsTree->LookupVRoot( szGroupName2, &pDriver );
		    if ( FAILED( hr ) || NULL == pDriver || pDriver != this ) {

		        // for all these cases, I will use the local copy
		        DebugTrace( 0, "Lookup vroot %x", hr );
                lpstrGroupName = szGroupName;
                idArt = i;
            } else {
    			lpstrGroupName = szGroupName2;
	    		idArt = idPrimary;
	        }
		}

		_ASSERT( lpstrGroupName );
		_ASSERT( strlen( lpstrGroupName ) <= MAX_GROUPNAME );

		// Get the group full path
		dwLen = MAX_PATH;
		hr = ObtainFullPathOfArticleFile(	lpstrGroupName,
											idArt,
											szFullPath,
											dwLen );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Obtain full path failed %x" , hr);
			goto Exit;
		}
		_ASSERT( szFullPath);
		_ASSERT( strlen( szFullPath ) <= MAX_PATH );

		// Initialize the article object
		_ASSERT( NULL == pArticle );
		pArticle = new CArticleCore;
		if ( NULL == pArticle ) {
			ErrorTrace(0, "Out of memory" );
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		if ( ! pArticle->fInit( szFullPath, nntpReturn, &allocator, INVALID_HANDLE_VALUE, 0, TRUE ) ) {
			DebugTrace( 0, "Initialize article object failed %d",
						GetLastError() );

			// But I will still try to loop thru other articles
			*pidNextArticle =i + 1;
            hr = S_OK;
			goto CompleteNext;
		}

		// XOver or XHdr ?
		if ( bIsXOver ) {
            if ( pArticle->fXOver( pcXOver, nntpReturn ) ) {

                // Append xover info into out buffer
                // This is a rough esimate
                if ( cbCount + pcXOver.m_cch > cbin ) { // buffer not enough
                    hr = ( i == idMinArticle ) ?
                            HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ):
                            S_FALSE;
                    DebugTrace(0, "Buffer too small" );
                    goto Exit;
                }

                // Set the article id before the entry
				lpstrStart = pcXOver.m_pch + cMaxNumber;
				_ASSERT( *lpstrStart == '\t' ); // this is what article obj should do
				_ltoa( i, szNumBuf,10 );
				_ASSERT( *szNumBuf );
				dwLen = strlen( szNumBuf );
				_ASSERT( dwLen <= cMaxNumber );
				lpstrStart -= dwLen;
				CopyMemory( lpstrStart, szNumBuf, dwLen );
				dwActualLen = pcXOver.m_cch - ( cMaxNumber - dwLen );
                CopyMemory( pcBuffer + cbCount, lpstrStart, dwActualLen );
                cbCount += dwActualLen;
                *pidNextArticle = i + 1;

                //
                // Clear pcXOver
                //
                pcXOver.m_pch = pchXoverBuf;
                pcXOver.m_cch = cchMaxBuffer;
            } else {

            	DebugTrace( 0, "Get XOver failed %d", GetLastError() );
            	hr = S_OK;
            	*pidNextArticle = i + 1;
            	goto CompleteNext;
            }
        } else {	// get xhdr
            //
            // get header length
            //
            _ASSERT( szHeader );
            _ASSERT( strlen( szHeader ) <= MAX_PATH );
            dwLen = 0;
            pArticle->fGetHeader( szHeader, NULL, 0, dwLen );
            if ( dwLen > 0 ) {

                //
                // Allocate buffer
                //
                lpstrEntry = NULL;
                lpstrEntry = pArticle->pAllocator()->Alloc( dwLen + 1 );
                if ( !lpstrEntry ) {
                    ErrorTrace(0, "Out of memory" );
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
                if ( !pArticle->fGetHeader( szHeader, (UCHAR*)lpstrEntry, dwLen + 1, dwLen ) ) {
                    DebugTrace( 0, "Get Xhdr failed %x", GetLastError() );
                    hr = S_OK;
                    *pidNextArticle = i + 1;
                    goto CompleteNext;
                }

                //
                // Append this header info, including the art id
                //
                _ltoa( i, szNumBuf, 10 );
                _ASSERT( *szNumBuf );
                dwActualLen = strlen( szNumBuf );
                _ASSERT( dwActualLen <= cMaxNumber );
                if ( cbCount + dwLen + dwActualLen + 1 > cbin ) { // buffer not enough
                    hr = ( i == idMinArticle ) ?
                        HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) :
                        S_FALSE;
                    ErrorTrace(0, "Buffer too small" );
                    goto Exit;
                }
                CopyMemory( pcBuffer + cbCount, szNumBuf, dwActualLen );
                cbCount += dwActualLen;
                *(pcBuffer+cbCount++) = ' ';
                CopyMemory( pcBuffer + cbCount, lpstrEntry, dwLen );
                cbCount += dwLen;
                *pidNextArticle = i + 1;

                pArticle->pAllocator()->Free( lpstrEntry );
                lpstrEntry = NULL;
            } else {
                DebugTrace( 0, "Get Xhdr failed %d", GetLastError() );
                hr = S_OK;
                *pidNextArticle = i + 1;
                goto CompleteNext;
            }
        }

CompleteNext:
		// delete the article object
		if( pArticle )
		    delete pArticle;
		pArticle = NULL;

		// Releaes property bag interface
		if ( pPrimary ) {
			pComplete->ReleaseBag( pPrimary );
		}
		pPrimary = NULL;

		// Now if we have next to complete, we should complete it
		if ( i + 1 <= idMaxArticle ) {

		    // We should have said there are pending completions
		    _ASSERT( bCompletePending );
        	scCompletion.WaitForCompletion();

        	// Now we should have one reference
        	_ASSERT( scCompletion.GetRef() == 0 );
        	hr = scCompletion.GetResult();
        	bCompletePending = FALSE;
		}
	}

Exit:	// clean up

    if ( bImpersonated ) RevertToSelf();

	*pcbout = cbCount;

    if ( S_OK == hr && cbCount == 0 ) hr = S_FALSE;

    // If we have completions pending, we must have come here
    // from error path, we should wait for it to complete first
    if ( bCompletePending ) {
        scCompletion.WaitForCompletion();
        _ASSERT( scCompletion.GetRef() == 0 );
    }

	if ( lpstrEntry ) {
		_ASSERT( pArticle );
		pArticle->pAllocator()->Free( lpstrEntry );
	}
	if ( pArticle ) delete pArticle;
	if ( pPrimary ) pComplete->ReleaseBag ( pPrimary );
	if ( pPrimaryNext ) pComplete->ReleaseBag( pPrimaryNext );
	if ( pPropBag ) pComplete->ReleaseBag( pPropBag );

	TraceFunctLeave();

	return hr;
}

HRESULT
CNntpFSDriver::EnumCheckInternal( 	INNTPPropertyBag *pPropBag,
                                    INntpComplete   *pComplete )
/*++

Routine description:

	Check group property consistency against itself and
	hash tables.

Arguments:

	INNTPPropertyBag *pPropBag - The group property bag

Return value:

	S_OK - Success
	NNTP_E_GROUP_CORRUPT - Group corrupted
--*/
{

	TraceFunctEnter( "CNntpFSDriver::EnumCheckInternal" );
	_ASSERT( pPropBag );
	_ASSERT( m_pNntpServer );	// I want to use this guy

	HRESULT hr = S_OK;

	DWORD	dwArtLow, dwArtHigh;
	DWORD	dwPrimary;
	DWORD	dwPrimHigh, dwPrimLow;
	INNTPPropertyBag *pPrimary = NULL;
	DWORD	i;
	CHAR	szGroupName[MAX_GROUPNAME+1];
	DWORD	dwLen;
	INntpDriver *pDriver = NULL;

	CDriverSyncComplete scCompletion;

	// check if this group belongs to me, if it doesn't
	// I will return S_OK
	dwLen = MAX_GROUPNAME;
	hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (PBYTE)szGroupName, &dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group name failed %x", hr );
		goto Exit;
	}
	_ASSERT( dwLen <= MAX_GROUPNAME && dwLen > 0);

	hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Vroot lookup failed %x", hr );
		goto Exit;
	}

	// check if this is me ?
	if ( (INntpDriver*)this != pDriver ) {
		hr = S_OK;
		DebugTrace( 0, "This group doesn't belong to me" );
		goto Exit;
	}

	// Get art low / high watermark first
	hr = pPropBag->GetDWord( NEWSGRP_PROP_FIRSTARTICLE, &dwArtLow );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get first article failed %x", hr );
		goto Exit;
	}

	hr = pPropBag->GetDWord( NEWSGRP_PROP_LASTARTICLE, &dwArtHigh );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get last article failed %x", hr );
		goto Exit;
	}

	// Validate low / high
	if ( !( dwArtLow <= dwArtHigh || dwArtLow - dwArtHigh == 1 ) ||
	        dwArtLow < 1 ) {
		DebugTrace( 0, "Group high / low inconsistenty" );
		hr = NNTP_E_GROUP_CORRUPT;
		goto Exit;
	}

	// if group is empty, it's OK
	if ( dwArtLow - dwArtHigh == 1 ) {
	    hr = S_OK;
	    goto Exit;
	}

	// Check low and high against hash table
	for ( i = dwArtLow; i <= dwArtHigh;
			i += ( dwArtHigh - dwArtLow == 0 ? 1:
					dwArtHigh - dwArtLow ) ) {
        scCompletion.AddRef();
		scCompletion.AddRef();
		_ASSERT( scCompletion.GetRef() == 2 );
		m_pNntpServer->FindPrimaryArticle( pPropBag,
											i,
											&pPrimary,
											&dwPrimary,
											FALSE,
											&scCompletion,
											pComplete );
		scCompletion.WaitForCompletion();
		_ASSERT( scCompletion.GetRef() == 0 );
		hr = scCompletion.GetResult();
		if ( FAILED( hr ) ) {
			DebugTrace( 0, "Low id can't be found in hash table %x", hr );
			hr = NNTP_E_GROUP_CORRUPT;
			goto Exit;
		}

		_ASSERT( pPrimary );

		if ( hr == S_FALSE ) { // only in this case we need to check

			_ASSERT( pPropBag != pPrimary );

			// Get primary's high / low water mark
			hr = pPrimary->GetDWord( NEWSGRP_PROP_FIRSTARTICLE, &dwPrimLow );
			if ( FAILED( hr ) ) {
				// this is fatal
				ErrorTrace( 0, "Get low water mark failed %x", hr );
				goto Exit;
			}

			hr = pPrimary->GetDWord( NEWSGRP_PROP_LASTARTICLE, &dwPrimHigh );
			if ( FAILED( hr ) ) {
				// this is fatal
				ErrorTrace( 0, "Get high water mark failed %x", hr );
				goto Exit;
			}

			// check
			if ( dwPrimary > dwPrimHigh || dwPrimary < dwPrimLow ) {
				DebugTrace( 0, "Hash table for group corrupted" );
				hr = NNTP_E_GROUP_CORRUPT;
				goto Exit;
			}
		}

    	// Release primary gorup
		_ASSERT( pPrimary );
		pComplete->ReleaseBag( pPrimary );
		pPrimary = NULL;
	}

Exit:

	if ( pPrimary ) {
		pComplete->ReleaseBag( pPrimary );
		pPrimary = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::ObtainFullPathOfArticleFile( IN LPSTR        szNewsGroupName,
                                            IN DWORD        dwArticleId,
                                            OUT LPSTR       pchBuffer,
                                            IN OUT DWORD&   cchBuffer )
/*++
Routine description:

    Given news group name and article id, build a full path file name for
    the article based on the store driver's article naming convention.

Arguments:

    IN LPSTR    szNewsGroupName - The news group name
    IN DWORD    dwArticleId     - The article Id
    OUT LPSTR   pchBuffer       - The buffer to return the full path
    IN DWORD&   cchBuffer       - The size of buffer prepared
    OUT DWORD&  cchBuffer       - On success, the actual length of string returned
                                  On fail because of insufficient buffer, the buffer size needed
                                  On fail because of other reasons, undefined

Return value:

    S_OK                    - Succeeded
    TYPE_E_BUFFERTOOSMALL   - The prepared buffer is too small
--*/
{
    TraceFunctEnter( "CNntpFSDriver::ObtainFullPathOfArticleFile" );
    _ASSERT( szNewsGroupName );
    _ASSERT( strlen( szNewsGroupName ) <= MAX_GROUPNAME );
    _ASSERT( pchBuffer );
    _ASSERT( cchBuffer > 0 );

    DWORD   dwBufferLenNeeded;
    DWORD   dwCount = 0;
    DWORD   dwArtId;
    HRESULT hr = S_OK;

    //
    //  Is the buffer big enough ?
    //  We have three parts for the whole path:
    //  1. Vroot path ( with or without trailing "\\" );
    //  2. The relative path from the group name ( equal length of group name, excluding "\\" );
    //  3. The article file name ( at most 12 )
    //
    if ( cchBuffer <
            ( dwBufferLenNeeded = lstrlen( m_szFSDir ) + lstrlen( szNewsGroupName ) + 14 )) {
        cchBuffer = dwBufferLenNeeded;
        hr = TYPE_E_BUFFERTOOSMALL;
        goto Exit;
    }

	// Convert the group name into FS path
	GroupName2Path( szNewsGroupName, pchBuffer );

    //
    // generate and catenate the file name
    //
    dwCount = strlen( pchBuffer );
    _ASSERT( dwCount > 0 );
    if ( *(pchBuffer + dwCount - 1 ) != '\\' ) {
	    *( pchBuffer + dwCount++ ) = '\\';
	}
    dwArtId = ArticleIdMapper( dwArticleId );
    _itoa( dwArtId, pchBuffer + dwCount, 16 );
    lstrcat( pchBuffer, g_szArticleFileExtension );

    cchBuffer = lstrlen( pchBuffer );
    _ASSERT( cchBuffer <= dwBufferLenNeeded );

Exit:
    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::ReadVrootInfo( IUnknown *punkMetabase )
/*++
Routine Description:

	Read the vroot info from metabase.

Arguments:

	IUnknown *punkMetabase - Unknown interface of metabase object

Return value:

	S_OK - on success, error code otherwise
--*/
{
	TraceFunctEnter( "CNntpFSDriver::ReadVRootInfo" );
	_ASSERT( punkMetabase );

	IMSAdminBase *pMB = NULL;
	HRESULT 	hr = S_OK;
	METADATA_HANDLE hVroot;
	WCHAR	wszBuffer[MAX_PATH+1];
	CHAR    szBuffer[MAX_PATH+1];
	DWORD	dwLen;
	BOOL	bKeyOpened = FALSE;
	DWORD	dwRetry = 5;
	DWORD   err;

	// Query for the right interface to do MB operation
	hr = punkMetabase->QueryInterface( IID_IMSAdminBase, (void**)&pMB );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Query for MB interface failed %x", hr );
		goto Exit;
	}

	// Open the MB key
	_ASSERT( m_wszMBVrootPath );
	_ASSERT( *m_wszMBVrootPath );
	do {
		hr = pMB->OpenKey( 	METADATA_MASTER_ROOT_HANDLE,
							m_wszMBVrootPath,
							METADATA_PERMISSION_READ,
							100,
		 					&hVroot );
	}
	while ( FAILED( hr ) && --dwRetry > 0 );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Open MB key failed %x" , hr );
		goto Exit;
	}

	bKeyOpened = TRUE;

	// Read vroot path
	dwLen = MAX_PATH;
	hr = GetString( pMB, hVroot, MD_FS_VROOT_PATH, wszBuffer, &dwLen );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Vroot path not found in mb %x", hr );
		goto Exit;
	}

	// Check file system type and UNC information
	CopyUnicodeStringIntoAscii( szBuffer, wszBuffer );
	_ASSERT( strlen( szBuffer ) <= MAX_PATH );

	err = GetFileSystemType(    szBuffer,
	                            &m_dwFSType,
	                            &m_bUNC );
	if ( err != NO_ERROR || m_dwFSType == FS_ERROR ) {
	    hr = HresultFromWin32TakeDefault( ERROR_INVALID_PARAMETER );
	    ErrorTrace( 0, "GetFileSystemType failed %x", hr );
        goto Exit;
    }

    // Make up the vroot dir
	strcpy( m_szFSDir, "\\\\?\\" );
	if ( m_bUNC ) {
	    strcat( m_szFSDir, "UNC" );
	    strcat( m_szFSDir, szBuffer + 1 ); // strip off one '\\'
	} else { // non UNC
	    strcat( m_szFSDir, szBuffer );
	}
    _ASSERT( strlen( m_szFSDir ) <= MAX_PATH );

	// Read vroot specific group property file path
	dwLen = MAX_PATH;
	*wszBuffer = 0;
	hr = GetString( pMB, hVroot, MD_FS_PROPERTY_PATH, wszBuffer, &dwLen );
	if ( FAILED( hr ) || *wszBuffer == 0 ) {
		DebugTrace( 0, "Group property file path not found in mb %x", hr);

		// we'll use vroot path as default
		_ASSERT( m_szFSDir );
		_ASSERT( *m_szFSDir );
		strcpy( m_szPropFile, m_szFSDir );
	} else {

		CopyUnicodeStringIntoAscii( m_szPropFile, wszBuffer );
    }

    _ASSERT( *m_szPropFile );

	//
	// Append the group file name
	//
	/*if ( *(m_szPropFile+strlen(m_szPropFile)-1) == ':' ||
	     *(m_szPropFile) == '\\' && *(m_szPropFile+1) == '\\' )*/
    strcat( m_szPropFile, "\\group" );

    hr = S_OK;

Exit:

	// Close the key
	if ( bKeyOpened ) {
		pMB->CloseKey( hVroot );
	}

	// Release it
	if ( pMB ) {
		pMB->Release();
		pMB = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HANDLE
CNntpFSDriver::CreateFileCallback(  LPSTR   lpstrName,
                                    LPVOID  lpvData,
                                    DWORD*  pdwSize,
                                    DWORD*  pdwSizeHigh )
/*++
Routine Description:

    Function that gets called on a cache miss.

Arguments:

    LPSTR lpstrName - File name
    LPVOID lpvData  - Callback context
    DWORD* pdwSize  - To return file size

Return value:

    File handle
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CreateFileCallback" );
    _ASSERT( lpstrName );
    _ASSERT( strlen( lpstrName ) <= MAX_PATH );
    _ASSERT( pdwSize );

    CREATE_FILE_ARG *arg = (CREATE_FILE_ARG*)lpvData;

    // If we are UNC vroot, we need to do impersonation
    if ( arg->bUNC ) {
        if ( !ImpersonateLoggedOnUser( arg->hToken ) ) {
            ErrorTrace( 0, "Impersonation failed %d", GetLastError() );
            return INVALID_HANDLE_VALUE;
        }
    }

    HANDLE hFile = CreateFileA(
                    lpstrName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    0,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_READONLY |
                    FILE_FLAG_SEQUENTIAL_SCAN |
                    FILE_FLAG_OVERLAPPED,
                    NULL
                    ) ;
    if( hFile != INVALID_HANDLE_VALUE ) {
        *pdwSize = GetFileSize( hFile, pdwSizeHigh ) ;
    }

    if ( arg->bUNC ) RevertToSelf();

    return  hFile ;
}

HRESULT
CNntpFSDriver::LoadGroupSecurityDescriptor( INNTPPropertyBag    *pPropBag,
                                            LPSTR&              lpstrSecDesc,
                                            PDWORD              pcbSecDesc,
                                            BOOL                bSetProp,
                                            PBOOL               pbAllocated )
/*++
Routine description:

    Load group's security descriptor from file system.  If bSetProp
    is true, it will also be loaded into the group's property bag

Arguments:

    INNNTPPropertyBag *pPropBag - The group's property bag
    LPSTR &lpstrSecDesc         - To receive the security descriptor
                                    It originally points to stack, only
                                    when the buffer on stack is not big
                                    enough will we allocate
    PDWORD  &pcbSecDesc         - To receive the length of security descriptor
    BOOL    bSetProp            - Whether to set it to property bag
    PBOOL   pbAllocated         - Tell caller if we have allocated buffer

Return value:

    S_OK - Success, Other HRESULT otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::LoadGroupSecurityDescriptor" );
    _ASSERT( pPropBag );
    _ASSERT( lpstrSecDesc );
    _ASSERT( pcbSecDesc );
    _ASSERT( pbAllocated );
    _ASSERT( *pcbSecDesc > 0 ); // original buffer size should be passed in

    CHAR    szGroupName[MAX_NEWSGROUP_NAME+1];
    DWORD   cbGroupName = MAX_NEWSGROUP_NAME+1;
    CHAR    szDirectory[MAX_PATH+1];
    HRESULT hr = S_OK;
    DWORD   dwSizeNeeded;

    SECURITY_INFORMATION	si =
				OWNER_SECURITY_INFORMATION |
				GROUP_SECURITY_INFORMATION |
				DACL_SECURITY_INFORMATION ;

    // Get the group name first
    hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME,
                            (PBYTE)szGroupName,
                            &cbGroupName );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Get group name failed %x", hr );
        goto Exit;
    }
    _ASSERT( *(szGroupName+cbGroupName-1) == 0 );

    // We use the group name to make up the directory path
    GroupName2Path( szGroupName, szDirectory );
    _ASSERT( strlen( szDirectory ) < MAX_PATH + 1 );

    *pbAllocated = FALSE;

    // Get the directory's security descriptor
    if ( !GetFileSecurity(  szDirectory,
                            si,
                            lpstrSecDesc,
                            *pcbSecDesc,
                            &dwSizeNeeded ) ) {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                dwSizeNeeded > *pcbSecDesc ) {

            // We allocate it
            lpstrSecDesc = XNEW char[dwSizeNeeded];
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Out of memory" );
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            *pbAllocated = TRUE;

            // Load it again
            if ( !GetFileSecurity(  szDirectory,
                                    si,
                                    lpstrSecDesc,
                                    dwSizeNeeded,
                                    &dwSizeNeeded ) ) {
                // This is fatal
        	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
                ErrorTrace( 0, "Second try loading desc failed %x", hr);
                goto Exit;
            }
        } else {    // fatal reason

    	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
            ErrorTrace( 0, "Get file sec desc failed %x", hr );
            goto Exit;
        }
    }

    // Being here, we already have the descriptor
    // If we are asked to set this property into property bag,
    // do it now
    if ( bSetProp ) {

        hr = pPropBag->PutBLOB( NEWSGRP_PROP_SECDESC,
                                dwSizeNeeded,
                                PBYTE(lpstrSecDesc));
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Put security descriptor failed %x", hr );
            goto Exit;
        }
    }

    *pcbSecDesc = dwSizeNeeded;

Exit:

    TraceFunctLeave();
    return hr;
}

BOOL
CNntpFSDriver::InvalidateGroupSecInternal( LPWSTR  wszDir )
/*++
Routine description:

    Invalidate the group security descriptor, so that the next time
    CheckGroupAccess is called, we'll load the security descriptor
    again.  This function gets called as callback by DirNot when
    DirNot is sure which specific directory's security descriptor
    has been changed

Arguments:

    PVOID pvContext - Context we have given DirNot ( this pointer in this case )
    LPWSTR wszDir   - The directory whose security descriptor has been changed

Return value:

    TRUE if succeeded, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::InvalidateGroupSecInternal" );
    _ASSERT( wszDir );

    CHAR szDir[MAX_PATH+1];
    CHAR szGroupName[MAX_NEWSGROUP_NAME+1];
    HRESULT hr = S_OK;
    INNTPPropertyBag *pPropBag = NULL;
    INntpDriver *pDriver;

    // Convert the directory to ascii
    CopyUnicodeStringIntoAscii( szDir, wszDir );

    // Convert the path into newsgroup name
    Path2GroupName( szGroupName, szDir );

    //
	// Check to see if this group really belongs to me
	//
	hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
		DebugTrace(0, "I don't own this group %s", szGroupName );
		goto Exit;
	}

    // Try to locate the group in newstree
    hr = m_pINewsTree->FindOrCreateGroupByName(	szGroupName,
												FALSE,
												&pPropBag,
												NULL,
												0xffffffff, // fake group id
												FALSE       );// we don't set group id
    /* We are pretty risky here to pass in NULL as the completion
       object, since the completion object passed in else where helps
       uncover group object leaks.  We can not pass in completion
       object here because this operation is not initialiated from
       protocol.  We should make sure that we don't leak group
       object here.
    */
	if ( FAILED( hr ) ) {
		DebugTrace( 0, "Can not find the group based on path %x" , hr );
		goto Exit;
	}

	// Should return either ERROR_NOT_FOUND or S_FALSE
	_ASSERT(    HRESULT_FROM_WIN32(ERROR_NOT_FOUND ) == hr ||
	            S_FALSE == hr );

    // Now remove the security descriptor from the group object
    _ASSERT( pPropBag );
    hr = pPropBag->RemoveProperty( NEWSGRP_PROP_SECDESC );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Remove security descriptor failed %x", hr );
        goto Exit;
    }

Exit:

    // Release bag, if necessary
    if ( pPropBag ) pPropBag->Release();
    pPropBag = NULL;

    //
    // I want to disable retry logic in DirNot, because there is
    // no reason here for DirNot to retry. So we always return
    // TRUE but assert real failed cases.
    //
    _ASSERT( SUCCEEDED( hr ) || HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == hr );
    return TRUE;
}

HRESULT
CNntpFSDriver::InvalidateTreeSecInternal()
/*++
Routine description:

    Invalidate the security descriptors in the whole tree.  We don't
    want to keep the whole tree from being accessed for this operation
    because we think that latencies in update of security descriptor
    are fine.

Arguments:

    None.

Return value:

    S_OK if succeeded, HRESULT error code otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::InvalidateTreeSecInternal" );

    INewsTreeIterator *piter    = NULL;
	INNTPPropertyBag *pPropBag  = NULL;
	BOOL    bWeAreInvalidating  = FALSE;
	HRESULT hr                  = S_OK;
	CHAR    szGroupName[MAX_NEWSGROUP_NAME];
	DWORD   dwLen = MAX_NEWSGROUP_NAME;
	INntpDriver*    pDriver;

    //
    // We should tell other notifications that we are already
    // invalidating the whole tree, so invalidating the tree
    // for a second time is not necessary
    //
    if ( InterlockedExchange(&m_lInvalidating, Invalidating) == Invalidating ) {

        //
        // Somebody else is already invalidating the tree, we should
        // not do this anymore
        //
        DebugTrace( 0, "Somebody else is already invalidating the tree" );
        goto Exit;
    }

    // We should invalidate the tree
    bWeAreInvalidating = TRUE;

	// Get the newstree iterator
	hr = m_pINewsTree->GetIterator( &piter );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get news tree iterator failed %x", hr );
		goto Exit;
	}

	// Enumerate all the groups
	_ASSERT( piter );
	while( !(piter->IsEnd()) ) {

		hr = piter->Current( &pPropBag, NULL );
		/*  Again, by passing the NULL as completion object here, we
		    are swearing to the protocol that we will release the
		    group object and you don't have to do check on me
		*/
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Enumerate group failed %x", hr );
			goto Exit;
		}
		_ASSERT( pPropBag );

		//
		// Get group name to check if this group belongs to us
		//
		dwLen = MAX_NEWSGROUP_NAME;
		hr = pPropBag->GetBLOB( NEWSGRP_PROP_NAME, (PBYTE)szGroupName, &dwLen );
		if ( FAILED( hr ) ) {
		    _ASSERT( FALSE && "Should have group name" );
		    ErrorTrace( 0, "Get group name failed with %x", hr );
		    goto Exit;
		}

		//
	    // Check to see if this group really belongs to me
	    //
	    hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver );
	    if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
		    DebugTrace(0, "I don't own this group %s", szGroupName );

		    //
		    // but we should still continue to invalid other groups
	    } else {

		    // Remove the security descriptor from the group
		    hr = pPropBag->RemoveProperty( NEWSGRP_PROP_SECDESC );
		    if ( FAILED( hr ) && HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) != hr ) {
		        ErrorTrace( 0, "Remove secruity descriptor failed %x", hr );
		        goto Exit;
		    }
		}

		_ASSERT( pPropBag );
		pPropBag->Release();
		pPropBag = NULL;

		piter->Next();
	}

Exit:


	if ( pPropBag ) {
		pPropBag->Release();
		pPropBag = NULL;
	}

	if ( piter ) {
		piter->Release();
		piter = NULL;
	}

	//
	// Now tell others that invalidating is completed, but we won't
	// disturb other invalidating process if we didn't do the invalidating
	// in the first place
	//
	if ( bWeAreInvalidating )
	    _VERIFY( Invalidating == InterlockedExchange( &m_lInvalidating, Invalidated ) );

    if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == hr ) hr = S_OK;
	TraceFunctLeave();
	return hr;
}

 DWORD
CNntpFSDriver::GetFileSystemType(
    IN  LPCSTR      pszRealPath,
    OUT LPDWORD     lpdwFileSystem,
    OUT PBOOL       pbUNC
    )
/*++
    Gets file system specific information for a given path.
    It uses GetVolumeInfomration() to query the file system type
       and file system flags.
    On success the flags and file system type are returned in
       passed in pointers.

    Arguments:

        pszRealPath    pointer to buffer containing path for which
                         we are inquiring the file system details.

        lpdwFileSystem
            pointer to buffer to fill in the type of file system.

        pbUNC
            Am I UNC vroot ?

    Returns:
        NO_ERROR  on success and Win32 error code if any error.

--*/
{
    TraceFunctEnter( "CNntpFSDriver::GetFileSystemType" );

    CHAR    rgchBuf[MAX_FILE_SYSTEM_NAME_SIZE];
    CHAR    rgchRoot[MAX_FILE_SYSTEM_NAME_SIZE];
    int     i;
    DWORD   dwReturn = ERROR_PATH_NOT_FOUND;
    DWORD   len;

    if ( (pszRealPath == NULL) || (lpdwFileSystem == NULL)) {
        return ( ERROR_INVALID_PARAMETER);
    }

    ZeroMemory( rgchRoot, sizeof(rgchRoot) );
    *lpdwFileSystem = FS_ERROR;

    //
    // Copy just the root directory to rgchRoot for querying
    //
    if ( (pszRealPath[0] == '\\') &&
         (pszRealPath[1] == '\\')) {

         *lpdwFileSystem = FS_NTFS; // so that we'll always do check
         *pbUNC = TRUE;

         return NO_ERROR;


#if 0 // if UNC vroot, we always do impersonation, thus no need
      // to check if it's a fat
        PCHAR pszEnd;

        //
        // this is an UNC name. Extract just the first two components
        //
        //
        pszEnd = strchr( pszRealPath+2, '\\');

        if ( pszEnd == NULL) {

            // just the server name present

            return ( ERROR_INVALID_PARAMETER);
        }

        pszEnd = (PCHAR)_mbschr( (PUCHAR)pszEnd+1, '\\');

        len = ( ( pszEnd == NULL) ? strlen(pszRealPath)
               : ((pszEnd - pszRealPath) + 1) );

        //
        // Copy till the end of UNC Name only (exclude all other path info)
        //

        if ( len < (MAX_FILE_SYSTEM_NAME_SIZE - 1) ) {

            CopyMemory( rgchRoot, pszRealPath, len);
            rgchRoot[len] = '\0';
        } else {

            return ( ERROR_INVALID_NAME);
        }

#if 1 // DBCS enabling for share name
        if ( *CharPrev( rgchRoot, rgchRoot + len ) != '\\' ) {
#else
        if ( rgchRoot[len - 1] != '\\' ) {
#endif

            if ( len < MAX_FILE_SYSTEM_NAME_SIZE - 2 ) {
                rgchRoot[len]   = '\\';
                rgchRoot[len+1] = '\0';
            } else {

                return (ERROR_INVALID_NAME);
            }
        }
#endif
    } else {

        //
        // This is non UNC name.
        // Copy just the root directory to rgchRoot for querying
        //
        *pbUNC = FALSE;

        for( i = 0; i < 9 && pszRealPath[i] != '\0'; i++) {

            if ( (rgchRoot[i] = pszRealPath[i]) == ':') {

                break;
            }
        } // for


        if ( rgchRoot[i] != ':') {

            //
            // we could not find the root directory.
            //  return with error value
            //

            return ( ERROR_INVALID_PARAMETER);
        }

        rgchRoot[i+1] = '\\';     // terminate the drive spec with a slash
        rgchRoot[i+2] = '\0';     // terminate the drive spec with null char

    } // else

    //
    // The rgchRoot should end with a "\" (slash)
    // otherwise, the call will fail.
    //

    if (  GetVolumeInformation( rgchRoot,        // lpRootPathName
                                NULL,            // lpVolumeNameBuffer
                                0,               // len of volume name buffer
                                NULL,            // lpdwVolSerialNumber
                                NULL,            // lpdwMaxComponentLength
                                NULL,            // lpdwSystemFlags
                                rgchBuf,         // lpFileSystemNameBuff
                                sizeof(rgchBuf)
                                ) ) {



        dwReturn = NO_ERROR;

        if ( strcmp( rgchBuf, "FAT") == 0) {

            *lpdwFileSystem = FS_FAT;

        } else if ( strcmp( rgchBuf, "NTFS") == 0) {

            *lpdwFileSystem = FS_NTFS;

        } else if ( strcmp( rgchBuf, "HPFS") == 0) {

            *lpdwFileSystem = FS_HPFS;

        } else if ( strcmp( rgchBuf, "CDFS") == 0) {

            *lpdwFileSystem = FS_CDFS;

        } else if ( strcmp( rgchBuf, "OFS") == 0) {

            *lpdwFileSystem = FS_OFS;

        } else {

            *lpdwFileSystem = FS_FAT;
        }

    } else {

        dwReturn = GetLastError();

        /*IF_DEBUG( DLL_VIRTUAL_ROOTS)*/ {

            ErrorTrace( 0,
                        " GetVolumeInformation( %s) failed with error %d\n",
                        rgchRoot, dwReturn);
        }

    }

    TraceFunctLeave();
    return ( dwReturn);
} // GetFileSystemType()

HRESULT
CNntpFSDriver::InitializeVppFile()
/*++
Routine description:

    Initialzie the group property file.  We'll not only create the
    object, but also check integrity of the file.  If the integrity
    is good, we'll return success.  If the file is somehow corrupted,
    we only return success if the server is in rebuild mode.   In
    those cases, we want to make sure that the vpp file is removed.

Arguments:

    None.

Return value:

    S_OK if succeeded, other error code if failed
--*/
{
    TraceFunctEnter( "CNntpFSDriver::InitializeVppFile" );

    HRESULT hr = S_OK;
    VAR_PROP_RECORD vpRecord;
    DWORD           cData;
    CHAR            szFileName[MAX_PATH+1];

    //
    // If server is doing clean rebuild, we should not trust
    // vpp file
    //
    if ( m_pNntpServer->QueryServerMode() == NNTP_SERVER_CLEAN_REBUILD ) {
        strcpy( szFileName, m_szPropFile );
        strcat( szFileName, ".vpp" );
        DeleteFile( szFileName );
        m_pffPropFile = NULL;
        return S_OK;
    }

    //
    // Create and initialize the flatfile object
    //
	m_pffPropFile = XNEW CFlatFile(	m_szPropFile,
									".vpp",
									NULL,
									CNntpFSDriver::OffsetUpdate );
	if ( NULL == m_pffPropFile ) {
		ErrorTrace( 0, "Create flat file object fail %d",
						GetLastError() );
	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
		return hr;
	}

    //
	// Try read one record from flatfile, to see if it will
	// cause sharing violation, and to keep the file handle open
	//
	hr = m_pffPropFile->GetFirstRecord( PBYTE(&vpRecord), &cData );
	if ( FAILED( hr ) && hr != HRESULT_FROM_WIN32( ERROR_MORE_DATA ) ) {
	    DebugTrace( 0, "Flatfile sharing violation" );
	    XDELETE m_pffPropFile;
	    m_pffPropFile = NULL;
	    return hr;
	} else hr = S_OK;

    //
    // Check to see if the vpp file is corrupted
    //
    if ( m_pffPropFile->FileInGoodShape() ) {

        //
        // Set it to be corrupted so that unless it is properly shutdown,
        // it will look corrupted to the next guy who initializes it again
        //
        /*
        hr = m_pffPropFile->DirtyIntegrityFlag();
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Dirty integrity flag failed %x", hr );
            XDELETE m_pffPropFile;
            m_pffPropFile = NULL;
            return hr;
        }
        */

        DebugTrace( 0, "The vpp file is good" );
        TraceFunctLeave();
        return hr;
    }

    //
    // Now I am pretty sure that the vpp file is corrupted
    //
    if ( m_pNntpServer->QueryServerMode() == NNTP_SERVER_STANDARD_REBUILD
        || m_pNntpServer->QueryServerMode() == NNTP_SERVER_CLEAN_REBUILD ) {

        //
        // If the driver is being connected for rebuild purpose, we should
        // still go ahead and allow the driver to connect, but we should
        // destroy the vpp file object, so that in DecorateNewsTree, we'll
        // know that the vpp file is not credible and we'll have to do
        // root scan
        //
        XDELETE m_pffPropFile;
        m_pffPropFile = NULL;
        TraceFunctLeave();
        return S_OK;
    }

    //
    // The file is corrupted and we are not rebuilding, so we'll have to report
    // error, which will cause the driver connection to fail
    //
    TraceFunctLeave();
    return HRESULT_FROM_WIN32( ERROR_FILE_CORRUPT );
}

HRESULT
CNntpFSDriver::TerminateVppFile()
/*++
Routine description:

    Terminate the vpp file, as the last thing to do, it sets the
    integrity flag on the vpp file, so that the next guy who
    opens the vpp file will know that the file is not corrupted

Arguments:

    None.

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::TerminateVppFile" );

    //
    // Set the flag
    //
    /*
    HRESULT hr = m_pffPropFile->SetIntegrityFlag();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Failed to set the integrity flag %x", hr );
    }
    */

    //
    // This is non-fatal: it only means that next time the server is up, we
    // will think that the vpp file has been corrupted and rebuild is needed
    // So we'll go ahead and destroy the object
    //
    HRESULT hr = S_OK;
    XDELETE m_pffPropFile;
    m_pffPropFile = NULL;

    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::CreateGroupInTree(   LPSTR szPath,
                                    INNTPPropertyBag **ppPropBag )
/*++
Routine description:

    Create the group in tree, given group name ( fs path in fact )

Arguments:

    LPSTR szPath - The file system path of the group
    INNTPPropertyBag **ppPropBag - To take group property bag

Return value:

    S_OK/S_FALSE if succeeded; error code otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CreateGroupInTree" );
    _ASSERT( szPath );
    _ASSERT( ppPropBag );

    CHAR szGroupName[MAX_NEWSGROUP_NAME+1];
    HRESULT hr = S_OK;

    //
    // Convert the path into group name
    //
    Path2GroupName( szGroupName, szPath );
    _ASSERT( strlen( szGroupName ) <= MAX_NEWSGROUP_NAME );

    //
    // Call newstree's FindOrCreateByName
    //
    hr = m_pINewsTree->FindOrCreateGroupByName( szGroupName,    // group name
                                                TRUE,          // create if non-exist
                                                ppPropBag,      // take back bag
                                                NULL,           // no protocolcompletion
                                                0xffffffff,     // fake group id
                                                FALSE           // we don't set group id
                                                );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Find or create group %s failed %x",
                    szGroupName, hr );
    } else {

        //
        // If we are adding the slave group, we'll make it special
        //
        if ( IsSlaveGroup() ) {
            (*ppPropBag)->PutBool( NEWSGRP_PROP_ISSPECIAL, TRUE );
        }
    }

    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::CreateGroupInVpp(    INNTPPropertyBag *pPropBag,
                                    DWORD   &dwOffset)
/*++
Routine description:

    Create the group in the vpp file.  We assume the call holds the reference
    on the property bag and releases it

Arguments:

    INNTPPropertyBag *pPropBag - The group's property bag

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CreateGroupInVpp" );
    _ASSERT( pPropBag );

    HRESULT         hr = S_OK;
    VAR_PROP_RECORD vpRecord;


    // Set group properties to flat file
	hr = Group2Record( vpRecord, pPropBag );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Group2Record fail with %x", hr );
		goto Exit;
	}

	//
	// Beofore vpp operation, dirty the integrity flag
	//
	m_PropFileLock.ExclusiveLock();
	hr = m_pffPropFile->DirtyIntegrityFlag();
	if ( FAILED( hr ) ) {
	    ErrorTrace( 0, "Dirty integrity flag failed %x", hr );
	    m_PropFileLock.ExclusiveUnlock();
	    goto Exit;
	}

	hr = m_pffPropFile->InsertRecord( 	(PBYTE)&vpRecord,
										RECORD_ACTUAL_LENGTH( vpRecord ),
										&dwOffset );
	if ( FAILED( hr ) ) {
	    //m_pffPropFile->SetIntegrityFlag();
		ErrorTrace( 0, "Insert Record fail %x", hr);
		m_PropFileLock.ExclusiveUnlock();
		goto Exit;
	}

	//
	// After the operation, set the integrity flag
	//
	hr = m_pffPropFile->SetIntegrityFlag();
	if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Set integrity flag failed %x", hr );
        m_PropFileLock.ExclusiveUnlock();
        goto Exit;
    }

    //
    // Unlock it
    //
    m_PropFileLock.ExclusiveUnlock();

	//loading offset into property bag
	hr = pPropBag->PutDWord( NEWSGRP_PROP_FSOFFSET, dwOffset );
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Loading flatfile offset failed %x", hr );
		goto Exit;
	}

Exit:

    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::LoadGroupsFromVpp( INntpComplete *pComplete )
/*++
Routine description:

    Load the groups from vpp file, including all the properties
    found from vpp file

Arguments:

    INntpComplete *pComplete - Protocol side complete object used
                                for property bag reference tracking

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::LoadGroupsFromVpp" );
    _ASSERT( pComplete );

    VAR_PROP_RECORD vpRec;
	DWORD			dwOffset;
	HRESULT			hr = S_OK;
	DWORD			dwSize;
	CHAR            szGroupProperty[MAX_NEWSGROUP_NAME+1];
	INntpDriver 	*pDriver = NULL;
	INNTPPropertyBag *pPropBag = NULL;

	_ASSERT( m_pffPropFile );

    m_PropFileLock.ShareLock();

	//
	// check to see if the vpp is in good shape
	//
	if ( !m_pffPropFile->FileInGoodShape() ) {
	    ErrorTrace( 0, "vpp file is corrupted" );
	    hr = HRESULT_FROM_WIN32( ERROR_FILE_CORRUPT );
	    m_PropFileLock.ShareUnlock();
	    return hr;
	}

	dwSize = sizeof( vpRec );
	hr = m_pffPropFile->GetFirstRecord( PBYTE(&vpRec), &dwSize, &dwOffset );
	m_PropFileLock.ShareUnlock();
	while ( S_OK == hr ) {

	    //
	    // Check to see if I should continue this loop
	    //
	    if ( !m_pNntpServer->ShouldContinueRebuild() ) {
	        DebugTrace( 0, "Rebuild cancelled" );
	        hr = HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED );
	        goto Exit;
	    }

		_ASSERT( dwSize == RECORD_ACTUAL_LENGTH( vpRec ) );
		_ASSERT( dwOffset != 0xffffffff );
		_ASSERT( vpRec.cbGroupNameLen <= MAX_GROUPNAME );
		strncpy(    szGroupProperty,
		            LPSTR(vpRec.pData + vpRec.iGroupNameOffset),
		            vpRec.cbGroupNameLen );
		*(szGroupProperty+vpRec.cbGroupNameLen) = 0;

        //
		// check if I own this group
		//
		hr = m_pINewsTree->LookupVRoot( szGroupProperty, &pDriver );
		if ( FAILED ( hr ) || pDriver != (INntpDriver*)this ) {
			// skip this group
			DebugTrace(0, "I don't own this group %s", szGroupProperty );
			goto NextIteration;
		}

		//
		// Since I own this group, I'll create this group in tree
		//
		hr = m_pINewsTree->FindOrCreateGroupByName(	szGroupProperty,
													TRUE,       // create if not exist
													&pPropBag,
													pComplete,
													vpRec.dwGroupId,
													TRUE);      // Set group id
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Load group %s into tree failed %x" ,
			            szGroupProperty, hr );
			goto Exit;  // should fail it ?
		}

        //
		// OK, the group has been successfully created, now set a bunch
		// of properties
		//
		// 1. Set offset
		//
		hr = pPropBag->PutDWord( NEWSGRP_PROP_FSOFFSET, dwOffset );
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Put offset failed %x", hr );
			goto Exit;
		}

		//
		// 1.5 IsSpecial
		//
		if ( IsSlaveGroup() ) {
		    hr = pPropBag->PutBool( NEWSGRP_PROP_ISSPECIAL, TRUE );
		    if ( FAILED( hr ) ) {
		        ErrorTrace( 0, "Put is special failed %x", hr );
		        goto Exit;
		    }
		}

		//
		// 2. Native name
		//
        _ASSERT( vpRec.cbNativeNameLen <= MAX_GROUPNAME );
        if ( vpRec.iNativeNameOffset > 0 ) {
            strncpy(    szGroupProperty,
                        LPSTR(vpRec.pData + vpRec.iNativeNameOffset),
                        vpRec.cbNativeNameLen );
            *(szGroupProperty+vpRec.cbNativeNameLen) = 0;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_NATIVENAME,
                                    vpRec.cbNativeNameLen,
                                    PBYTE(szGroupProperty) );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Put native name failed %x", hr );
                goto Exit;
            }
        }

        //
        // 3. Pretty name
        //
        _ASSERT( vpRec.cbPrettyNameLen <= MAX_GROUPNAME );
        if ( vpRec.cbPrettyNameLen > 0 ) {
            strncpy(    szGroupProperty,
                        LPSTR(vpRec.pData + vpRec.iPrettyNameOffset),
                        vpRec.cbPrettyNameLen );
            *(szGroupProperty+vpRec.cbPrettyNameLen) = 0;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_NATIVENAME,
                                    vpRec.cbPrettyNameLen,
                                    PBYTE(szGroupProperty) );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Put pretty name failed %x", hr );
                goto Exit;
            }
        }

        //
        // 4. Description text
        //
        _ASSERT( vpRec.cbDescLen <= MAX_GROUPNAME );
        if ( vpRec.cbDescLen > 0 ) {
            strncpy(    szGroupProperty,
                        LPSTR(vpRec.pData + vpRec.iDescOffset),
                        vpRec.cbDescLen );
            *(szGroupProperty+vpRec.cbDescLen) = 0;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_DESC,
                                    vpRec.cbDescLen,
                                    PBYTE(szGroupProperty) );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Put description text failed %x", hr);
                goto Exit;
            }
        }

        //
        // 5. Moderator
        //
        _ASSERT( vpRec.cbModeratorLen <= MAX_GROUPNAME );
        if ( vpRec.cbModeratorLen > 0 ) {
            strncpy(    szGroupProperty,
                        LPSTR(vpRec.pData + vpRec.iModeratorOffset),
                        vpRec.cbModeratorLen );
            *(szGroupProperty+vpRec.cbModeratorLen) = 0;
            hr = pPropBag->PutBLOB( NEWSGRP_PROP_MODERATOR,
                                    vpRec.cbModeratorLen,
                                    PBYTE(szGroupProperty) );
            if ( FAILED( hr ) ) {
                ErrorTrace( 0, "Put moderator failed %x", hr );
                goto Exit;
            }
        }

        //
        // 6. Create time
        //
        hr = pPropBag->PutDWord(    NEWSGRP_PROP_DATELOW,
                                    vpRec.ftCreateTime.dwLowDateTime );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Put low of date failed %x", hr );
            goto Exit;
        }

        hr = pPropBag->PutDWord(    NEWSGRP_PROP_DATEHIGH,
                                    vpRec.ftCreateTime.dwHighDateTime );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Put high of date failed %x", hr );
            goto Exit;
        }

        //
        // OK, we are done, release the property bag
        //
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;

NextIteration:

		dwSize = sizeof( vpRec );
		m_PropFileLock.ShareLock();
		hr = m_pffPropFile->GetNextRecord( PBYTE(&vpRec), &dwSize, &dwOffset );
		m_PropFileLock.ShareUnlock();
	}

Exit:

	if ( NULL != pPropBag ) {
		pComplete->ReleaseBag( pPropBag );
		pPropBag = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT
CNntpFSDriver::LoadGroups( INntpComplete *pComplete )
/*++
Routine description:

    Load the groups from store into newstree.  There are two possibilities:
    1. If vpp file is good, we'll load directly from vpp file;
    2. If vpp file is corrupted, we'll load by rootscan

Arguments:

    INntpComplete *pComplete - Protocol side complete object used for property
                                bag reference tracking

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::LoadGroups" );
    _ASSERT( pComplete );

    HRESULT                 hr = S_OK;
    CHAR                    szFileName[MAX_PATH+1];
    CNntpFSDriverRootScan   *pRootScan = NULL;
    CNntpFSDriverCancelHint *pCancelHint = NULL;

    if ( m_pffPropFile ) {

        //
        // vpp file is good, we'll load groups from vpp file
        //
        hr = LoadGroupsFromVpp( pComplete );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Load groups from vpp file failed %x", hr );
            goto Exit;
        }

    } else {

        //
        // If we are doing standard rebuild, we can not tolerate the
        // corruption of vpp file
        //
        if ( m_pNntpServer->QueryServerMode() == NNTP_SERVER_STANDARD_REBUILD ) {

            ErrorTrace( 0, "Vroot rebuild failed because vpp file corruption" );
            hr = HRESULT_FROM_WIN32( ERROR_FILE_CORRUPT );
            goto Exit;
        }

        //
        // We don't have a good vpp file, we'll have to do root scan
        //
        // Before rootscan, we'll delete the vpp file and restart a
        // new vpp file, so that root scan can start adding stuff into it
        //
        strcpy( szFileName, m_szPropFile );
        strcat( szFileName, ".vpp" );
        _ASSERT( strlen( szFileName ) <= MAX_PATH );
        DeleteFile( szFileName );

        //
        // Create the new vpp file object
        //
        m_pffPropFile = XNEW CFlatFile(	m_szPropFile,
		    							".vpp",
			    						NULL,
				    					CNntpFSDriver::OffsetUpdate );
    	if ( NULL == m_pffPropFile ) {
	    	ErrorTrace( 0, "Create flat file object fail %d",
		    				GetLastError() );
    	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
	    	goto Exit;
    	}

    	//
    	// Create the cancel hint object
    	//
    	_ASSERT( m_pNntpServer );
    	pCancelHint = XNEW CNntpFSDriverCancelHint( m_pNntpServer );
    	if ( NULL == pCancelHint ) {
    	    ErrorTrace( 0, "Create cancel hint object failed" );
    	    hr = E_OUTOFMEMORY;
    	    goto Exit;
    	}

    	//
    	// Now create the root scan object
    	//
    	pRootScan = XNEW CNntpFSDriverRootScan( m_szFSDir,
    	                                        m_pNntpServer->SkipNonLeafDirWhenRebuild(),
    	                                        this,
    	                                        pCancelHint );
    	if ( NULL == pRootScan ) {
    	    ErrorTrace( 0, "Create root scan object failed" );
    	    hr = E_OUTOFMEMORY;
    	    goto Exit;
    	}

    	//
    	// Now start the root scan
    	if ( !pRootScan->DoScan() ) {
    	    ErrorTrace( 0, "Root scan failed %d", GetLastError() );
    	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
    	    goto Exit;
    	}
    }

Exit:

    //
    // Clean up
    //
    if ( pRootScan ) XDELETE pRootScan;
    if ( pCancelHint ) XDELETE pCancelHint;
    if ( FAILED( hr ) ) {
        m_pNntpServer->SetRebuildLastError( ERROR_FILE_CORRUPT );
    }

    TraceFunctLeave();

    return hr;
}

HRESULT
CNntpFSDriver::UpdateGroupProperties(   DWORD               cCrossPosts,
                                        INNTPPropertyBag    *rgpPropBag[],
                                        ARTICLEID           rgArticleId[] )
/*++
Routine description:

    Update groups' article counts, high/low watermarks.  The only thing
    we take care of here is high watermark, since article count and low
    watermark should have been adjusted by the protocol.

Arguments:

    DWORD               cCrossPosts     - Number of groups to update
    INNTPPropertyBag    *rgpPropBag[]   - Array of property bags
    ARTICLEID           rgArticleId[]   - Array of article ids

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::UpdateGroupProperties" );

    _ASSERT( cCrossPosts > 0 );
    _ASSERT( rgpPropBag );
    _ASSERT( rgArticleId );

    HRESULT hr;
    DWORD   dwHighWatermark;

    for ( DWORD i = 0; i < cCrossPosts; i++ ) {

        hr = rgpPropBag[i]->GetDWord( NEWSGRP_PROP_LASTARTICLE, &dwHighWatermark );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Reading group properties failed %x", hr );
            return (hr);
        }

        if ( dwHighWatermark < rgArticleId[i] )
            dwHighWatermark = rgArticleId[i];

        hr = rgpPropBag[i]->PutDWord( NEWSGRP_PROP_LASTARTICLE, dwHighWatermark );
        if ( FAILED( hr ) ) {
            ErrorTrace( 0, "Writing group properties failed %x", hr );
            return (hr);
        }

    }

    TraceFunctLeave();
    return S_OK;
}

HRESULT
CNntpFSDriver::PreparePostParams(   LPSTR               szFileName,
                                    LPSTR               szGroupName,
                                    LPSTR               szMessageId,
                                    DWORD&              dwHeaderLen,
                                    DWORD&              cCrossPosts,
                                    INNTPPropertyBag    *rgpPropBag[],
                                    ARTICLEID           rgArticleId[],
                                    INntpComplete       *pProtocolComplete )
/*++
Routine description:

    Parse out all the necessary information from the message.

Arguments:

    LPSTR   szFileName      - The file name of the message
    LPSTR   szGroupName     - The news group name
    LPSTR   szMessage       - To return message id
    DWORD   &dwHeaderLen    - To return header length
    DWORD   &cCrossPosts    - Pass in the array length limit, pass out actual length
    INNTPPropertyBag *rgpPropBag[]  - To return array of property bags
    ARTICLEID   rgArticleId[]       - To return array of article ids'
    INntpComplete *pProtocolComplete    - Protocol's completion object that helps
                                            track property bag reference count

Return value:

    S_OK - OK and results returned, S_FALSE - Article parse failed and deleted
    Otherwise, failure
--*/
{
    TraceFunctEnter( "CNntpFSDriver::PrepareParams" );
    _ASSERT( szFileName );
    _ASSERT( szGroupName );
    _ASSERT( szMessageId );
    _ASSERT( cCrossPosts > 0 );
    _ASSERT( rgpPropBag );
    _ASSERT( rgArticleId );
    _ASSERT( pProtocolComplete );

    CNntpReturn nntpReturn;

    //
    // Create allocator for storing parsed header values
    //
    const DWORD     cchMaxBuffer = 1 * 1024;
    char            pchBuffer[cchMaxBuffer];
    CAllocator      allocator(pchBuffer, cchMaxBuffer);
    HRESULT         hr = S_OK;
    HEADERS_STRINGS *pHeaders;
    DWORD           err;
    DWORD           dwLen;
    WORD            wHeaderLen;
    WORD            wHeaderOffset;
    DWORD           dwTotalLen;

    //
    // Create the article object
    //
    CArticleCore    *pArticle = new CArticleCore;
    if ( NULL == pArticle ) {
        ErrorTrace( 0, "Out of memory" );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Initialize the article object
    //
    if ( !pArticle->fInit( szFileName, nntpReturn, &allocator ) ) {

        //
        // If we couldn't init the article, then return S_FALSE so
        // the caller will rename the file to *.BAD and continue
        //
	    hr = S_FALSE;
        ErrorTrace( 0, "Parse failed on %s: %x", szFileName, hr );
        goto Exit;
    }

    //
    // Get the message id
    //
    if ( !pArticle->fFindOneAndOnly(    szKwMessageID,
                                        pHeaders,
                                        nntpReturn ) ) {
        if ( nntpReturn.fIs( nrcArticleMissingField ) ) {

            //
            // This is fine, we'll return S_FALSE and delete the message
            // but rebuild will continue
            //
            XDELETE pArticle;
            pArticle = NULL;
            DebugTrace( 0, "Parse message id failed on %s", szFileName );
            hr = S_FALSE;
            goto Exit;
        } else {

            //
            // It's fatal, we'll error return
            //
    	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
            ErrorTrace( 0, "Parse message id failed %s: %x", szFileName, hr );
            goto Exit;
        }
    }

    //
    // Put the message id into the buffer
    //
    dwLen = pHeaders->pcValue.m_cch;
    _ASSERT( dwLen <= 2 * MAX_PATH );
    CopyMemory( szMessageId, pHeaders->pcValue.m_pch, dwLen );
    *(szMessageId + dwLen ) = 0;

    //
    // Now look for xref line
    //
    if ( !pArticle->fFindOneAndOnly(    szKwXref,
                                        pHeaders,
                                        nntpReturn ) ) {
        if ( nntpReturn.fIs( nrcArticleMissingField ) ) {

            //
            // This is fine, we'll return S_FALSE and delete the message
            // but rebuild will continue
            //
            XDELETE pArticle;
            pArticle = NULL;
            DebugTrace( 0, "Parse xref line failed %s", szFileName );
            hr = S_FALSE;
            goto Exit;
        } else {

            //
            // It's fatal, we'll error return
            //
    	    hr = HresultFromWin32TakeDefault( ERROR_NOT_ENOUGH_MEMORY );
            ErrorTrace( 0, "Parse xref failed on %s: %x", szFileName, hr );
            goto Exit;
        }
    }

    //
    // Parse the xref line and get array of property bags, article ids'
    //
    hr = ParseXRef( pHeaders, szGroupName, cCrossPosts, rgpPropBag, rgArticleId, pProtocolComplete );
    if ( FAILED( hr ) ) {

        //
        // This is non fatal, we'll ask the caller to continue after deleting this
        // message
        //
        XDELETE pArticle;
        pArticle = NULL;
        DebugTrace( 0, "Parse xref line failed on %s: %x", szFileName, hr );
        hr = S_FALSE;
        goto Exit;
    }

    //
    // Get the header length
    //
    pArticle->GetOffsets( wHeaderOffset, wHeaderLen, dwTotalLen );
    dwHeaderLen = wHeaderLen;

Exit:

    //
    // If we have allocated article object, we should free it
    //
    if ( pArticle ) delete pArticle;

    TraceFunctLeave();
    return hr;
}

INNTPPropertyBag *
CNntpFSDriver::GetPropertyBag(  LPSTR   pchBegin,
                                LPSTR   pchEnd,
                                LPSTR   szGroupName,
                                BOOL&   fIsNative,
                                INntpComplete *pProtocolComplete )
/*++
Routine description:

    Given group name ( possibly native name ), find it in the newstree
    and get the property bag

Arguments:

    LPSTR   pchBegin    - Start address for the "native name"
    LPSTR   pchEnd      - End address for the "native name"
    LPSTR   szGroupName - To return all low case group name converted from this guy
    BOOL    &fIsNative  - To return if this is really a native name
    INntpComplete *pProtocolComplete - Protocol completion object that helps track
                                        group reference count

Return value:

    Pointer to the bag, if succeeded, NULL otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::GetPropertyBag" );
    _ASSERT( pchBegin );
    _ASSERT( pchEnd );
    _ASSERT( pchEnd >= pchBegin );
    _ASSERT( szGroupName );
    _ASSERT( pProtocolComplete );

    fIsNative = FALSE;

    //
    // Convert the "native name" into group name
    //
    LPSTR   pchDest = szGroupName;
    for ( LPSTR pch = pchBegin; pch < pchEnd; pch++, pchDest++ ) {
        _ASSERT( pchDest - szGroupName <= MAX_NEWSGROUP_NAME );
        *pchDest = (CHAR)tolower( *pch );
        if ( *pchDest != *pch ) fIsNative = TRUE;
    }

    //
    // Null terminate szGroupName
    //
    *pchDest = 0;

    //
    // Now try to find the group from newstree
    //
    INNTPPropertyBag *pPropBag;
    GROUPID groupid = 0xffffffff;
    HRESULT hr = m_pINewsTree->FindOrCreateGroupByName( szGroupName,
                                                        FALSE,          // don't create
                                                        &pPropBag,
                                                        pProtocolComplete,
                                                        groupid,
                                                        FALSE           // don't set groupid
                                                        );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Can not find the group from newstree %x", hr );
        return NULL;
    }

    //
    // We found it, now return the bag
    //
    TraceFunctLeave();
    return pPropBag;
}

HRESULT
CNntpFSDriver::ParseXRef(   HEADERS_STRINGS     *pHeaderXref,
                            LPSTR               szPrimaryName,
                            DWORD&              cCrossPosts,
                            INNTPPropertyBag    *rgpPropBag[],
                            ARTICLEID           rgArticleId[],
                            INntpComplete       *pProtocolComplete )
/*++
Routine description:

    Parse out the cross post information, get property bags for each group
    and article id's for each cross post.

Arguments:

    HEADERS_STRINGS *pHeaderXref    - The xref header
    LPSTR           szPrimaryName     - The primary group name
    DWORD           &cCrossPosts    - In: array limit, out: actual cross posts
    INNTPPropertyBag *rgpPropBag[]  - Array of property bags
    ARTICLEID       rgArticleId[]   - Array of article ids'
    INntpComplete   *pProtocolComplete  - Protocol completion object for tracking property
                                            bag ref-counts

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::ParseXRef" );
    _ASSERT( pHeaderXref );
    _ASSERT( szPrimaryName );
    _ASSERT( cCrossPosts > 0 );
    _ASSERT( rgpPropBag );
    _ASSERT( rgArticleId );
    _ASSERT( pProtocolComplete );

    DWORD   i = 1;
    BOOL    fPrimarySkipped = FALSE;
    CHAR    ch;
    LPSTR   lpstrXRef       = pHeaderXref->pcValue.m_pch;
    DWORD   cXRef           = pHeaderXref->pcValue.m_cch;
    LPSTR   lpstrXRefEnd    = lpstrXRef + cXRef;
    LPSTR   pchBegin        = lpstrXRef;
    LPSTR   pchEnd;
    INNTPPropertyBag *pPropBag = NULL;
    CHAR    szGroupName[MAX_NEWSGROUP_NAME];
    CHAR    szNativeName[MAX_NEWSGROUP_NAME];
    CHAR    szNumBuf[MAX_PATH];
    BOOL    fIsNative;
    HRESULT hr = S_OK;
    ARTICLEID articleid;

    //
    // Notice that we'll start from element 1, because element 0 is kept
    // for szGroupName, which is the primary group
    //
    // Also initialize the array of property bags
    ZeroMemory( rgpPropBag, sizeof( cCrossPosts * sizeof( INNTPPropertyBag *)));

    //
    // Skip the "dns.microsoft.com " part - look for first space
    //
    while ( pchBegin < lpstrXRefEnd && *pchBegin != ' ' )
        pchBegin++;

    if ( pchBegin == lpstrXRefEnd ) {

        //
        // This guy is in invalid format
        //
        hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
        goto Exit;
    }
    _ASSERT( *pchBegin == ' ' );

    //
    // Loop through all the newsgroups in xref line
    //
    while( pchBegin < lpstrXRefEnd && i < cCrossPosts) {

        //
        // Skip extra spaces, if any
        //
        while( pchBegin < lpstrXRefEnd &&  *pchBegin == ' ' ) pchBegin++;
        if ( pchBegin < lpstrXRefEnd ) {

            //
            // Find the ":" as the end of the newsgroup name
            //
            pchEnd = pchBegin;
            while( pchEnd < lpstrXRefEnd && *pchEnd != ':' ) pchEnd++;

            if ( pchEnd < lpstrXRefEnd ) {

                pPropBag = GetPropertyBag(  pchBegin,
                                            pchEnd,
                                            szGroupName,
                                            fIsNative,
                                            pProtocolComplete );
                if ( pPropBag ) {

                    //
                    // if it's native name, we should load it into group
                    //
                    if ( fIsNative ) {

                        CopyMemory( szNativeName, pchBegin, pchEnd-pchBegin  );
                        *(szNativeName+(pchEnd-pchBegin)) = 0;
                        hr = pPropBag->PutBLOB( NEWSGRP_PROP_NATIVENAME,
                                                (DWORD)(pchEnd-pchBegin+1),  // including 0
                                                PBYTE(szNativeName) );
                        if ( FAILED( hr ) ) {
                            ErrorTrace( 0, "Put native name failed %x", hr );
                            goto Exit;
                        }
                    }

                    //
                    // Get the article id
                    //
                    _ASSERT( *pchEnd == ':' );
                    pchEnd++;
                    pchBegin = pchEnd;
                    while( pchEnd < lpstrXRefEnd && *pchEnd != ' ' ) pchEnd++;

                    CopyMemory( szNumBuf, pchBegin, pchEnd-pchBegin );
                    *(szNumBuf+(pchEnd-pchBegin)) = 0;
                    articleid = atol( szNumBuf );

                    //
                    // Now it's time to decide where to put this propbag/article pair
                    //
                    if ( !fPrimarySkipped && strcmp( szGroupName, szPrimaryName ) == 0 ) {

                        rgpPropBag[0] = pPropBag;
                        rgArticleId[0] = articleid;
                        fPrimarySkipped = TRUE;
                    } else {

                        rgpPropBag[i] = pPropBag;
                        rgArticleId[i++] = articleid;
                    }

                    pPropBag = NULL;

                 } else {

                    //
                    // Invalid newsgroup name got
                    //
                    ErrorTrace( 0, "Invalid newsgroup name got" );
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
            }

            //
            // Ready to find next newsgroup
            //
            pchBegin = pchEnd;
        }
    }

    //
    // If 0'th element of the array is not set, we failed
    //
    if ( rgpPropBag[0] == NULL ) {
        ErrorTrace( 0, "primary group not found in xref line" );
        hr = E_OUTOFMEMORY;
    }

Exit:

    //
    // Release pPropBag, if this guy is non-null
    //
    if ( pPropBag ) pProtocolComplete->ReleaseBag( pPropBag );

    //
    // If failed, we should release all the bags that have been allocated
    //
    if ( FAILED( hr ) ) {
        for ( DWORD j = 0; j < i; j++ )
            if ( rgpPropBag[j] ) pProtocolComplete->ReleaseBag( rgpPropBag[j] );
    }

    //
    // Set the actual length of the array
    //
    if ( SUCCEEDED( hr ) )
        cCrossPosts = i;
    else cCrossPosts = 0;

    TraceFunctLeave();
    return hr;
}

HRESULT
CNntpFSDriver::PostToServer(    LPSTR           szFileName,
                                LPSTR           szGroupName,
                                INntpComplete   *pProtocolComplete )
/*++
Routine description:

    Initialize the file with article object, parse out the necessary
    headers, post them into server, and update group properties

Arguments:

    LPSTR           szFileName          - The file name for the article
    INntpComplete   *pProtocolComplete  - Used to track property bag reference

Return value:

    HRESULT
--*/
{
    TraceFunctEnter( "CNntpFSDriver::PostToServer" );
    _ASSERT( szFileName );
    _ASSERT( pProtocolComplete );

    //
    // Prepare the post parameters from the article
    //
    HRESULT             hr = S_OK;
    CHAR                szMessageId[2*MAX_PATH+1];
    DWORD               dwHeaderLen = 0;
    DWORD               cCrossPosts = 512;      // I assume this would be enough
    INNTPPropertyBag    *rgpPropBag[512];
    ARTICLEID           rgArticleId[512];
    BOOL                fPrepareOK = FALSE;
    STOREID             storeid;
    CDriverSyncComplete scComplete;

    hr = PreparePostParams( szFileName,
                            szGroupName,
                            szMessageId,
                            dwHeaderLen,
                            cCrossPosts,
                            rgpPropBag,
                            rgArticleId,
                            pProtocolComplete );
    if ( S_OK != hr ) {
        ErrorTrace( 0, "Failed to parse post parameters %x", hr );
        goto Exit;
    }

    _ASSERT( cCrossPosts <= 512 );
    _ASSERT( cCrossPosts > 0 );
    fPrepareOK = TRUE;

    //
    // We want to make sure that this article doesn't already exist in
    // the server.  Since multiple vroots can keep same copy of the
    // article, those who won in posting the article first into xover/article
    // table will be deemed primary group/store
    //
    if( m_pNntpServer->MessageIdExist( szMessageId ) ) {

        /*
        if ( IsBadMessageIdConflict(    szMessageId,
                                        pPropBag,
                                        szGroupName,
                                        rgArticleId[0],
                                        pProtocolComplete ) ) {
            //
            // We should return return S_FALSE, so that the article
            // be bad'd
            //
            hr = S_FALSE;
            DebugTrace( 0, "A bad message id conflict" );
            goto Exit;
        } else {

            //
            // A good conflict, we should still update group properties
            //
            hr = UpdateGroupProperties( cCrossPosts,
                                        rgpPropBag,
                                        rgArticleId );
            goto Exit;
        }*/
        DebugTrace( 0, "Message already existed" );
        goto Exit;
    }

    //
    // Call the post interface to put them into hash tables
    //
    scComplete.AddRef();
    scComplete.AddRef();
    _ASSERT( scComplete.GetRef() == 2 );
    ZeroMemory( &storeid, sizeof( STOREID ) );  // I don't care about store id
    m_pNntpServer->CreatePostEntries(   szMessageId,
                                        dwHeaderLen,
                                        &storeid,
                                        (BYTE)cCrossPosts,
                                        rgpPropBag,
                                        rgArticleId,
                                        FALSE,
                                        &scComplete );
    scComplete.WaitForCompletion();
    _ASSERT( scComplete.GetRef() == 0 );
    hr = scComplete.GetResult();
    if ( FAILED( hr ) ) {

        //
        // BUGBUG: CreatePostEntries lied about the error code, it
        // always returns E_OUTOFMEMORY
        //
        ErrorTrace( 0, "Post entry to hash tables failed %x", hr );
        goto Exit;
    }

    /*
    //
    // If it has been succeeded or failed because of message already
    // existed
    //
    hr = UpdateGroupProperties( cCrossPosts,
                                rgpPropBag,
                                rgArticleId );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Update group properties failed %x", hr );
        goto Exit;
    }
    */

Exit:

    //
    // Release all the group bags, if necessary
    //
    if ( fPrepareOK ) {
        for ( DWORD i = 0; i < cCrossPosts; i++ ) {
            pProtocolComplete->ReleaseBag( rgpPropBag[i] );
        }
    }

    TraceFunctLeave();
    return hr;
}

#if 0
BOOL
CNntpFSDriver::IsBadMessageIdConflict(  LPSTR               szMessageId,
                                        INNTPPropertyBag    *pPropBag,
                                        LPSTR               szGroupName,
                                        ARTICLEID           articleid,
                                        INntpComplete       *pProtocolComplete )
/*++
Routine description:

    Check to see if the message id conflict that occurred during rebuild
    is bad.  It is bad if:

    1. The existing entry in article table was posted by a primary group
        that's in the same vroot as us;

        or
    2. 1 is false, but we are not one of the secondary groups of the existing
        entry
Arguments:

    LPSTR               szMessageId - The message id that's conflicted
    INNTPPropertyBag    *pPropBag   - The property bag of us ( the group )
    LPSTR               szGroupName - The newsgroup name
    ARTICLEID           articleid   - Article id of us

Return value:

    TRUE if it's a bad conflict, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::IsBadMessageIdConflict" );
    _ASSERT( szMessageId );
    _ASSERT( pPropBag );
    _ASSERT( szGroupName );

    BOOL    fSame = FALSE;

    //
    // Check to see if the guy in the article table is from the same vroot
    //
    if ( !FromSameVroot( szMessageId, szGroupName, fSame ) || fSame ) {

        //
        // Either "same" or function call failed, I'll assume it's bad
        //
        DebugTrace( 0, "The guy in article table is from the same vroot" );
        TraceFunctLeave();
        return TRUE;
    }

    //
    // They are from two different vroots, check to see if they are
    // really cross posts
    //
    return !CrossPostIncludesUs(    szMessageId,
                                    pPropBag,
                                    articleid,
                                    pProtocolComplete );
}

BOOL
CNntpFSDriver::CrossPostIncludesUs(     LPSTR               szMessageId,
                                        INNTPPropertyBag   *pPropBag,
                                        ARTICLEID           articleid,
                                        INntpComplete       *pProtocolComplete )
/*++
Routine description:

    Check to see if szMessageId in article table represents a
    cross post that includes us ( pPropBag )

Arguments:

    LPSTR       szMessageId     - Message id in the article table to check against
    INNTPPropertyBag *pPropBag  - Us ( who lost the game in inserting art map entry )
    ARTICLEID   articleid       - Article id of us
    INntpComplete   *pProtocolComplete - For tracking property bag references

Return value:

    TRUE if the cross post includes us as a secondary group, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::CrossPostIncludesUs" );
    _ASSERT( szMessageId );
    _ASSERT( pPropBag );

    //
    // Find the primary group from xover table
    //
    CDriverSyncComplete scComplete;
    scComplete.AddRef();
    scComplete.AddRef();
    _ASSERT( scComplete.GetRef() == 2 );
    INNTPPropertyBag    *pPrimeBag = NULL;
    ARTICLEID           articleidPrimary;
    GROUPID             groupidPrimary;
    ARTICLEID           articleidWon;
    GROUPID             groupidWon;
    STOREID             storeid;

    m_pNntpServer->FindPrimaryArticle( pPropBag,
                                       articleid,
                                       &pPrimeBag,
                                       &articleidPrimary,
                                       FALSE,      // I want global primary
                                       &scComplete,
                                       pProtocolComplete );
    scComplete.WaitForCompletion();
    _ASSERT( scComplete.GetResult() == 0 );
    HRESULT hr = scComplete.GetResult();
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "Find primary article failed with %x", hr );
        return FALSE;
    }

    //
    // Lets get the group id of that primary guy
    //
    hr = pPrimeBag->GetDWord( NEWSGRP_PROP_GROUPID, &groupidPrimary );
    if ( FAILED( hr ) ) {

        //
        // I tell a lie: saying cross post doesn't include us
        //
        ErrorTrace( 0, "Get group id failed %x", hr );
        pProtocolComplete->ReleaseBag( pPrimeBag );
        return FALSE;
    }

    //
    // It's time to release prime bag
    //
    pProtocolComplete->ReleaseBag( pPrimeBag );

    //
    // Lets find the groupid/articleid for the given messageid
    //
    if ( !m_pNntpServer->FindStoreId(   szMessageId,
                                        &groupidWon,
                                        &articleidWon,
                                        &storeid ) ) {
        ErrorTrace( 0, "Find store id failed %d", GetLastError() );
        return FALSE;
    }

    //
    // Now it's time to make comparison
    //
    return ( groupidWon == groupidPrimary && articleidWon == articleidPrimary );
}

BOOL
CNntpFSDriver::FromSameVroot(   LPSTR               szMessageId,
                                LPSTR               szGroupName,
                                BOOL&               fFromSame )
/*++
Routine description:

    Check to see if the guy in article table with the same message id
    was posted from the same vroot

Arguments:

    LPSTR               szMessageId - The message id that's conflicted
    LPSTR               szGroupName - The newsgroup name
    BOOL&               fFromSame   - To return if they are from same vroot

Return value:

    TRUE if it's from the same vroot, FALSE otherwise
--*/
{
    TraceFunctEnter( "CNntpFSDriver::FromSameVroot" );
    _ASSERT( szMessageId );

    //
    // Find out the group id of the guy in the article table
    //
    GROUPID     groupid;
    ARTICLEID   articleid;
    STOREID     storeid;
    INntpDriver *pDriver1 = NULL;
    INntpDriver *pDriver2 = NULL;
    HRESULT     hr = S_OK;

    if ( !m_pNntpServer->FindStoreId(   szMessageId,
                                         &groupid,
                                         &articleid,
                                         &storeid ) ) {
        ErrorTrace( 0, "FindStoreId failed with %d", GetLastError() );
        return FALSE;
    }

    //
    // Look up for the vroot of the guy in article table
    //
    hr = m_pINewsTree->LookupVRootEx( groupid, &pDriver1 );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "LookupVroot failed with %x", hr );
        return FALSE;
    }

    //
    // Look up for the vroot of myself
    //
    hr = m_pINewsTree->LookupVRoot( szGroupName, &pDriver2 );
    if ( FAILED( hr ) ) {
        ErrorTrace( 0, "LookupVRoot failed with %x", hr );
        return FALSE;
    }

    //
    // Check if those two vroots are same
    //
    fFromSame = ( pDriver1 == pDriver2 );
    TraceFunctLeave();
    return TRUE;
}

#endif

void STDMETHODCALLTYPE
CNntpFSDriver::MakeSearchQuery (
	IN	CHAR *pszSearchString,
	IN	INNTPPropertyBag *pGroupBag,
	IN	BOOL bDeepQuery,
	IN	WCHAR *pwszColumns,
	IN	WCHAR *pwszSortOrder,
	IN	LCID LocaleID,
	IN	DWORD cMaxRows,
	IN	HANDLE hToken,
	IN	BOOL fAnonymous,
	IN	INntpComplete *pICompletion,
	OUT	INntpSearchResults **pINntpSearchResults,
	IN	LPVOID lpvContext) {

	WCHAR wszTripoliCatalogPath[_MAX_PATH];

#define MAX_QUERY_STRING_LEN 2000

	TraceFunctEnter("CNntpFSDriver::MakeSearchQuery");

	_ASSERT(pszSearchString);
	_ASSERT(pwszColumns);
	_ASSERT(pwszSortOrder);
	_ASSERT(pICompletion);

	CHAR szGroupName[MAX_GROUPNAME];
	CHAR *pszGroupName = NULL;
	DWORD dwLen;
	HRESULT hr;
	CNntpSearchResults *pSearch = NULL;
	const DWORD cQueryStringBuffer = MAX_QUERY_STRING_LEN;
    WCHAR *pwszQueryString = NULL;

    CNntpSearchTranslator st;

	static const WCHAR wszVPathNws[] = L" & #filename *.nws";

   	// Get group name for the property bag passed in
   	if (pGroupBag) {
		dwLen = MAX_GROUPNAME;
		hr = pGroupBag->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
		if ( FAILED( hr ) ) {
			ErrorTrace( 0, "Get group name failed %x", hr);
			goto Exit;
		}
		_ASSERT( dwLen > 0 );
		pszGroupName = szGroupName;
	}

	DebugTrace((DWORD_PTR)this, "pszSearchString = %s", pszSearchString);
	DebugTrace((DWORD_PTR)this, "pszCurrentGroup = %s", pszGroupName);
	DebugTrace((DWORD_PTR)this, "pwszColumns = %ws", pwszColumns);
	DebugTrace((DWORD_PTR)this, "pwszSortOrder = %ws", pwszSortOrder);

    //
    // get a buffer where we can store the Tripoli version of the search
    // command
    //

    pwszQueryString = XNEW WCHAR[cQueryStringBuffer];
	_ASSERT(pwszQueryString);
	if (pwszQueryString == NULL) {
		DebugTrace(0, "Could not allocate search string");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

    //
    // convert the query string to Tripolize
    //

    if (!st.Translate(pszSearchString,
	   		pszGroupName,
			pwszQueryString,
			cQueryStringBuffer)) {
	    hr = HresultFromWin32TakeDefault( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

    //
    // append & #vpath *.nws so that we only look for news articles
    //
    if (cQueryStringBuffer - lstrlenW(pwszQueryString) < sizeof(wszVPathNws)) {
        DebugTrace((DWORD_PTR)this, "out of buffer space");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcatW(pwszQueryString, wszVPathNws);

	//
    // Determine the virtual server ID from the vroot's name in the
    // metabase
    //

	DWORD dwVirtualServerID;
    if (_wcsnicmp (m_wszMBVrootPath, L"/LM/Nntpsvc/",
    	(sizeof(L"/LM/Nntpsvc/") / sizeof(WCHAR)) - 1) != 0) {
    	ErrorTrace((DWORD_PTR)this, "Could not determine virtual server ID");
    	hr = E_FAIL;
    	goto Exit;
    }

    dwVirtualServerID =
    	_wtol(&m_wszMBVrootPath[(sizeof(L"/LM/Nntpsvc/") / sizeof(WCHAR)) - 1]);

    if (dwVirtualServerID == 0) {
    	ErrorTrace((DWORD_PTR)this, "Could not determine virtual server ID");
    	hr = E_FAIL;
    	goto Exit;
    }

    //
    // start the query going
    //
    DebugTrace(0, "query string = %S", pwszQueryString);
    hr = s_TripoliInfo.GetCatalogName(dwVirtualServerID, _MAX_PATH, wszTripoliCatalogPath);
    if (hr != S_OK) {
    	DebugTrace ((DWORD_PTR)this, "Could not find path for instance %d", /*inst*/ 1);
    	hr = E_FAIL;
    	goto Exit;
    }

    DebugTrace(0, "making query against catalog %S", wszTripoliCatalogPath);

	pSearch = XNEW CNntpSearchResults(this);
	_ASSERT (pSearch != NULL);
	if (pSearch == NULL) {
		ErrorTrace((DWORD_PTR)this, "Could not allocate search results");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	pSearch->AddRef();

	if (ImpersonateLoggedOnUser(hToken)) {
		hr = pSearch->MakeQuery(TRUE,		// Deep query
			pwszQueryString,
			NULL,							// This machine
			wszTripoliCatalogPath,
			NULL,							// Scope
			pwszColumns,					// Columns
			pwszSortOrder,					// Sort order
			LocaleID,
			cMaxRows);
		RevertToSelf();
		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR)this, "MakeQuery failed, %x", hr);
			goto Exit;
		}
	} else {
	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		ErrorTrace((DWORD_PTR)this, "Impersonation failed %x", hr );
		goto Exit;
	}

	*pINntpSearchResults = (INntpSearchResults *) pSearch;

Exit:
	if (pwszQueryString)
		XDELETE pwszQueryString;

	if (FAILED(hr) && pSearch != NULL)
		pSearch->Release();

	if (pGroupBag) {
		pICompletion->ReleaseBag(pGroupBag);
		pGroupBag = NULL;
	}

	pICompletion->SetResult(hr);
	pICompletion->Release();

	TraceFunctLeave();

	return ;
}


void STDMETHODCALLTYPE
CNntpFSDriver::MakeXpatQuery (
	IN	CHAR *pszSearchString,
	IN	INNTPPropertyBag *pGroupBag,
	IN	BOOL bDeepQuery,
	IN	WCHAR *pwszColumns,
	IN	WCHAR *pwszSortOrder,
	IN	LCID LocaleID,
	IN	DWORD cMaxRows,
	IN	HANDLE hToken,
	IN	BOOL fAnonymous,
	IN	INntpComplete *pICompletion,
	OUT	INntpSearchResults **pINntpSearchResults,
	OUT	DWORD *pdwLowArticleID,
	OUT	DWORD *pdwHighArticleID,
	IN	LPVOID lpvContext
) {

	WCHAR wszTripoliCatalogPath[_MAX_PATH];

#define MAX_QUERY_STRING_LEN 2000

	TraceFunctEnter("CNntpFSDriver::MakeXpatQuery");

	_ASSERT(pszSearchString);
	_ASSERT(pwszColumns);
	_ASSERT(pwszSortOrder);
	_ASSERT(pICompletion);
	_ASSERT(pGroupBag);

	CHAR szGroupName[MAX_GROUPNAME];
	DWORD dwLen;
	HRESULT hr;
	CNntpSearchResults *pSearch = NULL;
	const DWORD cQueryStringBuffer = MAX_QUERY_STRING_LEN;
    WCHAR *pwszQueryString = NULL;

    CXpatTranslator xt;

	static const WCHAR wszVPathNws[] = L" & #filename *.nws";


   	// Get group name for the property bag passed in
	dwLen = MAX_GROUPNAME;
	hr = pGroupBag->GetBLOB( NEWSGRP_PROP_NAME, (UCHAR*)szGroupName, &dwLen);
	if ( FAILED( hr ) ) {
		ErrorTrace( 0, "Get group name failed %x", hr);
		goto Exit;
	}
	_ASSERT( dwLen > 0 );

	DebugTrace((DWORD_PTR)this, "pszSearchString = %s", pszSearchString);
	DebugTrace((DWORD_PTR)this, "pszCurrentGroup = %s", szGroupName);
	DebugTrace((DWORD_PTR)this, "pwszColumns = %ws", pwszColumns);
	DebugTrace((DWORD_PTR)this, "pwszSortOrder = %ws", pwszSortOrder);

    //
    // get a buffer where we can store the Tripoli version of the search
    // command
    //

    pwszQueryString = XNEW WCHAR[cQueryStringBuffer];
	_ASSERT(pwszQueryString);
	if (pwszQueryString == NULL) {
		DebugTrace(0, "Could not allocate search string");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

    //
    // convert the query string to Tripolize
    //

    if (!xt.Translate(pszSearchString,
	   		szGroupName,
			pwszQueryString,
			cQueryStringBuffer)) {
	    hr = HresultFromWin32TakeDefault( ERROR_INVALID_PARAMETER );
		goto Exit;
	}

	*pdwLowArticleID = xt.GetLowArticleID();
	*pdwHighArticleID = xt.GetHighArticleID();

    //
    // append & #vpath *.nws so that we only look for news articles
    //
    if (cQueryStringBuffer - lstrlenW(pwszQueryString) < sizeof(wszVPathNws)) {
        DebugTrace((DWORD_PTR)this, "out of buffer space");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcatW(pwszQueryString, wszVPathNws);


	//
    // Determine the virtual server ID from the vroot's name in the
    // metabase
    //

	DWORD dwVirtualServerID;
    if (_wcsnicmp (m_wszMBVrootPath, L"/LM/Nntpsvc/",
    	(sizeof(L"/LM/Nntpsvc/") / sizeof(WCHAR)) - 1) != 0) {
    	ErrorTrace((DWORD_PTR)this, "Could not determine virtual server ID");
    	hr = E_FAIL;
    	goto Exit;
    }

    dwVirtualServerID =
    	_wtol(&m_wszMBVrootPath[(sizeof(L"/LM/Nntpsvc/") / sizeof(WCHAR)) - 1]);

    if (dwVirtualServerID == 0) {
    	ErrorTrace((DWORD_PTR)this, "Could not determine virtual server ID");
    	hr = E_FAIL;
    	goto Exit;
    }

    //
    // start the query going
    //
    DebugTrace(0, "query string = %S", pwszQueryString);
    hr = s_TripoliInfo.GetCatalogName(dwVirtualServerID, _MAX_PATH, wszTripoliCatalogPath);
    if (hr != S_OK) {
    	DebugTrace ((DWORD_PTR)this, "Could not find path for instance %d", /*inst*/ 1);
    	hr = E_FAIL;
    	goto Exit;
    }

    DebugTrace(0, "making query against catalog %S", wszTripoliCatalogPath);

	pSearch = XNEW CNntpSearchResults(this);
	_ASSERT (pSearch != NULL);
	if (pSearch == NULL) {
		ErrorTrace((DWORD_PTR)this, "Could not allocate search results");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	pSearch->AddRef();

	if (ImpersonateLoggedOnUser(hToken)) {
		hr = pSearch->MakeQuery(TRUE,		// Deep query
			pwszQueryString,
			NULL,							// This machine
			wszTripoliCatalogPath,
			NULL,							// Scope
			pwszColumns,					// Columns
			pwszSortOrder,					// Sort order
			LocaleID,
			cMaxRows);
		RevertToSelf();
		if (FAILED(hr)) {
			ErrorTrace((DWORD_PTR)this, "MakeQuery failed, %x", hr);
			goto Exit;
		}
	} else {
	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		ErrorTrace((DWORD_PTR)this, "Impersonation failed %x", hr );
		goto Exit;
	}

	*pINntpSearchResults = (INntpSearchResults *) pSearch;

Exit:
	if (pwszQueryString)
		XDELETE pwszQueryString;

	if (FAILED(hr) && pSearch != NULL)
		pSearch->Release();

	if (pGroupBag) {
		pICompletion->ReleaseBag(pGroupBag);
		pGroupBag = NULL;
	}

	pICompletion->SetResult(hr);
	pICompletion->Release();

	TraceFunctLeave();

	return ;
}

void STDMETHODCALLTYPE
CNntpFSDriver::GetDriverInfo(
	OUT	GUID *pDriverGUID,
	OUT	void **ppvDriverInfo,
	IN	LPVOID lpvContext
	) {

	// Return the GUID for this driver and an opaque pointer which
	// UsesSameSearchDatabase can use to see if two instances are
	// pointing to the same search database.

	CopyMemory(pDriverGUID, &GUID_NntpFSDriver, sizeof(GUID));
	*ppvDriverInfo = NULL;
}


BOOL STDMETHODCALLTYPE
CNntpFSDriver::UsesSameSearchDatabase (
	IN	INntpDriverSearch *pSearchDriver,
	IN	LPVOID lpvContext) {

	GUID pDriverGUID;
	void *pNotUsed;

	pSearchDriver->GetDriverInfo(&pDriverGUID, &pNotUsed, NULL);

	if (pDriverGUID == GUID_NntpFSDriver)
		return TRUE;

	return FALSE;
}


CNntpSearchResults::CNntpSearchResults(INntpDriverSearch *pDriverSearch) :
	m_cRef(0),
	m_pDriverSearch(pDriverSearch) {

	_ASSERT(pDriverSearch != NULL);

	m_pDriverSearch->AddRef();
}


CNntpSearchResults::~CNntpSearchResults() {
	m_pDriverSearch->Release();
}

void STDMETHODCALLTYPE
CNntpSearchResults::GetResults (
	IN OUT DWORD *pcResults,
	OUT	BOOL *pfMore,
	OUT	WCHAR *pGroupName[],
	OUT	DWORD *pdwArticleID,
	IN	INntpComplete *pICompletion,
	IN	HANDLE	hToken,
	IN	BOOL  fAnonymous,
	IN	LPVOID lpvContext) {

	TraceQuietEnter("CNntpSearchResults::GetResults");

	_ASSERT(pcResults);
	_ASSERT(pfMore);
	_ASSERT(pGroupName);
	_ASSERT(pdwArticleID);
	_ASSERT(pICompletion);

	HRESULT hr;
	PROPVARIANT *ppvResults[2*MAX_SEARCH_RESULTS];

	ZeroMemory (ppvResults, sizeof(ppvResults));

	if (ImpersonateLoggedOnUser(hToken)) {
		*pcResults = min (MAX_SEARCH_RESULTS, *pcResults);
		hr = GetQueryResults(pcResults, ppvResults, pfMore);
		RevertToSelf();
	} else {
	    hr = HresultFromWin32TakeDefault( ERROR_ACCESS_DENIED );
		ErrorTrace( 0, "Impersonation failed %x", hr );
	}

	if (SUCCEEDED(hr)) {
		for (DWORD i=0; i<*pcResults; i++) {
			PROPVARIANT **pvCur = &ppvResults[i*2];

	        // Column 0 is the group name (LPWSTR) and
	        // column 1 is the article ID (UINT)
	        // If the types are wrong, skip the row
			if (pvCur[0]->vt != VT_LPWSTR || pvCur[1]->vt != VT_UI4) {
				ErrorTrace(0, "invalid col types in IDQ results -> "
					"pvCur[0]->vt = %lu pvCur[1]->vt = %lu",
					pvCur[0]->vt, pvCur[1]->vt);
				i--;
				*pcResults--;
			}

			pGroupName[i] = pvCur[0]->pwszVal;
			pdwArticleID[i] = pvCur[1]->uiVal;
		}
	}

	pICompletion->SetResult(hr);
	pICompletion->Release();

}


BOOL
CNntpFSDriver::AddTerminatedDot(
    HANDLE hFile
    )
/*++

Description:

    Add the terminated dot

Argument:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    TraceFunctEnter( "CNntpFSDriver::AddTerminatedDot" );

    DWORD   ret = NO_ERROR;

    //  SetFilePointer to move the EOF file pointer
    ret = SetFilePointer( hFile,
                          5,            // move file pointer 5 chars more, CRLF.CRLF,...
                          NULL,
                          FILE_END );   // ...from EOF
    if (ret == 0xFFFFFFFF)
    {
        ret = GetLastError();
        ErrorTrace(0, "SetFilePointer() failed - %d\n", ret);
        return FALSE;
    }

    //  pickup the length of the file
    DWORD   cb = ret;

    //  Call SetEndOfFile to actually set the file pointer
    if (!SetEndOfFile( hFile ))
    {
        ret = GetLastError();
        ErrorTrace(0, "SetEndOfFile() failed - %d\n", ret);
        return FALSE;
    }

    //  Write terminating dot sequence
    static	char	szTerminator[] = "\r\n.\r\n" ;
    DWORD   cbOut = 0;
    OVERLAPPED  ovl;
    ovl.Offset = cb - 5;
    ovl.OffsetHigh = 0;
    HANDLE  hEvent = GetPerThreadEvent();
    if (hEvent == NULL)
    {
        _ASSERT( 0 );
        ErrorTrace(0, "CreateEvent() failed - %d\n", GetLastError());
        return FALSE;
    }

    ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1);
    if (! WriteFile( hFile, szTerminator, 5, &cbOut, &ovl ))
    {
        ret = GetLastError();
        if (ret == ERROR_IO_PENDING)
        {
            WaitForSingleObject( hEvent, INFINITE );
        }
        else
        {
            _VERIFY( ResetEvent( hEvent ) );
            ErrorTrace(0, "WriteFile() failed - %d\n", ret);
            return FALSE;
        }
    } else {    // completed synchronously

        _VERIFY( ResetEvent( hEvent ) );
    }

    return TRUE;
}

void
CNntpFSDriver::BackFillLinesHeader( HANDLE  hFile,
                                    DWORD   dwHeaderLength,
                                    DWORD   dwLinesOffset )
/*++
Routine description:

    Back fill the Lines header to the message, since this information is
    not available during posting early and munge headers

Arguments:

    HANDLE  hFile           - File to back fill into
    DWORD   dwHeaderLength  - "Lines:" is estimated "magically" by file size and dwHeaderLength
    DWORD   dwLinesOffset   - Where to fill the lines information from

Return value:

    None.
--*/
{
    TraceFunctEnter( "CNntpFSDriver::BackFillLinesHeader" );
    _ASSERT( INVALID_HANDLE_VALUE != hFile );
    _ASSERT( dwHeaderLength > 0 );
    _ASSERT( dwLinesOffset < dwHeaderLength );

    //
    // Get file size first
    //
    DWORD   dwFileSize =GetFileSize( hFile, NULL );
    _ASSERT( dwFileSize != INVALID_FILE_SIZE );
    if ( dwFileSize == INVALID_FILE_SIZE ) {
        // what can we do ? keep silent
        ErrorTrace( 0, "GetFileSize failed with %d", GetLastError());
        return;
    }

    //
    // "magically compute the line number in body"
    //
    _ASSERT( dwFileSize > dwLinesOffset );
    _ASSERT( dwFileSize >= dwHeaderLength );
    DWORD   dwLines = ( dwFileSize - dwHeaderLength ) / 40 + 1;

    //
    // convert this number into string
    //
    CHAR    szLines[MAX_PATH];
    sprintf( szLines, "%d", dwLines );

    //
    // Prepare for the overlapped structure and writefile
    //
    OVERLAPPED  ovl;
    ovl.Offset = dwLinesOffset;
    ovl.OffsetHigh = 0;
    DWORD   cbOut;
    HANDLE  hEvent = GetPerThreadEvent();
    if (hEvent == NULL)
    {
        _ASSERT( 0 );
        ErrorTrace(0, "CreateEvent() failed - %d\n", GetLastError());
        return;
    }

    ovl.hEvent = (HANDLE)(((DWORD_PTR)hEvent) | 0x1);
    if (! WriteFile( hFile, szLines, strlen(szLines), &cbOut, &ovl ))
    {
        DWORD ret = GetLastError();
        if (ret == ERROR_IO_PENDING)
        {
            WaitForSingleObject( hEvent, INFINITE );
        }
        else
        {
            _VERIFY( ResetEvent( hEvent ) );
            ErrorTrace(0, "WriteFile() failed - %d\n", ret);
            return;
        }
    } else {    // completed synchronously

        _VERIFY( ResetEvent( hEvent ) );
    }

    TraceFunctLeave();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\fsutil.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fsutil.cpp

Abstract:

    Static utility functions for FSDriver.

Author:

    Kangrong Yan ( KangYan )    16-March-1998

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include <nntpdrv.h>
#include <nntpfs.h>
#include <fsdriver.h>
#include <aclapi.h>



DWORD g_dwDebugFlags;

VOID
CNntpFSDriver::CopyUnicodeStringIntoAscii(
        IN LPSTR AsciiString,
        IN LPCWSTR UnicodeString
        )
{

    DWORD cbW = (wcslen( UnicodeString )+1) * sizeof(WCHAR);
    DWORD cbSize = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        (LPCWSTR)UnicodeString,
                        -1,
                        AsciiString,
                        cbW,
                        NULL,
                        NULL
                    );

    if( (int)cbSize >= 0 ) {
        AsciiString[cbSize] = '\0';
    }

} // CopyUnicodeStringIntoAscii

VOID
CNntpFSDriver::CopyAsciiStringIntoUnicode(
        IN LPWSTR UnicodeString,
        IN LPCSTR AsciiString
        )
{

    DWORD cbA = strlen( AsciiString )+1;

    DWORD cbSize = MultiByteToWideChar(
        CP_ACP,         // code page
        0,              // character-type options
        AsciiString,    // address of string to map
        -1,             // number of bytes in string
        UnicodeString,  // address of wide-character buffer
        cbA        // size of buffer
        );

    if ( (int)cbSize >= 0) {
        UnicodeString[cbSize] = L'\0';
    }

} // CopyAsciiStringIntoUnicode



// Recursively create dirs
BOOL
CNntpFSDriver::CreateDirRecursive(  LPSTR szDir,
                                    HANDLE  hToken )
{
	TraceFunctEnter( "CreateDirRecursive" );

	_ASSERT( szDir );
	_ASSERT( lstrlen( szDir ) <= MAX_PATH );

	LPSTR 	pch = szDir;
	LPSTR 	pchOld;
	DWORD	dwLen = lstrlen( szDir );
	CHAR	ch;
	BOOL	bMore = TRUE;
	HANDLE	hTemp;

    DWORD dwRes, dwDisposition;
    PSID pEveryoneSID = NULL;
    PSID pAnonymousLogonSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    const int cExplicitAccess = 4;
    EXPLICIT_ACCESS ea[cExplicitAccess];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;
    BOOL bReturn = FALSE;
    LONG lRes;


	// it should start with "\\?\"
	_ASSERT( strncmp( "\\\\?\\", szDir, 4 ) == 0 );
	if ( strncmp( "\\\\?\\", szDir, 4 ) ) {
		ErrorTrace( 0, "Invalid path" );
		SetLastError( ERROR_INVALID_PARAMETER );
		goto Cleanup;
	}

    // Create a security descriptor for the files

    // Create a well-known SID for the Everyone group.

    if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                 SECURITY_WORLD_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &pEveryoneSID) ) 
    {
        goto Cleanup;
    }

	if (!AllocateAndInitializeSid(&SIDAuthNT, 1,
    	SECURITY_ANONYMOUS_LOGON_RID,
    	0, 0, 0, 0, 0, 0, 0,
    	&pAnonymousLogonSID)) {
		goto Cleanup;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ZeroMemory(&ea, sizeof(ea));
	ea[0].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
	ea[0].grfAccessMode = DENY_ACCESS;
	ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea[0].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

	ea[1].grfAccessPermissions = GENERIC_ALL;
	ea[1].grfAccessMode = SET_ACCESS;
	ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea[1].Trustee.ptstrName  = (LPTSTR) pEveryoneSID;

	ea[2].grfAccessPermissions = WRITE_DAC | WRITE_OWNER;
	ea[2].grfAccessMode = DENY_ACCESS;
	ea[2].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[2].Trustee.TrusteeType = TRUSTEE_IS_USER;
	ea[2].Trustee.ptstrName  = (LPTSTR) pAnonymousLogonSID;

	ea[3].grfAccessPermissions = GENERIC_ALL;
	ea[3].grfAccessMode = SET_ACCESS;
	ea[3].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	ea[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	ea[3].Trustee.TrusteeType = TRUSTEE_IS_USER;
	ea[3].Trustee.ptstrName  = (LPTSTR) pAnonymousLogonSID;

    dwRes = SetEntriesInAcl(cExplicitAccess, ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes) 
    {
        goto Cleanup;
    }

    // Initialize a security descriptor.  
 
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                         SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL) 
    {
        goto Cleanup; 
    }
 
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) 
    {
        goto Cleanup; 
    }
 
    // Add the ACL to the security descriptor. 
 
    if (!SetSecurityDescriptorDacl(pSD, 
        TRUE,     // fDaclPresent flag   
        pACL, 
        FALSE))   // not a default DACL 
    {
        goto Cleanup; 
    }

    // Initialize a security attributes structure.

    sa.nLength = sizeof (SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;


    // Use the security to create the directory
    // If it's non-UNC, we'll check for drive access
    if ( !m_bUNC ) {
    	// skip this part, looking for ':'
	    _ASSERT( strlen( szDir ) >= 6 );
    	pch = szDir + 6;

	    if ( *pch == 0 || *(pch+1) == 0 ) { // a drive has been specified
										// we need to check its access
		    if ( *pch != 0 ) _ASSERT( *pch == '\\' );
    		// Check accessibility of that drive
	    	hTemp = CreateFile(	szDir,
		    					GENERIC_READ | GENERIC_WRITE,
			    				FILE_SHARE_READ | FILE_SHARE_WRITE,
				    			&sa,
					    		OPEN_ALWAYS,
						    	FILE_FLAG_BACKUP_SEMANTICS,
							    INVALID_HANDLE_VALUE
        						) ;

		    if( hTemp != INVALID_HANDLE_VALUE ) {
			    CloseHandle( hTemp ) ;
    			DebugTrace( 0, "Drive specified is %s", szDir );
	    		bReturn = TRUE;
	    		goto Cleanup;
		    } else {
	    	    ErrorTrace( 0, "Invalid path" );
    	    	if ( GetLastError() == NO_ERROR )
	    		    SetLastError( ERROR_INVALID_PARAMETER );
		    	goto Cleanup;
		    }
	    }

	    // *pch must be '\'
	    _ASSERT( *pch == '\\' );
	    pch++;
	} else {    // UNC
	    pch += 8;   // skip "\\?\UNC\"
        while ( *pch != '\\' ) pch++;
	    pch++;
	}

	while ( bMore ) {
		pchOld = pch;
		while ( *pch && *pch != '\\' ) pch++;

		if ( pch != pchOld  ) {	// found a sub-dir

			ch = *pch, *pch = 0;

			// Create the dir
			if( !CreateDirectory( szDir, &sa ) ) {
        		if( GetLastError() != ERROR_ALREADY_EXISTS ) {
        		    goto Cleanup;
    			}
        	}

        	*pch = ch;

        	if ( *pch == '\\' ) pch++;
        	bMore = TRUE;
	    } else {
	    	bMore = FALSE;
	    }
  	}

	bReturn = TRUE;

Cleanup:
	if (pEveryoneSID) 
		FreeSid(pEveryoneSID);
	if (pAnonymousLogonSID)
		FreeSid(pAnonymousLogonSID);
    if (pACL) 
        LocalFree(pACL);
    if (pSD) 
        LocalFree(pSD);
    
  	TraceFunctLeave();
	return bReturn;
}

// Check if the drive exists
BOOL
CNntpFSDriver::DoesDriveExist( CHAR chDrive )
{
	TraceFunctEnter( "CNntpFSDriver::DoesDriveExist" );

	chDrive = (CHAR) CharUpper( LPSTR(chDrive) );
	return ( GetLogicalDrives() & ( 1 << (chDrive - 'A')));
}

// helper function for getting string from mb
HRESULT
CNntpFSDriver::GetString(	 IMSAdminBase *pMB,
                             METADATA_HANDLE hmb,
                             DWORD dwId,
                             LPWSTR szString,
                             DWORD *pcString)
{
    METADATA_RECORD mdr;
    HRESULT hr;
    DWORD dwRequiredLen;

    mdr.dwMDAttributes = 0;
    mdr.dwMDIdentifier = dwId;
    mdr.dwMDUserType = ALL_METADATA;
    mdr.dwMDDataType = STRING_METADATA;
    mdr.dwMDDataLen = (*pcString) * sizeof(WCHAR);
    mdr.pbMDData = (BYTE *) szString;
    mdr.dwMDDataTag = 0;

    hr = pMB->GetData(hmb, L"", &mdr, &dwRequiredLen);
    if (FAILED(hr)) *pcString = dwRequiredLen;
    return hr;
}

DWORD
CNntpFSDriver::ByteSwapper(
        DWORD   dw
        ) {
/*++

Routine Description :

    Given a DWORD reorder all the bytes within the DWORD.

Arguments :

    dw - DWORD to shuffle

Return Value ;

    Shuffled DWORD

--*/

    WORD    w = LOWORD( dw ) ;
    BYTE    lwlb = LOBYTE( w ) ;
    BYTE    lwhb = HIBYTE( w ) ;

    w = HIWORD( dw ) ;
    BYTE    hwlb = LOBYTE( w ) ;
    BYTE    hwhb = HIBYTE( w ) ;

    return  MAKELONG( MAKEWORD( hwhb, hwlb ), MAKEWORD( lwhb, lwlb )  ) ;
}

DWORD
CNntpFSDriver::ArticleIdMapper( IN DWORD   dw )
/*++

Routine Description :

    Given an articleid mess with the id to get something that when
    converted to a string will build nice even B-trees on NTFS file systems.
    At the same time, the function must be easily reversible.
    In fact -

    ARTICLEID == ArticleMapper( ArticleMapper( ARTICLEID ) )

Arguments :

    articleId - the Article Id to mess with

Return Value :

    A new article id

--*/
{
    return  ByteSwapper( dw ) ;
}


HRESULT
CNntpFSDriver::MakeChildDirPath(   IN LPSTR    szPath,
                    IN LPSTR    szFileName,
                    OUT LPSTR   szOutBuffer,
                    IN DWORD    dwBufferSize )
/*++
Routine description:

    Append "szFileName" to "szPath" to make a full path.

Arguments:

    IN LPSTR    szPath  - The prefix to append
    IN LPSTR    szFileName - The suffix to append
    OUT LPSTR   szOutBuffer - The output buffer for the full path
    IN DWORD    dwBufferSize - The buffer size prepared

Return value:

    S_OK    - Success
    TYPE_E_BUFFERTOOSMALL   - The buffer is too small
--*/
{
	_ASSERT( szPath );
	_ASSERT( strlen( szPath ) <= MAX_PATH );
	_ASSERT( szFileName );
	_ASSERT( strlen( szFileName ) <= MAX_PATH );
    _ASSERT( szOutBuffer );
    _ASSERT( dwBufferSize > 0 );

    HRESULT hr = S_OK;
    LPSTR   lpstrPtr;

    if ( dwBufferSize < (DWORD)(lstrlen( szPath ) + lstrlen( szFileName ) + 2) ) {
        hr = TYPE_E_BUFFERTOOSMALL;
        goto Exit;
    }

    lstrcpy( szOutBuffer, szPath );
    lpstrPtr = szOutBuffer + lstrlen( szPath );
    if ( *( lpstrPtr - 1 )  == '\\' ) lpstrPtr--;
    *(lpstrPtr++) = '\\';

    lstrcpy( lpstrPtr, szFileName );    // trailing null should already be appended

Exit:

    return hr;
}

BOOL
CNntpFSDriver::IsChildDir( IN WIN32_FIND_DATA& FindData )
/*++
Routine description:

    Is the found data of a child dir ? ( Stolen from Jeff Richter's book )

Arguments:

    IN WIN32_FIND_DATA& FindData    - The find data of a file or directory

Return value:

    TRUE - Yes;
    FALSE - No
--*/
{
    return(
        (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
        (FindData.cFileName[0] != '.') );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the DirDropS
	project.

Author:

	Bin Lin	(binlin@microsoft.com)

Revision History:

	binlin	02/04/98	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\idl\nntpdrv\makefile.inc ===
$(O)\nntpdrv.h : $(STAXINC)\export\nntpdrv.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\nntpdrv_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\nntpdrv_i.c \
    -header $@ \
    -tlb $(O)\nntpdrv.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\stdafx.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Bin Lin	(binlin@microsoft.com)

Revision History:

	binlin	02/04/98	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <mddef.h>

HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (DWORD)((dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL));

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\driver\nntpfs\src\stdafx.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Bin Lin     (binlin@microsoft.com)

Revision History:

	binlin   02/04/98        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif

#define THIS_MODULE "nntpfs"

#ifdef _ATL_NO_DEBUG_CRT
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>
    #include <randfail.h>   
    #include <xmemwrpr.h>
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif

#include <dbgutil.h>
//#include "mailmsgprops.h"
#include <nntperr.h>
#include <mbstring.h>
#include <fsconst.h>
#include <stdlib.h>
#include <rwnew.h>
#include <nntpbag.h>
#include <flatfile.h>
#include <nntpmeta.h>
#include <cpool.h>
#include <time.h>
#include <tsunami.hxx>
#include <smartptr.h>
#include <filehc.h>
#include <syncomp.h>
#include <dirnot.h>

//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, CComObject<Base> **pp) {
//	template <class Base>
//	HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
//	{
	    _ASSERTE(pp != NULL);
	    HRESULT hRes = E_OUTOFMEMORY;
	    CComObject<Base>* p = NULL;
	    ATLTRY(p = new CComObject<Base>())
	    if (p != NULL)
	    {
//		    p->SetVoid(NULL);					// Change this...
			p->SetVoid(pUnkOuter);				// ... to this.
	        p->InternalFinalConstructAddRef();
	        hRes = p->FinalConstruct();
	        p->InternalFinalConstructRelease();
	        if (hRes != S_OK)
	        {
	            delete p;
	            p = NULL;
	        }
	    }
	    *pp = p;
	    return hRes;
//	}
}


template <class Base>
HRESULT AtlCreateInstanceOf(IUnknown *pUnkOuter, REFIID iidDesired, LPVOID *pp) {
	HRESULT hrRes;
	CComObject<Base> *p = NULL;

	_ASSERTE(pp != NULL);
	*pp = NULL;
	hrRes = AtlCreateInstanceOf(pUnkOuter,&p);
	if (SUCCEEDED(hrRes)) {
		_ASSERTE(p != NULL);
		p->AddRef();
		hrRes = p->QueryInterface(iidDesired,pp);
		p->Release();
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\idl\nntpdrv\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the
	NNTP Store Driver resources.

Author:

	Bin Lin	(binlin@microsoft.com)

Revision History:

	binlin	01/30/98	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inntpdrv.rc
//
#define IDS_PROJNAME					100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\idl\nntpdrv\nntpdrv.cpp ===
#include "windows.h"
#include "nntpdrv.h"

HINSTANCE g_hInst;

extern "C" {
BOOL WINAPI RPCProxyDllMain(HINSTANCE, DWORD, LPVOID);
HRESULT STDAPICALLTYPE RPCProxyDllRegisterServer();
HRESULT STDAPICALLTYPE RPCProxyDllUnregisterServer();
HRESULT STDAPICALLTYPE RPCProxyDllGetClassObject(REFCLSID, REFIID, void **);
HRESULT STDAPICALLTYPE RPCProxyDllCanUnloadNow();
}

BOOL WINAPI DllMain(
        HINSTANCE  hinstDLL,
        DWORD  fdwReason,
        LPVOID  lpvReserved)
{
    if(fdwReason == DLL_PROCESS_ATTACH)
        g_hInst = hinstDLL;
    return RPCProxyDllMain(hinstDLL, fdwReason, lpvReserved);
}

HRESULT STDAPICALLTYPE DllRegisterServer() {
	HRESULT hr;
	WCHAR wszFilename[MAX_PATH];

	if (GetModuleFileNameW(g_hInst, wszFilename, MAX_PATH) <= 0) {
		return HRESULT_FROM_WIN32(GetLastError());
	}
	ITypeLib *ptLib;
	hr = LoadTypeLib(wszFilename, &ptLib);
	if (SUCCEEDED(hr)) {
		hr = RegisterTypeLib(ptLib, wszFilename, NULL);
		if (SUCCEEDED(hr)) {
			hr = RPCProxyDllRegisterServer();
		}
		ptLib->Release();
	}

	return hr;
}

HRESULT STDAPICALLTYPE DllUnregisterServer()
{
	HRESULT hr;
	WCHAR wszFilename[MAX_PATH];

	// load the type library from our module
	if (GetModuleFileNameW(g_hInst, wszFilename, MAX_PATH) <= 0) {
		return HRESULT_FROM_WIN32(GetLastError());
	}

	ITypeLib *ptLib;
	hr = LoadTypeLib(wszFilename, &ptLib);
	if (SUCCEEDED(hr)) {
		// get the type library properties
		TLIBATTR *pTLAttributes;
		hr = ptLib->GetLibAttr(&pTLAttributes);
		if (SUCCEEDED(hr)) {
			// unregister the type library using those properties
			hr = UnRegisterTypeLib(pTLAttributes->guid, 
								   pTLAttributes->wMajorVerNum, 
								   pTLAttributes->wMinorVerNum,
								   pTLAttributes->lcid,
								   pTLAttributes->syskind);
		
			if (SUCCEEDED(hr)) {
				hr = RPCProxyDllRegisterServer();
				if (SUCCEEDED(hr)) {
					hr = RPCProxyDllUnregisterServer();
				}
			}
		}
		ptLib->Release();
	}

	return hr;
}

HRESULT STDAPICALLTYPE DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv) {
	return RPCProxyDllGetClassObject(rclsid, riid, ppv);
}

HRESULT STDAPICALLTYPE DllCanUnloadNow() {
	return RPCProxyDllCanUnloadNow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\isrpc\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    main.cxx

        Library initialization for infocomm.dll  --
           Internet Information Services Common dll.

    FILE HISTORY:
        Johnl       06-Oct-1994 Created.
*/

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

//
//  System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

//#include "dbgutil.h"

//
//  Project include files.
//

//#include <inetcom.h>
//#include <inetamsg.h>
//#include <tcpproc.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

//#include <svcloc.h>
//#define SECURITY_WIN32
//#include <sspi.h>           // Security Support Provider APIs
//#include <schnlsp.h>
//#include <lonsi.hxx>
//#include "globals.hxx"

#include "isrpc.hxx"
#include "isrpcexp.h"

PISRPC		g_pIsrpc = NULL;
HINSTANCE	g_hDll = NULL;
PISRPC		sm_isrpc = NULL;

BOOL
InitializeServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                );

BOOL
CleanupServiceRpc(
                 VOID
                 );

extern "C"
BOOL WINAPI DLLEntry( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
		case DLL_PROCESS_ATTACH:  

			g_hDll = hDll;
			break;

		case DLL_PROCESS_DETACH:
			break;

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		default:
			break ;
    }

    return ( fReturn);

}  // main()

BOOL
InitializeServiceRpc(
				IN LPCSTR        pszServiceName,
                IN RPC_IF_HANDLE hRpcInterface
                )
/*++
    Description:

        Initializes the rpc endpoint for the infocomm service.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.

    Returns:
        Win32 Error Code.

--*/
{

    DWORD dwError = NO_ERROR;
    PISRPC  pIsrpc;

    //DBG_ASSERT( pszServiceName != NULL);
    //DBG_ASSERT( sm_isrpc == NULL );

    pIsrpc = new ISRPC( pszServiceName);

    if ( pIsrpc == NULL) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    //  bind over Named pipe only.
    //  If needed to bind over TCP, bind with bit flag ISRPC_OVER_TCPIP on.
    //

    dwError = pIsrpc->AddProtocol( ISRPC_OVER_TCPIP
                                  | ISRPC_OVER_NP | ISRPC_OVER_LPC
                                  );

    if( (dwError == RPC_S_DUPLICATE_ENDPOINT) ||
       (dwError == RPC_S_OK)
       ) {

        dwError = pIsrpc->RegisterInterface(hRpcInterface);
    }

    if ( dwError != RPC_S_OK ) {
        goto exit;
    }

    //
    //  Start the RPC listen thread
    //
#if 0
    dwError = pIsrpc->StartServer( );
#endif

exit:

    if ( dwError != NO_ERROR ) {
        //DBGPRINTF(( DBG_CONTEXT,
        //           "Cannot start RPC Server for %s, error %lu\n",
        //           pszServiceName, dwError ));

        delete pIsrpc;
        SetLastError(dwError);
        return(FALSE);
    }

    sm_isrpc = pIsrpc;
    return(TRUE);

} // IIS_SERVICE::InitializeServiceRpc

BOOL
CleanupServiceRpc(
                       VOID
                       )
/*++
    Description:

        Cleanup the data stored and services running.
        This function should be called only after freeing all the
         services running using this DLL.
        This function is called typically when the DLL is unloaded.

    Arguments:
        pszServiceName - pointer to null-terminated string containing the name
          of the service.

        hRpcInterface - Handle for RPC interface.


    Returns:
        Win32 Error Code.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( sm_isrpc == NULL ) {
        //DBGPRINTF((DBG_CONTEXT,
        //    "no isrpc object to cleanup. Returning success\n"));
        return(TRUE);
    }

#if 0
    (VOID) sm_isrpc->StopServer( );
#endif

    //dwError = sm_isrpc->CleanupData();
    dwError = sm_isrpc->UnRegisterInterface();

    if( dwError != RPC_S_OK ) {
        //DBGPRINTF(( DBG_CONTEXT,
        //           "ISRPC(%08x) Cleanup returns %lu\n", sm_isrpc, dwError ));
        //DBG_ASSERT( !"RpcServerUnregisterIf failure" );
        SetLastError( dwError);
    }

    delete sm_isrpc;
    sm_isrpc = NULL;

    return TRUE;
} // CleanupServiceRpc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\isrpc\isrpc.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    isrpc.cxx

Abstract:

    Contains ISRPC class implementation.

Author:

    Murali R. Krishnan         11-Dec-1995

Environment:

    User Mode - Win32

Revision History:

--*/


/************************************************************
 *  Include Headers
 ************************************************************/

#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif

//
//  System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

//#include "dbgutil.h"

//
//  Project include files.
//

//#include <inetcom.h>
//#include <inetamsg.h>
//#include <tcpproc.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

//#include <svcloc.h>
//#define SECURITY_WIN32
//#include <sspi.h>           // Security Support Provider APIs
//#include <schnlsp.h>
//#include <lonsi.hxx>
//#include "globals.hxx"
#include "isrpc.hxx"

/************************************************************
 *  Functions
 ************************************************************/


DWORD
InetinfoStartRpcServerListen(
    VOID
    )
/*++

Routine Description:

    This function starts RpcServerListen for this process. The first
    service that is calling this function will actually start the
    RpcServerListen, subsequent calls are just noted down in num count.

Arguments:

    None.

Return Value:

    None.

--*/
{

    RPC_STATUS Status = RPC_S_OK;
    Status = RpcServerListen(
                    1,                              // minimum num threads.
                    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // max concurrent calls.
                    TRUE );                         // don't wait

    return( Status );
}


DWORD
InetinfoStopRpcServerListen(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    Status = RpcMgmtStopServerListening(0);

    //
    // wait for all RPC threads to go away.
    //

    if( Status == RPC_S_OK) {
        Status = RpcMgmtWaitServerListen();
    }

    return( Status );
}


ISRPC::ISRPC(IN LPCTSTR  pszServiceName)
/*++

  This function constructs a new ISRPC object, initializing the
   members to proper state.
  Always the ISRPC members will use RPC_C_AUTHN_WINNT.

  Arguments:

    pszServiceName -  pointer to string containing the name of the service
    dwServiceAuthId - DWORD containing the service Authentication Identifier.

  Returns:
    A valid initialized ISRPC object on success.

--*/
:  m_dwProtocols         ( 0),
   m_fInterfaceAdded     ( FALSE),
   m_fEpRegistered       ( FALSE),
   m_fServerStarted      ( FALSE),
   m_hRpcInterface       ( NULL),
   m_pszServiceName      ( pszServiceName),
   m_pBindingVector      ( NULL)
{
    //DBG_REQUIRE( SetSecurityDescriptor() == NO_ERROR);
    SetSecurityDescriptor();

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Created new ISRPC object for %s at %08x\n",
                   m_pszServiceName, this));
    }
#endif
} // ISRPC::ISRPC()




ISRPC::~ISRPC(VOID)
/*++

  This function cleans up the ISRPC object and releases any dynamic memory or
  state associated with this object.

--*/
{

    CleanupData();
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Destroyed ISRPC object for %s at %08x\n",
                   m_pszServiceName, this));
    }
#endif
} // ISRPC::~ISRPC()




DWORD
ISRPC::CleanupData(VOID)
/*++

Routine Description:

    This member function cleans up the ISRPC object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD rpcStatus = RPC_S_OK;
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   " ISRPC(%08x)::Cleaning up for %s\n",
                   m_pszServiceName));
    }
#endif
    if ( m_fServerStarted) {

        rpcStatus = StopServer( );
    }

    //DBG_ASSERT( rpcStatus == RPC_S_OK);

    rpcStatus = UnRegisterInterface();

    m_dwProtocols     = 0;
    m_hRpcInterface   = NULL;

    return (rpcStatus);
} // ISRPC::CleanupData()




DWORD
ISRPC::RegisterInterface( IN RPC_IF_HANDLE  hRpcInterface)
/*++

  This function registers the RPC inteface in the object.
  If there is already a valid instance present in the object,
   this function fails and returns error.
  If this is the new interface specified, the function registers the
    interface both for dynamic and static bindings.

   Should be called after calling AddProtocol() and before StartServer()

  Arguments:
    hRpcInteface - RPC inteface handle.

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD dwError = NO_ERROR;

    if ( m_dwProtocols == 0) {

        // No protocol added. Return failure.
        return ( ERROR_INVALID_PARAMETER);
    }

    if ( m_hRpcInterface != NULL) {

        dwError =  ( RPC_S_DUPLICATE_ENDPOINT);
    } else {

        //
        // since there is no duplicate, just set the new value and return.
        //

        if ( hRpcInterface == NULL) {

            dwError = ERROR_INVALID_PARAMETER;
        } else {

            m_hRpcInterface = hRpcInterface;
        }
    }


    if ( dwError == RPC_S_OK) {

        dwError = RpcServerRegisterIf(m_hRpcInterface,
                                      0,   // MgrUuid
                                      0    // MgrEpv (Entry Point Vector)
                                      );

        if ( dwError == RPC_S_OK ) {

            m_fInterfaceAdded = TRUE;

            //
            //  Establish the dynamic bindings if any.
            //

            if ( (m_dwProtocols & (ISRPC_OVER_TCPIP | ISRPC_OVER_SPX)) != 0) {

                dwError = RpcServerInqBindings( &m_pBindingVector);

                if ( dwError == RPC_S_OK) {

                    //DBG_ASSERT( m_pBindingVector != NULL);

                    dwError = RpcEpRegister(m_hRpcInterface,
                                            m_pBindingVector,
                                            NULL,
                                            (unsigned char *) "" );

                    if ( dwError == RPC_S_OK) {

                        m_fEpRegistered = TRUE;
                    }
                } // Ep registering
            } // dynamic bindings
        } // registration successful
    }

#if 0
    IF_DEBUG(DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%08x)::RegisterInterface(%08x)"
                   " returns %ld\n",
                   this, hRpcInterface, dwError));
    }
#endif
    return ( dwError);

} // ISRPC::RegisterInterface()



DWORD
ISRPC::UnRegisterInterface( VOID)
/*++

  This function unregisters the RPC inteface in the object.

   Should be called after after StopServer() and before cleanup.

  Arguments:
    None

  Returns:
    Win32 Error Code - NO_ERROR on success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( m_fEpRegistered) {

        //DBG_ASSERT( m_hRpcInterface != NULL && m_pBindingVector != NULL);
        rpcStatus = RpcEpUnregister(m_hRpcInterface,
                                    m_pBindingVector,
                                    NULL              // pUuidVector
                                    );
#if 0
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%08x::RpcEpUnregister(%s) returns %d\n",
                       this, m_pszServiceName, rpcStatus));
        }
#endif
        //DBG_ASSERT( rpcStatus == RPC_S_OK);
        m_fEpRegistered = FALSE;
    }

    if ( m_pBindingVector != NULL) {

        rpcStatus = RpcBindingVectorFree( &m_pBindingVector);
#if 0
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%08x::RpcBindingVectorFree(%s, %08x) returns %d\n",
                       this, m_pszServiceName,
                       m_pBindingVector, rpcStatus));
        }

        DBG_ASSERT( rpcStatus == RPC_S_OK);
#endif
        m_pBindingVector = NULL;
    }

    if ( m_fInterfaceAdded != NULL) {

#if 1
        rpcStatus = RpcServerUnregisterIf(m_hRpcInterface,
                                          NULL,      // MgrUuid
                                          TRUE  // wait for calls to complete
                                          );
#endif

#if 0
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF(( DBG_CONTEXT,
                       "%08x::RpcServerUnregisterIf(%s, %08x) returns %d\n",
                       this, m_pszServiceName, m_hRpcInterface, rpcStatus));
        }
#endif
		//_ASSERT(rpcStatus == RPC_S_OK);
		m_fInterfaceAdded = FALSE;
    }

#if 0
    IF_DEBUG(DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%08x)::UnRegisterInterface(%08x)"
                   " returns %ld\n",
                   this, m_hRpcInterface, rpcStatus));
    }
#endif
    return ( rpcStatus);
} // ISRPC::UnRegisterInterface()




DWORD
ISRPC::AddProtocol( IN DWORD Protocol)
/*++

Routine Description:

    This member function adds another protocol to the binding list.

Arguments:

    protocol - protocol binding opcode.

    fDynamic - Boolean indicating if the call should do dynamic or static
                RPC binding for the protocol specified.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_LPC ) {

        // Currently we only support static binding
        rpcStatus = BindOverLpc( FALSE);
    }

#ifndef CHICAGO

    //
    // Enable all remote bindings
    //

    if ( rpcStatus == RPC_S_OK ) {

        if ( Protocol & ISRPC_OVER_TCPIP ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverTcp( TRUE);
        }

        if ( rpcStatus == RPC_S_OK && Protocol & ISRPC_OVER_NP ) {

            // Currently we only support static binding
            rpcStatus = BindOverNamedPipe( FALSE);
        }

        if ( rpcStatus == RPC_S_OK &&  Protocol & ISRPC_OVER_SPX  ) {

            // Currently we only support dynamic binding
            rpcStatus = BindOverSpx( TRUE);
        }
    }

#else // CHICAGO
    rpcStatus = RPC_S_OK;

    if ( Protocol & ISRPC_OVER_TCPIP ) {

        // Currently we only support dynamic binding
        rpcStatus = BindOverTcp( TRUE);
    }

    if ( Protocol & ISRPC_OVER_NB ) {

        // Currently we only support dynamic binding
        // Ignore status for NB for now
        (VOID)BindOverNetBios(TRUE);
    }
#endif // CHICAGO
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%08x)::AddProtocol(%08x) returns %ld.\n",
                   this, Protocol, rpcStatus ));
    }
#endif
    return( rpcStatus );

} // ISRPC::AddProtocol()

DWORD
ISRPC::RemoveProtocol(IN DWORD Protocol)
/*++

Routine Description:

    This member function removes a protocol from the binding list.

Arguments:

    protocol - protocol binding opcode.

Return Value:

    RPC error code.

Note:
    As a side effect, this function removes the dynamic endpoing on
     TCPIP when SPX binding is removed and vice-versa.

--*/
{
#if 0
    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%08x)::RemoveProtocol(%s) is not implemented\n",
               this, m_pszServiceName));
    DBG_ASSERT( FALSE);
#endif
    return ( ERROR_CALL_NOT_IMPLEMENTED);
} // ISRPC::RemoveProtocol()




DWORD
ISRPC::StartServer(
            VOID
            )
/*++

Routine Description:

    This member function start RPC server.

Arguments:

    None.

Return Value:

    RPC error code.

--*/
{
    DWORD rpcStatus;

    //
    // add the interface.
    //

    if ( m_hRpcInterface == NULL) {

        return (ERROR_INVALID_PARAMETER);
    }

    //
    // start rpc server.
    //

#ifndef SERVICE_AS_EXE

    rpcStatus = InetinfoStartRpcServerListen();

#else

    rpcStatus = RpcServerListen(
                                1,          // minimum num threads.
                                1,          // max concurrent calls.
                                TRUE );     // don't wait

#endif // SERVICE_AS_EXE

    if ( rpcStatus == RPC_S_OK ) {
        m_fServerStarted = TRUE;
    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "ISRPC(%08x)::StartServer(%s) returns %ld\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return( rpcStatus );

} // ISRPC::StartServer()




DWORD
ISRPC::StopServer(
            VOID
            )
{
    DWORD  rpcStatus = RPC_S_OK;

    if( m_fServerStarted ) {

#ifndef SERVICE_AS_EXE

        rpcStatus = InetinfoStopRpcServerListen();
#else

        //
        // stop server listen.
        //

        rpcStatus = RpcMgmtStopServerListening(0);

        //
        // wait for all RPC threads to go away.
        //

        if( rpcStatus == RPC_S_OK) {

            rpcStatus = RpcMgmtWaitServerListen();
        }

#endif // SERVICE_AS_EXE

        m_fServerStarted = FALSE;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "ISRPC(%08x)::StopServer( %s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif

    return ( rpcStatus);
} // ISRPC::StopServer()



DWORD
ISRPC::EnumBindingStrings(
    IN OUT LPINET_BINDINGS pBindings
    )
/*++

Routine Description:

    This member function enumurates the binding strings of the protocols
    bound to the server.

Arguments:

    pBindings : pointer to a binding strings structure. The caller
        should call FreeBindingStrings member function to free the string
        after use.

Return Value:

    Windows Error Code;

--*/
{
   DWORD dwError;
   RPC_BINDING_VECTOR * pBindingVector = NULL;
   LPINET_BIND_INFO pBindingsInfo;
   DWORD  dwCount = 0;
   DWORD i;

   //
   // query RPC for RPC_BINDING_VECTORS.
   //

   dwError =   RpcServerInqBindings( &pBindingVector );

   if( dwError != NO_ERROR ) {

       goto Cleanup;
   }

   //DBG_ASSERT( pBindingVector->Count > 0 );

   //
   // alloc memory for  INET_RPC_BINDING_STRINGS.
   //

   pBindingsInfo = (LPINET_BIND_INFO)
     LocalAlloc( GPTR, sizeof(INET_BIND_INFO) * pBindingVector->Count );

   if( pBindingsInfo == NULL ) {

       dwError = ERROR_NOT_ENOUGH_MEMORY;
       goto Cleanup;
   }

   //
   // convert binding handle to binding vectors.
   //

   pBindings->NumBindings  = 0;
   pBindings->BindingsInfo = pBindingsInfo;

   for( i = 0; i < pBindingVector->Count; i++ ) {

       LPSTR BindingString;

       BindingString = NULL;
       dwError = RpcBindingToStringBindingA(pBindingVector->BindingH[i],
                                            (LPBYTE *)&BindingString );

       if( dwError != NO_ERROR ) {
           goto Cleanup;
       }
#if 0
       IF_DEBUG( DLL_RPC) {
           DBGPRINTF(( DBG_CONTEXT, "Binding Handle[%d] = %08x. String = %s\n",
                      i, pBindingVector->BindingH[i], BindingString));
       }
#endif

       //
       // check to we get only our named-pipe endpoint.
       //

       if( strstr( BindingString, "ncacn_np" ) != NULL ) {

           //
           // found a named-pipe binding string.
           //

           if( strstr(BindingString,
                      m_pszServiceName ) == NULL ) {

               //
               // found a non service named-pipe entry.
               // ignore it.
               //

               RpcStringFreeA( (LPBYTE *)&BindingString );

           } else {
#if 0
               IF_DEBUG( DLL_RPC) {
                   DBGPRINTF(( DBG_CONTEXT, "Binding String Chosen = %s\n",
                              BindingString));
               }
#endif
               pBindings->BindingsInfo[dwCount].Length =
                 (strlen(BindingString) + 1) * sizeof(CHAR);
               pBindings->BindingsInfo[dwCount].BindData = BindingString;
               dwCount++;
           }
       }

   } // for

   dwError = NO_ERROR;
   pBindings->NumBindings = dwCount;
#if 0
   IF_DEBUG( DLL_RPC) {

       DBGPRINTF(( DBG_CONTEXT, "Binding Vectors chosen"
                  " Service = %s, NumBindings = %d of Total = %d\n",
                  m_pszServiceName, dwCount, pBindingVector->Count));
   }
#endif
 Cleanup:

   if( pBindingVector != NULL ) {

       DWORD LocalError;
       LocalError = RpcBindingVectorFree( &pBindingVector );
       //DBG_ASSERT( LocalError == NO_ERROR );
   }

   if( dwError != NO_ERROR ) {
       FreeBindingStrings( pBindings );
       pBindings->NumBindings = 0;
#if 0
       IF_DEBUG( DLL_RPC) {

           DBGPRINTF(( DBG_CONTEXT,
                      "ISRPC(%08x)::EnumBindingStrings(%s) failed, %ld.",
                      this, m_pszServiceName, dwError ));
       }
#endif
   }

   return( dwError );

} // ISRPC::EnumBindingStrings()




VOID
ISRPC::FreeBindingStrings(
     IN OUT LPINET_BINDINGS pInetBindings
    )
/*++

Routine Description:

    This member function deletes a binding vector that was returned by the
    EnumBindingStrings member function.

Arguments:

    pBindings : pointer to a binding vector.

Return Value:

    Windows Error Code;

--*/
{
    DWORD dwError;
    DWORD i;


    //
    // free binding strings.
    //

    for( i = 0; i < pInetBindings->NumBindings; i++) {
        dwError = RpcStringFreeA( ((LPBYTE *)&pInetBindings
                                 ->BindingsInfo[i].BindData ));
        //DBG_ASSERT( dwError == NO_ERROR );
    }

    pInetBindings->NumBindings = 0;

    //
    // free bindings info array.
    //

    if( pInetBindings->BindingsInfo != NULL ) {
        LocalFree( (LPWSTR)pInetBindings->BindingsInfo );
        pInetBindings->BindingsInfo = NULL;
    }

    return;

} // ISRPC::FreeBindingStrings()




DWORD
ISRPC::BindOverTcp(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_TCPIP) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ( ISRPC::DynamicBindOverTcp());
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_TCPIP;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverTcp(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return ( rpcStatus);
} // ISRPC::BindOverTcpIp()

#ifdef CHICAGO
DWORD
ISRPC::BindOverNetBios(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NB) == 0);

    if ( !fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    // We will use Dynamic endpoint for the NetBios binding.

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_ipx",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid );           // security

    rpcStatus =
      RpcServerUseProtseqW(
                           L"ncacn_nb_tcp",        // protocol string.
                           ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                           &sm_sid );           // security

    switch (rpcStatus) {

      case RPC_S_OK:

        //
        // set the protocol bit.
        //

        m_dwProtocols |= ISRPC_OVER_NB;
        break;

      case RPC_S_DUPLICATE_ENDPOINT:

        //DBGPRINTF(( DBG_CONTEXT,
        //           "(%08x) ncacn_nb is already added for %s\n",
        //           this,
        //           m_pszServiceName));
        rpcStatus = RPC_S_OK;
        break;

      case RPC_S_PROTSEQ_NOT_SUPPORTED:
      case RPC_S_CANT_CREATE_ENDPOINT:

        //DBGPRINTF(( DBG_CONTEXT,
        //           "(%08x) ncacn_nb is not supported for %s (%ld).\n",
        //           this, m_pszServiceName, rpcStatus ));
        rpcStatus = RPC_S_OK;
        break;

      default:
        break;
    } // switch()

    //
    // if the security support provider is not enabled, do so.
    //

    if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

        rpcStatus = AddSecurity();

    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverNetBios(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif
    return ( rpcStatus);
} // ISRPC::BindOverNetBios()
#endif // CHICAGO

DWORD
ISRPC::BindOverNamedPipe(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_NP) == 0);


    //
    // On Named Pipe, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_NP) == 0 ) {

        WCHAR  rgchNp[1024];

        wsprintfW( rgchNp,
#ifdef UNICODE
                  L"%ws%s"
#else
                  L"%ws%S"
#endif // UNICODE
                  ,
                  ISRPC_NAMED_PIPE_PREFIX_W,
                  m_pszServiceName);

        //
        // Establish a static Named pipe binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncacn_np",        // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchNp,             // end point!
                                 &sm_sid );          // security
#if 0
        IF_DEBUG( DLL_RPC) {

            CHAR pszBuff[100];
            wsprintfA( pszBuff, "%S", rgchNp);
            DBGPRINTF(( DBG_CONTEXT,
                       " RpcServerUseProtseqEpW( %s, %d, %s, %08x) returns"
                       " %d\n",
                       "ncacn_np", ISRPC_PROTSEQ_MAX_REQS,
                       pszBuff, &sm_sid, rpcStatus));
        }
#endif
        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_NP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncacn_np is already added for %s\n",
            //           this,
            //           m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_NP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncacn_np is not supported for %s (%ld).\n",
            //           this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverNamedPipe()





DWORD
ISRPC::BindOverLpc(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_LPC) == 0);


    //
    // On LPC, we support only static bindings. No dynamic Binding.
    //

    if ( fDynamic) {

        return ( ERROR_CALL_NOT_IMPLEMENTED);
    }

    if( (m_dwProtocols & ISRPC_OVER_LPC) == 0 ) {

        WCHAR  rgchLpc[1024];

        // LPC Endpoint string is:   <InterfaceName>_LPC
        wsprintfW( rgchLpc,
#ifdef UNICODE
                  L"%s_%ws"
#else
                  L"%S_%ws"
#endif // UNICODE
                  ,
                  m_pszServiceName,
                  ISRPC_LPC_NAME_SUFFIX_W);

        //
        // Establish a static Lpc binding.
        //

        rpcStatus =
          RpcServerUseProtseqEpW(
                                 L"ncalrpc",         // protocol string.
                                 ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                                 rgchLpc,            // end point!
                                 &sm_sid );          // security
#if 0
        IF_DEBUG( DLL_RPC) {

            CHAR pszBuff[100];
            wsprintfA( pszBuff, "%S", rgchLpc);
            DBGPRINTF(( DBG_CONTEXT,
                       " RpcServerUseProtseqEpW( %s, %d, %s, %08x) returns"
                       " %d\n",
                       "ncalrpc", ISRPC_PROTSEQ_MAX_REQS,
                       pszBuff, &sm_sid, rpcStatus));
        }
#endif
        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            m_dwProtocols |= ISRPC_OVER_LPC;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //
            // Ignore the duplicate end point error
            //
            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncalrpc is already added for %s\n",
            //           this,
            //           m_pszServiceName));
            m_dwProtocols |= ISRPC_OVER_LPC;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "(%08x) ncalrpc is not supported for %s (%ld).\n",
            //           this, m_pszServiceName, rpcStatus ));
            rpcStatus = RPC_S_OK;
            break;

          default:
            break;
        } // switch()
    }

    return ( rpcStatus);

} // ISRPC::BindOverLpc()




DWORD
ISRPC::BindOverSpx(IN BOOL fDynamic)
{
    DWORD rpcStatus = RPC_S_OK;

    //DBG_ASSERT( (m_dwProtocols & ISRPC_OVER_SPX) == 0);

    if ( !fDynamic) {

        rpcStatus =  ( ERROR_CALL_NOT_IMPLEMENTED);

    } else {

        rpcStatus = ISRPC::DynamicBindOverSpx();
    }

    if ( rpcStatus == RPC_S_OK) {

        m_dwProtocols |= ISRPC_OVER_SPX;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "(%08x)::BindOverSpx(%s) returns %d\n",
                   this, m_pszServiceName, rpcStatus));
    }
#endif

    return ( rpcStatus);
} // ISRPC::BindOverSpx()


# if DBG

VOID
ISRPC::Print(VOID) const
{
#if 0
    DBGPRINTF(( DBG_CONTEXT,
               " ISRPC(%08x). SvcName=%s\n"
               " Protocols = %d.\n"
               " RPC Interface = %08x. Binding Vector = %08x\n"
               " InterfaceAdded = %d.\n"
               " EpRegistered = %d. ServerStarted = %d.\n"
               ,
               this, m_pszServiceName,
               m_dwProtocols,
               m_hRpcInterface, m_pBindingVector,
               m_fInterfaceAdded,
               m_fEpRegistered, m_fServerStarted
               ));
#endif

} // ISRPC::Print()

# endif // DBG



/******************************
 * STATIC Member Definitions
 ******************************/

DWORD ISRPC::sm_dwProtocols = 0;

SECURITY_DESCRIPTOR ISRPC::sm_sid;
PACL ISRPC::sm_pACL;
BOOL  ISRPC::sm_fSecurityEnabled = FALSE;


DWORD
ISRPC::Initialize(VOID)
{
    sm_dwProtocols  = 0;

    return SetSecurityDescriptor();

} // ISRPC::Initialize()



DWORD
ISRPC::Cleanup(VOID)
{
    //
    // Free up the memory holding the ACL for the security descriptor
    //
    delete [] ((BYTE *) sm_pACL);
    sm_pACL = NULL;

    //
    // Free up the security descriptor
    //

    ZeroMemory( (PVOID) &sm_sid, sizeof(sm_sid));

    //
    // For now nothing to do. Just a place holder.
    //

    return ( NO_ERROR);

} // ISRPC::Cleanup()


DWORD
ISRPC::DynamicBindOverTcp(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over TCP/IP, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_TCPIP) == 0 ) {

        //
        // Not already present. Add dynamic endpoint over TCP/IP
        //

        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_ip_tcp",    // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //

            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_ip_tcp is already added.\n"));
            sm_dwProtocols |= ISRPC_OVER_TCPIP;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_ip_tcp is not supported. Error = %ld\n",
            //           rpcStatus));

            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled() ) {

            rpcStatus = AddSecurity();

        }
    }
#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverTcp() returns %d\n",
                   rpcStatus));
    }
#endif
    return ( rpcStatus);

} // ISRPC::DynamicBindOverTcp()




DWORD
ISRPC::DynamicBindOverSpx(VOID)
/*++
  This static function (ISRPC member) establishes a dynamic endpoing
   RPC binding over SPX, using a run-time library call to RPC.
  RPC run-time library allows one to create as many dynamic end points
   as one wishes. So we maintain external state and control the number
   of end points created to 1.

  Arguments:
    None

  Returns:
    RPC status - RPC_S_OK for success.

--*/
{
    DWORD rpcStatus = RPC_S_OK;

    if( (sm_dwProtocols & ISRPC_OVER_SPX) == 0 ) {

        // Use dynamic end point for the server.
        rpcStatus =
          RpcServerUseProtseqW(
                               L"ncacn_spx",       // protocol string.
                               ISRPC_PROTSEQ_MAX_REQS, //max concurrent calls
                               &sm_sid );          // security

        switch (rpcStatus) {

          case RPC_S_OK:

            //
            // set the protocol bit.
            //
            sm_dwProtocols |= ISRPC_OVER_SPX;
            break;

          case RPC_S_DUPLICATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_spx is already added.\n"
            //           ));
            sm_dwProtocols |= ISRPC_OVER_SPX;
            rpcStatus = RPC_S_OK;
            break;

          case RPC_S_PROTSEQ_NOT_SUPPORTED:
          case RPC_S_CANT_CREATE_ENDPOINT:

            //DBGPRINTF(( DBG_CONTEXT,
            //           "ncacn_spx is not supported. Error (%ld).\n",
            //           rpcStatus ));
            break;

          default:
            break;
        } // switch()

        //
        // if the security support provider is not enabled, do so.
        //

        if( rpcStatus == RPC_S_OK && !IsSecurityEnabled()) {

            rpcStatus = AddSecurity();
        }
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "DynamicBindOverSpx() returns %d\n",
                   rpcStatus));
    }
#endif

    return ( rpcStatus);

} // ISRPC::DynamicBindOverSpx()





DWORD
ISRPC::SetSecurityDescriptor( VOID)
/*++

Routine Description:

    This member function builds the security descriptor used by RPC module.
    The security descriptor denies everybody the ability to change/see anything
    connected to the DACL and allows everybody to read from/write to the pipe.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD dwError = NO_ERROR;
    BOOL  fSuccess = FALSE;
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID psidWorld = NULL;
    PSID psidLocalSystem = NULL;
    BYTE *pbBuffer = NULL;
    DWORD cbAcl = 0;

    InitializeSecurityDescriptor(&sm_sid,
                                 SECURITY_DESCRIPTOR_REVISION );

    //
    // Create the "WORLD" sid
    //
    if ( !AllocateAndInitializeSid( &siaWorld,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0,0,0,0,0,0,0,
                                    &psidWorld ) )
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "AllocateAndInitializeSid failed : 0x%x\n",
        //           GetLastError()));
        goto cleanup;
    }

    //
    // Calculate the size of the ACL that will hold the the ACESS_DENIED and ACCESS_ALLOW ace
    // [ripped off from MSDN docs]
    //
   cbAcl = sizeof(ACL) +
           sizeof( ACCESS_ALLOWED_ACE ) +
           sizeof( ACCESS_DENIED_ACE )  +
           2*GetLengthSid(psidWorld) -
           2*sizeof(DWORD) ;

    if ( ! ( pbBuffer = new BYTE[cbAcl] ) )
    {
        goto cleanup;
    }

    sm_pACL = (PACL) pbBuffer;

    //
    // Initialize the ACL
    //
    if ( !InitializeAcl( sm_pACL,
                         cbAcl,
                         ACL_REVISION ) )
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "InitializeAcl failed : 0x%x\n",
        //           GetLastError()));
        goto cleanup;
    }

    //
    // Add the Access Denied ACE; this has to be first in the list to make sure
    // that any attempt to muck with the DACL will be disallowed
    //
    if ( !AddAccessDeniedAce( sm_pACL,
                              ACL_REVISION,
                              WRITE_DAC | DELETE | WRITE_OWNER,
                              psidWorld ) )
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "AddAccessDeniedAce failed : 0x%x\n",
        //           GetLastError()));
        goto cleanup;
    }

    //
    // Add the Access Allowed ACE
    //
    if ( !AddAccessAllowedAce( sm_pACL,
                               ACL_REVISION,
                               FILE_ALL_ACCESS,
                               psidWorld ) )
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "AddAccessAllowedAce failed : 0x%x\n",
        //           GetLastError()));
        goto cleanup;
    }

    //
    // Set (no) group & owner for the security descriptor
    //
    if ( !SetSecurityDescriptorOwner( &sm_sid,
                                      NULL,
                                      FALSE ) )
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "SetsecurityDescriptorOwner failed : 0x%x\n",
        //           GetLastError()));
        goto cleanup;
    }


    if ( !SetSecurityDescriptorGroup( &sm_sid,
                                      NULL,
                                      FALSE ) )
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "SetsecurityDescriptorGroup failed : 0x%x\n",
        //           GetLastError()));
        goto cleanup;
    }

    if ( !( fSuccess = SetSecurityDescriptorDacl ( &sm_sid,
                                                   TRUE,          // Dacl present
                                                   sm_pACL,
                                                   FALSE ) ) )    // Not defaulted
    {
        //DBGPRINTF((DBG_CONTEXT,
        //           "SetSecurityDescriptorDacl failed : 0x%x\n",
        //           GetLastError()));
    }


cleanup:


    if ( psidWorld )
    {
        FreeSid( psidWorld );
    }

    if (!fSuccess)
    {

        dwError = GetLastError();

        if ( pbBuffer )
        {
            delete [] pbBuffer;
            sm_pACL = NULL;
        }

        //
        // free up security discriptor memory and set it to NULL.
        //
        memset( (PVOID ) &sm_sid,  0, sizeof(sm_sid));
    }

    return( dwError );

} // ISRPC::SetSecurityDescriptor()


DWORD
ISRPC::AddSecurity(
    VOID
    )
/*++

Routine Description:

    This member function adds security support provider over RPC.

Arguments:

    None.

Return Value:

    Windows error code.

--*/
{
    DWORD rpcStatus;

    //
    // Register for authentication using WinNT.
    //

    rpcStatus = RpcServerRegisterAuthInfo(
                    (unsigned char * ) NULL, // app name to security provider
                    RPC_C_AUTHN_WINNT,       // Auth package ID.
                    NULL,                    // RPC_C_AUTHN_WINNT ==> NULL
                    NULL                     // args ptr for authn function.
                    );

    if ( rpcStatus == RPC_S_OK) {

        sm_fSecurityEnabled = TRUE;
    }

#if 0
    IF_DEBUG( DLL_RPC) {

        DBGPRINTF(( DBG_CONTEXT, "AddSecurity() returns Error %u\n",
                   rpcStatus));
    }
#endif

    return (rpcStatus);
} // ISRPC::AddSecurity()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpapi\nntpbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nntpbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the common
    internet Admin APIs.

Author:

    Madan Appiah (madana) 10-Oct-1995

Environment:

    User Mode -Win32

Revision History:

    Madan Appiah (madana) 10-Oct-1995 Created.
    Murali R. Krishnan (MuraliK)   15-Nov-1995   Remove Netp routines
    Murali R. Krishnan (MuraliK)   21-Nov-1995   Support TCP/IP binding
	Rajeev Rajan	(rajeevr)	   26-Feb-1997	 Moved from K2 tree for nntp

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>

#include <nntpsvc.h>
#include <inetinfo.h>
#include <norminfo.h>
#include "apiutil.h"



handle_t
NNTP_IMPERSONATE_HANDLE_bind(
    NNTP_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet info admin client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of security

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       NNTP_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );


    return BindHandle;
} // NNTP_IMPERSONATE_HANDLE_bind()



handle_t
NNTP_HANDLE_bind(
    NNTP_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet admin client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       NNTP_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return BindHandle;
} // NNTP_HANDLE_bind()



void
NNTP_IMPERSONATE_HANDLE_unbind(
    NNTP_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // NNTP_IMPERSONATE_HANDLE_unbind()



void
NNTP_HANDLE_unbind(
    NNTP_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from a server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);


    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // NNTP_IDENTITY_HANDLE_unbind()


/****************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpapi\nntpsubs.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    nntpsubs.c

Abstract:

    Subroutines for LAN Manager APIs.

Author:

    Dan Hinsley (DanHi) 23-Mar-93

Revision History:

--*/

// These must be included first:
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NOMINMAX                // Avoid stdlib.h vs. windows.h warnings.
#include <windows.h>


BOOLEAN
NntpInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DllHandle);          // avoid compiler warnings


    //
    // Handle attaching w3svc.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

#if 0
        //
        // Initialize RPC Bind Cache
        //

        NetpInitRpcBindCache();
#endif

    //
    // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
    // call is being made.  If lpReserved is Non-NULL, then ExitProcess is
    // in progress.  These cleanup routines will only be called when
    // a FreeLibrary is being called.  ExitProcess will automatically
    // clean up all process resources, handles, and pending io.
    //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

#if 0
        NetpCloseRpcBindCache();
#endif

    }

    return TRUE;

} // NntpInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpctrs\nntpctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nntpctrs.h

    Offset definitions for the NNTP Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    NntpOpenPerformanceData procecedure, they will be added to the
    NNTP Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the NNTPCTRS.DLL DLL code as well as the
    NNTPCTRS.INI definition file.  NNTPCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#ifndef _NNTPCTRS_H_
#define _NNTPCTRS_H_

//
// disabled tracing by default for the perfmon client code
//
#ifndef	NOTRACE
#define	NOTRACE
#endif

//
//  The "NNTP Server" object.
//

#define NNTP_COUNTER_OBJECT1                    0

//
//  The individual counters.
//

#define NNTP_BYTES_SENT_COUNTER                 2
#define NNTP_BYTES_RECEIVED_COUNTER             4
#define NNTP_BYTES_TOTAL_COUNTER                6

#define NNTP_TOTAL_CONNECTIONS_COUNTER          8
#define NNTP_TOTAL_SSL_CONNECTIONS_COUNTER      10
#define NNTP_CURRENT_CONNECTIONS_COUNTER        12
#define NNTP_MAX_CONNECTIONS_COUNTER            14

#define NNTP_CURRENT_ANONYMOUS_COUNTER          16
#define NNTP_CURRENT_NONANONYMOUS_COUNTER       18
#define NNTP_TOTAL_ANONYMOUS_COUNTER            20
#define NNTP_TOTAL_NONANONYMOUS_COUNTER         22
#define NNTP_MAX_ANONYMOUS_COUNTER              24
#define NNTP_MAX_NONANONYMOUS_COUNTER           26

#define NNTP_TOTAL_OUTBOUND_CONNECTS_COUNTER    28
#define NNTP_OUTBOUND_CONNECTS_FAILED_COUNTER   30
#define NNTP_CURRENT_OUTBOUND_CONNECTS_COUNTER  32
#define NNTP_OUTBOUND_LOGON_FAILED_COUNTER      34

#define NNTP_TOTAL_PULL_FEEDS_COUNTER           36
#define NNTP_TOTAL_PUSH_FEEDS_COUNTER           38
#define NNTP_TOTAL_PASSIVE_FEEDS_COUNTER        40

#define NNTP_ARTICLES_SENT_COUNTER              42
#define NNTP_ARTICLES_RECEIVED_COUNTER          44
#define NNTP_ARTICLES_TOTAL_COUNTER             46

#define NNTP_ARTICLES_POSTED_COUNTER            48
#define NNTP_ARTICLE_MAP_ENTRIES_COUNTER        50
#define NNTP_HISTORY_MAP_ENTRIES_COUNTER        52
#define NNTP_XOVER_ENTRIES_COUNTER              54

#define NNTP_CONTROL_MSGS_IN_COUNTER            56
#define NNTP_CONTROL_MSGS_FAILED_COUNTER        58
#define NNTP_MODERATED_POSTINGS_SENT_COUNTER    60
#define NNTP_MODERATED_POSTINGS_FAILED_COUNTER  62

#define NNTP_SESS_FLOW_CONTROL_COUNTER          64

#define NNTP_ARTICLES_EXPIRED_COUNTER           66

#define NNTP_ARTICLES_SENT_PERSEC_COUNTER       68
#define NNTP_ARTICLES_RECEIVED_PERSEC_COUNTER   70
#define NNTP_ARTICLES_POSTED_PERSEC_COUNTER     72
#define NNTP_ARTICLE_MAP_ENTRIES_PERSEC_COUNTER 74
#define NNTP_HISTORY_MAP_ENTRIES_PERSEC_COUNTER 76
#define NNTP_XOVER_ENTRIES_PERSEC_COUNTER       78
#define NNTP_ARTICLES_EXPIRED_PERSEC_COUNTER    80

//
//  The "NNTP Commands" counter object.
//

#define NNTP_COUNTER_OBJECT2                    100

//
//  The individual counters.
//

#define NNTP_CMDS_ARTICLE_COUNTER				102
#define NNTP_CMDS_PERSEC_ARTICLE_COUNTER		104
#define NNTP_CMDS_GROUP_COUNTER					106
#define NNTP_CMDS_PERSEC_GROUP_COUNTER			108
#define NNTP_CMDS_HELP_COUNTER					110
#define NNTP_CMDS_PERSEC_HELP_COUNTER			112
#define NNTP_CMDS_IHAVE_COUNTER					114
#define NNTP_CMDS_PERSEC_IHAVE_COUNTER			116
#define NNTP_CMDS_LAST_COUNTER					118
#define NNTP_CMDS_PERSEC_LAST_COUNTER			120
#define NNTP_CMDS_LIST_COUNTER					122
#define NNTP_CMDS_PERSEC_LIST_COUNTER			124
#define NNTP_CMDS_NEWGROUPS_COUNTER				126
#define NNTP_CMDS_PERSEC_NEWGROUPS_COUNTER		128
#define NNTP_CMDS_NEWNEWS_COUNTER				130
#define NNTP_CMDS_PERSEC_NEWNEWS_COUNTER		132
#define NNTP_CMDS_NEXT_COUNTER					134
#define NNTP_CMDS_PERSEC_NEXT_COUNTER			136
#define NNTP_CMDS_POST_COUNTER					138
#define NNTP_CMDS_PERSEC_POST_COUNTER			140
#define NNTP_CMDS_QUIT_COUNTER					142
#define NNTP_CMDS_PERSEC_QUIT_COUNTER			144
#define NNTP_CMDS_STAT_COUNTER					146
#define NNTP_CMDS_PERSEC_STAT_COUNTER			148
#define NNTP_LOGON_ATTEMPTS_COUNTER             150
#define NNTP_LOGON_FAILURES_COUNTER             152
#define NNTP_LOGON_ATTEMPTS_PERSEC_COUNTER      154
#define NNTP_LOGON_FAILURES_PERSEC_COUNTER      156
#define NNTP_CMDS_CHECK_COUNTER					158
#define NNTP_CMDS_TAKETHIS_COUNTER				160
#define NNTP_CMDS_MODE_COUNTER					162
#define NNTP_CMDS_SEARCH_COUNTER				164
#define NNTP_CMDS_XHDR_COUNTER					166
#define NNTP_CMDS_XOVER_COUNTER					168
#define NNTP_CMDS_XPAT_COUNTER					170
#define NNTP_CMDS_XREPLIC_COUNTER				172
#define NNTP_CMDS_PERSEC_CHECK_COUNTER			174
#define NNTP_CMDS_PERSEC_TAKETHIS_COUNTER		176
#define NNTP_CMDS_PERSEC_MODE_COUNTER			178
#define NNTP_CMDS_PERSEC_SEARCH_COUNTER			180
#define NNTP_CMDS_PERSEC_XHDR_COUNTER			182
#define NNTP_CMDS_PERSEC_XOVER_COUNTER			184
#define NNTP_CMDS_PERSEC_XPAT_COUNTER			186
#define NNTP_CMDS_PERSEC_XREPLIC_COUNTER		188

#endif  // _NNTPCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpctrs\debug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.h

    This file contains a number of debug-dependent definitions for
    the Nntp Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.

*/


#ifndef _NNTPDEBUG_H_
#define _NNTPDEBUG_H_


#if DBG

//
//  Debug output control flags.
//

#define TCP_DEBUG_ENTRYPOINTS          0x00000001L     // DLL entrypoints
#define TCP_DEBUG_OPEN                 0x00000002L     // OpenPerformanceData
#define TCP_DEBUG_CLOSE                0x00000004L     // CollectPerformanceData
#define TCP_DEBUG_COLLECT              0x00000008L     // ClosePerformanceData
#define TCP_DEBUG_OUTPUT_TO_DEBUGGER   0x40000000L

extern DWORD NntpDebug;

#else   // !DBG

#endif  // DBG


#endif  // _NNTPDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpapi\nntpstub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infostub.c

Abstract:

    Client stubs of the Internet Info Server Admin APIs.

Author:

    Madan Appiah (madana) 10-Oct-1993

Environment:

    User Mode - Win32

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <nntpsvc.h>


NET_API_STATUS
NET_API_FUNCTION
NntpGetAdminInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    OUT LPNNTP_CONFIG_INFO * pConfig
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpGetAdminInformation

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    pConfig -- On return a pointer to the return information structure
        is returned in the address pointed to by pConfig

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *pConfig = NULL;     // Must be NULL so RPC knows to fill it in.

    RpcTryExcept

       apiStatus = NntprGetAdminInformation(
                ServerName,
				InstanceId,
                (LPI_NNTP_CONFIG_INFO*)pConfig
                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpGetAdminInformation

NET_API_STATUS
NET_API_FUNCTION
NntpSetAdminInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_CONFIG_INFO pConfig,
    OUT LPDWORD pParmError OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpSetAdminInformation

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    pConfig -- A pointer to the config info structure used to set
        the admin information.

    pParmError - If ERROR_INVALID_PARAMETER is returned, will point to the
        offending parameter.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprSetAdminInformation(
                ServerName,
				InstanceId,
                (LPI_NNTP_CONFIG_INFO)pConfig,
                pParmError
                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpSetAdminInformation

NET_API_STATUS
NET_API_FUNCTION
NntpQueryStatistics(
    IN  LPWSTR      servername,
    IN	DWORD		InstanceId,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpGetStatistics

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    level --Level of information required. 100, 101 and 102 are valid
        for all platforms. 302, 402, 403, 502 are valid for the
        appropriate platform.

    bufptr --On return a pointer to the return information structure
        is returned in the address pointed to by bufptr.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    *bufptr = NULL;     // Must be NULL so RPC knows to fill it in.

    RpcTryExcept

       apiStatus = NntprQueryStatistics(
                                servername,
								InstanceId,
                                level,
                                (LPNNTP_STATISTICS_0*)bufptr
                                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpQueryStatistics

NET_API_STATUS
NET_API_FUNCTION
NntpClearStatistics(
    IN LPWSTR Server OPTIONAL,
    IN DWORD  InstanceId
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = NntpClearStatistics(
						Server,
						InstanceId
						);
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

} // NntpClearStatistics

NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateFeeds (
    IN  LPWSTR ServerName,
    IN	DWORD  InstanceId,
    OUT LPDWORD EntriesRead,
    OUT LPNNTP_FEED_INFO *Buffer
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpEnumerateFeeds

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;
    NNTP_FEED_ENUM_STRUCT EnumStruct;

	ZeroMemory( &EnumStruct, sizeof( EnumStruct ) ) ;

    RpcTryExcept

        apiStatus = NntprEnumerateFeeds(
                                ServerName,
								InstanceId,
                                &EnumStruct
                                );

        *EntriesRead = EnumStruct.EntriesRead;
        *Buffer = (LPNNTP_FEED_INFO)EnumStruct.Buffer;

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpEnumerateFeeds

NET_API_STATUS
NET_API_FUNCTION
NntpEnableFeed(
	IN	NNTP_HANDLE		ServerName,
    IN	DWORD			InstanceId,
	IN	DWORD			FeedId,
	IN	BOOL			Enable,
	IN	BOOL			Refill,
	IN	FILETIME		RefillTime 
	)
{

    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprEnableFeed(
                                    ServerName,
									InstanceId,
                                    FeedId,
									Enable,
									Refill,
									RefillTime
                                    );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
}

NET_API_STATUS
NET_API_FUNCTION
NntpGetFeedInformation(
    IN LPWSTR ServerName,
    IN DWORD  InstanceId,
    IN DWORD FeedId,
    OUT LPNNTP_FEED_INFO *Buffer
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpGetFeedInformation

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;
    LPI_FEED_INFO feedInfo;

    RpcTryExcept

        apiStatus = NntprGetFeedInformation(
                                    ServerName,
									InstanceId,
                                    FeedId,
                                    &feedInfo
                                    );

        *Buffer = (LPNNTP_FEED_INFO)feedInfo;

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpGetFeedInformation

NET_API_STATUS
NET_API_FUNCTION
NntpSetFeedInformation(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_FEED_INFO FeedInfo,
    OUT LPDWORD ParmErr OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpSetFeedInformation

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprSetFeedInformation(
                                    ServerName,
									InstanceId,
                                    (LPI_FEED_INFO)FeedInfo,
                                    ParmErr
                                    );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpSetFeedInformation

NET_API_STATUS
NET_API_FUNCTION
NntpAddFeed(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTP_FEED_INFO FeedInfo,
    OUT LPDWORD ParmErr OPTIONAL,
	OUT LPDWORD pdwFeedId
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpAddFeed

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprAddFeed(
                            ServerName,
							InstanceId,
                            (LPI_FEED_INFO)FeedInfo,
                            ParmErr,
							pdwFeedId
                            );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpAddFeed

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteFeed(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN DWORD FeedId
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpDeleteFeed

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprDeleteFeed(
                            ServerName,
							InstanceId,
                            FeedId
                            );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpAddFeed

NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateSessions (
    IN  LPWSTR ServerName,
    IN	DWORD  InstanceId,
    OUT LPDWORD EntriesRead,
    OUT LPNNTP_SESSION_INFO *Buffer
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpEnumerateSessions

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;
    NNTP_SESS_ENUM_STRUCT EnumStruct;

    RpcTryExcept

        apiStatus = NntprEnumerateSessions(
                                ServerName,
								InstanceId,
                                &EnumStruct
                                );

        *EntriesRead = EnumStruct.EntriesRead;
        *Buffer = (LPNNTP_SESSION_INFO)EnumStruct.Buffer;

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpEnumerateSessions

NET_API_STATUS
NET_API_FUNCTION
NntpTerminateSession (
    IN  LPWSTR ServerName,
    IN	DWORD  InstanceId,
    IN  LPSTR UserName,
    IN  LPSTR IPAddress
    )

/*++

Routine Description:

    This is the DLL entrypoint for NntpTerminateSession

Arguments:

Return Value:

--*/

{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprTerminateSession(
                                ServerName,
								InstanceId,
                                UserName,
                                IPAddress
                                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpTerminateSession



NET_API_STATUS
NET_API_FUNCTION
NntpEnumerateExpires(
	IN	NNTP_HANDLE		ServerName,
    IN	DWORD			InstanceId,
	OUT	LPDWORD			EntriesRead,
	OUT	LPNNTP_EXPIRE_INFO*	Buffer 
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpEnumerateExpires

Arguments : 

Return Value : 


--*/
{
    NET_API_STATUS apiStatus;
    NNTP_EXPIRE_ENUM_STRUCT	EnumStruct ;

	ZeroMemory( &EnumStruct, sizeof( EnumStruct ) ) ;

    RpcTryExcept

        apiStatus = NntprEnumerateExpires(
                                ServerName,
								InstanceId,
                                &EnumStruct
                                );

        *EntriesRead = EnumStruct.EntriesRead;
        *Buffer = (LPNNTP_EXPIRE_INFO)EnumStruct.Buffer;

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);


}	// NntpEnumerateExpires

NET_API_STATUS
NET_API_FUNCTION
NntpAddExpire(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	LPNNTP_EXPIRE_INFO	ExpireInfo,
	OUT	LPDWORD				ParmErr	OPTIONAL,
	OUT LPDWORD				pdwExpireId
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpAddExpire

Arguments : 

Return Value : 


--*/
{
	NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprAddExpire(
                            ServerName,
							InstanceId,
                            (LPI_EXPIRE_INFO)ExpireInfo,
                            ParmErr,
							pdwExpireId
                            );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
}	// NntpAddExpire

NET_API_STATUS
NET_API_FUNCTION
NntpDeleteExpire(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	DWORD				ExpireId 
	)	
/*++

Routine Description : 

	This is the DLL entrypoint for NntpDeleteExpire

Arguments : 

Return Value : 


--*/

{
	NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprDeleteExpire(
                            ServerName,
							InstanceId,
                            ExpireId
                            );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
}	// NntpDeleteExpire

NET_API_STATUS
NET_API_FUNCTION
NntpGetExpireInformation(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	DWORD				ExpireId,
	OUT	LPNNTP_EXPIRE_INFO	*Buffer
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpGetExpireInformation

Arguments : 

Return Value : 


--*/

{

	NET_API_STATUS apiStatus;
    LPI_EXPIRE_INFO	ExpireInfo;
    NNTP_EXPIRE_ENUM_STRUCT	EnumStruct ;

	ZeroMemory( &EnumStruct, sizeof( EnumStruct ) ) ;


    RpcTryExcept

/*
        apiStatus = NntprGetExpireInformation(
                                    ServerName,
                                    ExpireId,
                                    &ExpireInfo
                                    );

        *Buffer = (LPNNTP_EXPIRE_INFO)ExpireInfo;
*/

        apiStatus = NntprGetExpireInformation(
                                ServerName,
								InstanceId,
								ExpireId,
                                &EnumStruct
                                );

        if( EnumStruct.EntriesRead > 0 ) {
			*Buffer = (LPNNTP_EXPIRE_INFO)EnumStruct.Buffer;
		}	else	{
			*Buffer = 0 ;
		}

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
	

}	//	NntpGetExpireInformation

NET_API_STATUS
NET_API_FUNCTION
NntpSetExpireInformation(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN	LPNNTP_EXPIRE_INFO	ExpireInfo,
	OUT	LPDWORD				ParmErr	OPTIONAL
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpSetExpireInformation

Arguments : 

Return Value : 


--*/
{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprSetExpireInformation(
                                    ServerName,
									InstanceId,
                                    (LPI_EXPIRE_INFO)ExpireInfo,
                                    ParmErr
                                    );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}	// NntpSetExpireInformation


NET_API_STATUS
NET_API_FUNCTION
NntpGetNewsgroup(
	IN	NNTP_HANDLE			ServerName	OPTIONAL,
    IN	DWORD				InstanceId,
	IN OUT	LPNNTP_NEWSGROUP_INFO	*NewsgroupInfo
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpGetExpireInformation

Arguments : 

Return Value : 


--*/

{

	NET_API_STATUS apiStatus;

    RpcTryExcept


        apiStatus = NntprGetNewsgroup(
                                ServerName,
								InstanceId,
								(LPI_NEWSGROUP_INFO*)NewsgroupInfo
                                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
	

}	//	NntpGetNewsgroup

NET_API_STATUS
NET_API_FUNCTION
NntpSetNewsgroup(
	IN	NNTP_HANDLE				ServerName	OPTIONAL,
    IN	DWORD					InstanceId,
	IN	LPNNTP_NEWSGROUP_INFO	NewsgroupInfo
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpGetExpireInformation

Arguments : 

Return Value : 


--*/

{

	NET_API_STATUS apiStatus;

    RpcTryExcept


        apiStatus = NntprSetNewsgroup(
                                ServerName,
								InstanceId,
								(LPI_NEWSGROUP_INFO)NewsgroupInfo
                                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
	

}	//	NntpSetNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntpCreateNewsgroup(
	IN	NNTP_HANDLE				ServerName	OPTIONAL,
    IN	DWORD					InstanceId,
	IN	LPNNTP_NEWSGROUP_INFO	NewsgroupInfo
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpSetExpireInformation

Arguments : 

Return Value : 


--*/
{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprCreateNewsgroup(
                                ServerName,
								InstanceId,
								(LPI_NEWSGROUP_INFO)NewsgroupInfo
                                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}	// NntpCreateNewsgroup


NET_API_STATUS
NET_API_FUNCTION
NntpDeleteNewsgroup(
	IN	NNTP_HANDLE				ServerName	OPTIONAL,
    IN DWORD					InstanceId,
	IN	LPNNTP_NEWSGROUP_INFO	NewsgroupInfo
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpSetExpireInformation

Arguments : 

Return Value : 


--*/
{
    NET_API_STATUS apiStatus;

    RpcTryExcept

        apiStatus = NntprDeleteNewsgroup(
                                ServerName,
								InstanceId,
								(LPI_NEWSGROUP_INFO)NewsgroupInfo
                                );



    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}	// NntpDeleteNewsgroup

NET_API_STATUS
NET_API_FUNCTION
NntpFindNewsgroup(
	IN	NNTP_HANDLE			ServerName,
    IN	DWORD				InstanceId,
	IN	NNTP_HANDLE			NewsgroupPrefix,
	IN	DWORD				MaxResults,
	OUT	LPDWORD				pdwResultsFound,
	OUT LPNNTP_FIND_LIST    *ppFindList
	) 
/*++

Routine Description : 

	This is the DLL entrypoint for NntpFindNewsgroup

Arguments : 

Return Value : 


--*/

{
	NET_API_STATUS apiStatus;

	*ppFindList = NULL;

    RpcTryExcept


        apiStatus = NntprFindNewsgroup(
                                ServerName,
								InstanceId,
								NewsgroupPrefix,
								MaxResults,
								pdwResultsFound,
								ppFindList
                                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

}	//	NntpFindNewsgroup

NET_API_STATUS
NET_API_FUNCTION
NntpStartRebuild(
    IN LPWSTR pszServer OPTIONAL,
    IN DWORD  InstanceId,
    IN LPNNTPBLD_INFO pBuildInfo,
    OUT LPDWORD pParmError OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpStartRebuild

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

    pConfig -- A pointer to the config info structure used to set
        the rebuild information.

    pParmError - If ERROR_INVALID_PARAMETER is returned, will point to the
        offending parameter.

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprStartRebuild(
                pszServer,
				InstanceId,
                (LPI_NNTPBLD_INFO)pBuildInfo,
                pParmError
                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpStartRebuild

NET_API_STATUS
NET_API_FUNCTION
NntpGetBuildStatus(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
	IN BOOL   fCancel,
    OUT LPDWORD pdwProgress
    )
/*++

Routine Description:

    This is the DLL entrypoint for NntpGetBuildStatus

Arguments:

    servername --A pointer to an ASCIIZ string containing the name of
        the remote server on which the function is to execute. A NULL
        pointer or string specifies the local machine.

	fCancel		-- If TRUE, cancel the rebuild
	pdwProgress -- pointer to progress number

Return Value:

--*/

{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprGetBuildStatus(
							ServerName,
							InstanceId,
							fCancel,
							pdwProgress
							);

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} // NntpGetBuildStatus

#if 0
NET_API_STATUS
NET_API_FUNCTION
NntpAddDropNewsgroup(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR  szNewsgroup
    )
{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprAddDropNewsgroup(
                ServerName,
				InstanceId,
                szNewsgroup
                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} 

NET_API_STATUS
NET_API_FUNCTION
NntpRemoveDropNewsgroup(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR  szNewsgroup
    )
{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprRemoveDropNewsgroup(
                ServerName,
				InstanceId,
                szNewsgroup
                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} 
#endif

NET_API_STATUS
NET_API_FUNCTION
NntpCancelMessageID(
    IN LPWSTR ServerName OPTIONAL,
    IN DWORD  InstanceId,
    IN LPCSTR  szMessageID
    )
{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprCancelMessageID(
                ServerName,
				InstanceId,
                szMessageID
                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);

} 

NET_API_STATUS
NET_API_FUNCTION
NntpGetVRootWin32Error(
    IN LPWSTR   wszServername,
    IN DWORD    InstanceId,
    IN LPWSTR   wszVRootPath,
    OUT LPDWORD  pdwWin32Error
     )
{
    NET_API_STATUS              apiStatus;

    RpcTryExcept

       apiStatus = NntprGetVRootWin32Error(
                wszServername,
				InstanceId,
                wszVRootPath,
                pdwWin32Error
                );

    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        apiStatus = RpcExceptionCode( );
    RpcEndExcept

    return(apiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpapi\rpcutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      rpcutil.c

   Abstract:

      This module defines functions that may help to replace the rpc util
        functions from rpcutil.lib

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Sept-1995

   Environment:
       Win32 User Mode

   Project:

       Common Code for Internet Services

   Functions Exported:

        MIDL_user_allocate()
        MIDL_user_free()
        RpcBindHandleForServer()
        RpcBindHandleFree()

   Revision History:

        Murali R. Krishnan (MuraliK) 21-Dec-1995  Support TcpIp binding & free.
        Murali R. Krishnan (MuraliK) 20-Feb-1996  Support Lpc binding & free.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <rpc.h>

# include "apiutil.h"

# if DBG

# include <stdio.h>
# include <stdlib.h>

# define DBGPRINTF(s)       { CHAR rgchBuff[1024]; \
                              sprintf s ; \
                              OutputDebugStringA( rgchBuff); \
                            }
# define DBG_CONTEXT        ( rgchBuff)


# else // DBG


# define DBGPRINTF(s)     /* nothing */
# define DBG_CONTEXT      /* nothing */

# endif // DBG

#define ISRPC_CLIENT_OVER_TCPIP          0x00000001
#define ISRPC_CLIENT_OVER_NP             0x00000002
#define ISRPC_CLIENT_OVER_SPX            0x00000004
#define ISRPC_CLIENT_OVER_LPC            0x00000008

// # define MAX_COMPUTERNAME_LENGTH    (255)


/************************************************************
 *    Functions
 ************************************************************/


PVOID
MIDL_user_allocate(IN size_t size)
/*++

Routine Description:

    MIDL memory allocation.

Arguments:

    size : Memory size requested.

Return Value:

    Pointer to the allocated memory block.

--*/
{
    PVOID pvBlob;

    pvBlob = LocalAlloc( LPTR, size);

    return( pvBlob );

} // MIDL_user_allocate()




VOID
MIDL_user_free(IN PVOID pvBlob)
/*++

Routine Description:

    MIDL memory free .

Arguments:

    pvBlob : Pointer to a memory block that is freed.


Return Value:

    None.

--*/
{
    LocalFree( pvBlob);

    return;
}  // MIDL_user_free()




RPC_STATUS
RpcBindHandleOverNamedPipe( OUT handle_t * pBindingHandle,
                           IN LPWSTR      pwszServerName,
                           IN LPWSTR      pwszEndpoint,
                           IN LPWSTR      pwszOptions
                          )
/*++
  This function uses the parameters supplied and generates a named pipe
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszEndpoint     pointer to string containing the Named Pipe Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncacn_np",  // prot seq: named pipe
                                         pwszServerName, // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverNamedPipe()

RPC_STATUS
RpcBindHandleOverLpc( OUT handle_t * pBindingHandle,
                      IN LPWSTR      pwszEndpoint,
                      IN LPWSTR      pwszOptions
                     )
/*++
  This function uses the parameters supplied and generates a lpc
   binding handle for RPC.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszEndpoint     pointer to string containing the lpc Endpoint
   pwszOptions      pointer to string containing any additional options for
                       binding.


  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,            // ObjUuid
                                         L"ncalrpc",   // prot seq: lpc
                                         NULL,         // NetworkAddr
                                         pwszEndpoint, // Endpoint
                                         pwszOptions,  // Options
                                         &pwszBinding);    // StringBinding

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );
    }


    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {
        RpcStringFreeW(&pwszBinding);
    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            RpcBindingFree(*pBindingHandle);
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverLpc()




#ifndef CHICAGO

//
// If changes are made to the NT version, check out the windows 95
// version located right after this routine and see if the change
// needs to be propagated there too.
//

RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    NT Version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPWSTR     pwszBinding = NULL;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingComposeW(0,               // ObjUuid
                                         L"ncacn_ip_tcp", // tcpip seq
                                         pwszServerName,  // NetworkAddr
                                         NULL,            // Endpoint
                                         L"",             // Options
                                         &pwszBinding);   // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingComposeW(%S, %S) return %S."
                " Error = %ld\n",
                L"ncacn_ip_tcp",
                pwszServerName,
                pwszBinding,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBindingW(pwszBinding,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBindingW(%S) return %d."
                    "Binding=%p\n",
                    pwszBinding,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfoW(*pBindingHandle,
                                 pwszInterfaceName,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,                // AuthnIdentity
                                 0                    // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%S(Interface=%S), %p)"
                    " return %d.\n",
                    pwszBinding,
                    pwszInterfaceName,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pwszBinding != NULL) {

        DWORD rpcStatus1 = RpcStringFreeW(&pwszBinding);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()

#else // CHICAGO



RPC_STATUS
RpcBindHandleOverTcpIp( OUT handle_t * pBindingHandle,
                       IN LPWSTR       pwszServerName,
                       IN LPWSTR       pwszInterfaceName
                       )
/*++

    Windows 95 version

  This function uses the parameters supplied and generates a dynamic end point
     binding handle for RPC over TCP/IP.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus;
    LPSTR     pszBindingA = NULL;
    CHAR    szServerA[MAX_PATH];
    CHAR    szInterfaceA[MAX_PATH];
    int        cch;

    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

    *szServerA = '0';

    if (pwszServerName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszServerName,
                              -1,
                              szServerA,
                              sizeof(szServerA)/sizeof(CHAR),
                              NULL,NULL
                              );

    *szInterfaceA = '0';

    if(pwszInterfaceName)
    cch = WideCharToMultiByte(CP_ACP,
                              0,
                              pwszInterfaceName,
                              -1,
                              szInterfaceA,
                              sizeof(szInterfaceA)/sizeof(CHAR),
                              NULL,NULL
                              );


    //
    // Compose the binding string for named pipe binding
    //

    rpcStatus = RpcStringBindingCompose(0,            // ObjUuid
                                         "ncacn_ip_tcp", // tcpip seq
                                         szServerA, // NetworkAddr
                                         NULL, // Endpoint
                                         NULL, //L"",  // Options
                                         &pszBindingA);    // StringBinding

    DBGPRINTF( (DBG_CONTEXT, "\nRpcStringBindingCompose(%s, %s) return %s."
                " Error = %ld\n",
                "ncacn_ip_tcp",
                szServerA,
                pszBindingA,
                rpcStatus)
              );

    if ( rpcStatus == RPC_S_OK ) {

        //
        // establish the binding handle using string binding.
        //

        rpcStatus = RpcBindingFromStringBinding(pszBindingA,
                                                 pBindingHandle );

        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingFromStringBinding(%s) return %d."
                    "Binding=%08x\n",
                    pszBindingA,
                    rpcStatus,
                    *pBindingHandle)
                  );
    }

    if ( rpcStatus == RPC_S_OK) {

        //
        // set up the security information
        //

        rpcStatus =
          RpcBindingSetAuthInfo(*pBindingHandle,
                                 szInterfaceA,   // pszPrincipalName
                                 RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_AUTHN_WINNT,
                                 NULL,  // AuthnIdentity
                                 0      // AuthzSvc
                                 );
        DBGPRINTF( (DBG_CONTEXT,
                    "RpcBindingSetAuthInfo(%s(Interface=%s), %08x)"
                    " return %d.\n",
                    pszBindingA,
                    szInterfaceA,
                    *pBindingHandle,
                    rpcStatus
                    )
                  );

    }

    //
    // Cleanup and return back.
    //

    if ( pszBindingA != NULL) {

        DWORD rpcStatus1 = RpcStringFree(&pszBindingA);
        DBGPRINTF( (DBG_CONTEXT, "RpcStringFreeW() returns %d.",
                    rpcStatus1)
                  );

    }

    if ( rpcStatus != RPC_S_OK) {

        if ( pBindingHandle != NULL && *pBindingHandle != NULL) {

            // RPC should have freed the binding handle.
            // We will free it now.
            DWORD rpcStatus1 = RpcBindingFree(*pBindingHandle);
            DBGPRINTF( (DBG_CONTEXT, "RpcBindingFree() returns %d.\n",
                        rpcStatus1)
                      );
            *pBindingHandle = NULL;
        }
    }

    return (rpcStatus);

} // RpcBindHandleOverTcpIp()
#endif



#ifndef CHICAGO
DWORD
RpcuFindProtocolToUse( IN LPCWSTR pwszServerName)
/*++
  Given the server name this funciton determines the protocol
  to use for RPC binding.

  The transport used is determined dynamically based on following rules.

  If server name is NULL or 127.0.0.1 or same as local computer name
      then use the LPC.

  If server name starts with a leading "\\" (double slash),
      then attempt RPC binding over NamedPipe.

  If server name does not start with leading "\\",
      then attempt RPC binding over TCPIP.

  If TCPIP binding fails, then this function tries binding over NamedPipe.


  Argument:
    pwszServerName - pointer to string containing the name of the server


  Returns:
    DWORD containing the type of protocol to use.

--*/
{
    static WCHAR g_wchLocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1];
    BOOL   fLeadingSlashes;
    DWORD  dwBindProtocol = ISRPC_CLIENT_OVER_NP;
    BOOL   fLocalMachine;

    if ( pwszServerName == NULL ||
         _wcsicmp( L"127.0.0.1", pwszServerName) == 0) {


        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( g_wchLocalMachineName[0] == L'\0') {

        DWORD cchComputerNameLen = MAX_COMPUTERNAME_LENGTH;

        //
        // Obtain the local computer name
        //

        if (!GetComputerNameW( g_wchLocalMachineName,
                              &cchComputerNameLen)
            ) {

            *g_wchLocalMachineName = L'\0';
        }
    }

    fLeadingSlashes = ((*pwszServerName == L'\\') &&
                       (*(pwszServerName+1) == L'\\')
                       );


    //
    // Check to see if machine name matches local computer name
    //  if so, use LPC
    //

    fLocalMachine = !_wcsicmp( g_wchLocalMachineName,
                              ((fLeadingSlashes) ?
                               (pwszServerName + 2) : pwszServerName)
                              );

    if ( fLocalMachine) {

        return (ISRPC_CLIENT_OVER_LPC);
    }

    if ( !fLeadingSlashes) {

        DWORD  nDots;
        LPCWSTR pszName;

        //
        // Check if the name has dotted decimal name.
        // If so then suggest TCP binding.
        //

        for( nDots = 0, pszName = pwszServerName;
            ((pszName = wcschr( pszName, L'.' )) != NULL);
            nDots++, pszName++)
          ;

        if ( nDots == 3) {

            //
            // if the string has 3 DOTs exactly then this string must represent
            // an IpAddress.
            //

            return(ISRPC_CLIENT_OVER_TCPIP);
        }
    }


    return ( ISRPC_CLIENT_OVER_NP);
} // RpcuFindProtocolToUse()
#endif



RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       )
/*++
  This function uses the parameters supplied and generates a binding
    handle for RPC.


  It is assumed that binding over named pipe uses static end point
      with the interface name and options as provided.

  Arguments:
   pBindingHandle   pointer to location which will contain binding handle
                       on successful return
   pwszServerName   pointer to string containing the name of the server
                       to which, this function will obtain a binding.
   pwszInterfaceName pointer to string containing the interface name
   pwszOptions      pointer to string containing any additional options for
                       binding.

  Returns:
   RPC_STATUS  - RPC_S_OK  on success
   Also on success, the binding handle is stored in pBindingHandle.
   It should freed after usage, using the RpcBindingFree() function.

--*/
{
    RPC_STATUS rpcStatus = RPC_S_SERVER_UNAVAILABLE;
    LPWSTR     pwszBinding = NULL;
    DWORD      dwBindProtocol = 0;


    if ( pBindingHandle != NULL) {

        *pBindingHandle = NULL;   // init the value
    }

#ifndef CHICAGO
    dwBindProtocol = RpcuFindProtocolToUse( pwszServerName);
#else
    dwBindProtocol = ISRPC_CLIENT_OVER_TCPIP;
#endif

    switch ( dwBindProtocol) {

      case ISRPC_CLIENT_OVER_LPC:
        {

            WCHAR  rgchLpc[1024];

            //
            // generate a LPC end point name from the interface name.
            //  the End point =   <InterfaceName>_LPC
            //

            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchLpc)/sizeof(WCHAR) - 6)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcpyW( rgchLpc, pwszInterfaceName);
            lstrcatW( rgchLpc, L"_LPC");

            //
            // Attempt binding over static LPC.
            //

            rpcStatus = RpcBindHandleOverLpc( pBindingHandle,
                                             rgchLpc,
                                             pwszOptions
                                             );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverLpc(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));

            break;
        }

      case ISRPC_CLIENT_OVER_TCPIP:

// # ifdef RPC_BIND_OVER_TCP

        //
        // Attempt binding over TCPIP using Dynamic Endpoint.
        //

        rpcStatus = RpcBindHandleOverTcpIp( pBindingHandle,
                                           pwszServerName,
                                           pwszInterfaceName);

        DBGPRINTF(( DBG_CONTEXT,
                   " RpcBindingOverTcpIp(%S) returns %d. Handle = %p\n",
                   pwszServerName, rpcStatus, *pBindingHandle));

        if ( rpcStatus == RPC_S_OK) {

            break;  // done with RPC binding over TCP
        }

        // Fall Through

// # endif // RPC_BIND_OVER_TCP

      case ISRPC_CLIENT_OVER_NP:
        {
            WCHAR  rgchNp[1024];

            //
            // generate a NamedPipe end point name from the interface name.
            //  the End point =   \PIPE\<InterfaceName>
            //

            lstrcpyW( rgchNp, L"\\PIPE\\");
            if ( lstrlenW( pwszInterfaceName) >=
                ( sizeof(rgchNp)/sizeof(WCHAR) - 10)) {

                SetLastError( ERROR_INVALID_PARAMETER);
                return ( ERROR_INVALID_PARAMETER);
            }

            lstrcatW( rgchNp, pwszInterfaceName);

            //
            // Attempt binding over static NamedPipe.
            //

            rpcStatus = RpcBindHandleOverNamedPipe( pBindingHandle,
                                                   pwszServerName,
                                                   rgchNp,
                                                   pwszOptions
                                                   );

            DBGPRINTF(( DBG_CONTEXT,
                       " RpcBindingOverNamedPipe(%S) returns %d."
                       " Handle = %p\n",
                       pwszServerName, rpcStatus, *pBindingHandle));
            break;
        }

      default:
        break;

    } // switch()

    return ( rpcStatus);

} // RpcBindHandleForServer()





RPC_STATUS
RpcBindHandleFree(IN OUT handle_t * pBindingHandle)
/*++

  Description:

    This function frees up the binding handle allocated using
      RpcBindHandleForServer(). It uses RPC Binding Free routing to do this.
    This function acts just as a thunk so that the alloc/free of RPC contexts
      are consolidated within this module.

  Arguments:
    pBindingHandle  pointer to RPC binding handle that needs to be freed.


  Returns:
    RPC_STATUS - containig the RPC status. RPC_S_OK for success.

--*/
{

    return ( RpcBindingFree( pBindingHandle));

} // RpcBindHandleFree()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpctrs\nntpdata.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nntpdata.c

    Constant data structures for the NNTP Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#include <windows.h>
#include <winperf.h>
#include <nntpctrs.h>
#include <nntpdata.h>

static NNTP_COUNTER_BLOCK1	nntpc1;
static NNTP_COUNTER_BLOCK2	nntpc2;

//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

NNTP_DATA_DEFINITION_OBJECT1 NntpDataDefinitionObject1 =
{
    {   // NntpObjectType
        sizeof(NNTP_DATA_DEFINITION_OBJECT1) + sizeof(NNTP_COUNTER_BLOCK1),
        sizeof(NNTP_DATA_DEFINITION_OBJECT1),
        sizeof(PERF_OBJECT_TYPE),
        NNTP_COUNTER_OBJECT1,
        0,
        NNTP_COUNTER_OBJECT1,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_NNTP_COUNTERS_OBJECT1,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // NntpBytesSent
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_BYTES_SENT_COUNTER,
        0,
        NNTP_BYTES_SENT_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(nntpc1.BytesSent),
        0 // assigned in open procedure
    },

    {   // NNTPBytesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_BYTES_RECEIVED_COUNTER,
        0,
        NNTP_BYTES_RECEIVED_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(nntpc1.BytesReceived),
        0 // assigned in open procedure
    },

    {   // NNTPBytesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_BYTES_TOTAL_COUNTER,
        0,
        NNTP_BYTES_TOTAL_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(nntpc1.BytesTotal),
        0 // assigned in open procedure
    },

    {   // NntpTotalConnections
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_CONNECTIONS_COUNTER,
        0,
        NNTP_TOTAL_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalConnections),
        0 // assigned in open procedure
    },

    {   // NntpTotalSSLConnections
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_SSL_CONNECTIONS_COUNTER,
        0,
        NNTP_TOTAL_SSL_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalSSLConnections),
        0 // assigned in open procedure
    },

    {   // NntpCurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CURRENT_CONNECTIONS_COUNTER,
        0,
        NNTP_CURRENT_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.CurrentConnections),
        0 // assigned in open procedure
    },

    {   // NntpMaxConnections
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MAX_CONNECTIONS_COUNTER,
        0,
        NNTP_MAX_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.MaxConnections),
        0 // assigned in open procedure
    },

    {   // NntpCurrentAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CURRENT_ANONYMOUS_COUNTER,
        0,
        NNTP_CURRENT_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.CurrentAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpCurrentNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CURRENT_NONANONYMOUS_COUNTER,
        0,
        NNTP_CURRENT_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.CurrentNonAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpTotalAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_ANONYMOUS_COUNTER,
        0,
        NNTP_TOTAL_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpTotalNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_NONANONYMOUS_COUNTER,
        0,
        NNTP_TOTAL_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalNonAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpMaxAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MAX_ANONYMOUS_COUNTER,
        0,
        NNTP_MAX_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.MaxAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpMaxNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MAX_NONANONYMOUS_COUNTER,
        0,
        NNTP_MAX_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.MaxNonAnonymous),
        0 // assigned in open procedure
    },

    {   // NntpTotalOutboundConnects
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_OUTBOUND_CONNECTS_COUNTER,
        0,
        NNTP_TOTAL_OUTBOUND_CONNECTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalOutboundConnects),
        0 // assigned in open procedure
    },

    {   // NntpOutboundConnectsFailed
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_OUTBOUND_CONNECTS_FAILED_COUNTER,
        0,
        NNTP_OUTBOUND_CONNECTS_FAILED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.OutboundConnectsFailed),
        0 // assigned in open procedure
    },

    {   // NntpCurrentOutboundConnects
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CURRENT_OUTBOUND_CONNECTS_COUNTER,
        0,
        NNTP_CURRENT_OUTBOUND_CONNECTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.CurrentOutboundConnects),
        0 // assigned in open procedure
    },

    {   // NntpOutboundLogonFailed
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_OUTBOUND_LOGON_FAILED_COUNTER,
        0,
        NNTP_OUTBOUND_LOGON_FAILED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.OutboundLogonFailed),
        0 // assigned in open procedure
    },

    {   // NNTPPullFeeds
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_PULL_FEEDS_COUNTER,
        0,
        NNTP_TOTAL_PULL_FEEDS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalPullFeeds),
        0 // assigned in open procedure
    },

    {   // NNTPPushFeeds
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_PUSH_FEEDS_COUNTER,
        0,
        NNTP_TOTAL_PUSH_FEEDS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalPushFeeds),
        0 // assigned in open procedure
    },

    {   // NNTPPassiveFeeds
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_TOTAL_PASSIVE_FEEDS_COUNTER,
        0,
        NNTP_TOTAL_PASSIVE_FEEDS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.TotalPassiveFeeds),
        0 // assigned in open procedure
    },

    {   // NntpArticlesSent
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_SENT_COUNTER,
        0,
        NNTP_ARTICLES_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesSent),
        0 // assigned in open procedure
    },

    {   // NntpArticlesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_RECEIVED_COUNTER,
        0,
        NNTP_ARTICLES_RECEIVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesReceived),
        0 // assigned in open procedure
    },

    {   // NntpArticlesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_TOTAL_COUNTER,
        0,
        NNTP_ARTICLES_TOTAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesTotal),
        0 // assigned in open procedure
    },

    {   // ArticlesPosted
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_POSTED_COUNTER,
        0,
        NNTP_ARTICLES_POSTED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesPosted),
        0 // assigned in open procedure
    },

    {   // ArticleMapEntries
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLE_MAP_ENTRIES_COUNTER,
        0,
        NNTP_ARTICLE_MAP_ENTRIES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticleMapEntries),
        0 // assigned in open procedure
    },

    {   // HistoryMapEntries
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_HISTORY_MAP_ENTRIES_COUNTER,
        0,
        NNTP_HISTORY_MAP_ENTRIES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.HistoryMapEntries),
        0 // assigned in open procedure
    },

    {   // XoverEntries
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_XOVER_ENTRIES_COUNTER,
        0,
        NNTP_XOVER_ENTRIES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.XoverEntries),
        0 // assigned in open procedure
    },

	{   // ControlMessagesIn
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CONTROL_MSGS_IN_COUNTER,
        0,
        NNTP_CONTROL_MSGS_IN_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ControlMessagesIn),
        0 // assigned in open procedure
    },

    {   // ControlMessagesFailed
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CONTROL_MSGS_FAILED_COUNTER,
        0,
        NNTP_CONTROL_MSGS_FAILED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ControlMessagesFailed),
        0 // assigned in open procedure
    },

    {   // ModeratedPostingsSent
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MODERATED_POSTINGS_SENT_COUNTER,
        0,
        NNTP_MODERATED_POSTINGS_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ModeratedPostingsSent),
        0 // assigned in open procedure
    },

	{   // ModeratedPostingsFailed
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_MODERATED_POSTINGS_FAILED_COUNTER,
        0,
        NNTP_MODERATED_POSTINGS_FAILED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ModeratedPostingsFailed),
        0 // assigned in open procedure
    },

    {   // SessionsFlowControlled
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_SESS_FLOW_CONTROL_COUNTER,
        0,
        NNTP_SESS_FLOW_CONTROL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.SessionsFlowControlled),
        0 // assigned in open procedure
    },

    {   // ArticlesExpired
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_EXPIRED_COUNTER,
        0,
        NNTP_ARTICLES_EXPIRED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc1.ArticlesExpired),
        0 // assigned in open procedure
    },

    {   // NntpArticlesSentPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_SENT_PERSEC_COUNTER,
        0,
        NNTP_ARTICLES_SENT_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticlesSentPerSec),
        0 // assigned in open procedure
    },

    {   // NntpArticlesReceivedPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_RECEIVED_PERSEC_COUNTER,
        0,
        NNTP_ARTICLES_RECEIVED_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticlesReceivedPerSec),
        0 // assigned in open procedure
    },

    {   // ArticlesPostedPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_POSTED_PERSEC_COUNTER,
        0,
        NNTP_ARTICLES_POSTED_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticlesPostedPerSec),
        0 // assigned in open procedure
    },

    {   // ArticleMapEntriesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLE_MAP_ENTRIES_PERSEC_COUNTER,
        0,
        NNTP_ARTICLE_MAP_ENTRIES_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticleMapEntriesPerSec),
        0 // assigned in open procedure
    },

    {   // HistoryMapEntriesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_HISTORY_MAP_ENTRIES_PERSEC_COUNTER,
        0,
        NNTP_HISTORY_MAP_ENTRIES_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.HistoryMapEntriesPerSec),
        0 // assigned in open procedure
    },

    {   // XoverEntriesPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_XOVER_ENTRIES_PERSEC_COUNTER,
        0,
        NNTP_XOVER_ENTRIES_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.XoverEntriesPerSec),
        0 // assigned in open procedure
    },

    {   // ArticlesExpiredPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_ARTICLES_EXPIRED_PERSEC_COUNTER,
        0,
        NNTP_ARTICLES_EXPIRED_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc1.ArticlesExpiredPerSec),
        0 // assigned in open procedure
    }
};


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

NNTP_DATA_DEFINITION_OBJECT2 NntpDataDefinitionObject2 =
{
    {   // NntpObjectType
        sizeof(NNTP_DATA_DEFINITION_OBJECT2) + sizeof(NNTP_COUNTER_BLOCK2),
        sizeof(NNTP_DATA_DEFINITION_OBJECT2),
        sizeof(PERF_OBJECT_TYPE),
        NNTP_COUNTER_OBJECT2,
        0,
        NNTP_COUNTER_OBJECT2,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_NNTP_COUNTERS_OBJECT2,
        2,                              // Default = GroupCommands
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // ArticleCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_ARTICLE_COUNTER,
        0,
        NNTP_CMDS_ARTICLE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.ArticleCmds),
        0 // assigned in open procedure
    },

    {   // ArticleCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_ARTICLE_COUNTER,
        0,
        NNTP_CMDS_PERSEC_ARTICLE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.ArticleCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // GroupCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_GROUP_COUNTER,
        0,
        NNTP_CMDS_GROUP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.GroupCmds),
        0 // assigned in open procedure
    },

    {   // GroupCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_GROUP_COUNTER,
        0,
        NNTP_CMDS_PERSEC_GROUP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.GroupCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // HelpCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_HELP_COUNTER,
        0,
        NNTP_CMDS_HELP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.HelpCmds),
        0 // assigned in open procedure
    },

    {   // HelpCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_HELP_COUNTER,
        0,
        NNTP_CMDS_PERSEC_HELP_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.HelpCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // IHaveCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_IHAVE_COUNTER,
        0,
        NNTP_CMDS_IHAVE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.IHaveCmds),
        0 // assigned in open procedure
    },

    {   // IHaveCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_IHAVE_COUNTER,
        0,
        NNTP_CMDS_PERSEC_IHAVE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.IHaveCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // LastCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_LAST_COUNTER,
        0,
        NNTP_CMDS_LAST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.LastCmds),
        0 // assigned in open procedure
    },

    {   // LastCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_LAST_COUNTER,
        0,
        NNTP_CMDS_PERSEC_LAST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.LastCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // ListCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_LIST_COUNTER,
        0,
        NNTP_CMDS_LIST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.ListCmds),
        0 // assigned in open procedure
    },

    {   // ListCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_LIST_COUNTER,
        0,
        NNTP_CMDS_PERSEC_LIST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.ListCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // NewgroupsCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_NEWGROUPS_COUNTER,
        0,
        NNTP_CMDS_NEWGROUPS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.NewgroupsCmds),
        0 // assigned in open procedure
    },

    {   // NewgroupsCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_NEWGROUPS_COUNTER,
        0,
        NNTP_CMDS_PERSEC_NEWGROUPS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.NewgroupsCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // NewnewsCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_NEWNEWS_COUNTER,
        0,
        NNTP_CMDS_NEWNEWS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.NewnewsCmds),
        0 // assigned in open procedure
    },

    {   // NewnewsCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_NEWNEWS_COUNTER,
        0,
        NNTP_CMDS_PERSEC_NEWNEWS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.NewnewsCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // NextCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_NEXT_COUNTER,
        0,
        NNTP_CMDS_NEXT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.NextCmds),
        0 // assigned in open procedure
    },

    {   // NextCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_NEXT_COUNTER,
        0,
        NNTP_CMDS_PERSEC_NEXT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.NextCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // PostCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_POST_COUNTER,
        0,
        NNTP_CMDS_POST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.PostCmds),
        0 // assigned in open procedure
    },

    {   // PostCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_POST_COUNTER,
        0,
        NNTP_CMDS_PERSEC_POST_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.PostCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // QuitCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_QUIT_COUNTER,
        0,
        NNTP_CMDS_QUIT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.QuitCmds),
        0 // assigned in open procedure
    },

    {   // QuitCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_QUIT_COUNTER,
        0,
        NNTP_CMDS_PERSEC_QUIT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.QuitCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // StatCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_STAT_COUNTER,
        0,
        NNTP_CMDS_STAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.StatCmds),
        0 // assigned in open procedure
    },

    {   // StatCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_STAT_COUNTER,
        0,
        NNTP_CMDS_PERSEC_STAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.StatCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // NntpLogonAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_LOGON_ATTEMPTS_COUNTER,
        0,
        NNTP_LOGON_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.LogonAttempts),
        0 // assigned in open procedure
    },

    {   // NntpLogonFailures
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_LOGON_FAILURES_COUNTER,
        0,
        NNTP_LOGON_FAILURES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.LogonFailures),
        0 // assigned in open procedure
    },

    {   // NntpLogonAttemptsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_LOGON_ATTEMPTS_PERSEC_COUNTER,
        0,
        NNTP_LOGON_ATTEMPTS_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.LogonAttemptsPerSec),
        0 // assigned in open procedure
    },

    {   // NntpLogonFailuresPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_LOGON_FAILURES_PERSEC_COUNTER,
        0,
        NNTP_LOGON_FAILURES_PERSEC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.LogonFailuresPerSec),
        0 // assigned in open procedure
    },

    {   // CheckCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_CHECK_COUNTER,
        0,
        NNTP_CMDS_CHECK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.CheckCmds),
        0 // assigned in open procedure
    },

    {   // CheckCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_CHECK_COUNTER,
        0,
        NNTP_CMDS_PERSEC_CHECK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.CheckCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // TakethisCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_TAKETHIS_COUNTER,
        0,
        NNTP_CMDS_TAKETHIS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.TakethisCmds),
        0 // assigned in open procedure
    },

    {   // TakethisCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_TAKETHIS_COUNTER,
        0,
        NNTP_CMDS_PERSEC_TAKETHIS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.TakethisCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // ModeCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_MODE_COUNTER,
        0,
        NNTP_CMDS_MODE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.ModeCmds),
        0 // assigned in open procedure
    },

    {   // ModeCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_MODE_COUNTER,
        0,
        NNTP_CMDS_PERSEC_MODE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.ModeCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // SearchCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_SEARCH_COUNTER,
        0,
        NNTP_CMDS_SEARCH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.SearchCmds),
        0 // assigned in open procedure
    },

    {   // SearchCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_SEARCH_COUNTER,
        0,
        NNTP_CMDS_PERSEC_SEARCH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.SearchCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // XHdrCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_XHDR_COUNTER,
        0,
        NNTP_CMDS_XHDR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.XHdrCmds),
        0 // assigned in open procedure
    },

    {   // XHdrCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_XHDR_COUNTER,
        0,
        NNTP_CMDS_PERSEC_XHDR_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.XHdrCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // XOverCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_XOVER_COUNTER,
        0,
        NNTP_CMDS_XOVER_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.XOverCmds),
        0 // assigned in open procedure
    },

    {   // XOverCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_XOVER_COUNTER,
        0,
        NNTP_CMDS_PERSEC_XOVER_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.XOverCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // XPatCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_XPAT_COUNTER,
        0,
        NNTP_CMDS_XPAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.XPatCmds),
        0 // assigned in open procedure
    },

    {   // XPatCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_XPAT_COUNTER,
        0,
        NNTP_CMDS_PERSEC_XPAT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.XPatCmdsPerSec),
        0 // assigned in open procedure
    },

    {   // XReplicCommands
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_XREPLIC_COUNTER,
        0,
        NNTP_CMDS_XREPLIC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(nntpc2.XReplicCmds),
        0 // assigned in open procedure
    },

    {   // XreplicCommandsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        NNTP_CMDS_PERSEC_XREPLIC_COUNTER,
        0,
        NNTP_CMDS_PERSEC_XREPLIC_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(nntpc2.XReplicCmdsPerSec),
        0 // assigned in open procedure
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpctrs\nntpdata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nntpdata.h

    Extensible object definitions for the NNTP Server's counter
    objects & counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#ifndef _NNTPDATA_H_
#define _NNTPDATA_H_

#pragma pack(8) 

//
//  The counter structure returned.
//

typedef struct _NNTP_DATA_DEFINITION_OBJECT1
{
    PERF_OBJECT_TYPE            NntpObjectType;
    PERF_COUNTER_DEFINITION     NntpBytesSent;
    PERF_COUNTER_DEFINITION     NntpBytesReceived;
    PERF_COUNTER_DEFINITION     NntpBytesTotal;

    PERF_COUNTER_DEFINITION     NntpTotalConnections;
    PERF_COUNTER_DEFINITION     NntpTotalSSLConnections;
    PERF_COUNTER_DEFINITION     NntpCurrentConnections;
    PERF_COUNTER_DEFINITION     NntpMaxConnections;

    PERF_COUNTER_DEFINITION     NntpCurrentAnonymous;
    PERF_COUNTER_DEFINITION     NntpCurrentNonAnonymous;
    PERF_COUNTER_DEFINITION     NntpTotalAnonymous;
    PERF_COUNTER_DEFINITION     NntpTotalNonAnonymous;
    PERF_COUNTER_DEFINITION     NntpMaxAnonymous;
    PERF_COUNTER_DEFINITION     NntpMaxNonAnonymous;

    PERF_COUNTER_DEFINITION     NntpTotalOutboundConnects;
    PERF_COUNTER_DEFINITION     NntpOutboundConnectsFailed;
    PERF_COUNTER_DEFINITION     NntpCurrentOutboundConnects;
    PERF_COUNTER_DEFINITION     NntpOutboundLogonFailed;

    PERF_COUNTER_DEFINITION     NntpTotalPullFeeds;
    PERF_COUNTER_DEFINITION     NntpTotalPushFeeds;
    PERF_COUNTER_DEFINITION     NntpTotalPassiveFeeds;

    PERF_COUNTER_DEFINITION     NntpArticlesSent;
    PERF_COUNTER_DEFINITION     NntpArticlesReceived;
    PERF_COUNTER_DEFINITION     NntpArticlesTotal;

    PERF_COUNTER_DEFINITION     NntpArticlesPosted;
    PERF_COUNTER_DEFINITION     NntpArticleMapEntries;
    PERF_COUNTER_DEFINITION     NntpHistoryMapEntries;
    PERF_COUNTER_DEFINITION     NntpXoverEntries;

    PERF_COUNTER_DEFINITION     NntpControlMessagesIn;
    PERF_COUNTER_DEFINITION     NntpControlMessagesFailed;
    PERF_COUNTER_DEFINITION     NntpModeratedPostingsSent;
    PERF_COUNTER_DEFINITION     NntpModeratedPostingsFailed;

    PERF_COUNTER_DEFINITION     NntpSessionsFlowControlled;

    PERF_COUNTER_DEFINITION     NntpArticlesExpired;

    PERF_COUNTER_DEFINITION     NntpArticlesSentPerSec;
    PERF_COUNTER_DEFINITION     NntpArticlesReceivedPerSec;
    PERF_COUNTER_DEFINITION     NntpArticlesPostedPerSec;
    PERF_COUNTER_DEFINITION     NntpArticleMapEntriesPerSec;
    PERF_COUNTER_DEFINITION     NntpHistoryMapEntriesPerSec;
    PERF_COUNTER_DEFINITION     NntpXoverEntriesPerSec;
    PERF_COUNTER_DEFINITION     NntpArticlesExpiredPerSec;

} NNTP_DATA_DEFINITION_OBJECT1;

typedef struct _NNTP_DATA_DEFINITION_OBJECT2
{
    PERF_OBJECT_TYPE            NntpObjectType;
    PERF_COUNTER_DEFINITION     NntpArticleCmds;
    PERF_COUNTER_DEFINITION     NntpArticleCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpGroupCmds;
    PERF_COUNTER_DEFINITION     NntpGroupCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpHelpCmds;
    PERF_COUNTER_DEFINITION     NntpHelpCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpIHaveCmds;
    PERF_COUNTER_DEFINITION     NntpIHaveCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpLastCmds;
    PERF_COUNTER_DEFINITION     NntpLastCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpListCmds;
    PERF_COUNTER_DEFINITION     NntpListCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpNewgroupsCmds;
    PERF_COUNTER_DEFINITION     NntpNewgroupsCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpNewnewsCmds;
    PERF_COUNTER_DEFINITION     NntpNewnewsCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpNextCmds;
    PERF_COUNTER_DEFINITION     NntpNextCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpPostCmds;
    PERF_COUNTER_DEFINITION     NntpPostCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpQuitCmds;
    PERF_COUNTER_DEFINITION     NntpQuitCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpStatCmds;
    PERF_COUNTER_DEFINITION     NntpStatCmdsPerSec;

    PERF_COUNTER_DEFINITION     NntpLogonAttempts;
    PERF_COUNTER_DEFINITION     NntpLogonFailures;
    PERF_COUNTER_DEFINITION     NntpLogonAttemptsPerSec;
    PERF_COUNTER_DEFINITION     NntpLogonFailuresPerSec;

    PERF_COUNTER_DEFINITION     NntpCheckCmds;
    PERF_COUNTER_DEFINITION     NntpCheckCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpTakethisCmds;
    PERF_COUNTER_DEFINITION     NntpTakethisCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpModeCmds;
    PERF_COUNTER_DEFINITION     NntpModeCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpSearchCmds;
    PERF_COUNTER_DEFINITION     NntpSearchCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpXHdrCmds;
    PERF_COUNTER_DEFINITION     NntpXHdrCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpXOverCmds;
    PERF_COUNTER_DEFINITION     NntpXOverCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpXPatCmds;
    PERF_COUNTER_DEFINITION     NntpXPatCmdsPerSec;
    PERF_COUNTER_DEFINITION     NntpXReplicCmds;
    PERF_COUNTER_DEFINITION     NntpXReplicCmdsPerSec;
    
} NNTP_DATA_DEFINITION_OBJECT2;

typedef struct _NNTP_COUNTER_BLOCK1 {
    PERF_COUNTER_BLOCK	PerfCounterBlock;
    LONGLONG			BytesSent;
    LONGLONG			BytesReceived;
    LONGLONG			BytesTotal;

    DWORD				TotalConnections;
    DWORD				TotalSSLConnections;
    DWORD				CurrentConnections;
    DWORD				MaxConnections;

    DWORD				CurrentAnonymous;
    DWORD				CurrentNonAnonymous;
    DWORD				TotalAnonymous;
    DWORD				TotalNonAnonymous;
    DWORD				MaxAnonymous;
    DWORD				MaxNonAnonymous;

    DWORD				TotalOutboundConnects;
    DWORD				OutboundConnectsFailed;
    DWORD				CurrentOutboundConnects;
    DWORD				OutboundLogonFailed;

    DWORD				TotalPullFeeds;
    DWORD				TotalPushFeeds;
    DWORD				TotalPassiveFeeds;

    DWORD				ArticlesSent;
    DWORD				ArticlesReceived;
    DWORD				ArticlesTotal;

    DWORD				ArticlesPosted;
    DWORD				ArticleMapEntries;
    DWORD				HistoryMapEntries;
    DWORD				XoverEntries;

    DWORD				ControlMessagesIn;
    DWORD				ControlMessagesFailed;
    DWORD				ModeratedPostingsSent;
    DWORD				ModeratedPostingsFailed;

    DWORD				SessionsFlowControlled;

    DWORD				ArticlesExpired;

    DWORD				ArticlesSentPerSec;
    DWORD				ArticlesReceivedPerSec;
    DWORD				ArticlesPostedPerSec;
    DWORD				ArticleMapEntriesPerSec;
    DWORD				HistoryMapEntriesPerSec;
    DWORD				XoverEntriesPerSec;
    DWORD				ArticlesExpiredPerSec;

} NNTP_COUNTER_BLOCK1, * PNNTP_COUNTER_BLOCK1;

typedef struct _NNTP_COUNTER_BLOCK2 {
    PERF_COUNTER_BLOCK	PerfCounterBlock;
    DWORD				ArticleCmds;
    DWORD				ArticleCmdsPerSec;
    DWORD				GroupCmds;
    DWORD				GroupCmdsPerSec;
    DWORD				HelpCmds;
    DWORD				HelpCmdsPerSec;
    DWORD				IHaveCmds;
    DWORD				IHaveCmdsPerSec;
    DWORD				LastCmds;
    DWORD				LastCmdsPerSec;
    DWORD				ListCmds;
    DWORD				ListCmdsPerSec;
    DWORD				NewgroupsCmds;
    DWORD				NewgroupsCmdsPerSec;
    DWORD				NewnewsCmds;
    DWORD				NewnewsCmdsPerSec;
    DWORD				NextCmds;
    DWORD				NextCmdsPerSec;
    DWORD				PostCmds;
    DWORD				PostCmdsPerSec;
    DWORD				QuitCmds;
    DWORD				QuitCmdsPerSec;
    DWORD				StatCmds;
    DWORD				StatCmdsPerSec;

    DWORD				LogonAttempts;
    DWORD				LogonFailures;
    DWORD				LogonAttemptsPerSec;
    DWORD				LogonFailuresPerSec;

    DWORD     			CheckCmds;
    DWORD     			CheckCmdsPerSec;
    DWORD     			TakethisCmds;
    DWORD     			TakethisCmdsPerSec;
    DWORD     			ModeCmds;
    DWORD     			ModeCmdsPerSec;
    DWORD     			SearchCmds;
    DWORD     			SearchCmdsPerSec;
    DWORD     			XHdrCmds;
    DWORD     			XHdrCmdsPerSec;
    DWORD     			XOverCmds;
    DWORD     			XOverCmdsPerSec;
    DWORD     			XPatCmds;
    DWORD     			XPatCmdsPerSec;
    DWORD     			XReplicCmds;
    DWORD     			XReplicCmdsPerSec;

} NNTP_COUNTER_BLOCK2, * PNNTP_COUNTER_BLOCK2;

extern  NNTP_DATA_DEFINITION_OBJECT1    NntpDataDefinitionObject1;
extern  NNTP_DATA_DEFINITION_OBJECT2    NntpDataDefinitionObject2;

#define NUMBER_OF_NNTP_COUNTERS_OBJECT1 ((sizeof(NNTP_DATA_DEFINITION_OBJECT1) -        \
										sizeof(PERF_OBJECT_TYPE)) /           \
										sizeof(PERF_COUNTER_DEFINITION))

#define NUMBER_OF_NNTP_COUNTERS_OBJECT2 ((sizeof(NNTP_DATA_DEFINITION_OBJECT2) -        \
										sizeof(PERF_OBJECT_TYPE)) /           \
										sizeof(PERF_COUNTER_DEFINITION))

//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _NNTPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpctrs\perfutil.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.h

   Abstract:

      This file supports routines used to parse and create Performance Monitor
       Data structures, used by all the Internet Services product.

   Author:

       Murali R. Krishnan    ( MuraliK )    16-Nov-1995  
         From the common code for perfmon interface (Russ Blake's).

   Environment:

      User Mode

   Project:
   
       Internet Services Common Runtime code

   Revision History:

       Sophia Chung  (sophiac)  05-Nov-1996
         Added supports for mutlitple instances.

--*/

# ifndef _PERFUTIL_H_
# define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define PVOID_MULTIPLE(x) (((x+sizeof(PVOID)-1)/sizeof(PVOID))*sizeof(PVOID))


/************************************************************
 *     Symbolic Constants
 ************************************************************/


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


/************************************************************
 *     Function Declarations
 ************************************************************/

DWORD
GetQueryType (IN LPWSTR lpwszValue);

BOOL
IsNumberInUnicodeList (IN DWORD dwNumber, IN LPWSTR lpwszUnicodeList);

VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    );

# endif // _PERFUTIL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpctrs\perfutil.c ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.c

   Abstract:

      This file implements the utility routines used for all perfmon 
       interface dlls in the internet services group.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Nov-1995  
          Pulled from  perfmon interface common code.

   Environment:
       User Mode
       
   Project:

       Internet Servies Common Runtime functions

   Functions Exported:

        DWORD GetQueryType();
        BOOL  IsNumberInUnicodeList();
        VOID  MonBuildInstanceDefinition();

   Revision History:

       Sophia Chung (sophiac)  05-Nov-1996
          Added routine to support multiple instances

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <string.h>

#include <winperf.h>
#include <perfutil.h>


/************************************************************
 *     Global Data Definitions
 ************************************************************/

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))


/************************************************************
 *    Functions 
 ************************************************************/



DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}



BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList



VOID
MonBuildInstanceDefinition(
    OUT PERF_INSTANCE_DEFINITION *pBuffer,
    OUT PVOID *pBufferNext,
    IN DWORD ParentObjectTitleIndex,
    IN DWORD ParentObjectInstance,
    IN DWORD UniqueID,
    IN LPWSTR Name
    )
/*++

MonBuildInstanceDefinition  

    Build an instance of an object

Arguments:

    OUT pBuffer         -   pointer to buffer where instance is to
                            be constructed

    OUT pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

    IN  ParentObjectTitleIndex
                        -   Title Index of parent object type; 0 if
                            no parent object

    IN  ParentObjectInstance
                        -   Index into instances of parent object
                            type, starting at 0, for this instances
                            parent object instance

    IN  UniqueID        -   a unique identifier which should be used
                            instead of the Name for identifying
                            this instance

    IN  Name            -   Name of this instance

Return Value:

    None.

--*/
{
    DWORD NameLength;
    LPWSTR pName;
    //
    //  Include trailing null in name size
    //

    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    RtlMoveMemory(pName,Name,NameLength);

#if 0
    // allign on 8 byte boundary for new NT5 requirement
    pBuffer->ByteLength = QWORD_MULTIPLE(pBuffer->ByteLength);
    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
#endif

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    // round up to put next buffer on a QUADWORD boundry
    *pBufferNext = ALIGN_ON_QWORD (*pBufferNext);
    // adjust length value to match new length
    pBuffer->ByteLength = (ULONG)((ULONG_PTR)*pBufferNext - (ULONG_PTR)pBuffer);

    return;
}



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

//#define APP_NAME  "vgactrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpmib\main.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    main.c

Abstract:

    SNMP Extension Agent for nntp Service on Windows NT.

Created:

  MuraliK   22-Feb-1995

Revision History:

--*/

#include "mib.h"
#include <excpt.h>
#include "nntptype.h"
#include "nntpapi.h"
//#include <rpcutil.h>

/************************************************************
 *   Variable Definitions
 ************************************************************/

//
// Definition of the MIB objects
//

//
//  The InternetServer section of the OID tree is organized as follows:
//
//      iso(1)
//          org(3)
//              dod(6)
//                  internet(1)
//                      private(4)
//                          enterprises(1)
//                              microsoft(311)
//                                  software(1)
//                                      InternetServer(7)
//                                          InetSrvCommon(1)
//                                              InetSrvStatistics(1)
//                                          FtpServer(2)
//                                              FtpStatistics(1)
//                                          HttpServer(3)
//                                              HttpStatistics(1)
//                                          GopherServer(4)
//                                              GopherStatistics(1)
//                                          MnsServer(5)
//                                              MsnStatistics(1)
//                                          NntpServer(6)
//                                              NntpStatistics(1)
//

static UINT   sg_rguiPrefix[] =  { 1, 3, 6, 1, 4, 1, 311, 1, 7, 6};
static AsnObjectIdentifier sg_MibOidPrefix =
                      OID_FROM_UINT_ARRAY( sg_rguiPrefix);

# define NNTP_PREFIX_OID_LENGTH    ( GET_OID_LENGTH( sg_MibOidPrefix))
# define NNTP_STATISTICS_OID_SUFFIX            ( 1)


//
// Following is the global description of all MIB Entries ( Mibe s) for
//   Nntp Service.
// Definition appears as:
//  Mibe( MIB Entry Name, Index in MIB Block, NntpStatisticsField)
//
//   Incidentally, MIB Entry suffix coincides with the entry name in OID Tree
//
//  Any New MIB should be added here. and dont change use of after this defn.
//

# define ALL_MIB_ENTRIES()    \
Mibe( TotalBytesSent_HighWord,     1,    TotalBytesSent.HighPart) \
Mibe( TotalBytesSent_LowWord,      2,    TotalBytesSent.LowPart)  \
Mibe( TotalBytesReceived_HighWord, 3,    TotalBytesReceived.HighPart)\
Mibe( TotalBytesReceived_LowWord,  4,    TotalBytesReceived.LowPart) \
Mibe( TotalConnections,            5,    TotalConnections)        \
Mibe( TotalSSLConnections,         6,    TotalSSLConnections)     \
Mibe( CurrentConnections,          7,    CurrentConnections)      \
Mibe( MaxConnections,              8,    MaxConnections)          \
Mibe( LogonAttempts,               9,    LogonAttempts)           \
Mibe( LogonFailures,               10,   LogonFailures)           \
Mibe( CurrentAnonymousUsers,       11,   CurrentAnonymousUsers)   \
Mibe( CurrentNonAnonymousUsers,    12,   CurrentNonAnonymousUsers)\
Mibe( TotalAnonymousUsers,         13,   TotalAnonymousUsers)     \
Mibe( TotalNonAnonymousUsers,      14,   TotalNonAnonymousUsers)  \
Mibe( MaxAnonymousUsers,           15,   MaxAnonymousUsers)       \
Mibe( MaxNonAnonymousUsers,        16,   MaxNonAnonymousUsers)    \
Mibe( TotalOutboundConnects,       17,   TotalOutboundConnects)   \
Mibe( OutboundConnectsFailed,      18,   OutboundConnectsFailed)  \
Mibe( CurrentOutboundConnects,     19,   CurrentOutboundConnects) \
Mibe( OutboundLogonFailed,         20,   OutboundLogonFailed)     \
Mibe( TotalPullFeeds,              21,   TotalPullFeeds)          \
Mibe( TotalPushFeeds,              22,   TotalPushFeeds)          \
Mibe( TotalPassiveFeeds,           23,   TotalPassiveFeeds)       \
Mibe( ArticlesSent,                24,   ArticlesSent)            \
Mibe( ArticlesReceived,            25,   ArticlesReceived)        \
Mibe( ArticlesPosted,              26,   ArticlesPosted)          \
Mibe( ArticleMapEntries,           27,   ArticleMapEntries)       \
Mibe( HistoryMapEntries,           28,   HistoryMapEntries)       \
Mibe( XoverEntries,                29,   XoverEntries)            \
Mibe( SessionsFlowControlled,      30,   SessionsFlowControlled)  \
Mibe( ArticlesExpired,             31,   ArticlesExpired)		  \
Mibe( ControlMessagesIn,           32,   ControlMessagesIn)		  \
Mibe( ControlMessagesFailed,       33,   ControlMessagesFailed)	  \
Mibe( ModeratedPostingsSent,       34,   ModeratedPostingsSent)	  \
Mibe( ModeratedPostingsFailed,     35,   ModeratedPostingsFailed) \
Mibe( ArticleCommands,             36,   ArticleCommands)		  \
Mibe( GroupCommands,               37,   GroupCommands)			  \
Mibe( HelpCommands,                38,   HelpCommands)			  \
Mibe( IHaveCommands,               39,   IHaveCommands)			  \
Mibe( LastCommands,                40,   LastCommands)			  \
Mibe( ListCommands,                41,   ListCommands)			  \
Mibe( NewgroupsCommands,           42,   NewgroupsCommands)		  \
Mibe( NewnewsCommands,             43,   NewnewsCommands)		  \
Mibe( NextCommands,                44,   NextCommands)			  \
Mibe( PostCommands,                45,   PostCommands)			  \
Mibe( QuitCommands,                46,   QuitCommands)			  \
Mibe( StatCommands,          	   47,   StatCommands)			  \
Mibe( CheckCommands,          	   48,   CheckCommands)			  \
Mibe( TakethisCommands,        	   49,   TakethisCommands)		  \
Mibe( ModeCommands,          	   50,   ModeCommands)			  \
Mibe( SearchCommands,          	   51,   SearchCommands)		  \
Mibe( XHdrCommands,          	   52,   XHdrCommands)			  \
Mibe( XOverCommands,          	   53,   XOverCommands)			  \
Mibe( XPatCommands,          	   54,   XPatCommands)			  \
Mibe( XReplicCommands,         	   55,   XReplicCommands)

//
// Individual OID Definitions.
//   All Leaf variables should have a zero appended to their OID to indicate
//   that it is the only instance of this variable and that it exists.
//  Declare just the id's starting from next to the prefix given above.
//


//
// Few Convenience Macros for MIB entries addition.
//

# define MIB_VAR_NAME( NameSuffix)       MIB_ ## NameSuffix

# define DEFINE_MIBOID( NameSuffix, uiArray)   \
           UINT MIB_VAR_NAME( NameSuffix)[] = uiArray

# define DEFINE_MIBOID_LEAF( NameSuffix, NodeNumber) \
           UINT MIB_VAR_NAME( NameSuffix)[] = \
                          { NNTP_STATISTICS_OID_SUFFIX, ( NodeNumber), 0 }

//
// Define all the OIDs. First define the higher level node and then leaves.
//
DEFINE_MIBOID( Statistics,     { NNTP_STATISTICS_OID_SUFFIX} );

//
//  Define the Leaf OIDs.
//
# define Mibe( NameSuffix, Index, FieldName)  \
     DEFINE_MIBOID_LEAF( NameSuffix, Index);

//
// Expand the macro ALL_MIB_ENTRIES to obtain definitions of MIB Leafs.
//

ALL_MIB_ENTRIES()

# undef Mibe


//
//  MIB Variable definition
//

//
// Define Mibe()  to be for variable definitions of counters.
//  Note that the comma is appearing before a new counter name. It is used
//   for structure initialization.
//

# define OFFSET_IN_NNTP_STATISTICS( Field)    \
     FIELD_OFFSET( NNTP_STATISTICS_0,   Field)

# define Mibe( NameSuffix, Index, Field)        \
     , MIB_COUNTER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( NameSuffix)), \
                    OFFSET_IN_NNTP_STATISTICS(Field),              \
                    MibStatisticsWorker)

static MIB_ENTRY  sg_rgNntpMib[] = {

    //
    // Statistics
    //

    MIB_ENTRY_HEADER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( Statistics)))
    ALL_MIB_ENTRIES()
};

# undef Mibe

static MIB_ENTRIES  sg_NntpMibs =
  {
    &sg_MibOidPrefix,
    ( sizeof( sg_rgNntpMib) / sizeof( MIB_ENTRY)),
    sg_rgNntpMib
  };


/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    Nntp MIB DLL. It initialises local variables and prepares the
    interface for the process to use SNMP Extension Agents for NNTP service.

 Messages            Actions

    ProcessAttach        Initializes winsock and data structures.
                          It fails if winsock has not already been started.

    ProcessDetach        Cleans up local data structures and disconnects from
                         winsock.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH: {

        //
        // Initialize various modules
        //

        break;
    } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH: {

       //
       // Only cleanup when we are called because of a FreeLibrary().
       //  i.e., when lpvContext == NULL
       // If we are called because of a process termination, dont free anything
       //   the system will free resources and memory for us.
       //

       if ( lpvContext == NULL) {

           //
           // Code to be executed on successful termination
           //

       }

       break;
   } /* case DLL_PROCESS_DETACH */

   default:
       break;
  }    /* switch */

  return ( fReturn);
}  /* DllLibMain() */


/************************************************************
 *  Entry Points of SNMP Extension DLL For Nntp Service
 ************************************************************/

//
//  Extension Agent DLLs need access to elapsed time agent has been active.
//  This is implemented by initializing the Extension Agent with a time zero
//  reference, and allowing the agent to compute elapsed time by subtracting
//  the time zero reference from the current system time.  This example
//  Extension Agent implements this reference with dwTimeZero.
//

DWORD dwTimeZero = 0;


BOOL
SnmpExtensionInit(
    IN  DWORD                 dwTimeZeroReference,
    OUT HANDLE              * phPollForTrapEvent,
    OUT AsnObjectIdentifier * pAsnOidSupportedView
    )
/*++
  Description:
     The Extension Agent DLLs provide this entry point SnmpExtensionInit()
     to co-ordinate the initializations of the extension agent and the
     extendible  agent.
     The Extendible agent provides extension agent with a time zero reference.
     The Extension Agent provides Extendible agent with an Event Handle
         for communicating occurences of traps.
     The Extension Agent also provides Extendible agent with an ObjectId
         representing the root of the MIB structure
         that it (extension) supports.

  Arguments:
     dwTimeZeroReference    DWORD containing the Time Zero Reference for sync.
     phPollForTrapEvent     pointer to handle which on successful return
                             may contain an event handle to be polled for
                             traps.
     pAsnOidSupportedView   pointer to ASN ( Abstract Syntax Notation OID)
                             that contains the oid representing root of the
                             MIB structure.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{


    //
    //  Record the time reference provided by the Extendible Agent.
    //

    dwTimeZero = dwTimeZeroReference;

    //
    //  Indicate the MIB view supported by this Extension Agent, an object
    //  identifier representing the sub root of the MIB that is supported.
    //

    *pAsnOidSupportedView = sg_MibOidPrefix; // NOTE!  structure copy

    //
    // Though the following is a handle, dont use INVALID_HANDLE_VALUE ( -1)
    //  because that constant is only for few people ( Win32). But all through
    //  NT invalid handle value is NULL ( 0).
    //

    *phPollForTrapEvent = NULL;

    //
    //  Indicate that Extension Agent initialization was sucessfull.
    //

    return ( TRUE);

}   // SnmpExtensionInit()

BOOL
SnmpExtensionTrap(
    OUT AsnObjectIdentifier * pAsnOidEnterprise,
    OUT AsnInteger          * pAsniGenericTrap,
    OUT AsnInteger          * pAsniSpecificTrap,
    OUT AsnTimeticks        * pAsnTimeStamp,
    OUT RFC1157VarBindList  * pRfcVariableBindings
    )
/*++
  Description:
     This function is used to communicate traps to the Extendible Agent.
     The Extendible Agent will invoke this entry point when the trap event
      ( supplied at the initialization time) is asserted, which indicates
      that zero or more traps had occured.
     The Extendible agent will repeatedly query this function till this
      function returns FALSE.

  Arguments:
    pAsnOidEnterprise      pointer to ASN OID for Enterprise, indicating
                             original enterprise generating trap.
    pAsniGenericTrap       pointer to ASN Integer which on return will
                             contain the indication of the generic trap.
    pAsniSpecificTrap      pointer to ASN Integer which on return will
                             contain the specific trap generated.
    pAsnTimeStamp          pointer to ASN containing the received Time-Stamp.
    pRfcVariableBindings   pointer to RFC 1157 compliant variable bindings.


  Returns:
    TRUE if success and there are more traps to be queried.
    FALSE if all traps are answered and work done.

--*/
{

    //
    //  We don't support traps (yet).
    //

    return ( FALSE);

}   // SnmpExtensionTrap()

BOOL
SnmpExtensionQuery(
    IN BYTE                     bRequestType,
    IN OUT RFC1157VarBindList * pRfcVariableBindings,
    OUT AsnInteger         *    pAsniErrorStatus,
    OUT AsnInteger         *    pAsniErrorIndex
    )
/*++
  Description:
    This function is called by Extendible Agent to resolve the SNMP requests
    for queries on MIB Variables in the Extension Agent's supported MIB view.
    ( which was supplied at initialization time).
    The Request Type is GET, GETNEXT, and SET.

  Arguments:
    bRequestType    byte containing the type of request.
                    It can be one of
                     ASN_RFC1157_GETREQUEST
                     ASN_RFC1157_GETNEXTREQUEST
                     ASN_RFC1157_SETREQUEST

    pRfcVariableBindings
                   pointer to RFC 1157 compliant variable bindings.

    pAsniErrorStatus
                   pointer to ASN Integer for Error Status

    pAsniErrorIndex
                  pointer to ASN INteger giving the index for error.

  Returns:
    TRUE on success and FALSE on failure.
--*/

{
    LPNNTP_STATISTICS_0  pNntpStatistics = NULL;
    NET_API_STATUS     Status;

    //
    //  Try to query the statistics now so we'll have a consitent
    //  view across all variable bindings.
    //

    Status = NntpQueryStatistics(
                            NULL,                    // pszServer
							1,						 // virtual server instance
                            0,
                            (LPBYTE *) &pNntpStatistics
                            );

    //
    //  Status Errors not checked for  here!
    //  Reason:
    //    If the verb is GET_NEXT beyond the block we support,
    //           then there is no need to worry about the error at all.
    //    If the verb is GET within the block, it will get NULL value
    //           ( due the memset() done above).
    //

    __try {

        //
        //  Iterate through the variable bindings list to resolve individual
        //  variable bindings.
        //

        RFC1157VarBind * pVarBinding;

        for( pVarBinding = pRfcVariableBindings->list;
            pVarBinding < ( pRfcVariableBindings->list +
                            pRfcVariableBindings->len);
            pVarBinding++ ) {

            *pAsniErrorStatus = ResolveVarBinding( pVarBinding,
                                                  bRequestType,
                                                  pNntpStatistics,
                                                  &sg_NntpMibs);

            //
            //  Test and handle case where Get Next past end of MIB view
            //  supported by this Extension Agent occurs.  Special
            //  processing is required to communicate this situation to
            //  the Extendible Agent so it can take appropriate action,
            //  possibly querying other Extension Agents.
            //

            if(( *pAsniErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ) &&
               ( bRequestType == MIB_GETNEXT ) ) {

                *pAsniErrorStatus = SNMP_ERRORSTATUS_NOERROR;

                //
                //  Modify variable binding of such variables so the OID
                //  points just outside the MIB view supported by this
                //  Extension Agent.  The Extendible Agent tests for this,
                //  and takes appropriate action.
                //

                SNMP_oidfree( &pVarBinding->name );
                SNMP_oidcpy( &pVarBinding->name, &sg_MibOidPrefix);
                pVarBinding->name.ids[ NNTP_PREFIX_OID_LENGTH - 1]++;
            }

            //
            //  If an error was indicated, communicate error status and error
            //  index to the Extendible Agent.  The Extendible Agent will
            //  ensure that the origional variable bindings are returned in
            //  the response packet.

            *pAsniErrorIndex =
              (( *pAsniErrorStatus != SNMP_ERRORSTATUS_NOERROR ) ?
               ( (AsnInteger)((pVarBinding - pRfcVariableBindings->list) + 1)) : 0);

        } // for

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  For now do nothing.
        //

    }

    if ( pNntpStatistics )
    {
        NetApiBufferFree( pNntpStatistics );
    }

    return ( SNMPAPI_NOERROR);

}   // SnmpExtensionQuery()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpctrs\perfnntp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfnntp.c

    This file implements the Extensible Performance Objects for
    the NNTP Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.

*/

#define INITGUID

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <lm.h>

#include <string.h>
//#include <wcstr.h>

#include <nntpctrs.h>
#include <perfmsg.h>
#include <nntps.h>
#include <nntptype.h>
#include <nntpapi.h>

extern "C" {
#include <perfutil.h>
#include <nntpdata.h>
}

#include <ole2.h>
#include "iadm.h"

#define APP_NAME                     (TEXT("NntpCtrs"))
#define MAX_SIZEOF_INSTANCE_NAME     128
#define TOTAL_INSTANCE_NAME          L"_Total"

//
//  Private constants.
//

#if DBG

#undef IF_DEBUG
#define IF_DEBUG(flag)    if ( NntpDebug & TCP_ ## flag )

#undef DBG_CONTEXT
#define DBG_CONTEXT       NULL

#define TCP_ENTRYPOINTS   0x00001000
#define TCP_COLLECT       0X00002000
#endif //DBG

//
//  Private globals.
//

DWORD   cOpens    = 0;                  // Active "opens" reference count.
BOOL    fInitOK   = FALSE;              // TRUE if DLL initialized OK.

IMSAdminBaseW * g_pAdminBase = NULL;

#if DBG
DWORD   NntpDebug = 0;                  // Debug behaviour flags.
#endif  // DBG

//
//  Private prototypes.
//
VOID
CopyStatisticsData1(
    IN NNTP_STATISTICS_0          * pNntpStats,
    OUT NNTP_COUNTER_BLOCK1		  * pCounterBlock
    );

VOID
CopyStatisticsData2(
    IN NNTP_STATISTICS_0          * pNntpStats,
    OUT NNTP_COUNTER_BLOCK2		  * pCounterBlock
    );

VOID
Update_TotalStatisticsData1(
    IN NNTP_COUNTER_BLOCK1         * pCounterBlock,
    OUT NNTP_COUNTER_BLOCK1        * pTotal
    );

VOID
Update_TotalStatisticsData2(
    IN NNTP_COUNTER_BLOCK2         * pCounterBlock,
    OUT NNTP_COUNTER_BLOCK2        * pTotal
    );

VOID
UpdateNameAndHelpIndicies(
	IN DWORD dwFirstCounter,
	IN DWORD dwFirstHelp
	);

HRESULT
InitAdminBase();

VOID
UninitAdminBase();

HRESULT
OpenAdminBaseKey(
    OUT METADATA_HANDLE *phHandle
    );

VOID
CloseAdminBaseKey(
    IN METADATA_HANDLE hHandle
    );


//
//  Public prototypes.
//

PM_OPEN_PROC    OpenNntpPerformanceData;
PM_COLLECT_PROC CollectNntpPerformanceData;
PM_CLOSE_PROC   CloseNntpPerformanceData;


//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenNntpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD
OpenNntpPerformanceData(
        LPWSTR lpDeviceNames
        )
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    //PERF_COUNTER_DEFINITION * pctr;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK ) {

        //
        //  This is the *first* open.
        //

        //
        //  Open the NNTP Server service's Performance key.
        //

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            NNTP_PERFORMANCE_KEY,
                            0,
                            KEY_READ,
                            &hkey );

        if( err == NO_ERROR )
        {
            //
            //  Read the first counter DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Counter",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstCounter,
                                   &size );
        }

        if( err == NO_ERROR )
        {
            //
            //  Read the first help DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Help",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstHelp,
                                   &size );
        }

        if ( err == NO_ERROR ) {

            //
            //  Update the object & counter name & help indicies.
            //

			UpdateNameAndHelpIndicies( dwFirstCounter, dwFirstHelp );

            //
            //  Remember that we initialized OK.
            //

            fInitOK = TRUE;
        }

        //
        //  Close the registry if we managed to actually open it.
        //

        if( hkey != NULL )
        {
            RegCloseKey( hkey );
            hkey = NULL;
        }

        g_pAdminBase = NULL;
    }

    //
    //  Bump open counter.
    //

    cOpens++;

    return NO_ERROR;

}   // OpenNntpPerformanceData

/*******************************************************************

    NAME:       CollectNntpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectNntpPerformanceData(
                    LPWSTR    lpValueName,
                    LPVOID  * lppData,
                    LPDWORD   lpcbTotalBytes,
                    LPDWORD   lpNumObjectTypes
                    )
{
    PERF_INSTANCE_DEFINITION		*pPerfInstanceDefinition;
    DWORD							dwInstanceIndex = 0;
    DWORD							dwInstanceCount = 0;
    DWORD							dwCount = 0;
    DWORD							i = 0;
    DWORD							dwQueryType;
    ULONG							cbRequired;
    //DWORD							*pdwCounter;
    //LARGE_INTEGER					*pliCounter;
    NNTP_COUNTER_BLOCK1				*pCounterBlock1;
    NNTP_COUNTER_BLOCK1				*pTotal1;
    NNTP_COUNTER_BLOCK2				*pCounterBlock2;
    NNTP_COUNTER_BLOCK2				*pTotal2;
    NNTP_DATA_DEFINITION_OBJECT1	*pNntpDataDefinitionObject1;
    NNTP_DATA_DEFINITION_OBJECT2	*pNntpDataDefinitionObject2;
    NNTP_STATISTICS_0				*pNntpStats;
    NET_API_STATUS					neterr;
    HRESULT                 		hresErr;
	DWORD							dwRetCode = NO_ERROR;
    METADATA_HANDLE hObjHandle = 0;
    WCHAR   wszKeyName[METADATA_MAX_NAME_LEN];


    //
    //  No need to even try if we failed to open...
    //

    if( !fInitOK )
    {

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if( dwQueryType == QUERY_FOREIGN )
    {
        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        NntpDataDefinitionObject1.NntpObjectType.ObjectNameTitleIndex,
                        lpValueName ) &&
			!IsNumberInUnicodeList(
                        NntpDataDefinitionObject2.NntpObjectType.ObjectNameTitleIndex,
                        lpValueName )
						)
        {
            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  Enumerate and get total number of instances count.
    //

    hresErr = OpenAdminBaseKey(
                 &hObjHandle
                 );

    if( FAILED(hresErr) )
    {
        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    //
    // loop through instance keys and find out total number of instances
    //

    while( SUCCEEDED(hresErr = g_pAdminBase->EnumKeys( hObjHandle,
                                                       NULL,
                                                       wszKeyName,
                                                       dwInstanceIndex))) {
        dwInstanceIndex++;

        if( _wtoi(wszKeyName) == 0 ) {
            continue;
        }

        dwInstanceCount++;
    }


    //
    //  add 1 to dwInstanceCount for _Total instance
    //

    dwInstanceCount++;

    //
    //  always return an "instance sized" buffer after the definition
    //  blocks to prevent perfmon from reading bogus data. This is strictly
    //  a hack to accomodate how PERFMON handles the "0" instance case.
    //  By doing this, perfmon won't choke when there are no instances
    //  and the counter object & counters will be displayed in the list
    //  boxes, even though no instances will be listed.
    //

    pNntpDataDefinitionObject1 = (NNTP_DATA_DEFINITION_OBJECT1 *)*lppData;

    cbRequired = sizeof(NNTP_DATA_DEFINITION_OBJECT1) +
                 (dwInstanceCount * (sizeof(PERF_INSTANCE_DEFINITION) +
                 MAX_SIZEOF_INSTANCE_NAME +
                 sizeof (NNTP_COUNTER_BLOCK1)));

    cbRequired += sizeof(NNTP_DATA_DEFINITION_OBJECT2) +
                 (dwInstanceCount * (sizeof(PERF_INSTANCE_DEFINITION) +
                 MAX_SIZEOF_INSTANCE_NAME +
                 sizeof (NNTP_COUNTER_BLOCK2)));

    //
    //  See if there's enough space.
    //

    if( *lpcbTotalBytes < cbRequired ) {

        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

		dwRetCode = ERROR_MORE_DATA;
		goto Exit;
    }

    //
    //  Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pNntpDataDefinitionObject1,
             &NntpDataDefinitionObject1,
             sizeof(NNTP_DATA_DEFINITION_OBJECT1) );

    //
    //  Create data for return for each instance
    //

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pNntpDataDefinitionObject1[1];

    //
    // Set first block of Buffer for _Total
    //

    MonBuildInstanceDefinition(
        pPerfInstanceDefinition,
        (PVOID *)&pCounterBlock1,
        0,
        0,
        (DWORD)-1, // use name
        TOTAL_INSTANCE_NAME );   // pass in instance name

    pTotal1 = pCounterBlock1;
    memset( pTotal1, 0, sizeof(NNTP_COUNTER_BLOCK1 ));
    pTotal1->PerfCounterBlock.ByteLength = sizeof (NNTP_COUNTER_BLOCK1);
    pPerfInstanceDefinition =
        (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock1 +
         sizeof(NNTP_COUNTER_BLOCK1));

    //
    //  Try to retrieve the data for each instance.
    //

    for( i = 0, dwCount = 1 ; (i < dwInstanceIndex) && dwCount < dwInstanceCount;
         i++ ) {

        hresErr = g_pAdminBase->EnumKeys( hObjHandle,
                                          NULL,
                                          wszKeyName,
                                          i);

        if (FAILED(hresErr)) {

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

			dwRetCode = NO_ERROR;
			goto Exit;
        }
        if (_wtoi(wszKeyName) == 0) {
            continue;
        }

        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pCounterBlock1,
            0,
            0,
            (DWORD)-1, // use name
            (LPWSTR)wszKeyName );   // pass in instance name

        //
        // query for statistics info
        //

        neterr = NntpQueryStatistics(
                            NULL,
                            _wtoi(wszKeyName),  // instance id
                            0,
                            (LPBYTE *)&pNntpStats );

        if( neterr != NERR_Success )
        {
#if 0
            //
            //  Error retrieving statistics.
            //
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                0, W3_UNABLE_QUERY_W3SVC_DATA,
                (PSID)NULL, 0,
                sizeof(neterr), NULL,
                (PVOID)(&neterr));
#endif

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

			dwRetCode = NO_ERROR;
			goto Exit;
        }

        //
        //  Format the NNTP Server data.
        //

        CopyStatisticsData1( pNntpStats,
                             pCounterBlock1 );

        //
        //  update _total instance counters
        //

        Update_TotalStatisticsData1( pCounterBlock1,
                                     pTotal1 );

        pPerfInstanceDefinition =
            (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock1 +
             sizeof(NNTP_COUNTER_BLOCK1));

        dwCount++;

		//
		//  Free the API buffer.
		//

		//MIDL_user_free( pNntpStats );
		NetApiBufferFree((LPBYTE)pNntpStats);
    }

    if (dwInstanceCount == 1) {

        //
        //  zero fill one instance sized block of data if there's no data
        //  instances
        //

        memset (pPerfInstanceDefinition, 0,
            (sizeof(PERF_INSTANCE_DEFINITION) +
            MAX_SIZEOF_INSTANCE_NAME +
            sizeof(NNTP_COUNTER_BLOCK1)));

        // adjust pointer to point to end of zeroed block
        pPerfInstanceDefinition += (sizeof(PERF_INSTANCE_DEFINITION) +
            MAX_SIZEOF_INSTANCE_NAME +
            sizeof(NNTP_COUNTER_BLOCK1));
    }

    pNntpDataDefinitionObject1->NntpObjectType.NumInstances = dwInstanceCount;
    pNntpDataDefinitionObject1->NntpObjectType.TotalByteLength =
        *lpcbTotalBytes   = (DWORD)((PBYTE)pPerfInstanceDefinition -
                                    (PBYTE)pNntpDataDefinitionObject1);

	//
	//	Fill in data for Object 2 - the "NNTP Svc Client Request" object
	//

    *lppData          = (PVOID)(pPerfInstanceDefinition);
    pNntpDataDefinitionObject2 = (NNTP_DATA_DEFINITION_OBJECT2 *)*lppData;

    //
    //  Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pNntpDataDefinitionObject2,
             &NntpDataDefinitionObject2,
             sizeof(NNTP_DATA_DEFINITION_OBJECT2) );

    //
    //  Create data for return for each instance
    //

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pNntpDataDefinitionObject2[1];

    //
    // Set first block of Buffer for _Total
    //

    MonBuildInstanceDefinition(
        pPerfInstanceDefinition,
        (PVOID *)&pCounterBlock2,
        0,
        0,
        (DWORD)-1, // use name
        TOTAL_INSTANCE_NAME );   // pass in instance name

    pTotal2 = pCounterBlock2;
    memset( pTotal2, 0, sizeof(NNTP_COUNTER_BLOCK2 ));
    pTotal2->PerfCounterBlock.ByteLength = sizeof (NNTP_COUNTER_BLOCK2);
    pPerfInstanceDefinition =
        (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock2 +
         sizeof(NNTP_COUNTER_BLOCK2));

    //
    //  Try to retrieve the data for each instance.
    //

    for( i = 0, dwCount = 1 ; (i < dwInstanceIndex) && dwCount < dwInstanceCount;
         i++ ) {

        hresErr = g_pAdminBase->EnumKeys( hObjHandle,
                                          NULL,
                                          wszKeyName,
                                          i);

        if (FAILED(hresErr)) {

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

			dwRetCode = NO_ERROR;
			goto Exit;
        }
        if (_wtoi(wszKeyName) == 0) {
            continue;
        }

        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pCounterBlock2,
            0,
            0,
            (DWORD)-1, // use name
            (LPWSTR)wszKeyName );   // pass in instance name

        //
        // query for statistics info
        //

        neterr = NntpQueryStatistics(
                            NULL,
                            _wtoi(wszKeyName),  // instance id
                            0,
                            (LPBYTE *)&pNntpStats );

        if( neterr != NERR_Success )
        {
#if 0
            //
            //  Error retrieving statistics.
            //
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                0, W3_UNABLE_QUERY_W3SVC_DATA,
                (PSID)NULL, 0,
                sizeof(neterr), NULL,
                (PVOID)(&neterr));
#endif

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

			dwRetCode = NO_ERROR;
			goto Exit;
        }

        //
        //  Format the NNTP Server data.
        //

        CopyStatisticsData2( pNntpStats,
                             pCounterBlock2 );

        //
        //  update _total instance counters
        //

        Update_TotalStatisticsData2( pCounterBlock2,
                                     pTotal2 );

        pPerfInstanceDefinition =
            (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock2 +
             sizeof(NNTP_COUNTER_BLOCK2));

        dwCount++;

		//
		//  Free the API buffer.
		//

		//MIDL_user_free( pNntpStats );
		NetApiBufferFree((LPBYTE)pNntpStats);
    }

    if (dwInstanceCount == 1) {

        //
        //  zero fill one instance sized block of data if there's no data
        //  instances
        //

        memset (pPerfInstanceDefinition, 0,
            (sizeof(PERF_INSTANCE_DEFINITION) +
            MAX_SIZEOF_INSTANCE_NAME +
            sizeof(NNTP_COUNTER_BLOCK2)));

        // adjust pointer to point to end of zeroed block
        pPerfInstanceDefinition += (sizeof(PERF_INSTANCE_DEFINITION) +
            MAX_SIZEOF_INSTANCE_NAME +
            sizeof(NNTP_COUNTER_BLOCK2));
    }

    //
    //  Update arguments for return.
    //

    *lppData          = (PVOID)(pPerfInstanceDefinition);
    *lpNumObjectTypes = 2;

    pNntpDataDefinitionObject2->NntpObjectType.NumInstances = dwInstanceCount;
    pNntpDataDefinitionObject2->NntpObjectType.TotalByteLength =
							(DWORD)((PBYTE)pPerfInstanceDefinition -
                            ((PBYTE)pNntpDataDefinitionObject1 + *lpcbTotalBytes));

	*lpcbTotalBytes = 	(DWORD)((PBYTE)pPerfInstanceDefinition -
                                (PBYTE)pNntpDataDefinitionObject1);

Exit:

    //
    //  Free Metabase handle
    //

    CloseAdminBaseKey(hObjHandle);

    //
    //  Success!  Honest!!
    //

    return dwRetCode;

}   // CollectNntpPerformanceData

/*******************************************************************

    NAME:       CloseNntpPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseNntpPerformanceData( VOID )
{
    //
    //  No real cleanup to do here.
    //

    if ((--cOpens) == 0) {
        // Done each time the perf data is collect instead of here
        // UninitAdminBase();
	}

    return NO_ERROR;

}   // CloseNntpPerformanceData

VOID
CopyStatisticsData1(
    IN  NNTP_STATISTICS_0           * pNntpStats,
    OUT NNTP_COUNTER_BLOCK1         * pCounterBlock
    )
{
    //
    //  Format the NNTP Server data for Object1
    //

    pCounterBlock->PerfCounterBlock.ByteLength = sizeof (NNTP_COUNTER_BLOCK1);

    pCounterBlock->BytesSent        = pNntpStats->TotalBytesSent.QuadPart;
    pCounterBlock->BytesReceived    = pNntpStats->TotalBytesReceived.QuadPart;
    pCounterBlock->BytesTotal       = pNntpStats->TotalBytesSent.QuadPart + pNntpStats->TotalBytesReceived.QuadPart;

    pCounterBlock->TotalConnections = pNntpStats->TotalConnections;
    pCounterBlock->TotalSSLConnections = pNntpStats->TotalSSLConnections;
    pCounterBlock->CurrentConnections = pNntpStats->CurrentConnections;
    pCounterBlock->MaxConnections = pNntpStats->MaxConnections;
    pCounterBlock->CurrentAnonymous = pNntpStats->CurrentAnonymousUsers;
    pCounterBlock->CurrentNonAnonymous = pNntpStats->CurrentNonAnonymousUsers;
    pCounterBlock->TotalAnonymous = pNntpStats->TotalAnonymousUsers;
    pCounterBlock->TotalNonAnonymous = pNntpStats->TotalNonAnonymousUsers;
    pCounterBlock->MaxAnonymous = pNntpStats->MaxAnonymousUsers;
    pCounterBlock->MaxNonAnonymous = pNntpStats->MaxNonAnonymousUsers;
    pCounterBlock->TotalOutboundConnects = pNntpStats->TotalOutboundConnects;
    pCounterBlock->OutboundConnectsFailed = pNntpStats->OutboundConnectsFailed;
    pCounterBlock->CurrentOutboundConnects = pNntpStats->CurrentOutboundConnects;
    pCounterBlock->OutboundLogonFailed = pNntpStats->OutboundLogonFailed;
    pCounterBlock->TotalPullFeeds = pNntpStats->TotalPullFeeds;
    pCounterBlock->TotalPushFeeds = pNntpStats->TotalPushFeeds;
    pCounterBlock->TotalPassiveFeeds = pNntpStats->TotalPassiveFeeds;
    pCounterBlock->ArticlesSent = pNntpStats->ArticlesSent;
    pCounterBlock->ArticlesReceived = pNntpStats->ArticlesReceived;
    pCounterBlock->ArticlesTotal = pNntpStats->ArticlesSent + pNntpStats->ArticlesReceived;
    pCounterBlock->ArticlesPosted = pNntpStats->ArticlesPosted;
    pCounterBlock->ArticleMapEntries = pNntpStats->ArticleMapEntries;
    pCounterBlock->HistoryMapEntries = pNntpStats->HistoryMapEntries;
    pCounterBlock->XoverEntries = pNntpStats->XoverEntries;
    pCounterBlock->ControlMessagesIn = pNntpStats->ControlMessagesIn;
    pCounterBlock->ControlMessagesFailed = pNntpStats->ControlMessagesFailed;
    pCounterBlock->ModeratedPostingsSent = pNntpStats->ModeratedPostingsSent;
    pCounterBlock->ModeratedPostingsFailed = pNntpStats->ModeratedPostingsFailed;
    pCounterBlock->SessionsFlowControlled = pNntpStats->SessionsFlowControlled;
    pCounterBlock->ArticlesExpired = pNntpStats->ArticlesExpired;
    pCounterBlock->ArticlesSentPerSec = pNntpStats->ArticlesSent;
    pCounterBlock->ArticlesReceivedPerSec = pNntpStats->ArticlesReceived;
    pCounterBlock->ArticlesPostedPerSec = pNntpStats->ArticlesPosted;
    pCounterBlock->ArticleMapEntriesPerSec = pNntpStats->ArticleMapEntries;
    pCounterBlock->HistoryMapEntriesPerSec = pNntpStats->HistoryMapEntries;
    pCounterBlock->XoverEntriesPerSec = pNntpStats->XoverEntries;
    pCounterBlock->ArticlesExpiredPerSec = pNntpStats->ArticlesExpired;

}   // CopyStatisticsData

VOID
CopyStatisticsData2(
    IN  NNTP_STATISTICS_0           * pNntpStats,
    OUT NNTP_COUNTER_BLOCK2         * pCounterBlock
    )
{
    //
    //  Format the NNTP Server data for Object2
    //

    pCounterBlock->PerfCounterBlock.ByteLength = sizeof (NNTP_COUNTER_BLOCK2);

    pCounterBlock->ArticleCmds = pNntpStats->ArticleCommands;
    pCounterBlock->ArticleCmdsPerSec = pNntpStats->ArticleCommands;
    pCounterBlock->GroupCmds = pNntpStats->GroupCommands;
    pCounterBlock->GroupCmdsPerSec = pNntpStats->GroupCommands;
    pCounterBlock->HelpCmds = pNntpStats->HelpCommands;
    pCounterBlock->HelpCmdsPerSec = pNntpStats->HelpCommands;
    pCounterBlock->IHaveCmds = pNntpStats->IHaveCommands;
    pCounterBlock->IHaveCmdsPerSec = pNntpStats->IHaveCommands;
    pCounterBlock->LastCmds = pNntpStats->LastCommands;
    pCounterBlock->LastCmdsPerSec = pNntpStats->LastCommands;
    pCounterBlock->ListCmds = pNntpStats->ListCommands;
    pCounterBlock->ListCmdsPerSec = pNntpStats->ListCommands;
    pCounterBlock->NewgroupsCmds = pNntpStats->NewgroupsCommands;
    pCounterBlock->NewgroupsCmdsPerSec = pNntpStats->NewgroupsCommands;
    pCounterBlock->NewnewsCmds = pNntpStats->NewnewsCommands;
    pCounterBlock->NewnewsCmdsPerSec = pNntpStats->NewnewsCommands;
    pCounterBlock->NextCmds = pNntpStats->NextCommands;
    pCounterBlock->NextCmdsPerSec = pNntpStats->NextCommands;
    pCounterBlock->PostCmds = pNntpStats->PostCommands;
    pCounterBlock->PostCmdsPerSec = pNntpStats->PostCommands;
    pCounterBlock->QuitCmds = pNntpStats->QuitCommands;
    pCounterBlock->QuitCmdsPerSec = pNntpStats->QuitCommands;
    pCounterBlock->StatCmds = pNntpStats->StatCommands;
    pCounterBlock->StatCmdsPerSec = pNntpStats->StatCommands;
    pCounterBlock->LogonAttempts = pNntpStats->LogonAttempts;
    pCounterBlock->LogonFailures = pNntpStats->LogonFailures;
    pCounterBlock->LogonAttemptsPerSec = pNntpStats->LogonAttempts;
    pCounterBlock->LogonFailuresPerSec = pNntpStats->LogonFailures;
    pCounterBlock->CheckCmds = pNntpStats->CheckCommands;
    pCounterBlock->CheckCmdsPerSec = pNntpStats->CheckCommands;
    pCounterBlock->TakethisCmds = pNntpStats->TakethisCommands;
    pCounterBlock->TakethisCmdsPerSec = pNntpStats->TakethisCommands;
    pCounterBlock->ModeCmds = pNntpStats->ModeCommands;
    pCounterBlock->ModeCmdsPerSec = pNntpStats->ModeCommands;
    pCounterBlock->SearchCmds = pNntpStats->SearchCommands;
    pCounterBlock->SearchCmdsPerSec = pNntpStats->SearchCommands;
    pCounterBlock->XHdrCmds = pNntpStats->XHdrCommands;
    pCounterBlock->XHdrCmdsPerSec = pNntpStats->XHdrCommands;
    pCounterBlock->XOverCmds = pNntpStats->XOverCommands;
    pCounterBlock->XOverCmdsPerSec = pNntpStats->XOverCommands;
    pCounterBlock->XPatCmds = pNntpStats->XPatCommands;
    pCounterBlock->XPatCmdsPerSec = pNntpStats->XPatCommands;
    pCounterBlock->XReplicCmds = pNntpStats->XReplicCommands;
    pCounterBlock->XReplicCmdsPerSec = pNntpStats->XReplicCommands;

}   // CopyStatisticsData

VOID
Update_TotalStatisticsData1(
    IN NNTP_COUNTER_BLOCK1         * pCounterBlock,
    OUT NNTP_COUNTER_BLOCK1        * pTotal
    )
{
    //
    //  update _total instance counters for Object1
    //

    pTotal->BytesSent += pCounterBlock->BytesSent;
    pTotal->BytesReceived    += pCounterBlock->BytesReceived;
    pTotal->BytesTotal       += pCounterBlock->BytesSent + pCounterBlock->BytesReceived;

    pTotal->TotalConnections += pCounterBlock->TotalConnections;
    pTotal->TotalSSLConnections += pCounterBlock->TotalSSLConnections;
    pTotal->CurrentConnections += pCounterBlock->CurrentConnections;
    pTotal->MaxConnections += pCounterBlock->MaxConnections;
    pTotal->CurrentAnonymous += pCounterBlock->CurrentAnonymous;
    pTotal->CurrentNonAnonymous += pCounterBlock->CurrentNonAnonymous;
    pTotal->TotalAnonymous += pCounterBlock->TotalAnonymous;
    pTotal->TotalNonAnonymous += pCounterBlock->TotalNonAnonymous;
    pTotal->MaxAnonymous += pCounterBlock->MaxAnonymous;
    pTotal->MaxNonAnonymous += pCounterBlock->MaxNonAnonymous;
    pTotal->TotalOutboundConnects += pCounterBlock->TotalOutboundConnects;
    pTotal->OutboundConnectsFailed += pCounterBlock->OutboundConnectsFailed;
    pTotal->CurrentOutboundConnects += pCounterBlock->CurrentOutboundConnects;
    pTotal->OutboundLogonFailed += pCounterBlock->OutboundLogonFailed;
    pTotal->TotalPullFeeds += pCounterBlock->TotalPullFeeds;
    pTotal->TotalPushFeeds += pCounterBlock->TotalPushFeeds;
    pTotal->TotalPassiveFeeds += pCounterBlock->TotalPassiveFeeds;
    pTotal->ArticlesSent += pCounterBlock->ArticlesSent;
    pTotal->ArticlesReceived += pCounterBlock->ArticlesReceived;
    pTotal->ArticlesTotal += pCounterBlock->ArticlesTotal;
    pTotal->ArticlesPosted += pCounterBlock->ArticlesPosted;
    pTotal->ArticleMapEntries += pCounterBlock->ArticleMapEntries;
    pTotal->HistoryMapEntries += pCounterBlock->HistoryMapEntries;
    pTotal->XoverEntries += pCounterBlock->XoverEntries;
    pTotal->ControlMessagesIn += pCounterBlock->ControlMessagesIn;
    pTotal->ControlMessagesFailed += pCounterBlock->ControlMessagesFailed;
    pTotal->ModeratedPostingsSent += pCounterBlock->ModeratedPostingsSent;
    pTotal->ModeratedPostingsFailed += pCounterBlock->ModeratedPostingsFailed;
    pTotal->SessionsFlowControlled += pCounterBlock->SessionsFlowControlled;
    pTotal->ArticlesExpired += pCounterBlock->ArticlesExpired;
    pTotal->ArticlesSentPerSec += pCounterBlock->ArticlesSentPerSec;
    pTotal->ArticlesReceivedPerSec += pCounterBlock->ArticlesReceivedPerSec;
    pTotal->ArticlesPostedPerSec += pCounterBlock->ArticlesPostedPerSec;
    pTotal->ArticleMapEntriesPerSec += pCounterBlock->ArticleMapEntriesPerSec;
    pTotal->HistoryMapEntriesPerSec += pCounterBlock->HistoryMapEntriesPerSec;
    pTotal->XoverEntriesPerSec += pCounterBlock->XoverEntriesPerSec;
    pTotal->ArticlesExpiredPerSec += pCounterBlock->ArticlesExpiredPerSec;

}   // Update_TotalStatisticsData

VOID
Update_TotalStatisticsData2(
    IN NNTP_COUNTER_BLOCK2         * pCounterBlock,
    OUT NNTP_COUNTER_BLOCK2        * pTotal
    )
{
    //
    //  update _total instance counters for Object2
    //

    pTotal->ArticleCmds += pCounterBlock->ArticleCmds;
    pTotal->ArticleCmdsPerSec += pCounterBlock->ArticleCmdsPerSec;
    pTotal->GroupCmds += pCounterBlock->GroupCmds;
    pTotal->GroupCmdsPerSec += pCounterBlock->GroupCmdsPerSec;
    pTotal->HelpCmds += pCounterBlock->HelpCmds;
    pTotal->HelpCmdsPerSec += pCounterBlock->HelpCmdsPerSec;
    pTotal->IHaveCmds += pCounterBlock->IHaveCmds;
    pTotal->IHaveCmdsPerSec += pCounterBlock->IHaveCmdsPerSec;
    pTotal->LastCmds += pCounterBlock->LastCmds;
    pTotal->LastCmdsPerSec += pCounterBlock->LastCmdsPerSec;
    pTotal->ListCmds += pCounterBlock->ListCmds;
    pTotal->ListCmdsPerSec += pCounterBlock->ListCmdsPerSec;
    pTotal->NewgroupsCmds += pCounterBlock->NewgroupsCmds;
    pTotal->NewgroupsCmdsPerSec += pCounterBlock->NewgroupsCmdsPerSec;
    pTotal->NewnewsCmds += pCounterBlock->NewnewsCmds;
    pTotal->NewnewsCmdsPerSec += pCounterBlock->NewnewsCmdsPerSec;
    pTotal->NextCmds += pCounterBlock->NextCmds;
    pTotal->NextCmdsPerSec += pCounterBlock->NextCmdsPerSec;
    pTotal->PostCmds += pCounterBlock->PostCmds;
    pTotal->PostCmdsPerSec += pCounterBlock->PostCmdsPerSec;
    pTotal->QuitCmds += pCounterBlock->QuitCmds;
    pTotal->QuitCmdsPerSec += pCounterBlock->QuitCmdsPerSec;
    pTotal->StatCmds += pCounterBlock->StatCmds;
    pTotal->StatCmdsPerSec += pCounterBlock->StatCmdsPerSec;
    pTotal->LogonAttempts += pCounterBlock->LogonAttempts;
    pTotal->LogonFailures += pCounterBlock->LogonFailures;
    pTotal->LogonAttemptsPerSec += pCounterBlock->LogonAttemptsPerSec;
    pTotal->LogonFailuresPerSec += pCounterBlock->LogonFailuresPerSec;
    pTotal->CheckCmds += pCounterBlock->CheckCmds;
    pTotal->CheckCmdsPerSec += pCounterBlock->CheckCmdsPerSec;
    pTotal->TakethisCmds += pCounterBlock->TakethisCmds;
    pTotal->TakethisCmdsPerSec += pCounterBlock->TakethisCmdsPerSec;
    pTotal->ModeCmds += pCounterBlock->ModeCmds;
    pTotal->ModeCmdsPerSec += pCounterBlock->ModeCmdsPerSec;
    pTotal->SearchCmds += pCounterBlock->SearchCmds;
    pTotal->SearchCmdsPerSec += pCounterBlock->SearchCmdsPerSec;
    pTotal->XHdrCmds += pCounterBlock->XHdrCmds;
    pTotal->XHdrCmdsPerSec += pCounterBlock->XHdrCmdsPerSec;
    pTotal->XOverCmds += pCounterBlock->XOverCmds;
    pTotal->XOverCmdsPerSec += pCounterBlock->XOverCmdsPerSec;
    pTotal->XPatCmds += pCounterBlock->XPatCmds;
    pTotal->XPatCmdsPerSec += pCounterBlock->XPatCmdsPerSec;
    pTotal->XReplicCmds += pCounterBlock->XReplicCmds;
    pTotal->XReplicCmdsPerSec += pCounterBlock->XReplicCmdsPerSec;

}   // Update_TotalStatisticsData

VOID
UpdateNameAndHelpIndicies(
					IN DWORD dwFirstCounter,
					IN DWORD dwFirstHelp
					)
{
	NNTP_COUNTER_BLOCK1 nntpc1;
	NNTP_COUNTER_BLOCK2 nntpc2;

	//
    //  Update the object & counter name & help indicies for object1
    //

    NntpDataDefinitionObject1.NntpObjectType.ObjectNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpObjectType.ObjectHelpTitleIndex
        += dwFirstHelp;

    NntpDataDefinitionObject1.NntpBytesSent.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpBytesSent.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpBytesSent.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.BytesSent - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpBytesReceived.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpBytesReceived.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpBytesReceived.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.BytesReceived - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpBytesTotal.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpBytesTotal.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpBytesTotal.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.BytesTotal - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalConnections.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalConnections.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalConnections.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalConnections - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalSSLConnections.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalSSLConnections.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalSSLConnections.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalSSLConnections - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpCurrentConnections.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpCurrentConnections.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpCurrentConnections.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.CurrentConnections - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpMaxConnections.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpMaxConnections.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpMaxConnections.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.MaxConnections - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpCurrentAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpCurrentAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpCurrentAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.CurrentAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpCurrentNonAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpCurrentNonAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpCurrentNonAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.CurrentNonAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalNonAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalNonAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalNonAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalNonAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpMaxAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpMaxAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpMaxAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.MaxAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpMaxNonAnonymous.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpMaxNonAnonymous.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpMaxNonAnonymous.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.MaxNonAnonymous - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalOutboundConnects.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalOutboundConnects.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalOutboundConnects.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalOutboundConnects - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpOutboundConnectsFailed.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpOutboundConnectsFailed.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpOutboundConnectsFailed.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.OutboundConnectsFailed - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpCurrentOutboundConnects.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpCurrentOutboundConnects.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpCurrentOutboundConnects.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.CurrentOutboundConnects - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpOutboundLogonFailed.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpOutboundLogonFailed.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpOutboundLogonFailed.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.OutboundLogonFailed - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalPullFeeds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalPullFeeds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalPullFeeds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalPullFeeds - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalPushFeeds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalPushFeeds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalPushFeeds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalPushFeeds - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpTotalPassiveFeeds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpTotalPassiveFeeds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpTotalPassiveFeeds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.TotalPassiveFeeds - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesSent.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesSent.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesSent.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesSent - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesReceived.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesReceived.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesReceived.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesReceived - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesTotal.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesTotal.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesTotal.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesTotal - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesPosted.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesPosted.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesPosted.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesPosted - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticleMapEntries.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticleMapEntries.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticleMapEntries.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticleMapEntries - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpHistoryMapEntries.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpHistoryMapEntries.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpHistoryMapEntries.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.HistoryMapEntries - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpXoverEntries.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpXoverEntries.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpXoverEntries.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.XoverEntries - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpControlMessagesIn.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpControlMessagesIn.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpControlMessagesIn.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ControlMessagesIn - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpControlMessagesFailed.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpControlMessagesFailed.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpControlMessagesFailed.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ControlMessagesFailed - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpModeratedPostingsSent.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpModeratedPostingsSent.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpModeratedPostingsSent.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ModeratedPostingsSent - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpModeratedPostingsFailed.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpModeratedPostingsFailed.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpModeratedPostingsFailed.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ModeratedPostingsFailed - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpSessionsFlowControlled.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpSessionsFlowControlled.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpSessionsFlowControlled.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.SessionsFlowControlled - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesExpired.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesExpired.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesExpired.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesExpired - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesSentPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesSentPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesSentPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesSentPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesReceivedPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesReceivedPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesReceivedPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesReceivedPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesPostedPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesPostedPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesPostedPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesPostedPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticleMapEntriesPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticleMapEntriesPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticleMapEntriesPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticleMapEntriesPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpHistoryMapEntriesPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpHistoryMapEntriesPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpHistoryMapEntriesPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.HistoryMapEntriesPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpXoverEntriesPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpXoverEntriesPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpXoverEntriesPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.XoverEntriesPerSec - (LPBYTE)&nntpc1);

    NntpDataDefinitionObject1.NntpArticlesExpiredPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject1.NntpArticlesExpiredPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject1.NntpArticlesExpiredPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc1.ArticlesExpiredPerSec - (LPBYTE)&nntpc1);

	//
    //  Update the object & counter name & help indicies for object2
    //

    NntpDataDefinitionObject2.NntpObjectType.ObjectNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpObjectType.ObjectHelpTitleIndex
        += dwFirstHelp;

    NntpDataDefinitionObject2.NntpArticleCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpArticleCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpArticleCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ArticleCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpArticleCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpArticleCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpArticleCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ArticleCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpGroupCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpGroupCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpGroupCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.GroupCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpGroupCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpGroupCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpGroupCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.GroupCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpHelpCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpHelpCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpHelpCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.HelpCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpHelpCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpHelpCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpHelpCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.HelpCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpIHaveCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpIHaveCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpIHaveCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.IHaveCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpIHaveCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpIHaveCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpIHaveCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.IHaveCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLastCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLastCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLastCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LastCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLastCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLastCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLastCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LastCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpListCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpListCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpListCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ListCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpListCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpListCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpListCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ListCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNewgroupsCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNewgroupsCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNewgroupsCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NewgroupsCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNewgroupsCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNewgroupsCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNewgroupsCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NewgroupsCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNewnewsCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNewnewsCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNewnewsCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NewnewsCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNewnewsCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNewnewsCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNewnewsCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NewnewsCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNextCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNextCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNextCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NextCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpNextCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpNextCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpNextCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.NextCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpPostCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpPostCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpPostCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.PostCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpPostCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpPostCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpPostCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.PostCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpQuitCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpQuitCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpQuitCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.QuitCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpQuitCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpQuitCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpQuitCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.QuitCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpStatCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpStatCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpStatCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.StatCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpStatCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpStatCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpStatCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.StatCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLogonAttempts.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLogonAttempts.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLogonAttempts.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LogonAttempts - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLogonFailures.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLogonFailures.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLogonFailures.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LogonFailures - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLogonAttemptsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLogonAttemptsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLogonAttemptsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LogonAttemptsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpLogonFailuresPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpLogonFailuresPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpLogonFailuresPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.LogonFailuresPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpCheckCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpCheckCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpCheckCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.CheckCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpCheckCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpCheckCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpCheckCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.CheckCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpTakethisCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpTakethisCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpTakethisCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.TakethisCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpTakethisCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpTakethisCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpTakethisCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.TakethisCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpModeCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpModeCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpModeCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ModeCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpModeCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpModeCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpModeCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.ModeCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpSearchCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpSearchCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpSearchCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.SearchCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpSearchCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpSearchCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpSearchCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.SearchCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXHdrCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXHdrCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXHdrCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XHdrCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXHdrCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXHdrCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXHdrCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XHdrCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXOverCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXOverCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXOverCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XOverCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXOverCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXOverCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXOverCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XOverCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXPatCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXPatCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXPatCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XPatCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXPatCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXPatCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXPatCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XPatCmdsPerSec - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXReplicCmds.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXReplicCmds.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXReplicCmds.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XReplicCmds - (LPBYTE)&nntpc2);

    NntpDataDefinitionObject2.NntpXReplicCmdsPerSec.CounterNameTitleIndex
        += dwFirstCounter;
    NntpDataDefinitionObject2.NntpXReplicCmdsPerSec.CounterHelpTitleIndex
        += dwFirstHelp;
    NntpDataDefinitionObject2.NntpXReplicCmdsPerSec.CounterOffset =
        (DWORD)((LPBYTE)&nntpc2.XReplicCmdsPerSec - (LPBYTE)&nntpc2);
}

HRESULT
InitAdminBase()
{
    HRESULT hRes = S_OK;

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( RPC_E_CHANGED_MODE == hRes ) 
        hRes = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

    if (SUCCEEDED(hRes) ) {
        hRes = CoCreateInstance(
                   CLSID_MSAdminBase_W,
                   NULL,
                   CLSCTX_SERVER,
                   IID_IMSAdminBase_W,
                   (void**) &g_pAdminBase
                   );
    }
    else {
        //CoUninitialize();
    }

    return hRes;
}

VOID
UninitAdminBase()
{
    if (g_pAdminBase != NULL) {
        g_pAdminBase->Release();
        CoUninitialize();
        g_pAdminBase = NULL;
    }
}

HRESULT
OpenAdminBaseKey(
    OUT METADATA_HANDLE *phHandle
    )
{
    HRESULT hRes = S_OK;
    METADATA_HANDLE RootHandle;


    if (g_pAdminBase == NULL) {
        //
        // Don't have a Metadata interface
        // so try to get one.
        //
        hRes = InitAdminBase();
    }
    if (SUCCEEDED(hRes)) {
        hRes = g_pAdminBase->OpenKey(
                    METADATA_MASTER_ROOT_HANDLE,
                    L"/LM/NNTPSVC/",
                    METADATA_PERMISSION_READ,
                    100,
                    &RootHandle
                    );

        if (FAILED(hRes)) {
            if ((HRESULT_CODE(hRes) == RPC_S_SERVER_UNAVAILABLE) ||
                ((HRESULT_CODE(hRes) >= RPC_S_NO_CALL_ACTIVE) &&
                    (HRESULT_CODE(hRes) <= RPC_S_CALL_FAILED_DNE))) {
                //
                // RPC error, try to recover connection
                //
                UninitAdminBase();
                hRes = InitAdminBase();
                if (SUCCEEDED(hRes)) {
                    hRes = g_pAdminBase->OpenKey(
                                METADATA_MASTER_ROOT_HANDLE,
                                L"/LM/NNTPSVC/",
                                METADATA_PERMISSION_READ,
                                100,
                                &RootHandle
                                );
                }
            }
        }
        if (SUCCEEDED(hRes)) {
            *phHandle = RootHandle;
        }
    }

    return(hRes);
}

VOID
CloseAdminBaseKey(
    IN METADATA_HANDLE hHandle
    )
{
    g_pAdminBase->CloseKey(hHandle);
    UninitAdminBase();
    g_pAdminBase = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpmib\mib.h ===
/*++  BUILD Version: 001   // Increment this if a change has global effects

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.h

   Abstract:

     Generic Macros and Functions for SNMP Extension Agent for
       gathering statistics information for Internet Services on NT.

   Author:

       Murali R. Krishnan    ( MuraliK )    22-Feb-1995

   Environment:

      User Mode -- Win32

   Project:

      NNTP Server SNMP MIB DLL

   Revision History:

--*/

# ifndef _MIB_H_
# define _MIB_H_

#include <windows.h>
#include <snmp.h>
#include <lm.h>
#include <inetinfo.h>

//
//  MIB function actions.
//

#define MIB_GET         ( ASN_RFC1157_GETREQUEST)
#define MIB_SET         ( ASN_RFC1157_SETREQUEST)
#define MIB_GETNEXT     ( ASN_RFC1157_GETNEXTREQUEST)
#define MIB_GETFIRST    ( ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0 )


//
//  MIB Variable access privileges.
//

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS           3


typedef UINT ( * LPMIBFUNC)(
                            RFC1157VarBind    *  pRfcVarBind,
                            UINT                 Action,
                            struct _MIB_ENTRY *  pMibeCurrent,
                            struct _MIB_ENTRIES* pMibEntries,
                            LPVOID               pStatistics
                            );


typedef struct _MIB_ENTRY  {

    AsnObjectIdentifier   asnOid;       // OID for mib variable
    LONG                  lFieldOffset; // filed offset
    UINT                  uiAccess;     // type of accesss( R, W, R/W, None)
    LPMIBFUNC             pMibFunc;     // ptr to function managing this var.
    BYTE                  bType;        // Type( integer, counter, gauage).

} MIB_ENTRY, FAR * LPMIB_ENTRY;


typedef struct  _MIB_ENTRIES {

    AsnObjectIdentifier  *  pOidPrefix;  // Oid with prefix for MIB ENTRIES
    int                     cMibEntries; // count of MIB_ENTRIES in the array
    LPMIB_ENTRY             prgMibEntry; // ptr to array of MIB_ENTRIES

} MIB_ENTRIES, FAR * LPMIB_ENTRIES;

//
// GET_OID_LENGTH( oid)  gets the length of the oid.
//

# define  GET_OID_LENGTH( oid)           ((oid).idLength)

//
//  Macro to determine number of sub-oid's in an array of UINTs.
//

#define OID_SIZEOF( uiArray )      ( sizeof( uiArray) / sizeof(UINT) )

//
// OID_FROM_UINT_ARRAY():  Macro to define OID from an Array of UINTs
//
# define OID_FROM_UINT_ARRAY( uiArray)   { OID_SIZEOF( uiArray), uiArray }


//
// Macros for creating MIB Entries ( as specified in struct _MIB_ENTRY above)
//  MIB_ENTRY_HEADER:  creates a generic MIB_ENTRY for a MIB group header.
//  MIB_ENTRY_ITEM:    creates a generic MIB_ENTRY for a MIB variable.
//  MIB_COUNTER:       creates a counter type MIB_ENTRY
//  MIB_INTEGER:       creates an integer type MIB_ENTRY
//

# define MIB_ENTRY_HEADER( oid)             \
           {   oid,                         \
               -1,                          \
               MIB_NOACCESS,                \
               NULL,                        \
               ASN_RFC1155_OPAQUE,          \
           }

# define MIB_ENTRY_ITEM( oid, offset, access, type, func)  \
           {   oid,            \
               offset,         \
               access,         \
               ( func),        \
               ( type),        \
           }

# define MIB_COUNTER( oid, field, func)    \
     MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_RFC1155_COUNTER, func)

# define MIB_INTEGER( oid, field, func)    \
           MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_INTEGER, func)

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind * pRfcVarBinding,
   IN BYTE                 pduAction,
   IN LPVOID               pStatistics,
   IN LPMIB_ENTRIES        pMibEntries
  );


UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   );



# endif // _MIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\faildrive\main.cpp ===
#include <windows.h>
#include <winbase.h>
#include <objbase.h>
#include <iostream.h>
#include <stdio.h>
#include <crtdbg.h>
#include <stdio.h>

#include "fail_i.c"
#include "fail.h"



int __cdecl main(int argc, char **argv)
{
	HRESULT		hr = OleInitialize(NULL);
	wchar_t		progid[] = L"ss.ss.1";
	CLSID		clsid;
	IDispatch	*pdispPtr = NULL;
	Iss		*piReq;
	DWORD		cCount = 0;

	if ( FAILED( hr ) ) {// Oleinit 
		cout << "Oleinitialize fail" << endl;
		exit( 1 );
	}

	

	hr = CLSIDFromProgID(	progid,
							&clsid	);
	
	if ( FAILED( hr ) ) {
		cout << "Unable to get class id" 
			 << hr
			 << endl;

		exit(1);
	}

	
	hr = CoCreateInstance(	clsid,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_Iss,
							(void **)&pdispPtr	);
	if  ( FAILED ( hr ) ) {
		printf("Cocreat fail %x\n", hr);
		printf("%x\n", REGDB_E_CLASSNOTREG);
		printf("%x\n", CLASS_E_NOAGGREGATION);
		exit(1);  
	}

	piReq = (Iss *)pdispPtr;

	hr = piReq->DoQuery();
	cout << hr << endl;

		

	piReq->Release();


	OleUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\faildrive\fail.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0106 */
/* at Fri Aug 15 00:36:07 1997
 */
/* Compiler settings for d:\ex\stacks\src\news\search\qryobj2\fail.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fail_h__
#define __fail_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __Iss_FWD_DEFINED__
#define __Iss_FWD_DEFINED__
typedef interface Iss Iss;
#endif 	/* __Iss_FWD_DEFINED__ */


#ifndef __ss_FWD_DEFINED__
#define __ss_FWD_DEFINED__

#ifdef __cplusplus
typedef class ss ss;
#else
typedef struct ss ss;
#endif /* __cplusplus */

#endif 	/* __ss_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __Iss_INTERFACE_DEFINED__
#define __Iss_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Iss
 * at Fri Aug 15 00:36:07 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Iss;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C99F41AF-08FC-11D1-922A-00AA00C148BE")
    Iss : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown __RPC_FAR *piUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndPage( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoQuery( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IssVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Iss __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Iss __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Iss __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Iss __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Iss __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Iss __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Iss __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPage )( 
            Iss __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndPage )( 
            Iss __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoQuery )( 
            Iss __RPC_FAR * This);
        
        END_INTERFACE
    } IssVtbl;

    interface Iss
    {
        CONST_VTBL struct IssVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Iss_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Iss_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Iss_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Iss_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Iss_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Iss_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Iss_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Iss_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define Iss_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define Iss_DoQuery(This)	\
    (This)->lpVtbl -> DoQuery(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE Iss_OnStartPage_Proxy( 
    Iss __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piUnk);


void __RPC_STUB Iss_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE Iss_OnEndPage_Proxy( 
    Iss __RPC_FAR * This);


void __RPC_STUB Iss_OnEndPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Iss_DoQuery_Proxy( 
    Iss __RPC_FAR * This);


void __RPC_STUB Iss_DoQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Iss_INTERFACE_DEFINED__ */



#ifndef __FAILLib_LIBRARY_DEFINED__
#define __FAILLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: FAILLib
 * at Fri Aug 15 00:36:07 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_FAILLib;

EXTERN_C const CLSID CLSID_ss;

#ifdef __cplusplus

class DECLSPEC_UUID("C99F41B0-08FC-11D1-922A-00AA00C148BE")
ss;
#endif
#endif /* __FAILLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\offquery\offquery.h ===
#include <windows.h>
#define OLEDBVER 0x0250 // enable ICommandTree interface
#include <ole2.h>
#include <oledb.h>
#include <oledbdep.h>
#include <cmdtree.h>

// the maximum number of columns that the user can request in their
// comma delimited list
#define MAX_COLUMNS 6
#define MAX_FRIENDLYNAME 128

class CIndexServerQuery {
    public:
        CIndexServerQuery();
        //
        // start the query going.  
        //
        // arguments:
        // [in] bDeepQuery - TRUE if deep query, FALSE if shallow
        // [in] pwszQueryString - the tripoli query string
        // [in] pwszMachine - the machine to query against (NULL for localhost)
        // [in] pwszCatalog - the tripoli catalog to query against (name or
        //                    path is okay).
        // [in] pwszScope - the tripoli scope to query against.  NULL for the
        //                  default scope (\).
        // [in] pwszColumns - the columns to return.  supported columns are
        //                    filename,newsarticleid,newsgroup,newsmsgid.  
        //                    note: this string gets altered internally, so
        //                    it might change from what you pass in.
        // [in] pwszSortOrder - sort priority for the columns.  NULL to return
        //                      unsorted
        //
        HRESULT MakeQuery( BOOL bDeepQuery, WCHAR const *pwszQueryString,
            WCHAR const *pwszMachine, WCHAR const *pwszCatalog,
            WCHAR const *pwszScope, WCHAR *pwszColumns, WCHAR const *pwszSortOrder,
			LCID LocaleID = GetSystemDefaultLCID());
        //
        // get the results from the query
        //
        // arguments:
        // [in] pcResults - pointer to the a size of the ppvResults array
        // [out] pcResults - the number of items put into ppvResults
        // [in/out] ppvResults - an array of pointers to PROPVARIANTS.  this is
        //                       filled in by column for up to *pcResults
        //                       rows.
        // [out] pfMore - set to TRUE if there are more results, FALSE if
        //                this is the last set of results.
        //
        // usage:
        // DWORD cResults;
        // PROPVARIANT *rgpvResults[COLUMNS * ROWS];
        // BOOL fMore;
        // cResults = ROWS;
        // HRESULT hr;
        // hr = GetQueryResults(&cResults, rgpvResults, &fMore);
        // if (FAILED(hr)) /* handle error */
        // else {
        //    for (i = 0; i < ROWS; i++) {
        //       PROPVARIANT **ppvColumn = rgpvResults + (j * ROWS);
        //       /* ppvColumn[0] has column 0 in row j */
        //       /* ppvColumn[1] has column 1 in row j */
        //       /* etc... */
        //    }
        // }
        //
        HRESULT GetQueryResults(DWORD *pcResults, PROPVARIANT **ppvResults, 
                                BOOL *pfMore);
        ~CIndexServerQuery();

    private:
        HACCESSOR       m_hAccessor;
        IRowset         *m_pRowset;
        DWORD           m_cCols;
        BOOL            m_fNoMoreRows;
        HROW            *m_phRows;
        DWORD           m_cRowHandlesAllocated;
        DWORD           m_cRowHandlesInUse;
		struct tagCIPROPERTYDEF	*m_pPropDef;
		DWORD			m_cPropDef;

        HRESULT CreateAccessor(WCHAR *szColumns);
		HRESULT BuildFriendlyNames(const WCHAR *pwszQueryString);
        void ReleaseAccessor();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\faildrive\fail_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.03.0106 */
/* at Fri Aug 15 00:36:07 1997
 */
/* Compiler settings for d:\ex\stacks\src\news\search\qryobj2\fail.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_Iss = {0xC99F41AF,0x08FC,0x11D1,{0x92,0x2A,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


const IID LIBID_FAILLib = {0xC99F41A2,0x08FC,0x11D1,{0x92,0x2A,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


const CLSID CLSID_ss = {0xC99F41B0,0x08FC,0x11D1,{0x92,0x2A,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\offquery\offquery.cpp ===
#define INC_OLE2
#define UNICODE

#include <stdio.h>
#include <windows.h>

#define OLEDBVER 0x0250 // enable ICommandTree interface

#include <oledberr.h>
#include <oledb.h>
#include <cmdtree.h>
#include <oledbdep.h>
#include <query.h>
#include <ntquery.h>
#include <stgprop.h>
#define NTSTATUS HRESULT
#include <dbcmdtre.hxx>
#include <vquery.hxx>
#include <isquery.h>
#include <dbgtrace.h>

// {AA568EEC-E0E5-11cf-8FDA-00AA00A14F93}
GUID CLSID_NNTP_SummaryInformation =
{ 0xaa568eec, 0xe0e5, 0x11cf, { 0x8f, 0xda, 0x0, 0xaa, 0x0, 0xa1, 0x4f, 0x93 } };

static GUID guidSystem = PSGUID_STORAGE;
static GUID guidNews = CLSID_NNTP_SummaryInformation;
static CDbColId psNewsgroup(guidNews, 0x2);
static CDbColId psNewsArticleID(guidNews, 0x3c);
static CDbColId psNewsMessageID(guidNews, 0x7);
static CDbColId psFilename(guidSystem, 0xa);
static CDbColId psNewsFrom(guidNews, 0x6);
static CDbColId psNewsSubject(guidNews, 0x5);

static struct {
    WCHAR wszColumnName[16];
    CDbColId *pdbidColumn;
} rgColumnMap[] = {
    { L"filename",      &psFilename         },
    { L"newsarticleid", &psNewsArticleID    },
    { L"newsfrom",      &psNewsFrom         },
    { L"newsgroup",     &psNewsgroup        },
    { L"newsmsgid",     &psNewsMessageID    },
    { L"newssubject",   &psNewsSubject      },
    { NULL,             0                   }
};

static DBBINDING skelbinding = {
    0,4*0,0,0,0,0,0, DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED,
    DBPARAMIO_NOTPARAM, 0, 0,  DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0
};

CIndexServerQuery::CIndexServerQuery() {
    m_pRowset = NULL;
    m_hAccessor = NULL;
    m_cRowHandlesInUse = 0;
    m_phRows = NULL;
	m_cPropDef = 0;
	m_pPropDef = 0;
}

//
// build an Accessor for the rowset given the names of the rows that we
// are interested in.
//
// Arguments:
//  [in] wszCols - the columns that you are interested in, comma delimited
//
HRESULT CIndexServerQuery::CreateAccessor(WCHAR *szColumns) {
    TraceFunctEnter("CIndexServerQuery::CreateAccessor");

    IColumnsInfo *pColumnsInfo = NULL;
    DBBINDING rgBindings[MAX_COLUMNS];
    IAccessor *pIAccessor = NULL;
    DBID rgColumnIDs[MAX_COLUMNS];
    ULONG rgMappedColumnIDs[MAX_COLUMNS];
    DWORD i, cCols;
    WCHAR *rgszColumn[MAX_COLUMNS];

    //
    // find the column names
    //
    cCols = 1;
    rgszColumn[0] = szColumns;
    for (i = 0; szColumns[i] != 0; i++) {
        if (szColumns[i] == ',') {
            // check to make sure we don't overflow rgszColumn
            if (cCols == MAX_COLUMNS) {
                ErrorTrace((DWORD) this, "too many columns passed into CreateAccessor");
                TraceFunctLeave();
                return E_INVALIDARG;
            }
            rgszColumn[cCols] = szColumns + i + 1;
            if (*rgszColumn[cCols] == 0) {
                ErrorTrace((DWORD) this, "trailing comma found in szColumns");
                TraceFunctLeave();
                return E_INVALIDARG;
            }
            cCols++;
            szColumns[i] = 0;
        }
    }

    //
    // map the column names passed in by the user into column IDs
    //
    DebugTrace((DWORD) this, "%i columns in szColumns", cCols);
    for (i = 0; i < cCols; i++) {
        DWORD j;
        for (j = 0; rgColumnMap[j].wszColumnName != NULL; j++) {
            DWORD x = lstrcmpi(rgColumnMap[j].wszColumnName, rgszColumn[i]);

            if (x == 0) {
                rgColumnIDs[i] = *(rgColumnMap[j].pdbidColumn);
                DebugTrace((DWORD) this, "Column %i is %ws", i, rgszColumn[i]);
                break;
            }
        }
        // check to make sure that we found a matching column
        if (rgColumnMap[j].wszColumnName == NULL) {
            ErrorTrace((DWORD) this, "unsupported column %ws in szColumns", rgszColumn[i]);
            TraceFunctLeave();
            return E_INVALIDARG;
        }
    }

    //
    // get a IColumnsInfo interface and use it to map the column IDs
    //
    HRESULT hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **)&pColumnsInfo);
    if (FAILED(hr)) {
        ErrorTrace((DWORD) this, "QI(IID_IColumnsInfo) returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }
    hr = pColumnsInfo->MapColumnIDs(cCols, rgColumnIDs, rgMappedColumnIDs);
    pColumnsInfo->Release();
    if (FAILED(hr)) {
        ErrorTrace((DWORD) this, "MapColumnIDs returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }

    //
    // build up the binding array
    //
    for (i = 0; i < cCols; i++) {
        memcpy(&(rgBindings[i]), &(skelbinding), sizeof(DBBINDING));
        rgBindings[i].obValue = 4 * i;
        rgBindings[i].iOrdinal = rgMappedColumnIDs[i];
    }

    //
    // get the IAccessor interface and use that to build an accessor to
    // these columns.
    //
    hr = m_pRowset->QueryInterface( IID_IAccessor, (void **)&pIAccessor);
    if (FAILED(hr)) {
        ErrorTrace((DWORD) this, "QI(IID_IAccessor) returned 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }
    hr = pIAccessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                    cCols, rgBindings, 0, &m_hAccessor, 0 );
    pIAccessor->Release();

    m_cCols = cCols;

    DebugTrace((DWORD) this, "returning 0x%08x", hr);
    TraceFunctLeave();
    return hr;
}

//
// release's an accessor that was created with CreateAccessor
//
void CIndexServerQuery::ReleaseAccessor() {
    TraceFunctEnter("CIndexServerQuery::ReleaseAccessor");

    IAccessor * pIAccessor = 0;

    HRESULT hr = m_pRowset->QueryInterface(IID_IAccessor, (void **)&pIAccessor);
    if (FAILED(hr)) {
        DebugTrace((DWORD) this, "QI(IID_IAccessor) returned 0x%08x", hr);
        TraceFunctLeave();
        return;
    }

    hr = pIAccessor->ReleaseAccessor( m_hAccessor, 0 );
    if (FAILED(hr)) DebugTrace((DWORD) this, "ReleaseAccessor returned 0x%08x", hr);
    m_hAccessor = NULL;
    hr = pIAccessor->Release();
    if (FAILED(hr)) DebugTrace((DWORD) this, "pAccessor->Release returned 0x%08x", hr);

    TraceFunctLeave();
}

// 
// scan the query string and see if there are property names that are being
// queried that don't have friendly names.  if there are then we build up
// new friendly names
//
#define HEADERPREFIX L"@MSGH-"
#define HEADERPREFIXLEN 6
HRESULT CIndexServerQuery::BuildFriendlyNames(const WCHAR *pwszQueryString) {
	TraceFunctEnter("CIndexServerQuery::BuildFriendlyNames");
	
	const WCHAR *pwszHeaderPrefix;
	DWORD cFriendlyNames = 0;

	// count the number of friendly names in the string
	pwszHeaderPrefix = pwszQueryString;
	do {
		pwszHeaderPrefix = wcsstr(pwszHeaderPrefix, HEADERPREFIX);
		if (pwszHeaderPrefix != NULL) {
			cFriendlyNames++;
			pwszHeaderPrefix += HEADERPREFIXLEN;
		}
	} while (pwszHeaderPrefix != NULL);

	if (cFriendlyNames == 0) return S_OK;

	m_pPropDef = new CIPROPERTYDEF[cFriendlyNames];
	if (m_pPropDef == NULL) return E_OUTOFMEMORY;

	ZeroMemory(m_pPropDef, sizeof(CIPROPERTYDEF) * cFriendlyNames);

	pwszHeaderPrefix = wcsstr(pwszQueryString, HEADERPREFIX);
	while (pwszHeaderPrefix != NULL) {
		// copy from past the Mime to the next space into the friendly name
		WCHAR *pwszFriendlyName = new WCHAR[MAX_FRIENDLYNAME];
		if (pwszFriendlyName == NULL) {
			ErrorTrace((DWORD) this, "couldn't allocate mem for new friendlyname");
			TraceFunctLeave();
			return E_OUTOFMEMORY;
		}
		wcscpy(pwszFriendlyName, HEADERPREFIX + 1);
		WCHAR *pwszHeaderName = pwszFriendlyName + HEADERPREFIXLEN - 1;
		const WCHAR *p = pwszHeaderPrefix + HEADERPREFIXLEN;
		for (DWORD i = HEADERPREFIXLEN - 1; *p != 0 && *p != ' '; p++, i++) {
			if (i >= MAX_FRIENDLYNAME) {
				ErrorTrace((DWORD) this, "friendlyname %S is too long",
					pwszHeaderPrefix);
				TraceFunctLeave();
				return E_INVALIDARG;
			}
			pwszFriendlyName[i] = *p;
		}
		pwszFriendlyName[i] = 0;

		// see if this property has already been defined
		BOOL fFound = FALSE;
		for (DWORD m_iPropDef = 0; m_iPropDef < m_cPropDef; m_iPropDef++) {
			if (lstrcmpiW(m_pPropDef[m_iPropDef].wcsFriendlyName, pwszFriendlyName)) {
				fFound = TRUE;
			}
		}

		// if it hasn't been defined then add it to the list of defined
		// properties
		if (!fFound) {
			// build a new CIPROPERTYDEF
			_ASSERT(m_cPropDef <= cFriendlyNames);
			m_pPropDef[m_cPropDef].wcsFriendlyName = pwszFriendlyName;
			m_pPropDef[m_cPropDef].dbType = DBTYPE_WSTR;
			m_pPropDef[m_cPropDef].dbCol.eKind = DBKIND_GUID_NAME;
			m_pPropDef[m_cPropDef].dbCol.uGuid.guid = guidNews;
			m_pPropDef[m_cPropDef].dbCol.uName.pwszName = pwszHeaderName;

			DebugTrace((DWORD) this, "new friendly name %S", pwszFriendlyName);
			DebugTrace((DWORD) this, "pwszHeaderName = %S", pwszHeaderName);
			BinaryTrace((DWORD) this, (BYTE *) &guidNews, sizeof(guidNews));

			m_cPropDef++;
		}

		// p points to the end of the @MsgH-<header> part, where we might
		// expect to find another such word.
		pwszHeaderPrefix = wcsstr(p, HEADERPREFIX);
	}

	DebugTrace((DWORD) this, "defined %lu friendly names", m_cPropDef);
	TraceFunctLeave();
	return S_OK;
}

//
// make a query
//
// Arguments:
//  bDeepQuery - [in] TRUE if deep query, FALSE if shallow
//  pwszQueryString - [in] the Tripoli query string
//  pwszMachine - [in] the machine to query against (. for localhost)
//  pwszCatalog - [in] the catalog to query against
//  pwszScope - [in] the scope to query against
//  pwszColumns - [in] the columns to return.
//                Supports filename, newsgroup, newsarticleid
//  pwszSortOrder - [in] how to sort the above columns
//
HRESULT CIndexServerQuery::MakeQuery(BOOL bDeepQuery,
                                     WCHAR const *pwszQueryString,
                                     WCHAR const *pwszMachine,
                                     WCHAR const *pwszCatalog, 
                                     WCHAR const *pwszScope,
                                     WCHAR *pwszColumns, 
                                     WCHAR const *pwszSortOrder,
									 LCID LocalID,
									 DWORD dwMaxRows)
{
    TraceFunctEnter("MakeQuery");

    ULONG rgDepths[] = { bDeepQuery ? QUERY_DEEP : QUERY_SHALLOW};
    WCHAR const *rgScopes[] = { (pwszScope == NULL) ? L"\\" : pwszScope };
    WCHAR const *rgCatalogs[] = { pwszCatalog };
    WCHAR const *rgMachines[] = { (pwszMachine == NULL) ? L"." : pwszMachine };
    ICommand *pCommand = 0;

    DebugTrace((DWORD) this, "pwszQueryString = %ws", pwszQueryString);
    DebugTrace((DWORD) this, "pwszMachine = %ws", pwszMachine);
    DebugTrace((DWORD) this, "pwszCatalog = %ws", pwszCatalog);
    DebugTrace((DWORD) this, "pwszScope = %ws", pwszScope);
    DebugTrace((DWORD) this, "pwszColumns = %ws", pwszColumns);
    DebugTrace((DWORD) this, "pwszSortOrder = %ws", pwszSortOrder);

	_ASSERT(pwszColumns != NULL);
	if (pwszCatalog == NULL || pwszColumns == NULL) {
		ErrorTrace((DWORD) this, "pwszCatalog == NULL or pwszColumns == NULL");
		TraceFunctLeave();
		return E_POINTER;
	}

    _ASSERT(m_pRowset == NULL);
    if (m_pRowset != NULL) {
        ErrorTrace((DWORD) this, "MakeQuery called with pRowset != NULL");
        TraceFunctLeave();
        return E_UNEXPECTED;
    }

	HRESULT hr = BuildFriendlyNames(pwszQueryString);
	if (FAILED(hr)) return hr;

    DebugTrace((DWORD) this, "calling CIMakeICommand");
    hr = CIMakeICommand(&pCommand,
                               1,
                               rgDepths,
                               (WCHAR const * const *) rgScopes,
                               (WCHAR const * const *) rgCatalogs,
                               (WCHAR const * const *) rgMachines);

    if (SUCCEEDED(hr))
    {
        const unsigned MAX_PROPS = 8;
        DBPROPSET aPropSet[MAX_PROPS];
        DBPROP aProp[MAX_PROPS];
        ULONG cProps = 0;

        // We can handle PROPVARIANTs, not just ole automation variants
        static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
        static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

        aProp[cProps].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProps].dwOptions = DBPROPOPTIONS_SETIFCHEAP;
        aProp[cProps].dwStatus = 0;
        aProp[cProps].colid = dbcolNull;
        aProp[cProps].vValue.vt = VT_BOOL;
        aProp[cProps].vValue.boolVal = VARIANT_TRUE;
        aPropSet[cProps].rgProperties = &aProp[cProps];
        aPropSet[cProps].cProperties = 1;
        aPropSet[cProps].guidPropertySet = guidQueryExt;
        cProps++;

        ICommandProperties *pCmdProp = 0;
        hr = pCommand->QueryInterface(IID_ICommandProperties,
                                      (void **)&pCmdProp);
        if (SUCCEEDED(hr)) {
            DebugTrace((DWORD) this, "calling SetProperties");
            hr = pCmdProp->SetProperties( cProps, aPropSet );
            pCmdProp->Release();
        }

        DBCOMMANDTREE *pTree;
        DebugTrace((DWORD) this, "calling CITextToFullTree");
        hr = CITextToFullTree(pwszQueryString,              // query
                              pwszColumns,                  // columns
                              pwszSortOrder,                // sort
                              0,                            // grouping
                              &pTree,                       // resulting tree
                              m_cPropDef,                   // custom properties
                              m_pPropDef,                   // custom properties
                              LocalID);      			    // default locale

        if (SUCCEEDED(hr)) {
            ICommandTree *pCmdTree = NULL;
            hr = pCommand->QueryInterface(IID_ICommandTree,
                                          (void **)&pCmdTree);

            DebugTrace((DWORD) this, "calling SetCommandTree");
            hr = pCmdTree->SetCommandTree(&pTree, DBCOMMANDREUSE_NONE, FALSE);
            pCmdTree->Release();
            IRowset *pRowset = 0;

            if (SUCCEEDED(hr)) {
                DebugTrace((DWORD) this, "calling Execute");
                hr = pCommand->Execute(0,            // no aggr. IUnknown
                                       IID_IRowset,  // IID for i/f to return
                                       0,            // disp. params
                                       0,            // chapter
                                       (IUnknown **) &pRowset );

	            if (SUCCEEDED(hr))
	            {
	                DebugTrace((DWORD) this, "calling CreateAccessor");
	
	                m_pRowset = pRowset;
	
	                hr = CreateAccessor(pwszColumns);
	
	                m_fNoMoreRows = FALSE;
	                m_phRows = NULL;
	                m_cRowHandlesInUse = 0;
	                m_cRowHandlesAllocated = 0;
	            }
			}
        }
        pCommand->Release();
    }

    DebugTrace((DWORD) this, "returning 0x%08x", hr);
    TraceFunctLeave();
    return hr;
}

//
// Get back some query results after making a query
//
// Arguments:
//  pcResults - [in/out] The number of results to retrieve.  When the function
//              returns is has the number of results retrieved
//  ppvResults - [out] The array of propvariant pointers to receive the results
//  pfMore - [out] Set to FALSE when there are no more results to retrieve
//
HRESULT CIndexServerQuery::GetQueryResults(DWORD *pcResults,
                                           PROPVARIANT **ppvResults,
                                           BOOL *pfMore)
{
    TraceFunctEnter("GetQueryResults");

    HRESULT hr;
    DWORD cDesiredRows;
    DWORD iCurrentRow;

    // check to make sure that they've called MakeQuery successfully
    if (m_pRowset == NULL) {
        ErrorTrace((DWORD) this, "GetQueryResults called without MakeQuery");
        TraceFunctLeave();
        return E_UNEXPECTED;
    }

    if (m_fNoMoreRows) {
        *pfMore = FALSE;
        TraceFunctLeave();
        return S_OK;
    }

    cDesiredRows = *pcResults;
    *pcResults = 0;
    *pfMore = TRUE;
    
    if (m_cRowHandlesInUse != 0) {
        m_pRowset->ReleaseRows(m_cRowHandlesInUse, m_phRows, 0, 0, 0);
        m_cRowHandlesInUse = 0;
        if (cDesiredRows > m_cRowHandlesAllocated) {
            delete[] m_phRows;
            m_phRows = NULL;
            m_cRowHandlesAllocated = 0;
        }
    }

    // allocate memory for the row handles
    if (cDesiredRows > m_cRowHandlesAllocated) {
        _ASSERT(m_phRows == NULL);
        m_phRows = new HROW[cDesiredRows];
        if (m_phRows == NULL) {
            DebugTrace((DWORD) this, "out of memory trying to alloc %lu row handles", cDesiredRows);
            return E_OUTOFMEMORY;
        }
        m_cRowHandlesAllocated = cDesiredRows;
    }

    // fetch some more rows from tripoli
    DebugTrace((DWORD) this, "getting more tripoli rows");
    hr = m_pRowset->GetNextRows(0,
                                0,
                                cDesiredRows,
                                &m_cRowHandlesInUse,
                                &m_phRows);

    DebugTrace((DWORD) this, "GetNextRows returned %lu rows", m_cRowHandlesInUse);

    // check for end of rowset
    if (hr == DB_S_ENDOFROWSET) {
        DebugTrace((DWORD) this, "GetNextRows returned end of rowset");
        hr = S_OK;
        m_fNoMoreRows = TRUE;
        *pfMore = FALSE;
    }

    if (FAILED(hr)) {
        ErrorTrace((DWORD) this, "GetNextRows failed with 0x%08x", hr);
        TraceFunctLeave();
        return hr;
    }

    // get the data for each of the rows
    for (iCurrentRow = 0; iCurrentRow < m_cRowHandlesInUse; iCurrentRow++) {
        // fetch the data for this row
        hr = m_pRowset->GetData(m_phRows[iCurrentRow], m_hAccessor,
                                ppvResults + ((*pcResults) * m_cCols));
        if (FAILED(hr)) {
            ErrorTrace((DWORD) this, "GetData failed with 0x%08x", hr);
            TraceFunctLeave();
            return hr;
        } else {
            (*pcResults)++;
        }
    }

    DebugTrace((DWORD) this, "*pcResults = %lu, *pfMore = %lu", *pcResults, *pfMore);

    TraceFunctLeave();
    return hr;
}

CIndexServerQuery::~CIndexServerQuery() {
    TraceFunctEnter("CIndexServerQuery");

	// clean up any custom named properties
	if (m_cPropDef != 0) {
		while (m_cPropDef-- != 0) {
			delete[] m_pPropDef[m_cPropDef].wcsFriendlyName;
		}
		delete[] m_pPropDef;
	} else {
		_ASSERT(m_pPropDef == NULL);
	}
    if (m_cRowHandlesInUse != 0) {
        m_pRowset->ReleaseRows(m_cRowHandlesInUse, m_phRows, 0, 0, 0);
        m_cRowHandlesInUse = 0;
    }
    if (m_phRows != NULL) {
        delete[] m_phRows;
        m_phRows = NULL;
        m_cRowHandlesAllocated = 0;
    }
    
    if (m_pRowset != NULL) {
        if (m_hAccessor != NULL) {
            DebugTrace((DWORD) this, "releasing accessor");
            ReleaseAccessor();
        }
        DebugTrace((DWORD) this, "releasing rowset");
        m_pRowset->Release();
        m_pRowset = NULL;
    }

    TraceFunctLeave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\nntpmib\mib.c ===
/*++  BUILD Version: 0001   // Increment this if a change has global effects.

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.c

   Abstract:

      This defines Auxiliary functions for defining an SNMP Extension Agent
         for collecting and querying Statistical information.

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Feb-1995

   Environment:

       User Mode -- Win32

   Project:

       SNMP Extension DLL for HTTP Service DLL

   Functions Exported:

     UINT  ResolveVarBinding();
     UINT  MibStatisticsWorker();

   Revision History:

--*/

# include "mib.h"

static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  );

static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics
  );


static VOID
PrintAsnObjectIdentifier( IN char * pszOidDescription,
                          IN AsnObjectIdentifier * pAsno)
{

    return;
} // PrintAsnObjectIdentifier()


UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind   * pRfcVarBinding,
   IN BYTE                   pduAction,
   IN LPVOID                 pStatistics,
   IN LPMIB_ENTRIES          pMibEntries
  )
/*++
  Description:
    This function resolves a single variable binding. Modifies the variable
       on a GET or a GET-NEXT.

  Arguments:
     pRfcVarBinding    pointer to RFC Variable Bindings
     pduAction      Protocol Data Unit Action specified.
     pStatistics    pointer to statisitcs data structure containing
                      values of counter data.
     pMibEntries    pointer to MIB_ENTRIES context information
                      which contains prefix, array of MIB_ENTRIES and
                      count of the entries.
  Returns:
    Standard PDU error codes.

  Note:
--*/
{
    AsnObjectIdentifier  AsnTempOid;
    LPMIB_ENTRY  pMibScan;
    UINT         pduResult = SNMP_ERRORSTATUS_NOERROR;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // Search for the variable binding name in the mib.
    //

    for( pMibScan = pMibEntries->prgMibEntry;
        pMibScan < pMibUpperBound;
        pMibScan++) {

        int iCmpResult;

        //
        // Create a fully qualified OID for the current item in the MIB.
        //  and use it for comparing against variable to be resolved.
        //

        SNMP_oidcpy( &AsnTempOid, pMibEntries->pOidPrefix);
        SNMP_oidappend( &AsnTempOid, &pMibScan->asnOid);

        iCmpResult = SNMP_oidcmp( &pRfcVarBinding->name, &AsnTempOid);
        SNMP_oidfree( &AsnTempOid);

        if ( iCmpResult == 0) {

            //
            // Found a match. Stop the search and process.
            //

            break;

        } else
          if ( iCmpResult < 0) {

              //
              // This could be the OID of a leaf ( withoug a trailing 0) or
              //  it could contain an invalid OID ( between valid OIDs).
              //

              if ( pduAction == MIB_GETNEXT) {

                  //
                  // Advance the variable binding to next entry
                  //
                  SNMP_oidfree( &pRfcVarBinding->name);
                  SNMP_oidcpy( &pRfcVarBinding->name,
                                pMibEntries->pOidPrefix);
                  SNMP_oidappend( &pRfcVarBinding->name, &pMibScan->asnOid);

                  if ( ( pMibScan->bType != ASN_RFC1155_OPAQUE) &&
                       ( pMibScan->bType != ASN_SEQUENCE)) {

                      pduAction = MIB_GET;
                  }

              } else {

                  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              }

              //
              // Stop and process the appropriate entry.
              //

              break;
          } // ( iCmpResult < 0)

    } // for


    if ( pMibScan >= pMibUpperBound) {

        pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // A match is found or further processing is required.
        //

        if ( pMibScan->pMibFunc == NULL) {

            //
            // This happens only if the match is for Group OID
            //

            pduResult = ( ( pduAction != MIB_GETNEXT) ?
                       SNMP_ERRORSTATUS_NOSUCHNAME:
                         MibGetNextVar( pRfcVarBinding,
                                       pMibScan,
                                       pMibEntries,
                                       pStatistics));
        } else {

            pduResult = ( pMibScan->pMibFunc) ( pRfcVarBinding,
                                               pduAction,
                                               pMibScan,
                                               pMibEntries,
                                               pStatistics);
        }
    }


    return ( pduResult);

} // ResolveVarBinding()

UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT   pduResult = SNMP_ERRORSTATUS_NOERROR;
                 // default indicating action to be done at end of switch

    switch( pduAction) {

      case MIB_SET:
      case MIB_GETNEXT:

        // action is performed at the end of switch statement.
        break;


      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  If no statistics do no action.
        //  If this is the header field ( non-leaf) do no action
        //   Otherwise, perform action as if this is the leaf node.
        //

        if ( pStatistics == NULL || pMibeCurrent->lFieldOffset == -1) {

            pduResult = SNMP_ERRORSTATUS_GENERR;
        }

        // Action on this node is performed at the end of the switch statement.
        break;

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch()


    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // Use the generic leaf function to perform the action specified.
        //
        pduResult = MibLeafFunction( pRfcVarBinding, pduAction, pMibeCurrent,
                                    pMibEntries, pStatistics);
    }

    return ( pduResult);

} // MibStatisticsWorker()




static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics
    and that this is a leaf node of the MIB tree.
  This is a generic function for leaf nodes.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;  // default is error value.

    switch( pduAction ) {

      case MIB_GETNEXT:

        //
        //  Determine if we're within the range and not at the end.
        //  If not within the range the above default pduResult == NOSUCHNAME
        //         is the required error message.
        //

        if ( ( pMibeCurrent >= pMibEntries->prgMibEntry) &&
             ( pMibeCurrent <
              ( pMibEntries->prgMibEntry + pMibEntries->cMibEntries))) {

            pduResult = MibGetNextVar( pRfcVarBinding,
                                      pMibeCurrent,
                                      pMibEntries,
                                      pStatistics);
        }

        break;

      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  Make sure that this variable's ACCESS is GET'able.
        //  If the access prohibits from GETting it, report error as
        //    NOSUCHNAME ( default value of pduResult in initialization above)
        //

        if(( pMibeCurrent->uiAccess == MIB_ACCESS_READ ) ||
           ( pMibeCurrent->uiAccess == MIB_ACCESS_READWRITE ) ) {

            DWORD  dwValue;

            //
            //  Setup pRfcVarBinding's return value.
            //

            pRfcVarBinding->value.asnType = pMibeCurrent->bType;
            dwValue = *( (LPDWORD )((LPBYTE )pStatistics +
                                    pMibeCurrent->lFieldOffset));

            pduResult = SNMP_ERRORSTATUS_NOERROR;  // we found a value.

            switch( pMibeCurrent->bType)  {

              case ASN_RFC1155_GAUGE:
                pRfcVarBinding->value.asnValue.gauge = (AsnGauge ) dwValue;
                break;

              case ASN_RFC1155_COUNTER:
                pRfcVarBinding->value.asnValue.counter = (AsnCounter ) dwValue;
                break;

              case ASN_INTEGER:
                pRfcVarBinding->value.asnValue.number = (AsnInteger ) dwValue;
                break;

              case ASN_RFC1155_IPADDRESS:
              case ASN_OCTETSTRING:
                //
                //  Not supported for this MIB (yet).
                //  Fall through to indicate generic error.
                //

              default:

                //
                // Sorry! Type in Mibe does not suit our purpose.
                //   Indicate generic error.
                //
                pduResult = SNMP_ERRORSTATUS_GENERR;
                break;
            } // innner switch

        } // if ( valid read access)

        break;

      case MIB_SET:

        //
        //  We don't support settable variables (yet).
        //   Fall through for error.
        //

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch ( pduAction)


    return ( pduResult);

} // MibLeafFunction()





static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics)
/*++
  Description:
     This function sets the binding variable to iterate to the next variable.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.

  Returns:
     PDU Error Codes.
--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // If within the range of MIB ENTRIES process.
    //

    if ( pMibeCurrent >= pMibEntries->prgMibEntry) {

        //
        //  Scan through the remaining MIB Entries
        //

        LPMIB_ENTRY  pMibeScan;

        for( pMibeScan = pMibeCurrent+1;
             pMibeScan < pMibUpperBound;
             pMibeScan++ ) {

            //
            // Setup variable bindings for the next MIB variable
            //

            SNMP_oidfree( &pRfcVarBinding->name);
            SNMP_oidcpy( &pRfcVarBinding->name, pMibEntries->pOidPrefix);
            SNMP_oidappend( &pRfcVarBinding->name, &pMibeScan->asnOid);

            //
            //  If the function pointer is not NULL and the type of the MIB
            //  variable is anything but OPAQUE, then call the function to
            //  process the MIB variable.
            //

            if(( pMibeScan->pMibFunc != NULL ) &&
               ( pMibeScan->bType    != ASN_RFC1155_OPAQUE ) ) {

                pduResult = ( pMibeScan->pMibFunc)( pRfcVarBinding,
                                                   MIB_GETFIRST,
                                                   pMibeScan,
                                                   pMibEntries,
                                                   pStatistics);
                break;
            }

            //
            // On failure in the scan, pduResult will have default value
            //    as initialized above in declaration.
            //

        } // for
    }

    return ( pduResult);

} // MibGetNextVar()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\faildrive\fail_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 3.01.75 */
/* at Wed Jul 30 10:13:07 1997
 */
/* Compiler settings for fail.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY

#include "rpcproxy.h"
#include "fail.h"

#define TYPE_FORMAT_STRING_SIZE   19                                
#define PROC_FORMAT_STRING_SIZE   61                                

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: Iss, ver. 0.0,
   GUID={0xC99F41AF,0x08FC,0x11D1,{0x92,0x2A,0x00,0xAA,0x00,0xC1,0x48,0xBE}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO Iss_ServerInfo;

#pragma code_seg(".orpc")

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    0, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x301004b, /* MIDL Version 3.1.75 */
    0,
    0,
    0,  /* Reserved1 */
    0,  /* Reserved2 */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short Iss_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    24,
    42
    };

static const MIDL_SERVER_INFO Iss_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &Iss_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO Iss_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &Iss_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(10) _IssProxyVtbl = 
{
    &Iss_ProxyInfo,
    &IID_Iss,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* Iss::OnStartPage */ ,
    (void *)-1 /* Iss::OnEndPage */ ,
    (void *)-1 /* Iss::DoQuery */
};


static const PRPC_STUB_FUNCTION Iss_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IssStubVtbl =
{
    &IID_Iss,
    &Iss_ServerInfo,
    10,
    &Iss_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure OnStartPage */

			0x33,		/* FC_AUTO_HANDLE */
			0x64,		/* 100 */
/*  2 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  4 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x8 ),	/* 8 */
/* 10 */	0x6,		/* 6 */
			0x2,		/* 2 */

	/* Parameter piUnk */

/* 12 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 14 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 16 */	NdrFcShort( 0x0 ),	/* Type Offset=0 */

	/* Return value */

/* 18 */	NdrFcShort( 0x70 ),	/* 112 */
#ifndef _ALPHA_
/* 20 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 22 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure OnEndPage */

/* 24 */	0x33,		/* FC_AUTO_HANDLE */
			0x64,		/* 100 */
/* 26 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 28 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */
/* 32 */	NdrFcShort( 0x8 ),	/* 8 */
/* 34 */	0x4,		/* 4 */
			0x1,		/* 1 */

	/* Return value */

/* 36 */	NdrFcShort( 0x70 ),	/* 112 */
#ifndef _ALPHA_
/* 38 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DoQuery */

/* 42 */	0x33,		/* FC_AUTO_HANDLE */
			0x64,		/* 100 */
/* 44 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 46 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x8 ),	/* 8 */
/* 52 */	0x4,		/* 4 */
			0x1,		/* 1 */

	/* Return value */

/* 54 */	NdrFcShort( 0x70 ),	/* 112 */
#ifndef _ALPHA_
/* 56 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 58 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x0 ),	/* 0 */
/* 10 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 12 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 14 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 16 */	0x0,		/* 0 */
			0x46,		/* 70 */

			0x0
        }
    };

const CInterfaceProxyVtbl * _fail_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IssProxyVtbl,
    0
};

const CInterfaceStubVtbl * _fail_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IssStubVtbl,
    0
};

PCInterfaceName const _fail_InterfaceNamesList[] = 
{
    "Iss",
    0
};

const IID *  _fail_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _fail_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _fail, pIID, n)

int __stdcall _fail_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_fail_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo fail_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _fail_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _fail_StubVtblList,
    (const PCInterfaceName * ) & _fail_InterfaceNamesList,
    (const IID ** ) & _fail_BaseIIDList,
    & _fail_IID_Lookup, 
    1,
    2
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\makefile.inc ===
$(O)\meta2.h $(O)\meta2_i.c : meta2.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\meta2_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\meta2_i.c \
    -header $@ \
    -tlb $(O)\meta2.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\search.h $(O)\search_i.c : ..\qryobj\search.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\search_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\search_i.c \
    -header $@ \
    -tlb $(O)\search.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\meta2.cpp ===
// meta2.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f meta2ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "meta2.h"

#include "meta2_i.c"
#include <initguid.h>
#include "req.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_req, Creq)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\guids.c ===
//
//  Keep the top part in sync with stdafx.h
//
#include <windows.h>
#include <ole2.h>


#define  INITGUIDS
#include "initguid.h"

#include "iadmw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\metakey.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metakey.cpp

Abstract:

	A class to help manipulate metabase keys.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#include "stdafx.h"
#include "metakey.h"

#include <stdio.h>


#define _WIN32_WINNT 0x0400
#include <objbase.h>

#define MD_DEFAULT_TIMEOUT      5000
static BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey );

//$-------------------------------------------------------------------
//
//	CreateMetabaseObject
//
//	Description:
//
//		Creates an instance of the metabase object on the given
//		machine and initializes it.
//
//	Parameters:
//
//		wszMachine - The machine to create the metabase on.
//		ppMetabase - Returns the resulting metabase pointer.
//
//	Returns:
//
//		Error code from CoCreateInstance or the metabase routines.
//
//--------------------------------------------------------------------

HRESULT CreateMetabaseObject ( LPCWSTR wszMachine, IMSAdminBase ** ppMetabaseResult )
{
	TraceFunctEnter ( "CreateMetabaseObject" );

	// Check parameters:
	_ASSERT ( ppMetabaseResult != NULL );
	_ASSERT ( IS_VALID_OUT_PARAM ( ppMetabaseResult ) );

	if ( ppMetabaseResult == NULL ) {
		FatalTrace ( 0, "Bad Return Pointer" );

		TraceFunctLeave ();
		return E_POINTER;
	}

	// Variables:
	HRESULT				hr	= NOERROR;
	CComPtr<IMSAdminBase>	pMetabase;
	MULTI_QI			mqi[1];
	COSERVERINFO		coserver;

	// Zero the out parameter:
	*ppMetabaseResult = NULL;

	// QI for IID_IMSAdminBase:
	mqi[0].pIID	= &IID_IMSAdminBase;
	mqi[0].pItf	= NULL;
	mqi[0].hr	= 0;

	// Which remote server to talk to:
	coserver.dwReserved1	= 0;
	coserver.dwReserved2	= 0;
	coserver.pwszName		= const_cast<LPWSTR> (wszMachine);
	coserver.pAuthInfo		= NULL;

	// Create the object:
	hr = CoCreateInstanceEx (
		CLSID_MSAdminBase,
		NULL,
		CLSCTX_ALL,
		wszMachine ? &coserver : NULL,
		1,
		mqi );

	if ( FAILED(hr) ) {
		ErrorTraceX ( 0, "CoCreate(metabase) failed %x", hr );
		goto Exit;
	}

	if ( FAILED(mqi[0].hr) ) {
		hr = mqi[0].hr;
		ErrorTraceX ( 0, "QI(metabase) failed %x", hr );
		goto Exit;
	}

	// Get the interface pointer:
	pMetabase = (IMSAdminBase *) mqi[0].pItf;
    mqi[0].pItf->Release ();

	// Return the interface pointer:
	_ASSERT ( pMetabase );
	*ppMetabaseResult = pMetabase;
	pMetabase->AddRef();

Exit:
	TraceFunctLeave ();
	return hr;

	// pMetabase will be released automatically.
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CMetabaseKey
//
//	Description:
//
//		Initializes the CMetabaseKey
//
//	Parameters:
//
//		pMetabase - a pointer to the metabase object.
//
//--------------------------------------------------------------------

CMetabaseKey::CMetabaseKey ( IMSAdminBase * pMetabase )
{
	_ASSERT ( pMetabase );

	m_pMetabase				= pMetabase;
	m_hKey					= NULL;
	m_cChildren				= 0;
	m_cIntegerChildren		= 0;
	m_indexCursor			= 0;
	m_dwMaxIntegerChild		= 0;

	pMetabase->AddRef ();
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::~CMetabaseKey
//
//	Description:
//
//		Destroys the metabase key
//
//--------------------------------------------------------------------

CMetabaseKey::~CMetabaseKey ( )
{
	Close ();

	if ( m_pMetabase ) {
		m_pMetabase->Release ();
	}
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Open
//
//	Description:
//
//		Opens a key and associates that key with this object.
//
//	Parameters:
//
//		hParentKey - the already open key to use a base.
//		szPath - path of the key to open
//		dwPermissions - READ or WRITE access.
//
//	Returns:
//
//		see IMSAdminBase::OpenKey
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::Open ( METADATA_HANDLE hParentKey, IN LPCWSTR szPath, DWORD dwPermissions )
{
	TraceFunctEnter ( "CMetabaseKey::Open" );

	HRESULT		hr	= NOERROR;

	Close ();

	hr = m_pMetabase->OpenKey ( 
		hParentKey,
		szPath,
		dwPermissions,
		MD_DEFAULT_TIMEOUT,
		&m_hKey
		);

	if ( FAILED(hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to open key %s: %x", szPath, hr );
		goto Exit;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Attach
//
//	Description:
//
//		Attaches this object to an already opened metabase key.
//
//	Parameters:
//
//		hKey - the opened metabase key
//
//--------------------------------------------------------------------

void CMetabaseKey::Attach ( METADATA_HANDLE hKey )
{
	Close ();

	_ASSERT ( hKey != NULL );
	m_hKey = hKey;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Detach
//
//	Description:
//
//		Detaches the metabase key from this object and returns it
//
//	Returns:
//
//		The key handle that this object is holding.
//
//--------------------------------------------------------------------

METADATA_HANDLE CMetabaseKey::Detach ( )
{
	METADATA_HANDLE	hKeyResult;

	hKeyResult = m_hKey;
	m_hKey = NULL;

	return hKeyResult;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Close
//
//	Description:
//
//		Closes the key that this object has open.
//
//--------------------------------------------------------------------

void CMetabaseKey::Close ( )
{
	TraceFunctEnter ( "CMetabaseKey::Close" );

	HRESULT		hr;

	if ( m_hKey ) {
		hr = m_pMetabase->CloseKey ( m_hKey );

		_ASSERT ( SUCCEEDED(hr) );
		m_hKey = NULL;
	}

	TraceFunctLeave ();
}

void CMetabaseKey::GetLastChangeTime ( FILETIME * pftGMT, LPCWSTR wszPath )
{
	_ASSERT ( m_hKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( pftGMT ) );

	HRESULT		hr;

	hr = m_pMetabase->GetLastChangeTime ( m_hKey, wszPath, pftGMT, FALSE );
	_ASSERT ( SUCCEEDED(hr) );
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::Save
//
//	Description:
//
//		Saves the changes.
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::Save ( )
{
	TraceFunctEnter ( "CMetabaseKey::Save" );

	HRESULT		hr;

	hr = m_pMetabase->SaveData ( );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetChildCount
//
//	Description:
//
//		Returns the number of subkeys of the current metabase key.
//
//	Parameters:
//
//		pcChildren - resulting number of subkeys.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetChildCount ( OUT DWORD * pcChildren )
{
	_ASSERT ( m_hKey != NULL );

	if ( m_cChildren != 0 ) {
		*pcChildren = m_cChildren;
		return NOERROR;
	}

	HRESULT		hr;

	hr = CountSubkeys ( 
		NULL,
		&m_cChildren, 
		&m_cIntegerChildren, 
		NULL,
		&m_dwMaxIntegerChild 
		);

	*pcChildren = m_cChildren;
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetIntegerChildCount
//
//	Description:
//
//		Returns the number of integer subkeys of the current key.
//
//	Parameters:
//
//		pcIntegerChildren - the number of integer subkeys of the currently
//			opened key.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetIntegerChildCount ( OUT DWORD * pcIntegerChildren )
{
	_ASSERT ( m_hKey != NULL );

	if ( m_cChildren != 0 ) {
		*pcIntegerChildren = m_cIntegerChildren;
		return NOERROR;
	}

	HRESULT		hr;

	hr = CountSubkeys ( 
		NULL,
		&m_cChildren, 
		&m_cIntegerChildren, 
		NULL,
		&m_dwMaxIntegerChild 
		);

	*pcIntegerChildren = m_cIntegerChildren;
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::GetCustomChildCount
//
//	Description:
//
//		Returns the number of subkeys of the current metabase key
//		for which fpIsCustomKey returns true.
//
//	Parameters:
//
//		pcCustomChildren - resulting number of subkeys.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::GetCustomChildCount ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT DWORD * 		pcCustomChildren 
	)
{
	_ASSERT ( m_hKey != NULL );
	_ASSERT ( fpIsCustomKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcCustomChildren ) );

	HRESULT		hr;

	hr = CountSubkeys ( 
		fpIsCustomKey, 
		&m_cChildren, 
		&m_cIntegerChildren, 
		pcCustomChildren, 
		&m_dwMaxIntegerChild 
		);

	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::BeginChildEnumeration
//
//	Description:
//
//		Sets up the object to enumerate subkeys.
//		Call before calling NextChild or NextIntegerChild.
//
//--------------------------------------------------------------------

void CMetabaseKey::BeginChildEnumeration	 	( )
{
	TraceFunctEnter ( "CMetabaseKey::BeginChildEnumeration" );

	_ASSERT ( m_hKey != NULL );

	HRESULT	hr;

	m_indexCursor	= 0;

	StateTrace ( (LPARAM) this, "Changing to Read Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, 1, METADATA_PERMISSION_READ );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to change permissions to read: %x", hr );
	}

	TraceFunctLeave ();
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextChild
//
//	Description:
//
//		Returns the name of the next subkey.
//		Call BeginChildEnumeration before calling NextChild
//
//	Parameters:
//
//		szChildKey - the resulting key name
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextChild ( OUT LPWSTR wszChildKey )
{
	
	TraceFunctEnter ( "CMetabaseKey::NextChild" );


	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildKey ) );
	_ASSERT ( m_hKey != NULL );

	HRESULT		hr;

	*wszChildKey = NULL;

	// Use the m_indexCursor to enumerated the next child:
	hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszChildKey, m_indexCursor );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to get next child: %x", hr );
		goto Exit;
	}

	m_indexCursor++;

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextIntegerChild
//
//	Description:
//
//		Returns the name of the next integer subkey.
//		Call BeginChildEnumeration before calling NextIntegerChild
//
//	Parameters:
//
//		pdwID - the integer value of the subkey.
//		szIntegerChildKey - the subkey name string.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextIntegerChild ( OUT DWORD * pdwID, OUT LPWSTR wszIntegerChildKey )
{
	TraceFunctEnter ( "CMetabaseKey::NextChild" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pdwID ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszIntegerChildKey ) );

	_ASSERT ( m_hKey != NULL );
	_ASSERT ( m_indexCursor < m_cIntegerChildren );

	HRESULT		hr;
	BOOL		fFoundInteger;

	*pdwID				= 0;
	*wszIntegerChildKey 	= NULL;

	for ( fFoundInteger = FALSE; !fFoundInteger; ) {

		// Use the m_indexCursor to enumerated the next child:
		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszIntegerChildKey, m_indexCursor );
		if ( FAILED (hr) ) {
			goto Exit;
		}

		if ( IsValidIntegerSubKey ( wszIntegerChildKey ) ) {
			fFoundInteger = TRUE;
			*pdwID = _wtoi ( wszIntegerChildKey );
		}

		m_indexCursor++;
	}

Exit:
	// This means that you called NextIntegerChild more times than
	// was possible:
	_ASSERT ( HRESULTTOWIN32 ( hr ) != ERROR_NO_MORE_ITEMS );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::NextCustomChild
//
//	Description:
//
//		Returns the name of the next subkey for which fpIsCustomKey
//		returns true.
//		Call BeginChildEnumeration before calling NextCustomChild
//
//	Parameters:
//
//		fpIsCustomKey	- function that returns true if a given key
//			should be returned.
//		szChildKey - the resulting key name
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::NextCustomChild ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT LPWSTR wszChildKey 
	)
{
	TraceFunctEnter ( "CMetabaseKey::NextCustomChild" );

	_ASSERT ( fpIsCustomKey );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildKey ) );

	_ASSERT ( m_hKey != NULL );
	_ASSERT ( m_indexCursor < m_cChildren );

	HRESULT		hr;
	BOOL		fFoundCustomKey;

	*wszChildKey = NULL;

	for ( fFoundCustomKey = FALSE; !fFoundCustomKey; ) {

		// Use the m_indexCursor to enumerated the next child:
		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszChildKey, m_indexCursor );
		if ( FAILED (hr) ) {
			goto Exit;
		}

		if ( fpIsCustomKey ( wszChildKey ) ) {
			fFoundCustomKey = TRUE;
		}

		m_indexCursor++;
	}

Exit:
	// This means that you called NextCustomChild more times than
	// was possible:
	_ASSERT ( HRESULTTOWIN32 ( hr ) != ERROR_NO_MORE_ITEMS );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CreateChild
//
//	Description:
//
//		Creates the given path under the currently opened key.
//		Changes the current key to write permission.
//		Note: Does not call SaveData.
//
//	Parameters:
//
//		szChildPath - name of the subkey to create.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::CreateChild ( IN LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKey::CreateChild" );

	_ASSERT ( wszChildPath );
	_ASSERT ( m_hKey != NULL );
	
	HRESULT		hr;

	StateTrace ( (LPARAM) this, "Changing to Write Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, MD_DEFAULT_TIMEOUT, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_pMetabase->AddKey ( m_hKey, wszChildPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

/*
	// !!!magnush - Should we save the data now?
	hr = m_pMetabase->SaveData ();
	if ( FAILED (hr) ) {
		goto Exit;
	}
*/

	m_cChildren++;
	if ( IsValidIntegerSubKey ( wszChildPath ) ) {
		m_cIntegerChildren++;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::DestroyChild
//
//	Description:
//
//		Deletes the given subkey
//		Changes the current key to write permission.
//		Note: Does not call SaveData
//
//	Parameters:
//
//		szChildPath - the name of the subkey to delete.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::DestroyChild ( IN LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKey::DestroyChild" );

	_ASSERT ( wszChildPath );
	_ASSERT ( m_hKey != NULL );

	HRESULT	hr;

	StateTrace ( (LPARAM) this, "Changing to Write Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, MD_DEFAULT_TIMEOUT, METADATA_PERMISSION_WRITE );
	if ( FAILED(hr) ) {
		goto Exit;
	}

	hr = m_pMetabase->DeleteKey ( m_hKey, wszChildPath );
	if ( FAILED (hr) ) {
		goto Exit;
	}

/*
	// !!!magnush - Should we save the data now?
	hr = m_pMetabase->SaveData ();
	if ( FAILED (hr) ) {
		goto Exit;
	}
*/

	m_cChildren--;
	if ( IsValidIntegerSubKey ( wszChildPath ) ) {
		m_cIntegerChildren--;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CreateIntegerChild
//
//	Description:
//
//		Creates an integer subkey of the currently open key.
//		This key will be 1 + the highest integer subkey.
//
//	Parameters:
//
//		pdwID - the resulting integer value.
//		szChildPath - the resulting subkey path.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::CreateIntegerChild ( OUT DWORD * pdwID, OUT LPWSTR wszChildPath )
{
	TraceFunctEnter ( "CMetabaseKEy::CreateIntegerChild" );

	_ASSERT ( IS_VALID_OUT_PARAM ( pdwID ) );
	_ASSERT ( IS_VALID_OUT_PARAM ( wszChildPath ) );
	_ASSERT ( m_hKey != NULL );

	HRESULT		hr	= NOERROR;
	DWORD		dwId;

	*pdwID 			= 0;
	*wszChildPath 	= NULL;

	for ( dwId = 1; dwId != 0; dwId++ ) {
		//
		//	Keep trying to add an instance key until it works:
		//

		wsprintf ( wszChildPath, _T("%d"), dwId );

		hr = CreateChild ( wszChildPath );
		if ( SUCCEEDED(hr) ) {
			// We created the child, so lets get out of here.
			break;
		}
		else if ( HRESULTTOWIN32 ( hr ) == ERROR_ALREADY_EXISTS ) {
			// Child already exists, try the next one.
			continue;
		}
		else {
			// Real error: report it and bail.
			ErrorTrace ( (LPARAM) this, "Error %d adding %s\n", HRESULTTOWIN32(hr), wszChildPath );
			goto Exit;
		}
	}

	if ( dwId == 0 ) {
		hr = E_FAIL;
		goto Exit;
	}
	
	_ASSERT ( SUCCEEDED(hr) );
	if ( dwId > m_dwMaxIntegerChild ) {
		m_dwMaxIntegerChild = dwId;
	}

	*pdwID = dwId;

Exit:
	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::DestroyIntegerChild
//
//	Description:
//
//		Deletes the given integer subkey.
//
//	Parameters:
//
//		i - the subkey to delete
//
//	Returns:
//
//		metabase error code
//
//--------------------------------------------------------------------

HRESULT	CMetabaseKey::DestroyIntegerChild ( IN DWORD i )
{
	TraceFunctEnter ( "CMetabaseKey::DestroyIntegerChild" );

	_ASSERT ( i != 0 );
	_ASSERT ( m_hKey != NULL );

	WCHAR	wszChild [ METADATA_MAX_NAME_LEN ];
	HRESULT	hr;

	wsprintf ( wszChild, _T("%d"), i );

	hr = DestroyChild ( wszChild );

	TraceFunctLeave ();
	return hr;
}

//$-------------------------------------------------------------------
//
//	CMetabaseKey::CountSubKeys
//
//	Description:
//
//		Returns the number of subkeys and integer subkeys of the
//		current metabase key.
//		Changes the key to read permission.
//
//	Parameters:
//
//		fpIsCustomKey - Function that takes a key and returns true
//			if that key should be included in the custom child count.
//		pcSubKeys - number of subkeys.
//		pcIntegerSubKeys - number of integer subkeys.
//		pcCustomChildren - the number of keys for which fpIsCustomKey
//			returns true.
//		pdwMaxIntegerSubkey - the highest integer subkey value.
//
//	Returns:
//
//		metabase error code.
//
//--------------------------------------------------------------------

HRESULT CMetabaseKey::CountSubkeys ( 
	KEY_TEST_FUNCTION	fpIsCustomKey,
	OUT DWORD * 		pcSubKeys, 
	OUT DWORD *			pcIntegerSubKeys,
	OUT DWORD * 		pcCustomSubKeys,
	OUT DWORD * 		pdwMaxIntegerSubKey
	)
{
	TraceFunctEnter ( "CMetabaseKey::CountSubKeys" );

	_ASSERT ( pcSubKeys );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcSubKeys ) );
	_ASSERT ( pcIntegerSubKeys );
	_ASSERT ( IS_VALID_OUT_PARAM ( pcIntegerSubKeys ) );
//	_ASSERT ( pcCustomSubKeys );
//	_ASSERT ( IS_VALID_OUT_PARAM ( pcCustomSubKeys ) );
	_ASSERT ( m_hKey != NULL );

	// Zero the out parameter:
	*pcSubKeys				= 0;
	*pcIntegerSubKeys		= 0;
	*pdwMaxIntegerSubKey	= 0;
	if ( pcCustomSubKeys ) {
		*pcCustomSubKeys		= 0;
	}

	HRESULT	hr					= NOERROR;
	DWORD	cItems				= 0;
	DWORD	cIntegerItems		= 0;
	DWORD	cCustomItems		= 0;
	DWORD	dwMaxIntegerSubKey	= 0;
	WCHAR	wszName [ METADATA_MAX_NAME_LEN ];
	DWORD	i					= 0;

	StateTrace ( (LPARAM) this, "Changing to Read Permission" );
	hr = m_pMetabase->ChangePermissions ( m_hKey, 1, METADATA_PERMISSION_READ );
	_ASSERT ( SUCCEEDED(hr) );
	if ( FAILED (hr) ) {
		ErrorTraceX ( (LPARAM) this, "Failed to change permissions to read: %x", hr );
		goto Exit;
	}

	// Because I can't do a count here, I have to assume that the error means
	// there are no more items:
	for ( cItems = 0, cIntegerItems = 0, cCustomItems = 0, i = 0; 
		/* Don't know how long it will last */; 
		i++ ) {

		hr = m_pMetabase->EnumKeys ( m_hKey, _T(""), wszName, i );

		if ( HRESULTTOWIN32 ( hr ) == ERROR_NO_MORE_ITEMS ) {
			// This is expected, end the loop:
			hr = NOERROR;
			break;
		}

		if ( FAILED (hr) ) {
			// Unexpected error case.

			ErrorTraceX ( 0, "Failed to enum object %d : %x", i, hr );
			goto Exit;
		}

		cItems++;

		if ( IsValidIntegerSubKey ( wszName ) ) {
			DWORD	dwSubkey;

			cIntegerItems++;
			dwSubkey = _wtoi ( wszName );

			if ( dwSubkey > dwMaxIntegerSubKey ) {
				dwMaxIntegerSubKey = dwSubkey;
			}
		}
		else {
			// Don't count this one:
			ErrorTrace ( 0, "Bad subkey number: %d", i );
		}

		if ( fpIsCustomKey && fpIsCustomKey ( wszName ) ) {
			cCustomItems++;
		}

		_ASSERT ( i < 0xf000000 ); // Infinite loop
	}

	// Now we have the count of items in cItems.
	*pcSubKeys				= cItems;
	*pcIntegerSubKeys		= cIntegerItems;
	*pdwMaxIntegerSubKey	= dwMaxIntegerSubKey;
	if ( pcCustomSubKeys ) {
		*pcCustomSubKeys		= cCustomItems;
	}

Exit:
	TraceFunctLeave ();
	return hr;
}

BOOL IsValidIntegerSubKey ( LPCWSTR wszSubKey )
{
	TraceQuietEnter ( "IsValidIntegerSubKey" );

	WCHAR	wszIntegerKey [ METADATA_MAX_NAME_LEN ];
	DWORD	dwItemValue;

	dwItemValue = _wtoi ( wszSubKey );
	wsprintf ( wszIntegerKey, _T("%d"), dwItemValue );

	// If the key is nonzero AND
	// The key is just the itoa value of the number:
	if ( dwItemValue != 0 &&
		 lstrcmp ( wszIntegerKey, wszSubKey ) == 0 ) {

		 return TRUE;
	}
	else {
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\asptlb5.h ===
// This file was generated by mktyplib.exe, then munged by Active Server Pages build. 
// Changes: 
// - we include "dispatch.h" (our standard IDispatch implementation) 
// 
// - we #define "NO_BASEINTERFACE_FUNCS" to prevent pure virtual 
// redefinitions of the four IDispatch members that CDispatch defines. 
// 
// - we change the derivation of the classes from "IDispatch" to "CDispatch" 
// 
#include "dispatch.h" 
#define NO_BASEINTERFACE_FUNCS 
// 
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0106 */
/* at Tue Jul 15 12:18:35 1997
 */
/* Compiler settings for asp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef ___asptlb_h__
#define ___asptlb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IStringList_FWD_DEFINED__
#define __IStringList_FWD_DEFINED__
typedef interface IStringList IStringList;
#endif 	/* __IStringList_FWD_DEFINED__ */


#ifndef __IRequestDictionary_FWD_DEFINED__
#define __IRequestDictionary_FWD_DEFINED__
typedef interface IRequestDictionary IRequestDictionary;
#endif 	/* __IRequestDictionary_FWD_DEFINED__ */


#ifndef __IRequest_FWD_DEFINED__
#define __IRequest_FWD_DEFINED__
typedef interface IRequest IRequest;
#endif 	/* __IRequest_FWD_DEFINED__ */


#ifndef __Request_FWD_DEFINED__
#define __Request_FWD_DEFINED__

#ifdef __cplusplus
typedef class Request Request;
#else
typedef struct Request Request;
#endif /* __cplusplus */

#endif 	/* __Request_FWD_DEFINED__ */


#ifndef __IReadCookie_FWD_DEFINED__
#define __IReadCookie_FWD_DEFINED__
typedef interface IReadCookie IReadCookie;
#endif 	/* __IReadCookie_FWD_DEFINED__ */


#ifndef __IWriteCookie_FWD_DEFINED__
#define __IWriteCookie_FWD_DEFINED__
typedef interface IWriteCookie IWriteCookie;
#endif 	/* __IWriteCookie_FWD_DEFINED__ */


#ifndef __IResponse_FWD_DEFINED__
#define __IResponse_FWD_DEFINED__
typedef interface IResponse IResponse;
#endif 	/* __IResponse_FWD_DEFINED__ */


#ifndef __Response_FWD_DEFINED__
#define __Response_FWD_DEFINED__

#ifdef __cplusplus
typedef class Response Response;
#else
typedef struct Response Response;
#endif /* __cplusplus */

#endif 	/* __Response_FWD_DEFINED__ */


#ifndef __IVariantDictionary_FWD_DEFINED__
#define __IVariantDictionary_FWD_DEFINED__
typedef interface IVariantDictionary IVariantDictionary;
#endif 	/* __IVariantDictionary_FWD_DEFINED__ */


#ifndef __ISessionObject_FWD_DEFINED__
#define __ISessionObject_FWD_DEFINED__
typedef interface ISessionObject ISessionObject;
#endif 	/* __ISessionObject_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __IApplicationObject_FWD_DEFINED__
#define __IApplicationObject_FWD_DEFINED__
typedef interface IApplicationObject IApplicationObject;
#endif 	/* __IApplicationObject_FWD_DEFINED__ */


#ifndef __Application_FWD_DEFINED__
#define __Application_FWD_DEFINED__

#ifdef __cplusplus
typedef class Application Application;
#else
typedef struct Application Application;
#endif /* __cplusplus */

#endif 	/* __Application_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __IScriptingContext_FWD_DEFINED__
#define __IScriptingContext_FWD_DEFINED__
typedef interface IScriptingContext IScriptingContext;
#endif 	/* __IScriptingContext_FWD_DEFINED__ */


#ifndef __ScriptingContext_FWD_DEFINED__
#define __ScriptingContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScriptingContext ScriptingContext;
#else
typedef struct ScriptingContext ScriptingContext;
#endif /* __cplusplus */

#endif 	/* __ScriptingContext_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 



DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0,0xA85C,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IStringList,0xD97A6DA0,0xA85D,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8")
    IStringList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStringList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in][optional] */ VARIANT i,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0,0xA85F,0x11df,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85F-11df-83AE-00A0C90C2BD8")
    IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequestDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IRequestDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IRequestDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Count_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IRequestDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Key_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IRequestDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IRequest,0xD97A6DA0,0xA861,0x11cf,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A861-11cf-93AE-00A0C90C2BD8")
    IRequest : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBytes( 
            /* [retval][out] */ long __RPC_FAR *pcbTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryRead( 
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalBytes )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcbTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryRead )( 
            IRequest __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#define IRequest_get_TotalBytes(This,pcbTotal)	\
    (This)->lpVtbl -> get_TotalBytes(This,pcbTotal)

#define IRequest_BinaryRead(This,pvarCountToRead,pvarReturn)	\
    (This)->lpVtbl -> BinaryRead(This,pvarCountToRead,pvarReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_TotalBytes_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcbTotal);


void __RPC_STUB IRequest_get_TotalBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequest_BinaryRead_Proxy( 
    IRequest __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);


void __RPC_STUB IRequest_BinaryRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Request,0x920c25d0,0x25d9,0x11d0,0xa5,0x5f,0x00,0xa0,0xc9,0x0c,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("920c25d0-25d9-11d0-a55f-00a0c90c2091")
Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IReadCookie,0x71EAF260,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EAF260-0CE0-11D0-A53E-00A0C90C2091")
    IReadCookie : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReadCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0,0xA862,0x11cf,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A862-11cf-84AE-00A0C90C2BD8")
    IWriteCookie : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrDomain);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWriteCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWriteCookie_put_Item(This,key,bstrValue)	\
    (This)->lpVtbl -> put_Item(This,key,bstrValue)

#define IWriteCookie_put_Expires(This,dtExpires)	\
    (This)->lpVtbl -> put_Expires(This,dtExpires)

#define IWriteCookie_put_Domain(This,bstrDomain)	\
    (This)->lpVtbl -> put_Domain(This,bstrDomain)

#define IWriteCookie_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IWriteCookie_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT key,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrDomain);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IResponse,0xD97A6DA0,0xA864,0x11cf,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A864-11cf-83BE-00A0C90C2BD8")
    IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Buffer( 
            /* [in] */ VARIANT_BOOL fIsBuffering) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContentType( 
            /* [in] */ BSTR bstrContentType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ long lExpiresMinutes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpiresAbsolute( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ BSTR bstrStatus) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryWrite( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsClientConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CharSet( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CharSet( 
            /* [in] */ BSTR bstrCharSet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pics( 
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CacheControl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CacheControl( 
            /* [in] */ BSTR bstrCacheControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIsBuffering);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrContentType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ long lExpiresMinutes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrStatus);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClientConnected )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCharSet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pics )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCacheControl);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,bstrContentType)	\
    (This)->lpVtbl -> put_ContentType(This,bstrContentType)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,lExpiresMinutes)	\
    (This)->lpVtbl -> put_Expires(This,lExpiresMinutes)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,dtExpires)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,dtExpires)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,bstrStatus)	\
    (This)->lpVtbl -> put_Status(This,bstrStatus)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,varInput)	\
    (This)->lpVtbl -> BinaryWrite(This,varInput)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#define IResponse_IsClientConnected(This,pfIsClientConnected)	\
    (This)->lpVtbl -> IsClientConnected(This,pfIsClientConnected)

#define IResponse_get_CharSet(This,pbstrCharSetRet)	\
    (This)->lpVtbl -> get_CharSet(This,pbstrCharSetRet)

#define IResponse_put_CharSet(This,bstrCharSet)	\
    (This)->lpVtbl -> put_CharSet(This,bstrCharSet)

#define IResponse_Pics(This,bstrHeaderValue)	\
    (This)->lpVtbl -> Pics(This,bstrHeaderValue)

#define IResponse_get_CacheControl(This,pbstrCacheControl)	\
    (This)->lpVtbl -> get_CacheControl(This,pbstrCacheControl)

#define IResponse_put_CacheControl(This,bstrCacheControl)	\
    (This)->lpVtbl -> put_CacheControl(This,bstrCacheControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrContentType);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ long lExpiresMinutes);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrStatus);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_IsClientConnected_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);


void __RPC_STUB IResponse_IsClientConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);


void __RPC_STUB IResponse_get_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCharSet);


void __RPC_STUB IResponse_put_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Pics_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_Pics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);


void __RPC_STUB IResponse_get_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCacheControl);


void __RPC_STUB IResponse_put_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Response,0x46E19BA0,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("46E19BA0-25DD-11D0-A55F-00A0C90C2091")
Response;
#endif

#ifndef __IVariantDictionary_INTERFACE_DEFINED__
#define __IVariantDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVariantDictionary
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IVariantDictionary,0x4a7deb90,0xb069,0x11d0,0xb3,0x73,0x00,0xa0,0xc9,0x0c,0x2b,0xd8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7deb90-b069-11d0-b373-00a0c90c2bd8")
    IVariantDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariantDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IVariantDictionaryVtbl;

    interface IVariantDictionary
    {
        CONST_VTBL struct IVariantDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariantDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariantDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariantDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariantDictionary_get_Item(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Item(This,VarKey,pvar)

#define IVariantDictionary_put_Item(This,VarKey,var)	\
    (This)->lpVtbl -> put_Item(This,VarKey,var)

#define IVariantDictionary_putref_Item(This,VarKey,var)	\
    (This)->lpVtbl -> putref_Item(This,VarKey,var)

#define IVariantDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#define IVariantDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IVariantDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_put_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_putref_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Key_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Count_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IVariantDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get__NewEnum_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IVariantDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantDictionary_INTERFACE_DEFINED__ */


#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][oleautomation][dual][uuid] */ 



DEFINE_GUID(IID_ISessionObject,0xD97A6DA0,0xA865,0x11cf,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A865-11cf-83AF-00A0C90C2BD8")
    ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Timeout( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodePage( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CodePage( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LCID( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LCID( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISessionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define ISessionObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,lvar)	\
    (This)->lpVtbl -> put_Timeout(This,lvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#define ISessionObject_get_CodePage(This,plvar)	\
    (This)->lpVtbl -> get_CodePage(This,plvar)

#define ISessionObject_put_CodePage(This,lvar)	\
    (This)->lpVtbl -> put_CodePage(This,lvar)

#define ISessionObject_get_LCID(This,plvar)	\
    (This)->lpVtbl -> get_LCID(This,plvar)

#define ISessionObject_put_LCID(This,lvar)	\
    (This)->lpVtbl -> put_LCID(This,lvar)

#define ISessionObject_get_StaticObjects(This,ppTaggedObjects)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppTaggedObjects)

#define ISessionObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_StaticObjects_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);


void __RPC_STUB ISessionObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Contents_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ISessionObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Session,0x509F8F20,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("509F8F20-25DE-11D0-A55F-00A0C90C2091")
Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0,0xA866,0x11cf,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A866-11cf-83AE-10A0C90C2BD8")
    IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnLock( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IApplicationObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define IApplicationObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#define IApplicationObject_get_StaticObjects(This,ppProperties)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppProperties)

#define IApplicationObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_StaticObjects_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Contents_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Application,0x7C3BAF00,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("7C3BAF00-25DE-11D0-A55F-00A0C90C2091")
Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IServer,0xD97A6DA0,0xA867,0x11cf,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A867-11cf-83AE-01A0C90C2BD8")
    IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ScriptTimeout( 
            /* [in] */ long lTimeoutSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLPathEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long lTimeoutSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLPathEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,lTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,lTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#define IServer_URLPathEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLPathEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long lTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLPathEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLPathEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Server,0xA506D160,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("A506D160-25E0-11D0-A55F-00A0C90C2091")
Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A868-11cf-83AE-00B0C90C2BD8")
    IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptingContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus

class DECLSPEC_UUID("D97A6DA0-A868-11cf-83AE-11B0C90C2BD8")
ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\metakey.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	metakey.h

Abstract:

	CMetabaseKey - A class to help manipulate metabase keys.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _METAKEY_INCLUDED_
#define _METAKEY_INCLUDED_

//
// Creating a metabase object:
//

HRESULT CreateMetabaseObject ( LPCWSTR wszMachine, IMSAdminBase ** ppMetabase );

//
//	The metabase key class:
//

typedef BOOL (*KEY_TEST_FUNCTION) ( LPCWSTR szKey );

class CMetabaseKey
{
public:
	CMetabaseKey	( IMSAdminBase * pMetabase );
	~CMetabaseKey	( );

	//
	// METADATA_HANDLE manipulation:
	//

	inline HRESULT	Open	( IN LPCWSTR szPath, DWORD dwPermissions = METADATA_PERMISSION_READ );
	HRESULT			Open	( IN METADATA_HANDLE hParentKey, IN LPCWSTR szPath, DWORD dwPermissions = METADATA_PERMISSION_READ );
	void			Attach	( METADATA_HANDLE hKey );
	METADATA_HANDLE	Detach	( );
	void			Close 	( );

	void			GetLastChangeTime ( FILETIME * pftGMT, LPCWSTR wszPath = _T("") );
	HRESULT			Save	( );

	METADATA_HANDLE	QueryHandle ( ) { return m_hKey; }
	IMSAdminBase *	QueryMetabase ( ) { return m_pMetabase; }

	//
	// Getting metabase values:
	//

    inline HRESULT GetData		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType, VOID * pvData, DWORD * cbData, DWORD dwFlags );
    inline HRESULT GetDataSize	( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType, DWORD * pcbSize, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

    inline HRESULT GetDword		( LPCWSTR wszPath, DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetString	( LPCWSTR wszPath, DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetMultiSz	( LPCWSTR wszPath, DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetBinary	( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	// These routines default to the current metabase key path:
    inline HRESULT GetDword		( DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetString	( DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetMultiSz	( DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT GetBinary	( DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	//
	// Setting metabase values:
	//

    inline HRESULT SetData		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType, VOID * pvData, DWORD cbData, DWORD dwFlags );

    inline HRESULT SetDword		( LPCWSTR wszPath, DWORD dwPropID, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetString	( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetMultiSz	( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetBinary	( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	inline HRESULT DeleteData	( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType );

	// These routines default to the current metabase key path:
    inline HRESULT SetDword		( DWORD dwPropID, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetString	( DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetMultiSz	( DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );
    inline HRESULT SetBinary	( DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT, DWORD dwUserType = IIS_MD_UT_SERVER );

	inline HRESULT DeleteData	( DWORD dwPropID, DWORD dwDataType );


	//
	// Subkey manipulation:
	//

	HRESULT		GetChildCount			( OUT DWORD * pcChildren );
	HRESULT		GetIntegerChildCount	( OUT DWORD * pcIntegerChildren );
	HRESULT		GetCustomChildCount		( 
		IN KEY_TEST_FUNCTION func, 
		OUT DWORD * pcCustomChildren 
		);

	void		BeginChildEnumeration	( );
	HRESULT		NextChild				( OUT LPWSTR wszChildKey );
	HRESULT		NextIntegerChild		( OUT DWORD * pdwID, OUT LPWSTR wszIntegerChildKey );
	HRESULT		NextCustomChild			( 
		IN KEY_TEST_FUNCTION fpIsCustomKey, 
		OUT LPWSTR wszChildKey 
		);

	HRESULT		CreateChild			( IN LPWSTR wszChildPath );
	HRESULT		DestroyChild		( IN LPWSTR wszChildPath );
	HRESULT		CreateIntegerChild	( OUT DWORD * pdwID, OUT LPWSTR wszChildPath );
	HRESULT		DestroyIntegerChild	( IN DWORD i );

private:
	IMSAdminBase *		m_pMetabase;
	METADATA_HANDLE		m_hKey;

	DWORD				m_indexCursor;
	DWORD				m_cChildren;
	DWORD				m_cIntegerChildren;
	DWORD				m_dwMaxIntegerChild;

	HRESULT	CountSubkeys ( 
		IN  KEY_TEST_FUNCTION fpIsCustomKey,
		OUT DWORD * pcChildren, 
		OUT DWORD * pcIntegerChildren,
		OUT DWORD * pcCustomChildren, 
		OUT DWORD * pdwMaxIntegerChild 
		);
};

//--------------------------------------------------------------------
//
//	Inlined Functions:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::Open ( IN LPCWSTR szPath, DWORD dwPermissions )
{
	return Open ( METADATA_MASTER_ROOT_HANDLE, szPath, dwPermissions );
}

//--------------------------------------------------------------------
//
//	Simple GetData wrappers:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::GetDword ( LPCWSTR wszPath, DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags, DWORD dwUserType )
{
	DWORD	dwDummy	= sizeof (DWORD);

	return GetData ( wszPath, dwPropID, dwUserType, DWORD_METADATA, pdwValue, &dwDummy, dwFlags );
}

inline HRESULT CMetabaseKey::GetString ( LPCWSTR wszPath, DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, STRING_METADATA, wszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetMultiSz ( LPCWSTR wszPath, DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, MULTISZ_METADATA, mszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetBinary ( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( wszPath, dwPropID, dwUserType, BINARY_METADATA, pvData, &cbMax, dwFlags );
}

// These routines default to the current metabase key path:
inline HRESULT CMetabaseKey::GetDword ( DWORD dwPropID, DWORD * pdwValue, DWORD dwFlags, DWORD dwUserType )
{
	DWORD	dwDummy	= sizeof (DWORD);

	return GetData ( _T(""), dwPropID, dwUserType, DWORD_METADATA, pdwValue, &dwDummy, dwFlags );
}

inline HRESULT CMetabaseKey::GetString ( DWORD dwPropID, LPWSTR wszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, STRING_METADATA, wszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetMultiSz ( DWORD dwPropID, LPWSTR mszValue, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, MULTISZ_METADATA, mszValue, &cbMax, dwFlags );
}

inline HRESULT CMetabaseKey::GetBinary ( DWORD dwPropID, void * pvData, DWORD cbMax, DWORD dwFlags, DWORD dwUserType )
{
	return GetData ( _T(""), dwPropID, dwUserType, BINARY_METADATA, pvData, &cbMax, dwFlags );
}

//--------------------------------------------------------------------
//
//	Simple SetData wrappers:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::SetDword ( LPCWSTR wszPath, DWORD dwPropID, DWORD dwValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, DWORD_METADATA, &dwValue, sizeof (DWORD), dwFlags );
}

inline HRESULT CMetabaseKey::SetString ( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( 
		wszPath, 
		dwPropID, 
		dwUserType, 
		STRING_METADATA, 
		(void *) wszValue, 
		sizeof (WCHAR) * (lstrlen ( wszValue ) + 1), 
		dwFlags 
		);
}

inline HRESULT CMetabaseKey::SetMultiSz ( LPCWSTR wszPath, DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, MULTISZ_METADATA, (void *) mszValue, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::SetBinary ( LPCWSTR wszPath, DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( wszPath, dwPropID, dwUserType, BINARY_METADATA, pvData, cbData, dwFlags );
}

// These routines default to the current metabase key path:
inline HRESULT CMetabaseKey::SetDword ( DWORD dwPropID, DWORD dwValue, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, DWORD_METADATA, &dwValue, sizeof (DWORD), dwFlags );
}

inline HRESULT CMetabaseKey::SetString ( DWORD dwPropID, LPCWSTR wszValue, DWORD dwFlags, DWORD dwUserType )
{
	_ASSERT ( !IsBadStringPtr ( wszValue, -1 ) );

	return SetData ( 
		_T(""), 
		dwPropID, 
		dwUserType,
		STRING_METADATA, 
		(void *) wszValue, 
		sizeof (WCHAR) * ( lstrlen ( wszValue ) + 1 ),
		dwFlags
		);
}

inline HRESULT CMetabaseKey::SetMultiSz ( DWORD dwPropID, LPCWSTR mszValue, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, MULTISZ_METADATA, (void *) mszValue, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::SetBinary ( DWORD dwPropID, void * pvData, DWORD cbData, DWORD dwFlags, DWORD dwUserType )
{
	return SetData ( _T(""), dwPropID, dwUserType, BINARY_METADATA, pvData, cbData, dwFlags );
}

inline HRESULT CMetabaseKey::DeleteData ( DWORD dwPropID, DWORD dwDataType )
{
	return DeleteData ( _T(""), dwPropID, dwDataType );
}

inline HRESULT CMetabaseKey::DeleteData ( LPCWSTR wszPath, DWORD dwPropID, DWORD dwDataType )
{
	TraceQuietEnter ( "CMetabaseKey:DeleteData" );

	HRESULT		hRes;

	hRes = m_pMetabase->DeleteData ( m_hKey, wszPath, dwPropID, dwDataType );
	if ( hRes == MD_ERROR_DATA_NOT_FOUND ) {
		hRes = NOERROR;
	}

	//	Trace the error code:
	if ( FAILED(hRes) ) {
		ErrorTraceX ( 0, "DeleteData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

	return hRes;
}

//--------------------------------------------------------------------
//
//	The real work - Set & Get arbitrary metadata:
//
//--------------------------------------------------------------------

inline HRESULT CMetabaseKey::GetDataSize ( 
	LPCWSTR		wszPath, 
	DWORD 		dwPropID, 
	DWORD		dwDataType,
	DWORD *		pcbSize, 
	DWORD		dwFlags, 
	DWORD		dwUserType
	)
{
	TraceQuietEnter ( "CMetabaseKey::GetDataSize" );

    HRESULT         hRes;
    METADATA_RECORD mdRecord;
    DWORD			dwDummy			= 0;
    DWORD           dwRequiredLen	= 0;

	_ASSERT ( !IsBadWritePtr ( pcbSize, sizeof (DWORD) ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = 0;
    mdRecord.pbMDData        = (PBYTE) &dwDummy;

    hRes = m_pMetabase->GetData( m_hKey,
                                      wszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    *pcbSize = dwRequiredLen;

	if ( HRESULTTOWIN32 ( hRes ) == ERROR_INSUFFICIENT_BUFFER ) {
		// Of course the buffer is too small!
		hRes = NOERROR;
	}

	//	Trace the error code:
	if ( FAILED(hRes) && hRes != MD_ERROR_DATA_NOT_FOUND ) {
		ErrorTraceX ( 0, "GetDataSize failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

    return hRes;
}

inline HRESULT CMetabaseKey::GetData (
	LPCWSTR  	pszPath,
	DWORD       dwPropID,
	DWORD       dwUserType,
	DWORD       dwDataType,
	VOID *      pvData,
	DWORD *     pcbData,
	DWORD       dwFlags )
{
	TraceQuietEnter ( "CMetabaseKey::GetData" );

    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

	_ASSERT ( !IsBadReadPtr ( pcbData, sizeof (DWORD) ) );
	_ASSERT ( !IsBadWritePtr ( pvData, *pcbData ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = m_pMetabase->GetData( m_hKey,
                                      pszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    if ( SUCCEEDED( hRes )) {
        *pcbData = mdRecord.dwMDDataLen;
    }
    else {
	    *pcbData = dwRequiredLen;
	}

	//	Trace the error code:
	if ( FAILED(hRes) && hRes != MD_ERROR_DATA_NOT_FOUND ) {
		ErrorTraceX ( 0, "GetData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

    return hRes;
}

inline HRESULT CMetabaseKey::SetData ( 
	LPCWSTR 	pszPath,
	DWORD       dwPropID,
	DWORD       dwUserType,
	DWORD       dwDataType,
	VOID *      pvData,
	DWORD       cbData,
	DWORD       dwFlags )
{
	TraceQuietEnter ( "CMetabaseKey::SetData" );

    METADATA_RECORD mdRecord;
    HRESULT         hRes;

	_ASSERT ( !IsBadReadPtr ( pvData, cbData ) );

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = m_pMetabase->SetData( m_hKey,
                                      pszPath,
                                      &mdRecord );

	//	Trace the error code:
	if ( FAILED(hRes) ) {
		ErrorTraceX ( 0, "GetData failed unexpectedly: Prop(%d) Error(%x)", dwPropID, hRes );
	}

	return hRes;
}

#endif // _METAKEY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\admmacro.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	admmacro.h

Abstract:

	Useful macros used by all admin objects.

Author:

	Magnus Hedlund (MagnusH)		--

Revision History:

--*/

#ifndef _ADMMACRO_INCLUDED_
#define _ADMMACRO_INCLUDED_

//
//	Error handling:
//

#define BAIL_ON_FAILURE(hr)	\
{							\
	if ( FAILED(hr) ) {		\
		goto Exit;			\
	}						\
}
#define BAIL_WITH_FAILURE(hr, hrFailureCode)	\
{							\
	(hr) = (hrFailureCode);	\
	goto Exit;				\
}

//
//	Data validation macros:
//

#define IS_VALID_THIS_POINTER()			( !IsBadWritePtr ( (void *) this, sizeof (*this) ) )
#define IS_VALID_STRING(str)			( !IsBadStringPtr ( (str), (DWORD) -1 ) )
#define IS_VALID_STRING_LEN(str,len)	( !IsBadStringPtr ( (str), (len) ) )
#define IS_VALID_IN_PARAM(pIn)			( !IsBadReadPtr ( (pIn), sizeof ( *(pIn) ) ) )
#define IS_VALID_OUT_PARAM(pOut)		( !IsBadWritePtr ( (pOut), sizeof ( *(pOut) ) ) )

#define IS_VALID_READ_ARRAY(arr,cItems)		( !IsBadReadPtr ( (arr), (cItems) * sizeof ( *(arr) ) ) )
#define IS_VALID_WRITE_ARRAY(arr,cItems)	( !IsBadWritePtr ( (arr), (cItems) * sizeof ( *(arr) ) ) )

//
//	AssertValid for classes:
//

#ifdef DEBUG
	#define DECLARE_ASSERT_VALID()	void AssertValid ( ) const;
	#define DECLARE_VIRTUAL_ASSERT_VALID()	virtual void AssertValid ( ) const;
#else
	#define DECLARE_ASSERT_VALID()	inline void AssertValid ( ) const { }
	#define DECLARE_VIRTUAL_ASSERT_VALID()	inline void AssertValid ( ) const { }
#endif

//
//	Sizing macros:
//

inline DWORD STRING_BYTE_LENGTH ( LPWSTR wsz )
{
    if ( wsz == NULL ) {
        return 0;
    }

    return ( lstrlen ( wsz ) + 1 ) * sizeof wsz[0];
}

//	Use only for statically sized arrays:
#define ARRAY_SIZE(arr)	( sizeof (arr) / sizeof ( (arr)[0] ) )

//
//	Bit macros:
//

inline void SetBitFlag ( DWORD * pbv, DWORD bit, BOOL fFlag )
{
	_ASSERT ( IS_VALID_OUT_PARAM ( pbv ) );
	_ASSERT ( bit != 0 );

	if ( fFlag ) {
		*pbv |= bit;
	}
	else {
		*pbv &= ~bit;
	}
}

inline BOOL GetBitFlag ( DWORD bv, DWORD bit )
{
	return !!(bv & bit);
}

//
//	Macros for ole types that aren't wrapped using ATL:
//

inline void SAFE_FREE_BSTR ( BSTR & str )
{
	if ( str != NULL ) {
		::SysFreeString ( str );
		str = NULL;
	}
}

#define SAFE_RELEASE(x) { if ( (x) ) { (x)->Release(); (x) = NULL; } }

#endif // _ADMMACRO_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\name.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    name.cpp

Abstract:

    This module contains the property name table class.  Properties 
	of query object and querybase object are all collected in the 
	name table, which facilitates the property loading and saving
	by name, value pairs.  The table also has other information like
	dirty bits for each property.

	This module is used by both the query object module and the query
	base module.


Author:

    Kangrong Yan  ( t-kyan )     27-June-1997

Revision History:

--*/

// System includes
#include "stdafx.h"
#include <windows.h>
#include <dbgtrace.h>
#include <memory.h>
#include <string.h>


// User includes
#include "name.h"

//
// Global property table, it's operation is wrapped in CPropertyTable.
// It's made global to make initialization easier.  However, only 
// CPropertyTable will have access to this table.
//
//  It's terminated with empty string.
//
PropertyEntry g_MailPropertyTable[] =
{
	{QUERY_STRING_NAME,		QUERY_STRING,		0,	FALSE},
	{EMAIL_ADDRESS_NAME,	EMAIL_ADDRESS,		0,	FALSE},
	{NEWS_GROUP_NAME,		NEWS_GROUP,			0,	FALSE},
	{LAST_SEARCH_DATE_NAME,	LAST_SEARCH_DATE,	0,	FALSE},
	{QUERY_ID_NAME,			QUERY_ID,			0,	FALSE},
	{REPLY_MODE_NAME,		REPLY_MODE,			0,	FALSE},
	{FROM_LINE_NAME,		FROM_LINE,			0,	FALSE},
	{SUBJECT_LINE_NAME,		SUBJECT_LINE,		0,	FALSE},
	{EDIT_URL_NAME,			EDIT_URL,			0,	FALSE},
	{MAIL_PICKUP_DIR_NAME,	MAIL_PICKUP_DIR,	0,	FALSE},
	{QUERY_SERVER_NAME,		QUERY_SERVER,		0,	FALSE},
	{QUERY_CATALOG_NAME,	QUERY_CATALOG,		0,	FALSE},
	{MESSAGE_TEMPLATE_TEXT_NAME, MESSAGE_TEMPLATE_TEXT, 0, FALSE},
	{URL_TEMPLATE_TEXT_NAME, URL_TEMPLATE_TEXT, 0, FALSE},
	{MESSAGE_TEMPLATE_FILE_NAME, MESSAGE_TEMPLATE_FILE, 0, FALSE},
	{URL_TEMPLATE_FILE_NAME, URL_TEMPLATE_FILE, 0, FALSE},
	{SEARCH_FREQUENCY_NAME, SEARCH_FREQUENCY,   0, FALSE},
	{IS_BAD_QUERY_NAME,		IS_BAD_QUERY,	    0, FALSE},
	{NEWS_SERVER_NAME,		NEWS_SERVER,		0, FALSE},
	{NEWS_PICKUP_DIR_NAME,	NEWS_PICKUP_DIR,	0, FALSE}

};


//
// Constructor, destructor
//
CPropertyTable::CPropertyTable()
{

	TraceFunctEnter("CPropertyTable::CPropertyTable");
	
	m_cProperties = PROPERTY_TOTAL;
	//m_pPropertyTable = g_MailPropertyTable;
	memcpy(		m_pPropertyTable, 
				g_MailPropertyTable, 
				sizeof( PropertyEntry ) * PROPERTY_TOTAL );

	for ( UINT i = 0; i < m_cProperties; i++) {
		VariantInit( &(m_pPropertyTable[i].varVal) );
		m_pPropertyTable[i].fDirty = FALSE;
	}

	TraceFunctLeave();
}

CPropertyTable::~CPropertyTable()
{
	TraceFunctEnter("CPropertyTable::~CPropertyTable");
	DebugTrace(0, "1");
	_ASSERT( m_pPropertyTable );		// becaues only I am freeing it
	DebugTrace(0,"2");
	_ASSERT( m_cProperties >= 0 );
	DebugTrace(0,"3");

	//
	// Make sure all string values are freed first
	// we should have worried about more other pointer types,
	// but since in this application, properties are only going 
	// to be BSTR or DWORDs.  So I am only worried about BSTR
	//
	for ( UINT i = 0; i < m_cProperties; i++) {
		if ( VT_BSTR == m_pPropertyTable[i].varVal.vt		// is BSTR
			&&	m_pPropertyTable[i].varVal.bstrVal ) {			// is not null
			 DebugTraceX(0, "%d:%ws", i, m_pPropertyTable[i].varVal.bstrVal);
			 SysFreeString( m_pPropertyTable[i].varVal.bstrVal );
			 DebugTrace(0, "Freed");
		}
	}
	

	TraceFunctLeave();
}

PPropertyEntry 
CPropertyTable::operator[]( const LPWSTR wszName )
/*++

Routine Description : 

	Help access the property entry with name as index.

Arguemnts : 

	IN LPWSTR wszName	-	Name of the property
	
Return Value : 
	Pointer to the property entry, on success;
	Null, if fail.

--*/
{
	TraceFunctEnter("CPropertyTable::operator[]");
	_ASSERT( wszName );

	for ( UINT i = 0; i < m_cProperties; i++)
		if ( wcscmp( wszName, m_pPropertyTable[i].wszName ) == 0 ) {
			TraceFunctLeave();
			return ( m_pPropertyTable + i );
		}

	TraceFunctLeave();
	return NULL;
}
	

PPropertyEntry 
CPropertyTable::operator[]( DWORD dwPropID )
/*++

Routine Description : 

	Help access the property entry with property ID as index.

Arguemnts : 

	IN DWORD dwPropID	-	ID of the property
	
Return Value : 
	Pointer to the property entry, on success;
	Null, if fail.

--*/
{
	TraceFunctEnter("CPropertyTable::operator[]");
	_ASSERT( dwPropID >= 0 && dwPropID < PROPERTY_TOTAL );

	TraceFunctLeave();
	return ( m_pPropertyTable + dwPropID );
}

BOOL	
IsNumber( PWCHAR wszString )
/*++

Routine Description : 

	Whether the string is a number

Arguemnts : 

	IN PWCHAR wszString - the string to be tested
	
Return Value : 
	
	 TRUE if it's a number, FALSE otherwise.
--*/

{
	PWCHAR	pwchPtr = wszString;

	while ( *pwchPtr ) 
		if ( !isdigit( *(pwchPtr++) ) )
			return FALSE;

	return TRUE;
}


HRESULT
VerifyProperty(	LPWSTR	wszPropName,
				LPWSTR	wszPropVal )
/*++

Routine Description : 

	Verify the validation of each property.

Arguemnts : 

	IN LPWSTR wszPropName	-	Property name
	IN LPWSTR wszPropVal	-	Property value
	
Return Value : 
	
	ERORR CODE;
--*/
{
	TraceFunctEnter("VerifyProperty");
	_ASSERT( wszPropName );
	_ASSERT( wszPropVal );

	HRESULT		hr;

	if ( lstrlenW( wszPropVal ) >= MAX_PROP_LEN ) {
		hr = TYPE_E_BUFFERTOOSMALL;
		goto done;
	}

	if ( wcscmp( wszPropName, QUERY_STRING_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, EMAIL_ADDRESS_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, NEWS_GROUP_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, LAST_SEARCH_DATE_NAME ) == 0 ) {
		// empty would be invalid, since it could be empty per user
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else
			hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, QUERY_ID_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, FROM_LINE_NAME ) == 0 ) {
		// empty is invalid
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, SUBJECT_LINE_NAME ) == 0) {
		// empty would be invalid, because it might also be used
		// for news message
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else
			hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, EDIT_URL_NAME ) == 0 ) {
		// empty is invalid
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else hr = S_OK;
	} else if ( wcscmp( wszPropName, MAIL_PICKUP_DIR_NAME ) == 0 ) {
		// need to verify the writability of that directory
		WIN32_FIND_DATAW	wfdFind;
		HANDLE				hFile;

		hFile = FindFirstFileW(		wszPropVal,
									&wfdFind	);
		
		if ( INVALID_HANDLE_VALUE == hFile ) {
			hr = E_INVALIDARG;
			goto done;
		}

		FindClose( hFile );

		if ((FILE_ATTRIBUTE_DIRECTORY & wfdFind.dwFileAttributes) == 0 ||
			FILE_ATTRIBUTE_READONLY & wfdFind.dwFileAttributes ) {
			hr = E_INVALIDARG;
			goto done;
		}

		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, QUERY_SERVER_NAME ) == 0 ) {
		// empty is invalid
		if ( wcscmp( wszPropVal, L"") == 0 ) 
			hr = E_INVALIDARG;
		else hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, QUERY_CATALOG_NAME ) == 0 ) {
		// empty is invalid
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, MESSAGE_TEMPLATE_TEXT_NAME) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, MESSAGE_TEMPLATE_FILE_NAME) == 0 ) {
		// should verify its readability and existance
		WIN32_FIND_DATAW	wfdFind;
		HANDLE				hFile;

		if ( wcscmp( wszPropVal, L"") == 0 ) {
			hr = E_INVALIDARG;
			goto done;
		}
		
		hFile = FindFirstFileW(		wszPropVal,
									&wfdFind	);
		
		if ( INVALID_HANDLE_VALUE == hFile ) {
			hr = E_INVALIDARG;
			goto done;
		}

		FindClose( hFile );

		if (FILE_ATTRIBUTE_DIRECTORY & wfdFind.dwFileAttributes ) {
			hr = E_INVALIDARG;
			goto done;
		}

		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, URL_TEMPLATE_TEXT_NAME) == 0 ) {
		// verify nothing
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, URL_TEMPLATE_FILE_NAME) == 0 ) {
		// should verify its existance and readability
		WIN32_FIND_DATAW	wfdFind;
		HANDLE				hFile;

		if ( wcscmp( wszPropVal, L"") == 0 ) {
			hr = E_INVALIDARG;
			goto done;
		}
		
		hFile = FindFirstFileW(		wszPropVal,
									&wfdFind	);
		
		if ( INVALID_HANDLE_VALUE == hFile ) {
			hr = E_INVALIDARG;
			goto done;
		}

		FindClose( hFile );

		if (FILE_ATTRIBUTE_DIRECTORY & wfdFind.dwFileAttributes ) {
			hr = E_INVALIDARG;
			goto done;
		}

		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, SEARCH_FREQUENCY_NAME) == 0 ) {
		// can'e be empty
		if ( wcscmp( wszPropVal, L"" ) == 0 ) {
			hr = E_INVALIDARG;
			goto done;
		}

		// should be a number
		if ( IsNumber( wszPropVal ) )
			hr = S_OK;
		else 
			hr = E_INVALIDARG;
		goto done;
	} else if ( wcscmp( wszPropName, IS_BAD_QUERY_NAME ) == 0 ) {
		// it's either "1" or "2"
		if (	wcscmp( wszPropVal, L"1" ) != 0 &&
				wcscmp( wszPropVal, L"0" ) != 0 ) 
			hr = E_INVALIDARG;
		else 
			hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, REPLY_MODE_NAME ) == 0 ) {
		// verify nothing
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, NEWS_SERVER_NAME) == 0 ) {
		// can't be empty
		if ( 	wcscmp( wszPropVal, L"" ) == 0 )
			hr = E_INVALIDARG;
		else
			hr = S_OK;
	} else if ( wcscmp( wszPropName, NEWS_PICKUP_DIR_NAME ) == 0 ) {
		// that should be a dir and writeable
		WIN32_FIND_DATAW	wfdFind;
		HANDLE				hFile;

		hFile = FindFirstFileW(	wszPropVal,
								&wfdFind );
		if ( INVALID_HANDLE_VALUE == hFile ) {
			hr = E_INVALIDARG;
			goto done;
		}

		FindClose( hFile );

		if ( (FILE_ATTRIBUTE_DIRECTORY & wfdFind.dwFileAttributes) == 0 ||
				FILE_ATTRIBUTE_READONLY & wfdFind.dwFileAttributes ) {
			hr = E_INVALIDARG;
			goto done;
		}

		hr = S_OK;
		goto done;
	}
	else { // property not found
		hr = DISP_E_UNKNOWNNAME;
		goto done;
	}

done:

	TraceFunctLeave();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\name.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    name.h

Abstract:

    This module contains the property name table class.  Properties 
	of query object and querybase object are all collected in the 
	name table, which facilitates the property loading and saving
	by name, value pairs.  The table also has other information like
	dirty bits for each property.

	This module is used by both the query object module and the query
	base module.


Author:

    Kangrong Yan  ( t-kyan )     27-June-1997

Revision History:

--*/
#ifndef _NAME_H_
#define _NAME_H_


// System includes
#include <stdlib.h>
#include <atlbase.h>

//
// Total number of properties
//
#define PROPERTY_TOTAL		20

//
// Max property buffer length
//
#define MAX_PROP_LEN		1024

//
// Property IDs
//
#define	QUERY_STRING		0
#define	EMAIL_ADDRESS		1
#define	NEWS_GROUP			2
#define	LAST_SEARCH_DATE	3
#define	QUERY_ID			4
#define	REPLY_MODE			5
#define	FROM_LINE			6
#define	SUBJECT_LINE		7
#define	EDIT_URL			8
#define	MAIL_PICKUP_DIR		9
#define QUERY_SERVER		10
#define	QUERY_CATALOG		11
#define MESSAGE_TEMPLATE_TEXT	12	
#define URL_TEMPLATE_TEXT		13
#define MESSAGE_TEMPLATE_FILE	14	
#define URL_TEMPLATE_FILE		15
#define SEARCH_FREQUENCY		16
#define IS_BAD_QUERY			17
#define	NEWS_SERVER				18
#define	NEWS_PICKUP_DIR			19

//
// Property Names
//
#define QUERY_STRING_NAME		L"query_string"
#define	EMAIL_ADDRESS_NAME		L"email_address"
#define	NEWS_GROUP_NAME			L"news_group"
#define	LAST_SEARCH_DATE_NAME	L"last_search"
#define	QUERY_ID_NAME			L"query_id"
#define	REPLY_MODE_NAME			L"reply_mode"
#define	FROM_LINE_NAME			L"from_line"
#define	SUBJECT_LINE_NAME		L"subject_line"
#define EDIT_URL_NAME			L"edit_url"
#define MAIL_PICKUP_DIR_NAME	L"mail_pickup_dir"
#define QUERY_SERVER_NAME		L"query_server"
#define	QUERY_CATALOG_NAME		L"query_catalog"
#define MESSAGE_TEMPLATE_TEXT_NAME	L"message_template_text"
#define MESSAGE_TEMPLATE_FILE_NAME	L"message_template_file"
#define URL_TEMPLATE_TEXT_NAME		L"url_template_text"
#define URL_TEMPLATE_FILE_NAME		L"url_template_file"
#define SEARCH_FREQUENCY_NAME		L"search_frequency"
#define IS_BAD_QUERY_NAME			L"is_bad"	
#define	NEWS_SERVER_NAME			L"news_server"
#define	NEWS_PICKUP_DIR_NAME		L"news_pickup_dir"

//
// Macros that ease the access to PropertyEntry's fields
//
#define	NAME( X )	( ( X )->wszName )
#define ID( X )		( ( X )->dwPropID )
#define VALUE( X )	( ( X )->varVal )
#define	DIRTY( X )  ( ( X )->fDirty )

typedef struct {
	LPWSTR		wszName;				//Property's name
	DWORD		dwPropID;				//Each property has a constant value
	VARIANT		varVal;					//Actual value of the property
	BOOL		fDirty;					//Dirty bit of each property
} PropertyEntry, *PPropertyEntry;

extern PropertyEntry	g_QueryPropertyTable[];
HRESULT VerifyProperty( LPWSTR wszPropName, LPWSTR wszPropVal);
 
class CPropertyTable {		//ptbl
private:
	//
	// Pointer to the property array
	//
	PropertyEntry m_pPropertyTable[PROPERTY_TOTAL];

public:

	//
	// Counter of total properties in the table
	//
	DWORD m_cProperties;

	//
	// Constructor, destructor
	//
	CPropertyTable();
	~CPropertyTable();

	//
	// Some access operator overloads
	//
	PPropertyEntry operator[]( const LPWSTR	wszName );
	PPropertyEntry operator[]( DWORD dwPropID );

};
	
#endif // _NAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by meta2.rc
//
#define IDS_PROJNAME                    100
#define IDR_REQ                         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


//#define INITGUIDS
//#include "initguid.h"
//#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\req.h ===
// req.h : Declaration of the Creq

#ifndef __REQ_H_
#define __REQ_H_

#include "resource.h"       // main symbols
#if defined(EXEXPRESS) | defined(PLATINUM)
#include "asptlb5.h"         // Active Server Pages Definitions
#else
#include <asptlb.h>
#endif

#include "metakey.h"
#include "name.h"

/////////////////////////////////////////////////////////////////////////////
// Creq
class ATL_NO_VTABLE Creq : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Creq, &CLSID_req>,
	public IDispatchImpl<Ireq, &IID_Ireq, &LIBID_META2Lib>
{
public:
	Creq()
	{ 
		InitAsyncTrace();
		TraceFunctEnter("Creq::Creq");

		m_bOnStartPageCalled = FALSE;
		m_fInitOk = FALSE;
		m_fEnumInit = FALSE;
		m_bstrProperty = NULL;

		OpenDatabase();
		TraceFunctLeave();
	}

	~Creq()
	{
		TraceFunctEnter("Creq::~Creq");
		if ( m_bstrProperty )
			SysFreeString( m_bstrProperty );

		CloseDatabase();

		TraceFunctLeave();
		TermAsyncTrace();
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_REQ)

BEGIN_COM_MAP(Creq)
	COM_INTERFACE_ENTRY(Ireq)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Ireq
public:
	STDMETHOD(Clean)();
	STDMETHOD(get_EnumSucceeded)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_ItemNextX)(/*[out, retval]*/ LPDISPATCH *pVal);
	STDMETHOD(get_NewX)(/*[out, retval]*/ LPDISPATCH *pVal);
	STDMETHOD(get_ItemX)(BSTR wszGuid, /*[out, retval]*/ LPDISPATCH *pVal);
	STDMETHOD(Delete)(BSTR wszGuid);
	STDMETHOD(ItemClose)();
	STDMETHOD(ItemNext)(IDispatch **ppdispQry, BOOL *fSuccess);
	STDMETHOD(ItemInit)();
	STDMETHOD(Item)(BSTR wszGuid, IDispatch **ppdispQry);
	STDMETHOD(Save)(IDispatch *pdispQry);
	STDMETHOD(Write)(BSTR wszPropName, BSTR bstrVal, BSTR wszGuid);
	STDMETHOD(Read)(BSTR wszPropName, BSTR *pbstrVal, BSTR wszGuid);
	STDMETHOD(New)(IDispatch **);
	STDMETHOD(get_property)(BSTR bstrName, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_property)(BSTR bstrName, /*[in]*/ BSTR newVal);
	STDMETHOD(test)();
	//STDMETHOD(get_ErrorString)(/*[out, retval]*/ BSTR *pVal);

	//Active Server Pages Methods
	STDMETHOD(OnStartPage)(IUnknown* IUnk);
	STDMETHOD(OnEndPage)();

private:
	//
	// Is the enumeration successful ?
	//
	BOOL	m_fEnumSuccess;

	//
	// Porperty buffer
	//
	BSTR	m_bstrProperty;

	// 
	// Property table, just used for ID / name translation,
	// the table itself doesn't contain values or dirty bits
	//
	CPropertyTable m_ptblTable;

	//
	// pointer to metabase object
	//
	IMSAdminBase	*m_pMeta ;
	
	//
	// is enumeration inited ?
	//
	BOOL m_fEnumInit;

	//
	// is the database opened
	//
	BOOL m_fInitOk;

	//
	// pointer to metabase
	//
	CMetabaseKey * m_pMK;

	
	//
	//	class global error code, set by whoever meets error,
	//	also needed by VBscript as a property of requested
	//  operation
	//
	DWORD m_dwErrorCode;

	//
	//  string buffer that contains the machine name on which 
	//  database is stored ( metabase is retrieved )
	//
	WCHAR m_wszMachineName[_MAX_PATH];

	//
	//  Error String that reflects run time error, will be 
	//  got by get_Error property
	//
	WCHAR m_wszErrorString[_MAX_PATH+1];

	//
	// uni / ansi utility
	//
	void Uni2Char(LPSTR	lpszDest, LPWSTR	lpwszSrc );
	void Char2Uni(LPWSTR	lpwszDest,		LPSTR	lpszSrc );

	//
	//  create root key "/LM/nntpsvc/1/reqdb", it's done only once
	//
	BOOL CreateRootKey();

	//
	// Create a key in meta base, a guid is assigned as the key name
	//
	BOOL CreateKey(		LPWSTR wszGuid, 
						BOOL fGuidGiven = FALSE);

	//
	//  Open a given key
	//
	BOOL OpenKey(	LPWSTR wszGuid = NULL,
					BOOL fReadOnly = TRUE );

	//
	//  Open a key, given index into the metabase
	//
	BOOL OpenKey( DWORD dwIndex );

	//
	//  Open the root key
	//
	BOOL OpenRootKey();

	//
	//  Close a key
	//
	void CloseKey( BOOL fNeedSave = FALSE );

	//
	//  Delete a key , given the guid
	//
	BOOL DeleteKey( LPWSTR );

	//
	//  Initialization for enumeration of keys
	//
	BOOL EnumKeyInit();

	//
	//  Enumerate next key, open it for reference
	//
	BOOL OpenNextKey( LPWSTR wszGuid = NULL ); 

	//
	// generate guid and convert it to string
	//
	BOOL GenGUID( LPWSTR *wszGuid );

	//
	// Open the database
	//
	BOOL OpenDatabase();

	//
	// Close the database
	//
	void CloseDatabase();

	//
	// Set value to the metabase
	//
	BOOL SetProperty( LPWSTR wszName, LPWSTR wszVal);

	//
	// Get value from the metabase
	//
	BOOL GetProperty( LPWSTR wszName, LPWSTR wszVal);

	//
	// Is a particular request existing ?
	//
	BOOL RequestExist( LPWSTR wszGuid );

	//
	// Set default properties for querybase
	//
	BOOL SelfConfig();

	//
	// Read a value, which is not in the query database from metabase
	//
	BOOL ReadMetaValue( LPWSTR wszKey, DWORD dwValID, LPWSTR wszOut );

	//
	// Get idispatch of a specific object
	//
	HRESULT Creq::StdPropertyGetIDispatch ( 
				REFCLSID clsid, 
				IDispatch ** ppIDispatch 
			);

	//
	//  Error status related methods
	//
	void ResetErrorCode()	{	m_dwErrorCode = 0; }
	BOOL fSysFine()	{	return SUCCEEDED( m_dwErrorCode);	}
	
	//
	//  ASP related member variables
	//
	CComPtr<IRequest> m_piRequest;					//Request Object
	CComPtr<IResponse> m_piResponse;				//Response Object
	CComPtr<ISessionObject> m_piSession;			//Session Object
	CComPtr<IServer> m_piServer;					//Server Object
	CComPtr<IApplicationObject> m_piApplication;	//Application Object
	BOOL m_bOnStartPageCalled;						//OnStartPage successful?
};

#endif //__REQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\req.cpp ===
// req.cpp : Implementation of Creq
#include "stdafx.h"
#include "meta2.h"
#include "req.h"
#include "metakey.h"
#include "name.h"
#include "nntpmeta.h"
#include "smtpinet.h"

#include <stdio.h>

#include "search.h"
#include "search_i.c"

//
// Prog ID or the query object
//
#define QUERY_OBJ_ID	L"qry.qry.1"

//
// some compile time constants
//
#define REQDB_ROOT			L"/LM/NNTPSVC/1/REQDB"	// database root key
#define REQDB_ROOT_PARENT	L"/LM/NNTPSVC/1"		// nntpsvc root key
#define REQDB_ROOT_NAME		L"REQDB"				// database's root key name
#define DB_ERROR		E_FAIL							// set to m_dwErrorCode for unspecified errors
													// that has no system error codes
#define MAIL_KEY			L"/LM/SMTPSVC/1/PARAMETERS" // smtpsvc key
#define MAIL_ROOT			L"/LM/SMTPSVC/1"			// smtpsvc root key
#define NEWS_ROOT			L"/LM/NNTPSVC/1"			// nntpsvc root key

											


/////////////////////////////////////////////////////////////////////////////
// Creq

STDMETHODIMP Creq::OnStartPage (IUnknown* pUnk)  
{

	if(!pUnk)
		return E_POINTER;

	CComPtr<IScriptingContext> spContext;
	HRESULT hr;

	// Get the IScriptingContext Interface
	hr = pUnk->QueryInterface(IID_IScriptingContext, (void **)&spContext);
	if(FAILED(hr))
		return hr;

	// Get Request Object Pointer
	hr = spContext->get_Request(&m_piRequest);
	if(FAILED(hr))
	{
		spContext.Release();
		return hr;
	}

	// Get Response Object Pointer
	hr = spContext->get_Response(&m_piResponse);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		return hr;
	}
	
	// Get Server Object Pointer
	hr = spContext->get_Server(&m_piServer);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		return hr;
	}
	
	// Get Session Object Pointer
	hr = spContext->get_Session(&m_piSession);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		return hr;
	}

	// Get Application Object Pointer
	hr = spContext->get_Application(&m_piApplication);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		m_piSession.Release();
		return hr;
	}
	m_bOnStartPageCalled = TRUE;
	return S_OK;
}

STDMETHODIMP Creq::OnEndPage ()  
{
	m_bOnStartPageCalled = FALSE;
	// Release all interfaces
	m_piRequest.Release();
	m_piResponse.Release();
	m_piServer.Release();
	m_piSession.Release();
	m_piApplication.Release();

	return S_OK;
}

BOOL
Creq::CreateKey(	LPWSTR wszKeyName,
					BOOL fGuidGiven )
/*++

Routine Description:

	Create a meta base key.  A GUID string is assigned to be key name.

Arguments:

	wszKeyName - OUT The key name that is assigned by guid, if NULL is
				 passed, then it's not filled with that key name.
	fGuidGiven - IN if to use the given guid

Return Value:

	True if success, false otherwise
--*/
{
	TraceFunctEnter("Creq::CreateKey");

	if ( m_fInitOk == FALSE || m_pMK == NULL ) {
		m_dwErrorCode = DB_ERROR;
		ErrorTrace(0, "Create key before open");
		return FALSE;
	}
		
	LPWSTR		wszGuid;
	HRESULT		hResult;

	//
	// if the guid is given, don't bother to generate one
	//
	if ( fGuidGiven ) {
		wszGuid = wszKeyName;
		goto after_gen_guid;
	}

	// Prepare for the Guid
	//
	if ( ! GenGUID( &wszGuid ) ) {
		DebugTrace(0, "false");
		return FALSE;
	}

	//
	//  fill in the key name
	//
	if ( wszKeyName ) 
		wcscpy( wszKeyName, wszGuid );

after_gen_guid:

	//
	//	Open root key
	//
	hResult = m_pMK->Open (	METADATA_MASTER_ROOT_HANDLE, 
							REQDB_ROOT, 
							METADATA_PERMISSION_WRITE );
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Can't open metabase. Error code: %x", hResult );
		return FALSE;
	}

	//
	// Create the key
	//
	hResult = m_pMK->CreateChild( wszGuid );
	if ( FAILED( hResult) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Create key fail. Error: %x", m_dwErrorCode);
		return FALSE;
	}

	//
	//  close the root key
	//
	//m_pMK->Save();
	m_pMK->Close();

	//
	//  Create key also opens that key at last, as will be a convenient 
	//  feature for users
	//
	if ( !OpenKey( wszGuid, FALSE ) ) {
		ErrorTrace(0, "Open after create fail");
		return FALSE;
	}

	TraceFunctLeave();
	return TRUE;
}

BOOL
Creq::OpenKey(	LPWSTR wszGuid,
				BOOL fReadOnly )
/*++

Routine Description:

	Open a request key.  The open automatically closes what is opened
	previously.  This is done in function Open.
	
Arguments:

	wszGuid   - IN Key name, which is a guid
	fReadOnly - IN True - open with read permission, FALSE - open with write

Return Value:

	True if success, false otherwise
--*/
{
	TraceFunctEnter("Creq::OpenKey");
	
	WCHAR	wszBuf[_MAX_PATH+1];
	HRESULT	hResult;
	DWORD	dwPermit;

	//
	// get the full path of the key name
	//
	wsprintf(wszBuf, L"%s/%s", REQDB_ROOT, wszGuid);

	//
	// Set permission
	//
	dwPermit = fReadOnly ?	METADATA_PERMISSION_READ : 
							METADATA_PERMISSION_WRITE;

	//
	// open it
	//
	hResult = m_pMK->Open (	METADATA_MASTER_ROOT_HANDLE, 
							wszBuf, 
							dwPermit );
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Open req key error: %x", m_dwErrorCode);
		return FALSE;
	}

	TraceFunctLeave();
	return TRUE;
}

BOOL
Creq::OpenRootKey()
/*++

Routine Description:

	Open the root key.  The open automatically closes what is opened
	previously.  This is done in function Open.
	
Arguments:

	fReadOnly - IN True - open with read permission, FALSE - open with write

Return Value:

	True if success, false otherwise
--*/
{
	TraceFunctEnter("Creq::OpenRootKey");

	HRESULT		hr;
	DWORD		dwPermit;

	//
	// Set permission
	//
	dwPermit =	METADATA_PERMISSION_READ |
				METADATA_PERMISSION_WRITE;

	//
	// open it
	//
	hr = m_pMK->Open (	METADATA_MASTER_ROOT_HANDLE, 
						REQDB_ROOT, 
						dwPermit );
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Open req key error: %x", m_dwErrorCode);
		TraceFunctLeave();
		return FALSE;
	}

	TraceFunctLeave();
	return TRUE;
}

void 
Creq::CloseKey( BOOL fNeedSave)
/*++

Routine Description:

	Close a key.
	
Arguments:

	None

Return Value:

	None
--*/
{
	TraceFunctEnter("Creq::CloseKey");
	_ASSERT(m_pMK);

	if ( fNeedSave )
		m_pMK->Save();

	m_pMK->Close();

	TraceFunctLeave();
}

BOOL
Creq::DeleteKey( LPWSTR wszGuid )
/*++

Routine Description:

	Delete a key, given the guid.
	
Arguments:

	wszGuid - IN guid string

Return Value:

	TRUE if success, FALSE otherwise
--*/
{
	TraceFunctEnter("Creq::DeleteKey");
	_ASSERT(m_pMK);

	WCHAR	wszBuf[_MAX_PATH];
	HRESULT	hResult;

	//
	// check if the key already exists
	//
	swprintf(wszBuf, L"%s/%s", REQDB_ROOT, wszGuid);
	hResult = m_pMK->Open( wszBuf );
	if ( FAILED( hResult ) ) {
		ErrorTrace( 0, "Key to delete doesn't exist");
		return TRUE;		// this is not an error
	}
	m_pMK->Close();

	//
	//	open db root key, in order to delete child
	//
	hResult = m_pMK->Open (	METADATA_MASTER_ROOT_HANDLE, 
							REQDB_ROOT, 
							METADATA_PERMISSION_WRITE );
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Open root key error: %x", m_dwErrorCode);
		return FALSE;
	}

	//
	//  delete
	//
	hResult = m_pMK->DestroyChild( wszGuid );
	
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Delete req key fail: %x", m_dwErrorCode);
		m_pMK->Close();
		return FALSE;
	}

	//m_pMK->Save();
	m_pMK->Close();
	TraceFunctLeave();
	return TRUE;
}

BOOL
Creq::EnumKeyInit()
/*++

Routine Description:

	Initialization for enumerating a key.
	
Arguments:

	None

Return Value:

	True if success, false otherwise
--*/
{
	TraceFunctEnter("Creq::EnumKeyInit");
	_ASSERT(m_pMK);

	HRESULT		hResult;

	
	//
	//  Open root key
	//
	hResult = m_pMK->Open (	METADATA_MASTER_ROOT_HANDLE, 
							REQDB_ROOT, 
							METADATA_PERMISSION_READ );
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Open root key error: %x", m_dwErrorCode);
		return FALSE;
	}

	m_pMK->BeginChildEnumeration();

	m_pMK->Close();
	
	TraceFunctLeave();
	return TRUE;
}

BOOL
Creq::OpenNextKey( LPWSTR wszGuid )
/*++

Routine Description:

	Open next request key in the enumeration.
	
Arguments:

	None

Return Value:

	True if success, false otherwise
--*/
{
	TraceFunctEnter("Creq::OpenNextKey");
	_ASSERT(m_pMK);

	HRESULT hResult;
	WCHAR	wszBuf[_MAX_PATH+1];
	WCHAR	wszBuf2[_MAX_PATH+1];


	//
	//  Open root key
	//
	hResult = m_pMK->Open (	METADATA_MASTER_ROOT_HANDLE, 
							REQDB_ROOT, 
							METADATA_PERMISSION_READ );
	if ( FAILED( hResult ) ) { 
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Open root key error: %x", m_dwErrorCode);
		return FALSE;
	}

	//
	// Get next key name
	//
	hResult = m_pMK->NextChild( wszBuf );
	m_pMK->Close();
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Enumerate next key error: %x", m_dwErrorCode);
		return FALSE;
	}

	if ( wszGuid )
		wcscpy( wszGuid, wszBuf );
	
	//
	//  get next key full name
	//
	wsprintf(wszBuf2, L"%s/%s", REQDB_ROOT, wszBuf);

	//
	//  Open this next key
	//
	hResult = m_pMK->Open (	METADATA_MASTER_ROOT_HANDLE, 
							wszBuf2, 
							METADATA_PERMISSION_READ );
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Open req key error: %x", m_dwErrorCode);
		return FALSE;
	}

	TraceFunctLeave();
	return TRUE;
}

BOOL 
Creq::GenGUID(LPWSTR *wszGuid)
/*++

Routine Description:

	Generate a Globally unique id.
	wszGuid's memory should be pre-allocated
	
Arguments:

	wszGuid - OUT string format of the UUID

Return Value:

	True if success, false otherwise
--*/
{
	TraceFunctEnter("Creq::GenGUID");

	GUID	guidData;
	
	//
	//  Create guid
	//
	HRESULT hResult = CoCreateGuid(&guidData);
	if ( FAILED( hResult) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Can't create uuid. Error code: %x", m_dwErrorCode);
		return FALSE;
	}

	//
	//   convert to string
	//
	RPC_STATUS rpcStatus = UuidToString(&guidData, wszGuid);
	if ( rpcStatus != RPC_S_OK ) {
		m_dwErrorCode = rpcStatus;
		ErrorTrace(0, "UUID conversion fail. rpc status: %x", m_dwErrorCode);
		return FALSE;
	}
	

	TraceFunctLeave();
	return TRUE;
}

BOOL
Creq::OpenDatabase()
/*++

Routine Description:

	Everyone who is trying to use this database must call this function
	to perform some initialization.

Arguments:

	None

Return Value:

	HRESULT error code.
--*/
{

	TraceFunctEnter("Creq::OpenDatabase");

	if ( m_fInitOk == TRUE ) {
		m_dwErrorCode = ERROR_ALREADY_INITIALIZED;
		ErrorTrace(0, "Try to open data base twice without closing");
		return FALSE;
	}
	
	// local variables
	HRESULT			hResult;
	DWORD			cMacName = MAX_COMPUTERNAME_LENGTH+1;
	
	//
	// get the machine name, assume the metabase we are using is local
	//
	if ( ! GetComputerName( m_wszMachineName, &cMacName ) ) {
		m_dwErrorCode = GetLastError();
		ErrorTrace(0, "Can't get computer name. Error code: %x", m_dwErrorCode);
		return FALSE;
	}

	//
	//  obtain metabase object for root key
	//
	hResult = CreateMetabaseObject ( m_wszMachineName, &m_pMeta );
	if ( FAILED(hResult) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Can't create meta object. Error code: %x", m_dwErrorCode);
		return FALSE;
	}

	//
	//  allocate memory for m_pMK 
	//
	_ASSERT(m_pMeta);
	m_pMK = new CMetabaseKey(m_pMeta);
	if ( !m_pMK ) {
		m_dwErrorCode = GetLastError();
		ErrorTrace(0, "Not enough memory space");
		return FALSE;
	}

		
	//
	//  Test if the root key exists, if not, have to create it
	//
	hResult = m_pMK->Open(	REQDB_ROOT	);

	if ( FAILED( hResult ) ) {
		if ( !CreateRootKey() )
			return FALSE;
	} else
		m_pMK->Close();

	//
	//  Set default properties at the root key
	//
	if ( !SelfConfig() ) 
		return FALSE;

	m_fInitOk = TRUE;

	TraceFunctLeave();
	
	return TRUE;
}

void
Creq::CloseDatabase()
/*++

Routine Description:

	A chance to clean up.  Client should call it at the end.
	
Arguments:

	None

Return Value:

	HRESULT error code.
--*/
{
	TraceFunctEnter("Creq::CloseDatabase");

	_ASSERT( m_fInitOk == TRUE );
	_ASSERT( m_pMK );
	
	m_fInitOk = FALSE;

	m_pMK->Close();
	m_pMK->Save();
	delete m_pMK;
	m_pMK = NULL;

	m_pMeta->Release();

	TraceFunctLeave();
}

BOOL
Creq::CreateRootKey()
/*++

Routine Description:

	Create root key for the database, this is only done once.
	
Arguments:

	None

Return Value:

	TRUE if succeed, FALSE otherwise
--*/
{
	TraceFunctEnter("Creq::CreateRootKey");
	_ASSERT( m_pMK );

	HRESULT		hResult;

	//
	//  First open parent key
	//
	hResult = m_pMK->Open (	METADATA_MASTER_ROOT_HANDLE, 
							REQDB_ROOT_PARENT, 
							METADATA_PERMISSION_WRITE);
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Unable to open DB's parent key. Errorcode: %x", m_dwErrorCode);
		return FALSE;
	}

	//
	//   Now create 
	//
	hResult = m_pMK->CreateChild( REQDB_ROOT_NAME );
	if ( FAILED( hResult ) ) {
		m_dwErrorCode = hResult;
		ErrorTrace(0, "Unable to create root key for DB. Error: %x", m_dwErrorCode);
		return FALSE;
	}

	//
	//   Close parant key
	//
	//m_pMK->Save();
	m_pMK->Close();

	return TRUE;
}

void
Creq::Uni2Char(
			LPSTR	lpszDest,
			LPWSTR	lpwszSrc )	{
/*++

Routine Description:

	Convert a unicode string into char string. Destination
	string should be preallocated and length of _MAX_PATH 
	should be prepared.

Arguments:

	lpszDest - Destination char string
	lpwszSrc - Source wide char string

Return Value:

	None
--*/
	WideCharToMultiByte( CP_ACP,
						  0,
						  lpwszSrc,
						  -1,
						  lpszDest,
						  _MAX_PATH,
						  NULL,
						  NULL );
}

void
Creq::Char2Uni(
			LPWSTR	lpwszDest,
			LPSTR	lpszSrc )	{
/*++

Routine Description:

	Convert a char string into unicode string. Destination
	string should be preallocated and length of _MAX_PATH 
	should be prepared.

Arguments:

	lpwszDest - Destination wide char string
	lpszSrc - Source char string

Return Value:

	None
--*/
	MultiByteToWideChar ( CP_ACP,
						   0,
						   lpszSrc,
						   -1,
						   lpwszDest,
						   _MAX_PATH );
	
}

BOOL
Creq::RequestExist(LPWSTR wszGuid)
/*++

Routine Description:

	Test if the specified key or request exists.

Arguments:

	wszGuid - IN guid to tests against ( required )
	
Return Value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter("Creq::TestRequestExist");

	_ASSERT( wszGuid );

	ResetErrorCode();

	WCHAR	wszBuf[_MAX_PATH+1];
	HRESULT	hResult;

	swprintf(wszBuf, L"%s/%s", REQDB_ROOT, wszGuid);
	hResult = m_pMK->Open( wszBuf );
	if ( FAILED( hResult ) )  {	// doesn't exist
		m_dwErrorCode = hResult;
		DebugTrace(0, "Key doesn't exist");
		return FALSE;
	}
		
	m_pMK->Close();
	
	return TRUE;
}

BOOL
Creq::SetProperty(	LPWSTR wszName,
					LPWSTR wszVal )
/*++

Routine Description:

	Set a property to the request in the metabase.  The
	request should have already been opened.  

	Right now all the properties are strings.

Arguments:

	wszName - IN Property name
	wszVal	- IN Property value
	
Return Value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter("Creq::SetProperty");

	_ASSERT( wszName );
	_ASSERT( wszVal );

	HRESULT	hr;
	DWORD	dwPropID;

	dwPropID = ID ( m_ptblTable[wszName] );

	hr = m_pMK->SetString(	dwPropID,
							wszVal );
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Set property fail: %x", hr );
		TraceFunctLeave();
		return FALSE;
	}

	TraceFunctLeave();

	return TRUE;
}

BOOL
Creq::GetProperty(	LPWSTR wszName, 
					LPWSTR wszVal )
/*++

Routine Description:

	Get the property from the metabase.  The request
	should already have been opened.

	Right now all properties are string.  _MAX_PATH's 
	space should be prepared for the buffer.

Arguments:

	wszName - IN Property name to get
	wszVal  - OUT address to fill in the property string
	
Return Value:

	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter("Creq::GetProperty");

	HRESULT	hr;
	DWORD	dwPropID;

	_ASSERT( wszName );
	_ASSERT( wszVal );

	//
	// Get property ID
	//
	dwPropID = ID( m_ptblTable[wszName] );


	hr = m_pMK->GetString(	dwPropID,
							wszVal,
							MAX_PROP_LEN*sizeof(WCHAR)	);
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Get property fail: %x", hr );
		TraceFunctLeave();
		return FALSE;
	}

	TraceFunctLeave();

	return TRUE;
}


STDMETHODIMP Creq::test()
{
	HRESULT hr;
	IDispatch *ppi;
	BOOL fsuc;
	Iqry *pi;

	hr = ItemInit();

	if ( FAILED( hr ) )
		return hr;

	hr = ItemNext(&ppi, &fsuc);

	if ( FAILED( hr) )
		return hr;

	while ( fsuc ) {

	pi = (Iqry *)ppi;
			
	if ( FAILED( hr ) )
		return hr;

	//hr = pi->put_EmailAddress(L"yan@rdrc.rpi.edu");
	
	hr = pi->DoQuery();

	if ( FAILED ( hr ))
		return hr;

	hr = ItemNext( &ppi, &fsuc );

	if ( FAILED( hr ) )
		return hr;
	}

	//hr = Save(ppi);
	hr = ItemClose();

	if ( FAILED( hr ) )
		return hr;

	pi->Release();

	return S_OK;
}

BOOL
Creq::SelfConfig()
/*++

Routine Description:

	Set some default values to the root key. These values
	may be changed by accessing querybase object's property.
	But it's set here in case the user doesn't want to 
	bother himself with that.
	
Arguments:

	None.

Return Value:

	TRUE if success, FALSE otherwise
--*/
{
	TraceFunctEnter("Creq::SelfConfig");

	WCHAR	wszBuf[MAX_PROP_LEN+1];
	WCHAR	wszMailPickupDir[_MAX_PATH];
	WCHAR	wszNewsPickupDir[_MAX_PATH];
	WCHAR	wszTemplateFile[_MAX_PATH];

	//
	// Open root key
	//
	if ( !OpenRootKey() ) {
		ErrorTrace(0, "Open root key error");
		goto fail;
	}

	//
	// Set properties, if doesn't exist
	//
	if ( !GetProperty(QUERY_STRING_NAME, wszBuf ) )
		if ( !SetProperty(QUERY_STRING_NAME, L"") )
			goto fail;

	if ( !GetProperty(EMAIL_ADDRESS_NAME, wszBuf) )
		if ( !SetProperty(EMAIL_ADDRESS_NAME, L"") )
			goto fail;

	if ( !GetProperty(NEWS_GROUP_NAME, wszBuf) )
		if ( !SetProperty(NEWS_GROUP_NAME, L"") )
			goto fail;	

	if ( !GetProperty(LAST_SEARCH_DATE_NAME, wszBuf) )
		if ( !SetProperty(LAST_SEARCH_DATE_NAME, L"97/7/1 0:0:0") )
			goto fail;

	if ( !GetProperty(REPLY_MODE_NAME, wszBuf) )
		if ( !SetProperty(REPLY_MODE_NAME, L"mail") )
			goto fail;

	if ( !GetProperty(FROM_LINE_NAME, wszBuf) )
		if ( !SetProperty(FROM_LINE_NAME, L"SearchMaster") )
			goto fail;

	if ( !GetProperty(SUBJECT_LINE_NAME, wszBuf) )
		if ( !SetProperty(SUBJECT_LINE_NAME, L"News Search Update") )
			goto fail;

	if ( !GetProperty(EDIT_URL_NAME, wszBuf) ) {

		// assume it to be default web address
		_ASSERT( m_wszMachineName );
		wsprintf( wszBuf, L"http://%s/News/search/edit.asp", m_wszMachineName );

		if ( !SetProperty(EDIT_URL_NAME, wszBuf ) )
			goto fail;
	}

	if ( !GetProperty(MAIL_PICKUP_DIR_NAME, wszBuf) ) {
		//
		// Get the dir from meta base
		//
		if ( !ReadMetaValue( 	MAIL_KEY,
								MD_MAIL_PICKUP_DIR,
								wszMailPickupDir ) )
			if ( !ReadMetaValue(	MAIL_ROOT,
									MD_MAIL_PICKUP_DIR,
									wszMailPickupDir ) )
 				wcscpy( wszMailPickupDir, L"" );

		//
		// should keep the root key open
		//
		if ( !OpenRootKey() ) {
			ErrorTrace(0, "Open root key fail");
			goto fail;
		}

		if (	!SetProperty(MAIL_PICKUP_DIR_NAME,
				wszMailPickupDir)  )
			goto fail;
	}

	if ( !GetProperty(QUERY_SERVER_NAME, wszBuf) )
		if ( !SetProperty(QUERY_SERVER_NAME, m_wszMachineName ) )
			goto fail;

	if ( !GetProperty(QUERY_CATALOG_NAME, wszBuf) )
		if ( !SetProperty(QUERY_CATALOG_NAME, L"Web") )
			goto fail;

	if ( !GetProperty(MESSAGE_TEMPLATE_TEXT_NAME, wszBuf) )
		if ( !SetProperty(	MESSAGE_TEMPLATE_TEXT_NAME,
							L"" ) )
			goto fail;

	if ( !GetProperty(MESSAGE_TEMPLATE_FILE_NAME, wszBuf) ) {
		//
		// get system directory
		//
		if ( GetSystemDirectory( 	wszTemplateFile,
									_MAX_PATH ) <= 0 ) {
			ErrorTrace(	0, 
						"Unable to get system directory: %d", 
						GetLastError() );
			goto fail;
		}

		//
		// apend something
		//
		wcscat( wszTemplateFile, L"\\inetsrv\\big.tem" );

		if ( !SetProperty( MESSAGE_TEMPLATE_FILE_NAME, wszTemplateFile ) )
			goto fail;
	}
	if ( !GetProperty(URL_TEMPLATE_TEXT_NAME, wszBuf) )
		if ( !SetProperty(	URL_TEMPLATE_TEXT_NAME,
							L"") )
			goto fail;

	if ( !GetProperty(URL_TEMPLATE_FILE_NAME, wszBuf) ) {
		//
		// get system directory
		//
		if ( GetSystemDirectory(	wszTemplateFile,
									_MAX_PATH ) <= 0 ) {
			ErrorTrace( 0,
						"Unable to get system directory: %d",
						GetLastError() );
			goto fail;
		}

		//
		// append something
		//
		wcscat( wszTemplateFile, L"\\inetsrv\\small.tem" );

		if ( !SetProperty( URL_TEMPLATE_FILE_NAME, wszTemplateFile) )
			goto fail;
	}
	if ( !GetProperty(SEARCH_FREQUENCY_NAME, wszBuf) )
		if ( !SetProperty( SEARCH_FREQUENCY_NAME, L"1") )
			goto fail;


	if ( !GetProperty(IS_BAD_QUERY_NAME, wszBuf) )
		if ( !SetProperty( IS_BAD_QUERY_NAME, L"0") )
			goto fail;

	if ( !GetProperty(NEWS_SERVER_NAME, wszBuf) )
		if ( !SetProperty( NEWS_SERVER_NAME, m_wszMachineName) )
			goto fail;

	if ( !GetProperty(NEWS_PICKUP_DIR_NAME, wszBuf) ) {
		//
		// get it from metabase
		//
		if ( !ReadMetaValue( 	NEWS_ROOT,
								MD_PICKUP_DIRECTORY,
								wszNewsPickupDir ) )
			wcscpy( wszNewsPickupDir, L"" );

		//
		// should keep the root key open
		//
		if ( !OpenRootKey() ) {
			ErrorTrace(0, "Open root key fail");
			goto fail;
		}

		if ( !SetProperty( NEWS_PICKUP_DIR_NAME,
							wszNewsPickupDir ) )
			goto fail;
	}
		
	
	CloseKey();

	TraceFunctLeave();

	return TRUE;

fail:
	CloseKey();

	ErrorTrace(0, "Write default properties fail");
	
	TraceFunctLeave();

	return FALSE;
}

STDMETHODIMP Creq::get_property(	BSTR bstrName, 
									BSTR * pVal)
/*++

Routine Description:

	Property interface, reading one property
	
Arguments:

	IN BSTR bstrName - name of the property
	OUT BSTR pVal    - Address to fill address of property value
						the space is allocated on the server side,
						and will only be valid before next call.

Return Value:

	HRESULT code.
--*/

{
	TraceFunctEnter("Creq::get_property");
	_ASSERT( bstrName );
	_ASSERT( pVal );

	ResetErrorCode();

	WCHAR			wszBuf[MAX_PROP_LEN+1];
	PPropertyEntry	pPropEntry = NULL;

	//
	// if it's the property of error status
	//
	if ( wcscmp( 	bstrName,
					L"ErrorString" ) == 0 ) {
		wcscpy( wszBuf, m_wszErrorString );
		goto done;
	}	


	//
	// Open root key for reading
	//
	if ( !OpenRootKey() ) {
		ErrorTrace(0, "Open root key error");
		wcscpy( m_wszErrorString, L"Open metabase root key error");
		TraceFunctLeave();
		return m_dwErrorCode;
	}
	
	//
	// it's illegal to try gettign some per request properties
	//
	if (	wcscmp( bstrName, QUERY_STRING_NAME ) == 0 ||
			wcscmp( bstrName, EMAIL_ADDRESS_NAME ) == 0 ||
			wcscmp( bstrName, QUERY_ID_NAME ) == 0 ) { 
		ErrorTrace(0, "Try setting per request properties");
		wcscpy( m_wszErrorString, L"Property doesn't exist");
		m_dwErrorCode = DB_ERROR;
		TraceFunctLeave();
		return m_dwErrorCode;			
	}

	//
	// make sure the name passed in is valid
	//
	pPropEntry = m_ptblTable[ bstrName ];
	if ( !pPropEntry ) {
		ErrorTrace(0, "Invalid property name");
		wcscpy( m_wszErrorString, L"Property doesn't exist");
		m_dwErrorCode = DB_ERROR;
		CloseKey();
		TraceFunctLeave();
		return m_dwErrorCode;
	}

	//
	//  get property
	//
	if ( !GetProperty( bstrName, wszBuf) ) {
		ErrorTrace(0, "Get property fail");
		wcscpy( m_wszErrorString, L"Get property fail");
		CloseKey();
		TraceFunctLeave();
		return m_dwErrorCode;
	}

	CloseKey();

done:

	//
	//  prepare return string
	//
	if ( m_bstrProperty )
		SysFreeString( m_bstrProperty );
	m_bstrProperty = SysAllocString( wszBuf );
	if ( !m_bstrProperty ) {
		ErrorTrace(0, "Sys Alloc String fail");
		wcscpy( m_wszErrorString, L"Out of memory");
		m_dwErrorCode = DB_ERROR;
		CloseKey();
		TraceFunctLeave();
		return m_dwErrorCode;
	}

	//
	// assign it
	//
	*pVal = m_bstrProperty;

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Creq::put_property(	BSTR bstrName, 
									BSTR newVal)
/*++

Routine Description:

	Property interface, setting one property
	
Arguments:

	IN BSTR bstrName - name of the property
	IN BSTR newVal   - value to set

Return Value:

	HRESULT code.
--*/
{
	TraceFunctEnter("Creq::put_property");
	_ASSERT( bstrName );
	_ASSERT( newVal );

	ResetErrorCode();

	HRESULT 	hr;
	hr = VerifyProperty( 	bstrName,
							newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Verify property fail");
		swprintf(	m_wszErrorString, 
					L"Property %s invalid", 
					bstrName );
		TraceFunctLeave();
		return hr;
	}

	//
	// string length validation
	//
	if ( lstrlenW( newVal ) >= MAX_PROP_LEN ) {
		TraceFunctLeave();
		wcscpy(	m_wszErrorString, L"Input too long" );
		return TYPE_E_BUFFERTOOSMALL;
	}

	//
	// Open root key for writing
	//
	if ( !OpenRootKey() ) {
		ErrorTrace(0, "Open root key error");
		
		wcscpy( m_wszErrorString, L"Open root key error");
		TraceFunctLeave();
		return m_dwErrorCode;
	}
	
	//
	// it's illegal to try setting some per request properties
	//
	if (	wcscmp( bstrName, QUERY_STRING_NAME ) == 0 ||
			wcscmp( bstrName, EMAIL_ADDRESS_NAME ) == 0 ||
			wcscmp( bstrName, QUERY_ID_NAME ) == 0 ) { 
		ErrorTrace(0, "Try setting per request properties");
		wcscpy( m_wszErrorString, L"Setting property not allowed");
		m_dwErrorCode = DB_ERROR;
		TraceFunctLeave();
		return m_dwErrorCode;	
	}

	//
	// make sure the name passed in is valid
	//
	PPropertyEntry pPropEntry = m_ptblTable[ bstrName ];
	if ( !pPropEntry ) {
		ErrorTrace(0, "Invalid property name");
		wcscpy( m_wszErrorString, L"Invalid property name");
		m_dwErrorCode = DB_ERROR;
		CloseKey();
		TraceFunctLeave();
		return m_dwErrorCode;
	}

	//
	//  put property
	//
	if ( !SetProperty( bstrName, newVal) ) {
		ErrorTrace(0, "Get property fail");
		wcscpy( m_wszErrorString, L"Set property fail");
		CloseKey();
		TraceFunctLeave();
		return m_dwErrorCode;
	}

	CloseKey();

	TraceFunctLeave();

	return S_OK;
}

//$-------------------------------------------------------------------
//
//	StdPropertyGetIDispatch ( by Magnus )
//
//	Description:
//
//		Gets a IDispatch pointer for the given cLSID
//
//	Parameters:
//
//		clsid		- OLE CLSID of the object
//		ppIDipsatch	- the IDispatch pointer to that object.
//
//	Returns:
//
//		E_POINTER	- invalid argument
//		NOERROR		- Success
//		Others - defined by CoCreateInstance.
//
//--------------------------------------------------------------------
HRESULT 
Creq::StdPropertyGetIDispatch ( 
		REFCLSID clsid, 
		IDispatch ** ppIDispatch 
		)
{
	TraceFunctEnter ( "StdPropertyGetIDispatch" );

	CComPtr<IDispatch>	pNewIDispatch;
	HRESULT				hr = NOERROR;

	_ASSERT ( ppIDispatch );

	if ( ppIDispatch == NULL ) {
		FatalTrace ( 0, "Bad return pointer" );
		TraceFunctLeave ();
		return E_POINTER;
	}

	*ppIDispatch = NULL;

	hr = ::CoCreateInstance ( 
		clsid,
		NULL, 
		CLSCTX_ALL, 
		IID_IDispatch,
		(void **) &pNewIDispatch
		);

	if ( FAILED (hr) ) {
		DebugTraceX ( 0, "CoCreate(IDispatch) failed %x", hr );
		FatalTrace ( 0, "Failed to create IDispatch" );
		goto Exit;
	}

	*ppIDispatch = pNewIDispatch;
	pNewIDispatch->AddRef ();

Exit:
	TraceFunctLeave ();
	return hr;

	// Destructor releases pNewIDispatch
}

STDMETHODIMP Creq::New(IDispatch **ppdispQry)
/*++

Routine Description:

	Create a new query object.
	
Arguments:

	OUT IDispatch ** pIDisp - The pointer to the dispatch interface.

Return Value:

	HRESULT code.
--*/

{
	TraceFunctEnter("Creq::New");

	ResetErrorCode();

	HRESULT		hr;
	CLSID		clsid;
	WCHAR		wszGuid[_MAX_PATH];
	Iqry		*piQry;
	
	//
	// convert the progid to clsid
	//
	hr = CLSIDFromProgID(	QUERY_OBJ_ID,
							&clsid	);
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Component class doesn't exist");
		wcscpy( m_wszErrorString, L"Component class doesn't exist");
		TraceFunctLeave();
		return hr;
	}


	//
	// create object and get idispatch
	//
	hr =  Creq::StdPropertyGetIDispatch (	clsid, 
											ppdispQry);
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Get idispatch fail");
		wcscpy( m_wszErrorString, L"Get IDispatch fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// load the object, note that at this moment, the key for
	// the query object will only be created temporarily. It 
	// will be created permanently when saved back
	//
	
	// create key for the object
	if ( !CreateKey( wszGuid ) ) {
		ErrorTrace(0, "Create key fail");
		wcscpy( m_wszErrorString, L"Create key fail");
		TraceFunctLeave();
		return m_dwErrorCode;
	}

	// load
	piQry = (Iqry *)(*ppdispQry);
	hr = piQry->Load(	wszGuid,
						(IDispatch *)this,
						TRUE );
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Load fail: %x", hr);
		wcscpy( m_wszErrorString, L"Load property fail");
		CloseKey();
		TraceFunctLeave();
		return hr;
	}

	CloseKey();

	// now delete this key, because it has incomplete information
	// now, if the object is not saved back, it shouldn't exist
	if ( !DeleteKey( wszGuid ) ) {
		ErrorTrace(0, "Delete key fail");
		wcscpy( m_wszErrorString, L"Delete key fail");
		TraceFunctLeave();
		return m_dwErrorCode;
	}
	
	TraceFunctLeave();

	return S_OK;
}


STDMETHODIMP Creq::Read(	BSTR wszPropName, 
							BSTR * pbstrVal,
							BSTR wszGuid )
/*++

Routine Description:

	Read a property from querybase object
	
Arguments:

	IN BSTR wszPropName - Name of the property
	OUT BSTR * pbstrVal - Will contain the value to be passed out
	IN BSTR wszGuid - The object's ID

Return Value:

	HRESULT code.
--*/
{
	TraceFunctEnter("Creq::Read");
	_ASSERT( wszPropName );
	_ASSERT( pbstrVal );
	_ASSERT( wszGuid );

	ResetErrorCode();

	WCHAR	wszBuf[MAX_PROP_LEN+1];

	//
	//  if trying to read the guid itself, return it right away
	//
	if ( wcscmp( wszPropName, QUERY_ID_NAME ) == 0 ) {
		wcscpy( wszBuf, wszGuid );
		goto done;
	}

	//
	// Otherwise get it from the metabase
	//
	if ( !OpenKey( wszGuid ) ) {
		ErrorTrace(0, "Can't open key");
		wcscpy( m_wszErrorString, L"Can't open key");
		goto fail;
	}

	if ( !GetProperty(	wszPropName, 
						wszBuf ) ) {
		ErrorTrace(0, "Get property fail");
		wcscpy( m_wszErrorString, L"Get property fail");
		CloseKey();
		goto fail;
	}

	//
	// if the property is empty, I will get it from
	// root key again
	//
	if ( wcscmp(	wszBuf,
					L"" ) == 0 ) {
		CloseKey();
	    if ( !OpenRootKey() ) {
			ErrorTrace(0, "Open root key fail");
			wcscpy( m_wszErrorString, L"Open root key fail");
			goto fail;
		}

		if ( !GetProperty(	wszPropName,
							wszBuf ) ) {
			ErrorTrace(0, "Get property fail");
			wcscpy( m_wszErrorString, L"Get property fail");
			CloseKey();
			goto fail;
		}
	}

done:
	if ( m_bstrProperty )
		SysFreeString( m_bstrProperty );
	m_bstrProperty = SysAllocString( wszBuf );

	if ( !m_bstrProperty ) {
		ErrorTrace(0, "Sys alloc string fail");
		wcscpy( m_wszErrorString, L"Out of memory");
		m_dwErrorCode = DB_ERROR;
		CloseKey();
		goto fail;
	}

	*pbstrVal = m_bstrProperty;

	CloseKey();			//extra close doesn't harm

	TraceFunctLeave();

	return S_OK;

fail:
	
	TraceFunctLeave();

	return m_dwErrorCode;
}

STDMETHODIMP Creq::Write(	BSTR wszPropName, 
							BSTR bstrVal, 
							BSTR wszGuid)
/*++

Routine Description:

	Write a property from querybase object
	
Arguments:

	IN BSTR wszPropName - Name of the property
	IN BSTR bstrVal - the property value to write
	IN BSTR wszGuid - The object's ID

Return Value:

	HRESULT code.
--*/
{
	TraceFunctEnter("Creq::Write");
	_ASSERT( wszGuid );
	_ASSERT( wszPropName );
	_ASSERT( bstrVal );

	ResetErrorCode();

	//
	// only everal properties can be written by query object
	//
	if (	wcscmp( wszPropName, QUERY_STRING_NAME ) == 0 ||
			wcscmp( wszPropName, EMAIL_ADDRESS_NAME ) == 0 ||
			wcscmp( wszPropName, NEWS_GROUP_NAME ) == 0 ||
			wcscmp( wszPropName, REPLY_MODE_NAME ) == 0 ||
			wcscmp( wszPropName, LAST_SEARCH_DATE_NAME ) == 0 ||
			wcscmp( wszPropName, MESSAGE_TEMPLATE_TEXT_NAME) == 0 ||
			wcscmp( wszPropName, URL_TEMPLATE_TEXT_NAME) == 0 ||
			wcscmp( wszPropName, MESSAGE_TEMPLATE_FILE_NAME) == 0 ||
			wcscmp( wszPropName, URL_TEMPLATE_FILE_NAME ) == 0 ||
			wcscmp( wszPropName, SEARCH_FREQUENCY_NAME) == 0 ||
			wcscmp( wszPropName, IS_BAD_QUERY_NAME) == 0 ) {
		
		// open key
		if ( !OpenKey( wszGuid, FALSE ) )   // try create it
			if ( !CreateKey( wszGuid, TRUE	) ) {
				ErrorTrace(0, "Unable to open or create key");
				wcscpy( m_wszErrorString, L"Open key error");
				goto fail;
			}
		
		// set it
		if ( !SetProperty(	wszPropName,
							bstrVal ) ) {
			ErrorTrace(0, "Set property error");
			wcscpy( m_wszErrorString, L"Set property fail");
			CloseKey();
			goto fail;
		}
	
		CloseKey();
	}  //otherwise ignore it

	TraceFunctLeave();
	return S_OK;

fail:

	TraceFunctLeave();

	return m_dwErrorCode;
}

STDMETHODIMP Creq::Save(IDispatch * pdispQry)
/*++

Routine Description:

	Ask the querybase object to save the query object
	
Arguments:

	IN IDispatch *pdispQry - Interface pointer the the query object

Return Value:

	HRESULT error code
--*/

{
	TraceFunctEnter("Creq::Save");
	_ASSERT( pdispQry );

	ResetErrorCode();

	HRESULT		hr;
	Iqry		*piQry;

	piQry = (Iqry *)pdispQry;
	
	hr = piQry->Save(	(IDispatch *)this,
						TRUE,
						FALSE	);
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Save query object fail: %x", hr);
		wcscpy( m_wszErrorString, L"Save query object fail");
		TraceFunctLeave();
		return hr;
	}

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Creq::Item(	BSTR wszGuid, 
							IDispatch * * ppdispQry)
/*++

Routine Description:

	Reference a query object by guid
	
Arguments:

	IN BSTR wszGuid			- The query ID
	OUT IDispatch ** ppdispQry - The pointer to the dispatch interface.

Return Value:

	HRESULT code.
--*/

{
	TraceFunctEnter("Creq::Item");
	_ASSERT( wszGuid );
	_ASSERT( ppdispQry );

	ResetErrorCode();

	HRESULT		hr;
	CLSID		clsid;
	Iqry		*piQry;
	
	//
	// convert the progid to clsid
	//
	hr = CLSIDFromProgID(	QUERY_OBJ_ID,
							&clsid	);
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Component class doesn't exist");
		wcscpy( m_wszErrorString, L"Component class doesn't exist");
		TraceFunctLeave();
		return hr;
	}


	//
	// create object and get idispatch
	//
	hr =  Creq::StdPropertyGetIDispatch (	clsid, 
											ppdispQry);
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Get idispatch fail");
		wcscpy( m_wszErrorString, L"Get IDispatch fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// load the object, 
	//
	
	// open key for the object
	if ( !OpenKey( wszGuid ) ) {
		ErrorTrace(0, "Open key fail");
		wcscpy( m_wszErrorString, L"Open key fail");
		TraceFunctLeave();
		return m_dwErrorCode;
	}

	// load
	piQry = (Iqry *)(*ppdispQry);
	hr = piQry->Load(	wszGuid,
						(IDispatch *)this,
						FALSE );
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Load fail: %x", hr);
		wcscpy( m_wszErrorString, L"Load property fail");
		CloseKey();
		TraceFunctLeave();
		return hr;
	}

	CloseKey();
	
	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Creq::ItemInit()
/*++

Routine Description:

	Initialization of enumeration.
	
Arguments:

	None.

Return Value:

	HRESULT code.
--*/

{
	TraceFunctEnter("Creq::ItemInit");

	ResetErrorCode();

	if ( EnumKeyInit() ) {
		m_fEnumInit = TRUE;
		m_fEnumSuccess = FALSE;
		TraceFunctLeave();
		return S_OK;
	} else {
		TraceFunctLeave();
		wcscpy( m_wszErrorString, L"Item initialization fail");
		return m_dwErrorCode;
	}
}


STDMETHODIMP Creq::ItemNext(	IDispatch * * ppdispQry,
								BOOL *fSuccess)
/*++

Routine Description:

	Reference next query object during an enumeration
	
Arguments:

	OUT IDispatch ** ppdispQry - The pointer to the dispatch interface.
	OUT BOOL *fSuccess -  If this enumeration is successful, it should
							be judged by the returned handle value.

Return Value:

	HRESULT code.
--*/

{
	TraceFunctEnter("Creq::Item");
	_ASSERT( ppdispQry );

	ResetErrorCode();

	HRESULT		hr;
	CLSID		clsid;
	Iqry		*piQry;
	WCHAR		wszGuid[_MAX_PATH+1];

	if ( !m_fEnumInit ) {
		ErrorTrace(0, "Enum not inited");
		wcscpy( m_wszErrorString, L"Enumeration not inited");
		m_dwErrorCode = DB_ERROR;
		TraceFunctLeave();
		return m_dwErrorCode;
	}
	
	//
	// convert the progid to clsid
	//
	hr = CLSIDFromProgID(	QUERY_OBJ_ID,
							&clsid	);
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Component class doesn't exist");
		wcscpy( m_wszErrorString, L"Component class doesn't exist");
		TraceFunctLeave();
		return hr;
	}

	//
	// create object and get idispatch
	//
	hr =  Creq::StdPropertyGetIDispatch (	clsid, 
											ppdispQry);
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Get idispatch fail");
		wcscpy( m_wszErrorString, L"Get IDispatch fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// load the object, 
	//
	
	// open key for the object
	if ( !OpenNextKey( wszGuid ) ) {
		ErrorTrace(0, "Open key fail");
		*fSuccess = FALSE;
		(*ppdispQry)->Release();
		TraceFunctLeave();
		return S_OK;  // return a error code might cause asp crash,
					  //  which is not what the asp programmers expect,
					  //  so should only use fSuccess to test if an
					  //  enumeration succeeds.
	}

	// load
	piQry = (Iqry *)(*ppdispQry);
	hr = piQry->Load(	wszGuid,
						(IDispatch *)this,
						FALSE );
	if ( FAILED( hr ) ) {
		m_dwErrorCode = hr;
		ErrorTrace(0, "Load fail: %x", hr);
		wcscpy( m_wszErrorString, L"Load object fail");
		CloseKey();
		TraceFunctLeave();
		return hr;
	}

	CloseKey();
	*fSuccess = TRUE;
	TraceFunctLeave();
	return S_OK;
}

STDMETHODIMP Creq::ItemClose()
/*++

Routine Description:

	Close an enumeration
	
Arguments:

	None.

Return Value:

	HRESULT code.
--*/
{
	TraceFunctEnter("Creq::ItemClose");
	ResetErrorCode();

	CloseKey();		// extra close key doesn't harm

	m_fEnumInit = FALSE;

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Creq::Delete(BSTR wszGuid)
/*++

Routine Description:

	Delete a query object permanently.
	
Arguments:

	IN BSTR wszGuid - The query object's ID

Return Value:

	HRESULT code.
--*/

{
	TraceFunctEnter("Creq::Delete");
	_ASSERT( wszGuid );

	ResetErrorCode();

	if ( !DeleteKey( wszGuid ) ) {
		ErrorTrace(0, "Delete key fail");
		wcscpy( m_wszErrorString, L"Delete key fail");
		TraceFunctLeave();
		return m_dwErrorCode;
	}

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Creq::get_ItemX(	BSTR wszGuid, 
								LPDISPATCH * pVal)
/*++

Routine Description:

	Reference a query object, used by VB script as property.
	
Arguments:

	IN BSTR wszGuid - The query object's ID
	OUT LPDISPATCH pVal - the property value to be returned.

Return Value:

	HRESULT code.
--*/
{
	TraceFunctEnter("Creq::get_ItemX");
	HRESULT hr;

	hr = Item(	wszGuid,
				pVal	);

	TraceFunctLeave();
	return hr;
}


STDMETHODIMP Creq::get_NewX(LPDISPATCH * pVal)
/*++

Routine Description:

	Create a new query object and return it.  Used by 
	VBscript as a property.
	
Arguments:

	OUT LPDISPATCH pVal - the property value to be returned.

Return Value:

	HRESULT code.
--*/

{
	TraceFunctEnter("Creq::get_NewX");
	HRESULT hr;

	hr = New( pVal );

	TraceFunctLeave();

	return hr;
}

STDMETHODIMP Creq::get_ItemNextX(LPDISPATCH * pVal)
/*++

Routine Description:

	Enumerate the next query object. Used by VBscript as 
	a property.
	
Arguments:

	OUT LPDISPATCH pVal - the property value to be returned.

Return Value:

	HRESULT code.
--*/
{
	TraceFunctEnter("Creq::get_ItemNextX");
	HRESULT		hr;

	hr = ItemNext( pVal, &m_fEnumSuccess);

	TraceFunctLeave();
	return hr;
}

STDMETHODIMP Creq::get_EnumSucceeded(BOOL * pVal)
/*++

Routine Description:

	Property to show if the last enumeration succeeded.
	
Arguments:

	OUT BOOL *pVal - Address to put the boolean value

Return Value:

	HRESULT code.
--*/
{
	TraceFunctEnter("Creq::get_EnumSucceeded");

	*pVal = m_fEnumSuccess;

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Creq::Clean()
/*++

Routine Description:

	To clean all the bad queries
	
Arguments:

	None

Return Value:

	HRESULT code.
--*/

{
	TraceFunctEnter("Creq::Clean");

	BOOL	fMore = TRUE;
	HRESULT hr;
	WCHAR	wszGuid[_MAX_PATH+1];
	WCHAR	wszProp[MAX_PROP_LEN];

	ResetErrorCode();

	//
	// The outer loop is because the defect of metakey
	// enumeration: if one key is deleted, its next key
	// might not be enumerated.  So if one bad query is
	// cleaned, if its next key is bad, it won't be cleaned
	// and we should go over again, until no bad query exists
	//
	while ( fMore ) {

		fMore = FALSE;

		hr = ItemInit();
		if ( FAILED( hr ) ) {
			ErrorTrace(0, "Item Init fail: %x", hr);
			wcscpy( m_wszErrorString, L"Item init fail");
			TraceFunctLeave();
			return hr;
		}

		while ( OpenNextKey( wszGuid ) ) {
			
			if ( !GetProperty( 	IS_BAD_QUERY_NAME,
								wszProp ) ) {
				ErrorTrace(0, "Get property fail: %x", m_dwErrorCode);
				wcscpy( m_wszErrorString, L"Get property fail");
				CloseKey();
				TraceFunctLeave();		
				return m_dwErrorCode;
			}

			CloseKey();

			if ( wcscmp( wszProp, L"1" ) == 0 ) {
				fMore = TRUE;
				DeleteKey( wszGuid );
			}
		}

		hr = ItemClose();
		if ( FAILED( hr ) ) {
			ErrorTrace(0, "Item Close fail: %x", hr );
			wcscpy( m_wszErrorString, L"Item close fail");
			TraceFunctLeave();
			return hr;
		}
	}


	TraceFunctLeave();
	return S_OK;
}

BOOL
Creq::ReadMetaValue(	LPWSTR	wszKey,
						DWORD	dwValID,
						LPWSTR  wszOut )
/*++

Routine Description:

	Read a value from a specified metabase key.  Since all other
	metabase operations are query databaes oriented, this function
	is written to handle other metabase key read.  Note that since
	it's using the same metabase object as the query database, this
	method can't be called when a database key is opened already.
	Or the caller should properly handle this.

	Other than this, this method should have no negative effect on
	the query database operation.

	This method is used to read string type value only.

Arguments:

	IN LPWSTR wszKey - Key to open
	IN DWORD dwValID - ID of value to read
	OUT LPWSTR wszOut- Address to put the metabase value

Returned Value:

	TRUE if successful, FALSE otherwise

--*/
{
	TraceFunctEnter("Creq::ReadMetaValue");
	_ASSERT( wszKey );
	_ASSERT( dwValID >= 0 );
	_ASSERT( wszOut );
	_ASSERT( m_pMK );

	HRESULT 	hr;

	ResetErrorCode();

	// 
	// Close Key first
	//
	CloseKey();  //extra close key doesn't harm

	//
	// Open key
	//
	hr = m_pMK->Open( wszKey );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Open key fail: %x", hr);
		m_dwErrorCode = hr;
		TraceFunctLeave();
		return FALSE;
	}

	//
	// Read the value
	//
	hr = m_pMK->GetString(	dwValID,
							wszOut,
							_MAX_PATH*sizeof( WCHAR ) );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Read metabase value fail: %x", hr);
		m_dwErrorCode = hr;
		m_pMK->Close();
		TraceFunctLeave();
		return FALSE;
	}

	//
	// close key
	//
	m_pMK->Close();

	TraceFunctLeave();
	return TRUE;
}

/*
STDMETHODIMP Creq::get_ErrorString(BSTR * pVal)*/
/*++

Routine Description:

	Enumerate the next query object. Used by VBscript as 
	a property.
	
Arguments:

	OUT LPDISPATCH pVal - the property value to be returned.

Return Value:

	HRESULT code.
--*//*
{
	TraceFunctEnter("Creq::get_ErrorString");
FILE *fp = fopen("c:\\try\\bad.log", "w");
fclose(fp);
	
	*pVal = SysAllocString( m_wszErrorString );
	DebugTraceX(0, "Error string is: %ws", m_wszErrorString);
	if ( ! *pVal ) {
		ErrorTrace(0, "SysAllocString error");
		TraceFunctLeave();
		return E_OUTOFMEMORY;
	}
	TraceFunctLeave();
	return S_OK;
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qrydb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__583BDCA4_E7F7_11D0_91E8_00AA00C148BE__INCLUDED_)
#define AFX_STDAFX_H__583BDCA4_E7F7_11D0_91E8_00AA00C148BE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#define _UNICODE
#define UNICODE

#include <windows.h>


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//  Debugging support:
#undef _ASSERT
#include <dbgtrace.h>


//  The Metabase:
#include <iadmw.h>
#include <iiscnfg.h>

#include "admmacro.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__583BDCA4_E7F7_11D0_91E8_00AA00C148BE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\asptlb5.h ===
// This file was generated by mktyplib.exe, then munged by Active Server Pages build. 
// Changes: 
// - we include "dispatch.h" (our standard IDispatch implementation) 
// 
// - we #define "NO_BASEINTERFACE_FUNCS" to prevent pure virtual 
// redefinitions of the four IDispatch members that CDispatch defines. 
// 
// - we change the derivation of the classes from "IDispatch" to "CDispatch" 
// 
#include "dispatch.h" 
#define NO_BASEINTERFACE_FUNCS 
// 
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0106 */
/* at Tue Jul 15 12:18:35 1997
 */
/* Compiler settings for asp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef ___asptlb_h__
#define ___asptlb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IStringList_FWD_DEFINED__
#define __IStringList_FWD_DEFINED__
typedef interface IStringList IStringList;
#endif 	/* __IStringList_FWD_DEFINED__ */


#ifndef __IRequestDictionary_FWD_DEFINED__
#define __IRequestDictionary_FWD_DEFINED__
typedef interface IRequestDictionary IRequestDictionary;
#endif 	/* __IRequestDictionary_FWD_DEFINED__ */


#ifndef __IRequest_FWD_DEFINED__
#define __IRequest_FWD_DEFINED__
typedef interface IRequest IRequest;
#endif 	/* __IRequest_FWD_DEFINED__ */


#ifndef __Request_FWD_DEFINED__
#define __Request_FWD_DEFINED__

#ifdef __cplusplus
typedef class Request Request;
#else
typedef struct Request Request;
#endif /* __cplusplus */

#endif 	/* __Request_FWD_DEFINED__ */


#ifndef __IReadCookie_FWD_DEFINED__
#define __IReadCookie_FWD_DEFINED__
typedef interface IReadCookie IReadCookie;
#endif 	/* __IReadCookie_FWD_DEFINED__ */


#ifndef __IWriteCookie_FWD_DEFINED__
#define __IWriteCookie_FWD_DEFINED__
typedef interface IWriteCookie IWriteCookie;
#endif 	/* __IWriteCookie_FWD_DEFINED__ */


#ifndef __IResponse_FWD_DEFINED__
#define __IResponse_FWD_DEFINED__
typedef interface IResponse IResponse;
#endif 	/* __IResponse_FWD_DEFINED__ */


#ifndef __Response_FWD_DEFINED__
#define __Response_FWD_DEFINED__

#ifdef __cplusplus
typedef class Response Response;
#else
typedef struct Response Response;
#endif /* __cplusplus */

#endif 	/* __Response_FWD_DEFINED__ */


#ifndef __IVariantDictionary_FWD_DEFINED__
#define __IVariantDictionary_FWD_DEFINED__
typedef interface IVariantDictionary IVariantDictionary;
#endif 	/* __IVariantDictionary_FWD_DEFINED__ */


#ifndef __ISessionObject_FWD_DEFINED__
#define __ISessionObject_FWD_DEFINED__
typedef interface ISessionObject ISessionObject;
#endif 	/* __ISessionObject_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __IApplicationObject_FWD_DEFINED__
#define __IApplicationObject_FWD_DEFINED__
typedef interface IApplicationObject IApplicationObject;
#endif 	/* __IApplicationObject_FWD_DEFINED__ */


#ifndef __Application_FWD_DEFINED__
#define __Application_FWD_DEFINED__

#ifdef __cplusplus
typedef class Application Application;
#else
typedef struct Application Application;
#endif /* __cplusplus */

#endif 	/* __Application_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __IScriptingContext_FWD_DEFINED__
#define __IScriptingContext_FWD_DEFINED__
typedef interface IScriptingContext IScriptingContext;
#endif 	/* __IScriptingContext_FWD_DEFINED__ */


#ifndef __ScriptingContext_FWD_DEFINED__
#define __ScriptingContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScriptingContext ScriptingContext;
#else
typedef struct ScriptingContext ScriptingContext;
#endif /* __cplusplus */

#endif 	/* __ScriptingContext_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 



DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0,0xA85C,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IStringList,0xD97A6DA0,0xA85D,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8")
    IStringList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStringList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in][optional] */ VARIANT i,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0,0xA85F,0x11df,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85F-11df-83AE-00A0C90C2BD8")
    IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequestDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IRequestDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IRequestDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Count_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IRequestDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Key_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IRequestDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IRequest,0xD97A6DA0,0xA861,0x11cf,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A861-11cf-93AE-00A0C90C2BD8")
    IRequest : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBytes( 
            /* [retval][out] */ long __RPC_FAR *pcbTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryRead( 
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalBytes )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcbTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryRead )( 
            IRequest __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#define IRequest_get_TotalBytes(This,pcbTotal)	\
    (This)->lpVtbl -> get_TotalBytes(This,pcbTotal)

#define IRequest_BinaryRead(This,pvarCountToRead,pvarReturn)	\
    (This)->lpVtbl -> BinaryRead(This,pvarCountToRead,pvarReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_TotalBytes_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcbTotal);


void __RPC_STUB IRequest_get_TotalBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequest_BinaryRead_Proxy( 
    IRequest __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);


void __RPC_STUB IRequest_BinaryRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Request,0x920c25d0,0x25d9,0x11d0,0xa5,0x5f,0x00,0xa0,0xc9,0x0c,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("920c25d0-25d9-11d0-a55f-00a0c90c2091")
Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IReadCookie,0x71EAF260,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EAF260-0CE0-11D0-A53E-00A0C90C2091")
    IReadCookie : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReadCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0,0xA862,0x11cf,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A862-11cf-84AE-00A0C90C2BD8")
    IWriteCookie : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrDomain);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWriteCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWriteCookie_put_Item(This,key,bstrValue)	\
    (This)->lpVtbl -> put_Item(This,key,bstrValue)

#define IWriteCookie_put_Expires(This,dtExpires)	\
    (This)->lpVtbl -> put_Expires(This,dtExpires)

#define IWriteCookie_put_Domain(This,bstrDomain)	\
    (This)->lpVtbl -> put_Domain(This,bstrDomain)

#define IWriteCookie_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IWriteCookie_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT key,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrDomain);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IResponse,0xD97A6DA0,0xA864,0x11cf,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A864-11cf-83BE-00A0C90C2BD8")
    IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Buffer( 
            /* [in] */ VARIANT_BOOL fIsBuffering) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContentType( 
            /* [in] */ BSTR bstrContentType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ long lExpiresMinutes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpiresAbsolute( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ BSTR bstrStatus) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryWrite( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsClientConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CharSet( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CharSet( 
            /* [in] */ BSTR bstrCharSet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pics( 
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CacheControl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CacheControl( 
            /* [in] */ BSTR bstrCacheControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIsBuffering);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrContentType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ long lExpiresMinutes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrStatus);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClientConnected )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCharSet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pics )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCacheControl);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,bstrContentType)	\
    (This)->lpVtbl -> put_ContentType(This,bstrContentType)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,lExpiresMinutes)	\
    (This)->lpVtbl -> put_Expires(This,lExpiresMinutes)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,dtExpires)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,dtExpires)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,bstrStatus)	\
    (This)->lpVtbl -> put_Status(This,bstrStatus)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,varInput)	\
    (This)->lpVtbl -> BinaryWrite(This,varInput)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#define IResponse_IsClientConnected(This,pfIsClientConnected)	\
    (This)->lpVtbl -> IsClientConnected(This,pfIsClientConnected)

#define IResponse_get_CharSet(This,pbstrCharSetRet)	\
    (This)->lpVtbl -> get_CharSet(This,pbstrCharSetRet)

#define IResponse_put_CharSet(This,bstrCharSet)	\
    (This)->lpVtbl -> put_CharSet(This,bstrCharSet)

#define IResponse_Pics(This,bstrHeaderValue)	\
    (This)->lpVtbl -> Pics(This,bstrHeaderValue)

#define IResponse_get_CacheControl(This,pbstrCacheControl)	\
    (This)->lpVtbl -> get_CacheControl(This,pbstrCacheControl)

#define IResponse_put_CacheControl(This,bstrCacheControl)	\
    (This)->lpVtbl -> put_CacheControl(This,bstrCacheControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrContentType);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ long lExpiresMinutes);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrStatus);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_IsClientConnected_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);


void __RPC_STUB IResponse_IsClientConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);


void __RPC_STUB IResponse_get_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCharSet);


void __RPC_STUB IResponse_put_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Pics_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_Pics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);


void __RPC_STUB IResponse_get_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCacheControl);


void __RPC_STUB IResponse_put_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Response,0x46E19BA0,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("46E19BA0-25DD-11D0-A55F-00A0C90C2091")
Response;
#endif

#ifndef __IVariantDictionary_INTERFACE_DEFINED__
#define __IVariantDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVariantDictionary
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IVariantDictionary,0x4a7deb90,0xb069,0x11d0,0xb3,0x73,0x00,0xa0,0xc9,0x0c,0x2b,0xd8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7deb90-b069-11d0-b373-00a0c90c2bd8")
    IVariantDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariantDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IVariantDictionaryVtbl;

    interface IVariantDictionary
    {
        CONST_VTBL struct IVariantDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariantDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariantDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariantDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariantDictionary_get_Item(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Item(This,VarKey,pvar)

#define IVariantDictionary_put_Item(This,VarKey,var)	\
    (This)->lpVtbl -> put_Item(This,VarKey,var)

#define IVariantDictionary_putref_Item(This,VarKey,var)	\
    (This)->lpVtbl -> putref_Item(This,VarKey,var)

#define IVariantDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#define IVariantDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IVariantDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_put_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_putref_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Key_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Count_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IVariantDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get__NewEnum_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IVariantDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantDictionary_INTERFACE_DEFINED__ */


#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][oleautomation][dual][uuid] */ 



DEFINE_GUID(IID_ISessionObject,0xD97A6DA0,0xA865,0x11cf,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A865-11cf-83AF-00A0C90C2BD8")
    ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Timeout( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodePage( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CodePage( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LCID( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LCID( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISessionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define ISessionObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,lvar)	\
    (This)->lpVtbl -> put_Timeout(This,lvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#define ISessionObject_get_CodePage(This,plvar)	\
    (This)->lpVtbl -> get_CodePage(This,plvar)

#define ISessionObject_put_CodePage(This,lvar)	\
    (This)->lpVtbl -> put_CodePage(This,lvar)

#define ISessionObject_get_LCID(This,plvar)	\
    (This)->lpVtbl -> get_LCID(This,plvar)

#define ISessionObject_put_LCID(This,lvar)	\
    (This)->lpVtbl -> put_LCID(This,lvar)

#define ISessionObject_get_StaticObjects(This,ppTaggedObjects)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppTaggedObjects)

#define ISessionObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_StaticObjects_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);


void __RPC_STUB ISessionObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Contents_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ISessionObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Session,0x509F8F20,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("509F8F20-25DE-11D0-A55F-00A0C90C2091")
Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0,0xA866,0x11cf,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A866-11cf-83AE-10A0C90C2BD8")
    IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnLock( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IApplicationObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define IApplicationObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#define IApplicationObject_get_StaticObjects(This,ppProperties)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppProperties)

#define IApplicationObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_StaticObjects_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Contents_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Application,0x7C3BAF00,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("7C3BAF00-25DE-11D0-A55F-00A0C90C2091")
Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IServer,0xD97A6DA0,0xA867,0x11cf,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A867-11cf-83AE-01A0C90C2BD8")
    IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ScriptTimeout( 
            /* [in] */ long lTimeoutSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLPathEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long lTimeoutSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLPathEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,lTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,lTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#define IServer_URLPathEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLPathEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long lTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLPathEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLPathEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Server,0xA506D160,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("A506D160-25E0-11D0-A55F-00A0C90C2091")
Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Tue Jul 15 12:18:35 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A868-11cf-83AE-00B0C90C2BD8")
    IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptingContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus

class DECLSPEC_UUID("D97A6DA0-A868-11cf-83AE-11B0C90C2BD8")
ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\core.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    core.cpp

Abstract:

    This module contains the core functionality of doing an isquery. It
	derives CIndexServerQuery ( by Alex Wetmore ).

	It will be derived by CQueryToMail and CQueryToNews, which implements
	different reply modes.
	
Author:

    Kangrong Yan  ( t-kyan )     28-June-1997

Revision History:

--*/

//
// System includes
//
#include "stdafx.h"
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <dbgtrace.h>

//
// User includes
//
#include "core.h"

//
// Number of query results to fetch every time
//
#define		RESULTS	7

//
// Number of columns to query for
//
#define		COLUMNS		4

//
// Starting size for repeat message format
//
#define		START_SIZE	4096

//
// Expansion rate of buffer size for repeat message format
//
#define		EXPAND_RATE	4

//
// Limit size for that buffer block
//
#define		LIMIT_SIZE	1024*1024

// 
// Constructor and destructor for CSafeString
//
CSafeString::CSafeString( DWORD	dwInitBufSize )
{
	TraceFunctEnter("CSafeString::CSafeString");
	
	_ASSERT( dwInitBufSize >= 0 );

	m_cBuffer = dwInitBufSize;

	m_szBuffer = new CHAR[m_cBuffer];
	if ( !m_szBuffer ) 
		FatalTrace(0, "Out of memory.");

	//
	// set it to empty
	//
	m_szBuffer[0] = '\0';

	TraceFunctLeave();
}

CSafeString::~CSafeString()
{
	TraceFunctEnter("CSafeString::~CSafeString");

	if ( m_szBuffer )
		delete[] m_szBuffer;
	
	TraceFunctLeave();
}

BOOL
CSafeString::Append( LPSTR szToAppend )
/*++

Routine Description : 

	Append a string to the CSafeString object

Arguemnts : 

	IN LPWSTR wszToAppend	-	String to append
	
Return Value : 
	
	TRUE if successful, FALSE otherwise

--*/
{
	TraceFunctEnter("CSafeString::Append");
	_ASSERT( m_szBuffer );
	_ASSERT( szToAppend );

	if ( m_cBuffer >= strlen( m_szBuffer ) + strlen( szToAppend ) + 1 ) {
		// if there is enough space
		strcat( m_szBuffer, szToAppend );
	} else { // should reallocate memory
		//
		// calculate the new buffer size needed, it should be the 
		// greater of twice original size and actually needed size
		//
		m_cBuffer = max(	strlen(m_szBuffer) + strlen(szToAppend) + 1,
							m_cBuffer*2 );

		//
		// allocate new space
		//
		LPSTR szTempBuf = new CHAR[m_cBuffer];
		if ( !szTempBuf ) {
			FatalTrace(0, "Out of memory");
			return FALSE;
		}

		//
		//  fill them into new space
		//
		strcpy( szTempBuf, m_szBuffer );
		strcat( szTempBuf, szToAppend );

		//
		//  arrange pointers
		//
		delete[] m_szBuffer;
		m_szBuffer = szTempBuf;
	}

	TraceFunctLeave();

	return TRUE;
}

DWORD
CSafeString::Length()
/*++

Routine Description : 

	Get the current length of string.

Arguemnts : 

	None.
	
Return Value : 
	
	The length.
--*/
{
	TraceFunctEnter("CSafeString::Length");
	_ASSERT( m_szBuffer );

	TraceFunctLeave();
	return strlen( m_szBuffer );
}


LPSTR
CSafeString::ToString()
/*++

Routine Description : 

	Convert the SafeString object to LPWSTR.

Arguemnts : 

	None.
	
Return Value : 
	
	The pointer to string, on success; NULL otherwise
--*/
{
	TraceFunctEnter("CSafeString::ToString");
	_ASSERT( m_szBuffer );

	TraceFunctLeave();
	return m_szBuffer;
}

void
CSafeString::Clear()
/*++

Routine Description : 

	Sets the safe string to empty.

Arguemnts : 

	None.
	
Return Value : 
	
	None.
--*/
{
	m_szBuffer[0] = '\0';
}

//
// Constructor and destructor for CCore
//
CCore::CCore()
{
	TraceFunctEnter("CCore::CCore");
	
	m_psafBody = new CSafeString( _MAX_PATH );
	
	if ( !m_psafBody ) 
		FatalTrace(0, "out of memory");
	m_psafBody->Clear();

	m_psafBodyHdr = new CSafeString( _MAX_PATH );

	if ( !m_psafBodyHdr )
		FatalTrace(0, "out of memory");
	m_psafBodyHdr->Clear();

	m_psafLastDate = new CSafeString( _MAX_PATH );
	
	if ( !m_psafLastDate )
		FatalTrace(0, "out of memory");
	m_psafLastDate->Clear();

	m_psafMsgHdr = new CSafeString( _MAX_PATH );

	if ( !m_psafMsgHdr )
		FatalTrace(0, "out of memory");
	m_psafMsgHdr->Clear();

	TraceFunctLeave();
}

void
CCore::Uni2Char(
			LPSTR	lpszDest,
			LPWSTR	lpwszSrc )	{
/*++

Routine Description:

	Convert a unicode string into char string. Destination
	string should be preallocated and length of _MAX_PATH 
	should be prepared.

Arguments:

	lpszDest - Destination char string
	lpwszSrc - Source wide char string

Return Value:

	None
--*/
	WideCharToMultiByte( CP_ACP,
						  0,
						  lpwszSrc,
						  -1,
						  lpszDest,
						  MAX_PROP_LEN,
						  NULL,
						  NULL );
}

void
CCore::Char2Uni(
			LPWSTR	lpwszDest,
			LPSTR	lpszSrc )	{
/*++

Routine Description:

	Convert a char string into unicode string. Destination
	string should be preallocated and length of _MAX_PATH 
	should be prepared.

Arguments:

	lpwszDest - Destination wide char string
	lpszSrc - Source char string

Return Value:

	None
--*/
	MultiByteToWideChar ( CP_ACP,
						   0,
						   lpszSrc,
						   -1,
						   lpwszDest,
						   MAX_PROP_LEN );
	
}

CCore::~CCore()
{
	TraceFunctEnter("CCore::~CCore");

	if ( m_psafBody )
		delete m_psafBody;

	if ( m_psafBodyHdr )
		delete m_psafBodyHdr;

	if ( m_psafLastDate )
		delete m_psafLastDate;

	if ( m_psafMsgHdr )
		delete m_psafMsgHdr;

	TraceFunctLeave();
}

void
CCore::Filter(	LPSTR szToFilter,
				CHAR charToFind,
				CHAR charReplace )
/*++

Routine Description : 

	Filter away "<" and ">" and replace them with "(" and ")" in some
	strings because they hamper html display.

Arguemnts : 

	IN LPSTR szToFilter - String to be filtered.
	
Return Value : 
	
	None
--*/
{
	TraceFunctEnter("CCore::Filter");

	_ASSERT( szToFilter );

	LPSTR	lpstrPtr = szToFilter;

	while ( lpstrPtr = strchr( lpstrPtr, charToFind ) ) 
		*(lpstrPtr++) = charReplace;

	TraceFunctLeave();
}

BOOL
CCore::PrepareQueryString( CSafeString &safQueryString )
/*++

Routine Description : 

	Append the time stamp, etc. to the query string

Arguemnts : 

	OUT CSafeString safQueryString - String to fill in the result query.
	
Return Value : 
	
	None
--*/
{
	TraceFunctEnter("CCore::PrepareQueryString");
	_ASSERT( safQueryString.ToString() );
	CHAR	szBuffer[MAX_PROP_LEN];

	//
	// first append the query string
	//
	_ASSERT( VT_BSTR == VALUE( m_ptblTable[QUERY_STRING_NAME] ).vt );
	Uni2Char( szBuffer, VALUE( m_ptblTable[QUERY_STRING_NAME] ).bstrVal );
	if ( ! safQueryString.Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	//
	// then append time
	//
	if ( '\0' == *safQueryString.ToString() ) { // no need for "and"
		if ( !safQueryString.Append(" @Newsdate > ") ) {
			TraceFunctLeave();
			return FALSE;
		}
	}
	else {										// need "and"
		if ( ! safQueryString.Append(" and @Newsdate > ") ) {
			TraceFunctLeave();
			return FALSE;
		}
	}

	_ASSERT( VT_BSTR == VALUE( m_ptblTable[LAST_SEARCH_DATE] ).vt );
	Uni2Char( szBuffer, VALUE( m_ptblTable[LAST_SEARCH_DATE] ).bstrVal);
	if ( ! safQueryString.Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	//
	//  append vpath
	//
	if ( ! safQueryString.Append(" and #vpath *.nws") ) {
		TraceFunctLeave();
		return FALSE;
	}

	TraceFunctLeave();

	return TRUE;
}

BOOL
CCore::PrepareURL(	CSafeString &safURL,
					BSTR		wszMsgID )
/*++

Routine Description : 

	Prepare the news message URL to be appended.

Arguemnts : 

	OUT CSafeString safURL - String to fill in the URL.
	IN	BSTR	wszMsgID   - News message ID	
	
Return Value : 
	
	None
--*/
{
	TraceFunctEnter("CCore::PrepareURL");
	_ASSERT( safURL.ToString() );
	_ASSERT( wszMsgID );

	CHAR	szBuffer[MAX_PROP_LEN];

	if ( ! safURL.Append("news://") ) {
		TraceFunctLeave();
		return FALSE;
	}

	_ASSERT( VT_BSTR == VALUE( m_ptblTable[QUERY_SERVER] ).vt );
	Uni2Char( szBuffer, VALUE( m_ptblTable[QUERY_SERVER] ).bstrVal);

	if ( !safURL.Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	if ( ! safURL.Append("/") ) {
		TraceFunctLeave();
		return FALSE;
	}

	//
	// append msg ID
	//
	Uni2Char( szBuffer, wszMsgID );
	if ( ! safURL.Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	TraceFunctLeave();

	return TRUE;
}

LPVOID
CCore::OpenTemplate(	BOOL fIsBigTemplate )
/*++

Routine Description : 

	
Arguemnts : 

	IN BOOL fIsBigTemplate - If to open the whole message body template
	(BigTemplate: whole msg, otherwise: Msg URL slice)
Return Value : 
	
	 The memory address where the opened template is, NULL on fail.
--*/
{
	TraceFunctEnter("CCore::OpenTemplate");
	HANDLE	hFile;
	DWORD	dwSize = 0;
	PVOID	pvMem;
	BOOL	fSuccess;
	DWORD	cBytes;
	
	//
	// Try to get it from file
	//

	// get property name
	PPropertyEntry pPropEntry = NULL;
	if ( fIsBigTemplate )
		pPropEntry = m_ptblTable[MESSAGE_TEMPLATE_TEXT];
	else 
		pPropEntry = m_ptblTable[URL_TEMPLATE_TEXT];
	_ASSERT( pPropEntry );
	
	// only if property doesn't exist should we use file
	if ( L'\0' == VALUE( pPropEntry ).bstrVal[0] ||
		VT_BSTR != VALUE( pPropEntry ).vt ) {

		//
		// get file name
		//
		if ( fIsBigTemplate ) {
			pPropEntry = m_ptblTable[MESSAGE_TEMPLATE_FILE];
			_ASSERT(	L'\0' != VALUE( pPropEntry ).bstrVal &&
					VT_BSTR == VALUE( pPropEntry ).vt );
		}
		else {
			pPropEntry = m_ptblTable[URL_TEMPLATE_FILE];
			_ASSERT(	L'\0' != VALUE( pPropEntry ).bstrVal &&
						VT_BSTR == VALUE( pPropEntry ).vt );
		}

		// Open the file
		hFile = CreateFileW(	VALUE(pPropEntry).bstrVal,
								GENERIC_READ,
								FILE_SHARE_READ,
								NULL,			//no inherit security
								OPEN_EXISTING,	
								FILE_ATTRIBUTE_NORMAL,
								NULL	);
		if ( SUCCEEDED( hFile ) ) {		// only when the file exists

			//get file size and alloc memory
			dwSize = GetFileSize(	hFile,
									NULL );
			_ASSERT( dwSize > 0 );
			pvMem = VirtualAlloc(	NULL, 
									(dwSize+1)*sizeof(CHAR),
									MEM_RESERVE | MEM_COMMIT,
									PAGE_READWRITE );
			if ( !pvMem ) {
				ErrorTrace(0, "Out of memory");
				TraceFunctLeave();
				return NULL;
			}

			((LPSTR)pvMem)[0] = '\0';

			// read in the file
			fSuccess = ReadFile(	hFile,
									(LPSTR)pvMem,
									dwSize*sizeof(CHAR),
									&cBytes,
									NULL	);
			if ( !fSuccess ) {
				FatalTrace(0, "Read file fail");
				if ( !VirtualFree(	pvMem,
									0 ,
									MEM_RELEASE) ) 
					ErrorTrace(0, "Virtual Free fail: %x", GetLastError());
				

				TraceFunctLeave();
				return NULL;
			}

			// close the file
			CloseHandle( hFile );

			// message template isn't allowed to be empty string
			if ( ((LPSTR)pvMem)[0] == '\0' ) {
				VirtualFree(	pvMem,
								0,
								MEM_RELEASE );
				TraceFunctLeave();
				return NULL;
			}
			
			TraceFunctLeave();
			return pvMem;
		} else  { // read file fail
			TraceFunctLeave();
			return NULL;
		}
	}

	//
	// else using the property string
	//
	pvMem = VirtualAlloc(	NULL, 
							sizeof(CHAR)*(wcslen(VALUE(pPropEntry).bstrVal)+1),
							MEM_RESERVE | MEM_COMMIT,
							PAGE_READWRITE );
	
	
	if ( !pvMem ) {
		ErrorTrace(0, "Out of memory");
		TraceFunctLeave();
		return NULL;
	}


	((LPSTR)pvMem)[0] = '\0';

	//
	// Convert wide char to destination ( ansi)
	//
	Uni2Char( (LPSTR)pvMem, VALUE( pPropEntry).bstrVal);

	//
	// Message template is not allowed to be empty
	//
	if ( ((LPSTR)pvMem)[0] == '\0' ) {
		VirtualFree(	pvMem,
						0,
						MEM_RELEASE );
	
		TraceFunctLeave();
		return NULL;
	}
	
	TraceFunctLeave();
	return pvMem;
}

BOOL
CCore::AppendMsgSlice(	PVOID	pvTemplate,
						LPSTR	szURL,
						LPWSTR	wszSubject,
						LPWSTR	wszNewsGroup,
						LPWSTR	wszFrom,
						DWORD	cIndex )
/*++

Routine Description : 

	Append one msg slice to the m_psafBody, according to the 
	given template.

Arguemnts : 

	IN PVOID pvTemplate	    - Template buffer address
	IN LPWSTR wszURL		- News URL
	IN LPWSTR wszSubject	- News subject
	IN LPWSTR wszNewsGroup  - News group
	IN LPWSTR wszFrom		- News from line.
	IN DWORD  cIndex		- The index of a particular news url
	
Return Value : 
	
	 TRUE if successful, FALSE otherwise
--*/
{
	TraceFunctEnter("CCore::AppendMsgSlice");
	_ASSERT( pvTemplate );
	_ASSERT( wszSubject );
	_ASSERT( wszFrom );
	_ASSERT( wszNewsGroup );
	_ASSERT( szURL );

	DWORD	cResults;
	LPVOID	lpOut;
	CHAR	*ppInserts[4];
	CHAR	szBuffer[4][_MAX_PATH];
	BOOL	fStatus = TRUE;

	
	//
	// Create insert array
	//
	_itoa( cIndex, szBuffer[0], 10 );
	ppInserts[0] = szBuffer[0];
	ppInserts[1] = szURL;
	Uni2Char( szBuffer[1] , wszSubject);
	ppInserts[2] = szBuffer[1];
	Uni2Char( szBuffer[2] , wszFrom);
	ppInserts[3] = szBuffer[2];
	Uni2Char( szBuffer[3] , wszNewsGroup);
	ppInserts[4] = szBuffer[3];

	//
	// filter from line, becaue it contains "<" and ">"
	//
	Filter(	szBuffer[2],
			'<',
			'(' );
	Filter( szBuffer[2],
			'>',
			')'	);

	//
	// get the formated msg url slice
	//
	cResults = FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
								FORMAT_MESSAGE_FROM_STRING	|
								FORMAT_MESSAGE_ARGUMENT_ARRAY,
								(LPSTR)pvTemplate,
								0,
								0,
								(LPSTR)(&lpOut),
								_MAX_PATH,
								(va_list *)ppInserts	);
	if ( cResults <= 0 ) {
		ErrorTrace(	0, 
					"Format message fail:%d",
					GetLastError() );
		TraceFunctLeave();
		return FALSE;
	}

	//
	// append that slice to the m_psafBody
	//
	if ( ! m_psafBody->Append( (LPSTR)lpOut ) ) 
		fStatus = FALSE;
		
	if ( LocalFree( lpOut ) ) {
		ErrorTrace(0, "LocalFree fail: %d", GetLastError());
		fStatus = FALSE;
	}

	TraceFunctLeave();

	return fStatus;
}

BOOL
CCore::PrepareMsgBody()
/*++

Routine Description : 

	Function to do query, collect msg IDs and prepare the main body
	of reply message.  The message prepared is stored in the safe 
	string m_safBody.

Arguemnts : 

	None.
	
Return Value : 
	
	 TRUE if successful, FALSE otherwise
--*/
{
	TraceFunctEnter("CCore::PrepareMsgBody");
	_ASSERT( m_psafBody->ToString() );

	CSafeString		safQueryString( _MAX_PATH );
	CSafeString		safURL( _MAX_PATH );
	HRESULT			hr;
	BOOL			fMore;
	DWORD			cResults;
	PROPVARIANT		*rgpvResults[RESULTS*COLUMNS];
	WCHAR			wszColumn[_MAX_PATH+1];
	PVOID			pvTemplate;
	WCHAR			wszQueryString[MAX_PROP_LEN+1];
	DWORD			cIndex = 0;

	//
	// Prepare Query String
	//
	if ( ! PrepareQueryString( safQueryString ) ) {
		ErrorTrace(0, "Prepare Querystring fail");
		TraceFunctLeave();
		return FALSE;
	}

	Char2Uni( wszQueryString, safQueryString.ToString());

	//
	// Make query
	//
	wcscpy( wszColumn, L"newsgroup,newsmsgid,newsfrom,newssubject");
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[QUERY_SERVER]).vt );
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[QUERY_CATALOG]).vt );

	hr = MakeQuery(	TRUE,
					wszQueryString,
					VALUE(m_ptblTable[QUERY_SERVER]).bstrVal,
					VALUE(m_ptblTable[QUERY_CATALOG]).bstrVal,
					NULL,
					wszColumn,
					wszColumn	);
	if ( FAILED( hr ) ) {
		//
		// if error is caused by index server not running
		//
		if ( E_FAIL == hr ) {
			ErrorTrace(0, "Make query fail: %x", hr);
			TraceFunctLeave();
			return FALSE;
		} else { // the query string has problem
			//
			//we should warn the user of this, anyway
			//
			m_psafBody->Append("You have bad query, might be deleted.");

			//
			// and should mark it bad query
			//
			if ( VALUE( m_ptblTable[IS_BAD_QUERY] ).bstrVal )
				SysFreeString( VALUE( m_ptblTable[IS_BAD_QUERY]).bstrVal);
			VariantInit( & VALUE( m_ptblTable[IS_BAD_QUERY] ) );
			VALUE( m_ptblTable[IS_BAD_QUERY] ).bstrVal = SysAllocString(L"1");
			DIRTY( m_ptblTable[IS_BAD_QUERY] ) = TRUE;

			//
			// and not to continue
			//
			TraceFunctLeave();
			return TRUE;	
		}
	}

	//
	// Open msg url template 
	//
	pvTemplate = OpenTemplate( FALSE ); // open "small" template
	if ( !pvTemplate ) {
		ErrorTrace(0, "Can't open template file");
		TraceFunctLeave();
		return FALSE;
	}

	//
	// Get results
	//
	do {
		cResults = RESULTS;
		hr = GetQueryResults(	&cResults,
								rgpvResults,
								&fMore	);
		if ( FAILED( hr ) ) {
			ErrorTrace(0, "Getting results fail: %x", hr);
			TraceFunctLeave();
			return FALSE;
		}

		//
		// append results to msg body
		//
		for ( UINT i = 0; i < cResults ; i++) {
			PROPVARIANT	**ppvRow = rgpvResults + (i * COLUMNS);

			//
			// must check if the results getting back are invalid,
			// shouldn't process it
			//
			if ( ppvRow[0]->vt != VT_LPWSTR	||
				 ppvRow[1]->vt != VT_LPWSTR	||
				 ppvRow[2]->vt != VT_LPWSTR	||
				 ppvRow[3]->vt != VT_LPWSTR	)
				 continue;

			// Prepare URL
			safURL.Clear();			// should remember to set it empty
			if ( ! PrepareURL(	safURL,
								ppvRow[1]->pwszVal ) ) {
				ErrorTrace(0, "Prapare URL fail");
				TraceFunctLeave();
				return FALSE;
			}
			
			// generate one message slice
			if ( ! AppendMsgSlice(	pvTemplate,			// template buffer
									safURL.ToString(),  // URL
									ppvRow[3]->pwszVal, // subject
									ppvRow[0]->pwszVal, // newsgroup
									ppvRow[2]->pwszVal, // from
									++cIndex ) ){
				ErrorTrace(0, "Generate one msg slice fail");
				TraceFunctLeave();
				return FALSE;
			}
		}
	} while ( fMore );

	DebugTrace(0, "Index becomes %d", cIndex);

	//
	// deallocate the virtual memory allocated in "OpenTemplate"
	//
	if ( !VirtualFree(	pvTemplate,
						0,
						MEM_RELEASE	) ) {
		ErrorTrace(0, "Virtual free fail: %x", GetLastError());
		TraceFunctLeave();
		return FALSE;
	}

	TraceFunctLeave();

	return TRUE;
}

BOOL
CCore::PrepareEditURL()
/*++

Routine Description : 

	Prepare the message part that tells the user editing URL.

Arguemnts : 

	None.
	
Return Value : 
	
	TRUE on success, FALSE otherwise
--*/
{
	TraceFunctEnter("CCore::PrepareEditURL");
	_ASSERT( m_psafBodyHdr->ToString() );

	CHAR	szBuffer[MAX_PROP_LEN];

	_ASSERT( VT_BSTR == VALUE(m_ptblTable[EDIT_URL]).vt );
	Uni2Char( szBuffer, VALUE( m_ptblTable[EDIT_URL]).bstrVal); 

	if ( ! m_psafBodyHdr->Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	if ( ! m_psafBodyHdr->Append("?") ) {
		TraceFunctLeave();
		return FALSE;
	}

	_ASSERT( VT_BSTR == VALUE(m_ptblTable[QUERY_ID]).vt );
	Uni2Char( szBuffer, VALUE(m_ptblTable[QUERY_ID]).bstrVal);

	if ( ! m_psafBodyHdr->Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}
	
	TraceFunctLeave();

	return TRUE;
}

void
CCore::RefreshTime()
/*++

Routine Description : 

	Refresh the time stamp property after the search.

Arguemnts : 

	None.
	
Return Value : 
	
	None
--*/
{
	TraceFunctEnter("CCore::RefreshTime");

	SYSTEMTIME		stCurrentTime;
	WCHAR			wszBuffer[_MAX_PATH];
	PPropertyEntry	pTemp;
		
	//
	// Get system time
	//
	GetSystemTime( &stCurrentTime );

	//
	// form a time string
	//
	stCurrentTime.wYear %= 100;		// year should only have two digits
	swprintf(	wszBuffer, 
				L"%d/%d/%d %d:%d:%d",
				stCurrentTime.wYear,
				stCurrentTime.wMonth,
				stCurrentTime.wDay,
				stCurrentTime.wHour,
				stCurrentTime.wMinute,
				stCurrentTime.wSecond	);

	//
	//	set it to the property
	//
	pTemp = m_ptblTable[LAST_SEARCH_DATE];
	if ( VALUE( pTemp ).bstrVal )
		SysFreeString( VALUE( pTemp ).bstrVal );
	VariantInit( &VALUE( pTemp ) );
	VALUE( pTemp ).bstrVal = SysAllocString(wszBuffer);
	VALUE( pTemp ).vt = VT_BSTR;
	DIRTY( pTemp ) = TRUE;				// mark it dirty

	TraceFunctLeave();
}

BOOL
CCore::PrepareCore()
/*++

Routine Description : 

	Exposed to the deriving classes, basically does:
	1. Prepare the edit URL -> m_psafBodyHdr;
	2. Prepare the Msg Body -> m_psafBody;
	3. Refresh the time property;

Arguemnts : 

	None.
	
Return Value : 
	
	TRUE on success, FALSE otherwise
--*/	
{
	TraceFunctEnter("CCore::PrepareCore");
	CHAR	szBuffer[MAX_PROP_LEN];

	//
	// Prepare edit url
	//
	if ( ! PrepareEditURL() ) {
		ErrorTrace(0, "Prepare Edit URL fail");
		TraceFunctLeave();
		return FALSE;
	}

	//
	// Prepare Msg Body
	//
	if ( !PrepareMsgBody() ) {
		FatalTrace(0, "Prepare message body fail");
		TraceFunctLeave();
		return FALSE;
	}

	//
	// Refresh time, store last search date before refresh
	//
	Uni2Char( szBuffer, VALUE( m_ptblTable[LAST_SEARCH_DATE] ).bstrVal);

	if ( ! m_psafLastDate->Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	RefreshTime();

	TraceFunctLeave();
	return TRUE;
}

/*
BOOL 
CCore::RepeatFormatMessage(	PVOID	pvTemplate,
							LPVOID  *lpOut,
							va_list *ppInserts	)*/
/*++

Routine Description : 

	Repeat formating a message using my allocated buffer, until
	success.

Arguemnts : 

	IN PVOID pvTemplate - The template format string;
	OUT LPVOID *lpOut	- The out string address
	IN va_list *ppInserts - The array of strings to be inserted.
	
Return Value : 
	
	TRUE on success, FALSE otherwise
--*/	/*
{
	TraceFunctEnter("CCore::RepeatFormatMessage");
	_ASSERT( pvTemplate );
	_ASSERT( lpOut );
	_ASSERT( ppInserts );

	DWORD	dwBufferSize = START_SIZE;
	DWORD	dwBytesDone;

	// should free the buffer first, if it's not freed yet
	if ( *lpOut ) 
		LocalFree( *lpOut );

	while ( TRUE ) {
		//
		// Allocate memory of that big
		//
		*lpOut = VirtualAlloc(	NULL, 
								dwBufferSize*sizeof(CHAR),
								MEM_RESERVE | MEM_COMMIT,
								PAGE_READWRITE );
		if ( !*lpOut ) {
			ErrorTrace(0, "Out of memory");
			TraceFunctLeave();
			return FALSE;
		}

		//
		// Format a message
		//
		dwBytesDone = FormatMessage(	FORMAT_MESSAGE_FROM_STRING	|
										FORMAT_MESSAGE_ARGUMENT_ARRAY,
										pvTemplate,
										0,
										0,
										(LPSTR)(*lpOut),
										dwBufferSize,
										ppInserts	);
		if ( GetLastError() != ERROR_MORE_DATA )
			break;

		dwBufferSize *= EXPAND_RATE;

		if ( LIMIT_SIZE == dwBufferSize )
			break;

		VirtualFree(	*lpOut,
						0,
						MEM_RELEASE	);
	}

	TraceFunctLeave();

	if ( dwBufferSize > 0 )
		return TRUE;
	else 
		return FALSE;
}*/

BOOL
CCore::DropMessage(	HANDLE hFile )
/*++

Routine Description : 

	Put a message into the given file

Arguemnts : 

	IN HANDLE hFile - The file handle
Return Value : 
	
	TRUE on success, FALSE otherwise
--*/	
{
	TraceFunctEnter("CCore::DropMessage");

	LPSTR		lpstrTemplate;
	LPSTR		lpstrEnd;
	LPSTR		lpstrStart;
	BOOL		fHasBody;
	CHAR		*ppInserts[4];
	LPVOID		lpOut;
	DWORD		cResults;
	BOOL		fSuccess;
	DWORD		cBytes;
	BOOL		fStatus;

	_ASSERT( m_psafMsgHdr->ToString());
	_ASSERT( m_psafBodyHdr->ToString());
	_ASSERT( m_psafLastDate->ToString());
	_ASSERT( m_psafBody->ToString());

	//
	// Prepare insert string
	//
	ppInserts[0] = m_psafMsgHdr->ToString();
	ppInserts[1] = m_psafBodyHdr->ToString();
	ppInserts[2] = m_psafLastDate->ToString();
	ppInserts[3] = m_psafBody->ToString();

	//
	// Open big template
	//
	lpstrTemplate = (LPSTR)OpenTemplate( TRUE );	// BIG
	if ( !lpstrTemplate ) {
		FatalTrace(0, "Open template fail");
		TraceFunctLeave();
		return FALSE;
	}

	//
	// Find the part before the main body in template
	//
	lpstrEnd = strstr(	lpstrTemplate,
						"%4"	);
	if ( NULL == lpstrEnd ) // "%4" is not in template
		fHasBody = FALSE;
	else
		fHasBody = TRUE;

	if ( fHasBody ) 
		*lpstrEnd = '\0';

	//
	// put the first part into file
	//
	cResults = FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
								FORMAT_MESSAGE_FROM_STRING	|
								FORMAT_MESSAGE_ARGUMENT_ARRAY,
								lpstrTemplate,
								0,
								0,
								(LPSTR)(&lpOut),
								_MAX_PATH,
								(va_list *)ppInserts	);
	if ( cResults <= 0 ) {
		ErrorTrace(0, "Format message fail: %d", GetLastError());
		fStatus = FALSE;
		goto EXIT;
	}

	fSuccess = WriteFile(	hFile,
							(LPSTR)lpOut,
							lstrlen((LPSTR)lpOut),
							&cBytes,
							NULL	);
	if ( !fSuccess ) {
		FatalTrace(0, "Write Msg header fail");
		fStatus = FALSE;
		if ( LocalFree( lpOut ) )
			ErrorTrace(0, "LocalFree fail: %d", GetLastError());
		goto EXIT;
	}
	
	if ( LocalFree( lpOut ) ) {
		ErrorTrace(0, "Local free fail: %d", GetLastError());
		fStatus = FALSE;
		goto EXIT;
	}


	if ( fHasBody ) {

		*lpstrEnd = '%';

		// 
		// put the main body into file
		//
		fSuccess = WriteFile(	hFile,
								m_psafBody->ToString(),
								m_psafBody->Length(),
								&cBytes,
								NULL	);
		if ( !fSuccess ) {
			FatalTrace(0, "Write Msg header fail");
			fStatus = FALSE;
			goto EXIT;
		}

		//
		// put the last part into file
		//
		lpstrStart = lpstrEnd + 2; // pointing to last part of template

	
		cResults = FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
									FORMAT_MESSAGE_FROM_STRING	|
									FORMAT_MESSAGE_ARGUMENT_ARRAY,
									lpstrStart,
									0,
									0,
									(LPSTR)(&lpOut),
									_MAX_PATH,
									(va_list *)ppInserts	);

		if ( cResults <= 0 ) {
			ErrorTrace(0, "Format message fail: %d", GetLastError());
			fStatus = FALSE;
			goto EXIT;
		}

		fSuccess = WriteFile(	hFile,
								(LPSTR)lpOut,
								lstrlen((LPSTR)lpOut),
								&cBytes,
								NULL	);
		if ( !fSuccess ) {
			FatalTrace(0, "Write Msg header fail");
			fStatus = FALSE;
			if ( LocalFree( lpOut ) )
				ErrorTrace(0, "LocalFree fail: %d", GetLastError());
			goto EXIT;
		}
	
		if ( LocalFree( lpOut ) ) {
			ErrorTrace(0,"LocalFree fail: %d", GetLastError());
			fStatus = FALSE;
			goto EXIT;
		}
	}

	fStatus = TRUE;

EXIT:

	if ( !VirtualFree(	lpstrTemplate,
						0,
						MEM_RELEASE	) ) {
		ErrorTrace( 0, "Virtual free fail: %x", GetLastError());
		TraceFunctLeave();
		return FALSE;
	}

	TraceFunctLeave();

	return fStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\name.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    name.h

Abstract:

    This module contains the property name table class.  Properties 
	of query object and querybase object are all collected in the 
	name table, which facilitates the property loading and saving
	by name, value pairs.  The table also has other information like
	dirty bits for each property.

	This module is used by both the query object module and the query
	base module.


Author:

    Kangrong Yan  ( t-kyan )     27-June-1997

Revision History:

--*/
#ifndef _NAME_H_
#define _NAME_H_


// System includes
#include <stdlib.h>
#include <atlbase.h>

//
// Total number of properties
//
#define PROPERTY_TOTAL		20

//
// Max property buffer length
//
#define MAX_PROP_LEN		1024

//
// Property IDs
//
#define	QUERY_STRING		0
#define	EMAIL_ADDRESS		1
#define	NEWS_GROUP			2
#define	LAST_SEARCH_DATE	3
#define	QUERY_ID			4
#define	REPLY_MODE			5
#define	FROM_LINE			6
#define	SUBJECT_LINE		7
#define	EDIT_URL			8
#define	MAIL_PICKUP_DIR		9
#define QUERY_SERVER		10
#define	QUERY_CATALOG		11
#define MESSAGE_TEMPLATE_TEXT	12	
#define URL_TEMPLATE_TEXT		13
#define MESSAGE_TEMPLATE_FILE	14	
#define URL_TEMPLATE_FILE		15
#define SEARCH_FREQUENCY		16
#define IS_BAD_QUERY			17
#define NEWS_SERVER				18
#define NEWS_PICKUP_DIR			19

//
// Property Names
//
#define QUERY_STRING_NAME		L"query_string"
#define	EMAIL_ADDRESS_NAME		L"email_address"
#define	NEWS_GROUP_NAME			L"news_group"
#define	LAST_SEARCH_DATE_NAME	L"last_search"
#define	QUERY_ID_NAME			L"query_id"
#define	REPLY_MODE_NAME			L"reply_mode"
#define	FROM_LINE_NAME			L"from_line"
#define	SUBJECT_LINE_NAME		L"subject_line"
#define EDIT_URL_NAME			L"edit_url"
#define MAIL_PICKUP_DIR_NAME	L"mail_pickup_dir"
#define QUERY_SERVER_NAME		L"query_server"
#define	QUERY_CATALOG_NAME		L"query_catalog"
#define MESSAGE_TEMPLATE_TEXT_NAME	L"message_template_text"
#define MESSAGE_TEMPLATE_FILE_NAME	L"message_template_file"
#define URL_TEMPLATE_TEXT_NAME		L"url_template_text"
#define URL_TEMPLATE_FILE_NAME		L"url_template_file"
#define SEARCH_FREQUENCY_NAME		L"search_frequency"
#define IS_BAD_QUERY_NAME			L"is_bad"	
#define NEWS_SERVER_NAME			L"news_server"
#define NEWS_PICKUP_DIR_NAME		L"news_pickup_dir"

//
// Macros that ease the access to PropertyEntry's fields
//
#define	NAME( X )	( ( X )->wszName )
#define ID( X )		( ( X )->dwPropID )
#define VALUE( X )	( ( X )->varVal )
#define	DIRTY( X )  ( ( X )->fDirty )

typedef struct {
	LPWSTR		wszName;				//Property's name
	DWORD		dwPropID;				//Each property has a constant value
	VARIANT		varVal;					//Actual value of the property
	BOOL		fDirty;					//Dirty bit of each property
} PropertyEntry, *PPropertyEntry;

extern PropertyEntry	g_QueryPropertyTable[];
HRESULT VerifyProperty( LPWSTR wszPropName, LPWSTR wszPropVal);
 
class CPropertyTable {		//ptbl
private:
	//
	// Pointer to the property array
	//
	PropertyEntry m_pPropertyTable[PROPERTY_TOTAL];

public:

	//
	// Counter of total properties in the table
	//
	DWORD m_cProperties;

	//
	// Constructor, destructor
	//
	CPropertyTable();
	~CPropertyTable();

	//
	// Some access operator overloads
	//
	PPropertyEntry operator[]( const LPWSTR	wszName );
	PPropertyEntry operator[]( DWORD dwPropID );

};
	
#endif // _NAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\news.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    news.cpp

Abstract:

    This module adds in the news reply features to the query object.  It
	derives CCore, which fulfills basic functionality of query, adds the 
	preceding text and following text, and finally	places the messge into 
	the news server's pickup directory.

	It will be used by CQuery, which supports some COM dual interface and 
	wrapps all these query functionality.
	
Author:

    Kangrong Yan  ( t-kyan )     29-June-1997

Revision History:

--*/

//
// System includes
//
#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <dbgtrace.h>

//
// User includes
//
#include "news.h"
#include "svrapi.h"

//
// Constructor, destructor
//
CNews::CNews()
{
	TraceFunctEnter("CNews::CNews");

	TraceFunctLeave();
}

CNews::~CNews()
{
	TraceFunctEnter("CNews::~CNews");

	TraceFunctLeave();
}

BOOL
CNews::PrepareNewsHdr()
/*++

Routine Description : 

	Prepare the reply news message header.

Arguemnts : 

	None.

Return Value : 
	
	None
--*/
{
	TraceFunctEnter("CNews::PrepareNewsHdr");
	_ASSERT( m_psafMsgHdr->ToString() );

	//
	// Mail reply might have written something to it, now
	// I want to start from scratch
	//
	m_psafMsgHdr->Clear();

	CHAR	szBuffer[MAX_PROP_LEN];

	//
	// Append from line
	//
	if ( ! m_psafMsgHdr->Append( "From: " ) ) {
		ErrorTrace(0, "Append From fail");
		TraceFunctLeave();
		return FALSE;
	}
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[FROM_LINE]).vt );
	Uni2Char( szBuffer, VALUE(m_ptblTable[FROM_LINE]).bstrVal);

	if ( ! m_psafMsgHdr->Append( szBuffer ) ) {
		ErrorTrace(0, "Append from fail");
		TraceFunctLeave();
		return FALSE;
	}
	
	//
	// Append subject line
	//
	if ( ! m_psafMsgHdr->Append( "\r\nSubject: " ) ) {
		ErrorTrace(0, "Append Subject fail");
		TraceFunctLeave();
		return FALSE;
	}
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[SUBJECT_LINE]).vt );
	Uni2Char( szBuffer, VALUE(m_ptblTable[SUBJECT_LINE]).bstrVal);

	if ( ! m_psafMsgHdr->Append( szBuffer ) ) {
		ErrorTrace(0, "Append subject fail");
		TraceFunctLeave();
		return FALSE;
	}

	//
	// should make sure the news group really exists
	//
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[NEWS_SERVER]).vt );
	CSvrApi		saSvrApi( VALUE(m_ptblTable[NEWS_SERVER]).bstrVal );

	_ASSERT( VT_BSTR == VALUE(m_ptblTable[NEWS_GROUP]).vt );
	if ( !saSvrApi.CreateNewsGroup( VALUE(m_ptblTable[NEWS_GROUP]).bstrVal ) ) {
		// news group existing is not fail, already
		// tested in CreateNewsGroup
			DebugTraceX(0, "Newsgroup: %ws", VALUE(m_ptblTable[NEWS_GROUP]).bstrVal );
			ErrorTrace(0, "Create news group fail");
			TraceFunctLeave();
			return FALSE;
	}

	//
	// Append the news group line
	//
	if ( !m_psafMsgHdr->Append( "\r\nNewsgroups: ") ) {
		TraceFunctLeave();
		return FALSE;
	}


	Uni2Char( szBuffer, VALUE(m_ptblTable[NEWS_GROUP]).bstrVal);
	
	if ( ! m_psafMsgHdr->Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	_ASSERT( m_psafMsgHdr->ToString());

	TraceFunctLeave();

	return TRUE;
}

BOOL
CNews::Send()
/*++

Routine Description : 

	Put the whole message into news server's pickup directory.

Arguemnts : 

	None.

Return Value : 
	
	TRUE if successful, FALSE otherwise.
--*/
{
	TraceFunctEnter("CNews::Send");

	WCHAR	wszFileName[_MAX_PATH];
	HANDLE	hFile;
	BOOL	fSuccess;
	DWORD	cBytes;
	
	//
	// Prepare file name
	//
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[NEWS_PICKUP_DIR]).vt );
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[QUERY_ID]).vt );
	swprintf(	wszFileName,
				L"%s\\%s.btc",
				VALUE(m_ptblTable[NEWS_PICKUP_DIR]).bstrVal,
				VALUE(m_ptblTable[QUERY_ID]).bstrVal	);

	//
	// Create file
	//
	hFile = CreateFileW(	wszFileName,
							GENERIC_WRITE,
							0,				//exclusive access
							NULL,			//no inherit security
							CREATE_ALWAYS,	//overwrite if exists
							FILE_ATTRIBUTE_NORMAL,
							NULL	);
	if ( FAILED( hFile ) ) {
		FatalTrace(0, "Unable to create file: %x", hFile);
		TraceFunctLeave();
		return FALSE;
	}

	// 
	// drop the message
	//
	if ( ! DropMessage( hFile ) ) {
		FatalTrace(0, "Drop messsage fail");
		CloseHandle( hFile );
		
		
		TraceFunctLeave();
		return FALSE;
	}

	//
	// Append newline-dot ( for news protocol )
	//
	fSuccess = WriteFile(	hFile,
							"\r\n\r\n.\r\n",
							7,
							&cBytes,
							NULL	);
	if ( !fSuccess ) {
		ErrorTrace(0, "Write file fail: %d", GetLastError() );
		CloseHandle( hFile );

		TraceFunctLeave();
		return FALSE;
	}
	
	
	CloseHandle( hFile );
	
	TraceFunctLeave();
	return TRUE;
}

BOOL
CNews::DoQuery( BOOL fNeedPrepareCore )
/*++

Routine Description : 

	Organize all the query stuff.

Arguemnts : 

	IN BOOL fNeedPrepareCore - Whether need to prepare core.

Return Value : 
	
	TRUE if success, FALSE otherwise;
--*/
{
	TraceFunctEnter("CNews::DoQuery");

	if ( ! PrepareNewsHdr() ) {
		FatalTrace(0, "Prepare news header fail");
		TraceFunctLeave();
		return FALSE;
	}

	if ( fNeedPrepareCore ) {
		if ( !PrepareCore() ) {
			FatalTrace(0, "Unable to prepare core");
			TraceFunctLeave();
			return FALSE;
		}
	}

	if ( '\0' != (m_psafBody->ToString())[0] ) {
		if ( !Send() ) {
			FatalTrace(0, "Send fail");
			TraceFunctLeave();
			return FALSE;
		}
	}
	TraceFunctLeave();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\mail.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mail.h

Abstract:

    This module adds in the mail reply features to the query object.  It
	derives CCore, which fulfills basic functionality of query, adds mail
	message header, adds the preceding text and following text, and finally
	places the messge into the mail server's pickup directory.

	It will be used by CQuery, which supports some COM dual interface and 
	wrapps all these query functionality.
	
Author:

    Kangrong Yan  ( t-kyan )     29-June-1997

Revision History:

--*/
#ifndef _MAIL_H_
#define _MAIL_H_

//
// System includes
//

//
// User includes
//
#include "core.h"

class CMail : virtual public CCore {	//ma

	//
	//  Prepare the mail header
	//
	BOOL PrepareMailHdr();

	//
	//	Write to pickup directory
	//
	BOOL Send();

protected:
	//
	// do all the stuff
	//
	BOOL DoQuery();
	
public:
	//
	// Constructor, destructor
	//
	CMail();
	~CMail();

};

#endif	//_MAIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\name.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    name.cpp

Abstract:

    This module contains the property name table class.  Properties 
	of query object and querybase object are all collected in the 
	name table, which facilitates the property loading and saving
	by name, value pairs.  The table also has other information like
	dirty bits for each property.

	This module is used by both the query object module and the query
	base module.


Author:

    Kangrong Yan  ( t-kyan )     27-June-1997

Revision History:

--*/

// System includes
#include "stdafx.h"
#include <windows.h>
#include <dbgtrace.h>
#include <memory.h>
#include <string.h>


// User includes
#include "name.h"

//
// Global property table, it's operation is wrapped in CPropertyTable.
// It's made global to make initialization easier.  However, only 
// CPropertyTable will have access to this table.
//
//  It's terminated with empty string.
//
PropertyEntry g_MailPropertyTable[] =
{
	{QUERY_STRING_NAME,		QUERY_STRING,		0,	FALSE},
	{EMAIL_ADDRESS_NAME,	EMAIL_ADDRESS,		0,	FALSE},
	{NEWS_GROUP_NAME,		NEWS_GROUP,			0,	FALSE},
	{LAST_SEARCH_DATE_NAME,	LAST_SEARCH_DATE,	0,	FALSE},
	{QUERY_ID_NAME,			QUERY_ID,			0,	FALSE},
	{REPLY_MODE_NAME,		REPLY_MODE,			0,	FALSE},
	{FROM_LINE_NAME,		FROM_LINE,			0,	FALSE},
	{SUBJECT_LINE_NAME,		SUBJECT_LINE,		0,	FALSE},
	{EDIT_URL_NAME,			EDIT_URL,			0,	FALSE},
	{MAIL_PICKUP_DIR_NAME,	MAIL_PICKUP_DIR,	0,	FALSE},
	{QUERY_SERVER_NAME,		QUERY_SERVER,		0,	FALSE},
	{QUERY_CATALOG_NAME,	QUERY_CATALOG,		0,	FALSE},
	{MESSAGE_TEMPLATE_TEXT_NAME, MESSAGE_TEMPLATE_TEXT, 0, FALSE},
	{URL_TEMPLATE_TEXT_NAME, URL_TEMPLATE_TEXT, 0, FALSE},
	{MESSAGE_TEMPLATE_FILE_NAME, MESSAGE_TEMPLATE_FILE, 0, FALSE},
	{URL_TEMPLATE_FILE_NAME, URL_TEMPLATE_FILE, 0, FALSE},
	{SEARCH_FREQUENCY_NAME, SEARCH_FREQUENCY,   0, FALSE},
	{IS_BAD_QUERY_NAME,		IS_BAD_QUERY,	    0, FALSE},
	{NEWS_SERVER_NAME,		NEWS_SERVER,		0, FALSE},
	{NEWS_PICKUP_DIR_NAME,  NEWS_PICKUP_DIR,	0, FALSE}
};


//
// Constructor, destructor
//
CPropertyTable::CPropertyTable()
{

	TraceFunctEnter("CPropertyTable::CPropertyTable");
	
	m_cProperties = PROPERTY_TOTAL;
	//m_pPropertyTable = g_MailPropertyTable;
	memcpy(		m_pPropertyTable, 
				g_MailPropertyTable, 
				sizeof( PropertyEntry ) * PROPERTY_TOTAL );

	for ( UINT i = 0; i < m_cProperties; i++) {
		VariantInit( &(m_pPropertyTable[i].varVal) );
		m_pPropertyTable[i].fDirty = FALSE;
	}

	TraceFunctLeave();
}

CPropertyTable::~CPropertyTable()
{
	TraceFunctEnter("CPropertyTable::~CPropertyTable");
	DebugTrace(0, "1");
	_ASSERT( m_pPropertyTable );		// becaues only I am freeing it
	DebugTrace(0,"2");
	_ASSERT( m_cProperties >= 0 );
	DebugTrace(0,"3");

	//
	// Make sure all string values are freed first
	// we should have worried about more other pointer types,
	// but since in this application, properties are only going 
	// to be BSTR or DWORDs.  So I am only worried about BSTR
	//
	for ( UINT i = 0; i < m_cProperties; i++) {
		if ( VT_BSTR == m_pPropertyTable[i].varVal.vt		// is BSTR
			&&	m_pPropertyTable[i].varVal.bstrVal ) {			// is not null
			 DebugTraceX(0, "%d:%ws", i, m_pPropertyTable[i].varVal.bstrVal);
			 SysFreeString( m_pPropertyTable[i].varVal.bstrVal );
			 DebugTrace(0, "Freed");
		}
	}
	

	TraceFunctLeave();
}

PPropertyEntry 
CPropertyTable::operator[]( const LPWSTR wszName )
/*++

Routine Description : 

	Help access the property entry with name as index.

Arguemnts : 

	IN LPWSTR wszName	-	Name of the property
	
Return Value : 
	Pointer to the property entry, on success;
	Null, if fail.

--*/
{
	TraceFunctEnter("CPropertyTable::operator[]");
	_ASSERT( wszName );

	for ( UINT i = 0; i < m_cProperties; i++)
		if ( wcscmp( wszName, m_pPropertyTable[i].wszName ) == 0 ) {
			TraceFunctLeave();
			return ( m_pPropertyTable + i );
		}

	TraceFunctLeave();
	return NULL;
}
	

PPropertyEntry 
CPropertyTable::operator[]( DWORD dwPropID )
/*++

Routine Description : 

	Help access the property entry with property ID as index.

Arguemnts : 

	IN DWORD dwPropID	-	ID of the property
	
Return Value : 
	Pointer to the property entry, on success;
	Null, if fail.

--*/
{
	TraceFunctEnter("CPropertyTable::operator[]");
	_ASSERT( dwPropID >= 0 && dwPropID < PROPERTY_TOTAL );

	TraceFunctLeave();
	return ( m_pPropertyTable + dwPropID );
}

BOOL	
IsNumber( PWCHAR wszString )
/*++

Routine Description : 

	Whether the string is a number

Arguemnts : 

	IN PWCHAR wszString - the string to be tested
	
Return Value : 
	
	 TRUE if it's a number, FALSE otherwise.
--*/

{
	PWCHAR	pwchPtr = wszString;

	while ( *pwchPtr ) 
		if ( !isdigit( *(pwchPtr++) ) )
			return FALSE;

	return TRUE;
}


HRESULT
VerifyProperty(	LPWSTR	wszPropName,
				LPWSTR	wszPropVal )
/*++

Routine Description : 

	Verify the validation of each property.

Arguemnts : 

	IN LPWSTR wszPropName	-	Property name
	IN LPWSTR wszPropVal	-	Property value
	
Return Value : 
	
	ERORR CODE;
--*/
{
	TraceFunctEnter("VerifyProperty");
	_ASSERT( wszPropName );
	_ASSERT( wszPropVal );

	HRESULT		hr;

	if ( lstrlenW( wszPropVal ) >= MAX_PROP_LEN ) {
		hr = TYPE_E_BUFFERTOOSMALL;
		goto done;
	}

	if ( wcscmp( wszPropName, QUERY_STRING_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, EMAIL_ADDRESS_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, NEWS_GROUP_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, LAST_SEARCH_DATE_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, QUERY_ID_NAME ) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, FROM_LINE_NAME ) == 0 ) {
		// empty is invalid
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, SUBJECT_LINE_NAME ) == 0) {
		// empty would be invalid, because it might also be used
		// for news message
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else
			hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, EDIT_URL_NAME ) == 0 ) {
		// empty is invalid
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else hr = S_OK;
	} else if ( wcscmp( wszPropName, MAIL_PICKUP_DIR_NAME ) == 0 ) {
		// need to verify the writability of that directory
		WIN32_FIND_DATAW	wfdFind;
		HANDLE				hFile;
		
		hFile = FindFirstFileW(		wszPropVal,
									&wfdFind	);
		
		if ( INVALID_HANDLE_VALUE == hFile ) {
			hr = E_INVALIDARG;
			goto done;
		}

		FindClose( hFile );

		if ((FILE_ATTRIBUTE_DIRECTORY & wfdFind.dwFileAttributes) == 0 ||
			FILE_ATTRIBUTE_READONLY & wfdFind.dwFileAttributes ) {
			hr = E_INVALIDARG;
			goto done;
		}

		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, QUERY_SERVER_NAME ) == 0 ) {
		// empty is invalid
		if ( wcscmp( wszPropVal, L"") == 0 ) 
			hr = E_INVALIDARG;
		else hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, QUERY_CATALOG_NAME ) == 0 ) {
		// empty is invalid
		if ( wcscmp( wszPropVal, L"") == 0 )
			hr = E_INVALIDARG;
		else hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, MESSAGE_TEMPLATE_TEXT_NAME) == 0 ) {
		// not verified
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, MESSAGE_TEMPLATE_FILE_NAME) == 0 ) {
		// should verify its readability and existance
		WIN32_FIND_DATAW	wfdFind;
		HANDLE				hFile;

		if ( wcscmp( wszPropVal, L"") == 0 ) {
			hr = E_INVALIDARG;
			goto done;
		}
		
		hFile = FindFirstFileW(		wszPropVal,
									&wfdFind	);
		
		if ( INVALID_HANDLE_VALUE == hFile ) {
			hr = E_INVALIDARG;
			goto done;
		}

		FindClose( hFile );

		if (FILE_ATTRIBUTE_DIRECTORY & wfdFind.dwFileAttributes ) {
			hr = E_INVALIDARG;
			goto done;
		}

		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, URL_TEMPLATE_TEXT_NAME) == 0 ) {
		// verify nothing
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, URL_TEMPLATE_FILE_NAME) == 0 ) {
		// should verify its existance and readability
		WIN32_FIND_DATAW	wfdFind;
		HANDLE				hFile;

		if ( wcscmp( wszPropVal, L"") == 0 ) {
			hr = E_INVALIDARG;
			goto done;
		}
		
		hFile = FindFirstFileW(		wszPropVal,
									&wfdFind	);
		
		if ( INVALID_HANDLE_VALUE == hFile ) {
			hr = E_INVALIDARG;
			goto done;
		}

		FindClose( hFile );

		if (FILE_ATTRIBUTE_DIRECTORY & wfdFind.dwFileAttributes ) {
			hr = E_INVALIDARG;
			goto done;
		}

		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, SEARCH_FREQUENCY_NAME) == 0 ) {
		// should be a number
		if ( IsNumber( wszPropVal ) )
			hr = S_OK;
		else 
			hr = E_INVALIDARG;
		goto done;
	} else if ( wcscmp( wszPropName, IS_BAD_QUERY_NAME ) == 0 ) {
		// it's either "1" or "2"
		if (	wcscmp( wszPropVal, L"1" ) != 0 &&
				wcscmp( wszPropVal, L"0" ) != 0 ) 
			hr = E_INVALIDARG;
		else 
			hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, REPLY_MODE_NAME ) == 0 ) {
		// verify nothing
		hr = S_OK;
		goto done;
	} else if ( wcscmp( wszPropName, NEWS_SERVER_NAME) == 0 ) {
		// can't be empty
		if ( 	wcscmp( wszPropVal, L"" ) == 0 )
			hr = E_INVALIDARG;
		else
			hr = S_OK;
	} else if ( wcscmp( wszPropName, NEWS_PICKUP_DIR_NAME ) == 0 ) {
		// that should be a dir and writeable
		WIN32_FIND_DATAW	wfdFind;
		HANDLE				hFile;

		hFile = FindFirstFileW(	wszPropVal,
								&wfdFind );
		if ( INVALID_HANDLE_VALUE == hFile ) {
			hr = E_INVALIDARG;
			goto done;
		}

		FindClose( hFile );

		if ( (FILE_ATTRIBUTE_DIRECTORY & wfdFind.dwFileAttributes) == 0 ||
				FILE_ATTRIBUTE_READONLY & wfdFind.dwFileAttributes ) {
			hr = E_INVALIDARG;
			goto done;
		}

		hr = S_OK;
		goto done;
	}
	else { // property not found
		hr = DISP_E_UNKNOWNNAME;
		goto done;
	}

done:

	TraceFunctLeave();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\core.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    core.h

Abstract:

    This module contains the core functionality of doing an isquery. It
	derives CIndexServerQuery ( by Alex Wetmore ).

	It will be derived by CQueryToMail and CQueryToNews, which implements
	different reply modes.
	
Author:

    Kangrong Yan  ( t-kyan )     28-June-1997

Revision History:

--*/
#ifndef _CORE_H_
#define _CORE_H_

//
// System includes
//

#include "offquery.h"
#include <stdlib.h>

//
// user includes
//
#include "name.h"

//
// Class CSafeString is an auxiliary string operation class that
// supports dynamic expansion for string appending
//
class CSafeString {		//saf
	//
	// The buffer to contain the string
	//
	LPSTR	m_szBuffer;

	//
	// The buffer size
	//
	DWORD	m_cBuffer;

public:
	// Constructor, destructor
	CSafeString( DWORD dwInitBufSize );
	~CSafeString();

	//
	// append a string
	//
	BOOL Append( const LPSTR	szToAppend );

	//
	// return current length of the string
	//
	DWORD	Length();

	//
	// convert back to normal string
	//
	LPSTR ToString();

	
	//
	// clear the string, set it to empty string
	//
	void Clear();

	//
	// total bytes in the ansi string
	//
	DWORD AnsiLength();
};
	
class CCore : public CIndexServerQuery {	//cor

	//
	// Prepare query string, esp. append time stamp
	//
	BOOL PrepareQueryString( CSafeString &safQueryString );

	//
	// Prepare the URL after gettign query results
	//
	BOOL PrepareURL(	CSafeString &safURL,
						BSTR		wszMsgID );

	//
	// Method to prepare reply message body
	//
	BOOL PrepareMsgBody();

	//
	// Method to prepare the edit URL for the reply message
	//
	BOOL PrepareEditURL();

	//
	// Method to refresh time stamp - "last search " property
	//
	void RefreshTime();

	//
	// append one slice of msg url to accordign to the template format
	//
	BOOL AppendMsgSlice(	PVOID	pvTemplate,
							LPSTR	szURL,
							LPWSTR	wszSubject,
							LPWSTR	wszNewsGroup,
							LPWSTR	wszFrom	,
							DWORD	cIndex );

	//
	// filter away "<" and ">"
	//
	void Filter( LPSTR, CHAR, CHAR );

protected:
	//
	// Property table
	//
	CPropertyTable m_ptblTable;

	//
	// String of reply message body
	//
	CSafeString *m_psafBody;

	//
	// String that tells the edit URL
	//
	CSafeString *m_psafBodyHdr;

	//
	// String that contains last search date
	//
	CSafeString *m_psafLastDate;

	//
	// The message header
	//
	CSafeString *m_psafMsgHdr;

	//
	// convert unicode to char
	//
	void Uni2Char(LPSTR	lpszDest,LPWSTR	lpwszSrc );	

	//
	// convert char to uni
	//
	void Char2Uni(LPWSTR	lpwszDest,LPSTR	lpszSrc );

	//
	// main control method of class CCore
	//
	BOOL PrepareCore();

	//
	// Open a template block, from file or string property
	//
	LPVOID OpenTemplate(	BOOL fIsBigTemplate );

	//
	//  Put the message into a file
	//
	BOOL DropMessage(	HANDLE hFile );
						


	
public:
	//
	// Constructors, destructors
	//
	CCore();
	~CCore();
};

#endif	//_CORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\news.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    news.h

Abstract:

    This module adds in the news reply features to the query object.  It
	derives CCore, which fulfills basic functionality of query, adds the 
	preceding text and following text, and finally	places the messge into 
	the news server's pickup directory.

	It will be used by CQuery, which supports some COM dual interface and 
	wrapps all these query functionality.
	
Author:

    Kangrong Yan  ( t-kyan )     29-June-1997

Revision History:

--*/
#ifndef _NEWS_H_
#define _NEWS_H_

//
// System includes
//

//
// User includes
//
#include "core.h"

class CNews : virtual public CCore {	//ma

	//
	//  Prepare the news header
	//
	BOOL PrepareNewsHdr();

	//
	//	Write to pickup directory
	//
	BOOL Send();

protected:
	//
	// do all the stuff
	//
	BOOL DoQuery( BOOL fNeedPrepareCore );
	
public:
	//
	// Constructor, destructor
	//
	CNews();
	~CNews();

};

#endif	//_NEWS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\mail.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mail.cpp

Abstract:

    This module adds in the mail reply features to the query object.  It
	derives CCore, which fulfills basic functionality of query, adds mail
	message header, adds the preceding text and following text, and finally
	places the messge into the mail server's pickup directory.

	It will be used by CQuery, which supports some COM dual interface and 
	wrapps all these query functionality.
	
Author:

    Kangrong Yan  ( t-kyan )     29-June-1997

Revision History:

--*/
//
// System includes
//
#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <dbgtrace.h>

//
// User includes
//
#include "mail.h"

//
// Constructor, destructor
//
CMail::CMail()
{
	TraceFunctEnter("CMail::CMail");

	TraceFunctLeave();
}

CMail::~CMail()
{
	TraceFunctEnter("CMail::~CMail");

	TraceFunctLeave();
}

BOOL
CMail::PrepareMailHdr()
/*++

Routine Description : 

	Prepare the reply mail message header.

Arguemnts : 

	None.

Return Value : 
	
	None
--*/
{
	TraceFunctEnter("CMail::PrepareMailHdr");
	_ASSERT( m_psafMsgHdr->ToString() );

	CHAR	szBuffer[MAX_PROP_LEN];

	//
	// Append from line
	//
	if ( ! m_psafMsgHdr->Append( "From: " ) ) {
		TraceFunctLeave();
		return FALSE;
	}
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[FROM_LINE]).vt );
	Uni2Char( szBuffer, VALUE(m_ptblTable[FROM_LINE]).bstrVal);

	if ( ! m_psafMsgHdr->Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}
	
	//
	// Append to line
	//
	if ( ! m_psafMsgHdr->Append( "\r\nTo: " ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	_ASSERT( VT_BSTR == VALUE(m_ptblTable[EMAIL_ADDRESS]).vt );
	Uni2Char( szBuffer, VALUE(m_ptblTable[EMAIL_ADDRESS]).bstrVal);

	if ( !m_psafMsgHdr->Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	//
	// Append subject line
	//
	if ( ! m_psafMsgHdr->Append( "\r\nSubject: " ) ) {
		TraceFunctLeave();
		return FALSE;
	}
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[SUBJECT_LINE]).vt );
	Uni2Char( szBuffer, VALUE(m_ptblTable[SUBJECT_LINE]).bstrVal);

	if ( ! m_psafMsgHdr->Append( szBuffer ) ) {
		TraceFunctLeave();
		return FALSE;
	}

	_ASSERT( m_psafMsgHdr->ToString());

	TraceFunctLeave();

	return TRUE;
}

BOOL
CMail::Send()
/*++

Routine Description : 

	Put the whole message into mail server's pickup directory.

Arguemnts : 

	None.

Return Value : 
	
	TRUE if successful, FALSE otherwise.
--*/
{
	TraceFunctEnter("CMail::Send");

	WCHAR	wszFileName[_MAX_PATH];
	HANDLE	hFile;
	
	//
	// Prepare file name
	//
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[MAIL_PICKUP_DIR]).vt );
	_ASSERT( VT_BSTR == VALUE(m_ptblTable[QUERY_ID]).vt );
	swprintf(	wszFileName,
				L"%s\\%s.eml",
				VALUE(m_ptblTable[MAIL_PICKUP_DIR]).bstrVal,
				VALUE(m_ptblTable[QUERY_ID]).bstrVal	);

	//
	// Create file
	//
	hFile = CreateFileW(	wszFileName,
							GENERIC_WRITE,
							0,				//exclusive access
							NULL,			//no inherit security
							CREATE_ALWAYS,	//overwrite if exists
							FILE_ATTRIBUTE_NORMAL,
							NULL	);
	if ( FAILED( hFile ) ) {
		FatalTrace(0, "Unable to create file: %x", hFile);
		TraceFunctLeave();
		return FALSE;
	}

	// 
	// drop the message
	//
	if ( ! DropMessage( hFile ) ) {
		FatalTrace(0, "Drop messsage fail");
		CloseHandle( hFile );
		
		
		TraceFunctLeave();
		return FALSE;
	}

	
	CloseHandle( hFile );
	
	TraceFunctLeave();
	return TRUE;
}

BOOL
CMail::DoQuery()
/*++

Routine Description : 

	Organize all the query stuff.

Arguemnts : 

	None.

Return Value : 
	
	TRUE if success, FALSE otherwise;
--*/
{
	TraceFunctEnter("CMail::DoQuery");

	if ( ! PrepareMailHdr() ) {
		FatalTrace(0, "Prepare mail header fail");
		TraceFunctLeave();
		return FALSE;
	}

	if ( !PrepareCore() ) {
		FatalTrace(0, "Unable to prepare core");
		TraceFunctLeave();
		return FALSE;
	}

	if ( '\0' != (m_psafBody->ToString())[0] ) {
		if ( !Send() ) {
			FatalTrace(0, "Send fail");
			TraceFunctLeave();
			return FALSE;
		}
	}

	TraceFunctLeave();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\qry.cpp ===
// qry.cpp : Implementation of Cqry
#include "stdafx.h"
#include "search.h"
#include "qry.h"
#include "meta2.h"

#include <dbgtrace.h>
#include <stdio.h>


/////////////////////////////////////////////////////////////////////////////
// Cqry

STDMETHODIMP Cqry::OnStartPage (IUnknown* pUnk)  
{
	TraceFunctEnter("Cqry::OnStartPage");

	if(!pUnk) {
		TraceFunctLeave();
		return E_POINTER;
	}
	
	CComPtr<IScriptingContext> spContext;
	HRESULT hr;

	// Get the IScriptingContext Interface
	hr = pUnk->QueryInterface(IID_IScriptingContext, (void **)&spContext);
	if(FAILED(hr)) {
		TraceFunctLeave();
		return hr;
	}

	// Get Request Object Pointer
	hr = spContext->get_Request(&m_piRequest);
	if(FAILED(hr))
	{
		spContext.Release();
		TraceFunctLeave();
		return hr;
	}

	// Get Response Object Pointer
	hr = spContext->get_Response(&m_piResponse);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		TraceFunctLeave();
		return hr;
	}
	
	// Get Server Object Pointer
	hr = spContext->get_Server(&m_piServer);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		TraceFunctLeave();
		return hr;
	}
	
	// Get Session Object Pointer
	hr = spContext->get_Session(&m_piSession);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		TraceFunctLeave();
		return hr;
	}

	// Get Application Object Pointer
	hr = spContext->get_Application(&m_piApplication);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		m_piSession.Release();
		TraceFunctLeave();
		return hr;
	}
	m_bOnStartPageCalled = TRUE;
	
	TraceFunctLeave();
	return S_OK;
}

STDMETHODIMP Cqry::OnEndPage ()  
{
	TraceFunctEnter("Cqry::OnEndPage");
	m_bOnStartPageCalled = FALSE;
	// Release all interfaces
	m_piRequest.Release();
	m_piResponse.Release();
	m_piServer.Release();
	m_piSession.Release();
	m_piApplication.Release();
	TraceFunctLeave();

	return S_OK;
}


STDMETHODIMP Cqry::get_QueryString(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query string
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_QueryString");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[QUERY_STRING_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_QueryString(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN query string to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_QueryString");

	HRESULT		hr;

	hr = VerifyProperty( QUERY_STRING_NAME, newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Property verify fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[QUERY_STRING_NAME];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/ ) { // empty string is valid	
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_EmailAddress(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in email address.
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_EmailAddress");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[EMAIL_ADDRESS];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}



STDMETHODIMP Cqry::put_EmailAddress(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN email address to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_EmailAddress");

	HRESULT	hr;

	hr = VerifyProperty( EMAIL_ADDRESS_NAME, newVal);
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Property verify fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[EMAIL_ADDRESS];
	_ASSERT( pPropEntry );

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//

	if (	newVal /* not null*/	&&
			newVal[0] != L'\0' /* non empty*/	) {	// set it
		
		// free it first
		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_NewsGroup(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in news group
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_NewsGroup");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[NEWS_GROUP];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_NewsGroup(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN newsgroup to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_NewsGroup");

	HRESULT		hr;

	hr = VerifyProperty(	NEWS_GROUP_NAME, newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Verify property fail");
		TraceFunctLeave();
		return hr;
	}

	
	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[NEWS_GROUP];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/) {	// set it
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_ReplyMode(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in reply mode
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_ReplyMode");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[REPLY_MODE];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_ReplyMode(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN newsgroup to be set to reply mode
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_ReplyMode");

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[REPLY_MODE];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/) {	// set it
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::DoQuery()
/*++

Routine Description:

	Interface to issue a query.

Arguments:

	None.
	
Return Value:

	HRESULT error code
--*/

{
	InitAsyncTrace();
	TraceFunctEnter("Cqry::DoQuery");

	PPropertyEntry	pPropEntry;
	BOOL			fMailIsDone = FALSE;   // if done, no need to prepare core
											// for news

	//
	// check consistence of mail/news reply mode
	//
	if ( ! MailNewsConsistent() ) {
		ErrorTrace(0, "Reply mode inconsistent with property");

		// mark it bad
		if ( VALUE( m_ptblTable[IS_BAD_QUERY] ).bstrVal )
			SysFreeString( VALUE( m_ptblTable[IS_BAD_QUERY]).bstrVal);
		VariantInit( & VALUE( m_ptblTable[IS_BAD_QUERY] ) );
		VALUE( m_ptblTable[IS_BAD_QUERY] ).bstrVal = SysAllocString(L"1");
		DIRTY( m_ptblTable[IS_BAD_QUERY] ) = TRUE;

		TraceFunctLeave();
		return S_OK;		// still return OK, otherwise it's going 
							// to fail all operations
	}

	pPropEntry = m_ptblTable[REPLY_MODE];
	_ASSERT( pPropEntry );

	//
	// handle mail first
	//
	if ( wcscmp(	VALUE( pPropEntry ).bstrVal,
					L"both" ) == 0 ||
		 wcscmp(	VALUE( pPropEntry ).bstrVal,
					L"mail" ) == 0 ) {  
		// we are going to do mail query
		if ( !CMail::DoQuery() ) {
			ErrorTrace(0, "DoQuery fail for mail");
			TraceFunctLeave();
			TermAsyncTrace();
			return E_FAIL;
		}

		fMailIsDone = TRUE;
	}


	//
	// handle news second
	//
	if ( (wcscmp(	VALUE( pPropEntry ).bstrVal,
					L"both" ) == 0 ||
		 wcscmp(	VALUE( pPropEntry ).bstrVal,
					L"news" ) == 0) &&
		 wcscmp(	VALUE( m_ptblTable[NEWS_GROUP] ).bstrVal,
					L"" ) != 0 ) {
		// then do news 
		if ( !CNews::DoQuery( !fMailIsDone ) ) {
			ErrorTrace(0, "DoQuery fail for news");
			TraceFunctLeave();
			TermAsyncTrace();
			return E_FAIL;
		}
	}

	TraceFunctLeave();
	TermAsyncTrace();
	return S_OK;
}

STDMETHODIMP Cqry::Load(	BSTR wszGuid,
							IDispatch *dispReq,
							BOOL fNew)
/*++

Routine Description:

	Interface to ask the query object to load itself.

Arguments:

	IN BSTR wszGuid - The object's ID
	IN IDispatch *disReq - The querybase object's interface pointer
	IN BOOL fNew - is this a new object ?
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::Load");

	_ASSERT( wszGuid );

	PPropertyEntry	pPropEntry;
	BSTR			bstrTemp;
	HRESULT			hr;

	//
	// Set the guid property right away
	//
	pPropEntry = m_ptblTable[QUERY_ID];
	_ASSERT( pPropEntry );


	if ( VALUE( pPropEntry).bstrVal )
		SysFreeString( VALUE( pPropEntry ).bstrVal );

	VariantInit( &VALUE( pPropEntry ) );
	VALUE( pPropEntry ).vt = VT_BSTR;
	VALUE( pPropEntry ).bstrVal = SysAllocString( wszGuid );

	//
	// Set other properties
	//
	Ireq *piReq = (Ireq *)dispReq; 


	for( INT i = 0; i < PROPERTY_TOTAL; i++) {

		if ( QUERY_ID == i )
			continue;		// we have already done that

		pPropEntry = m_ptblTable[i];
		_ASSERT( pPropEntry );

		hr = piReq->Read(	NAME( pPropEntry ),
							&bstrTemp,
							wszGuid	);


		if ( FAILED( hr ) ) {
			ErrorTrace(0, "Read fail: %x", hr);
			TraceFunctLeave();
			return hr;
		}

		
		if ( VALUE( pPropEntry ).bstrVal )
			SysFreeString( VALUE( pPropEntry ).bstrVal );

		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( bstrTemp );


	}


	if ( fNew ) {
		DIRTY( m_ptblTable[QUERY_STRING_NAME] ) = TRUE;
		DIRTY( m_ptblTable[EMAIL_ADDRESS]) = TRUE;
	}

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::Save(	IDispatch * pdispReq, 
							BOOL fClearDirty, 
							BOOL fSaveAllProperties)
/*++

Routine Description:

	Interface to ask the query object to save itself.

Arguments:

	IN IDispatch * pdispReq	- The querybase object's interface pointer
	IN BOOL fClearDirty		- If should clear dirty bits after this save
	IN BOOL fSaveAllProperties - should I save all properties ?
	
Return Value:

	HRESULT error code
--*/

{
	TraceFunctEnter("Cqry::Save");
	_ASSERT( pdispReq );
	
	PPropertyEntry	pPropEntry;
	HRESULT			hr;
	Ireq			*piReq = (Ireq *)pdispReq;

	
	//
	// get my guid id
	//
	WCHAR	wszGuid[_MAX_PATH+1];
	wcscpy( wszGuid, VALUE( m_ptblTable[QUERY_ID] ).bstrVal );

	
	//
	// all querybase's write method
	//
	for ( INT i = 0; i < PROPERTY_TOTAL; i++) {

		// get property entry
		pPropEntry = m_ptblTable[i];
		_ASSERT( pPropEntry );

		// if not save all, may skip clean properties
		if (	!fSaveAllProperties &&
				!DIRTY( pPropEntry ) )
			continue;

/*		// empty string is only valid for query string,
		// format string
		if (	wcscmp(		VALUE( pPropEntry ).bstrVal,
							L"" ) == 0	&& 
				wcscmp(		NAME( pPropEntry ),
							MESSAGE_TEMPLATE_TEXT_NAME ) != 0 &&
				wcscmp(		NAME( pPropEntry ),
							URL_TEMPLATE_TEXT_NAME ) != 0 &&
				wcscmp(		NAME( pPropEntry ),
							QUERY_STRING_NAME ) != 0 )
			continue;*/

		
		hr = piReq->Write(	NAME( pPropEntry ),
							VALUE( pPropEntry ).bstrVal,
							wszGuid	);


		if ( FAILED ( hr ) ) {
			ErrorTrace(0, "Calling write fail: %x", hr);
			TraceFunctLeave();
			return hr;
		}

		if ( fClearDirty )
			DIRTY( pPropEntry ) = FALSE;
	}

	TraceFunctLeave();

	return S_OK;
}


STDMETHODIMP Cqry::get_Message_Template(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query string
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_Message_Template");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[MESSAGE_TEMPLATE_TEXT_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded
	DebugTrace(0, "%ws", VALUE( pPropEntry ).bstrVal);

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_Message_Template(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN query string to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_Message_Template");

	HRESULT		hr;
	hr = VerifyProperty(	MESSAGE_TEMPLATE_TEXT_NAME, 
							newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Verify property fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[MESSAGE_TEMPLATE_TEXT_NAME];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/ ) { // empty string is valid	
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_URL_Template(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query string
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_URL_Template");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[URL_TEMPLATE_TEXT_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded
	DebugTraceX(0, "%ws", VALUE( pPropEntry ).bstrVal );

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_URL_Template(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN query string to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_URL_Template");

	HRESULT		hr;
	hr = VerifyProperty(	URL_TEMPLATE_TEXT_NAME,
							newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Verify property fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[URL_TEMPLATE_TEXT_NAME];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/ ) { // empty string is valid	
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_LastDate(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query string
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_LastDate");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[LAST_SEARCH_DATE_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_LastDate(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN query string to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_LastDate");

	HRESULT		hr;
	hr = VerifyProperty(	LAST_SEARCH_DATE_NAME,
							newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Verify property fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[LAST_SEARCH_DATE_NAME];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/ ) { // empty string is valid	
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_Message_File(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query string
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_Message_File");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[MESSAGE_TEMPLATE_FILE_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_Message_File(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN query string to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_Message_File");

	HRESULT		hr;

	hr = VerifyProperty(	MESSAGE_TEMPLATE_FILE_NAME,
							newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Verify property fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[MESSAGE_TEMPLATE_FILE_NAME];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/ ) { // empty string is valid	
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_URLFile(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query string
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_URLFile");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[URL_TEMPLATE_FILE_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_URLFile(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN query string to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_URLFile");


	HRESULT		hr;
	hr = VerifyProperty(	URL_TEMPLATE_FILE_NAME,
							newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Verify property fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[URL_TEMPLATE_FILE_NAME];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/ ) { // empty string is valid	
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_SearchFrequency(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query string
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_SearchFrequency");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[SEARCH_FREQUENCY_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );
	
	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_SearchFrequency(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN query string to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_SearchFrequency");

	HRESULT		hr;
	hr = VerifyProperty(	SEARCH_FREQUENCY_NAME,
							newVal );
	if ( FAILED ( hr ) ) {
		ErrorTrace( 0, "Verify property fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[SEARCH_FREQUENCY_NAME];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/ ) { // empty string is valid	
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

STDMETHODIMP Cqry::get_QueryID(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query id
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_QueryID");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[QUERY_ID_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded
	DebugTrace(0, "%ws", VALUE( pPropEntry ).bstrVal);

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::get_IsBadQuery(BSTR * pVal)
/*++

Routine Description:

	Idispatch interface. 
	get method to simulate property's right value

Arguments:

	pVal - OUT address to fill in query string
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::get_IsBadQuery");

	//
	// get property entry
	//
	PPropertyEntry	pPropEntry = m_ptblTable[IS_BAD_QUERY_NAME];
	_ASSERT( VALUE( pPropEntry ).bstrVal ); // should have been loaded
	DebugTrace(0, "%ws", VALUE( pPropEntry ).bstrVal);

	//*pVal = VALUE( pPropEntry ).bstrVal;
	*pVal = SysAllocString( VALUE( pPropEntry ).bstrVal );

	TraceFunctLeave();
	
	return S_OK;
}

STDMETHODIMP Cqry::put_IsBadQuery(BSTR newVal)
/*++

Routine Description:

	Idispatch interface. 
	put method to simulate property's left value

Arguments:

	newVal - IN query string to be set to query object
	
Return Value:

	HRESULT error code
--*/
{
	TraceFunctEnter("Cqry::put_IsBadQuery");

	HRESULT		hr;
	hr = VerifyProperty(	IS_BAD_QUERY_NAME,
							newVal );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Verify property fail");
		TraceFunctLeave();
		return hr;
	}

	//
	// get property entry pointer
	//
	PPropertyEntry pPropEntry = m_ptblTable[IS_BAD_QUERY_NAME];

	_ASSERT( VALUE( pPropEntry ).bstrVal );  // should have been loaded

	//
	// set value
	//
	if (	newVal /* not null*/ ) { // empty string is valid	
		
		// free it first

		SysFreeString( VALUE( pPropEntry ).bstrVal );

		// set it
		VariantInit( &VALUE( pPropEntry ) );
		VALUE( pPropEntry ).vt = VT_BSTR;
		VALUE( pPropEntry ).bstrVal = SysAllocString( newVal );

		// mark it dirty
		DIRTY( pPropEntry ) = TRUE;
	}
	// else do nothing

	TraceFunctLeave();

	return S_OK;
}

BOOL
Cqry::MailNewsConsistent()
/*++

Routine Description:

	Before do query, to test if the mail/news properties are consistent:

	If mail reply is ordered, there must be email address;
	If news reply is ordered, there must be news group;
	Either email address or news group must exist;
	Reply mode must be "mail" or "news" or "both";

	These should already have been checked by front end asp files;
	If error is found here, query is not done.  The query is marked bad.

Arguments:

	None.
	
Return Value:

	TRUE if it's consistent, FALSE otherwise
--*/
{
	TraceFunctEnter("Cqry::MailNewsConsistent");

	PPropertyEntry	pPropEntry;

	//
	// reply mode must exist
	//
	pPropEntry = m_ptblTable[REPLY_MODE];
	_ASSERT( pPropEntry );
	if (	wcscmp(	VALUE( pPropEntry ).bstrVal,
					L"mail" ) != 0	&&
			wcscmp( VALUE( pPropEntry ).bstrVal,
					L"news" ) != 0  &&
			wcscmp(	VALUE( pPropEntry ).bstrVal,
					L"both" ) != 0 ) {
		goto bad;
	}

	//
	// if reply mode is "both" or "mail", email address 
	// must exist
	//
	if ( (	wcscmp( VALUE( pPropEntry ).bstrVal,
					L"mail" ) == 0	||
			wcscmp( VALUE( pPropEntry ).bstrVal,
					L"both" ) == 0 ) &&
			wcscmp(	VALUE( m_ptblTable[EMAIL_ADDRESS] ).bstrVal,
					L"" ) == 0 ) {
		goto bad;
	}

	//
	// if reply mode is "news" or "both", news group
	// must exist
	//
	if ( (	wcscmp( VALUE( pPropEntry ).bstrVal,
					L"news" ) == 0	||
			wcscmp( VALUE( pPropEntry ).bstrVal,
					L"both" ) == 0 ) &&
			wcscmp(	VALUE( m_ptblTable[NEWS_GROUP] ).bstrVal,
					L"" ) == 0 ) {
		goto bad;
	}

	TraceFunctLeave();
	return TRUE;

bad:

	TraceFunctLeave();
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\qry.h ===
// qry.h : Declaration of the Cqry

#ifndef __QRY_H_
#define __QRY_H_

#include "resource.h"       // main symbols
#include "asptlb5.h"         // Active Server Pages Definitions

#include "mail.h"
#include "news.h"

/////////////////////////////////////////////////////////////////////////////
// Cqry
class ATL_NO_VTABLE Cqry : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Cqry, &CLSID_qry>,
	public IDispatchImpl<Iqry, &IID_Iqry, &LIBID_SEARCHLib>,
	CMail,
	CNews
	
{
public:
	Cqry()
	{ 
		m_bOnStartPageCalled = FALSE;
	}
	
public:

DECLARE_REGISTRY_RESOURCEID(IDR_QRY)

BEGIN_COM_MAP(Cqry)
	COM_INTERFACE_ENTRY(Iqry)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Iqry
public:
	STDMETHOD(get_IsBadQuery)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_IsBadQuery)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_QueryID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SearchFrequency)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SearchFrequency)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_URLFile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_URLFile)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Message_File)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Message_File)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_LastDate)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_LastDate)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_URL_Template)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_URL_Template)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Message_Template)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Message_Template)(/*[in]*/ BSTR newVal);
	
	STDMETHOD(Save)(IDispatch *pdispReq, BOOL fClearDirty, BOOL fSaveAllProperties);
	STDMETHOD(Load)(BSTR wszGuid, IDispatch *pdispReq, BOOL fNew = FALSE);
	STDMETHOD(DoQuery)();
	STDMETHOD(get_ReplyMode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ReplyMode)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_NewsGroup)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_NewsGroup)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_EmailAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EmailAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_QueryString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_QueryString)(/*[in]*/ BSTR newVal);
	//Active Server Pages Methods
	STDMETHOD(OnStartPage)(IUnknown* IUnk);
	STDMETHOD(OnEndPage)();

private:
	BOOL MailNewsConsistent();					

	CComPtr<IRequest> m_piRequest;					//Request Object
	CComPtr<IResponse> m_piResponse;				//Response Object
	CComPtr<ISessionObject> m_piSession;			//Session Object
	CComPtr<IServer> m_piServer;					//Server Object
	CComPtr<IApplicationObject> m_piApplication;	//Application Object
	BOOL m_bOnStartPageCalled;						//OnStartPage successful?
};

#endif //__QRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by search.rc
//
#define IDS_PROJNAME                    100
#define IDR_QRY                         101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A5C8A9F7_F17A_11D0_91F3_00AA00C148BE__INCLUDED_)
#define AFX_STDAFX_H__A5C8A9F7_F17A_11D0_91F3_00AA00C148BE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A5C8A9F7_F17A_11D0_91F3_00AA00C148BE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\regop.h ===
// RegOp.h: interface for the CRegOp class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGOP_H__82EBD173_D778_11D0_91D8_00AA00C148BE__INCLUDED_)
#define AFX_REGOP_H__82EBD173_D778_11D0_91D8_00AA00C148BE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <wtypes.h>
#include <stdlib.h>

class CRegOp  {
// This class handles some basic registry operations
// currently it's implemented with only one value for
// each key at a time
private:

	// 
	// Root key that we are going to operate under
	//
	HKEY	hkRootKey;
	//
	// a string to be stored as key value
	//
	CHAR	lpszKeyValue[_MAX_PATH];

public:
	//
	// utility that converts unicode into one byte char *
	//
	BOOL	Uni2Char(
				LPSTR	lpszDest,
				LPWSTR	lpwszSrc );

	//
	// utility that converts one byte char into unicode
	//
	BOOL	Char2Uni(
				LPWSTR	lpwszDest,
				LPSTR	lpszSrc);

	CRegOp(HKEY);
	virtual ~CRegOp();

	//
	// Create a new key
	//
	BOOL	CreateNewKey(
				LPSTR	lpszNewKeyName,
				LPSTR	lpszPredefinedKeyName,
				PHKEY	phkResult);

	//
	// Retrieve a key value
	//
	BOOL	RetrieveKeyValue(
				LPSTR	lpszKeyName,
				LPSTR	lpszValueName,
				LPWSTR	lpwszVal);

	//
	// Set/Modify a key value
	// 
	BOOL	ModifyKeyValue(
				LPSTR	lpszKeyName,
				LPSTR	lpszValueName,
				LPWSTR  lpwszVal);
	
	//
	// Test if the specified key exists
	//
	BOOL	KeyExist(
				LPSTR	lpszKeyName );

	// 
	// Delete a key value
	//
	BOOL	DeleteKeyValue(
				LPSTR	lpszKeyName,
				LPSTR	lpszValueName );

	// 
	// Delete a key
	//
	BOOL	DeleteKey(
				LPSTR	lpszParentKeyName,
				LPSTR	lpszKeyName );

			
};

#endif // !defined(AFX_REGOP_H__82EBD173_D778_11D0_91D8_00AA00C148BE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\regop.cpp ===
// RegOp.cpp: implementation of the RegOp class.
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "RegOp.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CRegOp::CRegOp(HKEY key) : hkRootKey(key)
{

}

CRegOp::~CRegOp()
{

}

BOOL
CRegOp::Uni2Char(
			LPSTR	lpszDest,
			LPWSTR	lpwszSrc )	{
/*++

Routine Description:

	Convert a unicode string into char string. Destination
	string should be preallocated and length of _MAX_PATH 
	should be prepared.

Arguments:

	lpszDest - Destination char string
	lpwszSrc - Source wide char string

Return Value:

	True if success, false otherwise
--*/
	INT Result;

	Result = WideCharToMultiByte( CP_ACP,
								  0,
								  lpwszSrc,
								  -1,
								  lpszDest,
								  _MAX_PATH,
								  NULL,
								  NULL );
	return ( 0 != Result);
}

BOOL
CRegOp::Char2Uni(
			LPWSTR	lpwszDest,
			LPSTR	lpszSrc )	{
/*++

Routine Description:

	Convert a char string into unicode string. Destination
	string should be preallocated and length of _MAX_PATH 
	should be prepared.

Arguments:

	lpwszDest - Destination wide char string
	lpszSrc - Source char string

Return Value:

	True if success, false otherwise
--*/
	INT Result;

	Result = MultiByteToWideChar ( CP_ACP,
								   0,
								   lpszSrc,
								   -1,
								   lpwszDest,
								   _MAX_PATH );

	return ( 0 != Result );
}

BOOL
CRegOp::CreateNewKey(
				LPSTR	lpszNewKeyName,
				LPSTR	lpszPredefinedKeyName,
				PHKEY	phkResult)	{
/*++

Routine Description:

	Create a new key in the registry.

Arguments:

	lpszNewKeyName - New key name to be created
	lpszPredefinedKeyName - Under which key to create, including path
	phkResult - The handle to the created key

Return Value:

	True if success, false otherwise
--*/
	LONG	err;
	HKEY	hKey = NULL;

	//
	// try to get a handle to the predefined key
	//
	err = RegOpenKeyEx( hkRootKey,
						lpszPredefinedKeyName,
						NULL,
						KEY_CREATE_SUB_KEY,
						&hKey );
	if ( err != ERROR_SUCCESS || hKey == NULL )  {
		if ( hKey ) RegCloseKey( hKey );
		return FALSE;
	}
		 

	//
	// now it's time to create it
	//
	err = RegCreateKey( hKey,
					    lpszNewKeyName,
					    phkResult );

	//
	// close the key handle
	//
	if ( hKey ) RegCloseKey( hKey );

	return ( ERROR_SUCCESS == err );
}

BOOL
CRegOp::RetrieveKeyValue(
				LPSTR	lpszKeyName,
				LPSTR	lpszValueName,
				LPWSTR	lpwszVal)	{
/*++

Routine Description:

	Retrieve a key value.

Arguments:

	lpszKeyName - Key name to retrieve
	lpszValueName - Value name to retrieve
	lpwszVal - The Value that is wanted, it's in unicode

Return Value:

	True if success, false otherwise
--*/
	LONG	err;
	HKEY	key = NULL;
	DWORD	dwType;
	DWORD	dwBufSize = _MAX_PATH;
	
	// 
	// first open the key
	//
	err = RegOpenKeyEx( hkRootKey,
						lpszKeyName,
						NULL,
						KEY_QUERY_VALUE,
						&key);
	if ( NULL == key ||	ERROR_SUCCESS != err )	{
		if ( key ) RegCloseKey( key );
		return FALSE;
	}

	//
	// now retrieve it
	//
	err = RegQueryValueEx( key,
						   lpszValueName,
						   NULL,
						   &dwType,
						   (UCHAR *)lpszKeyValue,
						   &dwBufSize );

	RegCloseKey( key );
	if ( ERROR_SUCCESS != err ) 
		return FALSE;
	
	//
	// convert the key value to unicode
	//
	return ( Char2Uni(lpwszVal, lpszKeyValue) );
}

BOOL
CRegOp::ModifyKeyValue(
				LPSTR	lpszKeyName,
				LPSTR	lpszValueName,
				LPWSTR  lpwszVal)	{
/*++

Routine Description:

	Set a key value.

Arguments:

	lpszKeyName - Key name to set
	lpszValueName - Value name to set
	lpwszVal - The Value that is to be set, it's in unicode

Return Value:

	True if success, false otherwise
--*/
	LONG	err;
	HKEY	key = NULL;

	// 
	// first should open the key
	//
	err = RegOpenKeyEx( hkRootKey,
						lpszKeyName,
						NULL,
						KEY_SET_VALUE,
						&key);
	if ( NULL == key ||	ERROR_SUCCESS != err )	{
		if ( key ) RegCloseKey( key );
		return FALSE;
	}

	//
	// convert the value to set into char string
	//
	if ( !Uni2Char( lpszKeyValue, lpwszVal) )	{
		RegCloseKey( key );
		return FALSE;
	}

	// 
	// now set it
	//
	err = RegSetValueEx( key,
						 lpszValueName,
						 NULL,
						 REG_SZ,
						 (UCHAR *)lpszKeyValue,
						 strlen(lpszKeyValue)+1 );
	RegCloseKey( key );

	return ( ERROR_SUCCESS == err );
}

BOOL	
CRegOp::KeyExist(
			 LPSTR	lpszKeyName )	{
/*++

Routine Description:

	Test if a specified key exists.

Arguments:

	lpszKeyName - Key name to test
	
Return Value:

	True if exist, false otherwise
--*/
	LONG	err;
	HKEY	key = NULL;

	// 
	// try open the key
	//
	err = RegOpenKeyEx( hkRootKey,
						lpszKeyName,
						NULL,
						KEY_QUERY_VALUE, // I don't know if this could
										 // be the representative of
										 // the key's existance
						&key);
	if ( NULL != key &&	ERROR_SUCCESS == err )	{
		RegCloseKey( key );
		return TRUE;
	}

	if ( key ) RegCloseKey( key );
	return FALSE;
}

BOOL
CRegOp::DeleteKeyValue(
				LPSTR	lpszKeyName,
				LPSTR	lpszValueName )	{
/*++

Routine Description:

	Delete a key value.

Arguments:

	lpszKeyName - Key name 
	lpsValueName - Value name
	
Return Value:

	True if success, false otherwise
--*/
	LONG	err;
	HKEY	key = NULL;

	// 
	// try open the key
	//
	err = RegOpenKeyEx( hkRootKey,
						lpszKeyName,
						NULL,
						KEY_SET_VALUE,											
						&key);
	if ( NULL == key ||	ERROR_SUCCESS != err )	{
		if ( key ) RegCloseKey( key );
		return FALSE;
	}

	// 
	// Delete it
	//
	err = RegDeleteValue( key,
						  lpszValueName );
	RegCloseKey( key );

	return ( ERROR_SUCCESS == err );
}

BOOL
CRegOp::DeleteKey(
				  LPSTR lpszParentKeyName,
				  LPSTR	lpszKeyName ) {
/*++

Routine Description:

	Delete a key value.

Arguments:

	lpszKeyName - Key name 
	lpsValueName - Value name
	
Return Value:

	True if success, false otherwise
--*/
	LONG	err;
	HKEY	key = NULL;

	// 
	// open parent key
	//
	err = RegOpenKeyEx( hkRootKey,
						lpszParentKeyName,
						NULL,
						KEY_CREATE_SUB_KEY,											
						&key);
	if ( NULL == key ||	ERROR_SUCCESS != err )	{
		if ( key ) RegCloseKey( key );
		return FALSE;
	}

	//
	// now delete the child key
	//
	err = RegDeleteKey( key,
						lpszKeyName);

	RegCloseKey( key );
	return ( ERROR_SUCCESS == err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\svrapi.h ===
// SvrApi.h: interface for the CSvrApi class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SVRAPI_H__B21747D4_D801_11D0_964C_00AA006D21B7__INCLUDED_)
#define AFX_SVRAPI_H__B21747D4_D801_11D0_964C_00AA006D21B7__INCLUDED_

#include <windows.h>
#include <wtypes.h>
#include "smtpapi.h"
#include "nntptype.h"
#include "nntpapi.h"
#include "dbgtrace.h"

// 
// some registry names
//
#define C_MAILSVR	"mailsvr"
#define C_NEWSSVR	"newssvr"
#define C_M2NDOMAIN "m2ndomain"
#define C_N2MDOMAIN "n2mdomain"
#define CONFIG_PATH "SOFTWARE\\Microsoft\\NewsMail"
#define KEY_NAME	"NewsMail"
#define KEY_PARENT	"SOFTWARE\\Microsoft"

//
// Global Declarations
//
typedef (*FnSmtpCreateDistList) (LPWSTR, LPWSTR, DWORD, DWORD);
typedef (*FnSmtpDeleteDistList) (LPWSTR, LPWSTR, DWORD);
typedef (*FnSmtpCreateDistListMember) (LPWSTR, LPWSTR, LPWSTR, DWORD);
typedef (*FnSmtpDeleteDistListMember) (LPWSTR, LPWSTR, LPWSTR, DWORD);

class CSvrApi   //sa
{
public:
	LPWSTR GetN2MDomain();
	LPWSTR GetM2NDomain();
	BOOL FindNewsGroups(LPNNTP_FIND_LIST *ppList, DWORD *ResultsFound, DWORD cToFind, LPWSTR swzPrefix);
	LPWSTR GetMailServerName(void);
	BOOL DeleteNewsGroup(LPWSTR lpwstrNewsGroup);
	BOOL CreateNewsGroup(LPWSTR lpwstrNewsGroup);
	BOOL DelUserFromDL(LPWSTR lpwstrDL, LPWSTR lpwstrUserEmail);
	BOOL AddUserToDL(LPWSTR lpwstrDL, LPWSTR UserEmail);
	BOOL DeleteDL(LPWSTR lpwstrDL);
	BOOL CreateDL(LPWSTR lpwstrDL);
#if 0
	BOOL RemoveNewsGroup(LPCSTR lpcstrNewsGroup);
	BOOL AddNewsGroup(LPCSTR lpcstrNewsGroup);
#endif
	CSvrApi(LPWSTR lpwstrLocalHost);
	virtual ~CSvrApi();
	
private:
	void GetServerName(void);
	//WCHAR lpwstrUserEmail[_MAX_PATH+1];
	//WCHAR lpwstrGroup[_MAX_PATH+1];
	WCHAR lpwstrNewsServer[_MAX_PATH+1];
	WCHAR lpwstrMailServer[_MAX_PATH+1];
	WCHAR lpwstrM2NDomain[_MAX_PATH+1];
	WCHAR lpwstrN2MDomain[_MAX_PATH+1];
	WCHAR lpwstrLocalHost[MAX_COMPUTERNAME_LENGTH];
};

#endif // !defined(AFX_SVRAPI_H__B21747D4_D801_11D0_964C_00AA006D21B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\svrapi.cpp ===
// SvrApi.cpp: implementation of the CSvrApi class.
//
//////////////////////////////////////////////////////////////////////



#include "stdafx.h"
//#include "admin.h"
#include "SvrApi.h"
#include "regop.h"

#include <stdio.h>
#include <stdlib.h>
#include <crtdbg.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSvrApi::CSvrApi(LPWSTR lpwstrLocalHost)
{
	//
	// get the user mail address and specified news group 
	//
	wcscpy(this->lpwstrLocalHost, lpwstrLocalHost);
	lpwstrNewsServer[0] = L'\0';
	lpwstrMailServer[0] = L'\0';
	lpwstrM2NDomain[0] = L'\0';
	lpwstrN2MDomain[0] = L'\0';

	//
	// get the news server name and mail server name
	//
	GetServerName();
}

CSvrApi::~CSvrApi()
{

}

void
CSvrApi::GetServerName()
/*++

Routine Description:

	Get server names from the registry.  They should be 
	set previously by the administrator.  But if they are
	not already set, set them to he "localhost".  Just 
	assume they are running on the local_host.

	Getting Mail to news domain name has also been added to
	this function, seems not fit for this function name.

Arguments:

	None

Return Value:

	None
--*/
{
	BOOL	fResult = FALSE;
 	CRegOp	RegOp(HKEY_LOCAL_MACHINE);

			
	//  
	// get mail server name
	//
	fResult = RegOp.RetrieveKeyValue( CONFIG_PATH,
									  C_MAILSVR,
									  lpwstrMailServer);

	if (	!fResult ||
			L'\0' == lpwstrMailServer[0] ) { 
		// set it to local machine
		wcscpy(lpwstrMailServer, lpwstrLocalHost);
	}

	//
	// get news server name
	//
	fResult = RegOp.RetrieveKeyValue( CONFIG_PATH,
									  C_NEWSSVR,
									  lpwstrNewsServer);

	if (	!fResult ||
			L'\0' == lpwstrNewsServer[0] ) {
		// set it to local machine
		wcscpy(lpwstrNewsServer, lpwstrLocalHost);
	}

	// 
	// get mail to news domain
	//
	fResult = RegOp.RetrieveKeyValue(	CONFIG_PATH,
										C_M2NDOMAIN,
										lpwstrM2NDomain );
	if (	!fResult ||
			L'\0' == lpwstrM2NDomain[0] ) {
		//let it be the mail server name
		wcscpy(lpwstrM2NDomain, lpwstrMailServer );
	}

	// 
	// get news to mail domain
	//
	fResult = RegOp.RetrieveKeyValue(	CONFIG_PATH,
										C_N2MDOMAIN,
										lpwstrN2MDomain );
	if (	!fResult ||
			L'\0' == lpwstrN2MDomain[0] ) {
		//let it be the mail server name
		wcscpy(lpwstrN2MDomain, lpwstrMailServer );
	}
}

#if 0
BOOL
CSvrApi::AddNewsGroup(LPCSTR lpcstrNewsGroup)
/*++

Routine Description:

	Add news group to the nntp server drop list.

Arguments:

	lpwstrNewsGroup - The news group name to be added 

Return Value:

	True if successful, false otherwise
--*/
{
	LONG err;

	TraceFunctEnter("CSvrApi::AddNewsGroup");

	err = NntpAddDropNewsgroup( lpwstrNewsServer,
			                    1, 
							    lpcstrNewsGroup ) ;

	if ( ERROR_SUCCESS != err )
		DebugTrace(0,	"Add news group to drop list fail %d", 
						GetLastError() );

	TraceFunctLeave();
	
	return ( ERROR_SUCCESS == err );
}

BOOL
CSvrApi::RemoveNewsGroup( LPCSTR lpcstrNewsGroup)
/*++

Routine Description:

	Remove news group from the nntp server drop list.

Arguments:

	lpwstrNewsGroup - The news group name to be added 

Return Value:

	True if successful, false otherwise
--*/
{
	LONG err;

	TraceFunctEnter("SvrApi::RemoveNewsGroup");
	
	err = NntpRemoveDropNewsgroup( lpwstrNewsServer,
								   1,
								   lpcstrNewsGroup );

	if ( ERROR_SUCCESS != err ) 
		DebugTrace(0, "Remove Newsgroup fail %d", GetLastError());

	TraceFunctLeave();

	return ( ERROR_SUCCESS == err );
}
#endif

BOOL 
CSvrApi::CreateDL(LPWSTR lpwstrDL)
/*++

Routine Description:

	Create distribution list to the mail server

Arguments:

	lpwstrDL - The list name to be added 

Return Value:

	True if successful, false otherwise
--*/
{ 
	HINSTANCE	hinst;
	DWORD		dwError = NO_ERROR;
	FnSmtpCreateDistList fn;

	TraceFunctEnter("CSvrApi::CreateDL");

	hinst = LoadLibrary("smtpapi.dll");
	if ( !hinst ) {
		FatalTrace(0, "Load library fail %d", GetLastError() );
		TraceFunctLeave();
		return FALSE;
	}

	fn = (FnSmtpCreateDistList)GetProcAddress(hinst, 
											  "SmtpCreateDistList");
	if ( !fn ) {
		FreeLibrary( hinst );
		ErrorTrace(0, "Get procedure fail %d", GetLastError());
		TraceFunctLeave();
		return FALSE;
	}
 	
	dwError = (*fn) (lpwstrMailServer, 
					 lpwstrDL,
					 NAME_TYPE_LIST_NORMAL,
					 1 );
	
	if ( NO_ERROR != dwError ) {
		FreeLibrary( hinst );
		DebugTrace(0, "Create DL fail %d", dwError);
		TraceFunctLeave();
		return FALSE;
	}
	
	FreeLibrary( hinst );
	TraceFunctLeave();
	return TRUE;
}

BOOL
CSvrApi::DeleteDL(LPWSTR lpwstrDL)
/*++

Routine Description:

	Delete distribution list to the mail server

Arguments:

	lpwstrDL - The list name to be deleted

Return Value:

	True if successful, false otherwise
--*/
{
	HINSTANCE	hinst;
	DWORD		dwError;
	FnSmtpDeleteDistList fn;

	TraceFunctEnter("CSvrApi::DeleteDL");

	hinst = LoadLibrary("smtpapi.dll");
	if ( !hinst ) {
		FatalTrace(0, "Load library fail %d", GetLastError());
		TraceFunctLeave();
		return FALSE;
	}

	fn = (FnSmtpDeleteDistList)GetProcAddress( hinst, 
											   "SmtpDeleteDistList");
	if ( !fn ) {
		ErrorTrace(0, "Get procedure fail %d", GetLastError());
		TraceFunctLeave();
		FreeLibrary( hinst );
		return FALSE;
	}

	dwError = (*fn)(lpwstrMailServer, 
					lpwstrDL,
					1 );
	if ( NO_ERROR != dwError ) {
		DebugTrace(0, "Delete DL fail %d", GetLastError());
		TraceFunctLeave();
		FreeLibrary( hinst );
		return FALSE;
	}

	FreeLibrary( hinst );
	TraceFunctLeave();
	return TRUE;
}

BOOL 
CSvrApi::AddUserToDL(LPWSTR lpwstrDL, LPWSTR lpwstrUserEmail)
/*++

Routine Description:

	Add one user to the distribution list.

Arguments:

	lpwstrDL - The list name to be added into
	lpwstrUserEmail - The user address
	
Return Value:

	True if successful, false otherwise
--*/
{
	HINSTANCE	hinst;
	DWORD		dwError;
	FnSmtpCreateDistListMember fn;

	TraceFunctEnter("CSvrApi::AddUserToDL");

	hinst = LoadLibrary( "smtpapi.dll");
	if ( !hinst ) {
		FatalTrace(0, "Load library fail %d", GetLastError());
		TraceFunctLeave();
		return FALSE;
	}

	fn = (FnSmtpCreateDistListMember)GetProcAddress(hinst,
													"SmtpCreateDistListMember");
	if ( !fn ) {
		ErrorTrace(0, "Find procedure fail %d", GetLastError());
		TraceFunctLeave();
		FreeLibrary( hinst );
		return FALSE;
	}

	dwError = (*fn)(lpwstrMailServer, 
					lpwstrDL, 
					lpwstrUserEmail,
					1 );
	
	if ( NO_ERROR != dwError ) {
		DebugTrace(0, "Add user to DL fail %d", GetLastError());
		TraceFunctLeave();
		FreeLibrary( hinst );
		return FALSE;
	} 

	FreeLibrary( hinst );
	TraceFunctLeave();
	return TRUE;
}

BOOL 
CSvrApi::DelUserFromDL(LPWSTR lpwstrDL, LPWSTR lpwstrUserEmail)
/*++

Routine Description:

	Delete one user from the distribution list.

Arguments:

	lpwstrDL - The list name to be deleted from
	lpwstrUserEmail - The user address
	
Return Value:

	True if successful, false otherwise
--*/
{
	HINSTANCE	hinst;
	DWORD		dwError;
	FnSmtpDeleteDistListMember fn;

	TraceFunctEnter("CSvrApi::DelUserFromDL");

	hinst = LoadLibrary("smtpapi.dll");
	if ( !hinst ) {
		FatalTrace(0, "Load library fail %d", GetLastError());
		TraceFunctLeave();
		return FALSE;
	}

	fn = (FnSmtpDeleteDistListMember)GetProcAddress(hinst, 
													"SmtpDeleteDistListMember");
	if ( !fn ) {
		ErrorTrace(0, "Find procedure fail %d", GetLastError());
		TraceFunctLeave();
		FreeLibrary( hinst );
		return FALSE;
	}

	dwError = (*fn)(lpwstrMailServer, 
					lpwstrDL, 
					lpwstrUserEmail,
					1);
	
	if ( NO_ERROR != dwError ) {
		DebugTrace(0, "Del user from DL fail %d", GetLastError());
		TraceFunctLeave();
		FreeLibrary( hinst );
		return FALSE;
	}

	FreeLibrary( hinst );
	TraceFunctLeave();
	return TRUE;
}

BOOL 
CSvrApi::CreateNewsGroup(LPWSTR lpwstrNewsGroup)
/*++

Routine Description:

	Create a news group on the news server

Arguments:

	lpwstrNewsGroup - News group name
	
Return Value:

	True if successful, false otherwise
--*/
{
	DWORD					err;
	LPNNTP_NEWSGROUP_INFO	NewsGroupInfo;
	PCHAR					NewsGroupName = NULL;

	TraceFunctEnter("CSvrApi::CreateNewsGroup");

	//
	// set proper newsgroup infomation
	//

	NewsGroupInfo = new NNTP_NEWSGROUP_INFO;
	if ( !NewsGroupInfo )
		FatalTrace(0, "Memory allocation error");

	// clear memory
	ZeroMemory(NewsGroupInfo, sizeof(NNTP_NEWSGROUP_INFO) );

	NewsGroupName = (PCHAR)&lpwstrNewsGroup[0];
	NewsGroupInfo->Newsgroup = (PUCHAR)NewsGroupName;
	NewsGroupInfo->cbNewsgroup = (wcslen( (LPWSTR)NewsGroupName ) + 1) * sizeof(WCHAR);
	
	// 
	// Create it
	//
	err = NntpCreateNewsgroup(	lpwstrNewsServer,
								1,
								NewsGroupInfo );

	//
	// Free memory could be before error checking
	//
	delete NewsGroupInfo;

	/*if ( err != NO_ERROR )	{
		DebugTrace(0, "Create Newsgroup fail %d", err);
		TraceFunctLeave();
		return FALSE;
	}*/

	TraceFunctLeave();

	return TRUE;
}

BOOL 
CSvrApi::DeleteNewsGroup(LPWSTR lpwstrNewsGroup)
/*++

Routine Description:

	Delete a news group on the news server

Arguments:

	lpwstrNewsGroup - News group name
	
Return Value:

	True if successful, false otherwise
--*/ 
{
	DWORD					err;
	LPNNTP_NEWSGROUP_INFO	NewsGroupInfo;
	PCHAR					NewsGroupName = NULL;

	TraceFunctEnter("CSvrApi::DeleteNewsGroup");

	//
	// set proper newsgroup infomation
	//

	NewsGroupInfo = new NNTP_NEWSGROUP_INFO;
	if ( !NewsGroupInfo )
		FatalTrace(0, "Memroy allocate error");

	// clear memory
	ZeroMemory(NewsGroupInfo, sizeof(NNTP_NEWSGROUP_INFO) );

	NewsGroupName = (PCHAR)&lpwstrNewsGroup[0];
	NewsGroupInfo->Newsgroup = (PUCHAR)NewsGroupName;
	NewsGroupInfo->cbNewsgroup = (wcslen( (LPWSTR)NewsGroupName ) + 1) * sizeof(WCHAR);
	
	// 
	// Delete it
	//
	err = NntpDeleteNewsgroup(	lpwstrNewsServer,
								1,
								NewsGroupInfo );

	//
	// Free memory could be before error checking
	//
	delete NewsGroupInfo;

	if ( err != NO_ERROR )	{
		DebugTrace(0, "Delete News Group Fail %d", GetLastError());
		TraceFunctLeave();
		return FALSE;
	}

	TraceFunctLeave();

	return TRUE;
}

LPWSTR 
CSvrApi::GetMailServerName()
/*++

Routine Description:

	Just an interface to return the mail server name,
	shouldn't assume the returned string persists out
	side the function

Arguments:

	None

Return Value:

	Pointer to that string.
--*/
{
	return lpwstrMailServer;
}

BOOL 
CSvrApi::FindNewsGroups(	LPNNTP_FIND_LIST * ppList, 
							DWORD * ResultsFound, 
							DWORD cToFind, 
							LPWSTR swzPrefix)
/*++

Routine Description:

	Find the specified number of newsgroups with the specified
	prefix that currently exist on the news server

Arguments:

	ppList - Pointer to pointer to the list of results
	ResultsFound - Address to store number of newsgroups found
	cToFind - Number of groups to be found
	swzPrefix - Prefix of group to be found

Return Value:

	True if successful, false otherwise
--*/
{
	TraceFunctEnter("CSvrApi::FindNewsGroups");
	
	DWORD err;

	err = NntpFindNewsgroup(	lpwstrNewsServer,
								1,
								swzPrefix,
								cToFind,
								ResultsFound,
								ppList	);
	if ( err != NO_ERROR )	{
		ErrorTrace(	0, 
					"Can't find existing news groups, err %d",
					GetLastError()	);
		TraceFunctLeave();
		return FALSE;
	}
	else	{
		TraceFunctLeave();
		return TRUE;
	}
}

LPWSTR 
CSvrApi::GetM2NDomain()
/*++

Routine Description:

	Just an interface to return the Mail to News domain,
	shouldn't assume the returned string persists out
	side the function

Arguments:

	None

Return Value:

	Pointer to that string.
--*/
{
	return lpwstrM2NDomain;
}


LPWSTR 
CSvrApi::GetN2MDomain()
/*++

Routine Description:

	Just an interface to return the News to Mail domain,
	shouldn't assume the returned string persists out
	side the function

Arguments:

	None

Return Value:

	Pointer to that string.
--*/
{
	return lpwstrN2MDomain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj\search.cpp ===
// search.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f searchps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "search.h"

#include "search_i.c"
#include <initguid.h>
#include "qry.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_qry, Cqry)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj2\asptlb.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: ASPTypeLibrary */

#ifndef _ASPTypeLibrary_H_
#define _ASPTypeLibrary_H_

DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0L,0xA85C,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IStringList,0xD97A6DA0L,0xA85D,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IStringList */
#undef INTERFACE
#define INTERFACE IStringList

DECLARE_INTERFACE_(IStringList, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IStringList methods */
    STDMETHOD(get_Item)(THIS_ VARIANT i, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* cStrRet) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0L,0xA85F,0x11DF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequestDictionary */
#undef INTERFACE
#define INTERFACE IRequestDictionary

DECLARE_INTERFACE_(IRequestDictionary, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequestDictionary methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequest,0xD97A6DA0L,0xA861,0x11CF,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequest */
#undef INTERFACE
#define INTERFACE IRequest

DECLARE_INTERFACE_(IRequest, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequest methods */
    STDMETHOD(get_Item)(THIS_ BSTR bstrVar, IDispatch * FAR* ppObjReturn) PURE;
    STDMETHOD(get_QueryString)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Form)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Body)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ServerVariables)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ClientCertificate)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
};

DEFINE_GUID(CLSID_Request,0x920C25D0L,0x25D9,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Request;
#endif

DEFINE_GUID(IID_IReadCookie,0x71EAF260L,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

/* Definition of interface: IReadCookie */
#undef INTERFACE
#define INTERFACE IReadCookie

DECLARE_INTERFACE_(IReadCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IReadCookie methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0L,0xA862,0x11CF,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IWriteCookie */
#undef INTERFACE
#define INTERFACE IWriteCookie

DECLARE_INTERFACE_(IWriteCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IWriteCookie methods */
    STDMETHOD(put_Item)(THIS_ VARIANT key, BSTR bstrValue) PURE;
    STDMETHOD(put_Expires)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(put_Domain)(THIS_ BSTR bstrDomain) PURE;
    STDMETHOD(put_Path)(THIS_ BSTR bstrPath) PURE;
    STDMETHOD(put_Secure)(THIS_ VARIANT_BOOL fSecure) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IResponse,0xD97A6DA0L,0xA864,0x11CF,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IResponse */
#undef INTERFACE
#define INTERFACE IResponse

DECLARE_INTERFACE_(IResponse, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IResponse methods */
    STDMETHOD(get_Buffer)(THIS_ VARIANT_BOOL FAR* fIsBuffering) PURE;
    STDMETHOD(put_Buffer)(THIS_ VARIANT_BOOL fIsBuffering) PURE;
    STDMETHOD(get_ContentType)(THIS_ BSTR FAR* pbstrContentTypeRet) PURE;
    STDMETHOD(put_ContentType)(THIS_ BSTR bstrContentType) PURE;
    STDMETHOD(get_Expires)(THIS_ VARIANT FAR* pvarExpiresMinutesRet) PURE;
    STDMETHOD(put_Expires)(THIS_ long lExpiresMinutes) PURE;
    STDMETHOD(get_ExpiresAbsolute)(THIS_ VARIANT FAR* pvarExpiresRet) PURE;
    STDMETHOD(put_ExpiresAbsolute)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppCookies) PURE;
    STDMETHOD(get_Status)(THIS_ BSTR FAR* pbstrStatusRet) PURE;
    STDMETHOD(put_Status)(THIS_ BSTR bstrStatus) PURE;
    STDMETHOD(Add)(THIS_ BSTR bstrHeaderValue, BSTR bstrHeaderName) PURE;
    STDMETHOD(AddHeader)(THIS_ BSTR bstrHeaderName, BSTR bstrHeaderValue) PURE;
    STDMETHOD(AppendToLog)(THIS_ BSTR bstrLogEntry) PURE;
    STDMETHOD(BinaryWrite)(THIS_ VARIANT varInput) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(End)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;
    STDMETHOD(Redirect)(THIS_ BSTR bstrURL) PURE;
    STDMETHOD(Write)(THIS_ VARIANT varText) PURE;
    STDMETHOD(WriteBlock)(THIS_ short iBlockNumber) PURE;
};

DEFINE_GUID(CLSID_Response,0x46E19BA0L,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Response;
#endif

DEFINE_GUID(IID_ISessionObject,0xD97A6DA0L,0xA865,0x11CF,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: ISessionObject */
#undef INTERFACE
#define INTERFACE ISessionObject

DECLARE_INTERFACE_(ISessionObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ISessionObject methods */
    STDMETHOD(get_SessionID)(THIS_ BSTR FAR* pbstrRet) PURE;
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(get_Timeout)(THIS_ long FAR* plvar) PURE;
    STDMETHOD(put_Timeout)(THIS_ long lvar) PURE;
    STDMETHOD(Abandon)(THIS) PURE;
};

DEFINE_GUID(CLSID_Session,0x509F8F20L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Session;
#endif

DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0L,0xA866,0x11CF,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IApplicationObject */
#undef INTERFACE
#define INTERFACE IApplicationObject

DECLARE_INTERFACE_(IApplicationObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IApplicationObject methods */
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(Lock)(THIS) PURE;
    STDMETHOD(UnLock)(THIS) PURE;
};

DEFINE_GUID(CLSID_Application,0x7C3BAF00L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Application;
#endif

DEFINE_GUID(IID_IServer,0xD97A6DA0L,0xA867,0x11CF,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IServer */
#undef INTERFACE
#define INTERFACE IServer

DECLARE_INTERFACE_(IServer, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IServer methods */
    STDMETHOD(get_ScriptTimeout)(THIS_ long FAR* plTimeoutSeconds) PURE;
    STDMETHOD(put_ScriptTimeout)(THIS_ long lTimeoutSeconds) PURE;
    STDMETHOD(CreateObject)(THIS_ BSTR bstrProgID, IDispatch * FAR* ppDispObject) PURE;
    STDMETHOD(HTMLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
    STDMETHOD(MapPath)(THIS_ BSTR bstrLogicalPath, BSTR FAR* pbstrPhysicalPath) PURE;
    STDMETHOD(URLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
};

DEFINE_GUID(CLSID_Server,0xA506D160L,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Server;
#endif

DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IScriptingContext */
#undef INTERFACE
#define INTERFACE IScriptingContext

DECLARE_INTERFACE_(IScriptingContext, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptingContext methods */
    STDMETHOD(get_Request)(THIS_ IRequest FAR* FAR* ppRequest) PURE;
    STDMETHOD(get_Response)(THIS_ IResponse FAR* FAR* ppResponse) PURE;
    STDMETHOD(get_Server)(THIS_ IServer FAR* FAR* ppServer) PURE;
    STDMETHOD(get_Session)(THIS_ ISessionObject FAR* FAR* ppSession) PURE;
    STDMETHOD(get_Application)(THIS_ IApplicationObject FAR* FAR* ppApplication) PURE;
};

DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus
class ScriptingContext;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj2\fail.cpp ===
// fail.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f failps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "fail.h"

#include "fail_i.c"
#include <initguid.h>
#include "ss.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ss, Css)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj2\asptlb5.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: ASPTypeLibrary */

#ifndef _ASPTypeLibrary_H_
#define _ASPTypeLibrary_H_

DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0L,0xA85C,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IStringList,0xD97A6DA0L,0xA85D,0x11CF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IStringList */
#undef INTERFACE
#define INTERFACE IStringList

DECLARE_INTERFACE_(IStringList, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IStringList methods */
    STDMETHOD(get_Item)(THIS_ VARIANT i, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_Count)(THIS_ int FAR* cStrRet) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0L,0xA85F,0x11DF,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequestDictionary */
#undef INTERFACE
#define INTERFACE IRequestDictionary

DECLARE_INTERFACE_(IRequestDictionary, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequestDictionary methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IRequest,0xD97A6DA0L,0xA861,0x11CF,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IRequest */
#undef INTERFACE
#define INTERFACE IRequest

DECLARE_INTERFACE_(IRequest, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IRequest methods */
    STDMETHOD(get_Item)(THIS_ BSTR bstrVar, IDispatch * FAR* ppObjReturn) PURE;
    STDMETHOD(get_QueryString)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Form)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Body)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ServerVariables)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_ClientCertificate)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppDictReturn) PURE;
};

DEFINE_GUID(CLSID_Request,0x920C25D0L,0x25D9,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Request;
#endif

DEFINE_GUID(IID_IReadCookie,0x71EAF260L,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

/* Definition of interface: IReadCookie */
#undef INTERFACE
#define INTERFACE IReadCookie

DECLARE_INTERFACE_(IReadCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IReadCookie methods */
    STDMETHOD(get_Item)(THIS_ VARIANT Var, VARIANT FAR* pVariantReturn) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0L,0xA862,0x11CF,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IWriteCookie */
#undef INTERFACE
#define INTERFACE IWriteCookie

DECLARE_INTERFACE_(IWriteCookie, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IWriteCookie methods */
    STDMETHOD(put_Item)(THIS_ VARIANT key, BSTR bstrValue) PURE;
    STDMETHOD(put_Expires)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(put_Domain)(THIS_ BSTR bstrDomain) PURE;
    STDMETHOD(put_Path)(THIS_ BSTR bstrPath) PURE;
    STDMETHOD(put_Secure)(THIS_ VARIANT_BOOL fSecure) PURE;
    STDMETHOD(get_HasKeys)(THIS_ VARIANT_BOOL FAR* pfHasKeys) PURE;
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppEnumReturn) PURE;
};

DEFINE_GUID(IID_IResponse,0xD97A6DA0L,0xA864,0x11CF,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IResponse */
#undef INTERFACE
#define INTERFACE IResponse

DECLARE_INTERFACE_(IResponse, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IResponse methods */
    STDMETHOD(get_Buffer)(THIS_ VARIANT_BOOL FAR* fIsBuffering) PURE;
    STDMETHOD(put_Buffer)(THIS_ VARIANT_BOOL fIsBuffering) PURE;
    STDMETHOD(get_ContentType)(THIS_ BSTR FAR* pbstrContentTypeRet) PURE;
    STDMETHOD(put_ContentType)(THIS_ BSTR bstrContentType) PURE;
    STDMETHOD(get_Expires)(THIS_ VARIANT FAR* pvarExpiresMinutesRet) PURE;
    STDMETHOD(put_Expires)(THIS_ long lExpiresMinutes) PURE;
    STDMETHOD(get_ExpiresAbsolute)(THIS_ VARIANT FAR* pvarExpiresRet) PURE;
    STDMETHOD(put_ExpiresAbsolute)(THIS_ DATE dtExpires) PURE;
    STDMETHOD(get_Cookies)(THIS_ IRequestDictionary FAR* FAR* ppCookies) PURE;
    STDMETHOD(get_Status)(THIS_ BSTR FAR* pbstrStatusRet) PURE;
    STDMETHOD(put_Status)(THIS_ BSTR bstrStatus) PURE;
    STDMETHOD(Add)(THIS_ BSTR bstrHeaderValue, BSTR bstrHeaderName) PURE;
    STDMETHOD(AddHeader)(THIS_ BSTR bstrHeaderName, BSTR bstrHeaderValue) PURE;
    STDMETHOD(AppendToLog)(THIS_ BSTR bstrLogEntry) PURE;
    STDMETHOD(BinaryWrite)(THIS_ VARIANT varInput) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(End)(THIS) PURE;
    STDMETHOD(Flush)(THIS) PURE;
    STDMETHOD(Redirect)(THIS_ BSTR bstrURL) PURE;
    STDMETHOD(Write)(THIS_ VARIANT varText) PURE;
    STDMETHOD(WriteBlock)(THIS_ short iBlockNumber) PURE;
};

DEFINE_GUID(CLSID_Response,0x46E19BA0L,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Response;
#endif

DEFINE_GUID(IID_ISessionObject,0xD97A6DA0L,0xA865,0x11CF,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: ISessionObject */
#undef INTERFACE
#define INTERFACE ISessionObject

DECLARE_INTERFACE_(ISessionObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* ISessionObject methods */
    STDMETHOD(get_SessionID)(THIS_ BSTR FAR* pbstrRet) PURE;
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(get_Timeout)(THIS_ long FAR* plvar) PURE;
    STDMETHOD(put_Timeout)(THIS_ long lvar) PURE;
    STDMETHOD(Abandon)(THIS) PURE;
};

DEFINE_GUID(CLSID_Session,0x509F8F20L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Session;
#endif

DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0L,0xA866,0x11CF,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IApplicationObject */
#undef INTERFACE
#define INTERFACE IApplicationObject

DECLARE_INTERFACE_(IApplicationObject, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IApplicationObject methods */
    STDMETHOD(get_Value)(THIS_ BSTR bstrValue, VARIANT FAR* pvar) PURE;
    STDMETHOD(put_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(putref_Value)(THIS_ BSTR bstrValue, VARIANT var) PURE;
    STDMETHOD(Lock)(THIS) PURE;
    STDMETHOD(UnLock)(THIS) PURE;
};

DEFINE_GUID(CLSID_Application,0x7C3BAF00L,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Application;
#endif

DEFINE_GUID(IID_IServer,0xD97A6DA0L,0xA867,0x11CF,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IServer */
#undef INTERFACE
#define INTERFACE IServer

DECLARE_INTERFACE_(IServer, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IServer methods */
    STDMETHOD(get_ScriptTimeout)(THIS_ long FAR* plTimeoutSeconds) PURE;
    STDMETHOD(put_ScriptTimeout)(THIS_ long lTimeoutSeconds) PURE;
    STDMETHOD(CreateObject)(THIS_ BSTR bstrProgID, IDispatch * FAR* ppDispObject) PURE;
    STDMETHOD(HTMLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
    STDMETHOD(MapPath)(THIS_ BSTR bstrLogicalPath, BSTR FAR* pbstrPhysicalPath) PURE;
    STDMETHOD(URLEncode)(THIS_ BSTR bstrIn, BSTR FAR* pbstrEncoded) PURE;
};

DEFINE_GUID(CLSID_Server,0xA506D160L,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus
class Server;
#endif

DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

/* Definition of interface: IScriptingContext */
#undef INTERFACE
#define INTERFACE IScriptingContext

DECLARE_INTERFACE_(IScriptingContext, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IScriptingContext methods */
    STDMETHOD(get_Request)(THIS_ IRequest FAR* FAR* ppRequest) PURE;
    STDMETHOD(get_Response)(THIS_ IResponse FAR* FAR* ppResponse) PURE;
    STDMETHOD(get_Server)(THIS_ IServer FAR* FAR* ppServer) PURE;
    STDMETHOD(get_Session)(THIS_ ISessionObject FAR* FAR* ppSession) PURE;
    STDMETHOD(get_Application)(THIS_ IApplicationObject FAR* FAR* ppApplication) PURE;
};

DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0L,0xA868,0x11CF,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus
class ScriptingContext;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fail.rc
//
#define IDS_PROJNAME                    100
#define IDR_SS                          101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C99F41A6_08FC_11D1_922A_00AA00C148BE__INCLUDED_)
#define AFX_STDAFX_H__C99F41A6_08FC_11D1_922A_00AA00C148BE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C99F41A6_08FC_11D1_922A_00AA00C148BE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\redist\makefile.inc ===
copyfiles:
!if "$(_NTTREE)" != ""
	xcopy /verifd asp $(_NTTREE)\staxpt\srchasp
	xcopy /verifd samples $(_NTTREE)\staxpt\srchsmpl
!endif
!if "$(_NTTREE_NO_SPLIT)" != ""
	xcopy /verifd asp $(_NTTREE_NO_SPLIT)\staxpt\srchasp
	xcopy /verifd samples $(_NTTREE_NO_SPLIT)\staxpt\srchsmpl
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj2\ss.cpp ===
// ss.cpp : Implementation of Css

#include "stdafx.h"
#include "fail.h"
#include "ss.h"
#include "dbgtrace.h"

/////////////////////////////////////////////////////////////////////////////
// Css

STDMETHODIMP Css::OnStartPage (IUnknown* pUnk)  
{
	if(!pUnk)
		return E_POINTER;

	CComPtr<IScriptingContext> spContext;
	HRESULT hr;

	// Get the IScriptingContext Interface
	hr = pUnk->QueryInterface(IID_IScriptingContext, (void **)&spContext);
	if(FAILED(hr))
		return hr;

	// Get Request Object Pointer
	hr = spContext->get_Request(&m_piRequest);
	if(FAILED(hr))
	{
		spContext.Release();
		return hr;
	}

	// Get Response Object Pointer
	hr = spContext->get_Response(&m_piResponse);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		return hr;
	}
	
	// Get Server Object Pointer
	hr = spContext->get_Server(&m_piServer);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		return hr;
	}
	
	// Get Session Object Pointer
	hr = spContext->get_Session(&m_piSession);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		return hr;
	}

	// Get Application Object Pointer
	hr = spContext->get_Application(&m_piApplication);
	if(FAILED(hr))
	{
		m_piRequest.Release();
		m_piResponse.Release();
		m_piServer.Release();
		m_piSession.Release();
		return hr;
	}
	m_bOnStartPageCalled = TRUE;
	return S_OK;
}

STDMETHODIMP Css::OnEndPage ()  
{
	m_bOnStartPageCalled = FALSE;
	// Release all interfaces
	m_piRequest.Release();
	m_piResponse.Release();
	m_piServer.Release();
	m_piSession.Release();
	m_piApplication.Release();

	return S_OK;
}


STDMETHODIMP Css::DoQuery()
{
	// TODO: Add your implementation code here
	InitAsyncTrace();
	TraceFunctEnter("Css:DoQuery");

	HRESULT hr;

	CIndexServerQuery *in;

	in = new CIndexServerQuery;

	hr = in->MakeQuery(	TRUE,
						L"@Newsdate > 97/7/1 0:0:0 and #vpath *.nws",
						NULL,
						L"Web",
						NULL,
						L"newsgroup,newsarticleid,newsmsgid,newsfrom,newssubject,filename",
						L"newsgroup,newsarticleid,newsmsgid,newsfrom,newssubject,filename" );
	if ( FAILED( hr ) ) {
		ErrorTrace(0, "Make query failed: %x", hr );
		delete in;
		TraceFunctLeave();
		TermAsyncTrace();
		return hr;
	}

	delete in;

	TraceFunctLeave();
	TermAsyncTrace();
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\qryobj2\ss.h ===
// ss.h : Declaration of the Css

#ifndef __SS_H_
#define __SS_H_

#include "resource.h"       // main symbols
#include "asptlb5.h"         // Active Server Pages Definitions
#include "offquery.h"

/////////////////////////////////////////////////////////////////////////////
// Css
class ATL_NO_VTABLE Css : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<Css, &CLSID_ss>,
	public IDispatchImpl<Iss, &IID_Iss, &LIBID_FAILLib>
	
{
public:
	Css()
	{ 
		m_bOnStartPageCalled = FALSE;
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SS)

BEGIN_COM_MAP(Css)
	COM_INTERFACE_ENTRY(Iss)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Iss
public:
	STDMETHOD(DoQuery)();
	//Active Server Pages Methods
	STDMETHOD(OnStartPage)(IUnknown* IUnk);
	STDMETHOD(OnEndPage)();

private:
	CComPtr<IRequest> m_piRequest;					//Request Object
	CComPtr<IResponse> m_piResponse;				//Response Object
	CComPtr<ISessionObject> m_piSession;			//Session Object
	CComPtr<IServer> m_piServer;					//Server Object
	CComPtr<IApplicationObject> m_piApplication;	//Application Object
	BOOL m_bOnStartPageCalled;						//OnStartPage successful?
};

#endif //__SS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\utest\meta2_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Sun Jul 20 20:01:19 1997
 */
/* Compiler settings for d:\ex\stacks\src\news\search\qrydb\meta2.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_Ireq = {0x583BDCAD,0xE7F7,0x11D0,{0x91,0xE8,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


const IID LIBID_META2Lib = {0x583BDCA0,0xE7F7,0x11D0,{0x91,0xE8,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


const CLSID CLSID_req = {0x583BDCAE,0xE7F7,0x11D0,{0x91,0xE8,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\utest\main.cpp ===
#include <windows.h>
#include <winbase.h>
#include <objbase.h>
#include <iostream.h>
#include <stdio.h>
#include <crtdbg.h>
#include <stdio.h>

#include "search_i.c"
#include "search.h"
#include "meta2_i.c"
#include "meta2.h"

// whether need to save back times
BOOL	g_fNeedSave = FALSE;

// time interval ( hours )
CHAR	g_szHours[_MAX_PATH];

// time interval ( minutes )
CHAR	g_szMinutes[_MAX_PATH];

// if the program should be persistent
BOOL	g_fPersist = FALSE;

// to clean
BOOL	g_fToClean = FALSE;

// to restore
BOOL	g_fToRestore = FALSE;

BOOL	
isNumber( PCHAR szString )
{
	PCHAR	pchPtr = szString;

	while ( *pchPtr ) 
		if ( !isdigit( *(pchPtr++) ) )
			return FALSE;

	return TRUE;
}

VOID
WINAPI
ShowUsage (
             VOID
)
{
   fputs ("usage: drive [switches]\n"
	  "               [-?] show this message\n"
	  "               [-m] minutes after which to execute ( <= 0 will be ignored )  \n"
	  "               [-h] hours after which to execute ( <= 0 will be ignored ) \n"
	  "               [-s] save back the search time stamp \n"
	  "               [-c] clean out all bad queries ( when -r isn't set)\n"
	  "               [-r] restore all queries to be good ( when -c isn't set )\n"
	                 ,stderr);

   ExitProcess( 1 );
}

VOID
WINAPI
ParseSwitch (
               CHAR chSwitch,
               int *pArgc,
               char **pArgv[]
)
{
   switch (toupper (chSwitch))
   {

   case '?':
      ShowUsage ();
      break;

   case 'M':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      strcpy (g_szMinutes, *(*pArgv));
	  if ( !isNumber( g_szMinutes ) )
	  {
		  ShowUsage();
	  }
	  
      break;

   case 'H':
      if (!--(*pArgc))
      {
         ShowUsage ();
      }
      (*pArgv)++;
      strcpy (g_szHours, *(*pArgv));
	  if ( !isNumber( g_szHours ) )
	  {
		  ShowUsage();
	  }

      break;

   case 'S':
      g_fNeedSave = TRUE;
      break;

   case 'C':
	  g_fToClean = TRUE;
	  break;

   case 'R':
	   g_fToRestore = TRUE;
	   break;

   default:
      fprintf (stderr, "drive: Invalid switch - /%c\n", chSwitch);
      ShowUsage ();
      break;

   }
}


int __cdecl main(int argc, char **argv)
{
	HRESULT		hr = OleInitialize(NULL);
	wchar_t		progid[] = L"req.req.1";
	CLSID		clsid;
	IDispatch	*pdispPtr = NULL;
	Ireq		*piReq;
	Iqry		*piQry;
	BOOL		fSuccess;
	DWORD		cCount = 0;
	CHAR		chChar, *pchChar;
	DWORD		dwMins;
	DWORD		dwHours;
	DWORD		dwTotalMSecs;
	BSTR		bstrProperty;

	if ( FAILED( hr ) ) {// Oleinit 
		printf( "Oleinitialize fail\n" );
		exit( 1 );
	}

	//
	// Parse switch
	//
	while (--argc)
	{
		pchChar = *++argv;
		if (*pchChar == '/' || *pchChar == '-')
		{
			while (chChar = *++pchChar)
			{
				ParseSwitch (chChar, &argc, &argv);
			}
		}
	}

	//
	// they can't exist at the same time
	//
	if ( g_fToClean && g_fToRestore )
		ShowUsage();

	//
	// set times
	//
	if ( '\0' != g_szHours[0] ) 
		dwHours = atol( g_szHours );
	else
		dwHours = 0;

	if ( '\0' != g_szMinutes[0] )
		dwMins = atol( g_szMinutes );
	else 
		dwMins = 0;

	dwTotalMSecs = ( dwMins * 60 + dwHours * 3600 ) * 1000;

	g_fPersist = ( dwTotalMSecs > 0 );


	hr = CLSIDFromProgID(	progid,
							&clsid	);
	
	if ( FAILED( hr ) ) {
		printf( "Unable to get class id hr=%X\n", hr );

		exit(1);
	}

	while ( TRUE ) {

		cCount = 0;

		hr = CoCreateInstance(	clsid,
								NULL,
								CLSCTX_INPROC_SERVER,
								IID_Ireq,
								(void **)&pdispPtr	);
		if  ( FAILED ( hr ) ) {
			printf("Cocreat fail %x\n", hr);
			printf("%x\n", REGDB_E_CLASSNOTREG);
			printf("%x\n", CLASS_E_NOAGGREGATION);
			exit(1);  
		}

		piReq = (Ireq *)pdispPtr;

		if ( g_fToClean ) {
			printf( "Cleaning..." );
			piReq->Clean();
			printf( "\n" );
			goto release;
		}

		hr = piReq->ItemInit();
		if ( FAILED( hr ) ) {
			printf( "Enumeration init fail hr = %X\n" , hr );
			exit(1);
		}

		printf( "Item inited\n" );

		hr = piReq->ItemNext(	&pdispPtr,
							&fSuccess	);
		if ( FAILED( hr ) ) {
			printf( "Item next fail hr=%X\n", hr );

			exit(1);
		}

		while ( fSuccess ) {
		 
			piQry = (Iqry *)pdispPtr;

			//
			// if is a bad query and need clean
			//
			hr = piQry->get_IsBadQuery( &bstrProperty);
			if ( FAILED( hr ) ) {
				printf("Do query fail: %x", hr );
				exit(1);
			}

			if (	!wcscmp( bstrProperty, L"1") ) {
				SysFreeString( bstrProperty );

				//
				// if we want to restore
				//
				if ( g_fToRestore ) {
					// set property to be good
					hr = piQry->put_IsBadQuery(L"0");
					if ( FAILED( hr ) ) {
						printf( "Set property fail hr=%X", hr);
						exit(1);
					}

					g_fNeedSave = TRUE;

					goto next_with_save;
				}
			}

			SysFreeString(bstrProperty);
				
			//
			// if to clean or restore we are not going to do query
			if ( g_fToClean || g_fToRestore )
				goto next_with_save;

			hr = piQry->DoQuery();
			if ( FAILED( hr ) ) {
				printf( "Do query fail: hr=%X", hr );
				exit(1);
			}

next_with_save:
		
			 printf( "%d query processed.\n", ++cCount );

			if ( g_fNeedSave )
				piReq->Save( pdispPtr );	
		
			piQry->Release();
		
//next:
			hr = piReq->ItemNext(	&pdispPtr,
									&fSuccess );


			if ( FAILED ( hr ) ) {
				printf( "Item next fail hr=%X\n", hr );

				exit(1);
			}
		}

		piReq->ItemClose();

		printf( "Item Closed\n" );

release:
		piReq->Release();

		if ( ! g_fPersist )
			break;
		
		Sleep( dwTotalMSecs );
	}

	OleUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\utest\meta2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sun Jul 20 20:01:19 1997
 */
/* Compiler settings for d:\ex\stacks\src\news\search\qrydb\meta2.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __meta2_h__
#define __meta2_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __Ireq_FWD_DEFINED__
#define __Ireq_FWD_DEFINED__
typedef interface Ireq Ireq;
#endif 	/* __Ireq_FWD_DEFINED__ */


#ifndef __req_FWD_DEFINED__
#define __req_FWD_DEFINED__

#ifdef __cplusplus
typedef class req req;
#else
typedef struct req req;
#endif /* __cplusplus */

#endif 	/* __req_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __Ireq_INTERFACE_DEFINED__
#define __Ireq_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Ireq
 * at Sun Jul 20 20:01:19 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Ireq;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("583BDCAD-E7F7-11D0-91E8-00AA00C148BE")
    Ireq : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown __RPC_FAR *piUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndPage( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE test( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_property( 
            BSTR bstrName,
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_property( 
            BSTR bstrName,
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE New( 
            IDispatch __RPC_FAR *__RPC_FAR *ppdispQry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            BSTR wszPropName,
            BSTR __RPC_FAR *pbstrVal,
            BSTR wszGuid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Write( 
            BSTR wszPropName,
            BSTR bstrVal,
            BSTR wszGuid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( 
            IDispatch __RPC_FAR *pdispQry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            BSTR wszGuid,
            IDispatch __RPC_FAR *__RPC_FAR *ppdispQry) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ItemInit( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ItemNext( 
            IDispatch __RPC_FAR *__RPC_FAR *ppdispQry,
            BOOL __RPC_FAR *fSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ItemClose( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( 
            BSTR wszGuid) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ItemX( 
            BSTR wszGuid,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NewX( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ItemNextX( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumSucceeded( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clean( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IreqVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Ireq __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Ireq __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Ireq __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Ireq __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Ireq __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Ireq __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Ireq __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPage )( 
            Ireq __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndPage )( 
            Ireq __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *test )( 
            Ireq __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_property )( 
            Ireq __RPC_FAR * This,
            BSTR bstrName,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_property )( 
            Ireq __RPC_FAR * This,
            BSTR bstrName,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )( 
            Ireq __RPC_FAR * This,
            IDispatch __RPC_FAR *__RPC_FAR *ppdispQry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            Ireq __RPC_FAR * This,
            BSTR wszPropName,
            BSTR __RPC_FAR *pbstrVal,
            BSTR wszGuid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            Ireq __RPC_FAR * This,
            BSTR wszPropName,
            BSTR bstrVal,
            BSTR wszGuid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            Ireq __RPC_FAR * This,
            IDispatch __RPC_FAR *pdispQry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            Ireq __RPC_FAR * This,
            BSTR wszGuid,
            IDispatch __RPC_FAR *__RPC_FAR *ppdispQry);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ItemInit )( 
            Ireq __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ItemNext )( 
            Ireq __RPC_FAR * This,
            IDispatch __RPC_FAR *__RPC_FAR *ppdispQry,
            BOOL __RPC_FAR *fSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ItemClose )( 
            Ireq __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            Ireq __RPC_FAR * This,
            BSTR wszGuid);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ItemX )( 
            Ireq __RPC_FAR * This,
            BSTR wszGuid,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NewX )( 
            Ireq __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ItemNextX )( 
            Ireq __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnumSucceeded )( 
            Ireq __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clean )( 
            Ireq __RPC_FAR * This);
        
        END_INTERFACE
    } IreqVtbl;

    interface Ireq
    {
        CONST_VTBL struct IreqVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Ireq_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Ireq_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Ireq_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Ireq_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Ireq_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Ireq_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Ireq_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Ireq_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define Ireq_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define Ireq_test(This)	\
    (This)->lpVtbl -> test(This)

#define Ireq_get_property(This,bstrName,pVal)	\
    (This)->lpVtbl -> get_property(This,bstrName,pVal)

#define Ireq_put_property(This,bstrName,newVal)	\
    (This)->lpVtbl -> put_property(This,bstrName,newVal)

#define Ireq_New(This,ppdispQry)	\
    (This)->lpVtbl -> New(This,ppdispQry)

#define Ireq_Read(This,wszPropName,pbstrVal,wszGuid)	\
    (This)->lpVtbl -> Read(This,wszPropName,pbstrVal,wszGuid)

#define Ireq_Write(This,wszPropName,bstrVal,wszGuid)	\
    (This)->lpVtbl -> Write(This,wszPropName,bstrVal,wszGuid)

#define Ireq_Save(This,pdispQry)	\
    (This)->lpVtbl -> Save(This,pdispQry)

#define Ireq_Item(This,wszGuid,ppdispQry)	\
    (This)->lpVtbl -> Item(This,wszGuid,ppdispQry)

#define Ireq_ItemInit(This)	\
    (This)->lpVtbl -> ItemInit(This)

#define Ireq_ItemNext(This,ppdispQry,fSuccess)	\
    (This)->lpVtbl -> ItemNext(This,ppdispQry,fSuccess)

#define Ireq_ItemClose(This)	\
    (This)->lpVtbl -> ItemClose(This)

#define Ireq_Delete(This,wszGuid)	\
    (This)->lpVtbl -> Delete(This,wszGuid)

#define Ireq_get_ItemX(This,wszGuid,pVal)	\
    (This)->lpVtbl -> get_ItemX(This,wszGuid,pVal)

#define Ireq_get_NewX(This,pVal)	\
    (This)->lpVtbl -> get_NewX(This,pVal)

#define Ireq_get_ItemNextX(This,pVal)	\
    (This)->lpVtbl -> get_ItemNextX(This,pVal)

#define Ireq_get_EnumSucceeded(This,pVal)	\
    (This)->lpVtbl -> get_EnumSucceeded(This,pVal)

#define Ireq_Clean(This)	\
    (This)->lpVtbl -> Clean(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE Ireq_OnStartPage_Proxy( 
    Ireq __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piUnk);


void __RPC_STUB Ireq_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE Ireq_OnEndPage_Proxy( 
    Ireq __RPC_FAR * This);


void __RPC_STUB Ireq_OnEndPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_test_Proxy( 
    Ireq __RPC_FAR * This);


void __RPC_STUB Ireq_test_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Ireq_get_property_Proxy( 
    Ireq __RPC_FAR * This,
    BSTR bstrName,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Ireq_get_property_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Ireq_put_property_Proxy( 
    Ireq __RPC_FAR * This,
    BSTR bstrName,
    /* [in] */ BSTR newVal);


void __RPC_STUB Ireq_put_property_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_New_Proxy( 
    Ireq __RPC_FAR * This,
    IDispatch __RPC_FAR *__RPC_FAR *ppdispQry);


void __RPC_STUB Ireq_New_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_Read_Proxy( 
    Ireq __RPC_FAR * This,
    BSTR wszPropName,
    BSTR __RPC_FAR *pbstrVal,
    BSTR wszGuid);


void __RPC_STUB Ireq_Read_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_Write_Proxy( 
    Ireq __RPC_FAR * This,
    BSTR wszPropName,
    BSTR bstrVal,
    BSTR wszGuid);


void __RPC_STUB Ireq_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_Save_Proxy( 
    Ireq __RPC_FAR * This,
    IDispatch __RPC_FAR *pdispQry);


void __RPC_STUB Ireq_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_Item_Proxy( 
    Ireq __RPC_FAR * This,
    BSTR wszGuid,
    IDispatch __RPC_FAR *__RPC_FAR *ppdispQry);


void __RPC_STUB Ireq_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_ItemInit_Proxy( 
    Ireq __RPC_FAR * This);


void __RPC_STUB Ireq_ItemInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_ItemNext_Proxy( 
    Ireq __RPC_FAR * This,
    IDispatch __RPC_FAR *__RPC_FAR *ppdispQry,
    BOOL __RPC_FAR *fSuccess);


void __RPC_STUB Ireq_ItemNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_ItemClose_Proxy( 
    Ireq __RPC_FAR * This);


void __RPC_STUB Ireq_ItemClose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_Delete_Proxy( 
    Ireq __RPC_FAR * This,
    BSTR wszGuid);


void __RPC_STUB Ireq_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Ireq_get_ItemX_Proxy( 
    Ireq __RPC_FAR * This,
    BSTR wszGuid,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal);


void __RPC_STUB Ireq_get_ItemX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Ireq_get_NewX_Proxy( 
    Ireq __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal);


void __RPC_STUB Ireq_get_NewX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Ireq_get_ItemNextX_Proxy( 
    Ireq __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pVal);


void __RPC_STUB Ireq_get_ItemNextX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Ireq_get_EnumSucceeded_Proxy( 
    Ireq __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB Ireq_get_EnumSucceeded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Ireq_Clean_Proxy( 
    Ireq __RPC_FAR * This);


void __RPC_STUB Ireq_Clean_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Ireq_INTERFACE_DEFINED__ */



#ifndef __META2Lib_LIBRARY_DEFINED__
#define __META2Lib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: META2Lib
 * at Sun Jul 20 20:01:19 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_META2Lib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_req;

class DECLSPEC_UUID("583BDCAE-E7F7-11D0-91E8-00AA00C148BE")
req;
#endif
#endif /* __META2Lib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\utest\search.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Jul 17 23:45:37 1997
 */
/* Compiler settings for search.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __search_h__
#define __search_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __Iqry_FWD_DEFINED__
#define __Iqry_FWD_DEFINED__
typedef interface Iqry Iqry;
#endif 	/* __Iqry_FWD_DEFINED__ */


#ifndef __qry_FWD_DEFINED__
#define __qry_FWD_DEFINED__

#ifdef __cplusplus
typedef class qry qry;
#else
typedef struct qry qry;
#endif /* __cplusplus */

#endif 	/* __qry_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __Iqry_INTERFACE_DEFINED__
#define __Iqry_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: Iqry
 * at Thu Jul 17 23:45:37 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_Iqry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("A5C8AA00-F17A-11D0-91F3-00AA00C148BE")
    Iqry : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown __RPC_FAR *piUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndPage( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_QueryString( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NewsGroup( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NewsGroup( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReplyMode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReplyMode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoQuery( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Load( 
            BSTR wszGuid,
            IDispatch __RPC_FAR *pdispReq,
            BOOL fNew) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Save( 
            IDispatch __RPC_FAR *pdispReq,
            BOOL fClearDirty,
            BOOL fSaveAllProperties) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message_Template( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Message_Template( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL_Template( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_URL_Template( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastDate( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LastDate( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message_File( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Message_File( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URLFile( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_URLFile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchFrequency( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SearchFrequency( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QueryID( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsBadQuery( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsBadQuery( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IqryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            Iqry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            Iqry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            Iqry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            Iqry __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            Iqry __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            Iqry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            Iqry __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnStartPage )( 
            Iqry __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEndPage )( 
            Iqry __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_QueryString )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EmailAddress )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EmailAddress )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NewsGroup )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NewsGroup )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReplyMode )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReplyMode )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoQuery )( 
            Iqry __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            Iqry __RPC_FAR * This,
            BSTR wszGuid,
            IDispatch __RPC_FAR *pdispReq,
            BOOL fNew);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            Iqry __RPC_FAR * This,
            IDispatch __RPC_FAR *pdispReq,
            BOOL fClearDirty,
            BOOL fSaveAllProperties);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Message_Template )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Message_Template )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL_Template )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL_Template )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LastDate )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LastDate )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Message_File )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Message_File )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URLFile )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URLFile )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SearchFrequency )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SearchFrequency )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryID )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBadQuery )( 
            Iqry __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_IsBadQuery )( 
            Iqry __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IqryVtbl;

    interface Iqry
    {
        CONST_VTBL struct IqryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define Iqry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define Iqry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define Iqry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define Iqry_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define Iqry_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define Iqry_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define Iqry_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define Iqry_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define Iqry_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define Iqry_get_QueryString(This,pVal)	\
    (This)->lpVtbl -> get_QueryString(This,pVal)

#define Iqry_put_QueryString(This,newVal)	\
    (This)->lpVtbl -> put_QueryString(This,newVal)

#define Iqry_get_EmailAddress(This,pVal)	\
    (This)->lpVtbl -> get_EmailAddress(This,pVal)

#define Iqry_put_EmailAddress(This,newVal)	\
    (This)->lpVtbl -> put_EmailAddress(This,newVal)

#define Iqry_get_NewsGroup(This,pVal)	\
    (This)->lpVtbl -> get_NewsGroup(This,pVal)

#define Iqry_put_NewsGroup(This,newVal)	\
    (This)->lpVtbl -> put_NewsGroup(This,newVal)

#define Iqry_get_ReplyMode(This,pVal)	\
    (This)->lpVtbl -> get_ReplyMode(This,pVal)

#define Iqry_put_ReplyMode(This,newVal)	\
    (This)->lpVtbl -> put_ReplyMode(This,newVal)

#define Iqry_DoQuery(This)	\
    (This)->lpVtbl -> DoQuery(This)

#define Iqry_Load(This,wszGuid,pdispReq,fNew)	\
    (This)->lpVtbl -> Load(This,wszGuid,pdispReq,fNew)

#define Iqry_Save(This,pdispReq,fClearDirty,fSaveAllProperties)	\
    (This)->lpVtbl -> Save(This,pdispReq,fClearDirty,fSaveAllProperties)

#define Iqry_get_Message_Template(This,pVal)	\
    (This)->lpVtbl -> get_Message_Template(This,pVal)

#define Iqry_put_Message_Template(This,newVal)	\
    (This)->lpVtbl -> put_Message_Template(This,newVal)

#define Iqry_get_URL_Template(This,pVal)	\
    (This)->lpVtbl -> get_URL_Template(This,pVal)

#define Iqry_put_URL_Template(This,newVal)	\
    (This)->lpVtbl -> put_URL_Template(This,newVal)

#define Iqry_get_LastDate(This,pVal)	\
    (This)->lpVtbl -> get_LastDate(This,pVal)

#define Iqry_put_LastDate(This,newVal)	\
    (This)->lpVtbl -> put_LastDate(This,newVal)

#define Iqry_get_Message_File(This,pVal)	\
    (This)->lpVtbl -> get_Message_File(This,pVal)

#define Iqry_put_Message_File(This,newVal)	\
    (This)->lpVtbl -> put_Message_File(This,newVal)

#define Iqry_get_URLFile(This,pVal)	\
    (This)->lpVtbl -> get_URLFile(This,pVal)

#define Iqry_put_URLFile(This,newVal)	\
    (This)->lpVtbl -> put_URLFile(This,newVal)

#define Iqry_get_SearchFrequency(This,pVal)	\
    (This)->lpVtbl -> get_SearchFrequency(This,pVal)

#define Iqry_put_SearchFrequency(This,newVal)	\
    (This)->lpVtbl -> put_SearchFrequency(This,newVal)

#define Iqry_get_QueryID(This,pVal)	\
    (This)->lpVtbl -> get_QueryID(This,pVal)

#define Iqry_get_IsBadQuery(This,pVal)	\
    (This)->lpVtbl -> get_IsBadQuery(This,pVal)

#define Iqry_put_IsBadQuery(This,newVal)	\
    (This)->lpVtbl -> put_IsBadQuery(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE Iqry_OnStartPage_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *piUnk);


void __RPC_STUB Iqry_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE Iqry_OnEndPage_Proxy( 
    Iqry __RPC_FAR * This);


void __RPC_STUB Iqry_OnEndPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_QueryString_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_QueryString_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_EmailAddress_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_EmailAddress_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_EmailAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_NewsGroup_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_NewsGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_NewsGroup_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_NewsGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_ReplyMode_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_ReplyMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_ReplyMode_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_ReplyMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Iqry_DoQuery_Proxy( 
    Iqry __RPC_FAR * This);


void __RPC_STUB Iqry_DoQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Iqry_Load_Proxy( 
    Iqry __RPC_FAR * This,
    BSTR wszGuid,
    IDispatch __RPC_FAR *pdispReq,
    BOOL fNew);


void __RPC_STUB Iqry_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Iqry_Save_Proxy( 
    Iqry __RPC_FAR * This,
    IDispatch __RPC_FAR *pdispReq,
    BOOL fClearDirty,
    BOOL fSaveAllProperties);


void __RPC_STUB Iqry_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_Message_Template_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_Message_Template_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_Message_Template_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_Message_Template_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_URL_Template_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_URL_Template_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_URL_Template_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_URL_Template_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_LastDate_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_LastDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_LastDate_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_LastDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_Message_File_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_Message_File_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_Message_File_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_Message_File_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_URLFile_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_URLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_URLFile_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_URLFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_SearchFrequency_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_SearchFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_SearchFrequency_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_SearchFrequency_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_QueryID_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_QueryID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE Iqry_get_IsBadQuery_Proxy( 
    Iqry __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB Iqry_get_IsBadQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE Iqry_put_IsBadQuery_Proxy( 
    Iqry __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB Iqry_put_IsBadQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __Iqry_INTERFACE_DEFINED__ */



#ifndef __SEARCHLib_LIBRARY_DEFINED__
#define __SEARCHLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: SEARCHLib
 * at Thu Jul 17 23:45:37 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_SEARCHLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_qry;

class DECLSPEC_UUID("A5C8AA01-F17A-11D0-91F3-00AA00C148BE")
qry;
#endif
#endif /* __SEARCHLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\search\utest\search_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Jul 17 23:45:37 1997
 */
/* Compiler settings for search.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_Iqry = {0xA5C8AA00,0xF17A,0x11D0,{0x91,0xF3,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


const IID LIBID_SEARCHLib = {0xA5C8A9F3,0xF17A,0x11D0,{0x91,0xF3,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


const CLSID CLSID_qry = {0xA5C8AA01,0xF17A,0x11D0,{0x91,0xF3,0x00,0xAA,0x00,0xC1,0x48,0xBE}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\sources.inc ===
!INCLUDE $(INETROOT)\build\paths.all

MAJORCOMP=news
MINORCOMP=nntpsvc

TARGETNAME=nntpsvc
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup
DLLBASE=$(DEFBASEADDR)
DLLDEF=..\nntpsvc.def

#USER_C_FLAGS=/D_NO_TEMPLATES_

DBGINCLUDES=..\..\inc;\
	$(EXTINCPATH)\iis.40;

INCLUDES= ..\..;\
	..;\
	$(EXTINCPATH)\iis.40;\
	$(LOCALTARGET);\
	$(LOCALROOT)\core\include;

USE_TRACING=1

TARGETLIBS=   \
        $(DEFAULTLIBS) \
        $(EXTLIBPATH)\iis.40\infocomm.lib   \
        $(EXTLIBPATH)\iis.40\isatq.lib   \
        $(EXTLIBPATH)\iis.40\metadata.lib   \
        $(EXTLIBPATH)\iis.40\coadmin.lib   \
        $(SDKLIBPATH)\ntdll.lib     \
        $(SDKLIBPATH)\netlib.lib    \
        $(SDKLIBPATH)\rpcrt4.lib    \
        $(SDKLIBPATH)\security.lib  \
        $(SDKLIBPATH)\lsadll.lib  \
        $(SDKLIBPATH)\version.lib  \
        $(CORELIBPATH)\shuttle.lib  \
        $(CORELIBPATH)\iruuid.lib \
        $(CORELIBPATH)\simauth2.lib \
        $(CORELIBPATH)\simssl.lib \
        $(CORELIBPATH)\tbombsrv.lib \
        $(CORELIBPATH)\thrdpool.lib  \
		$(LOCALLIBPATH)\nntpsrch.lib \
		$(LOCALLIBPATH)\isrpc.lib \
		$(LOCALLIBPATH)\xoverlib.lib \
		$(LOCALLIBPATH)\nntphash.lib \
		$(LOCALLIBPATH)\dirnot.lib \
        $(CORELIBPATH)\hashmap.lib \
		$(CORELIBPATH)\cachelib.lib \
		$(CORELIBPATH)\rw.lib \
		$(LOCALLIBPATH)\rootscan.lib \
		$(SDKLIBPATH)\ole32.lib \
		$(SDKLIBPATH)\oleaut32.lib \
		$(SDKLIBPATH)\uuid.lib \
        $(DEFAULTLIBS)

SOURCES=  \
        ..\nntpsvc2.rc \
        ..\article.cpp \
        ..\nntpsupp.cpp \
        ..\cio.cpp \
        ..\commands.cpp \
        ..\cservic.cpp \
        ..\expire.cpp \
        ..\feedmgr.cpp \
        ..\feedq.cpp    \
        ..\fromclnt.cpp \
        ..\frommstr.cpp \
        ..\frompeer.cpp \
        ..\grpiter.cpp \
        ..\infeed.cpp \
        ..\io.cpp \
        ..\lockq.cpp \
        ..\mapfile.cpp \
        ..\newsgrp.cpp \
        ..\newstree.cpp \
        ..\connect.cxx \
        ..\nntpdata.cpp \
        ..\main.cxx  \
        ..\nntpret.cpp \
        ..\nntpstr.cpp \
        ..\nntpsvc_s.c  \
        ..\outfeed.cpp \
        ..\packet.cpp \
        ..\passthru.cpp \
        ..\pcparse.cpp \
        ..\pcstring.cpp \
        ..\queue.cpp \
        ..\resource.c   \
        ..\sfromcl.cpp \
        ..\socket.cpp \
        ..\state.cpp \
        ..\svcadm.cpp \
        ..\svcfeeds.cpp \
        ..\svcsess.cpp \
        ..\svcsupp.cpp \
        ..\svcstat.cpp  \
        ..\tigmem.cpp \
        ..\timeconv.cpp \
        ..\toclient.cpp \
        ..\newwild.cpp  \
        ..\gcache.cpp \
        ..\svcxpire.cpp \
        ..\svcgroup.cpp \
        ..\datetime.cxx \
        ..\boot.cpp \
        ..\rebuild.cpp \
        ..\ir.cpp \
        ..\persistc.cpp \
        ..\smtpcli.cpp \
        ..\smtpdll.cpp \
        ..\addon.cpp \
        ..\nntpinst.cxx \
        ..\rpcex.cxx \
        ..\iisnntp.cxx \
        ..\svcbuild.cpp

SOURCES_USED=..\SOURCES.INC

PRECOMPILED_INCLUDE=..\tigris.hxx
PRECOMPILED_PCH=tigris.pch
PRECOMPILED_OBJ=tigris.obj

NTTARGETFILE0=..\nntpmsg.h \
              .\nntpmsg.rc \
              .\msg00001.bin

!INCLUDE $(INETROOT)\build\sources.all
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\globals.cpp ===
#include "stdinc.h"

#define DEF_EXPIRE_INTERVAL (3 * SEC_PER_WEEK)
DWORD numField = 0;
DWORD numPCString = 0;
DWORD numDateField = 0;
DWORD numFromPeerArt = 0;
DWORD ArticleTimeLimitSeconds = DEF_EXPIRE_INTERVAL + SEC_PER_WEEK;
DWORD numArticle = 0;
DWORD numPCParse = 0;
DWORD numMapFile = 0;

DEBUG_PRINTS *g_pDebug;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\artcore.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    artcore.cpp

Abstract:

    This module contains definition for the CArticleCore base class.

	This class provides basic, general tools to parse and edit a
	Netnews articles.

	The basic idea is to map the files containing the articles and
	then to record the location of parts of the articles with CPCStrings.
	A CPCString is just a pointer (usually into the mapped file) and a length.

Author:

    Carl Kadie (CarlK)     06-Oct-1995

Revision History:

--*/

#ifdef	_NO_TEMPLATES_
#define	DEFINE_CGROUPLST_FUNCTIONS
#endif

#include "stdinc.h"
#include <artcore.h>
#include    <stdlib.h>

//
// externs
//
extern BOOL    g_fBackFillLines;

//
// CPool is used to allocate memory while processing an article.
//

CPool*  CArticleCore::g_pArticlePool;

const	unsigned	cbMAX_ARTCORE_SIZE = MAX_ARTCORE_SIZE ;

//
// Some function prototypes
//

// Does most of the work of testing a newsgroup name for legal values.
BOOL fTestComponentsInternal(
			 const char * szNewsgroups,
			 CPCString & pcNewsgroups
			);


BOOL
AgeCheck(	CPCString	pcDate ) {

	//
	//	This function will be used to determine whether an article is
	//	to old for the server to take.  In case of error return TRUE
	//	so that we take the article anyways !
	//

	extern	BOOL
		StringTimeToFileTime(
			IN  const TCHAR * pszTime,
			OUT LARGE_INTEGER * pliTime
			) ;

	extern	BOOL
		ConvertAsciiTime( char*	pszTime,	FILETIME&	filetime ) ;


	char	szDate[512] ;

	if( pcDate.m_cch > sizeof( szDate )-1 ) {
		return	TRUE ;
	}
	
	CopyMemory( szDate, pcDate.m_pch, pcDate.m_cch ) ;
	//
	//	Null terminate
	//
	szDate[pcDate.m_cch] = '\0' ;

	LARGE_INTEGER	liTime ;
	FILETIME		filetime ;

	if( ConvertAsciiTime( szDate, filetime ) ) {

		liTime.LowPart = filetime.dwLowDateTime ;
		liTime.HighPart = filetime.dwHighDateTime ;

	}	else	if( !StringTimeToFileTime( szDate, &liTime ) ) {

		//
		//	Could not convert the time so accept the article !!
		//

		return	TRUE ;

	}


	FILETIME	filetimeNow ;

	GetSystemTimeAsFileTime( &filetimeNow ) ;

	LARGE_INTEGER	liTimeNow ;
	liTimeNow.LowPart = filetimeNow.dwLowDateTime ;
	liTimeNow.HighPart = filetimeNow.dwHighDateTime ;

	if( liTime.QuadPart > liTimeNow.QuadPart )	{
		return	TRUE ;
	}	else	{

		LARGE_INTEGER	liDiff ;
		liDiff.QuadPart = liTimeNow.QuadPart - liTime.QuadPart ;		

		LARGE_INTEGER	liExpire ;
		liExpire.QuadPart = ArticleTimeLimitSeconds  ;
		liExpire.QuadPart += (24 * 60 * 60 * 2) ;	// fudge by 2 days !
		liExpire.QuadPart *= 10 * 1000 * 1000 ;		// convert seconds to 100th of Nanoseconds.

		if( liDiff.QuadPart > liExpire.QuadPart )
			return	FALSE ;
	}
	
	return	TRUE ;
}


BOOL
CArticleCore::InitClass(
					void
					)
/*++

Routine Description:

    Preallocates memory for CArticle objects

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
    g_pArticlePool = new CPool( ARTCORE_SIGNATURE );
    if (g_pArticlePool == NULL)
    	return FALSE;

	return	g_pArticlePool->ReserveMemory( MAX_ARTICLES, cbMAX_ARTCORE_SIZE ) ;	
}


BOOL
CArticleCore::TermClass(
					void
					)
/*++

Routine Description:

    Called when objects are freed.

Arguments:

    None.

Return Value:

    TRUE

--*/
{

	_ASSERT( g_pArticlePool->GetAllocCount() == 0 ) ;

	BOOL b;
	
	b =	g_pArticlePool->ReleaseMemory() ;
    delete g_pArticlePool;
    return b;

}


CArticleCore::CArticleCore(
                void
                ):
/*++

Routine Description:

    Class Constructor. Does nothing except initial member variables.

Arguments:

    None.

Return Value:

    TRUE

--*/
	m_hFile(INVALID_HANDLE_VALUE),
	//m_pOpenFile( 0 ),
	//m_pInstance( NULL ),
	m_cHeaders(0),
	m_articleState(asUninitialized),
	m_pHeaderBuffer( 0 ),
	m_pMapFile( 0 ),
	m_CacheCreateFile( TRUE )
{
   m_szFilename = 0 ;
   numArticle++;

} // CArticleCore

	
	
CArticleCore::~CArticleCore(
                    void
                    )
/*++

Routine Description:

    Class destructor

Arguments:

    None.

Return Value:

    None

--*/
{

    //
    // Be sure the file is closed
    //

	if( m_pHeaderBuffer ) {
							
		m_pAllocator->Free(m_pHeaderBuffer);
		m_pHeaderBuffer = 0 ;

	}

	if (m_pMapFile)
	{
		XDELETE	m_pMapFile ;//!!!mem
		m_pMapFile = NULL ;
	}

	//
	// If file handle is open and it's not in the cache, close it
	//

	if( m_hFile != INVALID_HANDLE_VALUE &&
	    !m_CacheCreateFile.m_pFIOContext )
	{
		BOOL	fSuccess = ArtCloseHandle(
												m_hFile
												//m_pOpenFile
												) ;

		_ASSERT( fSuccess ) ;
	}

	//
	//!!!COMMENT May want to make this a function so that
	// m_pMapFile can be make private.

    numArticle--;

}



void
CArticleCore::vClose(
					 void
					 )
/*++

Routine Description:

    Close the file mapping and handle (if any)  of the article's file.

Arguments:

    None

Return Value:

    None

--*/
{

	//
	// We shouldn't be calling this unless it is open
	//

	if (m_pMapFile)
	{
		XDELETE	m_pMapFile ;//!!!MEM
		m_pMapFile = NULL ;
	}

	//
	// If file handle is open, close it
	//

	if( m_hFile != INVALID_HANDLE_VALUE )
	{
		// bugbug ... clean up this debug code some time

		BOOL	fSuccess = ArtCloseHandle(
												m_hFile
												//m_pOpenFile
												) ;
		DWORD	dw = GetLastError() ;
		_ASSERT( fSuccess ) ;

#ifdef	DEBUG
		_ASSERT( ValidateFileBytes( m_szFilename ) );
#endif

	}

}


void
CArticleCore::vCloseIfOpen (
					 void
					 )
/*++

Routine Description:

    If the mapping and handle are open,
	close them.

Arguments:

    None

Return Value:

    None

--*/
{

	//
	// We shouldn't be calling this unless it is open
	//

	// The mapping and the handle should agree.
	//_ASSERT((INVALID_HANDLE_VALUE == m_hFile) == (NULL == m_pMapFile));

	if(m_pMapFile)
		vClose();


}

void
CArticleCore::vFlush(	
				void	
				)
/*++

Routine Description :

	This function ensures that all of our file mapping bytes are written to
	the harddisk.

Arguments :

	None.

Return Value :

	None.

--*/
{

	if(	m_pMapFile ) {

		DWORD	cb = 0 ;
		LPVOID	lpv = m_pMapFile->pvAddress(	&cb	) ;
		if( lpv != 0 ) {
			BOOL	fSuccess = FlushViewOfFile(	lpv, cb ) ;
			_ASSERT( fSuccess ) ;
			_ASSERT( memcmp( ((BYTE*)lpv)+cb-5, "\r\n.\r\n", 5 ) == 0 ) ;
		}
	}
}

BOOL
CArticleCore::fInit(
				char*	pchHead,
				DWORD	cbHead,
				DWORD	cbArticle,
				DWORD	cbBufferTotal,
				CAllocator*	pAllocator,
				//PNNTP_SERVER_INSTANCE pInstance,
				CNntpReturn&	nntpReturn
				)	{

	m_articleState = asInitialized ;
	//m_pInstance = pInstance ;

	m_szFilename = 0 ;
	m_hFile = INVALID_HANDLE_VALUE ;
	//m_pOpenFile = 0 ;
	m_pAllocator = pAllocator ;
	m_pcGap.m_cch = 0 ;

	m_pMapFile = 0 ;

	m_pcFile.m_pch = pchHead ;
	m_pcFile.m_cch = cbBufferTotal ;
	m_pcGap.m_pch = m_pcFile.m_pch ;

	m_pcArticle.m_pch = m_pcFile.m_pch ;
	m_pcArticle.m_cch = cbArticle ;

	m_pcHeader.m_pch = pchHead ;
	m_pcHeader.m_cch = cbHead ;

	m_ibBodyOffset = cbHead - 2 ;

	_ASSERT( strncmp( m_pcArticle.m_pch + m_ibBodyOffset, "\r\n", 2 ) == 0 ) ;

	if( !fPreParse(nntpReturn))
		return	FALSE;

	return	TRUE ;
}


BOOL
CArticleCore::fInit(
				char*	pchHead,
				DWORD	cbHead,
				DWORD	cbArticle,
				DWORD	cbBufferTotal,
				HANDLE	hFile,
				LPSTR	lpstrFileName,
				DWORD	ibHeadOffset,
				CAllocator*	pAllocator,
				//PNNTP_SERVER_INSTANCE pInstance,
				CNntpReturn&	nntpReturn
				)	{

	m_articleState = asInitialized ;
	//m_pInstance = pInstance ;
	
	m_szFilename = lpstrFileName ;
	m_hFile = hFile ;
	//m_pOpenFile = 0 ;
	m_pAllocator = pAllocator ;
	m_pcGap.m_cch = ibHeadOffset ;

	m_pMapFile = 0 ;

	m_pcFile.m_pch = 0 ;
	m_pcFile.m_cch = cbArticle + ibHeadOffset ;
	m_pcGap.m_pch = 0 ;

	m_pcArticle.m_pch = pchHead ;
	m_pcArticle.m_cch = cbArticle ;

	m_pcHeader.m_pch = pchHead ;
	m_pcHeader.m_cch = cbHead ;

	m_ibBodyOffset = cbHead - 2 + ibHeadOffset ;

	//
	//	Verify our arguments !!!
	//
	
#ifdef	DEBUG

	BY_HANDLE_FILE_INFORMATION	fileinfo ;
	if( !GetFileInformationByHandle( hFile, &fileinfo ) ) {

		_ASSERT( 1==0 ) ;

	}	else	{

		_ASSERT( fileinfo.nFileSizeLow == ibHeadOffset + cbArticle ) ;

		CMapFile	map( hFile, FALSE, FALSE, 0 ) ;

		if( !map.fGood() ) {

			//_ASSERT( 1==0 ) ;

		}	else	{
			DWORD	cb ;
			char*	pch = (char*)map.pvAddress( &cb ) ;

			_ASSERT( cb == ibHeadOffset + cbArticle ) ;
			_ASSERT( strncmp( pch + ibHeadOffset + cbHead - 4, "\r\n\r\n", 4 ) == 0 ) ;
			_ASSERT( strncmp( pch + ibHeadOffset + cbArticle - 5, "\r\n.\r\n", 5 ) == 0 ) ;
			_ASSERT( strncmp( pch + m_ibBodyOffset, "\r\n", 2 ) == 0 ) ;
		}
	}
#endif

	if( !fPreParse(nntpReturn))
		return	FALSE;

	_ASSERT( cbHead-2 == m_pcHeader.m_cch ) ;

	return	TRUE ;
}

BOOL
CArticleCore::fInit(
			  const char * szFilename,
  			  CNntpReturn & nntpReturn,
  			  CAllocator * pAllocator,
			  HANDLE hFile,
			  DWORD	cBytesGapSize,
			  BOOL fCacheCreate
	  )

/*++

Routine Description:

    Initialize from a file handle - used on incoming files

Arguments:

	szFilename - The name of the file containing the article
	nntpReturn - The return value for this function call
	hFile - A file handle to an Netnews article
	cBytesGapSize - The number of bytes in the file before the article starts
	pAllocator	- the object that handle memory allocations while article processing.

Return Value:

    TRUE, if and only if process succeeded.

--*/
{
    //
    // Determine if we want mapfile to do cache create
    //
    CCreateFile *pCreateFile = fCacheCreate ? &m_CacheCreateFile : NULL;

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Set article state
	//

	//_ASSERT(asUninitialized == m_articleState);
	m_articleState = asInitialized;
	//m_pInstance = pInstance ;

    //
    // Set membership variables
    //

	m_szFilename = (char*)szFilename ;
	m_hFile = hFile;
	//m_pOpenFile = pOpenFile ;
	m_pcGap.m_cch = cBytesGapSize;
	m_pAllocator = pAllocator;



#ifdef	DEBUG
				_ASSERT( ValidateFileBytes( (char *) szFilename, FALSE ) );
#endif

	//
    // Map the file.
    //

	m_pMapFile = XNEW CMapFile(m_szFilename, m_hFile, fReadWrite(),0, pCreateFile);//!!!MEM now

	if (!m_pMapFile || !m_pMapFile->fGood())
	{
		if (m_pMapFile)	{
			XDELETE m_pMapFile;//!!!mem
			m_pMapFile = 0 ;
		}
		return nntpReturn.fSet(nrcArticleMappingFailed, m_szFilename, GetLastError());
	}
	

	//
	// Set the file, gap, and article PC (pointer/count) strings.
	//

	m_pcFile.m_pch = (char *) m_pMapFile->pvAddress( &(m_pcFile.m_cch) );
	m_pcGap.m_pch = m_pcFile.m_pch; //length set in init

	//
	// If the length of the gap size is not known, determine it from the file itself
	//

	if (cchUnknownGapSize == m_pcGap.m_cch)
	{
		vGapRead();
	}

	m_pcArticle.m_pch = m_pcFile.m_pch + m_pcGap.m_cch;
	m_pcArticle.fSetCch(m_pcFile.pchMax());	
	
	//
	// Preparse the file (meaning find where the header, body, and fields are.)
	//
	

	if (!fPreParse(nntpReturn))
		return nntpReturn.fFalse();

	m_ibBodyOffset = (DWORD)(m_pcBody.m_pch - m_pcFile.m_pch) ;

	return nntpReturn.fSetOK();
}



BOOL
CArticleCore::fPreParse(
					CNntpReturn & nntpReturn
					)
/*++

Routine Description:

    Find where the header, body, and fields are.
	Results for the fields is an array of structure in which
	each structure points to the parts of each field.

Arguments:

	nntpReturn - The return value for this function call
	pchMax -

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//

	_ASSERT(asInitialized == m_articleState); //real
	m_articleState = asPreParsed;


	//
	// Create a pointer to the first address past the end of the article
	//

	char * pchMax = m_pcArticle.pchMax();

	//
	//	Some versions of fInit() our able to setup m_pcHeader based on IO buffers
	//	which captured the head of the article - make sure we remain within these if
	//	this is setup !
	//

	if( m_pcHeader.m_pch != 0 &&
		m_pcHeader.m_cch != 0 ) {

		_ASSERT( m_pcHeader.m_pch == m_pcArticle.m_pch ) ;

		pchMax = m_pcHeader.pchMax() ;
	}

	//
	// (re)initialize the list of header strings
	//

	m_cHeaders = 0;

	//
	// record where the header starts
	//

	m_pcHeader.m_pch = m_pcArticle.m_pch;
	m_pcHeader.m_cch = 0 ;

	//
	// Loop while there is data and the next field
	// doesn't start with a new line.
	//

	char * pchCurrent = m_pcArticle.m_pch;
	while( pchCurrent < pchMax && !fNewLine(pchCurrent[0]))
	{
		if (!fAddInternal(pchCurrent, pchMax, TRUE, nntpReturn))
			return nntpReturn.fFalse();
	}

	//
	// _ASSERT that the length of the header (as measured with the running total)
	// is correct.
	//
	_ASSERT((signed)  m_pcHeader.m_cch == (pchCurrent - m_pcHeader.m_pch));

	//
	// Check that there is at least one header line
	//

	if (0 == m_cHeaders)
		return nntpReturn.fSet(nrcArticleMissingHeader);

	//
	// Record the body's start and length
	//

	m_pcBody.m_pch = pchCurrent;
	m_pcBody.fSetCch(m_pcArticle.pchMax());


	//
	// Check that the body is not too long.
	//

	if (!fCheckBodyLength(nntpReturn))
		return nntpReturn.fFalse();

	return nntpReturn.fSetOK();
}

BOOL
CArticleCore::fGetHeader(
				LPSTR	szHeader,
				BYTE*	lpb,
				DWORD	cbSize,
				DWORD&	cbOut ) {

	cbOut = 0 ;

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	DWORD cbHeaderLen = lstrlen( szHeader );
	for (phs = m_rgHeaders;
			phs < phsMax;
			phs++)
	{
		//if ((phs->pcKeyword).fEqualIgnoringCase(szHeader))

		//if( _strnicmp( phs->pcKeyword.m_pch, szHeader, phs->pcKeyword.m_cch - 1 ) == 0 )
		if( (!phs->fRemoved) && (phs->pcKeyword.m_cch >= cbHeaderLen) &&  _strnicmp( phs->pcKeyword.m_pch, szHeader,  cbHeaderLen ) == 0 )
		{
			cbOut = (phs->pcValue).m_cch + 2 ;
			if( cbOut < cbSize ) {
				CopyMemory( lpb, (phs->pcValue).m_pch, cbOut-2) ;
				lpb[cbOut-2] = '\r' ;
				lpb[cbOut-1] = '\n' ;
				return	TRUE ;
			}	else	{
				SetLastError( ERROR_INSUFFICIENT_BUFFER ) ;
				return	FALSE ;
			}
		}

	}
	SetLastError( ERROR_INVALID_NAME ) ;
	return	FALSE ;
}				



BOOL
CArticleCore::fRemoveAny(
				  const char * szKeyword,
				  CNntpReturn & nntpReturn
				  )
/*++

Routine Description:

  Removes every occurance of a type of header (e.g. every "XRef:" header).

Arguments:

	szKeyword - The keyword to remove.
	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//

	_ASSERT(asPreParsed == m_articleState
			|| asModified == m_articleState);//real
	m_articleState = asModified;

	//
	// Loop though the array of header information
	// removing matches.
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	for (phs = m_rgHeaders;
			phs < phsMax;
			phs++)
	{
		if ((phs->pcKeyword).fEqualIgnoringCase(szKeyword))
		{
			_ASSERT(TRUE == phs->fInFile); //real
			vRemoveLine(phs);
		}

	}

	
	return nntpReturn.fSetOK();
	
}

void
CArticleCore::vRemoveLine(
					  HEADERS_STRINGS * phs
					  )
/*++

Routine Description:

  Removes an item from the array of header info.

Arguments:

	phs - a pointer to an item in the array

Return Value:

    None

--*/
{
	if (!phs->fRemoved)
	{
		//
		// Make the item as removed
		//

		phs->fRemoved = TRUE;

		//
		// Adjust the size of the article and header.
		//

		m_pcArticle.m_pch = NULL;
		m_pcArticle.m_cch -= phs->pcLine.m_cch;
		m_pcHeader.m_pch = NULL;
		m_pcHeader.m_cch -= phs->pcLine.m_cch;
	}
}

BOOL
CArticleCore::fAdd(
			   char * pchCurrent,
			   const char * pchMax,
			   CNntpReturn & nntpReturn
			   )
/*++

Routine Description:

  Adds text to the header.

Arguments:

	pchCurrent - A pointer to a dynamically-allocated string buffer
	pchMax	- A pointer to one past the end of that string
	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Just like fAddInternal except that pchCurrent is call-by-value
	//

	return fAddInternal(pchCurrent, pchMax, FALSE, nntpReturn);
}


BOOL
CArticleCore::fAddInternal(
			   char * & pchCurrent,
			   const char * pchMax,
			   BOOL fInFile,
			   CNntpReturn & nntpReturn
			   )
/*++

Routine Description:

  Adds text to the header.

Arguments:

	pchCurrent - A pointer to a string buffer
	pchMax	- A pointer to one past the end of that string
	fInFile - True, if and only the string buffer is in a mapped file
	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{
    TraceFunctEnter("CArticleCore::fAddInternal");

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Set the article's state
	//

	if (fInFile)
	{
		_ASSERT((asPreParsed == m_articleState)
			|| asModified == m_articleState);//real
	} else {
		_ASSERT((asPreParsed == m_articleState)
			|| asModified == m_articleState);//real
		m_articleState = asModified;
	}

	//
	// Check that there is a slot available in the header array.
	//

	if (uMaxFields <= m_cHeaders)
	{
		return nntpReturn.fSet(nrcArticleTooManyFields, m_cHeaders);
	}

	//
	// Create a pointer to the next slot in the header array
	//

	HEADERS_STRINGS * phs = &m_rgHeaders[m_cHeaders];

	//
	// Record whether the string buffer is dynamic or in a mapped file.
	//

	phs->fInFile = fInFile;

	//
	// Set that this field as not been removed
	//

	phs->fRemoved = FALSE;

	//
	// Record where the keyword and line start
	//

	phs->pcKeyword.m_pch = pchCurrent;
	phs->pcLine.m_pch = pchCurrent;
	
	//
	// Look for ":" and record it
	//

	for (;
			(pchCurrent < pchMax) && !fCharInSet(pchCurrent[0], ": \t\n\0");
			pchCurrent++)
			{};

	//
	// we should not be at the end and the character should be a ":"
	//

	if(!((pchCurrent < pchMax) && ':' == pchCurrent[0]))
	{
		nntpReturn.fSet(nrcArticleIncompleteHeader);
		ErrorTrace((DWORD_PTR) this, "%d, %s", nntpReturn.m_nrc, nntpReturn.szReturn());
		return nntpReturn.fFalse();
	}
	
	//
	// move current to the character following the ":"
	//

	pchCurrent++;
	phs->pcKeyword.m_cch = (DWORD)(pchCurrent - phs->pcKeyword.m_pch);

    // Avoid this check for INN-compatibility
	char chBad;
	if (!phs->pcKeyword.fCheckTextOrSpace(chBad))
		return nntpReturn.fSet(nrcArticleBadChar,  (BYTE) chBad, "header");

	//
	// Check for end-of-file and illegal an illegal character
	//

	if (pchCurrent >= pchMax)
		nntpReturn.fSet(nrcArticleIncompleteHeader);

	if (!fCheckFieldFollowCharacter(*pchCurrent))
	{
		const DWORD cMaxBuf = 50;
		char szKeyword[cMaxBuf];
		(phs->pcKeyword).vCopyToSz(szKeyword, cMaxBuf);
		nntpReturn.fSet(nrcArticleBadFieldFollowChar, szKeyword);
		ErrorTrace((DWORD_PTR) this, "%d, %s", nntpReturn.m_nrc, nntpReturn.szReturn());
		return nntpReturn.fFalse();
	}


	//
	// Look for end of white space
	//

	for (; (pchCurrent < pchMax) && fWhitespaceNull(pchCurrent[0]); pchCurrent++);

	phs->pcValue.m_pch = pchCurrent;


	//
	// Find the end of this item - it may be several lines long.
	//

	for(; pchCurrent < pchMax && '\0' != pchCurrent[0]; pchCurrent++ )
	{
		if( pchCurrent[0] == '\n' )
		{
			//
			// Continues if next char is white space (unless this is the end of the header)
			//

			if(pchCurrent+1 >= pchMax || !fWhitespaceNull(pchCurrent[1]))
			{
				//
				//   Hit the end,  so get out now.
				//

				pchCurrent++;		// Include the \n too.
				break;
			}
		}
	}

	//
	// The line to add should end in a \n
	//

	if((phs->pcLine.m_pch >= pchCurrent) || ('\n' != *(pchCurrent-1)))
	{
		const DWORD cMaxBuf = 50;
		char szLine[cMaxBuf];
		(phs->pcLine).vCopyToSz(szLine, cMaxBuf);
		nntpReturn.fSet(nrcArticleAddLineBadEnding, szLine);
		ErrorTrace((DWORD_PTR) this, "%d, %s", nntpReturn.m_nrc, nntpReturn.szReturn());
		return nntpReturn.fFalse();
	}

		
	//
	// Line string includes end of line.
	//

	phs->pcLine.fSetCch(pchCurrent);

	//
	// Value string does not include end of line, so trim it.
	//

	phs->pcValue.fSetCch(pchCurrent);
	phs->pcValue.dwTrimEnd(szNLChars);

	//
	// Adjust the size of the header
	//

	m_pcHeader.m_cch += phs->pcLine.m_cch;

	//
	// Adjust the size of the article
	//

	if (!fInFile)
	{
		m_pcArticle.m_cch += phs->pcLine.m_cch;
		m_pcArticle.m_pch = NULL;
		m_pcHeader.m_pch = NULL;

	}

	//
	// Increment the count in the array of headers.
	//

	m_cHeaders++;

    TraceFunctLeave();

	return nntpReturn.fSetOK();

}




BOOL
CArticleCore::fFindOneAndOnly(
			  const char * szKeyword,
			  HEADERS_STRINGS * & pHeaderString,
			  CNntpReturn & nntpReturn
						  )
/*++

Routine Description:

  Finds the one and only occurance of a field in the headers.
  If there is more than one, it returns an error.

Arguments:

	szKeyword - The keyword to remove.
	pHeaderString - a pointer to the field's keyword, value, and line.
	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//
	_ASSERT((asPreParsed == m_articleState)||(asSaved == m_articleState));//real


	//
	// Loop through the array of header data.
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phsTemp;
	pHeaderString = NULL;

	for (phsTemp = m_rgHeaders;
			phsTemp < phsMax;
			phsTemp++)
	{
		if ((phsTemp->pcKeyword).fEqualIgnoringCase(szKeyword)
			&& !phsTemp->fRemoved)
		{
			if (pHeaderString)
			{
				nntpReturn.fSetEx(nrcArticleTooManyFieldOccurances, szKeyword);
				return FALSE;
			} else {
				pHeaderString = phsTemp;
			}
		}

	}

	if (!pHeaderString)
		return nntpReturn.fSetEx(nrcArticleMissingField, szKeyword);
	
	return nntpReturn.fSetOK();
	
}


BOOL
CArticleCore::fDeleteEmptyHeader(
					  CNntpReturn & nntpReturn
						  )
/*++

Routine Description:

  Removes every valueless field from the headers.

Arguments:

	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//

	_ASSERT((asPreParsed == m_articleState) || (asModified == m_articleState));//real



	//
	// Loop through the array of header data.
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	
	for (phs = m_rgHeaders;
			phs < phsMax;
			phs++)
	{

		//
		//!!!CLIENT LATER -- should we assert if the line is not infile?
		//
		
		//
		// If the line has not already been remove and its value has zero length
		// then remove it.
		//

		if (0 == phs->pcValue.m_cch)
			vRemoveLine(phs);
	}
	
	return nntpReturn.fSetOK();
	
}

BOOL
CArticleCore::fGetBody(
		CMapFile * & pMapFile,
        char * & pchMappedFile,
		DWORD & dwLength
		)
/*++

Routine Description:

	Returns the body of the article.
	If article is cached, return pointers to the i/o buffers else
	map the file containing the article

Arguments:

	pMapFile - Returns the pointer to the mapped file (if mapping is needed)
	******** NOTE: It is the responsibility of the caller to delete this **********

	pchMappedFile - Returns the pointer to the article's body
	dwLength - Returns the length of the body.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	// hopefully we dont have to map the article !
	pMapFile = NULL;

	if( fIsArticleCached() ) {

		if( m_pHeaderBuffer ) {

			// Skip over the new line
			pchMappedFile = (m_pcBody.m_pch + 2);
			dwLength = m_pcBody.m_cch - 2;

		}	else	{

			// Skip over the new line
			_ASSERT( m_ibBodyOffset );
			pchMappedFile = (m_pcArticle.m_pch + m_ibBodyOffset + 2);
			dwLength = m_pcArticle.m_cch - m_ibBodyOffset - 2;
		}
		
	}	else	{

		//
		//	article is not cached - check to see if it is already mapped
		//  if not - map it
		//

		if( m_pMapFile ) {

			pchMappedFile = (m_pcBody.m_pch + 2);
			dwLength = m_pcBody.m_cch - 2;

		} else {

			HANDLE hFile = INVALID_HANDLE_VALUE;
			DWORD  Offset = 0;
			DWORD  Length = 0;

			BOOL fWhole = fWholeArticle(hFile, Offset, Length);
			_ASSERT( fWhole );

			// deleted by caller !!!
			pMapFile = XNEW CMapFile( hFile, FALSE, FALSE, 0 ) ;

			if( !pMapFile || !pMapFile->fGood() ) {

				// error - failed to map file !
				pchMappedFile = NULL;
				dwLength = 0;
				if( pMapFile ) {
					XDELETE pMapFile;
					pMapFile = NULL;
				}
				return FALSE;

			}	else	{
				DWORD	cb ;
				char*	pch = (char*)pMapFile->pvAddress( &cb ) ;

				// Skip over the new line
				_ASSERT( m_ibBodyOffset );
				pchMappedFile = (pch + m_ibBodyOffset + 2);
				dwLength = cb - m_ibBodyOffset - 2;
			}
		}
	}

	// Assert that the body starts with a new line.
	_ASSERT(memcmp( pchMappedFile-2, "\r\n", 2 ) == 0 );

	return TRUE;
}

BOOL
CArticleCore::fSaveHeader(
					  CNntpReturn & nntpReturn,
					  PDWORD        pdwLinesOffset
						  )
/*++

Routine Description:

  Saves changes to the current header back to disk.

Arguments:

	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set the article's state
	//

	_ASSERT(asModified == m_articleState);//real
	m_articleState = asSaved;



	//
	// _ASSERT that the header and the article have some content
	//

	_ASSERT(!m_pcHeader.m_pch && m_pcHeader.m_cch > 0
		   && !m_pcArticle.m_pch && m_pcArticle.m_cch > 0); //real

	if( fIsArticleCached() ) {

		fSaveCachedHeaderInternal( nntpReturn, pdwLinesOffset ) ;

	}	else	{

		//
		// Declare some objects
		//

		CPCString pcHeaderBuf;
		CPCString pcNewBody;

		fSaveHeaderInternal(pcHeaderBuf, pcNewBody, nntpReturn, pdwLinesOffset );

					
		m_pAllocator->Free(pcHeaderBuf.m_pch);

	}

	return nntpReturn.fIsOK();
	
}

BOOL
CArticleCore::fCommitHeader(	CNntpReturn&	nntpReturn )	{
/*++

Routine Description :

	The user is not going to call fSaveHeader(), however the article
	may have been created with an initial gap.
	This function will ensure the gap image is correct.

Arguments :

	nntpReturn - return error code if necessary !

Return Value :

	TRUE if successfull, false otherwise.

--*/

	if( !fIsArticleCached() ) {

		if( m_pcGap.m_cch != 0 ) {
			if( m_pMapFile == 0 ) {

				m_pMapFile = XNEW CMapFile(m_szFilename, m_hFile, TRUE, 0 );

				if (!m_pMapFile || !m_pMapFile->fGood())
					return nntpReturn.fSet(nrcArticleMappingFailed, m_szFilename, GetLastError());

				m_pcFile.m_pch = (char *) m_pMapFile->pvAddress( &(m_pcFile.m_cch) );

				m_pcGap.m_pch = m_pcFile.m_pch ;

			}
			vGapFill() ;
		}
	}

	return	TRUE ;
}

BOOL
CArticleCore::fSaveCachedHeaderInternal(
							CNntpReturn&	nntpReturn,
							PDWORD          pdwLinesOffset
							) {
/*++

Routine Description :

	Assuming that the entire article is sitting in a memory buffer
	somewhere, we want to try to modify the memory buffer to contain
	the correct header contents.

Arguments :


--*/

	//_ASSERT( m_hFile == INVALID_HANDLE_VALUE ) ;
	//_ASSERT( m_pBuffer != 0 ) ;
	//_ASSERT( m_cbBuffer >= m_pcArticle.m_cch ) ;


	CPCString	pcHeaderBuf ;
	CPCString	pcBodyBuf ;

	if( !fBuildNewHeader( pcHeaderBuf, nntpReturn, pdwLinesOffset ) )
		return	nntpReturn.fIsOK() ;

	if( m_pcArticle.m_cch <= m_pcFile.m_cch )	{

		if( m_pcBody.m_pch < (m_pcFile.m_pch + m_pcHeader.m_cch) ) {
			//
			//	Need to move the body around !
			//

			pcBodyBuf.m_pch = m_pcFile.m_pch + m_pcHeader.m_cch ;
			pcBodyBuf.m_cch = m_pcBody.m_cch ;

			pcBodyBuf.vMove( m_pcBody ) ;
			
			m_pcArticle.fSetPch( pcBodyBuf.pchMax() ) ;
			m_pcHeader.m_pch = m_pcArticle.m_pch ;
			m_pcBody = pcBodyBuf ;

		}	else	{

			m_pcArticle.fSetPch( m_pcBody.pchMax() ) ;
			m_pcHeader.m_pch = m_pcArticle.m_pch ;

		}
		m_pcGap.m_pch = 0 ;
		m_pcGap.m_cch = 0 ;

		m_pcHeader.vCopy( pcHeaderBuf ) ;


		//
		//	We have moved all the headers around - the pointers
		//	in the m_rgHeaders array refer to the dynamically allocated
		//	memory which starts at pcHeaderBuf.m_pch
		//	We want to do some math on each pointer to move it to
		//	the correct offset from m_pcHeader.m_pch
		//	
		//	So the math should be
		//
		//	m_pcHeader.m_pch Now points to first character of the header
		//	pcHeaderBuf.m_pch Points to first character of the regenerated header
		//	phs->XXXX->m_pch Originally points to first character in regen'd header
		//		should finally point to offset within m_pcHeader.m_pch buffer
		//
		//	(NEW)phs->XXXX->m_pch = (phs->XXXX->m_pch - pcHeaderBuf.m_pch) + m_pchHeader.m_pch ;
		//
		//	Note also that
		//

		for (HEADERS_STRINGS* phs = m_rgHeaders, 	*phsMax = m_rgHeaders + m_cHeaders;
			phs < phsMax;
			phs++)
		{
			phs->fInFile = TRUE;

			char * pchBufLine = phs->pcLine.m_pch;
			char * pchFileLine = m_pcHeader.m_pch +
				(pchBufLine - pcHeaderBuf.m_pch);

			//
			// Adjust all the line's pointers
			//

			phs->pcLine.m_pch =  pchFileLine;
			phs->pcKeyword.m_pch = pchFileLine;
			phs->pcValue.m_pch = pchFileLine +
				(phs->pcValue.m_pch - pchBufLine);
		}

		m_pAllocator->Free(pcHeaderBuf.m_pch);

		//
		// compress the items in the array
		//

		vCompressArray();
		
		if (0 == m_cHeaders)
			return nntpReturn.fSet(nrcArticleMissingHeader);



	}	else	{
		//
		//	Buffer is too small to hold resulting article !!
		//

		m_pHeaderBuffer = pcHeaderBuf.m_pch ;
		
		m_pcHeader.m_pch = m_pHeaderBuffer ;

	}


	return	nntpReturn.fSetOK() ;
}

BOOL
CArticleCore::fBuildNewHeader(	CPCString&		pcHeaderBuf,
							    CNntpReturn&	nntpReturn,
							    PDWORD          pdwLinesOffset )	{

    TraceFunctEnter("CArticleCore::fSaveHeaderInternal");

	//
	// Create a pointer to the array of header info and a pointer to the
	// first entry beyond the array of header info
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	//
	// Create a buffer for the new header
	//


	pcHeaderBuf.m_pch = m_pAllocator->Alloc(m_pcHeader.m_cch);

	if (!pcHeaderBuf.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// The new header buffer starts out with zero content
	//

	pcHeaderBuf.fSetCch(pcHeaderBuf.m_pch);

	//
	// Loop though the array of header information
	//

	for (phs = m_rgHeaders;
			phs < phsMax;
			phs++)
	{
		//
		// Point to the start of the current line
		//

		char * pchOldLine = phs->pcLine.m_pch;

		//
		// If the current line has not be removed, copy it to the new buffer
		//

		if (!phs->fRemoved)
		{
			//
			// Point to where the current line will be copied to
			//

			char * pchNewLine = pcHeaderBuf.pchMax();

			//
			// _ASSERT that there is enough space in the buffer to do the
			// copy. There should be, because we should have allocated exactly
			// the right amount of space.
			//

			_ASSERT(pcHeaderBuf.m_pch + m_pcHeader.m_cch
						>= pcHeaderBuf.pchMax()+phs->pcLine.m_cch);//real

			//
			// Before copying the line to the new buffer, we'll check if it's 
			// Lines line, if it is, we'll record the offset into which to
			// back fill the actual line information.
			//
			if ( pdwLinesOffset && strncmp( phs->pcKeyword.m_pch, szKwLines, strlen(szKwLines) ) == 0 ) {
                *pdwLinesOffset =   pcHeaderBuf.m_cch +
                                    strlen( szKwLines ) +
                                    1;  // plus one space
            }

			//
			// Copy the line to the new buffer
			//

			pcHeaderBuf << (phs->pcLine);

			//
			// Adjust all the line's pointers
			//

			phs->pcLine.m_pch =  pchNewLine;
			phs->pcKeyword.m_pch = pchNewLine;
			phs->pcValue.m_pch += (pchNewLine - pchOldLine);
		}

		//
		// If the memory was allocated dynamically, free it.
		//
		if (!phs->fInFile)
			m_pAllocator->Free(pchOldLine);


	}
	
	//
	// double check that everything copy copied to the buffer
	//
	_ASSERT(pcHeaderBuf.m_cch == m_pcHeader.m_cch); //real



	return	nntpReturn.fSetOK() ;

}

BOOL
CArticleCore::fSaveHeaderInternal(
							    CPCString & pcHeaderBuf,
							    CPCString & pcNewBody,
				  			    CNntpReturn & nntpReturn,
				  			    PDWORD      pdwLinesOffset
							)
/*++

Routine Description:

  Does most of the work of saving changes to the current header back to disk.

Arguments:

	nntpReturn - The return value for this function call

Return Value:

    TRUE, if and only if process succeeded.

--*/
{
    TraceFunctEnter("CArticleCore::fSaveHeaderInternal");

	//
	// Create a pointer to the array of header info and a pointer to the
	// first entry beyond the array of header info
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phs;

	//
	// Create a buffer for the new header
	//


	if( !fBuildNewHeader( pcHeaderBuf, nntpReturn, pdwLinesOffset ) )
		return	nntpReturn.fIsOK() ;


	//
	// Now there are two cases 1. There is enough room in the
	// file for the new header or 2. there is not.
	//

	//
	// Case 1. There is enough room
	//
	if (m_pcArticle.m_cch <= m_pcFile.m_cch)
	{
		//
		// Update article/header/gap
		// (body and file stay the same).
		//


		if( m_pMapFile == 0 ) {

			m_pMapFile = XNEW CMapFile(m_szFilename, m_hFile, TRUE, 0 );

			if (!m_pMapFile || !m_pMapFile->fGood())
				return nntpReturn.fSet(nrcArticleMappingFailed, m_szFilename, GetLastError());

			m_pcFile.m_pch = (char *) m_pMapFile->pvAddress( &(m_pcFile.m_cch) );

			m_pcGap.m_pch = m_pcFile.m_pch ;

		}

		_ASSERT(m_pcArticle.m_cch == pcHeaderBuf.m_cch + m_pcBody.m_cch); //real
		m_pcArticle.fSetPch(m_pcFile.pchMax());
		m_pcHeader.m_pch = m_pcArticle.m_pch;
		m_pcGap.fSetCch(m_pcArticle.m_pch);



		//
		//Fill in the gap
		//

		vGapFill();

	} else {
		//
		// Case 2. There is not enough room, so close and reopen the file bigger
		//

		//
		// Double check that we know the article, header and body sizes
		// are consistent.
		//

		_ASSERT(m_pcArticle.m_cch == pcHeaderBuf.m_cch + m_pcBody.m_cch); //real


		//
		// Need to create a new file
		//

		//
		// Find offset of body from start of file
		//

		DWORD dwBodyOffset = m_ibBodyOffset ; //m_pcBody.m_pch - m_pcFile.m_pch;
		
		//
		//!!!CLIENT NOW - This  does not need to close the handle.
		// It could just close the mapping and then
		// reopen the mapping bigger.
		//

		//
		// Close and reopen the file and mapping
		//

		if( m_pMapFile )
			vClose();
		

		//!!!MEM now
		m_pMapFile = XNEW CMapFile(m_szFilename, m_hFile, TRUE, m_pcArticle.m_cch - m_pcFile.m_cch);


		if (!m_pMapFile || !m_pMapFile->fGood())
			return nntpReturn.fSet(nrcArticleMappingFailed, m_szFilename, GetLastError());

		//
		// Point to the start of the new file
		//

		m_pcFile.m_pch = (char *) m_pMapFile->pvAddress( &(m_pcFile.m_cch) );

		//
		// Point to the start of the body in the new mapping
		//

		m_pcBody.m_pch = m_pcFile.m_pch + dwBodyOffset;

		//
		// Set gap to new mapping, size 0
		//

		m_pcGap.m_pch = m_pcFile.m_pch;
		m_pcGap.m_cch = 0;

		//
		// Set article to new mapping
		//

		m_pcArticle.m_pch = m_pcFile.m_pch + m_pcGap.m_cch;
		_ASSERT(m_pcArticle.pchMax() == m_pcFile.pchMax());	//real

		//
		// Set header to new mapping
		//

		m_pcHeader.m_pch = m_pcArticle.m_pch;
		
		//
		// Shift the body down
		//

		pcNewBody.m_pch = m_pcArticle.m_pch + m_pcHeader.m_cch;
		pcNewBody.fSetCch(m_pcArticle.pchMax());

		ErrorTrace((DWORD_PTR) this, "About to move the body %d bytes", pcNewBody.m_pch - m_pcBody.m_pch);

        //
        //  src+len and dst+len should be within the file mapping
        //
        ASSERT( m_pcBody.m_pch+m_pcBody.m_cch <= m_pcFile.m_pch+m_pcFile.m_cch );
        ASSERT( pcNewBody.m_pch+m_pcBody.m_cch <= m_pcFile.m_pch+m_pcFile.m_cch );
		pcNewBody.vMove(m_pcBody);
		m_pcBody = pcNewBody;
#if DEBUG
		_ASSERT(memcmp( m_pcFile.pchMax()-5, "\r\n.\r\n", 5 ) == 0 );
		_ASSERT(memcmp( m_pcArticle.pchMax()-5, "\r\n.\r\n", 5 ) == 0 );
		_ASSERT(memcmp( m_pcBody.pchMax()-5, "\r\n.\r\n", 5 ) == 0 );
#endif
	}

	//
	// Fill in the new header
	//

	m_pcHeader.vCopy(pcHeaderBuf);
	
	//
	// adjust the field's start pointers
	//

	//
	//!!!CLIENT LATER there may be an off-by-one error here
	//!!! this hasn't been test well because new mapping keeps coming
	// up with the same address as the old mapping
	//

	for (phs = m_rgHeaders;
		phs < phsMax;
		phs++)
	{
		phs->fInFile = TRUE;

		char * pchBufLine = phs->pcLine.m_pch;
		char * pchFileLine = m_pcHeader.m_pch +
			(pchBufLine - pcHeaderBuf.m_pch);

		//
		// Adjust all the line's pointers
		//

		phs->pcLine.m_pch =  pchFileLine;
		phs->pcKeyword.m_pch = pchFileLine;
		phs->pcValue.m_pch = pchFileLine +
			(phs->pcValue.m_pch - pchBufLine);
	}

	//
	// compress the items in the array
	//

	vCompressArray();
	
	if (0 == m_cHeaders)
		return nntpReturn.fSet(nrcArticleMissingHeader);

	return nntpReturn.fSetOK();
}

void
CArticleCore::vCompressArray(
						 void
						  )
/*++

Routine Description:

  Removes empty entries from the array of header items.

Arguments:

	None

Return Value:

    None

--*/
{

	//
	// Loop though the array
	//

	HEADERS_STRINGS * phsMax = m_rgHeaders + m_cHeaders;
	HEADERS_STRINGS * phsBefore;
	HEADERS_STRINGS * phsAfter = m_rgHeaders;;

	for (phsBefore = m_rgHeaders;
			phsBefore < phsMax;
			phsBefore++)
	{
		if (phsBefore->fRemoved)
		{
			//
			// only InFile fields may be deleted
			//
			_ASSERT(phsBefore->fInFile);//real
			m_cHeaders--;
		} else {

			//
			// If deleted items have been skipped over, then copy
			// items down.
			//

			if (phsBefore != phsAfter)
				CopyMemory(phsAfter, phsBefore, sizeof(HEADERS_STRINGS));
			phsAfter++;
		}
	}
}

void
CArticleCore::vGapFill(
		 void
		 )
/*++

Routine Description:

	Fills the gap in the file.
	
	The rule is	a gap is any whitespace before non-whitespace
	except if a gap starts with a TAB then it can contain
	a number that tells the size of the gap.

Arguments:

	None

Return Value:

    None

--*/
{
	switch (m_pcGap.m_cch)
	{
		case 0:

			//
			// do nothing
			//

			break;
		case 1:
			m_pcGap.m_pch[0] = ' ';
			break;
		case 2:
			m_pcGap.m_pch[0] = ' ';
			m_pcGap.m_pch[1] = ' ';
			break;
		case 3:
			lstrcpy(m_pcGap.m_pch, "   ");
			break;
		default:

			//
			// Fill the gap with  " nnnn      " where
			// nnnn is the size of the gap, expressed in as few
			// decimal digits as possible.
			//

			int iFilled = wsprintf(m_pcGap.m_pch, "\t%-lu ", m_pcGap.m_cch);
			FillMemory(m_pcGap.m_pch + iFilled, m_pcGap.m_cch - iFilled, (BYTE) ' ');
	}
	
};

void
CArticleCore::vGapRead(
		 void
		 )
/*++

Routine Description:

	Reads the gap in the file.
	
	If there is a gap, it start with ' ' or '\x0d'

Arguments:

	None

Return Value:

    None

--*/
{
	_ASSERT(m_pcGap.m_pch == m_pcFile.m_pch); //real

	//
	//If the file is empty or starts with something besides ' '
	// then the gap must have zero length
	//

	if (0 == m_pcFile.m_cch || !isspace(m_pcGap.m_pch[0]))
	{
		m_pcGap.m_cch = 0;
		return;
	}

#if 0
	if ('\t' == m_pcGap.m_pch[0])
	{
		if (1 == sscanf(m_pcGap.m_pch, " %u ", &m_pcGap.m_cch))
		{
			return;
		}
	}
#endif

	//
	// the gap ends with the whitespace ends
	//

	char * pcGapMax = m_pcGap.m_pch;
	char * pcFileMax = m_pcFile.pchMax();
	while (pcGapMax <= pcFileMax && isspace(pcGapMax[0]))
		pcGapMax++;

	if( '\t' == m_pcGap.m_pch[0]) {
		char	szBuff[9] ;
		ZeroMemory( szBuff, sizeof( szBuff ) ) ;
		CopyMemory( szBuff, pcGapMax, min( sizeof(szBuff)-1, pcFileMax - pcGapMax ) ) ;
		for( int i=0; i<sizeof(szBuff); i++ ) {
			if( !isdigit( szBuff[i] ) )			
				break ;		
		}
		szBuff[i] = '\0' ;
		m_pcGap.m_cch = atoi( szBuff ) ;
		return ;
	}

	m_pcGap.fSetCch(pcGapMax);
	return;
}


BOOL
CField::fParseSimple(
						BOOL fEmptyOK,
						CPCString & pc,
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	 Finds everything in the value part of a header line
	 expect trims staring and ending white space.


Arguments:

	fEmptyOK - True, if and only, if empty values are OK
	pc - The PCString to return
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//
	_ASSERT(fsFound == m_fieldState);//real
	_ASSERT(m_pHeaderString); //real


	m_fieldState = fsParsed;
	
	pc = m_pHeaderString->pcValue;

	pc.dwTrimStart(szWSNLChars);
	pc.dwTrimEnd(szWSNLChars);

	if (!fEmptyOK && 0 == pc.m_cch )
		return nntpReturn.fSetEx(nrcArticleFieldMissingValue, szKeyword());

	return nntpReturn.fSetOK();
}


BOOL
CField::fParseSplit(
						BOOL fEmptyOK,
						char * & multisz,
						DWORD & c,
						char const * szDelimSet,
						CArticleCore & article,
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	Splits the value part of a header into a list.

Arguments:

	fEmptyOK - True, if and only, if empty values are OK
	multisz - The list returned
	c - The size of the list returned
	szDelimSet - A set of delimiters
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT(fsFound == m_fieldState);//real
	_ASSERT(m_pHeaderString); //real
	m_fieldState = fsParsed;
	
	CPCString * ppcValue = & (m_pHeaderString->pcValue);

	multisz = article.pAllocator()->Alloc((ppcValue->m_cch)+2);

	if (multisz == NULL)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	ppcValue->vSplitLine(szDelimSet, multisz, c);

	if (!fEmptyOK && 0 == c)
		return nntpReturn.fSetEx(nrcArticleFieldZeroValues, szKeyword());

	return nntpReturn.fSetOK();
}


BOOL
CMessageIDField::fParse(
					    CArticleCore & article,
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	Parses MessageID headers.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	extern	BOOL
	FValidateMessageId(	LPSTR	lpstrMessageId ) ;


	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT(fsFound == m_fieldState);//real
	_ASSERT(m_pHeaderString); //real
	CPCString pcMessageID;

	if (!fParseSimple(FALSE, pcMessageID, nntpReturn))
		return FALSE;

	if (MAX_MSGID_LEN-1 <= pcMessageID.m_cch)
		return nntpReturn.fSet(nrcArticleFieldMessIdTooLong, pcMessageID.m_cch, MAX_MSGID_LEN-1);


	if (!(
		'<' == pcMessageID.m_pch[0]
		&&	'>' == pcMessageID.m_pch[pcMessageID.m_cch - 1]
		))
		return nntpReturn.fSet(nrcArticleFieldMessIdNeedsBrack);

	//
	// See if '>' anywhere other than as the last character
	//
#if 0
	char * pchLast = pcMessageID.pchMax() -1;
	for (char * pch = pcMessageID.m_pch + 1; pch < pchLast; pch++)
	{
		if ('>' == *pch)
			return nntpReturn.fSet(nrcArticleFieldMessIdNeedsBrack);
	}
#endif

	pcMessageID.vCopyToSz(m_szMessageID);

	if( !FValidateMessageId( m_szMessageID ) ) {
		nntpReturn.fSet(nrcArticleBadMessageID, m_szMessageID, szKwMessageID  ) ;
		ZeroMemory( &m_szMessageID[0], sizeof( m_szMessageID ) ) ;
        return  FALSE ;
	}

	return nntpReturn.fSetOK();	
}


					
const char *
CNewsgroupsField::multiSzGet(
						void
						)
/*++

Routine Description:

	Returns the list of newsgroups in the Newsgroups field as a
	multisz.

Arguments:

	None.

Return Value:

	The list of Newsgroups.

--*/
{
	_ASSERT(fsParsed == m_fieldState);//real
	return m_multiSzNewsgroups;
}


DWORD
CNewsgroupsField::cGet(
						void
						)
/*++

Routine Description:

	Returns the number of newsgroups in the Newsgroups field as a
	multisz.

Arguments:

	None.

Return Value:

	The number of newsgroups.

--*/
{
	_ASSERT(fsParsed == m_fieldState);//real
	return m_cNewsgroups;
}

const char *
CDistributionField::multiSzGet(
						void
						)
/*++

Routine Description:

	Returns the list of Distribution in the Distribution field as a
	multisz.

Arguments:

	None.

Return Value:

	The list of Distribution.

--*/
{
	_ASSERT(fsParsed == m_fieldState);//real
	return m_multiSzDistribution;
}



DWORD
CDistributionField::cGet(
						void
						)
/*++

Routine Description:

	Returns the number of Distribution in the Distribution field as a
	multisz.

Arguments:

	None.

Return Value:

	The number of Distribution.

--*/
{
	_ASSERT(fsParsed == m_fieldState);//real
	return m_cDistribution;
}


const char *
CPathField::multiSzGet(
						void
						)
/*++

Routine Description:

	Returns the list of path items in the Path field as a
	multisz.

Arguments:

	None.

Return Value:

	The list of path items.

--*/
{
	
	const char * multiszPath = m_multiSzPath;
	if (multiszPath)
		return multiszPath;
	else
		return "\0\0";
}


BOOL
CPathField::fSet(
 				 CPCString & pcHub,
				 CArticleCore & article,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Replaces any old Path headers (if any) with a new one.	

Arguments:

	pcHub - The name of the hub the current machine is part of.
	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT(fsParsed == m_fieldState);//real
	CPCString pcLine;


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	//
	// max size needed is
	//

	const DWORD cchMaxPath =
			STRLEN(szKwPath)	// for the Path keyword
			+ 1					// space following the keyword
			+ pcHub.m_cch		// the hub name
			+ 1					// the "!"
			+ (m_pHeaderString->pcValue).m_cch

								//
								// length of the old value.
								//

			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxPath);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Path: <hubname>!"
	//

	wsprintf(pcLine.m_pch, "%s %s!", szKwPath, pcHub.sz());
	pcLine.m_cch = STRLEN(szKwPath)	+ 1	+ pcHub.m_cch + 1;

	//
	// Add the old path value and string terminators
	//

	pcLine << (m_pHeaderString->pcValue) << "\r\n";
	pcLine.vMakeSz(); // add string terminator

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxPath-1 == pcLine.m_cch);//real


	if (!(
  		article.fRemoveAny(szKwPath, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.m_pch+cchMaxPath, nntpReturn)
		))
	{
		article.pAllocator() -> Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}
	
	return nntpReturn.fIsOK();
}



BOOL
CPathField::fCheck(
 				 CPCString & pcHub,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Tells if the current hub name appears in the path (but
	the last position doesn't count. See RFC1036).

	This is used for finding cycles.


Arguments:

	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT(fsParsed == m_fieldState);//real
	_ASSERT(!m_fChecked);
	m_fChecked = TRUE;

	char const * sz = multiSzGet();
	DWORD	dwCount = cGet();
	do
	{
		if ((0 == lstrcmp(sz, pcHub.sz()))
				&& (dwCount >=1))
			return nntpReturn.fSet(nrcPathLoop, pcHub.sz());

		dwCount--;

		//
		// go to first char after next null
		//

		while ('\0' != sz[0])
			sz++;
		sz++;
	} while ('\0' != sz[0]);

	return nntpReturn.fSetOK();
}
	
BOOL
CControlField::fParse(
			 CArticleCore & article,
			 CNntpReturn & nntpReturn
			 )
/*++

Routine Description:

	Parses the control field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real
	_ASSERT(m_pHeaderString); //real

	if (!fParseSimple(FALSE, m_pc, nntpReturn))
		return nntpReturn.fFalse();

    BOOL fValidMsg = FALSE;
    for(DWORD i=0; i<MAX_CONTROL_MESSAGES; i++)
    {
        DWORD cbMsgLen = lstrlen(rgchControlMessageTbl [i]);

        // The control message keyword len is greater than the value in the control header
        if(m_pc.m_cch < cbMsgLen)
            continue;

        char * pch = m_pc.m_pch;
        if(!_strnicmp(pch, rgchControlMessageTbl[i], cbMsgLen))
        {
            // check for exact match
            if(!isspace(*(pch+cbMsgLen)))
                continue;

            // matched control message keyword - note the type
            m_cmCommand = (CONTROL_MESSAGE_TYPE)i;
            fValidMsg = TRUE;
            break;
        }
    }

    if(!fValidMsg)
        return nntpReturn.fSet(nrcIllegalControlMessage);

	return nntpReturn.fSetOK();
}
	
BOOL
CXrefField::fSet(
				 CPCString & pcHub,
				 CNAMEREFLIST & namereflist,
				 CArticleCore & article,
				 CNewsgroupsField & fieldNewsgroups,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Replaces any old Xref headers with a new one.

  The form of an Xref line is something like:
		Xref: <hubname> alt.politics.libertarian:48170 talk.politics.misc:188851


Arguments:

	pcHub - The name of the hub the current machine is part of.
	namereflist - a list of the newsgroups names and article numbers
	article - The article being processed.
	fieldNewsgroups - The Newsgroups field for this article.
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful. FALSE, otherwise.
*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//
	// We don't expect this field to be found or parsed, because
	// we don't care about old values, if any.
	//

	_ASSERT(fsInitialized == m_fieldState);//real
	CPCString pcLine;


	//
	// The number of our newsgroups to post to.
	//

	const DWORD cgroups = namereflist.GetCount();


#if 0   // we want XREF in all articles, not just crossposted ones
	if( cgroups == 1 ) {

		if (!article.fRemoveAny(szKwXref, nntpReturn))
			nntpReturn.fFalse();

	}	else	{
#endif

		//
		// max size needed is
		//

		const DWORD cchMaxXref =
				STRLEN(szKwXref)	// for the Xref keyword
				+ 1					// space following the keyword
				+ pcHub.m_cch		// the hub name
				+ ((fieldNewsgroups.m_pHeaderString)->pcValue).m_cch
				+ 16				// max size of any of the control.* groups
				+ (cgroups *		// for each newsgroup
					(10				// space for any DWORD
					+ 2))			// space for the ":" and leading space

				//
				// length of the old value.
				//

				+ 2 // for the newline
				+ 1; // for a terminating null

		//
		// Allocate memory for line within a PCString.
		//

		pcLine.m_pch  = article.pAllocator() -> Alloc(cchMaxXref);
		if (!pcLine.m_pch)
			return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

		//
		// Start with "Xref: <hubname>"
		//

		wsprintf(pcLine.m_pch, "%s %s", szKwXref, pcHub.sz());
		pcLine.m_cch = STRLEN(szKwXref)	+ 1	+ pcHub.m_cch;

		//
		// For each newsgroup ...
		//

		POSITION	pos = namereflist.GetHeadPosition() ;
		while( pos  )
		{
			NAME_AND_ARTREF * pNameAndRef = namereflist.GetNext( pos ) ;

			//
			// Add " <newsgroupname>:<articlenumber>"
			//

			pcLine << (const CHAR)' ' << (pNameAndRef->pcName)
	               << (const CHAR)':' << ((pNameAndRef->artref).m_articleId);
		}

		//
		// Add newline and string terminators.
		//

		pcLine << "\r\n";
		pcLine.vMakeSz(); // add string terminator

		 //
		 // confirm that we allocated enough memory
		 //

		_ASSERT(cchMaxXref >= pcLine.m_cch);//real

		//
		// Remove the old Xref line and add the new one.
		//

		if (!(
  				article.fRemoveAny(szKwXref, nntpReturn)
				&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
				))
		{
			article.pAllocator() -> Free(pcLine.m_pch);	
			return nntpReturn.fFalse();
		}

#if 0 // XREF in all articles, not just cross posted ones
	}
#endif

	return nntpReturn.fIsOK();
}


		
BOOL
CXrefField::fSet(
				 CArticleCore & article,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	 Just remove the old fields, if any.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	_ASSERT(fsInitialized == m_fieldState);//real
	CPCString pcLine;
	nntpReturn.fSetClear(); // clear the return object

	if (!article.fRemoveAny(szKwXref, nntpReturn))
		nntpReturn.fFalse();

	return nntpReturn.fIsOK();
}


BOOL
CField::fFind(
			  CArticleCore & article,
			  CNntpReturn & nntpReturn
			)
/*++

Routine Description:

	Finds the location of a field (based on keyword) in the article.
	Returns an error if there is more than one occurance of the field.

Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//
	_ASSERT(fsInitialized == m_fieldState); //real
	m_fieldState = fsFound;

	//
	// Mark as not set
	//

	return article.fFindOneAndOnly(szKeyword(), m_pHeaderString, nntpReturn);
}


BOOL
CField::fFindOneOrNone(
			  CArticleCore & article,
			  CNntpReturn & nntpReturn
			)
/*++

Routine Description:

	Finds the location of a field (based on keyword) in the article.
	Returns an error if there is more than one occurance of the field.
	Does not return an error if the field does not exist at all.



Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Set article state
	//

	_ASSERT(fsInitialized == m_fieldState); //real

	if (!article.fFindOneAndOnly(szKeyword(), m_pHeaderString, nntpReturn))

		//
		//If the field is missing that is OK
		//

		if (nntpReturn.fIs(nrcArticleMissingField))
		{
			m_fieldState = fsNotFound;
			return nntpReturn.fSetOK();
		} else {
			return nntpReturn.fFalse(); // return with error from FindOneAndOnly
		}

	m_fieldState = fsFound;
	return nntpReturn.fIsOK();

}

BOOL
CField::fFindNone(
			  CArticleCore & article,
			  CNntpReturn & nntpReturn
			)
/*++

Routine Description:

	Finds the location of a field (based on keyword) in the article.
	Returns an error if there is one occurance of the field.
	Does not return an error if the field does not exist at all.

Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Set article state
	//

	_ASSERT(fsInitialized == m_fieldState); //real

	if (!article.fFindOneAndOnly(szKeyword(), m_pHeaderString, nntpReturn))
    {
		//
		//If the field is missing that is OK
		//
		if (nntpReturn.fIs(nrcArticleMissingField))
		{
			m_fieldState = fsNotFound;
			return nntpReturn.fSetOK();
		}

    } else {
        nntpReturn.fSet(nrcSystemHeaderPresent, szKeyword());
    }

	return nntpReturn.fFalse();
}

BOOL
CNewsgroupsField::fParse(
						 CArticleCore & article,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Parse the Newsgroups field by creating a list and removing duplicates.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real

	if (!fParseSplit(FALSE, m_multiSzNewsgroups, m_cNewsgroups, " \t\r\n,",
				article, nntpReturn))
		return nntpReturn.fFalse();

	//
	//Remove duplicates
	//

	if (!fMultiSzRemoveDupI(m_multiSzNewsgroups, m_cNewsgroups, article.pAllocator()))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	
	//
	// check for illegal characters and substrings in newsgroup name
	//

	char const * szNewsgroup = m_multiSzNewsgroups;
	DWORD i = 0;
	do
	{
		if ('\0' == szNewsgroup[0]
			|| strpbrk(szNewsgroup,":")
			|| '.' == szNewsgroup[0]
			|| strstr(szNewsgroup,"..")
			)
		return nntpReturn.fSet(nrcArticleFieldIllegalNewsgroup, szNewsgroup, szKeyword());

		//
		// go to first char after next null
		//

		while ('\0' != szNewsgroup[0])
			szNewsgroup++;
		szNewsgroup++;
	} while ('\0' != szNewsgroup[0]);

	return nntpReturn.fSetOK();
}


BOOL
CDistributionField::fParse(
						 CArticleCore & article,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Parse the Distribution field by creating a list and removing duplicates.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real

	if (!fParseSplit(FALSE, m_multiSzDistribution, m_cDistribution, " \t\r\n,",
				article, nntpReturn))
		return nntpReturn.fFalse();

	//
	//Remove duplicates
	//

	if (!fMultiSzRemoveDupI(m_multiSzDistribution, m_cDistribution, article.pAllocator()))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	
	//
	// Don't really need to check for illegal characters, because
	// we should be able to tolerate them.
	//

	return nntpReturn.fSetOK();
}


BOOL
CArticleCore::fHead(
			  HANDLE & hFile,
			  DWORD & dwOffset,
			  DWORD & dwLength
			  )
/*++

Routine Description:

	Returns the header of the article.

Arguments:

	hFile - Returns a handle to the file
	dwOffset - Returns the offset to the article's header
	dwLength - Returns the length of the header.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	_ASSERT(INVALID_HANDLE_VALUE != m_hFile);
	hFile = m_hFile;
	dwOffset = (DWORD)(m_pcHeader.m_pch - m_pcFile.m_pch);
	dwLength = m_pcHeader.m_cch;
	return TRUE;
}


BOOL
CArticleCore::fBody(
			  HANDLE & hFile,
			  DWORD & dwOffset,
			  DWORD & dwLength
			  )
/*++

Routine Description:

	Returns the body of the article.

Arguments:

	hFile - Returns a handle to the file
	dwOffset - Returns the offset to the article's body
	dwLength - Returns the length of the body.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	_ASSERT(INVALID_HANDLE_VALUE != m_hFile);
	hFile = m_hFile;

	// Assert that the body start with a new line.
	_ASSERT(memcmp( m_pcBody.m_pch, "\r\n", 2 ) == 0 );

	//
	// Skip over the new line
	//

	dwOffset = (DWORD)((m_pcBody.m_pch + 2) - m_pcFile.m_pch);

	dwLength = m_pcBody.m_cch - 2;

	return TRUE;
}

BOOL
CArticleCore::fBody(
        char * & pchMappedFile,
		DWORD & dwLength
		)
/*++

Routine Description:

	Returns the body of the article.

Arguments:

	pchMappedFile - Returns the pointer to the article's body
	dwLength - Returns the length of the body.

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	// Assert that the body start with a new line.
	_ASSERT(memcmp( m_pcBody.m_pch, "\r\n", 2 ) == 0 );

	//
	// Skip over the new line
	//
	pchMappedFile = (m_pcBody.m_pch + 2);
	dwLength = m_pcBody.m_cch - 2;

	return TRUE;
}


BOOL
CArticleCore::fWholeArticle(
			  HANDLE & hFile,
			  DWORD & dwOffset,
			  DWORD & dwLength
			  )
/*++

Routine Description:

	Returns the whole article of the article.

Arguments:

	hFile - Returns a handle to the file
	dwOffset - Returns the offset to the start of the whole article
	dwLength - Returns the length of the whole article.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	_ASSERT(INVALID_HANDLE_VALUE != m_hFile);
	hFile = m_hFile;
	dwOffset = m_pcGap.m_cch; //m_pcArticle.m_pch - m_pcFile.m_pch;
	dwLength = m_pcArticle.m_cch;
	return TRUE;
}


BOOL
CArticleCore::fFindAndParseList(
				  CField * * rgPFields,
				  DWORD cFields,
				  CNntpReturn & nntpReturn
				  )
/*++

Routine Description:

	Given a list of fields, find the location of the
	field and parses it.

Arguments:

	rgPFields - A list of fields
	cFields - The number of fields in the list.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	for (DWORD dwFields = 0; dwFields < cFields; dwFields++)
	{
		CField * pField = rgPFields[dwFields];

		//
		// If the find or the parse fails, return a new error message based on the
		// message from fFindAndParse
		//

		if (!pField->fFindAndParse(*this, nntpReturn))
			return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}

BOOL
CField::fFindAndParse(
						CArticleCore & article,
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	Find the location of this field in the article and parse it.

Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check that it is found if it is required.
	//

	if (!fFind(article, nntpReturn))
		return nntpReturn.fFalse();
	
	//
	// If it is optional, just return
	//

	if (m_fieldState == fsNotFound)
		return nntpReturn.fSetOK();

	//
	// Otherwise, parse it
	//

	return fParse(article, nntpReturn);
};


BOOL
CArticleCore::fConfirmCapsList(
				  CField * * rgPFields,
				  DWORD cFields,
				  CNntpReturn & nntpReturn
				  )
/*++

Routine Description:

	Given a list of fields, confirms and
	fixes (if necessary) the capitalization
	of the keywords.

Arguments:

	rgPFields - A list of fields
	cFields - The number of fields in the list.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Loop through each field
	//

	for (DWORD dwFields = 0; dwFields < cFields; dwFields++)
	{
		CField * pField = rgPFields[dwFields];

		if (!pField->fConfirmCaps(nntpReturn))
			return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}

BOOL
CField::fConfirmCaps(
						CNntpReturn & nntpReturn
						)
/*++

Routine Description:

	confirms and fixes (if necessary) the capitalization
	of the keywords.

Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// If it is optional, just return
	//

	if (m_fieldState == fsNotFound)
		return nntpReturn.fSetOK();

	//
	// _ASSERT that it was found
	//

	_ASSERT(m_fieldState == fsParsed);

	//
	// Fix the capitalization
	//

	(m_pHeaderString->pcKeyword).vReplace(szKeyword());

	return nntpReturn.fSetOK();
}

#define	HOUR( h )	((h)*60)

typedef	enum	DaylightSavingsModes	{
	tZONE,		/* No daylight savings stuff */
	tDAYZONE,	/* Daylight savings zone */
}	;

typedef	struct	tsnTimezones	{

	LPSTR	lpstrName ;
	int		type ;
	long	offset ;

}	TIMEZONE ;

//	This table taken from INN's parsedate.y
/* Timezone table. */
static TIMEZONE	TimezoneTable[] = {
    { "gmt",	tZONE,     HOUR( 0) },	/* Greenwich Mean */
    { "ut",	tZONE,     HOUR( 0) },	/* Universal */
    { "utc",	tZONE,     HOUR( 0) },	/* Universal Coordinated */
    { "cut",	tZONE,     HOUR( 0) },	/* Coordinated Universal */
    { "z",	tZONE,     HOUR( 0) },	/* Greenwich Mean */
    { "wet",	tZONE,     HOUR( 0) },	/* Western European */
    { "bst",	tDAYZONE,  HOUR( 0) },	/* British Summer */
    { "nst",	tZONE,     HOUR(3)+30 }, /* Newfoundland Standard */
    { "ndt",	tDAYZONE,  HOUR(3)+30 }, /* Newfoundland Daylight */
    { "ast",	tZONE,     HOUR( 4) },	/* Atlantic Standard */
    { "adt",	tDAYZONE,  HOUR( 4) },	/* Atlantic Daylight */
    { "est",	tZONE,     HOUR( 5) },	/* Eastern Standard */
    { "edt",	tDAYZONE,  HOUR( 5) },	/* Eastern Daylight */
    { "cst",	tZONE,     HOUR( 6) },	/* Central Standard */
    { "cdt",	tDAYZONE,  HOUR( 6) },	/* Central Daylight */
    { "mst",	tZONE,     HOUR( 7) },	/* Mountain Standard */
    { "mdt",	tDAYZONE,  HOUR( 7) },	/* Mountain Daylight */
    { "pst",	tZONE,     HOUR( 8) },	/* Pacific Standard */
    { "pdt",	tDAYZONE,  HOUR( 8) },	/* Pacific Daylight */
    { "yst",	tZONE,     HOUR( 9) },	/* Yukon Standard */
    { "ydt",	tDAYZONE,  HOUR( 9) },	/* Yukon Daylight */
    { "akst",	tZONE,     HOUR( 9) },	/* Alaska Standard */
    { "akdt",	tDAYZONE,  HOUR( 9) },	/* Alaska Daylight */
    { "hst",	tZONE,     HOUR(10) },	/* Hawaii Standard */
    { "hast",	tZONE,     HOUR(10) },	/* Hawaii-Aleutian Standard */
    { "hadt",	tDAYZONE,  HOUR(10) },	/* Hawaii-Aleutian Daylight */
    { "ces",	tDAYZONE,  -HOUR(1) },	/* Central European Summer */
    { "cest",	tDAYZONE,  -HOUR(1) },	/* Central European Summer */
    { "mez",	tZONE,     -HOUR(1) },	/* Middle European */
    { "mezt",	tDAYZONE,  -HOUR(1) },	/* Middle European Summer */
    { "cet",	tZONE,     -HOUR(1) },	/* Central European */
    { "met",	tZONE,     -HOUR(1) },	/* Middle European */
    { "eet",	tZONE,     -HOUR(2) },	/* Eastern Europe */
    { "msk",	tZONE,     -HOUR(3) },	/* Moscow Winter */
    { "msd",	tDAYZONE,  -HOUR(3) },	/* Moscow Summer */
    { "wast",	tZONE,     -HOUR(8) },	/* West Australian Standard */
    { "wadt",	tDAYZONE,  -HOUR(8) },	/* West Australian Daylight */
    { "hkt",	tZONE,     -HOUR(8) },	/* Hong Kong */
    { "cct",	tZONE,     -HOUR(8) },	/* China Coast */
    { "jst",	tZONE,     -HOUR(9) },	/* Japan Standard */
    { "kst",	tZONE,     -HOUR(9) },	/* Korean Standard */
    { "kdt",	tZONE,     -HOUR(9) },	/* Korean Daylight */
    { "cast",	tZONE,     -(HOUR(9)+30) }, /* Central Australian Standard */
    { "cadt",	tDAYZONE,  -(HOUR(9)+30) }, /* Central Australian Daylight */
    { "east",	tZONE,     -HOUR(10) },	/* Eastern Australian Standard */
    { "eadt",	tDAYZONE,  -HOUR(10) },	/* Eastern Australian Daylight */
    { "nzst",	tZONE,     -HOUR(12) },	/* New Zealand Standard */
    { "nzdt",	tDAYZONE,  -HOUR(12) },	/* New Zealand Daylight */

    /* For completeness we include the following entries. */
#if	0

    /* Duplicate names.  Either they conflict with a zone listed above
     * (which is either more likely to be seen or just been in circulation
     * longer), or they conflict with another zone in this section and
     * we could not reasonably choose one over the other. */
    { "fst",	tZONE,     HOUR( 2) },	/* Fernando De Noronha Standard */
    { "fdt",	tDAYZONE,  HOUR( 2) },	/* Fernando De Noronha Daylight */
    { "bst",	tZONE,     HOUR( 3) },	/* Brazil Standard */
    { "est",	tZONE,     HOUR( 3) },	/* Eastern Standard (Brazil) */
    { "edt",	tDAYZONE,  HOUR( 3) },	/* Eastern Daylight (Brazil) */
    { "wst",	tZONE,     HOUR( 4) },	/* Western Standard (Brazil) */
    { "wdt",	tDAYZONE,  HOUR( 4) },	/* Western Daylight (Brazil) */
    { "cst",	tZONE,     HOUR( 5) },	/* Chile Standard */
    { "cdt",	tDAYZONE,  HOUR( 5) },	/* Chile Daylight */
    { "ast",	tZONE,     HOUR( 5) },	/* Acre Standard */
    { "adt",	tDAYZONE,  HOUR( 5) },	/* Acre Daylight */
    { "cst",	tZONE,     HOUR( 5) },	/* Cuba Standard */
    { "cdt",	tDAYZONE,  HOUR( 5) },	/* Cuba Daylight */
    { "est",	tZONE,     HOUR( 6) },	/* Easter Island Standard */
    { "edt",	tDAYZONE,  HOUR( 6) },	/* Easter Island Daylight */
    { "sst",	tZONE,     HOUR(11) },	/* Samoa Standard */
    { "ist",	tZONE,     -HOUR(2) },	/* Israel Standard */
    { "idt",	tDAYZONE,  -HOUR(2) },	/* Israel Daylight */
    { "idt",	tDAYZONE,  -(HOUR(3)+30) }, /* Iran Daylight */
    { "ist",	tZONE,     -(HOUR(3)+30) }, /* Iran Standard */
    { "cst",	 tZONE,     -HOUR(8) },	/* China Standard */
    { "cdt",	 tDAYZONE,  -HOUR(8) },	/* China Daylight */
    { "sst",	 tZONE,     -HOUR(8) },	/* Singapore Standard */

    /* Dubious (e.g., not in Olson's TIMEZONE package) or obsolete. */
    { "gst",	tZONE,     HOUR( 3) },	/* Greenland Standard */
    { "wat",	tZONE,     -HOUR(1) },	/* West Africa */
    { "at",	tZONE,     HOUR( 2) },	/* Azores */
    { "gst",	tZONE,     -HOUR(10) },	/* Guam Standard */
    { "nft",	tZONE,     HOUR(3)+30 }, /* Newfoundland */
    { "idlw",	tZONE,     HOUR(12) },	/* International Date Line West */
    { "mewt",	tZONE,     -HOUR(1) },	/* Middle European Winter */
    { "mest",	tDAYZONE,  -HOUR(1) },	/* Middle European Summer */
    { "swt",	tZONE,     -HOUR(1) },	/* Swedish Winter */
    { "sst",	tDAYZONE,  -HOUR(1) },	/* Swedish Summer */
    { "fwt",	tZONE,     -HOUR(1) },	/* French Winter */
    { "fst",	tDAYZONE,  -HOUR(1) },	/* French Summer */
    { "bt",	tZONE,     -HOUR(3) },	/* Baghdad */
    { "it",	tZONE,     -(HOUR(3)+30) }, /* Iran */
    { "zp4",	tZONE,     -HOUR(4) },	/* USSR Zone 3 */
    { "zp5",	tZONE,     -HOUR(5) },	/* USSR Zone 4 */
    { "ist",	tZONE,     -(HOUR(5)+30) }, /* Indian Standard */
    { "zp6",	tZONE,     -HOUR(6) },	/* USSR Zone 5 */
    { "nst",	tZONE,     -HOUR(7) },	/* North Sumatra */
    { "sst",	tZONE,     -HOUR(7) },	/* South Sumatra */
    { "jt",	tZONE,     -(HOUR(7)+30) }, /* Java (3pm in Cronusland!) */
    { "nzt",	tZONE,     -HOUR(12) },	/* New Zealand */
    { "idle",	tZONE,     -HOUR(12) },	/* International Date Line East */
    { "cat",	tZONE,     HOUR(10) },	/* -- expired 1967 */
    { "nt",	tZONE,     HOUR(11) },	/* -- expired 1967 */
    { "ahst",	tZONE,     HOUR(10) },	/* -- expired 1983 */
    { "hdt",	tDAYZONE,  HOUR(10) },	/* -- expired 1986 */
#endif	/* 0 */
};


BOOL
CField::fStrictDateParse(
					   CPCString & pcDate,
					   BOOL fEmptyOK,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Strictly parse a date-style field.

	Here is the grammer:

               Date-content  = [ weekday "," space ] date space time
               weekday       = "Mon" / "Tue" / "Wed" / "Thu"
                             / "Fri" / "Sat" / "Sun"
               date          = day space month space year
               day           = 1*2digit
               month         = "Jan" / "Feb" / "Mar" / "Apr" / "May" / "Jun"
                             / "Jul" / "Aug" / "Sep" / "Oct" / "Nov" / "Dec"
               year          = 4digit / 2digit
               time          = hh ":" mm [ ":" ss ] space timezone
               timezone      = "UT" / "GMT"
                             / ( "+" / "-" ) hh mm [ space "(" zone-name ")" ]
               hh            = 2digit
               mm            = 2digit
               ss            = 2digit
               zone-name     = 1*( <ASCII printable character except ()\> / space )

Arguments:

	pcDate - The string to parse
	fEmptyOK - True, if and only, if empty values are OK
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	if (!fParseSimple(fEmptyOK, pcDate, nntpReturn))
		return nntpReturn.fFalse();

	if (fEmptyOK && (0 == pcDate.m_cch)) //!!!isn't there a pc.fEmpty()?
		return nntpReturn.fSetOK();

	CPCString pc = pcDate;

	if (0 == pc.m_cch)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue);
		
	//
	// If it start with an alpha, parse weekday
	//

	if (isalpha(pc.m_pch[0]))
	{
		const int cchMax = 4;
		const int iDaysInAWeek = 7;

		if (cchMax > pc.m_cch)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

		char * rgszWeekDays[] = {"Mon,", "Tue,", "Wed,", "Thu,", "Fri,", "Sat,", "Sun,"};

		int i;
		for (i = 0; i < iDaysInAWeek; i++)
			if (0== _strnicmp(rgszWeekDays[i], pc.m_pch, cchMax))
				break;
		if (iDaysInAWeek == i)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
		pc.vSkipStart(cchMax);

		//
		// must be a 'space' of some type after the day of the week.
		//

		if (0 == pc.dwTrimStart(szWSNLChars))
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	}
	
	if (0 ==  pc.m_cch)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	//
	// Check for a day-of-the-month with length 1 or 2
	//

	char	*pchDayOfMonth = pc.m_pch ;
	DWORD dwDayLength = pc.dwTrimStart("0123456789");
	if ((0 == pc.m_cch) || (0 == dwDayLength) || (2 < dwDayLength))
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	//
	// must be a 'space' of some type after the day and that must not be the end
	//

	if ((0 == pc.dwTrimStart(szWSNLChars)) || (0 ==  pc.m_cch))
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	const int cchMax = 3;
	const int iMonthsInAYear = 12;

	char * rgszYearMonths[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
							"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
	int i;
	for (i = 0; i < iMonthsInAYear; i++)
		if (0== _strnicmp(rgszYearMonths[i], pc.m_pch, cchMax))
			break;
	if (iMonthsInAYear == i)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
	pc.vSkipStart(cchMax);

	int	DayOfMonth = atoi( pchDayOfMonth ) ;
	int	rgdwDaysOfMonth[] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 } ;
	if( DayOfMonth > rgdwDaysOfMonth[i] ) {
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
	}
	

	//
	// must be a 'space' of some type after the month
	//

	if ((0 == pc.dwTrimStart(szWSNLChars)) || (0 ==  pc.m_cch))
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	//
	// must have a 4 digit year
	//

	DWORD	cDigits = pc.dwTrimStart("0123456789") ;
	if ((4 != cDigits && 2 != cDigits) || (0 ==  pc.m_cch))//!!contize
		return nntpReturn.fSet(nrcArticleFieldDate4DigitYear, szKeyword());
	
	//
	// must be a 'space' of some type after the year
	//

	if ((0 == pc.dwTrimStart(szWSNLChars)) || (0 ==  pc.m_cch))
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

    //
    // finally parse   time  = hh ":" mm [ ":" ss ] space timezone
    //

	//
	// hh:mm
	//

	if ((2 != pc.dwTrimStart("0123456789"))
			|| (0 ==  pc.m_cch)
			|| (1 != pc.dwTrimStart(":"))
			|| (0 ==  pc.m_cch)
			|| (2 != pc.dwTrimStart("0123456789"))
			|| (0 ==  pc.m_cch)
		)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	//
	// Parse optional second
	//

	if (':' == pc.m_pch[0])
	{
		pc.vSkipStart(1); // skip ':'
		if ((0 ==  pc.m_cch)
			|| (2 != pc.dwTrimStart("0123456789"))//!!constize
			|| (0 ==  pc.m_cch)
			)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
	}

	//
	// must be a 'space' of some type before the year
	//

	if ((0 == pc.dwTrimStart(szWSNLChars)) || (0 ==  pc.m_cch))
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());


#if 0
	/*               timezone      = "UT" / "GMT"
                             / ( "+" / "-" ) hh mm [ space "(" zone-name ")" ]
	 */
	const char * szUT = "UT";
	const char * szGMT = "GMT";
	if ((STRLEN(szUT) <= pc.m_cch) && (0==strncmp(szUT, pc.m_pch, STRLEN(szUT))))
	{
		pc.vSkipStart(STRLEN(szUT));
	} else if ((STRLEN(szGMT) <= pc.m_cch) && (0==strncmp(szGMT, pc.m_pch, STRLEN(szUT))))
	{
		pc.vSkipStart(STRLEN(szGMT));
	} else
#endif

	BOOL	fGoodTimeZone = FALSE ;
	long	tzOffset = 0 ;
	for( i=0; i < sizeof( TimezoneTable ) / sizeof( TimezoneTable[0] ); i++ ) {

		if( (DWORD)lstrlen( TimezoneTable[i].lpstrName ) >= pc.m_cch ) {
			if( _strnicmp( pc.m_pch, TimezoneTable[i].lpstrName, pc.m_cch ) == 0 ) {
				fGoodTimeZone = TRUE ;
				tzOffset = TimezoneTable[i].offset ;
				pc.vSkipStart( lstrlen( TimezoneTable[i].lpstrName ) ) ;
				break ;
			}
		}
	}
	if( !fGoodTimeZone ) { //( "+" / "-" ) hh mm [ space "(" zone-name ")" ]
		if ((0 ==  pc.m_cch)
			|| (2 <= pc.dwTrimStart("+-"))
			|| (0 ==  pc.m_cch)
			|| (4 != pc.dwTrimStart("0123456789"))//!!constize
			)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
		if (0 < pc.m_cch) // must have optional timezone comment
		{

			//
			// Look for " (.*)$"
			//

			if ((0 == pc.dwTrimStart(szWSNLChars))
				|| (0 ==  pc.m_cch)
				|| (1 != pc.dwTrimStart("("))
				|| (1 >=  pc.m_cch)
				|| (')' != (pc.m_pch[pc.m_cch-1]))
				)
			return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

			for( DWORD i=0; i<pc.m_cch-1; i++ ) {
				if( fCharInSet( pc.m_pch[i], "()\\/>" ) ) {
					return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
				}
			}


			pc.m_pch = pc.pchMax()-1;
			pc.m_cch = 0;
		}
	}

	//
	// That should be everything
	//

	if (0 !=  pc.m_cch)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());

	return nntpReturn.fSetOK();
}

#define MAX_TIMEUNITS 9

/*
 *   relative date time units
 */

static  char  *rgchTimeUnits[ MAX_TIMEUNITS ] =
{
	"year", "month", "week", "day", "hour", "minute",
	"min", "second", "sec",
};

enum
{
	ExpectNumber,
	ExpectTimeUnit
};

BOOL
CField::fRelativeDateParse(
					   CPCString & pcDate,
						BOOL fEmptyOK,
						CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	parse a relative date field eg: 5 years 3 months 24 days

	Here is the grammar:

			   Date-content  = token | token {space}+ Date-content
			   token         = number {space}+ time-unit
			   number        = digit | digit number
			   digit		 = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
			   time-unit     = "year" / "month" / "week" / "day" / "hour"
							 / "minute" / "min" / "second" / "sec"
							   (plural allowed, any capitalization allowed)

Arguments:

	pcDate - The string to parse
	fEmptyOK - True, if and only, if empty values are OK
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if Date value is a relative date FALSE, otherwise.

--*/
{
	BOOL  fValid = FALSE;
	BOOL  fDone  = FALSE;

	//
	// clear the return code object
	//
	nntpReturn.fSetClear();

	// get the value to parse
	pcDate = m_pHeaderString->pcValue;

	pcDate.dwTrimStart(szWSNLChars);
	pcDate.dwTrimEnd(szWSNLChars);

	if (fEmptyOK && (0 == pcDate.m_cch)) //!!!isn't there a pc.fEmpty()?
		return nntpReturn.fSetOK();

	// make a copy, so original date value is preserved
	CPCString pc = pcDate;

	if (0 == pc.m_cch)
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue);
		
	DWORD dwNumSize = 0;
	CPCString pcWord;
	DWORD dwState = ExpectNumber;

	// parse the string
	while(pc.m_cch)
	{
		// state toggles between ExpectNumber and ExpectTimeUnit
		switch(dwState)
		{
			case ExpectNumber:

				// skip the number
				dwNumSize = pc.dwTrimStart("0123456789");
				if(0 == dwNumSize)
				{
					// expected number, got junk
					fValid = FALSE;
					fDone  = TRUE;
					break;
				}

				// skipped number, now expect time-unit
				dwState = ExpectTimeUnit;

				break;

			case ExpectTimeUnit:

				// skip word; check if word is a valid time-unit
				pc.vGetWord(pcWord);
				if(	(0 == pcWord.m_cch) ||
					(!pcWord.fExistsInSet(rgchTimeUnits, MAX_TIMEUNITS))
					)
				{
					// expected time-unit, got junk
					fValid = FALSE;
					fDone = TRUE;
					break;
				}

				// seen at least one <number> space <time-unit> sequence
				// now expect a number
				fValid = TRUE;
				dwState = ExpectNumber;

				break;

			default:

				fValid = FALSE;
				fDone  = TRUE;
		};

		// syntax error detected - bail out
		if(fDone) break;

		// skip whitespace between tokens
		pc.dwTrimStart(szWSChars);
	}

	if(fValid)
		return nntpReturn.fSetOK();
	else
		return nntpReturn.fSet(nrcArticleFieldDateIllegalValue, szKeyword());
}


BOOL
CField::fStrictFromParse(
					   CPCString & pcFrom,
					   BOOL fEmptyOK,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Stickly parse a from-style (address-style) field.

  The grammer is:

               From-content  = address [ space "(" paren-phrase ")" ]
                             /  [ plain-phrase space ] "<" address ">"
               paren-phrase  = 1*( paren-char / space / encoded-word )
               paren-char    = <ASCII printable character except ()<>\>
               plain-phrase  = plain-word *( space plain-word )
               plain-word    = unquoted-word / quoted-word / encoded-word
               unquoted-word = 1*unquoted-char
               unquoted-char = <ASCII printable character except !()<>@,;:\".[]>
               quoted-word   = quote 1*( quoted-char / space ) quote
               quote         = <" (ASCII 34)>
               quoted-char   = <ASCII printable character except "()<>\>
               address       = local-part "@" domain
			                     OR JUST local-part
               local-part    = unquoted-word *( "." unquoted-word )
               domain        = unquoted-word *( "." unquoted-word )

Arguments:

	pcFrom - The string to parse
	fEmptyOK - True, if and only, if empty values are OK
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	if (!fParseSimple(fEmptyOK, pcFrom, nntpReturn))
		return nntpReturn.fFalse();

	if (fEmptyOK && (0==pcFrom.m_cch))
		return nntpReturn.fSetOK();

	CPCParse pcFrom2(pcFrom.m_pch, pcFrom.m_cch);

	if (!pcFrom2.fFromContent())
		return nntpReturn.fSet(nrcArticleFieldAddressBad, szKeyword());

	return nntpReturn.fSetOK();
}


BOOL
fTestAComponent(
				const char * szComponent
				)
/*++

Routine Description:

	Test components of a newsgroup name (e.g. "alt" "ms-windows", etc.)
	for illegal values.

	!!!CLIENT LATER might be nice of errors were more specific

Arguments:

	szComponent - The newsgroup component to test.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	const char szSpecial[] = "+-_";

	//
	// If it is empty or starts with one of the special characters,
	// or is the wild card value ("all"), return FALSE
	//

	if ('\0' == szComponent[0]
		|| fCharInSet(szComponent[0], szSpecial)
		|| 0 == lstrcmp("all", szComponent))
		return FALSE;

	//
	// Look at each character (including the first one)
	//

	for (int i = 0; ; i++)
	{

#if 0
		//
		// If the length is too long return FALSE
		//

		if (i > cchMaxNewsgroups)
			return FALSE;
#endif

		//
		// If the character is not a..z, 0..9, + - _ return FALSE
		//

		char ch = szComponent[i];
		if ('\0' == ch) break;
		if ((!isalnum(ch)) && (!fCharInSet(ch, szSpecial)))
			return FALSE;
	}

	return TRUE;

}


BOOL
fTestANewsgroupComponent(
				const char * szComponent
				)
/*++

Routine Description:

	Test components of a newsgroup name (e.g. "alt" "ms-windows", etc.)
	for illegal values.

	NOTE: We deviate from the RFC to be more INN compatible - we allow
	newsgroups to begin with '+-_=', and we also allow '=' as a character
	in the newsgroup name.

	!!!CLIENT LATER might be nice of errors were more specific

Arguments:

	szComponent - The newsgroup component to test.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	const char szSpecial[] = "+-_=@";

	//
	// If it is empty or starts with one of the special characters,
	// or is the wild card value ("all"), return FALSE
	//

	if ('\0' == szComponent[0]
		|| 0 == lstrcmp("all", szComponent))
		return FALSE;

	//
	// Look at each character (including the first one)
	//

	for (int i = 0; ; i++)
	{

#if 0
		//
		// If the length is too long return FALSE
		//

		if (i > cchMaxNewsgroups)
			return FALSE;
#endif

		//
		// If the character is not a..z, 0..9, + - _ return FALSE
		//

		char ch = szComponent[i];
		if ('\0' == ch) break;
		if ((!isalnum(ch)) && (!fCharInSet(ch, szSpecial)))
			return FALSE;
	}

	return TRUE;

}


BOOL
fTestComponents(
				 const char * szNewsgroups
				)
/*++

Routine Description:

	Test a newsgroup name (e.g. "alt.barney") for illegal values.


Arguments:

	szNewsgroups - The newsgroup name to test.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	CPCString pcNewsgroups((char *)szNewsgroups);
	BOOL fOK = FALSE;
	CNntpReturn nntpReturn;

	if (pcNewsgroups.m_cch-1 > MAX_PATH)
		return FALSE;

	//
	// Split the newsgroup up into its components
	// No matter what, delete the multisz
	//

	fOK = fTestComponentsInternal(szNewsgroups, pcNewsgroups);

	return fOK;
}


BOOL
fTestComponentsInternal(
				 const char * szNewsgroups,
				 CPCString & pcNewsgroups
				)
/*++

Routine Description:

	Does most of the work of testing
	a newsgroup name (e.g. "alt.barney") for illegal values.


Arguments:

	szNewsgroups - The newsgroup name to test.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	DWORD count;
	char multiSz[MAX_PATH + 2];

	//
	// Reject newsgroup names that start or end with "."
	//
	
	if (0 == pcNewsgroups.m_cch
		|| '.' == pcNewsgroups.m_pch[0]
		|| '.' == pcNewsgroups.m_pch[pcNewsgroups.m_cch -1]
		)
		return FALSE;


	// Split the newsgroup name
	pcNewsgroups.vSplitLine(".", multiSz, count);
	if (0 == count)
		return FALSE;

	//
	// Loop through the components
	//

	char const * szComponent = multiSz;
	do
	{
		if (!fTestANewsgroupComponent(szComponent))
			return FALSE;

		//
		// go to first char after next null
		//

		while ('\0' != szComponent[0])
			szComponent++;
		szComponent++;
	} while ('\0' != szComponent[0]);

	return TRUE;

}
	
BOOL
CField::fStrictNewsgroupsParse(
					   BOOL fEmptyOK,
					   char * & multiSzNewsgroups,
					   DWORD & cNewsgroups,
					   CArticleCore & article,
						CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Stictly parse a value of the Newsgroups field.

	 Not as strict as it used to be because things like dups and uppers case are
	 now fixed.


Arguments:

	fEmptyOK - True, if and only, if empty values are OK
	multiSzNewsgroups - A list of newsgroups in multsz form.
	cNewsgroups - The number of newsgroups.
	nntpReturn - The return value for this function call

Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	if (!fParseSplit(fEmptyOK, multiSzNewsgroups, cNewsgroups, " \t\r\n,",
			article, nntpReturn))//!!const
		return nntpReturn.fFalse();

	if (fEmptyOK && 0==cNewsgroups)
		return nntpReturn.fSetOK();

	if (!fMultiSzRemoveDupI(multiSzNewsgroups, cNewsgroups, article.pAllocator()))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// check for illegal characters and substrings in newsgroup name
	//

	char const * szNewsgroup = multiSzNewsgroups;
	do
	{
		if (('\0' == szNewsgroup[0])
			|| !fTestComponents(szNewsgroup)
			)
			return nntpReturn.fSet(nrcArticleFieldIllegalNewsgroup, szNewsgroup, szKeyword());

		//
		// go to first char after next null
		//

		while ('\0' != szNewsgroup[0])
			szNewsgroup++;
		szNewsgroup++;
	} while ('\0' != szNewsgroup[0]);

	return nntpReturn.fSetOK();
}


BOOL
CField::fTestAMessageID(
				 const char * szMessageID,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Check if a message id is of legal form.

Arguments:

	szMessageID - The message id to check.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	CPCString pcMessageID((char *) szMessageID);

	if (!(
		'<' == pcMessageID.m_pch[0]
		&&	'>' == pcMessageID.m_pch[pcMessageID.m_cch - 1]
		))
		return nntpReturn.fSet(nrcArticleBadMessageID, szMessageID, szKeyword());

	return nntpReturn.fSetOK();
}

BOOL
CArticleCore::fXOver(
				  CPCString & pcBuffer,
				  CNntpReturn & nntpReturn
				  )
/*++

Routine Description:

	Returns XOver information (except for the initial artid)

	format of the Xover data is:

	artid|subject|From|date|messageId|References|bytecount|linecount|Xref:

	where | is \t and linecount and References may be empty.
		Check if a message id is of legal form.

Arguments:

	pcBuffer - A buffer in to which the Xover information should be placed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();


	//
	// Set article state
	//

	_ASSERT((asPreParsed == m_articleState)||(asSaved == m_articleState));//real

	char szDwBuf[12]; // enougth room for any DWORD
	_itoa(m_pcFile.m_cch, szDwBuf, 10);

	char	szNumberBuff[20] ;
	FillMemory( szNumberBuff, sizeof( szNumberBuff ), ' ' ) ;
	CPCString	pcMaxNumber( szNumberBuff, sizeof( szNumberBuff ) ) ;

	CPCString pcXover(pcBuffer.m_pch, 0);
	if (!(
		pcXover.fAppendCheck(pcMaxNumber, pcBuffer.m_cch )
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwSubject, TRUE, FALSE, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwFrom, TRUE, FALSE, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwDate, TRUE, FALSE, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwMessageID, TRUE, FALSE, nntpReturn)
		&& fXOverAppendReferences(pcXover, pcBuffer.m_cch, nntpReturn)
		&& fXOverAppendStr(pcXover, pcBuffer.m_cch, szDwBuf, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwLines, FALSE, FALSE, nntpReturn)
		&& fXOverAppend(pcXover, pcBuffer.m_cch, szKwXref, FALSE, TRUE, nntpReturn)
		))
		return nntpReturn.fFalse();

	//
	// Append a newline
	//
	CPCString	pcNewline( "\r\n", 2 ) ;

	if (!pcXover.fAppendCheck(pcNewline, pcBuffer.m_cch))
		return nntpReturn.fFalse();

	//
	// Record the length of the string in the original buffer
	//

	pcBuffer.m_cch = pcXover.m_cch;

	return nntpReturn.fSetOK();

}

BOOL
CArticleCore::fXOverAppend(
					   CPCString & pc,
					   DWORD cchLast,
					   const char * szKeyword,
			   		   BOOL fRequired,
					   BOOL fIncludeKeyword,
					   CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Appends new information to the Xover return buffer. It is very careful
	to return an error is the buffer is not big enough.

Arguments:

	pc - The XOver string so far
	cchLast - The size of the buffer
	szKeyword - The keyword for this data
	fRequired - True, if it there must be data for this keyword
	fIncludeKeyword - True, if the keyword should be included with the XOver return string.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	HEADERS_STRINGS * pHeaderString;


	//
	// Find the keyword (if not found, is it required?)
	//

	if (!fFindOneAndOnly(szKeyword, pHeaderString, nntpReturn))
	{
		if (nntpReturn.fIs(nrcArticleMissingField) && fRequired)
		{
			return nntpReturn.fFalse();
		} else {
			if (fIncludeKeyword)
			{
				return nntpReturn.fSetOK();
			} else {
				if (!pc.fAppendCheck('\t', cchLast))
					return nntpReturn.fSet(nrcArticleXoverTooBig);
				else
					return nntpReturn.fSetOK();
			}
		}
	}

	//
	// Append Tab
	//

	if (!pc.fAppendCheck('\t', cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);

	//
	// Append Keyword if appropriate
	//

	if (fIncludeKeyword)
	{
		if (!(
			pc.fAppendCheck(pHeaderString->pcKeyword, cchLast)
			&& pc.fAppendCheck(' ', cchLast)
			))
			return nntpReturn.fSet(nrcArticleXoverTooBig);
	}

	CPCString pcNew(pc.pchMax(), (pHeaderString->pcValue).m_cch);

	//
	// Append value
	//

	if (!pc.fAppendCheck(pHeaderString->pcValue, cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);

	//
	// Translate any newline characters or tab to blank
	//

	pcNew.vTr("\n\r\t", ' ');

	return nntpReturn.fSetOK();
}


BOOL
CArticleCore::fXOverAppendReferences(
					   CPCString & pc,
					   DWORD cchLast,
					   CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Appends references information to the Xover return buffer.
	It is very careful to return an error is the buffer is not big enough.
	It will shorten the References list if it is too long.

Arguments:

	pc - The XOver string so far
	cchLast - The size of the buffer
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	HEADERS_STRINGS * pHeaderString;

   const char * szKeyword = szKwReferences;

	//
	// Find the keyword (if not found, it is not required)
	//

	if (!fFindOneAndOnly(szKeyword, pHeaderString, nntpReturn))
	{
		if (!pc.fAppendCheck('\t', cchLast))
			return nntpReturn.fSet(nrcArticleXoverTooBig);
		else
			return nntpReturn.fSetOK();
	}

	//
	// Append Tab
	//

	if (!pc.fAppendCheck('\t', cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);


	CPCString pcNew(pc.pchMax(), (pHeaderString->pcValue).m_cch);

	//
	// Append value
	//

	if (pHeaderString->pcValue.m_cch <= MAX_REFERENCES_FIELD)
	{
		if (!pc.fAppendCheck(pHeaderString->pcValue, cchLast))
			return nntpReturn.fSet(nrcArticleXoverTooBig);
	} else {
		// Shorten the References line
		CPCString pcRefList = pHeaderString->pcValue;

		char rgchBuf[MAX_REFERENCES_FIELD];
		CPCString pcNewValue(rgchBuf, 0);

		CPCString pcFirst;

		static	char	sz3spaces[] = "   " ;
		CPCString	pc3spaces( sz3spaces, sizeof( sz3spaces ) ) ;

		// Copy the first references and append 3 spaces as son of 1036
		// recommends
		pcRefList.vGetToken(szWSNLChars, pcFirst);
		if (!(
				pcNewValue.fAppendCheck(pcFirst, MAX_REFERENCES_FIELD)
				&& pcNewValue.fAppendCheck(pc3spaces, MAX_REFERENCES_FIELD)
				))
			return nntpReturn.fSet(nrcArticleXoverTooBig);

		// Skip over the rest of the refs, until the list is short enough
		CPCString pcJunk;
		while (pcRefList.m_cch > (MAX_REFERENCES_FIELD - pcNewValue.m_cch))
			pcRefList.vGetToken(szWSNLChars, pcJunk);

		// pcRefList might have zero length, that's OK
		if (!pcNewValue.fAppendCheck(pcRefList, MAX_REFERENCES_FIELD))
			return nntpReturn.fSet(nrcArticleXoverTooBig);
		
		// Now pcNewValue has the shortened References in it, so copy it
		// to the Xover line

		if (!pc.fAppendCheck(pcNewValue, cchLast))
			return nntpReturn.fSet(nrcArticleXoverTooBig);


	}

	//
	// Translate any newline characters or tab to blank
	//

	pcNew.vTr("\n\r\t", ' ');

	return nntpReturn.fSetOK();
}

BOOL
CArticleCore::fXOverAppendStr(
						  CPCString & pc,
						  DWORD cchLast,
						  char * const sz,
						CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Adds Xover information to the XOver return string.

Arguments:

	pc - The Xover return string.
	cchLast - The size of the buffer.
	sz - The information to add.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear(); // clear the return object

	//
	// Append Tab
	//

	if (!pc.fAppendCheck('\t', cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);

	//
	// Append the string
	//

	CPCString pcAdd(sz);
	if (!pc.fAppendCheck(pcAdd, cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);
	
	return nntpReturn.fSetOK();
}

#if 0
BOOL
CArticleCore::fXhdrGet(
					   CPCString & pc,
					   DWORD cchLast,
					   const char * szKeyword,
					   CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Finds the value for the keyword (the keyword should have no colon)

Arguments:

	pc - The XOver string so far
	cchLast - The size of the buffer
	szKeyword - The keyword for this data
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	HEADERS_STRINGS * pHeaderString;


	//
	// Find the keyword (if not found, is it required?)
	//

	if (!fFindAny(szKeyword, pHeaderString, nntpReturn))
		return nntpReturn.fFalse();

	CPCString pcNew(pc.pchMax(), (pHeaderString->pcValue).m_cch);

	//
	// Append value
	//

	if (!pc.fAppendCheck(pHeaderString->pcValue, cchLast))
		return nntpReturn.fSet(nrcArticleXoverTooBig);

	//
	// Translate any newline characters or tab to blank
	//

	pcNew.vTr("\n\r\t", ' ');

	return nntpReturn.fSetOK();
}

#endif


BOOL
CLinesField::fSet(
				 CArticleCore & article,
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:


	If the Line field is missing, adds it.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//
	//
	// If it already exists, then just return
	//

	if (fsParsed == m_fieldState)
		return nntpReturn.fSetOK();

	//
	// If we are asked not to back fill, we don't bother
	// to add the line to the header
	//
	if ( !g_fBackFillLines )
	    return nntpReturn.fSetOK();

	//
	// Otherwise, add it.
	//

	_ASSERT(fsNotFound == m_fieldState);//real
	CPCString pcLine;

	//
	// max size needed is
	//

	const DWORD cchMaxLine =
			STRLEN(szKwLines)	// for the Line keyword
			+ 1					// space following the keyword
			+ 10				// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxLine);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Line: ", then add an approximation of the number of Line
	// in the body and the newline
	// 
	// KangYan: start with "Lines: ", then add 10 spaces to be back filled
	//

	pcLine << szKwLines << (const CHAR)' ' << (const DWORD)1 << "         \r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxLine-1 >= pcLine.m_cch);//real

	if (!article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}


BOOL CArticleCore::fGetStream(IStream **ppStream) {
	if (fIsArticleCached()) {
		CStreamMem *pStream = XNEW CStreamMem(m_pcArticle.m_pch,
											 m_pcArticle.m_cch);
		*ppStream = pStream;
	} else {
		BOOL fMappedAlready = (m_pMapFile != NULL);

		// map the article if it isn't already mapped
		if (!fMappedAlready) {
			m_pMapFile = XNEW CMapFile( m_hFile, FALSE, FALSE, 0 );
			if (m_pMapFile == NULL || !m_pMapFile->fGood()) {
				if (m_pMapFile) {
				    XDELETE m_pMapFile;
					m_pMapFile = NULL;
				}
				return FALSE;
			}
		}

		// get the pointer to the article and its size
		DWORD cb;
		char *pch = (char*)m_pMapFile->pvAddress(&cb);

		// build a stream from that
		CStreamMem *pStream = XNEW CStreamMem(pch, cb);
		*ppStream = pStream;
	}

	return (*ppStream != NULL);
}

//
// this function makes it safe to use the fGetHeader() function after
// the article has been closed with vClose().
//
BOOL CArticleCore::fMakeGetHeaderSafeAfterClose(CNntpReturn &nntpReturn) {
	//
	// fGetHeader is always safe after a vClose() if the article is cached,
	// because vClose is a NO-OP for cached articles, and the memory backing
	// the cached article is valid for the lifetime of the CArticleCore
	//
	if (fIsArticleCached()) return TRUE;

	//
	// if the article isn't cached then m_pHeaderBuffer should be NULL
	//
	_ASSERT(m_pHeaderBuffer == NULL);

	//
	// fBuildNewHeader copies the headers to pcHeaderBuf and rewrites
	// the pointers in m_pcHeaders to point to values inside pcHeaderBuf.
	//
	CPCString	pcHeaderBuf ;
	if (!fBuildNewHeader(pcHeaderBuf, nntpReturn)) {
		return nntpReturn.fIsOK();
	}

	//
	// set m_pHeaderBuffer and m_pcHeader to point to the newly created buffer
	//
	// CArticleCore::~CArticleCore will clean up m_pHeaderBuffer if it is set
	//
	m_pHeaderBuffer = pcHeaderBuf.m_pch;
	m_pcHeader.m_pch = m_pHeaderBuffer;
	_ASSERT(m_pcHeader.m_cch == pcHeaderBuf.m_cch);

	return TRUE;
}

BOOL
CArticleCore::ArtCloseHandle(
                HANDLE& hFile
                //LPTS_OPEN_FILE_INFO&    pOpenFile
                )   {
/*++

Routine Description :

    Wrap the call to TsCloseHandle() so we don't have knowledge of
    g_pTsvcInfo everywhere
    We will set the callers handle and pOpenFile to
    INVALID_HANDLE_VALUE and NULL

Arguments :

    hFile - IN/OUT - file handle of file
    pOpenFile - IN/OUT gibraltar caching stuff

Return Value :

    TRUE if successfull, FALSE otherwise

--*/

    BOOL    fSuccess = FALSE ;

    /*if( pOpenFile == 0 ) {*/

        if( hFile != INVALID_HANDLE_VALUE ) {

            fSuccess = CloseHandle( hFile ) ;
            _ASSERT( fSuccess ) ;
            hFile = INVALID_HANDLE_VALUE ;

        }/*
    }   else    {

        fSuccess = ::TsCloseHandle( GetTsvcCache(),
                                    pOpenFile ) ;
        pOpenFile = 0 ;
        hFile = INVALID_HANDLE_VALUE ;

        _ASSERT( fSuccess ) ;

    }*/
    return  fSuccess ;
}

CCacheCreateFile::~CCacheCreateFile()
{
    if ( m_pFIOContext ) ReleaseContext( m_pFIOContext );
    m_pFIOContext = NULL;
}

HANDLE
CCacheCreateFile::CacheCreateCallback(  LPSTR   szFileName,
                                        LPVOID  pv,
                                        PDWORD  pdwSize,
                                        PDWORD  pdwSizeHigh )
/*++
Routine Description:

    Function that gets called on a cache miss.

Arguments:

    LPSTR szFileName - File name
    LPVOID lpvData  - Callback context
    DWORD* pdwSize  - To return file size

Return value:

    File handle
--*/
{
    TraceFunctEnter( "CCacheCreateFile::CreateFileCallback" );
    _ASSERT( szFileName );
    _ASSERT( strlen( szFileName ) <= MAX_PATH );
    _ASSERT( pdwSize );

    HANDLE hFile = CreateFileA(
                    szFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    0,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN |
                    FILE_ATTRIBUTE_READONLY |
                    FILE_FLAG_OVERLAPPED,
                    NULL
                    ) ;
    if( hFile != INVALID_HANDLE_VALUE ) {
        *pdwSize = GetFileSize( hFile, pdwSizeHigh ) ;
    }

    return  hFile ;
}

HANDLE
CCacheCreateFile::CreateFileHandle( LPCSTR szFileName )
/*++
Routine description:

    Create the file for map file.

Arguments:

    LPSTR   szFileName  - The file name to open

Return value:

    File handle
--*/
{
    TraceFunctEnter( "CCacheCreateFile::CreateFileHandle" );
    _ASSERT( szFileName );

    m_pFIOContext = CacheCreateFile(    (LPSTR)szFileName,
                                        CacheCreateCallback,
                                        NULL,
                                        TRUE );
    if ( m_pFIOContext == NULL ) return INVALID_HANDLE_VALUE;
    else return m_pFIOContext->m_hFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\artutil.cpp ===
#include "stdinc.h"

BOOL
ValidateFileBytes(  LPSTR   lpstrFile, BOOL fFileMustExist ) {

#if 0

    //
    //  Check that the file is OK.
    //

    HANDLE  hFile = CreateFile( lpstrFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE ) ;

    if( hFile == INVALID_HANDLE_VALUE ) {
        DWORD   dw = GetLastError() ;
        return  !fFileMustExist ;
    }   else    {

        char    szBuff[5] ;
        DWORD   cbJunk = 0 ;
        ZeroMemory( szBuff, sizeof( szBuff ) ) ;

        SetFilePointer( hFile, -5, 0, FILE_END ) ;
        if( ReadFile( hFile, szBuff, 5, &cbJunk, 0 ) )  {
            if( memcmp( szBuff, "\r\n.\r\n", 5 ) == 0 ) {
                _VERIFY( CloseHandle( hFile ) );
                return  TRUE ;
            }
        }
        _VERIFY( CloseHandle( hFile ) );
    }
    return  FALSE ;
#else
    return  TRUE ;
#endif
}

BOOL
ValidateFileBytes(	HANDLE	hFileIn )		{

	HANDLE	hProcess = GetCurrentProcess() ;
	HANDLE	hFile = INVALID_HANDLE_VALUE ;
	if( !DuplicateHandle( hProcess, hFileIn, hProcess, &hFile, 0, FALSE, DUPLICATE_SAME_ACCESS ) ) {
		DWORD	dw = GetLastError() ;
		return	FALSE ;
	}	else	{
		char	szBuff[5] ;
		DWORD	cbJunk = 0 ;
		ZeroMemory( szBuff, sizeof( szBuff ) ) ;

		SetFilePointer( hFile, -5, 0, FILE_END ) ;
		if( ReadFile( hFile, szBuff, 5, &cbJunk, 0 ) )	{
			if( memcmp( szBuff, "\r\n.\r\n", 5 ) == 0 ) {
				_VERIFY( CloseHandle( hFile ) );
				return	TRUE ;
			}
		}
		DWORD	dw = GetLastError() ;
		_VERIFY( CloseHandle( hFile ) );
	}
	return	FALSE ;
}


BOOL
fMultiSzRemoveDupI(char * multiSz, DWORD & c, CAllocator * pAllocator)
{
    char * * rgsz;
    char * multiSzOut = NULL; // this is only used if necessary
    DWORD k = 0;
    BOOL    fOK = FALSE; // assume the worst
    DWORD   cb = 0 ;


    rgsz = (CHARPTR *) pAllocator->Alloc(sizeof(CHARPTR) * c);
    if (!rgsz)
        return FALSE;

    char * sz = multiSz;

    for (DWORD i = 0; i < c; i++)
    {
        _ASSERT('\0' != sz[0]); // real

        cb = lstrlen( sz ) ;

        // Look for match
        BOOL fMatch = FALSE; // assume
        for (DWORD j = 0; j < k; j++)
        {
            if (0 == _stricmp(sz, rgsz[j]))
            {
                fMatch = TRUE;
                break;
            }
        }

        // Handle match
        if (fMatch)
        {
            // If they are equal and we are not yet
            // using multiSzOut, the start it at 'sz'
            if (!multiSzOut)
                multiSzOut = sz;
        }
        else
        {
            // If the are not equal and we are using multiSzOut
            // then copy sz into multiSzOut;
            if (multiSzOut)
            {
                rgsz[k++] = multiSzOut;
                vStrCopyInc(sz, multiSzOut);
                *multiSzOut++ = '\0'; // add terminating null
            }
            else
            {
                rgsz[k++] = sz;
            }
        }

	    // go to first char after next null
	    //while ('\0' != sz[0])
	    //  sz++;
	    //sz++;
	    sz += cb + 1 ;
    }


    fOK = TRUE;

    pAllocator->Free((char *)rgsz);

    c = k;
    if (multiSzOut)
        multiSzOut[0] = '\0';
    return fOK;
}

///!!!
// Copies the NULL, too
void
vStrCopyInc(char * szIn, char * & szOut)
{
    while (*szIn)
        *szOut++ = *szIn++;
}

BOOL
FValidateMessageId( LPSTR   lpstrMessageId ) {
/*++

Routine Description :

    Check that the string is a legal looking message id.
    Should contain 1 @ sign and at least one none '>' character
    after that '@' sign.

Arguments :

    lpstrMessageId - Message ID to be validated.

Returns

    TRUE if it appears to be legal
    FALSE   otherwise

--*/

    int cb = lstrlen( lpstrMessageId );

    if( lpstrMessageId[0] != '<' || lpstrMessageId[cb-1] != '>' ) {
        return  FALSE ;
    }

    if( lpstrMessageId[1] == '@' )
        return  FALSE ;

    int cAtSigns = 0 ;
    for( int i=1; i<cb-2; i++ ) {
        if( lpstrMessageId[i] == '@' ) {
            cAtSigns++ ;
        }   else if( lpstrMessageId[i] == '<' || lpstrMessageId[i] == '>' ) {
            return  FALSE ;
        }   else if( isspace( (BYTE)lpstrMessageId[i] ) ) {
            return  FALSE ;
        }
    }
    if( lpstrMessageId[i] == '<' || lpstrMessageId[i] == '>' || cAtSigns != 1 ) {
        return  FALSE ;
    }
    return  TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\mapfile.cpp ===
/* ------------------------------------------------------------------------
  mapfile.cpp
     (was bbmpfile.cpp)
  	A wrapper function to perform the cook book type operations required
  	to map a file into memory.  Maps the whole file, and nothing but the
  	file, so help me God.  Returns a pointer to void;  NULL on error.
  	An error also results in an entry in the event log, unless the error
  	is "file not found" during CreateFile().

  Copyright (C)  1994, 1995  Microsoft Corporation.
  All Rights Reserved.

  Author
  	Lindsay Harris	- lindsayh

   ------------------------------------------------------------------------ */

//#ifndef	UNIT_TEST
//#include "tigris.hxx"
//#else
//#include	<windows.h>
//#include	"mapfile.h"

//#ifndef	_ASSERT
//#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
//#endif
//#endif

#include "stdinc.h"

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for unicode mapping.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:11 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, to support tracking of objects in exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const WCHAR *pwchFileName, BOOL fWriteEnable, BOOL fTrack )
{

    HANDLE   hFile;				// Ditto.

	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;			// Until later.
#ifndef	UNIT_TEST
    numMapFile++;
#endif

    hFile = CreateFileW( pwchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;				// Default values are failure.
    }
    wcsncpy( m_rgwchFileName, pwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, 0 );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor for ascii file name version.

  Author
  	Lindsay Harris	- lindsayh

  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
    HANDLE   hFile;				// Ditto.

	//    Set default values corresponding to no mapping happened.
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.
#ifndef	UNIT_TEST
    numMapFile++;
#endif

    hFile = CreateFile( pchFileName,
                 fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
		   && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
			m_pv = NULL;
    	}
        return;
    }

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	BOOL	fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::CMapFile.
  	Constructor for ascii file name version.

  Note: Creates file handle if necessary. Does not close file handle.

  Author
  	Lindsay Harris	- lindsayh


  History:
	16:13 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to handle tracking of objects for exception handling.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( const char *pchFileName, HANDLE & hFile, BOOL fWriteEnable, DWORD cbIncrease, CCreateFile *pCreateFile )
{
	// Set default values corresponding to no mapping happened.
    //
	m_pv = NULL;
	m_cb = 0;
	m_fFlags = 0;				// None set yet.
#ifndef	UNIT_TEST
    numMapFile++;
#endif

	if ( INVALID_HANDLE_VALUE == hFile )
	{

	    //
	    // If we are given an interface to create file, we'll use it,
	    // otherwise use the default mechanism to create it
	    //
	    if ( pCreateFile ) {
	        hFile = pCreateFile->CreateFileHandle( pchFileName );
	    } else {
		    hFile = CreateFile( pchFileName,
			            		fWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
					            FILE_SHARE_READ, NULL, OPEN_EXISTING,
					            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );
		}

		if ( INVALID_HANDLE_VALUE == hFile )
		{
			//  Only legitimate reason for coming here is non-existent file.
            //
			if (  GetLastError() != ERROR_FILE_NOT_FOUND
               && GetLastError() != ERROR_PATH_NOT_FOUND )
			{
				// Error case
                //
				m_pv = NULL;
			}
			return;
		}
	}

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pchFileName, -1,
												 m_rgwchFileName, MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	return;
}

/* ------------------------------------------------------------------------
  CMapFile::CMapFile
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFile::CMapFile( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease, BOOL fZero )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
#ifndef	UNIT_TEST
    numMapFile++;
#endif
	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease, fZero );

	return;
}


/* ------------------------------------------------------------------------
  CMapFile::~CMapFile
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFile::~CMapFile( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//
#ifndef	UNIT_TEST
    numMapFile--;
#endif

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pv )
		{
			UnmapViewOfFile( m_pv );
		}
	}
	return;
}



/* ------------------------------------------------------------------------
  CMapFile::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFile::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease, BOOL fZero )
{

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.
	}

#if 1
    if ( cbIncrease )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbNewSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }
#endif

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( hFile, NULL,
                                 fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, cbNewSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pv = MapViewOfFile( hFileMap,
                                 fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !m_pv )
	{
        // Error case
        //
		m_pv = NULL;
		m_cb = 0;			// Also set to zero, just in case.

	}

	if( fZero && cbIncrease )
	{
		// zero out the part grown
		DWORD cbOldSize = cbNewSize - cbIncrease;
		ZeroMemory( (LPVOID)((LPBYTE)m_pv + cbOldSize), cbNewSize - cbOldSize );
	}

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );
	

    return;

}




/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	14:21 on Mon 20 Feb 1995    -by-    Lindsay Harris   [lindsayh]
  	Amended to use unicode file name.

	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  WCHAR  *pwchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//
    VOID    *pvRet;				// Returned to caller
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFileW( pwchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
		    // Error case
    	}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.

  Author
  	Lindsay Harris	- lindsayh

  History
	10:18 on Tue 29 Nov 1994    -by-    Lindsay Harris   [lindsayh]
  	Made a separately compiled module.

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile( DWORD  *pdwSize, const  char  *pchFileName, BOOL bWriteEnable )
{
	//
	// Cook book formula.
	//

    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;			// Used during operations, closed before return
    HANDLE   hFile;				// Ditto.


    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
    	//  Only legitimate reason for coming here is non-existent file.
        //
    	if (  GetLastError() != ERROR_FILE_NOT_FOUND
           && GetLastError() != ERROR_PATH_NOT_FOUND )
    	{
			// Error case
            //
		}
        return NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
    if ( pdwSize )
		*pdwSize = GetFileSize( hFile, NULL );


    //
    // Create the mapping object.
    //
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, 0, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
		_ASSERT( fClose ) ;

        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		// Error case
        //
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose || hFileMap == 0 ) ;
	fClose = CloseHandle( hFile );
	_ASSERT( fClose || hFile == INVALID_HANDLE_VALUE ) ;

    return  pvRet;

}



/* -------------------------------------------------------------------------
  pvFromHandle
  	Creates a mapped file from an file handle. Does not close that handle.

  History

  	21 Dec 1994 	-by-	Carl Kadie		 [carlk]
	Based on pvMapFile code by Lindsay Harris   [lindsayh]

   ------------------------------------------------------------------------- */

void *
pvFromHandle( HANDLE hFile,
              BOOL bWriteEnable,        // If the file is to be writeable
              DWORD  * pdwSizeFinal,    // If not Null, returns the final size of the file
              DWORD dwSizeIncrease )    // Use 0 if the size is not to increase
{
	DWORD dwSize;
    VOID    *pvRet;				/* Returned to caller */
    HANDLE   hFileMap;


	dwSize = GetFileSize( hFile, NULL ) + dwSizeIncrease;
    if ( pdwSizeFinal )
	{
		*pdwSizeFinal = dwSize;
	}

	// If the ultimate size of the file is 0, then return NULL. The
	// calling program may decide that this is OK.
    //
	if ( !dwSize)
	{
		return NULL;
	}

#if 1
    if ( dwSizeIncrease )
    {
        _ASSERT(bWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == (fpos = SetFilePointer( hFile, dwSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            BOOL fClose = CloseHandle( hFile );           // No handle leaks.
            return NULL;
        }
    }
#endif

    //
    // Create the mapping object.
    //								
    hFileMap = CreateFileMapping( hFile, NULL,
                                 bWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                                 0, dwSize, NULL );

    if ( !hFileMap )
    {
		// Error case
        //
        BOOL fClose = CloseHandle( hFile );           // No handle leaks.
        return NULL;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    pvRet = MapViewOfFile( hFileMap,
                                 bWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
                                 0, 0, 0 );

	if ( !pvRet )
	{
		//  Log the error,  but continue, which returns the error.
        //
#if 0
		char	rgchErr[ MAX_PATH + 32 ];
		wsprintf( rgchErr, "MapViewOfFile" );
		LogErrorEvent( MSG_GEN_FAIL, rgchErr, "pvFromHandle" );
#endif
	}

    //
    // Now that we have our pointer, we can close the file and the
    // mapping object.
    //

    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose ) ;

	return pvRet;
}

/* -------------------------------------------------------------------------
  pvMapFile
  	Map a file into memory and return the base address, NULL on failure.
	Also, allows the file to be grown.

  History

  	11:08 on Tue 18 Oct 1994	-by-	Carl Kadie		 [carlk]
	Generalize pvMapFile to add support for adding to the file

	10:55 on Mon 10 Oct 1994    -by-    Lindsay Harris   [lindsayh]
  	Added FILE_FLAG_SEQUENTIAL_SCAN to speed up directory reading.

	17:38 on Wed 06 Jul 1994    -by-    Lindsay Harris   [lindsayh]
    Make write enable code functional; clean up some old ideas.

    15:35 on Wed 06 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	Adding this comment, written some time back.

   ------------------------------------------------------------------------- */

void *
pvMapFile(	const char  * pchFileName,		// The name of the file
			BOOL bWriteEnable,		// If the file is to be writeable
 			DWORD  * pdwSizeFinal, // If not Null, returns the final size of the file
			DWORD dwSizeIncrease )     // Use 0 if the size is not to increase
{
	//
	// Cook book formula.
	//
    HANDLE   hFile;
    VOID    *pvRet;				/* Returned to caller */
	
	// If the file is to grow, it only makes sense to open it read/write.
    //
	if (0 != dwSizeIncrease && !bWriteEnable)
	{
		return NULL;
	}

    hFile = CreateFile( pchFileName,
                 bWriteEnable ? (GENERIC_READ | GENERIC_WRITE) : GENERIC_READ,
                 FILE_SHARE_READ, NULL, OPEN_ALWAYS,  //changed from open_existing
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        return  NULL;
    }

    //
    // If the caller wants to know the size (usually does) then get it now.
    //
	pvRet = pvFromHandle(hFile, bWriteEnable, pdwSizeFinal, dwSizeIncrease);

	BOOL fClose = CloseHandle( hFile );
	_ASSERT( fClose ) ;

    return  pvRet;
}

#ifdef DEBUG
//
//	CMapFileEx: version with guard pages to be used only in DEBUG builds
//	to catch other threads writing into our memory !
//

/* ------------------------------------------------------------------------
  CMapFileEx::CMapFileEx
  	Constructor when a file handle is available rather than a name.
	Note that it does not closes the handle

  Author
  	Lindsay Harris	- lindsayh

  History
	16:14 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version to allow object tracking.  Based on CarlK's function.

   ------------------------------------------------------------------------ */

CMapFileEx::CMapFileEx( HANDLE hFile, BOOL fWriteEnable, BOOL fTrack, DWORD cbIncrease )
{
	m_pv = NULL;
	m_cb = 0;				// Set defaults.
	m_fFlags = 0;			// None set yet.
	m_hFile = INVALID_HANDLE_VALUE;
	m_pvFrontGuard = NULL;
	m_cbFrontGuardSize = 0;
	m_pvRearGuard = NULL;
	m_cbRearGuardSize = 0;
	InitializeCriticalSection(&m_csProtectMap);

	wcsncpy( m_rgwchFileName, L"<name unavailable - from handle>", MAX_PATH );

	MapFromHandle( hFile, fWriteEnable, cbIncrease );

	m_hFile = hFile;

	return;
}


/* ------------------------------------------------------------------------
  CMapFileEx::~CMapFileEx
  	Destructor.  Two purposes, being to unmap the file, and optionally
  	remove it from the track data.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

CMapFileEx::~CMapFileEx( void )
{
    //
	// Unmap the file, if we succeeded in mapping it first!
	//

	//   Lock
	EnterCriticalSection(&m_csProtectMap);

	if ( !(m_fFlags & MF_RELINQUISH) )
	{
		//   We're still controlling this file, so stick with it.
        //
		if ( m_pvFrontGuard )
		{
			_ASSERT( m_pvFrontGuard && m_pv && m_pvRearGuard );
			_ASSERT( m_cbFrontGuardSize && m_cb && m_cbRearGuardSize );

			// get rid of guard pages
			DWORD dwOldProtect = PAGE_READONLY | PAGE_GUARD;
			if(!VirtualProtect(
						(LPVOID)m_pvFrontGuard,
						m_cbFrontGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pv,
						m_cb,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1==0 );
				goto CMapFileEx_Exit ;
			}

			if(!VirtualProtect(
						(LPVOID)m_pvRearGuard,
						m_cbRearGuardSize,
						PAGE_READWRITE,
						&dwOldProtect
						))
			{
				_ASSERT( 1== 0 );
				goto CMapFileEx_Exit ;
			}

			MoveMemory( m_pvFrontGuard, m_pv, m_cb );

			FlushViewOfFile( m_pvFrontGuard, m_cb ) ;

			UnmapViewOfFile( (LPVOID)m_pvFrontGuard );

			if( INVALID_HANDLE_VALUE != m_hFile )
			{
				if( SetFilePointer( m_hFile, m_cb, NULL, FILE_BEGIN ) == m_cb ) 
				{
					SetEndOfFile( m_hFile ) ;
				}
			}

			m_pvFrontGuard = m_pvRearGuard = m_pv = NULL ;
			m_cbFrontGuardSize = m_cb = m_cbRearGuardSize = 0;
		}
	}

CMapFileEx_Exit:

	LeaveCriticalSection(&m_csProtectMap);

	DeleteCriticalSection(&m_csProtectMap);

	return;
}



/* ------------------------------------------------------------------------
  CMapFileEx::MapFromHandle
  	Does the real work of mapping.  Given a handle to the file, go through
  	the motions of mapping, and recording what happens.  Reports errors
  	as needed.  Also adjusts file size if requested.

  Author
  	Lindsay Harris	- lindsayh
  	Carl Kadie		- carlk

  History
	16:30 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	First version, based on older code with CarlK enhancements.

   ------------------------------------------------------------------------ */

void
CMapFileEx::MapFromHandle( HANDLE hFile, BOOL fWriteEnable, DWORD cbIncrease )
{
	BOOL fErr = FALSE;

	if ( !fWriteEnable && cbIncrease != 0 )
		return;				// This is non-sensical.

	m_cb = GetFileSize( hFile, NULL );

	DWORD	cbNewSize = 0;
	DWORD	cbOldSize = 0;

	//
	// Determine if the file is to grow.  Only pass a non-zero size
	// to the system if the size is growing - it's probably faster, and
	// the most likely common case.
	//
	if ( cbIncrease )
	{
		cbNewSize = m_cb += cbIncrease;
	}
	else
	{
		if ( m_cb == 0 )
			return;				// Nothing there.

		// In the guard page version we always grow the file by 2*GuardPageSize !
		cbNewSize = m_cb;
	}

	//
	// Add guard page logic
	//
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	DWORD dwPageSize = si.dwPageSize ;
	DWORD dwGuardPageSize = si.dwAllocationGranularity;

	// GuardPageSize should be > cbNewSize
	while( cbNewSize > dwGuardPageSize )
	{
		dwGuardPageSize += si.dwAllocationGranularity;
	}

	// cbNewSize should be a multiple of dwPageSize, to ensure rear guard page is properly aligned
	_ASSERT( (cbNewSize % dwPageSize) == 0 ) ;

	DWORD cbAllocSize = (2 * (dwGuardPageSize)) + cbNewSize;
	DWORD dwOldProtect = PAGE_READWRITE ;
	DWORD dwError;

	//
	//	Grow the file to match the size of memory mapping
	//

    if ( cbIncrease || cbAllocSize )
    {
        _ASSERT(fWriteEnable);

        //
        // Make sure the file is the correct size.
        //
        DWORD fpos;
        BOOL  fSetEnd;
        if ( (DWORD)-1 == ( fpos = SetFilePointer( hFile, cbAllocSize, NULL, FILE_BEGIN ))
           || !(fSetEnd = SetEndOfFile( hFile ))
           )
        {
            //
            // Error case
            //
            m_pv = NULL;
            return;
        }
    }

    //
    // Create the mapping object.
    //
	HANDLE hFileMap;				// Intermediate step.

    hFileMap = CreateFileMapping( 
							hFile, 
							NULL,
                            fWriteEnable ? PAGE_READWRITE : PAGE_READONLY,
                            0, 
							cbAllocSize,	// NOTE: this is greater than cbNewSize by 2*GuardPageSize
							NULL 
							);

    if ( !hFileMap )
    {
		// Error case
        //
		m_pv = NULL;
		m_cb = 0;
        return;
    }

    //
    // Get the pointer mapped to the desired file.
    //
    m_pvFrontGuard = (LPBYTE)MapViewOfFile( 
									hFileMap,
									fWriteEnable ? FILE_MAP_WRITE : FILE_MAP_READ,
									0, 0, 0
									);

	if ( !m_pvFrontGuard )
	{
		//
        // Error case
        //
		fErr = TRUE;
		goto MapFromHandle_Exit;
	}

	// zero out the part grown
	cbOldSize = cbNewSize - cbIncrease;
	ZeroMemory( m_pvFrontGuard + cbOldSize, cbAllocSize - cbOldSize );

	// front guard page of size (64KB)
	m_cbFrontGuardSize = dwGuardPageSize ;

	// actual memory-mapping
	m_pv = m_pvFrontGuard + m_cbFrontGuardSize ;
	MoveMemory( m_pv, m_pvFrontGuard, cbNewSize );

	// rear guard page of size (64KB)
	m_pvRearGuard  = m_pv + cbNewSize ;
	m_cbRearGuardSize = m_cbFrontGuardSize ;

	// zero out the front and rear guard pages
	ZeroMemory( m_pvFrontGuard, m_cbFrontGuardSize );
	ZeroMemory( m_pvRearGuard,  m_cbRearGuardSize );

	// make front page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvFrontGuard,
				m_cbFrontGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}

	// make mapping read-only; users of CMapFileEx will need to use the
	// UnprotectMapping() / ProtectMapping() calls to write to this mapping.
	if(!VirtualProtect(
				(LPVOID)m_pv,
				cbNewSize,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}

	// make rear page a guard page
	if(!VirtualProtect(
				(LPVOID)m_pvRearGuard,
				m_cbRearGuardSize,
				PAGE_READONLY | PAGE_GUARD,
				&dwOldProtect
				))
	{
		Cleanup();
		fErr = TRUE;
		goto MapFromHandle_Exit ;
	}


MapFromHandle_Exit:

	dwError = GetLastError();

    //
    // Now that we have our pointer, we can close the mapping object.
    //
    BOOL fClose = CloseHandle( hFileMap );
	_ASSERT( fClose );
	
	// reset all member vars in error cases
	if( fErr )
	{
		m_pvFrontGuard = m_pvRearGuard = m_pv = NULL;
		m_cbFrontGuardSize = m_cbRearGuardSize = m_cb = 0;
		m_hFile = INVALID_HANDLE_VALUE;
	}

    return;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	Change mapping from READONLY to READWRITE when a write is necessary
	**** NOTE: Calls to UnprotectMapping() and ProtectMapping() should be matched ***
	eg:
		{
			UnprotectMapping();

			//
			//	 code to write to the mapping
			//

			ProtectMapping();
		}

	Returns TRUE on success, FALSE on failure
	Lock is held only if returns TRUE

   ------------------------------------------------------------------------ */

BOOL	
CMapFileEx::UnprotectMapping()
{
	DWORD dwOldProtect = PAGE_READONLY;

	// *** This is released in ProtectMapping() ***
	EnterCriticalSection(&m_csProtectMap);

	// enable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READWRITE,
				&dwOldProtect
				))
	{
		LeaveCriticalSection(&m_csProtectMap);
		return FALSE;
	}

	return TRUE;
}

/* ------------------------------------------------------------------------
  CMapFileEx::UnprotectMapping

	This is called to revert the mapping protection back to READONLY
	**** The thread calling this function should have the protect lock *****

	Returns TRUE on success, FALSE on failure
	Lock is released in either case

   ------------------------------------------------------------------------ */

BOOL	
CMapFileEx::ProtectMapping()
{
	DWORD dwOldProtect = PAGE_READWRITE;
	BOOL  fRet = TRUE;

	// disable writes
	if(!VirtualProtect(
				(LPVOID)m_pv,
				m_cb,
				PAGE_READONLY,
				&dwOldProtect
				))
	{
		fRet = FALSE ;
	}

	LeaveCriticalSection(&m_csProtectMap);
	return fRet;
}

/* ------------------------------------------------------------------------
  CMapFileEx::Cleanup
  	Called when MapFromHandle fails - Does the necessary VirtualProtects
	to revert guard pages back and unmap view of file.

  Author
  	Lindsay Harris	- lindsayh

  History
	16:22 on Mon 10 Apr 1995    -by-    Lindsay Harris   [lindsayh]
  	Numero Uno.

   ------------------------------------------------------------------------ */

void
CMapFileEx::Cleanup( void )
{
	_ASSERT( m_pvFrontGuard && m_pv && m_pvRearGuard );
	_ASSERT( m_cbFrontGuardSize && m_cb && m_cbRearGuardSize );

	//
	// get rid of guard pages - make everything PAGE_READWRITE !
	//
	DWORD dwOldProtect = PAGE_READONLY | PAGE_GUARD;
	VirtualProtect( (LPVOID)m_pvFrontGuard, m_cbFrontGuardSize, PAGE_READWRITE, &dwOldProtect);
	VirtualProtect( (LPVOID)m_pv, m_cb, PAGE_READWRITE, &dwOldProtect);
	VirtualProtect( (LPVOID)m_pvRearGuard, m_cbRearGuardSize, PAGE_READWRITE, &dwOldProtect);

	// move data back
	MoveMemory( m_pvFrontGuard, m_pv, m_cb );

	// flush and unmap !
	FlushViewOfFile( m_pvFrontGuard, m_cb ) ;
	UnmapViewOfFile( (LPVOID)m_pvFrontGuard );

	if( INVALID_HANDLE_VALUE != m_hFile )
	{
		if( SetFilePointer( m_hFile, m_cb, NULL, FILE_BEGIN ) == m_cb ) 
		{
			SetEndOfFile( m_hFile ) ;
		}
	}

	m_pvFrontGuard = m_pvRearGuard = m_pv = NULL ;
	m_cbFrontGuardSize = m_cb = m_cbRearGuardSize = 0;

	return;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\datetime.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

      datetime.cxx

   Abstract:

      This module exports common functions for date and time fields,
      Expanding into strings and manipulation.

   Author:

           Murali R. Krishnan    ( MuraliK )    3-Jan-1995

   Project:

      Internet Services Common DLL

   Functions Exported:

      SystemTimeToGMT()
      NtLargeIntegerTimeToSystemTime()

   Revision History:

      MuraliK    23-Feb-1996      Added IslFormatDate()

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include	<stdlib.h>
//#include	"tigris.hxx"
#include "stdinc.h"

#ifndef DBG_ASSERT
#define	DBG_ASSERT( f )		_ASSERT( f )
#endif

#if 0
# include <tcpdllp.hxx>
# include "mainsupp.hxx"
#endif

/************************************************************
 *   Data
 ************************************************************/
static  TCHAR * s_rgchDays[] =  {
    TEXT("Sun"),
    TEXT("Mon"),
    TEXT("Tue"),
    TEXT("Wed"),
    TEXT("Thu"),
    TEXT("Fri"),
    TEXT("Sat") };

static TCHAR * s_rgchMonths[] = {
    TEXT("Jan"),
    TEXT("Feb"),
    TEXT("Mar"),
    TEXT("Apr"),
    TEXT("May"),
    TEXT("Jun"),
    TEXT("Jul"),
    TEXT("Aug"),
    TEXT("Sep"),
    TEXT("Oct"),
    TEXT("Nov"),
    TEXT("Dec") };




/************************************************************
 *    Functions
 ************************************************************/

int
make_month(
    TCHAR * s
    )
{
    int i;

    for (i=0; i<12; i++)
        if (!_strnicmp(s_rgchMonths[i], s, 3))
            return i + 1;
    return 0;
}


BOOL
SystemTimeToGMT(
    IN  const SYSTEMTIME & st,
    OUT CHAR *             pszBuff,
    IN  DWORD              cbBuff
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    DBG_ASSERT( pszBuff != NULL);

    if ( cbBuff < 40 ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    ::wsprintf( pszBuff,
                TEXT( "%s, %02d %s %04d %02d:%02d:%02d GMT"),
                s_rgchDays[st.wDayOfWeek],
                st.wDay,
                s_rgchMonths[st.wMonth - 1],
                st.wYear,
                st.wHour,
                st.wMinute,
                st.wSecond);

    return ( TRUE);

} // SystemTimeToGMT()

BOOL
NtLargeIntegerTimeToLocalSystemTime(
    IN const LARGE_INTEGER * pliTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in Local Time zone.

  Arguments:
    pliTime        pointer to large integer containing the time in NT format.
    pst            pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            27-Apr-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG.
--*/
{
    FILETIME  ftLocal;

    if ( pliTime == NULL || pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    //  Convert the given large integer to local file time and
    //  then convert that to SYSTEMTIME.
    //   structure, containing the time details.
    //  I dont like this cast ( assumes too much about time structures)
    //   but again suitable methods are not available.
    //
    return (FileTimeToLocalFileTime((FILETIME *) pliTime,
                                     &ftLocal) &&
            FileTimeToSystemTime(&ftLocal, pst)
            );

} // NtLargeIntegerTimeToLocalSystemTime()

BOOL
SystemTimeToGMTEx(
    IN  const SYSTEMTIME & st,
    OUT CHAR *      pszBuff,
    IN  DWORD       cbBuff,
    IN  DWORD       csecOffset
    )
/*++
  Converts the given system time to string representation
  containing GMT Formatted String.

  Arguments:
      st         System time that needs to be converted.
      pstr       pointer to string which will contain the GMT time on
                  successful return.
      cbBuff     size of pszBuff in bytes
      csecOffset The number of seconds to offset the specified system time

  Returns:
     TRUE on success.  FALSE on failure.

  History:
     MuraliK        3-Jan-1995
--*/
{
    SYSTEMTIME    sttmp;
    DWORD         dwSeconds = 0;
    ULARGE_INTEGER liTime;
    FILETIME    ft;

    DBG_ASSERT( pszBuff != NULL);

    //
    //  If an offset is specified, calculate that now
    //

    if (!SystemTimeToFileTime( &st, &ft )) {
        return(FALSE);
    }

    liTime.HighPart = ft.dwHighDateTime;
    liTime.LowPart = ft.dwLowDateTime;

    //
    //  Nt Large integer times are stored in 100ns increments, so convert the
    //  second offset to 100ns increments then add it
    //

    liTime.QuadPart += ((ULONGLONG) csecOffset) * (ULONGLONG) 10000000;

    ft.dwHighDateTime = liTime.HighPart;
    ft.dwLowDateTime = liTime.LowPart;

    FileTimeToSystemTime( &ft, &sttmp );

    return SystemTimeToGMT( sttmp,
                            pszBuff,
                            cbBuff );
} // SystemTimeToGMTEx

BOOL
NtLargeIntegerTimeToSystemTime(
    IN const LARGE_INTEGER & liTime,
    OUT SYSTEMTIME * pst)
/*++
  Converts the time returned by NTIO apis ( which is a LARGE_INTEGER) into
  Win32 SystemTime in GMT

  Arguments:
    liTime             large integer containing the time in NT format.
    pst                pointer to SYSTEMTIME structure which contains the time
                         fields on successful conversion.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    MuraliK            3-Jan-1995

  Limitations:
     This is an NT specific function !! Reason is: Win32 uses FILETIME
      structure for times. However LARGE_INTEGER and FILETIME both use
      similar structure with one difference that is one has a LONG while
      other has a ULONG. Will that make a difference ? God knows.
       Or substitute whatever you want for God...
--*/
{
    FILETIME ft;

    if ( pst == NULL) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // convert li to filetime
    //

    ft.dwLowDateTime = liTime.LowPart;
    ft.dwHighDateTime = liTime.HighPart;

    //
    // convert to system time
    //

    if (!FileTimeToSystemTime(&ft,pst)) {
        return(FALSE);
    }

    return ( TRUE);

} // NtLargeIntegerTimeToSystemTime()

BOOL
NtSystemTimeToLargeInteger(
    IN  const SYSTEMTIME * pst,
    OUT LARGE_INTEGER *    pli
    )
{

    FILETIME ft;

    //
    // Convert to file time
    //

    if ( !SystemTimeToFileTime( pst, &ft ) ) {
        return(FALSE);
    }

    //
    // Convert file time to large integer
    //

    pli->LowPart = ft.dwLowDateTime;
    pli->HighPart = ft.dwHighDateTime;

    return(TRUE);
}

BOOL
StringTimeToFileTime(
    IN  const TCHAR * pszTime,
    OUT LARGE_INTEGER * pliTime
    )
/*++

  Converts a string representation of a GMT time (three different
  varieties) to an NT representation of a file time.

  We handle the following variations:

    Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
    Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
    Sun Nov  6 08:49:37 1994        (ANSI C's asctime() format

  Arguments:
    pszTime             String representation of time field
    pliTime             large integer containing the time in NT format.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    Johnl       24-Jan-1995     Modified from WWW library

--*/
{

    TCHAR * s;
    SYSTEMTIME    st;

    if (!pszTime) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    st.wMilliseconds = 0;

    if ((s = strchr(pszTime, ','))) {    /* Thursday, 10-Jun-93 01:29:59 GMT */
        s++;                /* or: Thu, 10 Jan 1993 01:29:59 GMT */
        while (*s && *s==' ') s++;
        if (strchr(s,'-')) {        /* First format */

            if ((int)strlen(s) < 18) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
            st.wDay = (WORD)atoi(s);
            st.wMonth = (WORD)make_month(s+3);
            st.wYear = (WORD)atoi(s+7);
            st.wHour = (WORD)atoi(s+10);
            st.wMinute = (WORD)atoi(s+13);
            st.wSecond = (WORD)atoi(s+16);
        } else {                /* Second format */

            if ((int)strlen(s) < 20) {
                SetLastError( ERROR_INVALID_PARAMETER );
                return FALSE;
            }
            st.wDay = (WORD)atoi(s);
            st.wMonth = (WORD)make_month(s+3);
            st.wYear = (WORD)atoi(s+7);
            st.wHour = (WORD)atoi(s+12);
            st.wMinute = (WORD)atoi(s+15);
            st.wSecond = (WORD)atoi(s+18);

        }
    } else {    /* Try the other format:  Wed Jun  9 01:29:59 1993 GMT */

        s = (TCHAR *) pszTime;
        while (*s && *s==' ') s++;

        if ((int)strlen(s) < 24) {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        st.wDay = (WORD)atoi(s+8);
        st.wMonth = (WORD)make_month(s+4);
        st.wYear = (WORD)atoi(s+22);
        st.wHour = (WORD)atoi(s+11);
        st.wMinute = (WORD)atoi(s+14);
        st.wSecond = (WORD)atoi(s+17);
    }

    //
    //  Adjust for dates with only two digits
    //

    if ( st.wYear < 1000 ) {
        if ( st.wYear < 50 ) {
            st.wYear += 2000;
        } else {
            st.wYear += 1900;
        }
    }

    if ( !NtSystemTimeToLargeInteger( &st,pliTime )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
    return(TRUE);
}


#if 0
/************************************************************
 *  Cached Date Time Formats
 *
 *  Formatting Date and Time for
 *    HTTP headers & Logging Requests
 *    is a costly operation.
 *  Using default NT Formatting operations with wsprintf()
 *    consumes about 6000 instructions/transaction
 *
 *  Following code addresses this issue by
 *   1) Caching formatted date/time pair for all purposes
 *   2) Caching is done at the granularity of seconds/minute
 *      If there is a match till seconds, we return entire
 *        formatted information.
 *      If there is a match till the minutes, then the seconds
 *        portion is over-written using a seconds-lookup-table.
 *
 *   Murali R. Krishnan (MuraliK)   23-Feb-1996
 ************************************************************/

# define ENABLE_AUX_COUNTERS  ( 1)

//
// Seconds lookup table
//
static TCHAR  g_rgchSeconds[60][2] =
{
    '0', '0',
    '0', '1',
    '0', '2',
    '0', '3',
    '0', '4',
    '0', '5',
    '0', '6',
    '0', '7',
    '0', '8',
    '0', '9',

    '1', '0',
    '1', '1',
    '1', '2',
    '1', '3',
    '1', '4',
    '1', '5',
    '1', '6',
    '1', '7',
    '1', '8',
    '1', '9',

    '2', '0',
    '2', '1',
    '2', '2',
    '2', '3',
    '2', '4',
    '2', '5',
    '2', '6',
    '2', '7',
    '2', '8',
    '2', '9',

    '3', '0',
    '3', '1',
    '3', '2',
    '3', '3',
    '3', '4',
    '3', '5',
    '3', '6',
    '3', '7',
    '3', '8',
    '3', '9',

    '4', '0',
    '4', '1',
    '4', '2',
    '4', '3',
    '4', '4',
    '4', '5',
    '4', '6',
    '4', '7',
    '4', '8',
    '4', '9',

    '5', '0',
    '5', '1',
    '5', '2',
    '5', '3',
    '5', '4',
    '5', '5',
    '5', '6',
    '5', '7',
    '5', '8',
    '5', '9'
}; // g_rgchSeconds


//
// The delimiter string is :  <logDelimiterChar><blank>
// The delimiter char should be same as the one used for LOG_RECORD
//   in the file: ilogcls.cxx
//
const TCHAR G_PSZ_LOG_DELIMITER[3] = TEXT(", ");

# define MAX_NUM_CACHED_DATETIME_FORMATS   (10)  // maintain 10 minute history
# define MAX_FORMATTED_DATETIME_LEN        (50)


struct DATETIME_FORMAT_ENTRY {

    SYSTEMTIME stDateTime;

    int    cchOffsetSeconds[dftMax];
    DWORD  cbDateTime[dftMax];
    TCHAR  rgchDateTime[dftMax][ MAX_FORMATTED_DATETIME_LEN];

    VOID CopyFormattedData(IN const SYSTEMTIME * pst,
                           IN DATETIME_FORMAT_TYPE   dft,
                           OUT TCHAR * pchDateTime)
      {
          // copy the formatted date/time information
          memcpy(pchDateTime,
                 rgchDateTime[dft],
                 cbDateTime[dft]
                 );

          if ( stDateTime.wSecond != pst->wSecond) {

              // seconds do not match. update seconds portion alone
              LPTSTR pch = pchDateTime + cchOffsetSeconds[dft];

              DBG_ASSERT( pst->wSecond < 60);
              *pch       = g_rgchSeconds[pst->wSecond][0];
              *(pch + 1) = g_rgchSeconds[pst->wSecond][1];
          }

          return;
      }


    BOOL IsHit( IN const SYSTEMTIME * pst)
      {
          // Ignore seconds & milli-seconds during comparison
          return ( memcmp( &stDateTime, pst,
                          (sizeof(SYSTEMTIME) - 2* sizeof(WORD)))
                  == 0);
      }

    VOID
      GenerateDateTimeFormats(IN const SYSTEMTIME * pst);

}; // struct DATETIME_FORMAT_ENTRY

typedef DATETIME_FORMAT_ENTRY * PDFT_ENTRY;






class CACHED_DATETIME_FORMATS {

  public:

    CACHED_DATETIME_FORMATS(VOID)
    :
# if ENABLE_AUX_COUNTERS
    m_nMisses      ( 0),
    m_nAccesses    ( 0),
# endif // ENABLE_AUX_COUNTERS
    m_pdftCurrent  ( m_rgDateTimes)
      {
          InitializeCriticalSection( &m_csLock);
          memset( m_rgDateTimes, 0, sizeof(m_rgDateTimes));
      }

    ~CACHED_DATETIME_FORMATS(VOID)
      { DeleteCriticalSection( &m_csLock); }


    VOID Lock(VOID)
      { EnterCriticalSection( &m_csLock); }

    VOID Unlock(VOID)
      { LeaveCriticalSection( &m_csLock); }

    DWORD
      GetFormattedDateTime(IN const SYSTEMTIME * pst,
                           IN DATETIME_FORMAT_TYPE   dft,
                           OUT TCHAR * pchDateTime);

  private:

    // m_pdftCurrent points into m_rgDateTimes array
    DATETIME_FORMAT_ENTRY * m_pdftCurrent;

# if ENABLE_AUX_COUNTERS
  public:

    LONG              m_nMisses;
    LONG              m_nAccesses;

  private:
# endif // ENABLE_AUX_COUNTERS

    DATETIME_FORMAT_ENTRY   m_rgDateTimes[ MAX_NUM_CACHED_DATETIME_FORMATS];

    CRITICAL_SECTION    m_csLock;

}; // class CACHED_DATETIME_FORMATS


CACHED_DATETIME_FORMATS * g_pCachedDft;



#ifdef ENABLE_AUX_COUNTERS

# define CdtCountAccesses()  InterlockedIncrement( &g_pCachedDft->m_nAccesses)
# define CdtCountMisses()    InterlockedIncrement( &g_pCachedDft->m_nMisses)

# else  // ENABLE_AUX_COUNTERS

# define CdtCountAccesses()  /* do nothing */
# define CdtCountMisses()    /* do nothing */

# endif // ENABLE_AUX_COUNTERS






VOID
DATETIME_FORMAT_ENTRY::GenerateDateTimeFormats(
    IN const SYSTEMTIME * pst
    )
/*++
  Description:

     This function generates the datetime formats for all predefined
      sequences. It attempts to generate the formatted date/time
      to the accuracy of a minute. If need be the seconds portion
      is obtained by indexing an array.

     This function should be called for a locked pdft entry,
     and the caller should make sure that the structures can be accessed
     freely for update

  Arguments:
     pst  - pointer to system time for which the datetime format is required

  Returns:
     None
--*/
{
    TCHAR rgchTime[25];
    TCHAR * pchDateTime;


    //
    // Format date for Logging (dftLog)
    //  Format is:
    //      <Date><DelimiterString><Time><DelimiterString>
    //
    // We need to generate the date format again, only if it changes
    //

    pchDateTime = rgchDateTime[dftLog];
    if ( memcmp( &stDateTime, pst, 4 * sizeof(WORD)) != 0) {

        DBG_REQUIRE( ::GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                     LOCALE_NOUSEROVERRIDE,
                                     pst, NULL,
                                     pchDateTime,
                                     15)
                    != 0
                    );

        lstrcat( pchDateTime, G_PSZ_LOG_DELIMITER);

        // the time is usually formatted as hh:mm:ss
        // hence offset of seconds is about 6 chars from end of date string
        cchOffsetSeconds[dftLog] = lstrlen(pchDateTime) + 6;

        DBG_ASSERT( pchDateTime == rgchDateTime[dftLog]);
    }

    // format the time portion
    DBG_REQUIRE( ::GetTimeFormat( LOCALE_SYSTEM_DEFAULT,
                                 (LOCALE_NOUSEROVERRIDE |
                                  TIME_FORCE24HOURFORMAT|
                                  TIME_NOTIMEMARKER),
                                 pst, NULL,
                                 rgchTime, 15)
                != 0);


    DBG_ASSERT(lstrlen(rgchTime) + lstrlen( G_PSZ_LOG_DELIMITER) <
               sizeof(rgchTime));
    lstrcat( rgchTime, G_PSZ_LOG_DELIMITER);

    // append time to date generated
    DBG_ASSERT( cchOffsetSeconds[dftLog] - 6 > 0); // range is fine
    lstrcpy(pchDateTime + cchOffsetSeconds[dftLog] - 6,
            rgchTime);

    DBG_ASSERT( lstrlen( pchDateTime) < sizeof( rgchDateTime[dftLog]));

    cbDateTime[dftLog] = (lstrlen( rgchDateTime[dftLog]) + 1) * sizeof(TCHAR);


    //
    // Format date for Logging (dftGmt)
    //  Format is:
    //   Date: <date-time> GMT\r\n
    //
    pchDateTime = rgchDateTime[dftGmt];

    memcpy( pchDateTime, TEXT("Date: "), sizeof(TEXT("Date: ")) - sizeof(TCHAR) );
    pchDateTime += sizeof(TEXT("Date: ")) - sizeof(TCHAR);

    if ( !::SystemTimeToGMT( *pst,
                       pchDateTime,
                       sizeof(rgchDateTime[dftGmt])
                         - sizeof( TEXT("Date: " "\r\n")) ) )
    {
        rgchDateTime[dftGmt][0] = '\0';
    }
    else
    {
        pchDateTime += lstrlen( pchDateTime );

        cchOffsetSeconds[dftGmt] = pchDateTime
                - rgchDateTime[dftGmt]
                - 2         // minus 2 digits for seconds
                - 4;        // minus " GMT"

        memcpy( pchDateTime, TEXT("\r\n"), sizeof(TEXT("\r\n")) );
    }

    cbDateTime[dftGmt] =
      ( lstrlen( rgchDateTime[dftGmt] ) + 1) * sizeof(TCHAR);

    DBG_ASSERT( dftMax == 2);  // there are only 2 date formats to be done now


    // store the valid time now
    memcpy( &stDateTime, pst, sizeof(*pst));

    return;

} // CACHED_DATETIME_FORMATS::GenerateDateTimeFormats()





DWORD
CACHED_DATETIME_FORMATS::GetFormattedDateTime(IN const SYSTEMTIME * pst,
                                              IN DATETIME_FORMAT_TYPE   dft,
                                              OUT TCHAR * pchDateTime)
/*++
  This function obtains formatted string for date specified in *pst.

  It uses a cache to do lookup for the formatted date and time.

  If all entries fail, then it calls the Formatting functions to
    generate a new format.

  It has been experimentally determined that the cost of formatting is too
    high and hence we resort to caching and this comprehensive lookup function.

  Also this function is NOT a GENERAL PURPOSE DATE-FORMAT cacher.
   We cache with the ASSUMPTION that the date format requests will be for
   consecutive time intervals.

  Arguments:
    pst   - pointer to SYSTEMTIME
    dft   - enumerated value indicating the type of format request
    pchDateTime - pointer to character buffer into which the formatted
                     date will be copied.

  Returns:
    TRUE on success. FALSE if there is any error.
--*/
{
    PDFT_ENTRY  pdft;
    DWORD cbFmt;

    DBG_ASSERT( pst != NULL && pchDateTime != NULL);

    CdtCountAccesses();

    //
    // 1. Fast lookup to retrieve the formatted date for current item
    //
    //   Since dates are stored in sequential order, we look in
    //    the linear fashion, scanning backward first and then scanning forward
    //  TBD: This code needs to be improved based on proximity of search.
    //

    Lock();

    for ( pdft = m_pdftCurrent;
          pdft >= m_rgDateTimes;
          pdft--
         ) {

        if ( pdft->IsHit(pst)) {

            //
            // The date time format is valid. Copy formatted date time.
            // It is assumed that the buffer has sufficient space for
            //   the formatted date
            //

            pdft->CopyFormattedData(pst, dft, pchDateTime);
            cbFmt = pdft->cbDateTime[dft];

            Unlock();
            return (cbFmt);
        }

    } // for ( backward scan)

    // forward scan
    for ( pdft = m_pdftCurrent + 1;
          pdft < m_rgDateTimes + MAX_NUM_CACHED_DATETIME_FORMATS;
          pdft++
         ) {

        if ( pdft->IsHit(pst)) {

            //
            // The date time format is valid. Copy formatted date time.
            // It is assumed that the buffer has sufficient space for
            //   the formatted date
            //

            pdft->CopyFormattedData(pst, dft, pchDateTime);
            cbFmt = pdft->cbDateTime[dft];

            Unlock();
            return (cbFmt);
        }

    } // for ( forward scan)


    //
    // 3. Even an exhaustive search missed the date format.
    //  It is time to get into dirty part of thework
    //  Generate the date formats anew and cache them.
    //

    pdft = m_pdftCurrent;

    // circular shift the current pointer
    pdft = (((pdft - m_rgDateTimes) == (MAX_NUM_CACHED_DATETIME_FORMATS - 1)) ?
            m_rgDateTimes : pdft + 1);

    pdft->GenerateDateTimeFormats( pst);

    // change the current pointer atomically to new one
    m_pdftCurrent = pdft;

    // copy off the formatted date into current buffer
    pdft->CopyFormattedData(pst, dft, pchDateTime);
    cbFmt = pdft->cbDateTime[dft];

    Unlock();

    CdtCountMisses();
    return ( cbFmt );

} // CACHED_DATETIME_FORMATS::GetFormattedDateTime()



DWORD
IslInitDateTimesCache( VOID)
{

    g_pCachedDft = XNEW CACHED_DATETIME_FORMATS();

    return (( g_pCachedDft == NULL) ? ERROR_NOT_ENOUGH_MEMORY: NULL);

} // IslInitDateTimesCache()



VOID
IslCleanupDateTimesCache( VOID)
{

    XDELETE g_pCachedDft;
    g_pCachedDft = NULL;

} // IslCleanupDateTimesCache()




DWORD
IslFormatDateTime(IN const SYSTEMTIME *  pst,
                  IN DATETIME_FORMAT_TYPE    dft,
                  OUT TCHAR     *        pchDateTime
                  )
/*++
  IslFormatDateTime()

    This function formats the date/time given into a string.
     It should be used only for cacheable dates/times (with temporal locality).
     The function maintains cached entries and attempts to pull the formatted
     entries from cache to avoid penalty of regenerating formatted data.

    This is not a General purpose function.
    It is a function for specific purpose.

--*/
{
    //
    // 1. Obtain the formatted date from global cache
    //    return the strlen() of the data
    //

    return g_pCachedDft->GetFormattedDateTime(pst, dft, pchDateTime)
            - 1;

} // IslFormatDateTime()

#endif


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\frmstore.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fromclnt.cpp

Abstract:

	Contains InFeed, Article, and Fields code specific to FromStore Infeeds

	As the name suggests, these for for processing articles that come from
	clients. The idea is to be very strict in what is allowed from the client.
	If an article doesn't match spec, it is either fixed or rejected.


Author:

    Carl Kadie (CarlK)     05-Dec-1995

Revision History:

--*/

#ifdef  _NO_TEMPLATES_
#define DEFINE_CGROUPLST_FUNCTIONS
#endif

#include "stdinc.h"
//#include <artcore.h>
//#include    <stdlib.h>

#define FROMSTOREART_SIGNATURE  (DWORD) 'ArtC'

//
// CPool is used to allocate memory while processing an article.
//

CPool  CFromStoreArticle::g_ArticlePool(FROMSTOREART_SIGNATURE);

//
//  Largest possible CFromStoreArticle derived object
//
#define MAX_ARTICLE_SIZE    sizeof( CFromStoreArticle )

//
// An upperbound on the number of article objects that can
// exist at any time.
//
const   unsigned    cbMAX_ARTICLE_SIZE = MAX_ARTICLE_SIZE ;

void*
CFromStoreArticle::operator      new(    size_t  size )
{
        _ASSERT( size <= cbMAX_ARTICLE_SIZE ) ;
        return  g_ArticlePool.Alloc() ;
}

void
CFromStoreArticle::operator      delete( void*   pv )
{
        g_ArticlePool.Free( pv ) ;
}

BOOL
CFromStoreArticle::InitClass(
					void
					)
/*++

Routine Description:

    Preallocates memory for CArticle objects

Arguments:

    None.

Return Value:

    TRUE, if successful. FALSE, otherwise.

--*/
{
	return	g_ArticlePool.ReserveMemory( MAX_ARTICLES, cbMAX_ARTICLE_SIZE ) ;
}


BOOL
CFromStoreArticle::TermClass(
					void
					)
/*++

Routine Description:

    Called when objects are freed.

Arguments:

    None.

Return Value:

    TRUE

--*/
{

	_ASSERT( g_ArticlePool.GetAllocCount() == 0 ) ;

	BOOL b;

	b =	g_ArticlePool.ReleaseMemory() ;
    //delete g_ArticlePool;
    return b;

}


BOOL
CFromStoreArticle::fValidate(
							//CPCString& pcHub,
							//const char * szCommand,
							//CInFeed*	pInFeed,
							CNntpReturn & nntpReturn
							)
/*++

Routine Description:

	Validates an article from a client. Does not change the article
	except to fix (if necessary) the capitalization of some header keywords.

Arguments:

	szCommand - The arguments (if any) used to post/xreplic/etc this article.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// Check article state
	//

	_ASSERT(asPreParsed == m_articleState);

#if 0
	char chBad;
	if (!m_pcHeader.fCheckTextOrSpace(chBad))
		return nntpReturn.fSet(nrcArticleBadChar,  (BYTE) chBad, "header");
#endif

    //
    // Check required and optional fields
    //

	CField * rgPFields [] = {
            &m_fieldControl,
			&m_fieldSubject,
			&m_fieldNewsgroups,
			&m_fieldDistribution,
			&m_fieldFrom,
			&m_fieldDate,
			&m_fieldFollowupTo,
			&m_fieldReplyTo,
			&m_fieldApproved,
			&m_fieldSender,
			&m_fieldOrganization,
			&m_fieldSummary,
			&m_fieldReferences,
			&m_fieldLines,
			&m_fieldKeyword,
			&m_fieldExpires,
			&m_fieldPath,
			//&m_fieldNNTPPostingHost,  // forget about NNTP Posting Host for now...
			&m_fieldMessageID	// must be last - as we may not want to parse it !
				};
	DWORD cFields = sizeof(rgPFields)/sizeof(CField *);

#if 0
	if( !gHonorStoreMessageIDs ) {
		cFields -- ;
	}
#endif

    // By default, we honor Message-Id
    cFields;

	if (!fFindAndParseList((CField * *) rgPFields, cFields, nntpReturn))
	{
    	return (nntpReturn.fFalse());
        //return FALSE;
    }

	CPCString	pcDate = m_fieldDate.pcGet() ;
	if( pcDate.m_pch != 0 ) {

		if( !AgeCheck( pcDate ) ) {
			nntpReturn.fSet( nrcArticleDateTooOld ) ;
			return	FALSE ;
		}
	}

/*
	LPSTR	lpstrMessageId = m_fieldMessageID.szGet() ;
	if( lpstrMessageId != 0 && *lpstrMessageId != '\0' ) {
		if (m_pInstance->ArticleTable()->SearchMapEntry(lpstrMessageId)
			|| m_pInstance->HistoryTable()->SearchMapEntry(lpstrMessageId))
		{
			nntpReturn.fSet(nrcArticleDupMessID, lpstrMessageId, GetLastError());
			return nntpReturn.fFalse();
		}
	}
*/

	//
	// Confirm (and fix, if necessary) the capitalization of the fields
	//

	if (!fConfirmCapsList((CField * *) rgPFields, cFields, nntpReturn))
		return nntpReturn.fFalse();
        //return FALSE;
//
	//!!!CLIENT LATER Not doing anything with control messages
	//

	/* !!!CLIENT LATER
	Body
	SHOULD limit signatures -- !!!LATER
	Early  difficulties in inferring return addresses from article headers led to "signatures": short closing texts,  automatically  added  to  the end of articles by posting agents, identifying the poster and giving his network addresses etc.  If  a  poster

 or posting agent does append a signature to an article, the signature SHOULD be preceded with  a  delimiter line  containing  (only)  two hyphens (ASCII 45) followed by one blank (ASCII  32).   Posting  agents  SHOULD  limit  the length  of  signatures

 since  verbose  excess bordering on abuse is common if no restraint is imposed;  4  lines  is  a common limit.

	Whole Article
	No NULL character allowed
	Header and body lines MAY contain any ASCII characters other than CR (ASCII 13), LF (ASCII 10), and NUL (ASCII 0).
	NO char > oct 127 allowed (unless co-operating)
	Articles  MUST  not  contain  any octet with value exceeding 127, i.e. any octet that is not an ASCII character.
	Limit to 60K -- LATER
	Posters SHOULD limit  posted  articles  to  at  most  60,000 octets,  including  headers  and EOL representations, unless the articles are being posted only within a cooperating sub-net which is known to be capable of handling larger articles gracefully.


  Posting agents presented with a  large  article SHOULD warn the poster and request confirmation.
	*/

	return nntpReturn.fSetOK();
}


BOOL
CFromStoreArticle::fMungeHeaders(
							 CPCString& pcHub,
							 CPCString& pcDNS,
							 //CNAMEREFLIST & grouplist,
							 DWORD remoteIpAddress,
							 CNntpReturn & nntpReturn
			  )

/*++

Routine Description:

	Modify the headers of the article.

Arguments:

	grouplist - A list: for each newsgroup its name, and the article number in that group.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	/* !!!CLIENT LATER
	Must validate encodings see From parsing
	Posting agents MUST ensure that any material  resembling  an  encoded  word (complete  with  all delimiters), in a context where encoded words may appear, really is an encoded word.

	*/

	if (!(
  			   m_fieldMessageID.fSet(*this, pcDNS, nntpReturn)
  			&& m_fieldNewsgroups.fSet(*this, nntpReturn)
  			&& m_fieldDistribution.fSet(*this, nntpReturn)
  			&& m_fieldDate.fSet(*this, nntpReturn)
  			&& m_fieldLines.fSet(*this, nntpReturn)
  			&& m_fieldOrganization.fSet(*this, nntpReturn)
  			&& m_fieldPath.fSet(*this, pcHub, nntpReturn)
			/*&& m_fieldXref.fSet(pcHub, grouplist, *this, m_fieldNewsgroups, nntpReturn)*/
			&& m_fieldNNTPPostingHost.fSet(*this, remoteIpAddress, nntpReturn)
			/* && m_fieldXAuthLoginName.fSet(*this, nntpReturn) */
			&& fDeleteEmptyHeader(nntpReturn)
			&& fSaveHeader(nntpReturn)
		))
		return nntpReturn.fFalse();

	return nntpReturn.fSetOK();
}



BOOL
CFromStoreArticle::fCheckBodyLength(
				 CNntpReturn & nntpReturn
				 )
/*++

Routine Description:

	Checks if the length of the body is within bounds.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	//!!!CLIENT NEXT need to add a real body length check here
	//

	return nntpReturn.fSetOK();
}



BOOL
CFromStoreNewsgroupsField::fSet(
				   				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Rewrites the Newsgroups line, fixing some problems such as
	extra whitespace and duplicates.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsParsed == m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is the size of the old line
	//

	const DWORD cchMaxNewsgroups =
			(m_pHeaderString->pcLine).m_cch
			+ 2 // for the newline
			+ 1; // for a terminating null


	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxNewsgroups);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Newsgroups: "
	//

	pcLine << szKwNewsgroups << (char) ' ';

	//
	// Loop through the newsgroups
	//

	_ASSERT(0 < cGet());//real
	char const * szNewsgroup = multiSzGet();
	do
	{

	//
	// Start with newsgroup name, then add comma
	//

//		pcLine << szDownCase((char *)szNewsgroup, szNewsgroupBuf) << (char) ',';
		pcLine << szNewsgroup << (char) ',';

		//
		// go to first char after next null
		//

		while ('\0' != szNewsgroup[0])
			szNewsgroup++;
		szNewsgroup++;
	} while ('\0' != szNewsgroup[0]);

	//
	// Remove the last ","
	//

	pcLine.vSkipEnd(1);

	pcLine	<< "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxNewsgroups-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwNewsgroups, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromStoreDistributionField::fSet(
				   				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Rewrites the Distribution line, fixing some problems such as
	extra whitespace and duplicates.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// If it was not found exists, then just return
	//

	if (fsNotFound == m_fieldState)
		return nntpReturn.fSetOK();


	//
	// Otherwise, fix up what was found.
	//

	//
	// Check article state
	//

	_ASSERT(fsParsed == m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is the size of the old line
	//

	const DWORD cchMaxDistribution =
			(m_pHeaderString->pcLine).m_cch
			+ 2 // for the newline
			+ 1; // for a terminating null


	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxDistribution);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Distribution: "
	//

	pcLine << szKwDistribution << (char) ' ';

	//
	// Loop through the Distribution
	//

	_ASSERT(0 <= (int)cGet());//real
	char const * szDistributrionValue = multiSzGet();
	do
	{

	//
	// Start with distribution value and add comma
	//

//		pcLine << szDownCase((char *)szDistributrionValue, szDistributrionValueBuf) << ',';
		pcLine << szDistributrionValue << (char) ',';

		//
		// go to first char after next null
		//

		while ('\0' != szDistributrionValue[0])
			szDistributrionValue++;
		szDistributrionValue++;
	} while ('\0' != szDistributrionValue[0]);

	//
	// Remove the last ","
	//

	pcLine.vSkipEnd(1);

	pcLine	<< "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxDistribution-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwDistribution, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}



BOOL
CFromStoreDateField::fSet(
				   				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	If the date field is missing, adds it.


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//
	//
	// If it already exists, then just return
	//

	if (fsParsed == m_fieldState)
		return nntpReturn.fSetOK();


	//
	// Otherwise, add it.
	//

	_ASSERT(fsNotFound == m_fieldState);//real
	CPCString pcLine;

	//
	// max size needed is
	//

	const DWORD cchMaxDate =
			STRLEN(szKwDate)	// for the Date keyword
			+ 1					// space following the keyword
			+ cMaxArpaDate		// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxDate);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	char szDateBuf[cMaxArpaDate];

	//
	// Start with "Date: ", then add the date and the newline
	//

	pcLine << szKwDate << (char) ' ' << (GetArpaDate(szDateBuf)) << "\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxDate-1 >= pcLine.m_cch);//real

	if (!article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);
		nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}

/*
Organization: Optional  But if not and default is given, create
The Organization header content is a short phrase  identify-ing the posters organization:
Organization-content = nonblank-text
This header is typically supplied by the posting agent.  The Organization content SHOULD  mention  geographical  location (e.g.  city  and  country)  when  it is not obvious from the organization?s name.  policy.  Posting agents SHOULD permit the poster t


o override a local default Organization header.
*/

BOOL
CFromStoreOrganizationField::fSet(
   				   				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Optional, But if not given my user and default is given, create


Arguments:

	country -


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

//
//!!!CLIENT NEXT - add this code
//

	return nntpReturn.fSetOK();
}

//
//!!!constize
//

/*
Restricted Syntax
The  From header contains the electronic address, and possibly the full name, of the articles author:
From-content  = address [ space "(" paren-phrase ")" ]
/  [ plain-phrase space ] "<" address ">"
paren-phrase  = 1*( paren-char / space / encoded-word )
paren-char    = <ASCII printable character except ()<>\>
plain-phrase  = plain-word *( space plain-word )
plain-word    = unquoted-word / quoted-word / encoded-word
unquoted-word = 1*unquoted-char
unquoted-char = <ASCII printable character except !()<>@,;:\".[]>
               quoted-word   = quote 1*( quoted-char / space ) quote
               quote         = <" (ASCII 34)>
               quoted-char   = <ASCII printable character except "()<>\>
               address       = local-part "@" domain
               local-part    = unquoted-word *( "." unquoted-word )
               domain        = unquoted-word *( "." unquoted-word )

(Encoded words are described in section 4.5.)  The full name is  distinguished  from  the  electronic  address  either by enclosing the former in parentheses (making  it  resemble  a MAIL  comment, after the address) or by enclosing the latter in angle br


ackets.  The second form is  preferred.   In  the first  form, encoded words inside the full name MUST be composed  entirely  of  <paren-char>s.   In  the  second  form, encoded  words  inside the full name may not contain characters other than letters (o

f either case),  digits,  and  the characters "!", "*", "+", "-", "/", "=", and "_".  The local part is case-sensitive (except that all case counterparts of "postmaster"  are  deemed  equivalent),  the domain is case-insensitive, and all other parts of  t


he  From  content  are comments  which  MUST  be  ignored  by news software (except insofar as reading agents may wish to display  them  to  the reader).   Posters  and  posting  agents MUST restrict them-selves to this subset of the MAIL From syntax; rel


ayers  MAY accept  a  broader subset, but see the discussion in section 9.1.
Avoid "!" and "@" in full names
Posters  and  posting agents SHOULD avoid use of the characters "!" and "@" in full names, as they may trigger unwanted header rewriting by old, simple-minded news software.
"." and "," must be quoted
NOTE: Also, the characters "." and ",", not infrequently found in names (e.g., "John  W.  Campbell, Jr."), are NOT, repeat NOT, allowed in an unquoted word.  A From header like the following  MUST  not be written without the quotation marks:
                    From:	"John W. Campbell, Jr." <editor@analog.com>

*/
/*
 Three permissible forms documented in RFC 1036 should be supported.  Full names within this header line can only contain printable ASCII (0x20 to 0x7E) except "(", ")", "<", ">".  The following characters are inadvisable: ",", ":", "@", "!", "/", "=", ";


".  Test cases include non-printable characters, empty header line (can?t be empty), missing/duplicate "@" address delimiter, multiple address, name lists (not supported), missing address, invalid address, inadvisable characters in name, etc.
 */

BOOL
CFromStoreXAuthLoginNameField::fSet(
				 				 CFromStoreArticle & article,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	replace with our value


Arguments:

	article - The article being processed.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsInitialized == m_fieldState);//real
	CPCString pcLine;


	//
	// max size needed is
	//

	const DWORD cchMaxXAuthLoginName =
			STRLEN(szKwXAuthLoginName)	// for the XAuthLoginName keyword
			+ 1					// space following the keyword
			//+ cMaxLoginName		// bound on the data string
            + MAX_PATH		// bound on the data string
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxXAuthLoginName);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "XAuthLoginName: "
	//

	wsprintf(pcLine.m_pch, "%s ", szKwXAuthLoginName);
	pcLine.m_cch = STRLEN(szKwXAuthLoginName)	+ 1;

	//
	// Add the data value and newline
	//

	pcLine << (article.m_szLoginName) << "\r\n";
	pcLine.vMakeSz(); // Terminate the string

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxXAuthLoginName-1 >= pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwXAuthLoginName, nntpReturn)
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.m_pAllocator->Free(pcLine.m_pch);

		return nntpReturn.fFalse();
	}


	return nntpReturn.fSetOK();
}






//
//!!!CLIENT NEXT: In Newsgroups: parse need to check for illegal groups like "control" and "poster"
//

/*
Followup-To: Optional
Email address is not allowed. Like newsgroups line or "poster" (capitalization?)
NOTE: The way to request that followups be  mailed to  a specific address other than that in the From line is  to  supply  "Followup-To: poster"  and  a Reply-To header.  Putting a mailing address in the Followup-To  line  is  incorrect;  posting  agent

should reject or rewrite such headers.
*/
/*
Reply-To: Optional
Must be a valid email address
*/

/*

//
///!!!CLIENT NEXT should Hubname be lower case?
///!!!CLIENT NEXT should Hubname be the domain name (for message id?)
//

/*
Message-ID: Replace any with own
How to create a messageid
5.3. Message-ID
The  Message-ID  header contains the articles message ID, a unique identifier  distinguishing  the  article  from  every other article:
Message-ID-content  = message-id
message-id          = "<" local-part "@" domain ">"
As  with  From addresses, a message IDs local part is case-sensitive and its domain is case-insensitive.  The  "<"  and ">"  are  parts  of the message ID, not peculiarities of the Message-ID header.
NOTE: News message IDs are a restricted subset  of MAIL message IDs.  In particular, no existing news software copes properly with MAIL quoting  conventions  within  the local part, so they are forbid-den.  This is unfortunate, particularly for  X.400 gat

es on gatewaying in section 10.
The domain in the message ID SHOULD  be  the  full  Internet domain name of the posting agent?s host.  Use of the ".uucp" pseudo-domain (for hosts registered in the UUCP maps) or the ".bitnet"  pseudo-domain  (for Bitnet hosts) is permissible, but SHOUL

be avoided.
Posters and posting agents MUST generate the local part of a
message ID using an algorithm which obeys the specified syn-
tax (words separated by ".",  with  certain  characters  not
permitted)  (see  section  5.2  for  details),  and will not repeat itself (ever).  The  algorithm  SHOULD  not  generate message  IDs which differ only in case of letters.  Note the specification in section 6.5 of a recommended convention for indicatin

 subject  changes.  Otherwise the algorithm is up to the implementor.
NOTE: The crucial use of message IDs is to distinguish  circulating  articles  from  each other and from articles circulated recently.  They are  also potentially  useful  as  permanent  indexing keys, hence the requirement for permanent  uniqueness...  b


ut   indexers  cannot  absolutely  rely  on  this because the earlier RFCs  urged  it  but  did  not demand  it.  All major implementations have always generated  permanently-unique   message   IDs   by design,  but  in  some  cases this is sensitive to p


roper administration,  and  duplicates  may  have occurred by accident.
NOTE:  The most popular method of generating local parts is to use the date and time, plus  some  way of distinguishing between simultaneous postings on the same host (e.g. a process number), and  encode them  in a suitably-restricted alphabet.  An olde

but now  less-popular  alternative  is  to  use  a sequence  number,  incremented  each time the host generates a new message ID; this is workable,  but requires  careful  design  to  cope  properly with simultaneous  posting  attempts,  and  is  not  a

robust  in  the presence of crashes and other malfunctions.
NOTE: Some buggy news software  considers  message
IDs  completely case-insensitive, hence the advice
to  avoid  relying  on  case  distinctions.    The
restrictions  placed  on  the  "alphabet" of local
parts and domains in section 5.2 have  the  useful side effect of making it unnecessary to parse message IDs in complex ways to break them into  case-sensitive and case-insensitive portions.

*/
BOOL
CFromStoreMessageIDField::fSet(
				 				 CFromStoreArticle  & article,
								 CPCString & pcHub,
								 CNntpReturn & nntpReturn
								 )
/*++

Routine Description:


	Replaces any messageid field, with a newly created one.


  Form: <1993Jun27.0645330123.1778.343@localmachinename>

Arguments:

	article - The article being processed.
	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{

	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	if( m_fieldState == fsParsed ) {
		return	nntpReturn.fSetOK() ;
	}

	CPCString pcLine;


	//
	// max size needed is
	//

#if 0
	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					// space following the keyword
			+ 5					// <..@>
			+ cMaxMessageIDDate // The message id date
			+ 20				// Two dwords
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ 1; // for a terminating null
#endif

	const DWORD cchMaxMessageID =
			STRLEN(szKwMessageID)	// for the MessageID keyword
			+ 1					// space following the keyword
			+ 4					// <..@>
			+ cMaxMessageIDDate // The message id date
			+ 10				// One dword
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ 1; // for a terminating null

	//
	// The message-id created (without the newlines) must be less than the max
	//

	_ASSERT(cchMaxMessageID - 2 < MAX_MSGID_LEN);

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxMessageID);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "MessageID: <"
	//

	wsprintf(pcLine.m_pch, "%s <", szKwMessageID);
	pcLine.m_cch = STRLEN(szKwMessageID)	+ 2;

	char szMessageIDBuf[cMaxMessageIDDate];

	CArticleRef artRef = article.articleRef();

	pcLine
			//
			// Add the local part
			//
			<< (GetMessageIDDate( artRef.m_groupId, artRef.m_articleId, szMessageIDBuf))
			<< (char) '.'
			//<< (GetCurrentProcessId())
			//<< '.'
			<< (const DWORD) (GetCurrentThreadId())
			//
			// Add '@' and domain and '>' and newline
			//
			<< (char) '@'
			<< pcHub ///!!!CLIENT NEXT I need the local machine rather than the hub
			<< ">\r\n";
	pcLine.vMakeSz(); // terminate the string

	//
	// confirm that we allocated enough memory
	//

	//_ASSERT(cchMaxMessageID-1-STRLEN(szKwMessageID)-1 >= pcLine.m_cch);//real
	_ASSERT(cchMaxMessageID >= pcLine.m_cch+1);//real

	if (!(
  		article.fRemoveAny(szKwMessageID, nntpReturn)//!!!CLIENT NEXT -- this really only needs to be called of state is parsed
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		article.pAllocator()->Free(pcLine.m_pch);
		return nntpReturn.fFalse();
	}


	//
	//Also save the value (without newlines but with room for a terminating
	//a '\0') in m_szMessageID
	//

	DWORD cchMessageID = pcLine.m_cch - 2 - STRLEN(szKwMessageID) - 1;
	strncpy(m_szMessageID, pcLine.m_pch + STRLEN(szKwMessageID)	+ 1, cchMessageID);
	m_szMessageID[cchMessageID] ='\0';
	_ASSERT('<' == m_szMessageID[0] && '>' == m_szMessageID[cchMessageID-1]);


	return nntpReturn.fSetOK();
}


BOOL
CFromStorePathField::fSet(
						   CFromStoreArticle & article,
						   CPCString & pcHub,
						   CNntpReturn & nntpReturn
						   )
/*++

Routine Description:


	Replaces any existing Path header with a newly created one that
	contains only the name of the hub.


Arguments:

	article - The article being processed.
	pcHub - The name of the hub the current machine is part of.
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsInitialized != m_fieldState);//real

	CPCString pcLine;


	//
	// max size needed is
	//

	DWORD	cbOldPath = 0 ;
	if( m_pHeaderString && m_pHeaderString->pcValue.m_pch ) {
		cbOldPath = m_pHeaderString->pcValue.m_cch + 1 ;	//include 1 for extra '!'
	}

	const DWORD cchMaxPath =
			STRLEN(szKwPath)	// for the Path keyword
			+ 1					// space following the keyword
			+ pcHub.m_cch		// the hub name
			+ 2 // for the newline
			+ cbOldPath // in case there already is a path header !
			+ 1; // for a terminating null

	//
	// Allocate memory for line within a PCString.
	//

	pcLine.m_pch  = article.pAllocator()->Alloc(cchMaxPath);
	if (!pcLine.m_pch)
		return nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	//
	// Start with "Path: <hubname>"
	//

	pcLine << szKwPath << (char) ' ' << pcHub ;		//	<< "\r\n";

	if( m_pHeaderString && m_pHeaderString->pcValue.m_pch ) {
		_ASSERT( m_pHeaderString->pcValue.m_cch != 0 ) ;
		pcLine << "!" << (m_pHeaderString->pcValue) ;
	}

	pcLine << "\r\n" ;

	pcLine.vMakeSz();

	//
	// confirm that we allocated enough memory
	//

	_ASSERT(cchMaxPath-1 == pcLine.m_cch);//real

	if (!(
  		article.fRemoveAny(szKwPath, nntpReturn)//!!!CLIENT NEXT -- this really only needs to be called of state is parsed
		&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
		))
	{
		//
		// If anything went wrong, free the memory.
		//

		article.pAllocator()->Free(pcLine.m_pch);

		return nntpReturn.fFalse();
	}

	return nntpReturn.fSetOK();
}


BOOL
CFromStoreNNTPPostingHostField::fSet(
									  CFromStoreArticle & article,
									  DWORD remoteIpAddress,
									  CNntpReturn & nntpReturn
									  )
/*++

Routine Description:

	Behavior is governed by global set by a reg key.
	In any case, this removes any old NNTPPostingHost headers.

	If global is set, a new NNTP-Posting-Host header is added
	else no new header is added. default behavior is to NOT add
	this header.

Arguments:

	article - The article being processed.
	remoteIpAddress - client IP address
	nntpReturn - The return value for this function call



Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//  Forget about NNTP-Posting-Host for now
#if 0
	//
	// Check article state - article validation should have rejected this
    // post if this header was present.
	//

	_ASSERT(fsNotFound == m_fieldState);//real

	//
	//	generate header only if reg key is set
	//	if an error occurs, revert to default behavior
	//
	while ( gEnableNntpPostingHost ) {

		IN_ADDR remoteAddr;
		char szIpAddress [16];
		DWORD cbIpAddr = 0;
		struct hostent* pRemoteHost = NULL;
		DWORD cbRemoteHost = 0;

        // Convert IP to dotted decimal format
        _ASSERT( sizeof(remoteAddr) == sizeof(remoteIpAddress) );
        CopyMemory( (LPVOID)&remoteAddr, (LPVOID)&remoteIpAddress, sizeof(remoteIpAddress) );
	    DWORD dwError = InetNtoa( remoteAddr, szIpAddress);
		_ASSERT( dwError == NO_ERROR);  // since we had given sufficient buffer
		cbIpAddr = lstrlen( szIpAddress );

		//
		// Do a reverse DNS lookup on client IP
		//

		pRemoteHost = gethostbyaddr( (const char FAR*) &remoteIpAddress, sizeof( remoteIpAddress), PF_INET );
		if( pRemoteHost != NULL ) {
			cbRemoteHost = lstrlen( pRemoteHost->h_name ) + 1;
		}

		// calculate length of header
		DWORD cchMaxHost =
				STRLEN(szKwNNTPPostingHost)	// for the NNTPPostingHost keyword
				+ 1							// space following the keyword
				+ cbRemoteHost				// the reverse DNS name followed by space
//				+ 2							// enclosing []
				+ cbIpAddr					// dotted-decimal IP address
				+ 2							// for the newline
				+ 1;						// for a terminating null

		CPCString pcLine;

		//
		// Allocate memory for line within a PCString.
		//

		pcLine.m_pch  = article.pAllocator()->Alloc( cchMaxHost );
		if (!pcLine.m_pch)
			break;

		//
		// NNTP-Posting-Host: <reverse DNS lookup name> <[dotted-decimal IP address]\r\n
		//
		pcLine << szKwNNTPPostingHost << (char) ' ';
		if( pRemoteHost != NULL ) {
			pcLine << pRemoteHost->h_name << (char) ' ';
		}

		pcLine << szIpAddress << "\r\n";
		pcLine.vMakeSz();

		//
		// confirm that we allocated enough memory
		//
		_ASSERT(cchMaxHost-1 == pcLine.m_cch);

		if (!(
  			article.fRemoveAny(szKwNNTPPostingHost, nntpReturn)
			&& article.fAdd(pcLine.sz(), pcLine.pchMax(), nntpReturn)
			))
		{
			//
			// If anything went wrong, free the memory.
			//

			article.pAllocator()->Free(pcLine.m_pch);

			return nntpReturn.fFalse();
		}

		return nntpReturn.fSetOK();
	}

	//
	//	Default behavior - remove NNTP-Posting-Host header if present
	//
	return article.fRemoveAny(szKwNNTPPostingHost, nntpReturn);
#endif

	return nntpReturn.fSetOK();
}


BOOL
CFromStoreDistributionField::fParse(
									 CArticleCore & article,
									 CNntpReturn & nntpReturn
									 )
/*++

Routine Description:

  Parses the Distribution field. Here is the grammer from Son of 1036:

               Newsgroups-content  = newsgroup-name *( ng-delim newsgroup-name )
               newsgroup-name      = plain-component *( "." component )
               component           = plain-component / encoded-word
               plain-component     = component-start *13component-rest
               component-start     = lowercase / digit
               lowercase           = <letter a-z>
               component-rest      = component-start / "+" / "-" / "_"
               ng-delim            = ","


Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	if (!fParseSplit(TRUE, m_multiSzDistribution, m_cDistribution, " \t\r\n,",
			article, nntpReturn))
		return FALSE;

	//
	//Check for duplicates
	//

	DWORD cOldCount = m_cDistribution;
	if (!fMultiSzRemoveDupI(m_multiSzDistribution, m_cDistribution, m_pAllocator))
		nntpReturn.fSet(nrcMemAllocationFailed, __FILE__, __LINE__);

	if( m_cDistribution == 0 ) {
		return	nntpReturn.fSetOK() ;
	}

	//
	// check for illegal characters and substrings in Distribution name
	//

	char const * szDistribution = m_multiSzDistribution;
	do
	{
		if ('\0' == szDistribution[0]
			|| !fTestAComponent(szDistribution)
			)
		return nntpReturn.fSet(nrcArticleFieldIllegalComponent, szDistribution, szKeyword());

		//
		// go to first char after next null
		//

		while ('\0' != szDistribution[0])
			szDistribution++;
		szDistribution++;
	} while ('\0' != szDistribution[0]);

	return nntpReturn.fSetOK();
}

BOOL
CFromStoreLinesField::fParse(
						 CArticleCore & article,
						 CNntpReturn & nntpReturn
						 )
/*++

Routine Description:

	Parses the Lines field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real

	if (!fParseSimple(TRUE, m_pc, nntpReturn))
		return nntpReturn.fFalse();

	char * pchMax = m_pc.pchMax();
	for (char * pch = m_pc.m_pch; pch < pchMax; pch++)
	{
		if (!isdigit(*pch))
			return nntpReturn.fSet(nrcArticleFieldBadChar, (BYTE) *pch, szKeyword());
	}

	return nntpReturn.fSetOK();
}

BOOL
CFromStoreReferencesField::fParse(
								   CArticleCore & article,
								   CNntpReturn & nntpReturn
								   )
/*++

Routine Description:

	Parses the References field.

Arguments:

	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Check article state
	//

	_ASSERT(fsFound == m_fieldState);//real

	_ASSERT(m_pHeaderString); //real


	//
	// Record the allocator
	//

	m_pAllocator = article.pAllocator();

	if (!fParseSplit(FALSE, m_multiSzReferences, m_cReferences, szWSNLChars,
			article, nntpReturn))
		return nntpReturn.fFalse();

	//
	// check for illegal characters and substrings in References name
	//

	char const * szReferences = m_multiSzReferences;
	do
	{
		if (!fTestAMessageID(szReferences, nntpReturn))
			return nntpReturn.fFalse();

		//
		// go to first char after next null
		//

		while ('\0' != szReferences[0])
			szReferences++;
		szReferences++;
	} while ('\0' != szReferences[0]);

	return nntpReturn.fSetOK();
}

#if 0   // no CFromStoreFeed

BOOL
CFromStoreFeed::fRecordMessageIDIfNecc(
										CNntpServerInstanceWrapper * pInstance,
										const char * szMessageID,
										CNntpReturn & nntpReturn
										)
/*++

Routine Description:

	Records the MessageID of an article in article table.

Arguments:

	pInstance - virtual server instance
	szMessageID - the message id to record
	nntpReturn - The return value for this function call


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	//
	// clear the return code object
	//

	nntpReturn.fSetClear();

	//
	// Now, insert the article
	//

	if (!(pInstance->ArticleTable())->InsertMapEntry(szMessageID))
		return nntpReturn.fSet(nrcArticleDupMessID, szMessageID, GetLastError());

	return nntpReturn.fSetOK();
}

//
// This function handles picking up files from the pickup directory.
//
// parameters:
// 		pvInstance [in] - a void pointer to the current instance
//		pwszFilename [in] - the filename that was detected in the pickup dir
// returns:
//		TRUE - the file was handled.  if TRUE is returned than directory
//				notification won't put this file on the retryq.
//		FALSE - the file was not handled.  this causes the file to be put
//				onto the retry q.  PickupFile will be called with this file
//				again.
// notes:
//  	pInstance->IncrementPickupCount() and DecrementPickupCount() should
//		be used to keep track of the number of threads which are currently
//		in this method.  the instance won't shutdown until there are no
// 		threads in this method.
//
BOOL CFromStoreFeed::PickupFile(PVOID pvInstance, WCHAR *pwszFilename) {
	DWORD dwFileSizeHigh = 0;
    ULARGE_INTEGER liStart;
    ULARGE_INTEGER liNow;
    FILETIME now;


	TraceFunctEnter("CFromStoreFeed::PickupFile");

    GetSystemTimeAsFileTime(&now);
    LI_FROM_FILETIME(&liStart, &now);

	CNntpServerInstanceWrapper *pInstance = (NNTP_SERVER_INSTANCE *) pvInstance;

	pInstance->IncrementPickupCount();

	//
	// Check to see if the instance is good !
	//
	if( !CheckIISInstance( pInstance ) ) {
		ErrorTrace(0,"Instance %d not runnable", pInstance->QueryInstanceId() );
		pInstance->DecrementPickupCount();
		TraceFunctLeave();
		// we return TRUE so that this item isn't put back onto the retry q
		return TRUE;
	}

	//
	// open the file
	//
	HANDLE hFile = CreateFileW(pwszFilename, GENERIC_READ | GENERIC_WRITE,
							   0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		if (GetLastError() == ERROR_FILE_NOT_FOUND) {
			ErrorTrace(0, "%S reported in pickup dir, but doesn't exist",
				pwszFilename);
			pInstance->DecrementPickupCount();
			TraceFunctLeave();
			return TRUE;
		} else {
			ErrorTrace(0, "%S reported in pickup dir, can't open, retry later",
				pwszFilename);
			pInstance->DecrementPickupCount();
			TraceFunctLeave();
			return FALSE;
		}
	}

	//
	// handle 0 length files - zap 'em !
	//

	if( !GetFileSize( hFile, &dwFileSizeHigh ) && !dwFileSizeHigh ) {
		ErrorTrace(0,"%S is zero length - deleting", pwszFilename);
		_VERIFY( CloseHandle( hFile ) );
		DeleteFileW( pwszFilename );
		pInstance->DecrementPickupCount();
		TraceFunctLeave();
		return TRUE;
	}

	//
	// post this file
	//
	CInFeed *pFeed;

	pFeed = pInstance->NewStoreFeed();
	if (pFeed == NULL) {
		ErrorTrace(0, "couldn't allocate CFromStoreFeed to handle %S",
			pwszFilename);
		pInstance->DecrementPickupCount();
		TraceFunctLeave();
		return FALSE;
	}
	pFeed->fInit(pInstance->m_pFeedblockDirPickupPostings,
				 pInstance->m_PeerTempDirectory,
				 0,
				 0,
				 0,
				 FALSE,
				 TRUE,
				 pInstance->m_pFeedblockDirPickupPostings->FeedId);

	//
	// memory map the file
	//
	CMapFile map(hFile, TRUE, FALSE, 0);
	if (!map.fGood()) {
		// the memory map failed, put it on the retry queue
		ErrorTrace(0, "%S reported in pickup dir, can't map, retry later",
			pwszFilename);
		delete pFeed;
		pInstance->DecrementPickupCount();
		TraceFunctLeave();
		return FALSE;
	}
	DWORD cMapBuffer;
	char *pMapBuffer = (char *) map.pvAddress(&cMapBuffer);
	BOOL fSuccess = TRUE;

	//
	// a valid buffer needs to be at least 9 bytes long (to contain
	// \r\n\r\n\r\n.\r\n and pass the next two tests.  we aren't
	// assuming anything about what headers need to be here, we'll
	// let fPost handle that).
	//
	CNntpReturn nr;
	DWORD	dwSecondary;
	char szMessageID[MAX_PATH] = "";
	char szGroups[MAX_PATH] = "";

	if (cMapBuffer >= 9) {
		//
		// make sure the article ends with \r\n.\r\n.  we scan for it, and
		// when we find it we set pDot to point at it.
		//
		char *pDot = pMapBuffer + (cMapBuffer - 5);
		while (fSuccess && memcmp(pDot, "\r\n.\r\n", 5) != 0) {
			pDot--;
			if (pDot == pMapBuffer) fSuccess = FALSE;
		}

		if (fSuccess) {
			//
			// find the end of the headers
			//
			char *pEndBuffer = pMapBuffer + (cMapBuffer - 1);
			char *pBodyStart = pMapBuffer;
			while (fSuccess && memcmp(pBodyStart, "\r\n\r\n", 4) != 0) {
				pBodyStart++;
				if (pBodyStart >= pEndBuffer - 4) fSuccess = FALSE;
			}

			_ASSERT(pBodyStart > pMapBuffer);
			_ASSERT(pDot < pEndBuffer);
			_ASSERT(pBodyStart < pEndBuffer);

			// this can happen if there is junk after the \r\n.\r\n that includes
			// a \r\n\r\n
			if (pBodyStart >= pDot) fSuccess = FALSE;

			if (fSuccess) {
				// pBodyStart points to the \r\n\r\n now, point it at the real
				// body
				pBodyStart += 4;
				DWORD cbHead = pBodyStart - pMapBuffer;
				DWORD cbArticle = (pDot + 5) - pMapBuffer;
				//
				// pass it into the feed's post method
				//
				fSuccess = pFeed->fPost(pInstance,
										NULL,
										NULL,
										pMapBuffer,
										cbHead,
										cbArticle,
										cMapBuffer,
										szMessageID,
										MAX_PATH,
										szGroups,
										MAX_PATH,
										0,
										nr,
										dwSecondary
										);
			} else {
				// we couldn't find the \r\n\r\n between the headers and body
				nr.fSet(nrcPostFailed, dwSecondary, "Bad Article");
				dwSecondary = nrcArticleIncompleteHeader;
			}
		} else {
			// the buffer didn't contain the trailing .
			nr.fSet(nrcPostFailed, dwSecondary, "Bad Article");
			dwSecondary = nrcArticleIncompleteHeader;
		}
	} else {
		// the buffer was too short to contain the trailing .
		nr.fSet(nrcPostFailed, dwSecondary, "Bad Article");
		dwSecondary = nrcArticleIncompleteHeader;
	}

	pFeed->IncrementFeedCounter(dwSecondary);

	delete pFeed;

	//
	// close the file
	//
	UnmapViewOfFile(pMapBuffer);
	map.Relinquish();
	_VERIFY( CloseHandle(hFile) );

	WCHAR *pwszDestDirectory = pInstance->QueryFailedPickupDirectory();

	// check the status and act appropriately
	if (fSuccess || pwszDestDirectory[0] == (WCHAR) 0) {
		// the post was successful, delete the file
		if (!DeleteFileW(pwszFilename)) {
			ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
				pwszFilename, GetLastError());
//			_ASSERT(FALSE);
		}
	} else {
		// the post failed, move the file to a badarticles directory
		WCHAR wszDest[MAX_PATH + 1];
		WCHAR *pwszBasename = pwszFilename + lstrlenW(pwszFilename);
		while (pwszBasename[-1] != L'\\' && pwszBasename > pwszFilename)
			*pwszBasename--;
		lstrcpyW(wszDest, pwszDestDirectory);
		lstrcatW(wszDest, pwszBasename);

		if (!MoveFileExW(pwszFilename, wszDest, MOVEFILE_COPY_ALLOWED)) {
			ErrorTrace(0, "MoveFileW(%S, %S) failed with %lu",
				pwszFilename, wszDest, GetLastError());

			// if this failed then we need to make a unique name to copy
			// to
			UINT cDest = GetTempFileNameW(pwszDestDirectory, L"nws", 0,
				wszDest);

			// this can fail if the bad articles directory has all temp file
			// names used or if the directory doesn't exist
			if (cDest == 0) {
				ErrorTrace(0, "GetTempFileNameW failed with %lu", GetLastError());
				if (!DeleteFileW(pwszFilename)) {
					ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
						pwszFilename, GetLastError());
					_ASSERT(FALSE);
				}
			} else {
				// GetTempFileName creates a 0 byte file with the name wszDest,
				// so we need to allow copying over that
				if (!MoveFileExW(pwszFilename, wszDest, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {
					// this should never happen.  just in case it does we just
					// delete the file
					ErrorTrace(0, "MoveFile(%S, %S) failed with %lu",
						pwszFilename, wszDest, GetLastError());
					if (!DeleteFileW(pwszFilename)) {
						ErrorTrace(0, "DeleteFileW(%S) failed with %lu",
							pwszFilename, GetLastError());
//						_ASSERT(FALSE);
					}
				}
			}
		}
	}

	//
	// we log an event if they have event logging turned on for the Post
	// command and if this is an error or if they have erroronly logging
	// turned off
	//
	if (pInstance->GetCommandLogMask() & ePost &&
		((!(pInstance->GetCommandLogMask() & eErrorsOnly)) ||
		 (NNTPRET_IS_ERROR(nr.m_nrc))))
	{
		//
		// make a transaction log event
		//
	    INETLOG_INFORMATION request;			// log information
		char szFilename[MAX_PATH];				// the filename in ascii
		if (!WideCharToMultiByte(CP_ACP, 0, pwszFilename, -1, szFilename, MAX_PATH, NULL, NULL)) szFilename[0] = 0;

		// build the request structure
		ZeroMemory( &request, sizeof(request));
		request.pszStoreUserName = "<pickup>";
	    // How long were we processing this?
	    GetSystemTimeAsFileTime( &now );
	    LI_FROM_FILETIME( &liNow, &now );
	    liNow.QuadPart -= liStart.QuadPart;
	    liNow.QuadPart /= (ULONGLONG)( 10 * 1000 );
	    request.msTimeForProcessing = liNow.LowPart;
		request.dwWin32Status = dwSecondary;
		request.dwProtocolStatus = nr.m_nrc;
		request.pszOperation = "post";
		request.cbOperation  = 4;
		if (*szMessageID != 0) {
			request.pszTarget = szGroups;
			request.cbTarget = lstrlen(szGroups);
		}
		if (*szGroups != 0) {
			request.pszParameters = szMessageID;
		}

		// log the event
	    if (pInstance->m_Logging.LogInformation(&request) != NO_ERROR) {
	        ErrorTrace(0,"Error %d Logging information!", GetLastError());
	    }
	}

	pInstance->DecrementPickupCount();
	TraceFunctLeave();
	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\stdinc.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\smtpdll.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fpost.h

Abstract:

	Definitions of the fPost interface

Author:

    Rajeev Rajan (RajeevR)     17-May-1996

Revision History:

--*/

#ifndef _SMTPDLL_H_
#define _SMTPDLL_H_

// Initialize the moderated provider interface
BOOL InitModeratedProvider();

// Terminate the moderated provider interface
BOOL TerminateModeratedProvider();

// Signal a change in the SMTP server
VOID SignalSmtpServerChange();

// Post an article to the moderator
BOOL fPostArticleEx(
		IN HANDLE	hFile,
        IN LPSTR	lpFileName,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpTempDirectory,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		);

// Post an article via SMTP persistent connection interface
BOOL fPostArticle(
		IN HANDLE	hFile,
		IN DWORD	dwOffset,
		IN DWORD	dwLength,
		IN char*	pchHead,
		IN DWORD	cbHead,
		IN char*	pchBody,
		IN DWORD	cbBody,
		IN LPSTR	lpModerator,
		IN LPSTR	lpSmtpAddress,
		IN DWORD	cbAddressSize,
		IN LPSTR	lpFrom,
		IN DWORD	cbFrom
		);

#endif	// _SMTPDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\nntpret.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpret.cpp

Abstract:

    This module implements an object from returning return codes
	and objects.

Author:

    Carl Kadie (CarlK)     16-Oct-1995

Revision History:

--*/

//#include "tigris.hxx"
#include  <stdlib.h>
#include "stdinc.h"
#include <stdio.h>

BOOL
ResultCode(
		   char*	szCode,
		   NRC&	nrcOut
		   )
/*++

Routine Description:

	Turns a return code expressed as a string of ascii numerals into
	a number.

Arguments:

	szCode - The return code string.
	nrcOut - The return code as a number.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	nrcOut = nrcNotSet ;

	if( isdigit( szCode[0] ) &&
		isdigit( szCode[1] ) &&
		isdigit( szCode[2] ) &&
		szCode[3] == '\0' )	{
		nrcOut = (NRC)atoi( szCode ) ;
		return	TRUE ;
	}
	return	FALSE ;
}


BOOL
CNntpReturn::fSetOK(
	   void
	   )
/*++

Routine Description:

	Efficently sets the return code object to be "OK".


Arguments:

	None.

Return Value:

	Always TRUE

--*/
{
  m_nrc = nrcOK;
  m_sz = szOK;
  return TRUE;
}


BOOL
CNntpReturn::fSetClear(
	   void
	   )
/*++

Routine Description:

	Efficently sets the return code object to be undefined.


Arguments:

	None.

Return Value:

	Always TRUE

--*/
{
  m_nrc = nrcNotSet;
  m_sz = szNotSet;
  return TRUE;
}

	
BOOL
CNntpReturn::fSet(
				  NRC nrc,
				  ...
				  )
/*++

Routine Description:

	Sets the return code object.

	 Returns TRUE if the the nrc is nrcOK, otherwise returns
	 false. The idea is that this return value can be returned by
	 the calling function.


Arguments:

	nrc - The numeric return code.
	... -  Arguments to the error message


Return Value:

	TRUE, if nrc is nrcOK. FALSE, otherwise.

--*/
{

	if (nrcOK == nrc)
		return fSetOK();

	char const * szFormat;
	BOOL fHasFormatCodes;
	m_nrc = nrc;

	vSzFormat(szFormat, fHasFormatCodes);

	va_list arglist;

    va_start(arglist, nrc);

	//
	// there is a short circuit here for the common case... if there are
	// no formatting codes in the return string then we don't need to
	// run it through _vsnprintf, so we'll skip that.
	//
	if (fHasFormatCodes) {
		_vsnprintf(m_szBuf, maxCchNntpLine, szFormat, arglist);
		m_sz = m_szBuf;
	} else {
		m_sz = szFormat;
	}

    va_end(arglist);

	return FALSE;
}

//
// this is just like fSet, except for we defer the call into _vsnprintf.
// this version is only designed to be used with format strings which have
// one %s item in them, and which can guarantee that the argument is
// a static literal.
//
BOOL
CNntpReturn::fSetEx(NRC nrc,
					char const *szArg)
{
	if (nrcOK == nrc)
		return fSetOK();

#ifdef DEBUG
	if (!IsDebuggerPresent()) {
		// make sure that we can't write to the memory... static literals should
		// be read only
		//
		// we only do this if the debugger isn't attached so that it doesn't
		// cause the debugger to stop in every call to IsBadWritePtr.
		_ASSERT(IsBadWritePtr((void *) szArg, 1));
	}

	// make sure that its not on the stack
	DWORD blah;
	DWORD_PTR addrBlah = (DWORD_PTR) &blah, addrArg = (DWORD_PTR) szArg;

	// make sure that szArg isn't within +/- 4k of the stack variable blah
	_ASSERT(addrArg < (addrBlah - 4096) || addrArg > (addrBlah + 4096));
#endif

	m_nrc = nrc;
	m_szArg = szArg;
	m_sz = NULL;
	return FALSE;
}

const char *
CNntpReturn::szReturn() {
	if (m_sz == NULL) {
		// we are in lazy evaluation mode...we need to fill in m_sz now
		_ASSERT(m_szArg != NULL);
		char const * szFormat;
		BOOL fHasFormatCodes;

		vSzFormat(szFormat, fHasFormatCodes);
		_ASSERT(fHasFormatCodes);

		_snprintf(m_szBuf, maxCchNntpLine, szFormat, (char *) m_szArg);
		m_sz = m_szBuf;
	}
	return m_sz;
}

void
CNntpReturn::vSzFormat(
					   char const * & szFormat,
					   BOOL &fHasFormatCodes
					   )
/*++

Routine Description:

	Returns the string used to format the message.

Arguments:

	szFormat - the string returned.


Return Value:

	None.

--*/
{
	fHasFormatCodes = FALSE;
	switch (m_nrc)
	{
		case nrcServerReady :
			szFormat = "Good Enough" ;
			break ;
		case nrcServerReadyNoPosts :
			szFormat = "Posting Not Allowed" ;
			break ;
		case nrcSlaveStatusNoted :
			szFormat = "Unsupported" ;
			break ;
		case nrcModeStreamSupported :
			szFormat = "Mode Stream Supported" ;
			break ;
		case nrcXoverFollows :
			szFormat = "data follows \r\n." ;
			break ;
		case nrcNewnewsFollows :
			szFormat = "Newnews follows" ;
			break ;
        case nrcSNotAccepting :
            szFormat = "Not Accepting Articles " ;
            break ;
		case	nrcNoSuchGroup :
			szFormat = "no such newsgroup" ;
			break ;
		case	nrcNoGroupSelected :
			szFormat = "no Newsgroup has been selected" ;
			break ;
		case	nrcNoCurArticle :
			szFormat = "no current article has been selected" ;
			break ;
		case	nrcNoNextArticle :
			szFormat = "no next article" ;
			break ;
		case	nrcSTransferredOK:
			szFormat = "article successfully transferred";
			break ;
		case	nrcNoPrevArticle :
			szFormat = "no prev article" ;
			break ;
		case	nrcNoArticleNumber :
			szFormat = "no such article number in group" ;
			break ;
		case	nrcNoSuchArticle :
			szFormat = "no such article found" ;
			break ;
		case	nrcNotWanted :
			szFormat = "article not wanted" ;
			break ;
		case	nrcArticleTransferredOK :
			szFormat = "Article Transferred OK";
			break;
		case	nrcArticlePostedOK :
			szFormat = "Article Posted OK";
			break;
		case nrcOK:
			szFormat = szOK;
			break;
		case nrcPostFailed:
			szFormat = "(%d) Article Rejected -- %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcNoMatchesFound:
			szFormat = "No Matches Found";
			break;
		case nrcErrorPerformingSearch:
			szFormat = "Error Performing Search";
			break;
		case nrcPostModeratedFailed:
			szFormat = "Failed to mail Article to %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcLogonRequired:
			szFormat = "Logon Required" ;
			break;
        case nrcNoListgroupSelected:
            szFormat = "No group specified" ;
            break ;
		case nrcTransferFailedTryAgain:
			szFormat = "(%d) Transfer Failed - Try Again -- %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcTransferFailedGiveUp:
			szFormat = "(%d) Transfer Failed - Do Not Try Again -- %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcSAlreadyHaveIt :
			szFormat = "%s" ;
			fHasFormatCodes = TRUE;
			break ;
		case nrcSArticleRejected :
			szFormat = "(%d) Transfer Failed - Do Not Try Again -- %s";
			fHasFormatCodes = TRUE;
			break ;
		case nrcPostingNotAllowed :
			szFormat = "No Posting" ;
			break ;
		case	nrcNotRecognized :
			szFormat = "Command Not Recognized" ;
			break ;
		case	nrcSyntaxError :
			szFormat = "Syntax Error in Command" ;
			break ;
		case	nrcNoAccess :
			szFormat = "Access Denied."	;
			break ;
		case	nrcServerFault :
			szFormat = "Server Failure." ;
			break ;
		case nrcArticleIncompleteHeader:
			szFormat = "Header is incomplete";
			break;
		case nrcArticleMissingHeader:
			szFormat = "Header is missing";
			break;
		case nrcArticleTooManyFieldOccurances:
			szFormat = "Multiple '%s' fields";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleMissingField:
			szFormat = "Missing '%s' field";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleBadField:
			szFormat = "Bad '%s' field";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldZeroValues:
			szFormat = "The '%s' field requires one or more values";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldMessIdNeedsBrack:
			szFormat = "The message id must start with '<' and end with '>'";
			break;
		case nrcArticleFieldMissingValue:
			szFormat = "The '%s' field is empty";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldIllegalNewsgroup:
			szFormat = "Illegal newsgroup '%s' in '%s' field";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleTooManyFields:
			szFormat = "Too many fields in article header (limit is %d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcMemAllocationFailed:
			szFormat = "Memory Allocation Failed (File %s, Line %d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldMessIdTooLong:
			szFormat = "Message ID had length %d. The longest supported is %d";
			fHasFormatCodes = TRUE;
			break;
		case nrcErrorReadingReg:
			szFormat = "Can't read registry value '%s' from key '%s'";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleDupMessID:
			szFormat = "Duplicate Message-ID %s (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleMappingFailed:
			szFormat = "Mapping of file %s failed. LastError is %d";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleAddLineBadEnding:
			szFormat = "Line should end with newline character (%s)";
			fHasFormatCodes = TRUE;
			break;
		case nrcPathLoop:
			szFormat = "This hub (%s) found in path.";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleInitFailed:
			szFormat = "Initialization of article failed.";
			break;
		case nrcNewsgroupInsertFailed:
			szFormat = "Insertion into group %s of article %s failed.";
			fHasFormatCodes = TRUE;
			break;
		case nrcNewsgroupAddRefToFailed:
			szFormat = "Adding xref to group %s for article %s failed.";
			fHasFormatCodes = TRUE;
			break;
		case nrcHashSetArtNumSetFailed:
			szFormat = "Can't set IDs to %d/%d for article %s in Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcHashSetXrefFailed:
			szFormat = "Can't add xrefs to article %s in Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcOpenFile:
			szFormat = "Can't open file %s. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleBadFieldFollowChar:
			szFormat = "Keyword '%s' is not followed by a space";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleBadChar:
			szFormat = "A bad character (%d) was found in the %s";
			fHasFormatCodes = TRUE;
			break;
		case nrcDuplicateComponents:
			szFormat = "Duplicate components found in field '%s'";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldIllegalComponent:
			szFormat = "Illegal component '%s' in field '%s'";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleBadMessageID:
			szFormat = "Ill-formed message id '%s' in field '%s'";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldBadChar:
			szFormat = "A bad character (%d) was found in the %s field";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldDateIllegalValue:
			szFormat = "Date in '%s' field has illegal value";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldDate4DigitYear:
			szFormat = "Date in '%s' field must contain 4-digit year";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleFieldAddressBad:
			szFormat = "Address in '%s' field has an illegal value";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleXoverTooBig:
			szFormat = "Too much Xover data";
			break;
		case nrcCreateNovEntryFailed:
			szFormat = "Xover insertion (group %d, article %d, GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleXrefBadHub:
			szFormat = "Hub from Master in Xref ('%s') does not match local hub ('%s')";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleNoSuchGroups:
			szFormat = "No such groups";
			break;
		case nrcHashSetFailed:
			szFormat = "Can't add article %s to %s Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleTableCantDel		:
			szFormat = "Can't delete message id %s from the Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleTableError		:
			szFormat = "Error trying to find entry for %s in Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcArticleTableDup		:
			szFormat = "Unexpected duplicate entry %s in Article Table. (GLE=%d)";
			fHasFormatCodes = TRUE;
			break;
		case nrcCantAddToQueue		:
			szFormat = "Error trying to add article reference to outgoing feed";
			break;
		case nrcSlaveGroupMissing	:
			szFormat = "The special group for sending articles to the Master is missing";
			break;
		case nrcInconsistentMasterIds :
			szFormat = "The xreplic command line does not match the group ids in the articles Xref line";
			break ;
		case nrcInconsistentXref :
			szFormat = "The groups in the xreplic command line do not match the groups in the articles Xref line";
			break ;
		case nrcArticleDateTooOld :
			szFormat = "The Date in the date header is too old";
			break ;
		case nrcArticleTooLarge :
			szFormat = "The article is to large" ;
			break ;
		case nrcIllegalControlMessage :
			szFormat = "Illegal control message" ;
			break ;
		case nrcNotYetImplemented :
			szFormat = "Not Yet Implemented" ;
			break ;
		case nrcControlNewsgroupMissing :
			szFormat = "Control.* newsgroup is missing" ;
			break ;
		case nrcBadNewsgroupNameLen :
			szFormat = "Newsgroup name too long or zero" ;
			break ;
		case nrcNewsgroupDescriptionTooLong :
			szFormat = "Newsgroup description too long" ;
			break ;
		case nrcCreateNewsgroupFailed :
			szFormat = "Create Newsgroup failed" ;
			break ;
		case nrcGetGroupFailed :
			szFormat = "Get group failed" ;
			break ;
		case nrcControlMessagesNotAllowed :
			szFormat = "Control messages are not allowed by this server" ;
			break ;
		case nrcServerEventCancelledPost :
			szFormat = "A server event filter cancelled the posting" ;
			break ;

		case nrcLoggedOn :
			szFormat = "Packages Follow \r\n%s." ;
			fHasFormatCodes = TRUE;
			break ;
		case nrcSystemHeaderPresent:
			szFormat = "The '%s' header is a system header - client posts should not have it";
			fHasFormatCodes = TRUE;
			break;

		default:
			szFormat = "<no text for error code>";
			break;

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\nntpstr.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nntpstr.cpp

Abstract:

    This module contains definition all string definitions

Author:

    Johnson Apacible (JohnsonA)     25-Sept-1995

Revision History:

--*/

//#include "tigris.hxx"
#include "stdinc.h"

//
// from extcmk2.h
//

const char szWSChars[] = " \t";
const char szWSNullChars[] = " \t\0";
const char szNLChars[] = "\n\r";
const char szWSNLChars[] = " \t\n\r";
const char StrNewLine[] = "\r\n";
const char StrTermLine[] = ".\r\n";

//
// Misc
//

LPSTR StrUnknownUser = "Anonymous";

//
// registry stuff
//

LPSTR StrParmKey = "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters";
LPSTR StrFeedKey = "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters\\Feeds";
LPSTR StrExpireKey = "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters\\Expires";
LPSTR StrVirtualRootsKey = "System\\CurrentControlSet\\Services\\NNTPSvc\\Parameters\\Virtual Roots";
LPSTR StrExpireNewsgroups = "Newsgroups" ;
LPSTR StrExpirePolicy = "ExpirePolicy" ;
LPSTR StrTreeRoot = "TreeRoot";
LPSTR StrRejectGenome = "RejectGenomeGroups";
LPSTR StrServerName = "ServerName";
LPSTR StrNntpHubName = "HubName";
LPSTR StrFeedType = "FeedType";
LPSTR StrFeedInterval = "FeedInterval";
LPSTR StrFeedDistribution = "Distribution";
LPSTR StrFeedNewsgroups = "Newsgroups";
LPSTR StrFeedAutoCreate = "CreateAutomatically";
LPSTR StrFeedAllowControl = "AllowControlMessages";
LPSTR StrFeedOutgoingPort = "OutgoingPort";
LPSTR StrFeedPairId = "FeedPairId";
LPSTR StrFeedIsMaster = "IsNntpMaster";
LPSTR StrFeedStartHigh = "FeedStartTimeHigh";
LPSTR StrFeedStartLow = "FeedStartTimeLow";
LPSTR StrFeedNextPullLow = "NextPullTimeLow";
LPSTR StrFeedNextPullHigh = "NextPullTimeHigh";
LPSTR StrPeerGapSize = "PeerGapSize";
LPSTR StrPeerTempDir = "PeerTempDirectory";
LPSTR StrFeedTempDir = "FeedTempDirectory" ;
LPSTR StrFeedUucpName = "UucpName" ;
LPSTR StrFeedMaxConnectAttempts = "MaxConnectionAttempts" ;
LPSTR StrFeedConcurrentSessions = "ConcurrentSessions" ;
LPSTR StrFeedSecurityType = "SecurityType" ;
LPSTR StrFeedAuthType = "AuthenticationType" ;
LPSTR StrFeedAuthAccount = "AuthinfoAccount" ;
LPSTR StrFeedAuthPassword = "AuthinfoPassword" ;
LPSTR StrListFileName = "ListFile";
LPSTR StrQueueFile = "QueueFile";
LPSTR StrExpireHorizon = "ExpireHorizon";
LPSTR StrExpireSpace   = "ExpireSpace";
LPSTR StrCleanBoot = "CleanBoot";
LPSTR StrSocketRecvSize = "SocketRecvBufferSize" ;
LPSTR StrSocketSendSize = "SocketSendBufferSize" ;
LPSTR StrBuffer = "BufferedWrites" ;
LPSTR StrCommandLogMask = "CommandLogMask" ;
LPSTR StrActiveFile = "Active.txt" ;
LPSTR StrDescriptiveFile = "groups.txt" ;
LPSTR StrGroupList = "group.lst" ;
LPSTR StrModeratorFile = "nntpfile\\moderatr.txt" ;
LPSTR StrFeedDisabled = "Disabled" ;
LPSTR StrAFilePath = "ArticleTableFile" ;
LPSTR StrHFilePath = "HistoryTableFile" ;
LPSTR StrXFilePath = "XoverTableFile" ;
LPSTR StrModeratorPath = "ModeratorFile" ;
LPSTR StrHistoryExpiration = "HistoryExpiration" ;
LPSTR StrArticleTimeLimit = "ArticleTimeLimit" ;
LPSTR StrAllowClientPosts = "AllowClientPosts" ;
LPSTR StrAllowFeedPosts = "AllowFeedPosts" ;
LPSTR StrAllowControlMessages = "AllowControlMessages" ;
LPSTR StrServerSoftLimit = "ServerPostingSoftLimit" ;
LPSTR StrServerHardLimit = "ServerPostingHardLimit" ;
LPSTR StrFeedSoftLimit = "FeedPostSoftLimit" ;
LPSTR StrFeedHardLimit = "FeedPostHardLimit" ;
LPSTR StrServerOrg = "ServerOrganization" ;
LPSTR StrSmallBufferSize = "SmallBufferSize" ;
LPSTR StrMediumBufferSize = "MediumBufferSize" ;
LPSTR StrLargeBufferSize = "LargeBufferSize" ;
LPSTR StrNewsCrawlerTime = "NewsCrawlerTime" ;
LPSTR StrNewsVrootUpdateRate = "NewsVrootUpdateRate" ;
LPSTR StrHonorClientMessageIDs = "HonorClientMessageIDs" ;
LPSTR StrDisableNewnews = "DisableNewnews" ;
LPSTR StrGenerateErrFiles = "GenerateErrFiles" ;
LPSTR StrXoverPageEntry = "NumXoverPageEntry" ;
LPSTR StrArticlePageEntry = "NumArticlePageEntry" ;
LPSTR StrHistoryPageEntry = "NumHistoryPageEntry" ;	
LPSTR StrShutdownLatency = "ShutdownLatency" ;
LPSTR StrStartupLatency = "StartupLatency" ;
LPSTR StrHonorApprovedHeader = "HonorApprovedHeader" ;
LPSTR StrMailFromHeader = "MailFromHeader" ;
LPSTR StrEnableNntpPostingHost = "EnableNntpPostingHost" ;
LPSTR StrNumExpireThreads = "NumExpireThreads" ;
LPSTR StrNumSpecialCaseExpireThreads = "NumSpecialCaseExpireThreads" ;
LPSTR StrSpecialExpireArtCount = "SpecialExpireArtCount" ;
LPSTR StrSpecialExpireGroup = "SpecialExpireGroup" ;
LPSTR StrNewsTreeFileScanRate = "NewsTreeFileScanRate" ;
LPSTR StrPageCacheSize = "PageCacheSize" ;
LPSTR StrFileHandleCacheSize = "FileHandleCacheSize" ;
LPSTR StrXixHandlesPerTable = "XixHandlesPerTable" ;
LPSTR StrHashTableNoBuffering = "HashTableNoBuffering" ;
LPSTR StrPostBackFillLines = "PostBackFillLines";

LPWSTR StrSmtpAddressW = L"SmtpAddress" ;
LPWSTR StrUucpNameW = L"ServerUucpName" ;
LPSTR  StrUucpNameA = "ServerUucpName" ;
LPWSTR StrDefaultModeratorW = L"DefaultModerator" ;
LPWSTR StrAuthPackagesW = L"NTAuthenticationProviders" ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\pcparse.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pcprase.cpp

Abstract:

    This module implements an object for parsing FROM values.
	It works by creating a function for each grammer rule.
	When called the function will "eat up" any characters that
	parse and return TRUE. If no characters parse, then none
	will be eaten up and the return will be FALSE.

Author:

    Carl Kadie (CarlK)     11-Dec-1995

Revision History:

--*/

//#include "tigris.hxx"
#include "stdinc.h"

BOOL
CPCParse::fParenChar(
								void
				 )
/*++

Routine Description:

	Parse a "("

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if ((0<m_cch) && fParenCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
		return TRUE;
	}

	return FALSE;
}

BOOL
CPCParse::fIsChar(
				 char ch
				 )
/*++

Routine Description:

	Look at next char to see if it matches ch.

Arguments:

	ch - The character to look for.


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if ((0<m_cch) && (ch == m_pch[0]))
	{
		return TRUE;
	}

	return FALSE;
}


BOOL
CPCParse::fParseSingleChar(
				 char ch
				 )
/*++

Routine Description:

	Parse a single character.

Arguments:

	ch - The character to look for.


Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if ((0<m_cch) && (ch == m_pch[0]))
	{
		m_pch++;
		m_cch--;
		return TRUE;
	}

	return FALSE;
}


BOOL
CPCParse::fAtLeast1QuotedChar(
								   void
		  )
/*++

Routine Description:

	Parse one or more occurances of a "QuotedChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fQuotedCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
	//

	while ((0<m_cch) && fQuotedCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}


	return TRUE;
}

BOOL
CPCParse::fAtLeast1UnquotedChar(
								   void
		  )
/*++

Routine Description:

	Parse one or more occurances of a "UnquotedChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fUnquotedCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
	//

	while ((0<m_cch) && fUnquotedCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}


	return TRUE;
}


BOOL
CPCParse::fAtLeast1UnquotedDotChar(
								   void
								   )
/*++

Routine Description:

	Parse one or more occurances of a "UnquotedChar" - allows Dots to be present

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fUnquotedDotCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
	//

	while ((0<m_cch) && fUnquotedDotCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}


	return TRUE;
}

BOOL
CPCParse::fAtLeast1Space(
					   void
		  )
/*++

Routine Description:

	Parse one or more occurances of a "Space"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fSpaceTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) && fSpaceTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}


BOOL
CPCParse::fAtLeast1QuotedCharOrSpace(
					   void
		  )
/*++

Routine Description:

	Parse one or more occurances of a "QuotedChar" or Space

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fQuotedCharOrSpaceTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) /*&& fParenCharTest(m_pch[0]*/ && *m_pch != '\"' )
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}

BOOL
CPCParse::fAtLeast1ParenChar(
					   void
		  )
/*++

Routine Description:

	Parse at least one "ParenChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fParenCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) && fParenCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}

BOOL
CPCParse::fAtLeast1CodeChar(
					   void
		  )
/*++

Routine Description:

	Parse at least one "CodeChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fCodeCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) && fCodeCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}

BOOL
CPCParse::fAtLeast1TagChar(
					   void
		  )
/*++

Routine Description:

	Parse at least one "TagChar"

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{

	//
	// Is it even long enough?
	//

	DWORD dwN = 1;
	if (m_cch < dwN)
		return FALSE;

	//
	// Are their N occuraces?
	//

	DWORD dw;
	for (dw = 0; dw < dwN; dw++)
	{
 		if (!fTagCharTest(m_pch[dw]))
			return FALSE;
	}
	vSkipStart(dw);

	//
	// Process any additional occuracies
		// Process any additional occuracies
		//

	while ((0<m_cch) && fTagCharTest(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	return TRUE;
}


BOOL
CPCParse::fQuotedWord(
			void
			)
/*++

Routine Description:


	 quoted-word   = quote 1*( quoted-char / space ) quote


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	CPCParse pcOld = *this;
	if (fParseSingleChar('\"') //!!!constize
		&& fAtLeast1QuotedCharOrSpace()
		&& fParseSingleChar('\"')
		)
		return TRUE;

	*this = pcOld;
	return FALSE;
}

BOOL
CPCParse::fLocalPart(
			void
			)
/*++

Routine Description:

	 local-part    = unquoted-word *( "." unquoted-word )


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if (!fUnquotedWord())
		return FALSE;

	CPCParse pcOld = *this;

	while(fParseSingleChar('.') && fUnquotedWord())
		pcOld = *this;

	*this = pcOld;
	return TRUE;
}



BOOL
CPCParse::fStrictAddress(
			void
			)
/*++

Routine Description:


	address       = local-part "@" domain

  !!!X LATER - do we want a flag that tells if just local-part is acceptable?

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	CPCParse pcOld = *this;

	if (!fLocalPart())
		return FALSE;

	if (!fParseSingleChar('@'))
		return FALSE;

	if (fDomain())
		return TRUE;

	*this = pcOld;
	return FALSE;
}

BOOL
CPCParse::fAddress(
			void
			)
/*++

Routine Description:


	address       = local-part "@" domain or JUST local-part

  !!!X LATER - do we want a flag that tells if just local-part is acceptable?

Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	CPCParse pcOld = *this;

	if (!fLocalPart())
		return FALSE;

	if (!fParseSingleChar('@'))
		return TRUE;

	if (fDomain())
		return TRUE;

	*this = pcOld;
	return FALSE;
}

BOOL
CPCParse::fPlainPhrase(
			void
			)
/*++

Routine Description:

	 plain-phrase  = plain-word *( space plain-word )


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if (!fPlainWord())
		return FALSE;

	CPCParse pcOld = *this;

	while(fSpace() && fPlainWord())
		pcOld = *this;

	*this = pcOld;
	return TRUE;
}


BOOL
CPCParse::fParenPhrase(
			 void
			 )
/*++

Routine Description:

    paren-phrase  = 1*( paren-char / space / encoded-word )


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	if (!(
		   fParenChar()
		|| fSpace()
		|| fEncodedWord()
        )) {

        //
        // special case () to fix rfc-non-compliance by TIN
        //
		return fIsChar(')');
    }

	CPCParse pcOld = *this;

	while(fParenChar()|| fSpace() || fEncodedWord())
		pcOld = *this;

	*this = pcOld;
	return TRUE;
}


BOOL
CPCParse::fFromContent(
			 void
			 )
/*++

Routine Description:

	  From-content  = address [ space "(" paren-phrase ")" ]
	         /  [ plain-phrase space ] "<" address ">"


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
	CPCParse pcOld = *this;
	BOOL fOK = FALSE; // Assume the worst

    // try style 1
	if (fStrictAddress())
	{
        // address is ok
        fOK = TRUE;

        // now check for optional [ space "(" paren-phrase ")" ]
		if (fSpace())
		{
			if (!(
				fParseSingleChar('(') 
				&& fParenPhrase()
				&& fParseSingleChar(')')
				))
			{
				fOK = FALSE;
			}	
			else	
			{
				fOK = TRUE ;
			}
		}
	}

	// If it didn't parse that way, try style 2
	if (!fOK)
	{
		*this = pcOld;

		if (fPlainPhrase() && !fSpace())
		{
            fOK = FALSE;
        } else if (!(fParseSingleChar('<') 
			        && fAddress()
			        && fParseSingleChar('>')
			        ))
		{
            fOK = FALSE;
        } else {
            fOK = TRUE ;
        }
	}

    // style 1 and 2 both failed
    if( !fOK )
    {
        *this = pcOld;
        if( fAddress() ) {
            fOK = TRUE;
        }
    }

	//
	// There should be no characters left
	//

	if (0 != m_cch)
		{
			*this = pcOld;
			return FALSE;
		}

	return TRUE;
}


BOOL
CPCParse::fEncodedWord(
			 void
			 )
/*++

Routine Description:

	  encoded-word  = "=?" charset "?" encoding "?" codes "?="


Arguments:

	None.

Return Value:

	TRUE, if successful. FALSE, otherwise.    

--*/
{
		CPCParse pcOld = *this;
		if (
			 fParseSingleChar('=')
			&& fParseSingleChar('?')
			&& fCharset()
			&& fParseSingleChar('?')
			&& fEncoding()
			&& fParseSingleChar('?')
			&& fCodes()
			&& fParseSingleChar('?')
			&& fParseSingleChar('=')
			)
			return TRUE;

		*this = pcOld;
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\nntpcons.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpcons.h

Abstract:

    This module contains global constants for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPCONS_
#define _NNTPCONS_

//
// manifest constants
//

#define     KB                          1024
#define     MEG                         (KB * KB)
#define     MAX_NNTP_LINE               512
//
// convert to seconds
//

#define     SEC_PER_MIN                 (60)
#define     SEC_PER_HOUR                (60* SEC_PER_MIN)
#define     SEC_PER_DAY                 (24* SEC_PER_HOUR)
#define     SEC_PER_WEEK                (7 * SEC_PER_DAY)

//
// Port numbers
//

#define     NNTP_PORT                   119
#define     NNTP_SSL_PORT               563

//
// Id values
//

#define     GROUPID_INVALID             0xffffffff
#define     GROUPID_DELETED             0xfffffffe

#define     ARTICLEID_INVALID           0xffffffff

//
// Secret data name
//

#define NNTP_SSL_CERT_SECRET    L"NNTP_CERTIFICATE"
#define NNTP_SSL_PKEY_SECRET    L"NNTP_PRIVATE_KEY"
#define NNTP_SSL_PWD_SECRET     L"NNTP_SSL_PASSWORD"

//
// Default pull date/time
//

#define DEF_PULL_TIME           "000000"

//
// Maximum xover reference
//

#define MAX_REFERENCES_FIELD             512

//
//	Newsgroup constants
//
//
const	DWORD	MAX_DESCRIPTIVE_TEXT = 512 ;
const	DWORD	MAX_MODERATOR_NAME = 512 ;
const	DWORD	MAX_VOLUMES = 1;
const	DWORD	MAX_NEWSGROUP_NAME = 512 ;
const	DWORD	MAX_PRETTYNAME_TEXT = 72 ;

#endif // _NNTPCONS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\nntpmacr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    nntpmacr.h

Abstract:

    This module contains macross for the NNTP server.

Author:

    Johnson Apacible (JohnsonA)     26-Sept-1995

Revision History:

--*/

#ifndef _NNTPMACR_
#define _NNTPMACR_


#define ALLOCATE_HEAP( nBytes ) LocalAlloc( 0, nBytes )
#define FREE_HEAP( _heap )      LocalFree( (PVOID)(_heap) )

//
// try/finally macros
//

#define START_TRY               __try {
#define END_TRY                 }
#define TRY_EXCEPT              } __except(EXCEPTION_EXECUTE_HANDLER) {
#define START_FINALLY           } __finally {

//
// tracing
//

#define INIT_TRACE              InitAsyncTrace( )
#define TERM_TRACE              TermAsyncTrace( )
#define ENTER( _x_ )            TraceFunctEnter( _x_ );
#define LEAVE                   TraceFunctLeave( );

//
// Convert FILETIME TO LIs
//

#define LI_FROM_FILETIME( _pLi, _pFt ) {               \
            (_pLi)->LowPart = (_pFt)->dwLowDateTime;   \
            (_pLi)->HighPart = (_pFt)->dwHighDateTime; \
            }

#define FILETIME_FROM_LI( _pFt, _pLi ) {               \
            (_pFt)->dwLowDateTime = (_pLi)->LowPart;   \
            (_pFt)->dwHighDateTime = (_pLi)->HighPart; \
            }

//
// CRITICAL SECTIONS
//

#define INIT_LOCK( _l )     InitializeCriticalSection( _l )
#define ACQUIRE_LOCK( _l )  EnterCriticalSection( _l )
#define RELEASE_LOCK( _l )  LeaveCriticalSection( _l )
#define DELETE_LOCK( _l )   DeleteCriticalSection( _l )

//
// LockStatistics
//

#define LockStatistics( pInst )						ACQUIRE_LOCK( &pInst->m_StatLock );
#define UnlockStatistics( pInst )					RELEASE_LOCK( &pInst->m_StatLock );
#define IncrementStat( pInst, _x )					((pInst->m_NntpStats). ## _x)++;
#define DecrementStat( pInst, _x )					((pInst->m_NntpStats). ## _x)--;
#define InterlockedIncrementStat( pInst, _x )		InterlockedIncrement((LPLONG)&((pInst->m_NntpStats). ## _x));
#define InterlockedDecrementStat( pInst, _x )		InterlockedDecrement((LPLONG)&((pInst->m_NntpStats). ## _x));
#define InterlockedExchangeAddStat( pInst, _x, _y )	InterlockedExchangeAdd( (PLONG)&((pInst->m_NntpStats). ## _x), (LONG)(_y) )
#define AddByteStat( pInst, _x, _y ) \
        if( (ULONG)InterlockedExchangeAdd( (PLONG)&(((pInst->m_NntpStats). ## _x).LowPart), (LONG)(_y)) \
			> ( ULONG_MAX - (ULONG)(_y) ) ) InterlockedIncrement( (LPLONG)&(((pInst->m_NntpStats). ## _x).HighPart) );

//
// debug constants\macros
//

#define  NNTP_DEBUG_REGISTRY        0x00000004
#define  NNTP_DEBUG_EXPIRE          0x00000008
#define  NNTP_DEBUG_LOCKS           0x00000010
#define  NNTP_DEBUG_ARTMAP          0x00000020
#define  NNTP_DEBUG_HISTORY         0x00000040
#define  NNTP_DEBUG_HEAP            0x00000080
#define  NNTP_DEBUG_HASH            0x00000100
#define  NNTP_DEBUG_SECURITY        0x00000200
#define  NNTP_DEBUG_FEEDMGR         0x00000400
#define  NNTP_DEBUG_FEEDBLOCK       0x00000800

extern DWORD DebugLevel;
#define DO_DEBUG( flag ) \
    if ( DebugLevel & (NNTP_DEBUG_ ## flag) )

//
// on debug build define all inline functions as regular functions.
// copied from msndef.h
//

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

//
// from extcmk2.h
//

#define fCharInSet(ch, set) (NULL !=strchr(set, ch))
#define STRLEN(sz) (sizeof(sz)-1)
#define	fWhitespace(ch) fCharInSet(ch, szWSChars)
#define	fWhitespaceNull(ch) fCharInSet(ch, szWSNullChars)
#define	fWhitespaceNewLine(ch) fCharInSet(ch, szWSNLChars)
#define	fNewLine(ch) ( ( ch != '\0' ) && fCharInSet(ch, szNLChars) )

#ifndef	Assert
#define Assert _ASSERT
#endif

//
//	Virtual Server scoping macros
//
#define XOVER_TABLE(   pTree )		((pTree->GetVirtualServer())->XoverTable())
#define ARTICLE_TABLE( pTree )		((pTree->GetVirtualServer())->ArticleTable())
#define HISTORY_TABLE( pTree )		((pTree->GetVirtualServer())->HistoryTable())
#define XOVER_CACHE( pTree )		((pTree->GetVirtualServer())->XoverCache())
#define EXPIRE_OBJECT( pTree )		((pTree->GetVirtualServer())->ExpireObject())
#define INST( pS )					((pS->m_context).m_pInstance)

//
//	Delete macros
//
#define DELETE_CHK( ptr )	if( ptr ) { delete ptr ; ptr = NULL ; }

#endif // _NNTPMACR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\cbuffer\stdinc.cpp ===
#include "stdinc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\pcstring.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pcstring.cpp

Abstract:

    This module implements an abstract data type called
	"Pointer/Counter Strings". Each object is just
	a pair: a pointer to char and a count of how many
	characters are in the string.

Author:

    Carl Kadie (CarlK)     10-Oct-1995

Revision History:

--*/

//#include "tigris.hxx"
#include "stdinc.h"

char *
CPCString::pchMax(
				  void
				  )
/*++

Routine Description:

	Returns a pointer to one past the last legal character.

Arguments:

	None.

Return Value:

	A pointer to one past the last legal character.

--*/
{
	return m_pch + m_cch;
}

BOOL
CPCString::fEqualIgnoringCase(
							  const char * sz
							  )
/*++

Routine Description:

	Tests if sz is equal to the current sting.

		\\!!! What if the sz is longer?? Should test that, too.

Arguments:

	sz - The string to compare with the current string.


Return Value:

	TRUE, if eqaul. FALSE, otherwise.

--*/
{
	return m_cch && (0 == _strnicmp(sz, m_pch, m_cch));
}

BOOL
CPCString::fExistsInSet(char ** rgsz, DWORD dwNumStrings)
/*++

Routine Description:

	Tests if the current string exists in the set of strings rgsz


Arguments:

	rgsz			-  The set of strings
	dwNumStrings	-  number of strings in rgsz


Return Value:

	TRUE, if exists. FALSE, otherwise.

--*/
{
	BOOL fExists = FALSE;

	// iterate over set of strings
	for(DWORD i=0; i<dwNumStrings; i++)
	{
		// If this string equals current string in set
		if(0 == _strnicmp(rgsz[i], m_pch, strlen(rgsz[i])))
		{
			fExists = TRUE;
			break;
		}
	}

	return fExists;
}

BOOL
CPCString::fSetCch(
				   const char * pchMax
				   )
/*++

Routine Description:

	Sets the string's length based a pointer to one beyond
		its last legal character.

Arguments:

	pchMax - One beyond the legal legal character of this string.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	if (NULL == m_pch || pchMax < m_pch)
		return FALSE;

	m_cch = (DWORD)(pchMax - m_pch);
	return TRUE;

};

BOOL
CPCString::fSetPch(
				   char * pchMax
				   )
/*++

Routine Description:

	Sets the string's start based a pointer to one beyond
		its last legal character (and its length).

Arguments:

	pchMax - One beyond the legal legal character of this string.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	if (NULL == pchMax)
		return FALSE;

	m_pch = pchMax - m_cch;
	return TRUE;

};

DWORD
CPCString::dwTrimEnd(
					 const char * szSet
					 )
/*++

Routine Description:

	Trims characters in the set from the end of the string.

Arguments:

	szSet - the set of characters to trim.


Return Value:

	Number of characters trimed.

--*/
{
	DWORD dw = m_cch;
	while(m_cch > 0 && fCharInSet(m_pch[m_cch-1], szSet))
		m_cch--;

		return dw-m_cch;
}

DWORD
CPCString::dwTrimStart(
					   const char * szSet
					   )
/*++

Routine Description:

	Trims characters in the set from the beginning of the string.

Arguments:

	szSet - the set of characters to trim.


Return Value:

	Number of characters trimed.

--*/
{
	DWORD dw = m_cch;
	while(m_cch > 0 && fCharInSet(m_pch[0], szSet))
	{
		m_pch++;
		m_cch--;
	}

	return dw-m_cch;
}

	
void
CPCString::vSplitLine(
		  const char *	szDelimSet,
		  char *	multiszBuf,
		  DWORD	&	dwCount	
		  )
/*++

Routine Description:

	Splits the string on the delimiters.

	It is not stict about repeated delimiters or whitespace
	It returns TRUE even if count is 0..
	The caller must allocate space for multisz. It
	 can be up to two bytes longer that the original string


Arguments:

	szDelimSet - The set of delimiter characters.
	multiszBuf - The buffer to write the results to
	dwCount - The number of items in the list.


Return Value:

	None.

--*/
{

	//
	// Create a pointer into the output buffer
	//

	char * multisz = multiszBuf;

	//
	// Create a pointer into the input
	//

	char * pch = m_pch;

	//
	// Create a pointer to the one past the end of the input buffer
	//

	const char * pchMax1 = pchMax();

	dwCount = 0;

	//
	// skip over any leading delimiters
	//

	while (pch < pchMax1 && fCharInSet(pch[0], szDelimSet))
		pch++;

	if (pch >= pchMax1)
	{
		multisz[0] = '\0';
		multisz[1] = '\0';

	} else {
		do
		{

			//
			// copy until delimiter
			//

			while (pch < pchMax1 && !fCharInSet(pch[0], szDelimSet))
				*multisz++ = *pch++;

			//
			// terminate the string
			//

			*multisz++ = '\0';
			dwCount++;

			//
			// skip any delimiters
			//

			while (pch < pchMax1 && fCharInSet(pch[0], szDelimSet))
				pch++;

		} while (pch < pchMax1);

		//
		// terminate the multistring
		//

		*multisz++ = '\0';
	}

	return;
}


CPCString&
CPCString::operator <<(
				   const CPCString & pcNew
				   )
/*++

Routine Description:

	Append a second PCString to the current one.

Arguments:

	pcNew - the PCString to append.


Return Value:

	The current PCString after the append.

--*/
{
	CopyMemory(pchMax(), pcNew.m_pch, pcNew.m_cch); //!!!check for error
	fSetCch(pchMax() + pcNew.m_cch);
	return *this;
}

CPCString&
CPCString::operator <<(
				  const char * szNew
				  )
/*++

Routine Description:

	Append a sz string to the current PCString.

Arguments:

	szNew - the sz string to append.


Return Value:

	The current PCString after the append.

--*/
{
	while (*szNew)
		m_pch[m_cch++] = *(szNew++);

	return *this;
}

CPCString&
CPCString::operator <<(
				  const char cNew
				  )
/*++

Routine Description:

	Append a character to the current PCString.

Arguments:

	cNew - the character to append


Return Value:

	The current PCString after the append.

--*/
{
	m_pch[m_cch++] = cNew;
	return *this;
}
CPCString&
CPCString::operator <<(
				  const DWORD dwNew
				  )
/*++

Routine Description:

	Append a number to the current PCString.

Arguments:

	dwNew - the number to append


Return Value:

	The current PCString after the append.

--*/
{
	int iLen = wsprintf(m_pch+m_cch, "%lu", dwNew);
	_ASSERT(iLen>0);
	m_cch += iLen;
	return *this;
}

void
CPCString::vCopy(
				   CPCString & pcNew
				   )
/*++

Routine Description:

	Copy from a second PCString to this one.

Arguments:

	pcNew - the PCString to copy from


Return Value:

	None.

--*/
{
	CopyMemory(m_pch, pcNew.m_pch, pcNew.m_cch);
	m_cch = pcNew.m_cch;
}

void
CPCString::vMove(
				   CPCString & pcNew
				   )
/*++

Routine Description:

	"Move" (safe copy) from a second PCString to this one.

Arguments:

	pcNew - the PCString to copy from


Return Value:

	None.

--*/
{
	MoveMemory(m_pch, pcNew.m_pch, pcNew.m_cch);
	m_cch = pcNew.m_cch;
}


void
CPCString::vCopyToSz(
					 char * sz
				   )
/*++

Routine Description:

	Copy to an sz.

Arguments:

	sz - The sz to copy to.


Return Value:

	None.

--*/
{
	strncpy(sz, m_pch, m_cch);
	sz[m_cch] = '\0';
}

void
CPCString::vCopyToSz(
					 char * sz,
					 DWORD cchMax
				   )
/*++

Routine Description:

	Copy to an sz.

Arguments:

	sz - The sz string to copy to.
	cchMax - The maximum number of characters to copy.
	        (The last character will always be a \0.)


Return Value:

	None.

--*/
{
	DWORD cchLast = min(cchMax - 1, m_cch);
	strncpy(sz, m_pch, cchLast);
	sz[cchLast] = '\0';
}


void
CPCString::vMakeSz(
				   void
				   )
/*++

Routine Description:

	Adds a '\0' one chacter past the end of the string.

Arguments:

	None.

Return Value:

	None.

--*/
{
	m_pch[m_cch] = '\0';
}


char *
CPCString::sz(
				void
				)
/*++

Routine Description:

	Returns the current PCstring as an sz string.

	 Only to be used in the special case in which you
	 now that the string is null termianted.


Arguments:

	None.

Return Value:

	The sz string.

--*/
{
	_ASSERT('\0' == m_pch[m_cch]); //real
	return m_pch;
}


BOOL
CPCString::fCheckTextOrSpace(
						char & chBad
						)
/*++

Routine Description:

	 Returns TRUE if contains only 7-bit characters (and no nulls)


Arguments:

	chBad - the character that was bad.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	char * pchMax = m_pch + m_cch; //!!!should me pchMax();
	for (char * pch = m_pch; pch < pchMax; pch++)
	{
		if (('\0'==*pch) || !__isascii(*pch))
		{
			chBad = *pch;
			return FALSE;
		}
	}

	return TRUE;
}

BOOL
CPCString::fAppendCheck(
			 const CPCString & pcNew,
			 DWORD cchLast
			 )
/*++

Routine Description:

	Appends pcNew to the current PCString,
	but only if it the result is not too long.

Arguments:

	pcNew - the PCString to append to this string.
	cchLast - The greatest allowed length of the result.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	if(m_cch+pcNew.m_cch > cchLast)
		return FALSE;
	
	(*this)<<pcNew;
	return TRUE;
}

BOOL
CPCString::fAppendCheck(
			 char ch,
			 DWORD cchLast
			 )
/*++

Routine Description:

	Appends a character to the current PCString,
	but only if it the result is not too long.

Arguments:

	ch - the character to append to this string.
	cchLast - The greatest allowed length of the result.


Return Value:

	TRUE, if successful. FALSE, otherwise.

--*/
{
	if(m_cch+1 > cchLast)
		return FALSE;
	
	(*this)<<ch;
	return TRUE;
}


void
CPCString::vTr(
	const char * szFrom,
	char chTo
	)
/*++

Routine Description:

	 Translate any character in a set to some other character.

Arguments:

	szFrom - The set of characters to translate from
	chTo - The character to translate to


Return Value:

	None.

--*/
{
	const char * pchMax1 = pchMax();
	for (char * pch = m_pch; pch < pchMax1; pch++)
	{
		if (fCharInSet(*pch, szFrom))
			*pch = chTo;
	}
}


void
CPCString::vGetToken(
		  const char *	szDelimSet,
		  CPCString & pcToken
	)
/*++

Routine Description:

	Get a token from the current string. As a side-effect
	remove the token and any delimiters from the string.

Arguments:

	szDelimSet - The set of delimiter characters.
	pcToken - The token


Return Value:

	None.

--*/
{
	pcToken.m_pch = m_pch;

	while(m_cch > 0 && !fCharInSet(m_pch[0], szDelimSet))
	{
		m_pch++;
		m_cch--;
	}

	pcToken.fSetCch(m_pch);

	dwTrimStart(szDelimSet);

}

void
CPCString::vGetWord(
		  CPCString & pcWord
	)
/*++

Routine Description:

	Get a word from the current string. As a side-effect
	remove the word from the string. NOTE: this string
	should be trimmed of whitespace before calling this
	function.

Arguments:

	pcWord - The word


Return Value:

	None.

--*/
{
	pcWord.m_pch = m_pch;

	while(m_cch > 0 && isalpha(m_pch[0]))
	{
		m_pch++;
		m_cch--;
	}

	pcWord.fSetCch(m_pch);
}

DWORD
CPCString::dwCountChar(
			char ch
			)
/*++

Routine Description:

	Counts the number of times a specified character
	appears in the string.

Arguments:

	ch - the character of interest.


Return Value:

	The number of times it occurs.

--*/
{
	DWORD dw = 0;

	const char * pchMax1 = pchMax();
	for (char * pch = m_pch; pch < pchMax1; pch++)
	{
		if (*pch == ch)
			dw++;
	}

	return dw;
}


void
CPCString::vReplace(
				   const char * sz
				   )
/*++

Routine Description:

	Replaces the current string with a sz string of
	exactly the same length.

Arguments:

	sz - the sz string


Return Value:

	None.

--*/
{
	_ASSERT('\0' == sz[m_cch]);

	CopyMemory(m_pch, sz, m_cch);
}

void
CPCString::vSkipLine(void)
/*++

Routine Description:

	Skip a CRLF terminated line

Arguments:


Return Value:

	void

--*/
{
    while( (*m_pch) != '\n')
    {
        m_pch++;
        m_cch--;
        _ASSERT(m_cch);
    }

    m_pch++;
    m_cch--;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <randfail.h>

#ifdef __cplusplus
};
#endif

#include <malloc.h>

#include <objidl.h>
#include <nntps.h>
#include <xmemwrpr.h>
#include <nntptype.h>
#include <nntpapi.h>
#include <tigdflts.h>
#include <smartptr.h>
#include <cpool.h>
#include <tsunami.hxx>
#include <stdio.h>
#include <cstream.h>
#include <time.h>
//#include <tsvcinfo.hxx>
//#include <tcpproc.h>
#include "dbgtrace.h"
//#include "resource.h"

#include "tigtypes.h"
#include "fsconst.h"

#ifdef PROFILING
#include "icapexp.h"
#endif

typedef char *LPMULTISZ;

#include <filehc.h>
#include <artcore.h>
#include <frmstore.h>

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\tigmem.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tigmem.cpp

Abstract:

    This module contains definition for the CAllocator base class.
	That class can be used to allocator memory from a fixed buffer
	before resorting to "new".

Author:

    Carl Kadie (CarlK)     12-Jan-1995

Revision History:

--*/

//#ifndef	UNIT_TEST
//#include "tigris.hxx"
//#else
//#include	<windows.h>
//#include	"tigmem.h"
#include "stdinc.h"


//#ifndef	_ASSERT
//#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
//#endif
//#ifndef	TraceFunctEnter( sz )
//#define	TraceFunctEnter( sz )
//#endif
//#ifndef	ErrorTrace
//#define ErrorTrace  1 ? (void)0 : PreAsyncTrace
//#endif
//__inline int PreAsyncTrace( LPARAM lParam, LPCSTR szFormat, ... )
//{
//        return( 1);
//}
//
//#endif


char *
CAllocator::Alloc(
	  size_t size
	  )
{
	char * pv;

	//
	// Align the request on SIZE_T boundry
	//

 	if (0 != size%(sizeof(SIZE_T)))
		size += (sizeof(SIZE_T)) - (size%(sizeof(SIZE_T)));

	if( size <= (m_cchMaxPrivateBytes - m_ichLastAlloc) )
	{
		pv = m_pchPrivateBytes + m_ichLastAlloc;
		_ASSERT(0 == (((DWORD_PTR)pv)%(sizeof(SIZE_T)))); //should be SIZE_T aligned.
		m_ichLastAlloc += size;
		m_cNumberOfAllocs ++;
		return (char *) (pv);
	} else {
		m_cNumberOfAllocs ++;
		return PCHAR(PvAlloc(size));
	}
};


void
CAllocator::Free(
	 char *pv
	 )
{
	if (!pv)
		return;

	_ASSERT(0 != m_cNumberOfAllocs);

	if ( pv >= m_pchPrivateBytes &&
		pv < (m_pchPrivateBytes + m_cchMaxPrivateBytes))
	{
		m_cNumberOfAllocs --;
	} else {
		m_cNumberOfAllocs --;
		FreePv( pv );
	}

};

CAllocator::~CAllocator(void)
{
	TraceFunctEnter("CAllocator::~CAllocator");
	if (0 != m_cNumberOfAllocs)
	{
		ErrorTrace((DWORD_PTR) this, "CAllocator has %d allocations outstanding", m_cNumberOfAllocs);
		_ASSERT(FALSE);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\utest\testart.cpp ===
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <stdinc.h>
#include <xmemwrpr.h>

int _cdecl main(int argc, char **argv) {
    CHAR buffer[2048];
    CHAR* szFileName = "test.art";
    BOOL fResult;
    CHAR pcBuf[4000];
	CHAR szArticle[4000];

    _VERIFY( ExchMHeapCreate( NUM_EXCHMEM_HEAPS, 0, 100 * 1024, 0 ) );
    
    lstrcpy( szArticle, "From: alex\r\nSubject: test\r\nNewsgroups: test\r\n\r\n" );

#if 0
    HANDLE hFile = CreateFile(  szFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_READONLY,
                                NULL );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf( "Open file fail\n");
        exit( 1 );
    } 
#endif

    CAllocator Allocator( buffer, 20 );
    CNntpReturn nntpReturn;

    CArticleCore::InitClass();
    
    CArticleCore *particle = new CArticleCore;
    CPCString pcLine( pcBuf, 2048 );
#if 0
    fResult = particle->fInit(    szFileName,
                                nntpReturn,
                                &Allocator,
                                hFile );
#endif
	fResult = particle->fInit(szArticle,
							strlen(szArticle),
							strlen(szArticle),
							strlen(szArticle),
							&Allocator,
							nntpReturn);
    printf("fInit returns: %d\n", fResult );

    fResult = particle->fXOver( pcLine, nntpReturn );
    printf("fXOver returns %d\n", fResult );
    printf("%s\n", pcLine.m_pch);

    delete particle;

    CArticleCore::TermClass();

    ///////////////////////////////////
    //  Test CFromStoreArticle

    DeleteFile(szFileName);

    printf("Article before munging:\n%s\n", szArticle);

    CFromStoreArticle::InitClass();

    CFromStoreArticle*   pstoreart = new CFromStoreArticle("LoginName");
    fResult = pstoreart->fInit(szArticle,
                             strlen(szArticle),
                             strlen(szArticle),
                             strlen(szArticle),
                             &Allocator,
                             nntpReturn);
    printf("fInit CFromStoreArticle returns: %d\n", fResult);

    fResult = pstoreart->fValidate( nntpReturn );
    printf("fValidate CFromStoreArticle returns: %d\n", fResult);

    char    szHubName[MAX_PATH*2];
    char    szDNSName[MAX_PATH*2];
    DWORD   cbHubName = sizeof(szHubName);

    if (GetComputerName(szHubName, &cbHubName) == 0)
    {
        printf("GetComputerName() failed %d\n", GetLastError());
        CFromStoreArticle::TermClass();
        _VERIFY( ExchMHeapDestroy());
        return 0;
    }

    printf("szHubName %s\n", szHubName);

    WSADATA  WsaData;
    if (WSAStartup(0x0101, &WsaData) == SOCKET_ERROR)
    {
        printf("WSAStartup() failed %d\n", GetLastError());
        CFromStoreArticle::TermClass();
        _VERIFY( ExchMHeapDestroy() );
        return 0;
    }

	if( gethostname( szDNSName, sizeof( szDNSName ) ) == SOCKET_ERROR )
    {
		printf("gethostname() failed %d\n", GetLastError());
        CFromStoreArticle::TermClass();
        WSACleanup();
        _VERIFY( ExchMHeapDestroy() );
        return 0;
    }

    printf("szDNSName %s\n", szDNSName);

    WSACleanup();

    CPCString   pcHub(szHubName, lstrlen(szHubName));
    CPCString   pcDNS(szDNSName, lstrlen(szDNSName));

    fResult = pstoreart->fMungeHeaders(pcHub, pcDNS, 0, nntpReturn);

    printf("fMungeHeader CFromStoreArticle return %d\n", fResult);

    //  Try to print the entire article out
    DWORD   cBuf = sizeof(pcBuf);
    ZeroMemory(pcBuf, cBuf);
    fResult = pstoreart->fGetHeader( "Message-Id", (UCHAR*)pcBuf, cBuf+1, cBuf );
    printf("Message-id return %d: %s\n", fResult, pcBuf);

    cBuf = sizeof(pcBuf);
    ZeroMemory(pcBuf, cBuf);
    fResult = pstoreart->fGetHeader( "Subject", (UCHAR*)pcBuf, cBuf+1, cBuf );
    printf("Subject return %d: %s\n", fResult, pcBuf);

    cBuf = sizeof(pcBuf);
    ZeroMemory(pcBuf, cBuf);
    fResult = pstoreart->fGetHeader( "From", (UCHAR*)pcBuf, cBuf+1, cBuf );
    printf("From return %d: %s\n", fResult, pcBuf);

    cBuf = sizeof(pcBuf);
    ZeroMemory(pcBuf, cBuf);
    fResult = pstoreart->fGetHeader( "Newsgroups", (UCHAR*)pcBuf, cBuf+1, cBuf );
    printf("Newsgroups return %d: %s\n", fResult, pcBuf);

    cBuf = sizeof(pcBuf);
    ZeroMemory(pcBuf, cBuf);
    fResult = pstoreart->fGetHeader( "Path", (UCHAR*)pcBuf, cBuf+1, cBuf );
    printf("Path return %d: %s\n", fResult, pcBuf);

    cBuf = sizeof(pcBuf);
    ZeroMemory(pcBuf, cBuf);
    fResult = pstoreart->fGetHeader( "Date", (UCHAR*)pcBuf, cBuf+1, cBuf );
    printf("Date return %d: %s\n", fResult, pcBuf);

    //  print out the entire article
    pstoreart->CopyHeaders(pcBuf);
    printf("Article Headers after munging:\n%s\n", pcBuf);

    delete pstoreart;
    CFromStoreArticle::TermClass();

    _VERIFY( ExchMHeapDestroy() );
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\cbuffer\gcache.cpp ===
//#ifdef	UNIT_TEST
//#include	<windows.h>
//#include	"gcache.h"
//#else
#include	"stdinc.h"
//#endif

#ifndef	_ASSERT
#define	_ASSERT( f )	if( (f) ) ; else DebugBreak()
#endif

DWORD	CClassAllocator::cbJunk	= 0 ;
DWORD	CCache::cbJunk = 0 ;

CCache::CCache(	void**	ppv,	DWORD	size	)	:
	m_pCache( ppv ), m_clpv( size ) {
	ZeroMemory( ppv, m_clpv * sizeof( void * ) ) ;
}

CCache::~CCache( ) {
	for( DWORD	i=0; i<m_clpv; i++ ) {
		_ASSERT( m_pCache[i] == 0 ) ;
	}
}

void*	
CCache::InternalFree(	void*	lpv ) {
	for(	DWORD	i=0;	i<m_clpv && lpv != 0 ; i++ ) {
		lpv = (void*)InterlockedExchangePointer( &m_pCache[i], lpv ) ;
	}
	return	lpv ;
}

void*
CCache::InternalAlloc()	{
	LPVOID	lpv	 = 0 ;
	for( DWORD	i=0; i<m_clpv && lpv == 0; i++ ) {
		lpv = (void*)InterlockedExchangePointer( &m_pCache[i], NULL ) ;
	}
	return	lpv ;
}

void
CCache::Free(	void*	lpv,	CClassAllocator*	pAllocator ) {

#ifdef	DEBUG
	_ASSERT( pAllocator->RangeCheck( lpv ) ) ;
	pAllocator->Erase( lpv ) ;
#endif

	lpv = InternalFree( lpv ) ;

	if( lpv != 0 ) {
#ifdef	DEBUG
		_ASSERT( pAllocator->EraseCheck( lpv ) ) ;
#endif
		pAllocator->Release( lpv ) ;
	}
}

void*
CCache::Alloc(	DWORD	size,	CClassAllocator*	pAllocator, DWORD &cbOut )	{

	void*	lpv = InternalAlloc() ;

#ifdef	DEBUG
	_ASSERT( pAllocator->SizeCheck( size ) ) ;
	if( lpv != 0 ) {
		_ASSERT(	pAllocator->EraseCheck( lpv ) ) ;
	}
#endif

	if( lpv == 0 ) {
		lpv = pAllocator->Allocate(	size, cbOut ) ;
	}
	return	lpv ;
}

void*
CCache::Empty(	)	{
	return	InternalAlloc() ;
}

void
CCache::Empty( CClassAllocator*	pAllocator ) {

	LPVOID	lpv = 0 ;
	for( DWORD i=0; i<m_clpv; i++ ) {
		lpv = (void*)InterlockedExchangePointer( &m_pCache[i], NULL ) ;
		if( lpv != 0 ) {
			pAllocator->Release( lpv ) ;
		}
	}
}

CClassAllocator::CClassAllocator()	{
}

CClassAllocator::~CClassAllocator()	{
}


#ifdef	DEBUG
void
CClassAllocator::Erase(	LPVOID	lpv ) {

}

BOOL
CClassAllocator::EraseCheck( LPVOID	lpv )	{

	return	TRUE ;
}

BOOL
CClassAllocator::RangeCheck(	LPVOID	lpv )	{
	return	TRUE ;
}

BOOL
CClassAllocator::SizeCheck(	DWORD	cb )	{
	return	TRUE ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\article\src\timeconv.cpp ===
/* --------------------------------------------------------------------------
	timeconv.cpp
		Functions to perform various time conversion operations.
	
	Copyright (C) 1994, Microsoft Corporation.
	All rights reserved.

	Author:
		Lindsay Harris - lindsayh

   -------------------------------------------------------------------------- */

//#include "tigris.hxx"
#include "stdinc.h"
#include <stdlib.h>

/*
 *   A handcrafted time zone string to GMT offsets table.  This is not
 *  a very good way to handle this.
 */

static  struct
{
	int		iTZOffset;		// Arithmetic offset from GMT, in seconds.
	char    rgchTZName[ 4 ];	// String representation of time zone.
} _TZ_NAME[] =
{
	{ 0, 		{ 'G', 'M', 'T', '\0' } },
	{ 0, 		{ 'U', 'T', 'C', '\0' } },
	{ 0, 		{ 'U', 'T', '\0', '\0' } },
	{ -14400,	{ 'E', 'D', 'T', '\0' } },
	{ -18000,	{ 'E', 'S', 'T', '\0' } },
	{ -18000,	{ 'C', 'D', 'T', '\0' } },
	{ -21600,	{ 'C', 'S', 'T', '\0' } },
	{ -21600,	{ 'M', 'D', 'T', '\0' } },
	{ -25200,	{ 'M', 'S', 'T', '\0' } },
	{ -25200,	{ 'P', 'D', 'T', '\0' } },
	{ -28800,	{ 'P', 'S', 'T', '\0' } },
	{  43200,	{ 'N', 'Z', 'S', '\0' } },	// NZ standard time.
	{  46800,	{ 'N', 'Z', 'D', '\0' } },
};

#define	NUM_TZ	(sizeof( _TZ_NAME ) / sizeof( _TZ_NAME[ 0 ] ))

// The date Jan 1, 1970 00:00:00 in type FILETIME
#define	ft1970high 27111902
#define	ft1970low 3577643008

static FILETIME ft1970 = {ft1970low, ft1970high};


// The number of FILETIME units (100's of nanoseconds) in a time_t unit (seconds)
#define dFiletimePerDTime_t 10000000

#define BUNCH_FACTOR	  6
#define MESSAGE_ID_SPAN	  64

char MsgIdSet[MESSAGE_ID_SPAN] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','#','$'
};

/*
 *   English language month table.
 */

static  char  *rgchMonth[ 12 ] =
{
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};

/*
 *   English language weekday table.
 */

static  char  *rgchDayOfWeek[ 7 ] =
{
	"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
};

/* --------------------------------------------------------------------------
   dwConvertAsciiTime
   	Convert a usenet (unix) style date string into a MOS time value.  There
   	seem to be some variations on this format.  Time returned is GMT/UNC.


   Author:
   	Lindsay Harris - lindsayh

   History:
    13:49 on Thu 31 Mar 1994    -by-    Lindsay Harris   [lindsayh]
   	First version.

   -------------------------------------------------------------------------- */
BOOL
ConvertAsciiTime( char *pchInput, FILETIME	&filetime )
{
	DWORD  dwRet;			// Return value,  0 on error.
	
	int	   iTZOffset = 0;		// Time zone offset, if it can be decided.

	SYSTEMTIME  tm;			// Result is built in here.

	
	char  *pchTemp;

	dwRet = 0;

	GetSystemTime(&tm);

	
	if( pchTemp = strchr( pchInput, ':' ) )
	{
		/*
		 *  Found a colon, which separates hours and minutes.  Probably valid.
		 *  The other part of the test is if the preceeding character is a
		 *  digit which is also preceeded by either a digit or a space char.
		 *  That is,  we have either <digit><digit>: or <space><digit>:
		 */

		if( isdigit( *(pchTemp - 1) ) &&
			(isdigit( *(pchTemp - 2) ) || *(pchTemp - 2) == ' ') )
		{
			tm.wHour = (WORD)atoi( pchTemp - 2 );
			tm.wMinute = (WORD)atoi( pchTemp + 1 );

			pchTemp += 3;		// Skip to char after minutes digit.

			if( *pchTemp == ':' )
			{
				tm.wSecond = (WORD)atoi( pchTemp + 1 );
				tm.wMilliseconds = 0;

				pchTemp += 3;			// Skip :ss to first byte past end.
			}
			else
			{
				tm.wSecond = 0;
				tm.wMilliseconds = 0;
			}
			
			//  Time zone information - much guess work here!
			while( *pchTemp && *pchTemp == ' ' )
					++pchTemp;

			/*
			 *   Sometimes there is a time zone offset encoded.  This starts
			 *  with either a + or - sign or a digit,  having 4 digits in all.
			 *  Otherwise,  presume it is some sort of time zone string,
			 *  of 3 letters and totally ambiguous as to where it is unless
			 *  it happens to be GMT.
			 */
			
			if( *pchTemp == '-' || *pchTemp == '+' || isdigit( *pchTemp ) )
			{
				//  Appears to be numeric value.
				int   iSign;

				iSign = *pchTemp == '-' ? -60 : 60;

				if( !isdigit( *pchTemp ) )
					++pchTemp;				// Skip the sign.
				
				iTZOffset = (*pchTemp - '0') * 10 + *(pchTemp + 1) - '0';
				pchTemp += 2;
				iTZOffset *= 60;		// Into minutes.

				iTZOffset += (*pchTemp - '0') * 10 + *(pchTemp + 1) - '0';

				iTZOffset *= iSign;		// Into seconds.


			}
			else
			{
				int  iIndex;

				iTZOffset = 0;			// Default to GMT if nothing found.

				for( iIndex = 0; iIndex < NUM_TZ; ++iIndex )
				{
					if( !strncmp( pchTemp, _TZ_NAME[ iIndex ].rgchTZName, 3 ) )
					{
						iTZOffset = _TZ_NAME[ iIndex ].iTZOffset;

						break;
					}
				}
			}

			/*
			 *   Now try for the date.  The format is day of month, three
			 *  letter abbreviation of month, then year, as either 2 or 4
			 *  digits.  This is at the start of the string, possibly
			 *  preceeded by a 3 letter day of week with following comma.
			 */
			
			pchTemp = pchInput;

			// skip over any leading blanks
			while( *pchTemp && *pchTemp == ' ' )
					++pchTemp;

			if( *(pchTemp + 3) == ',' )
				pchTemp += 5;			// Skip over day + comma + space.
			
			if( (*pchTemp == ' ' || isdigit( *pchTemp )) &&
				(*(pchTemp + 1) == ' ' || isdigit( *(pchTemp + 1) )) )
			{
				//  Looks good, so turn into day of month.

				int   iIndex;


				tm.wDay = 0;
				if( isdigit( *pchTemp ) )
					tm.wDay = *pchTemp - '0';

				++pchTemp;

				if( isdigit( *pchTemp ) )
					tm.wDay = tm.wDay * 10 + *pchTemp++ - '0';

				pchTemp++;		// Skip the space before name of month.

				for( iIndex = 0; iIndex < 12; ++iIndex )
				{
					if( strncmp( pchTemp, rgchMonth[ iIndex ], 3 ) == 0 )
					{
						tm.wMonth = iIndex + 1;
						break;
					}
				}
				pchTemp += 4;
				iIndex = atoi( pchTemp );
				if( iIndex < 50 ) {
					iIndex += 2000;
			    } else if (iIndex < 100) {
			        iIndex += 1900;
			    }
				
				tm.wYear = (WORD)iIndex;

			}

		}

	}

	return	SystemTimeToFileTime( &tm, &filetime ) ;
}



/* -----------------------------------------------------------------------
  GetArpaDate
  	Returns a pointer to static memory containing the current date in
  	Internet/ARPA standard format.

  Author
 	Lindsay Harris	- lindasyh

  History
	13:49 on Wed 20 Apr 1994    -by-    Lindsay Harris   [lindsayh]
  	First version.
	Imported to Tigris. Added passed-in buffer, changed year to 4-digit format

   ----------------------------------------------------------------------- */


char  *
GetArpaDate( char achReturn[ cMaxArpaDate ] )
{

	char    chSign;							// Sign to print.

	DWORD   dwResult;

	int		iBias;							// Offset relative to GMT.

	TIME_ZONE_INFORMATION	tzi;			// Local time zone data.

	SYSTEMTIME	stUTC;						// The current time in UTC/GMT



	dwResult = GetTimeZoneInformation( &tzi );
	GetLocalTime( &stUTC );

	//  Calculate the time zone offset.
	iBias = tzi.Bias;
	if( dwResult == TIME_ZONE_ID_DAYLIGHT )
		iBias += tzi.DaylightBias;
	
	/*
	 *   We always want to print the sign for the time zone offset, so
	 *  we decide what it is now and remember that when converting.
	 *  The convention is that west of the 0 degree meridian has a
	 *  negative offset - i.e. add the offset to GMT to get local time.
	 */

	if( iBias > 0 )
	{
		chSign = '-';		// Yes, I do mean negative.
	}
	else
	{
		iBias = -iBias;
		chSign = '+';
	}

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	_snprintf( achReturn, cMaxArpaDate , "%s, %02d %s %04d %02d:%02d:%02d %c%02d%02d",
			rgchDayOfWeek[stUTC.wDayOfWeek], stUTC.wDay, rgchMonth[ stUTC.wMonth - 1 ],
			stUTC.wYear,
			stUTC.wHour, stUTC.wMinute, stUTC.wSecond, chSign,
			(iBias / 60) % 100, iBias % 60 );

	return achReturn;
}

/* -----------------------------------------------------------------------
  GetMessageIDDate

   ----------------------------------------------------------------------- */


char  *
GetMessageIDDate( DWORD GroupId, DWORD ArticleId, char achReturn[ cMaxMessageIDDate ] )
{
	SYSTEMTIME	stUTC;						// The current time in UTC/GMT
	FILETIME    ftUTC;
	DWORD NumSextets = (sizeof(MsgIdSet) / BUNCH_FACTOR)+1;
	LARGE_INTEGER liMask;
	LARGE_INTEGER liSextet;
	LARGE_INTEGER * pliDate;

#if 0
	GetSystemTime( &stUTC );

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	wsprintf( achReturn, "%d%s%d.%02d%02d%02d%04d",
			stUTC.wYear,
			rgchMonth[ stUTC.wMonth - 1 ],
			stUTC.wDay,
			stUTC.wHour,
			stUTC.wMinute,
			stUTC.wSecond,
			stUTC.wMilliseconds);
#endif

	// If articles are created sufficiently close, use the sum of grp and art id to create a difference
	// NOTE: Only 24 bits are taken so that the difference is within 1.6 secs
	DWORD dwGrpArtSuffix = GroupId + ArticleId;
	dwGrpArtSuffix &= 0x00ffffff;

	GetSystemTime( &stUTC );
	SystemTimeToFileTime( &stUTC, &ftUTC );

	liMask.QuadPart = 0x3F;		// Mask to get sextets
	pliDate = (LARGE_INTEGER *) (void *) & ftUTC;

	// add a 24-bit offset that is a function of the group id and article id
	pliDate->QuadPart += dwGrpArtSuffix;

	// For each sextet in the date, lookup a char in the lookup array
	for(DWORD i=0; i<NumSextets; i++)
	{
		liSextet.QuadPart = ( pliDate->QuadPart ) & liMask.QuadPart;
		liSextet.QuadPart >>= i*BUNCH_FACTOR;
		liMask.QuadPart <<= BUNCH_FACTOR;

		_ASSERT( 0 <= liSextet.QuadPart && liSextet.QuadPart <= MESSAGE_ID_SPAN-1 );
		
		achReturn [i] = MsgIdSet [liSextet.QuadPart];
	}

	achReturn [i] = '\0';

	return achReturn;
}

/* -----------------------------------------------------------------------
  SystemTimeToTime_T
  	Coverts SYSTEMTIME to time_t.

  	Returns 0 if date is before 1970 or -1 if far, far into the future.


  Author
  	Carl Kadie - carlk

  History
	Thu, 15 Dec 1994   -by-    Carl Kadie [carlk]
  	First version.

   ----------------------------------------------------------------------- */

time_t
SystemTimeToTime_T(SYSTEMTIME & st)
{
	FILETIME ft;

	// Convert from SYSTEMTIME to FILETIME
	SystemTimeToFileTime(&st, &ft);

	// If date is before 1970, return 0
	if (filetimeGreaterThan(ft1970, ft))
	{
		return 0;
	} else {
		// Convert from FILETIME to time_t
		ft = filetimeSubtract(ft, ft1970);
		return dTime_tFromDFiletime(ft);
	}
}

/* -----------------------------------------------------------------------
  Time_TToSystemTime
  	Converts time_t to SYSTEMTIME

  Author
  	Carl Kadie - carlk

  History
	Thu, 15 Dec 1994   -by-    Carl Kadie [carlk]
  	First version.

   ----------------------------------------------------------------------- */

void
Time_TToSystemTime(time_t tt, SYSTEMTIME & st)
{
	// These must be the same
	_ASSERT(sizeof(LARGE_INTEGER) == sizeof(FILETIME));

	FILETIME ft;

	// Convert from time_t to FILETIME
	ft = dFiletimeFromDTime_t(tt);
	ft = filetimeAdd(ft1970, ft);


	// Convert from FILETIME to SYSTEMTIME
	FileTimeToSystemTime(&ft, &st);

}

/* -----------------------------------------------------------------------
  Time_TToArpaDate
  	Given a time_t time, returns Internet/ARPA standard format. Uses
	Win32 functions, so should be more reliable than "ctime"
	It uses no statics variables or buffers, but does change the buffer
	it is given as an argument.

	The character buffer passed in should be at least 26 characters long.

  Author
  	Carl Kadie - carlk

  History
  	Thu 15 Dec 1994	- by - Carl Kadie [carlk]
	Based on GetArpaDate by Lindsay Harris   [lindsayh]
  	First version.

   ----------------------------------------------------------------------- */


char  *
Time_TToArpaDate( time_t tt, char * achReturn )
{
	SYSTEMTIME	st;

	_ASSERT(achReturn); //real assert

	Time_TToSystemTime(tt, st);

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	wsprintf( achReturn, "%d %s %02d %02d:%02d:%02d",
			st.wDay, rgchMonth[ st.wMonth - 1 ],
			st.wYear % 100,
			st.wHour, st.wMinute, st.wSecond);

	return achReturn;
}



/* -----------------------------------------------------------------------
  FileTimeToArpaDate
  	Given a filetime time, returns Internet/ARPA standard format.
  Author
  	Carl Kadie - carlk

  History
  	1 March 1995 - by - Carl Kadie [carlk]
	Based on SystemTimeToArpaDate

   ----------------------------------------------------------------------- */


char  *
FileTimeToArpaDate(const FILETIME & ft, char * achReturn )
{

	SYSTEMTIME	st;

	_ASSERT(achReturn); //real assert

	FileTimeToSystemTime(&ft, &st);

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	wsprintf( achReturn, "%d %s %02d %02d:%02d:%02d",
			st.wDay, rgchMonth[ st.wMonth - 1 ],
			st.wYear % 100,
			st.wHour, st.wMinute, st.wSecond);

	return achReturn;
}


/* -----------------------------------------------------------------------
  FileTimeToLocalArpaDate
  	Given a filetime time, returns Internet/ARPA standard format.
  Author
  	Carl Kadie - carlk

  History
  	7 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */


char  *
FileTimeToLocalArpaDate(const FILETIME & ft, char * achReturn )
{

	FILETIME ftLocal;
	SYSTEMTIME	st;

	_ASSERT(achReturn); //real assert

	FileTimeToLocalFileTime(&ft, &ftLocal);

	FileTimeToSystemTime(&ftLocal, &st);

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	wsprintf( achReturn, "%d %s %02d %02d:%02d:%02d",
			st.wDay, rgchMonth[ st.wMonth - 1 ],
			st.wYear % 100,
			st.wHour, st.wMinute, st.wSecond);

	return achReturn;
}

/* -----------------------------------------------------------------------
  FileTimeToLocalArpaDateEx
  	Given a filetime time, returns Internet/ARPA standard format.
  	( with offset and four digit year )
  Author
  	Kangrong Yan - KangYan

  History
  	20 June 1998 - by - Kangrong Yan [KangYan]

   ----------------------------------------------------------------------- */
char  *
FileTimeToLocalArpaDateEx(const FILETIME & ft, char * achReturn )
{
	char    chSign;							// Sign to print.
	DWORD   dwResult;
	int		iBias;							// Offset relative to GMT.
	TIME_ZONE_INFORMATION	tzi;			// Local time zone data.
	SYSTEMTIME	st;							// The local time
	FILETIME	ftLocal;


	dwResult = GetTimeZoneInformation( &tzi );

	// Get local FILETIME and convert it into system time
	FileTimeToLocalFileTime(&ft, &ftLocal);
	FileTimeToSystemTime(&ftLocal, &st);

	//  Calculate the time zone offset.
	iBias = tzi.Bias;
	if( dwResult == TIME_ZONE_ID_DAYLIGHT )
		iBias += tzi.DaylightBias;
	
	/*
	 *   We always want to print the sign for the time zone offset, so
	 *  we decide what it is now and remember that when converting.
	 *  The convention is that west of the 0 degree meridian has a
	 *  negative offset - i.e. add the offset to GMT to get local time.
	 */

	if( iBias > 0 )
	{
		chSign = '-';		// Yes, I do mean negative.
	}
	else
	{
		iBias = -iBias;
		chSign = '+';
	}

	/*
	 *    No major trickery here.  We have all the data, so simply
	 *  format it according to the rules on how to do this.
	 */

	_snprintf( achReturn, cMaxArpaDate , "%s, %02d %s %04d %02d:%02d:%02d %c%02d%02d",
			rgchDayOfWeek[st.wDayOfWeek], st.wDay, rgchMonth[ st.wMonth - 1 ],
			st.wYear,
			st.wHour, st.wMinute, st.wSecond, chSign,
			(iBias / 60) % 100, iBias % 60 );

	return achReturn;

}



/* -----------------------------------------------------------------------
  dTime_tFromDFiletime
	Converts changes in filetimes (dFiletime) to changes in time_ts (dTime_t)

	Do not use to change absolute FILETIME's to absolute time_t's

	Returns -1 if the dFiletime overflows the dTime_t

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

time_t
dTime_tFromDFiletime(const FILETIME & ft)
{
	_ASSERT(sizeof(LARGE_INTEGER) == sizeof(FILETIME));
	_ASSERT(sizeof(LARGE_INTEGER) == (2 * sizeof(time_t)));

	LARGE_INTEGER * pli = (LARGE_INTEGER *)(void *) &ft;
	LARGE_INTEGER liHold;

	liHold.QuadPart = pli->QuadPart / dFiletimePerDTime_t;

	if (0 == liHold.HighPart)
		return (time_t) liHold.LowPart;
	else
		return (time_t) -1;
}


/* -----------------------------------------------------------------------
  dFiletimeFromDTime_t
	Converts changes in time_ts (dTime_t) to changes in filetimes (dFiletime)

	Do not use to change absolute time_t's to absolute FILETIME's

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

FILETIME
dFiletimeFromDTime_t(time_t tt)
{
	LARGE_INTEGER li;

	_ASSERT(sizeof(LARGE_INTEGER) == sizeof(FILETIME));
	_ASSERT(sizeof(LARGE_INTEGER) == (2 * sizeof(time_t)));
	_ASSERT(0 <= tt); //time_t is signed, FILETIME is not
	_ASSERT(0 <= dFiletimePerDTime_t); //LargeInteger is signed, FILETIME is not


	li.QuadPart = (LONGLONG)tt * dFiletimePerDTime_t;

	
	return *((FILETIME *)(void *)(&li));
}


/* -----------------------------------------------------------------------
  vFiletimeCurrent
	Gives the current time in FILETIME

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

void
vFiletimeCurrent(FILETIME & ft)
{
	SYSTEMTIME  st;
	GetSystemTime(&st);
	SystemTimeToFileTime(&st, &ft);
}


/* -----------------------------------------------------------------------
  vTime_tCurrent
	Gives the current time in time_t

  Author
  	Carl Kadie - carlk

  History
  	22 May 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

time_t
time_tCurrent()
{
	SYSTEMTIME  st;
	GetSystemTime(&st);
	return SystemTimeToTime_T(st);
}


/* -----------------------------------------------------------------------
  filetimeAdd
	Add two filetimes (or add increment a filetime by a dFiletime)

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

FILETIME
filetimeAdd(const FILETIME & ft1, const FILETIME & ft2)
{
	LARGE_INTEGER li;

	LARGE_INTEGER * pli1 = (LARGE_INTEGER *) (void *) & ft1;
	LARGE_INTEGER * pli2 = (LARGE_INTEGER *) (void *) & ft2;

	_ASSERT(0 <= pli1->HighPart && 0 <= pli2->HighPart); //LargeInteger is signed, FILETIME is not

	li.QuadPart = pli1->QuadPart + pli2->QuadPart;
	
	return *((FILETIME *)(void *)(&li));
}

/* -----------------------------------------------------------------------
  filetimeSubtract
	Subtract two filetimes (or subtract a filetime by a dFiletime)

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

FILETIME
filetimeSubtract(const FILETIME & ft1, const FILETIME & ft2)
{
	LARGE_INTEGER li;

	LARGE_INTEGER * pli1 = (LARGE_INTEGER *) (void *) & ft1;
	LARGE_INTEGER * pli2 = (LARGE_INTEGER *) (void *) & ft2;

	_ASSERT(0 <= pli1->HighPart && 0 <= pli2->HighPart); //LargeInteger is signed, FILETIME is not

	li.QuadPart = pli1->QuadPart - pli2->QuadPart;

	return *((FILETIME *)(void *)(&li));
}


/* -----------------------------------------------------------------------
  filetimeGreaterThan
	Compare two filetimes

  Author
  	Carl Kadie - carlk

  History
  	24 March 1995 - by - Carl Kadie [carlk]

   ----------------------------------------------------------------------- */

BOOL
filetimeGreaterThan(const FILETIME & ft1, const FILETIME & ft2)
{
    return ((ft1.dwHighDateTime == ft2.dwHighDateTime) && (ft1.dwLowDateTime > ft2.dwLowDateTime)) ||
    		(ft1.dwHighDateTime > ft2.dwHighDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\cbuffer\stdinc.h ===
#ifndef	_STDINC_H_
#define	_STDINC_H_

//
// disables a browser info warning that breaks the build
//
#pragma warning (disable:4786)

//
// disables redundant warning about / in // comments
//
#pragma warning (disable:4010)

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <randfail.h>

#ifdef __cplusplus
};
#endif

#include <smartptr.h>
#include <cpool.h>
#include <xmemwrpr.h>
#include <nntpcons.h>
#include "gcache.h"
#include "cbuffer.h"

#pragma hdrstop

#endif	// _STDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\cbuffer\cbuffer.cpp ===
/*++

	packet.cpp

	This file contains the code which implements the CPacket derived classes.
	A CPacket derived object describes the most basic IO operation that is performed.


--*/




#include	"stdinc.h"

#ifdef	CIO_DEBUG
#include	<stdlib.h>		// For Rand() function
#endif

#ifdef	_NO_TEMPLATES_

DECLARE_ORDEREDLISTFUNC( CPacket ) 

#endif


//
//	Module globals 
//
CPool	CBufferAllocator::rgPool[ MAX_BUFFER_SIZES ] ;//!!!How do you give this a signature?
DWORD	CBufferAllocator::rgPoolSizes[ MAX_BUFFER_SIZES ] ;
CBufferAllocator	CBuffer::gAllocator ;
CBufferAllocator*	CSmallBufferCache::BufferAllocator = 0 ;
CBufferAllocator*	CMediumBufferCache::BufferAllocator = 0 ;
CSmallBufferCache*	CBuffer::gpDefaultSmallCache = 0 ;
CMediumBufferCache*	CBuffer::gpDefaultMediumCache = 0  ;

//
//  Control what size buffers the server uses
//
DWORD   cbLargeBufferSize = 33 * 1024 ;
DWORD   cbMediumBufferSize = 4 * 1024 ;
DWORD   cbSmallBufferSize =  512 ;

BOOL
CBufferAllocator::InitClass( ) {
/*++

Routine Description : 

	This function initializes the CBufferAllocator class which handles all 
	memory management of CBuffer objects.
	We will use three different CPools to produce CBuffers of different sizes.

Arguments : 

	None.

Return Value : 

	TRUE if successfull false otherwise !

--*/

	rgPoolSizes[0] = cbSmallBufferSize ;
	rgPoolSizes[1] = cbMediumBufferSize ;
	rgPoolSizes[2] = cbLargeBufferSize ;

	for( int i=0; i< sizeof( rgPoolSizes ) / sizeof( rgPoolSizes[0] ); i++ ) {
		if( !rgPool[i].ReserveMemory(	MAX_BUFFERS / ((i+1)*(i+1)), rgPoolSizes[i] ) ) break ;
	} 		
	
	if( i != sizeof( rgPoolSizes ) / sizeof( rgPoolSizes[0] ) ) {
		for( i--; i!=0; i-- ) {
			rgPool[i].ReleaseMemory() ;
		}
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CBufferAllocator::TermClass()	{
/*++

Routine Description : 

	Clean up all the CPool objects we use to manage CBuffer memory

Arguments : 

	None.

Return Value ;

	TRUE if successfull FALSE otherwise.

--*/

	BOOL	fSuccess = TRUE ;
	for( int i=0; i< sizeof( rgPoolSizes ) / sizeof( rgPoolSizes[0] ); i++ ) {
		_ASSERT( rgPool[i].GetAllocCount() == 0 ) ;
		fSuccess &= rgPool[i].ReleaseMemory() ;
	} 		
	return	fSuccess ;
}

LPVOID	
CBufferAllocator::Allocate(	
					DWORD	cb,	
					DWORD&	cbOut 
					) {
/*++

Routine description : 

	Allocate the memory required for a CBuffer object from the CPool which 
	will provide a large enough block of memory.
	We will use a portion of the allocated memory to hold a pointer back to 
	the particular CPool from which this memory was allocated

Arguments : 

	cb -	Number of bytes required
	cbOut -	Number of bytes allocated for the CBuffer

Return Value : 

	Pointer to the allocated block of memory - NULL on failure

--*/

	//cb += sizeof( CBuffer ) ;
	cb += sizeof( CPool* ) ; 

	//_ASSERT(	size == sizeof( CBuffer ) ) ;

	cbOut = 0 ;
	for( int i=0; i<sizeof(rgPoolSizes)/sizeof(rgPoolSizes[0]); i++ ) {
		if( cb < rgPoolSizes[i] ) {
			cbOut = rgPoolSizes[i] - sizeof( CPool * ) ;
			void *pv = rgPool[i].Alloc() ;
			if( pv == 0 ) {
				return	0 ;
			}
			((CPool **)pv)[0] = &rgPool[i] ;
			return	(void *)&(((CPool **)pv)[1]) ;
		}
	}
	_ASSERT( 1==0 ) ;
	return	0 ;
}

void
CBufferAllocator::Release(	
					void*	pv 
					)	{
/*++

Routine description : 

	Release memory that was used for a CBuffer object back to its CPool
	examine the DWORD before the allocated memory to figure out which CPool
	to release this too.

Arguments : 

	pv - the memory being released

Return Value : 

	None.

--*/
	CPool**	pPool = (CPool**)pv ;
	pPool[-1]->Free( (void*)&(pPool[-1]) ) ;
}

#ifdef	DEBUG

//
//	Debug functions - the following functions all do various forms of validation
//	to ensure that memory is being properly manipulated
//

int	
CBufferAllocator::GetPoolIndex(	
						void*	lpv 
						)	{
/*++

Routine Description : 

	figure out which pool this block of memory was allocated out of.

Agruments : 

	lpv - pointer to a block of memory allocated by CBufferAllocator
		when it was allocated we stuck a pointer to the CPool we used 
		ahead of the pointer

Return Value : 

	index of the pool used to allocate the buffer

--*/
	CPool**	pPool = (CPool**)lpv ;
	CPool*	pool = pPool[-1] ;

	for( int i=0; i < sizeof(rgPoolSizes)/sizeof(rgPoolSizes[0]); i++ ) {
		if( pool == &rgPool[i] ) {
			return	i ;
		}
	}
	return	-1 ;
}

void
CBufferAllocator::Erase(	
						void*	lpv 
						) {
/*++

Routine Description : 

	Fill a block of released memory so it is easy to spot during debug.

Arguments : 

	lpv - released memory

Returns : 

	Nothing

--*/

	int	i = GetPoolIndex( lpv ) ;
	_ASSERT( i >= 0 ) ;

	DWORD	cb = rgPoolSizes[i] - sizeof( CPool*) ;
	FillMemory( (BYTE*)lpv, cb, 0xCC ) ;
}

BOOL
CBufferAllocator::EraseCheck(	
						void*	lpv 
						)	{
/*++

Routine Description : 

	Verify that a block of memory has been erased using CBufferAllocator::Erase()

Arguments : 

	lpv - released memory

Returns : 

	TRUE if correctly erased
	FALSE otherwise

--*/
	int	i = GetPoolIndex( lpv ) ;
	_ASSERT( i>=0 ) ;
	
	DWORD	cb = rgPoolSizes[i] - sizeof( CPool* ) ;
	
	for( DWORD	j=sizeof(CPool*); j < cb; j++ ) {
		if(	((BYTE*)lpv)[j] != 0xCC ) 
			return	FALSE ;
	}
	return	TRUE ;
}

BOOL
CBufferAllocator::RangeCheck(	
						void*	lpv 
						)	{
/*++

Routine Description : 

	Check that a block of memory is actually something that 
	we would allocate.  Unfortunately, this is hard to do 
	with the current CPool interface.

Arguments : 

	lpv - block of memory

Return Value : 

	Always TRUE

--*/
	//
	//	Need to modify CPool so we can examine the address range into which objects fall !
	//	
	return	TRUE ;
}

BOOL
CBufferAllocator::SizeCheck(	
						DWORD	cb 
						)	{
/*++

Routine Description : 
	
	Check that we are trying to allocate a size which is legal 
	for this allocater.

Arguments : 

	cb - the requested size

Return Value : 

	TRUE if legit, FALSE otherwise.

--*/
	return	(cb + sizeof( CPool* )) < rgPoolSizes[2] ;
}
#endif	// DEBUG


BOOL	CBuffer::gTerminate = FALSE ;

BOOL
CBuffer::InitClass()	{
/*++

Routine Description : 

	This class initializes the CBufferClass.

Arguemtns : 

	None.

Return Value : 

	TRUE if successfull.

--*/
	gTerminate = FALSE ;
	if( CBufferAllocator::InitClass() )	{
		CSmallBufferCache::InitClass( &gAllocator ) ;
		CMediumBufferCache::InitClass( &gAllocator ) ;

		gpDefaultSmallCache = XNEW	CSmallBufferCache() ;
		gpDefaultMediumCache = XNEW	CMediumBufferCache() ;
		if( gpDefaultSmallCache == 0 ||
			gpDefaultMediumCache == 0 ) {

			if( gpDefaultMediumCache != 0 ) {
				XDELETE	gpDefaultMediumCache ;
				gpDefaultMediumCache = 0 ;
			}
			if( gpDefaultSmallCache != 0 ) {
				XDELETE	gpDefaultSmallCache ;
				gpDefaultSmallCache = 0 ;
			}
			CBufferAllocator::TermClass() ;
			return	gTerminate ;

		}	else	{
			gTerminate = TRUE ;
		}
	}
	return	gTerminate ;
}

BOOL
CBuffer::TermClass()	{
/*++

Routine Description : 

	Terminate the CBuffer class - release everything ever allocated 
	through this class.

Arguments : 

	None.

Return Value : 
	
	TRUE if successfull.

--*/

	if( gpDefaultMediumCache != 0 ) {
		XDELETE	gpDefaultMediumCache ;
		gpDefaultMediumCache = 0 ;
	}
	if( gpDefaultSmallCache != 0 ) {
		XDELETE	gpDefaultSmallCache ;
		gpDefaultSmallCache = 0 ;
	}

	if( !gTerminate ) {
		return	TRUE ;
	}	else	{
		return	CBufferAllocator::TermClass() ;
	}
}

void*
CBuffer::operator	new(	
					size_t	size,	
					DWORD	cb,	
					DWORD	&cbOut,	
					CSmallBufferCache*	pCache,
					CMediumBufferCache*	pMediumCache
					) {
/*++

Routine Description : 

	Allocate a buffer of a specified size, if possible from a Cache.

Arguments : 

	size - size being requested - this will be the size of CBuffer itself as
		generated by the compiler.  not so usefull as we intend m_rgbBuff to 
		be variable sized.
	cb -	Caller provided size - this indicates how big we want the buffer
		to be and tells us we need to allocate a block big support a 
		m_rgbBuff of that size
	cbOut - Out parameter - get the exact sizeof m_rgbBuff that can be 
		accommodated
	pCache - Cache from which to allocate small buffers
	pMediumCache - Cache from which to allocate medium sized buffers

Return Value : 

	pointer to allocated block (NULL on failure).		

--*/

	//
	//	Validate args - default args for pCache and pMediumCache
	//	should ensure these are never NULL
	//
	_ASSERT( pCache != 0 ) ;
	_ASSERT( pMediumCache != 0 ) ;

	cb += sizeof( CBuffer ) ;
	_ASSERT( size == sizeof( CBuffer ) ) ;

	void*	pv = 0 ;
	
	if( cb <= CBufferAllocator::rgPoolSizes[0] )	{
		pv = pCache->Alloc( cb, cbOut ) ;
	}	else if( cb <= CBufferAllocator::rgPoolSizes[1] ) {
		pv = pMediumCache->Alloc( cb, cbOut ) ;
	}	else	{
		pv = gAllocator.Allocate( cb, cbOut ) ;
	}
		
	if( pv != 0 ) {
		cbOut -= sizeof( CBuffer ) ;
	}
	_ASSERT( cbOut >= (cb - sizeof(CBuffer)) )  ;

	return	pv ;
}

void
CBuffer::operator	delete(	
						void*	pv 
						) {
/*++

Routine Description : 

	Release a block of memory allocated to hold a CBuffer object to 
	some place.

Arguments : 

	pv - block of memory being released.

Return Value : 

	none.

--*/

	CPool** pPool = (CPool**)pv ;

	if( pPool[-1] == &CBufferAllocator::rgPool[0] ) 
		gpDefaultSmallCache->Free( pv ) ;
	else if (pPool[-1] == &CBufferAllocator::rgPool[1] )
		gpDefaultMediumCache->Free( pv ) ;
	else
		gAllocator.Release( pv ) ;
}

void
CBuffer::Destroy(	
			CBuffer*	pbuffer,	
			CSmallBufferCache*	pCache 
			) {
	if( pCache == 0 ) {
		delete	pbuffer ;
	}	else	{
		pCache->Free( (void*)pbuffer ) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\dirnot\src\cretryq.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        cretryq.cxx

   Abstract:
		Implements the generic retry queue

   Author:

           Rohan Phillips    ( Rohanp )    18-JAN-1996

   Project:

          SMTP Server DLL

   Functions Exported:


   Revision History:


--*/

/************************************************************
 *     Include Headers
 ************************************************************/

#include "cretryq.hxx"
//#include "timemath.h"

// Calculate timeout in milliseconds from timeout in seconds.
#define TimeToWait(Timeout)   (((Timeout) == INFINITE) ? INFINITE : \
                                (Timeout) * 1000)

CRetryQ::CRetryQ(void) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::CRetryQ");

	m_hTimeoutEvent = NULL;
	m_hThreadHandle = NULL;
	m_cEntries = 0;
	m_cTimeOut = INFINITE;
	m_fLongSleep = TRUE;
	m_pLastEntry = NULL;

	//init list and crit sect
	InitializeListHead(&m_leQueueHead);
   	InitializeCriticalSection( &m_csQueue);

	TraceFunctLeaveEx((LPARAM)this);
}

CRetryQ::~CRetryQ() {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::~CRetryQ");

	DeleteCriticalSection (&m_csQueue);

	TraceFunctLeaveEx((LPARAM)this);
}

void CRetryQ::InsertIntoQueue(CRetryQueueEntry *pEntry) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::InsertIntoQueue");

    _ASSERT(pEntry != NULL);

	if (pEntry == NULL) {
		TraceFunctLeaveEx((LPARAM)this);
		return;
	}

#if 0
	// BUGBUG
	if(QuerySmtpInstance()->IsShuttingDown())
	{
		delete MailQEntry;
		TraceFunctLeaveEx((LPARAM)this);
		return;
	}
#endif

	LockList();

	// Insert into the list of entrys to retry/NDR.
	InsertTailList(&m_leQueueHead, pEntry->QueryListEntry());

	// wake up the timeout thread if its been sleeping too long
    if (m_fLongSleep) SetEvent(m_hTimeoutEvent);

	m_cEntries++;

	UnLockList();

	TraceFunctLeaveEx((LPARAM)this);
}

void CRetryQ::RemoveFromQueue(CRetryQueueEntry *pEntry) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::RemoveFromQueue");

    _ASSERT(pEntry != NULL);

	if(pEntry == NULL) {
		TraceFunctLeaveEx((LPARAM)this);
		return;
	}

	LockList();

    // Remove from list of connections
    RemoveEntryList(pEntry->QueryListEntry());

    // Decrement count of entries
    m_cEntries--;

	UnLockList();

	TraceFunctLeaveEx((LPARAM)this);
}

void CRetryQ::FlushQueue(void) {
	PLIST_ENTRY pEntry;
	CRetryQueueEntry *pQEntry;

	TraceFunctEnterEx((LPARAM) this, "void CRetryQ::FlushQueue(void)");

    // delete all entries from the list
    while(!IsListEmpty(&m_leQueueHead)) {
		pEntry = RemoveHeadList(&m_leQueueHead);
		pQEntry = CONTAINING_RECORD(pEntry, CRetryQueueEntry, m_le);
		delete pQEntry;
		m_cEntries--;
    }

    TraceFunctLeaveEx((LPARAM) this);
}

void CRetryQ::CleanQueue(void *pvContext) {
	CRetryQueueEntry *pQEntry;

	TraceFunctEnterEx((LPARAM) this, "void CRetryQ::CleanQueue(void *pvContext)");

	LockList();

    PLIST_ENTRY pEntry = m_leQueueHead.Flink;
    while(pEntry != &m_leQueueHead) {
		PLIST_ENTRY pNext = pEntry->Flink;

		pQEntry = CONTAINING_RECORD(pEntry, CRetryQueueEntry, m_le);
		if (pQEntry->MatchesContext(pvContext)) {
			RemoveEntryList(pEntry);
			delete pQEntry;
			m_cEntries--;
		}

		pEntry = pNext;
    }

	UnLockList();

    TraceFunctLeaveEx((LPARAM) this);
}

BOOL CRetryQ::InitializeQueue(DWORD cTimeOut) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::InitializeQueue");

	m_cTimeOut = cTimeOut;
	m_fShutdown = FALSE;

	// create the event the thread waits on
	m_hTimeoutEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (!m_hTimeoutEvent) {
		ErrorTrace((LPARAM) NULL, "CreateEvent failed (err=%d)", GetLastError());
		TraceFunctLeaveEx((LPARAM)this);
		return(FALSE);
	}

  	// create the thread that processes things out of the
  	// the queue
  	DWORD ThreadId;
	m_hThreadHandle = CreateThread(NULL, 0, CRetryQ::RetryQueueThread, 
		this, 0, &ThreadId);
  	if (m_hThreadHandle == NULL) {
		ErrorTrace((LPARAM) NULL, "CreateThread failed (err=%d)", GetLastError());
		CloseHandle(m_hTimeoutEvent);
		m_hTimeoutEvent = NULL;
		TraceFunctLeaveEx((LPARAM)this);
	    return FALSE;  		
  	}
   	
	TraceFunctLeaveEx((LPARAM)this);
   	return(TRUE);
}

BOOL CRetryQ::ShutdownQueue(PFN_SHUTDOWN_FN pfnShutdown) {

	DWORD ec;
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::ShutdownQueue");

	// signal that we are shutting down
	m_fShutdown = TRUE;

	// set the event to shutdown the retry thread
	SetEvent(m_hTimeoutEvent);

	for( int i=1; i<=120; i++)
	{
		// wait to get notice that its shutdown
		ec = WaitForSingleObject(m_hThreadHandle, 1000);
		if( pfnShutdown ) {
			(*pfnShutdown)();
		}

		if( WAIT_OBJECT_0 == ec ) break;
	}
	
	if (ec != WAIT_OBJECT_0) {
		ErrorTrace(0, "retry thread hasn't shutdown yet, waiting some more");
		_ASSERT(FALSE);
		ec = WaitForSingleObject(m_hThreadHandle, INFINITE);
		_ASSERT(ec == WAIT_OBJECT_0);
	}

	// remove all items from the queue
	FlushQueue();

	// close handles
	CloseHandle(m_hTimeoutEvent);
	CloseHandle(m_hThreadHandle);

	TraceFunctLeaveEx((LPARAM) this);

	return TRUE;
}

void CRetryQ::ProcessQueue(void) {
	TraceFunctEnterEx((LPARAM)this, "CRetryQ::ProcessQueue");

	PLIST_ENTRY     pEntry = NULL;
	PLIST_ENTRY     pEntryNext = NULL;
	PLIST_ENTRY     pEntryTail = NULL;
	CRetryQueueEntry *pContext = NULL;
	DWORD			NumProcessed = 0;

	// grab the crit sect
	LockList();

	// setup the pointers
	pEntry = m_leQueueHead.Flink,
	m_pLastEntry = m_leQueueHead.Blink;

    // unlock the list
	UnLockList();

	for(; pEntry != &m_leQueueHead; pEntry = pEntryNext) {
		// save the guy in front, in case this guy gets
		// removed from the queue.
		pEntryNext = pEntry->Flink;
		// get the pointer to the full entry class
		pContext = CONTAINING_RECORD(pEntry, CRetryQueueEntry, m_le);

		// process the entry.  if its successful then remove it from the queue
		if (pContext->ProcessEntry()) {
			RemoveFromQueue(pContext);
			delete pContext;
		}

		// If we have just processed the guy who was in the tail
		// of the initial list (there could be more guys added
		// at this point). We exit out of the loop to prevent
		// infinite looping
		if (pEntry == m_pLastEntry) {
			break;
		}

		// during shutdown we need to bail
		if (m_fShutdown) {
			break;
		}
	}
	
	TraceFunctLeaveEx((LPARAM)this);
}

DWORD WINAPI CRetryQ::RetryQueueThread(void *ThisPtr) {
    DWORD        cTimeout = INFINITE; // In seconds
	CRetryQ      *ThisQ = (CRetryQ *) ThisPtr;

	TraceFunctEnterEx((LPARAM) ThisPtr, "RetryQueueThread(LPDWORD param)");

    for(;;) {
        DWORD dwErr = WaitForSingleObject(ThisQ->GetTimeoutEvent(), 
			TimeToWait(cTimeout));

        switch (dwErr) {
            //  Somebody wants us to wake up and do something
	        case WAIT_OBJECT_0:
				// kill the thread if we're shutting down
				if (ThisQ->m_fShutdown) return 0;

				ThisQ->LockList();
				ThisQ->ClearLongSleep();
				ThisQ->UnLockList();

				cTimeout = ThisQ->GetRetryTimeout();

				DebugTrace((LPARAM) ThisQ,
					"Retry thread setting timeout value to %d", cTimeout);

				continue;

	        //
	        //  When there is work to do, we wakeup every x seconds to look at
	        //  the list.  That's what we need to do now.
	        //
	        case WAIT_TIMEOUT:
				// kill the thread if we're shutting down
				if (ThisQ->m_fShutdown) return 0;

				DebugTrace((LPARAM)ThisQ,
					"Retry thread timed out....scanning retry list");
	
	            // We are at a Timeout Interval. Examine and timeout requests.
	            ThisQ->LockList();  // Prevents adding/removing items
	
	            //
	            //  If the list is empty, then turn off timeout processing
	            //  We actually wait for one complete RetryMinute before
	            //   entering the sleep mode.
	            //
	            if (ThisQ->IsQEmpty()) {
	                // We ought to enter long sleep mode.
					ThisQ->SetLongSleep();
	                ThisQ->UnLockList();
	
	                cTimeout = INFINITE;
					DebugTrace(
						(LPARAM)ThisQ, "Retry thread setting timeout value to INFINITE because list is empty");
	                continue;
	            }

				ThisQ->UnLockList();

				//process each item in the queue
				ThisQ->ProcessQueue();

				continue;

	        //
	        //  Somebody must have closed the event, time to leave
	        //
	        default:
				DebugTrace((LPARAM)ThisQ,"Retry thread hit default case error = %d", GetLastError());
				TraceFunctLeaveEx((LPARAM) ThisQ);
	            return 0;
        } // switch
    } 

	_ASSERT(FALSE);
	TraceFunctLeaveEx((LPARAM) ThisQ);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\dirnot\src\dirnot.cpp ===
#include "dirnot.h"
#include <randfail.h>
#include <dbgtrace.h>
#include <stdio.h>
#include "cretryq.hxx"

CPool*  CDirNotBuffer::g_pDirNotPool = NULL;
CRetryQ *IDirectoryNotification::g_pRetryQ;
PFN_SHUTDOWN_FN IDirectoryNotification::m_pfnShutdown = NULL;

//
// one of these is passed into the retry q for each file that can't be 
// opened
//
class CDirNotRetryEntry : public CRetryQueueEntry {
	public:
		virtual BOOL ProcessEntry(void);
		virtual BOOL MatchesContext(void *pvContext) { return pvContext == m_pDirNot; }
		CDirNotRetryEntry(PVOID pvContext, WCHAR *szPathname, 
			IDirectoryNotification *pDirNot);

	private:
		WCHAR m_szPathname[MAX_PATH + 1];
		IDirectoryNotification *m_pDirNot;
		PVOID m_pvContext;
};

CDirNotRetryEntry::CDirNotRetryEntry(PVOID pvContext,
									 WCHAR *szPathname, 
								     IDirectoryNotification *pDirNot) 
{
	TraceFunctEnter("CDirNotRetryEntry::CDirNotRetryEntry");
	
	_ASSERT(lstrlen(szPathname) <= MAX_PATH);
	lstrcpy(m_szPathname, szPathname);
	_ASSERT(pDirNot != NULL);
	m_pDirNot = pDirNot;
	m_pvContext = pvContext;
	
	TraceFunctLeave();
}

BOOL CDirNotRetryEntry::ProcessEntry(void) {
	TraceFunctEnter("CDirNotRetryEntry::ProcessEntry");

	BOOL f;
	_ASSERT(m_pDirNot != NULL);

	// if the directory notification has been shutdown then we are done
	// here
	if (m_pDirNot->IsShutdown()) {
		TraceFunctLeave();
		return(TRUE);
	}

	f = m_pDirNot->CallCompletionFn(m_pvContext, m_szPathname);
	TraceFunctLeave();
	return f;
}

//
// one of these is stuck onto the retry queue during startup to find 
// files in that pickup 
//
class CDirNotStartupEntry : public CRetryQueueEntry {
	public:
		virtual BOOL ProcessEntry(void);
		virtual BOOL MatchesContext(void *pvContext) { return pvContext == m_pDirNot; }
		CDirNotStartupEntry(IDirectoryNotification *pDirNot);

	private:
		IDirectoryNotification *m_pDirNot;
};

CDirNotStartupEntry::CDirNotStartupEntry(IDirectoryNotification *pDirNot) {
	_ASSERT(pDirNot != NULL);
	m_pDirNot = pDirNot;
}

BOOL CDirNotStartupEntry::ProcessEntry(void) {
	TraceFunctEnter("CDirNotStartupEntry::ProcessEntry");

	_ASSERT(m_pDirNot != NULL);

	// if the directory notification has been shutdown then we are done
	// here
	if (m_pDirNot->IsShutdown()) return TRUE;

	HRESULT hr = m_pDirNot->CallSecondCompletionFn( m_pDirNot );
	if (FAILED(hr)) {
		ErrorTrace(0, "DoFindFile() failed with 0x%x", hr);
	}
	TraceFunctLeave();
	return TRUE;
}

IDirectoryNotification::IDirectoryNotification() {
	m_pAtqContext = NULL;
}

IDirectoryNotification::~IDirectoryNotification() {
	_ASSERT(m_pAtqContext == NULL);
}

HRESULT IDirectoryNotification::GlobalInitialize(DWORD cRetryTimeout, 
												 DWORD cMaxInstances, 
												 DWORD cInstanceSize,
												 PFN_SHUTDOWN_FN pfnShutdown) {
	TraceFunctEnter("IDirectoryNotification::GlobalInitialize");

	// set shutdown fn ptr
	m_pfnShutdown = pfnShutdown;

	// Allocate the cpool object
	CDirNotBuffer::g_pDirNotPool = new CPool( DIRNOT_BUFFER_SIGNATURE );
	if ( NULL == CDirNotBuffer::g_pDirNotPool ) {
	    TraceFunctLeave();
	    return E_OUTOFMEMORY;
	}
	
	// reserve memory for our cpool
	if (!CDirNotBuffer::g_pDirNotPool->ReserveMemory(cMaxInstances, cInstanceSize)) {
		return HRESULT_FROM_WIN32(GetLastError());
	} 

	// create the retry Q
	g_pRetryQ = XNEW CRetryQ;
	if (g_pRetryQ == NULL || !(g_pRetryQ->InitializeQueue(cRetryTimeout))) {
		DWORD ec = GetLastError();
		if (g_pRetryQ != NULL) XDELETE g_pRetryQ;
		ErrorTrace(0, "CRetryQ::InitializeQueue(%lu) failed with %lu", 
			cRetryTimeout, ec);
		CDirNotBuffer::g_pDirNotPool->ReleaseMemory();
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(ec);
	}

	TraceFunctLeave();
	return S_OK;
}

HRESULT IDirectoryNotification::GlobalShutdown(void) {
	TraceFunctEnter("IDirectoryNotification::GlobalShutdown");

	// shutdown the retry Q
	if (!g_pRetryQ->ShutdownQueue( m_pfnShutdown )) {
		ErrorTrace(0, "g_pRetryQ->Shutdown failed with %lu", GetLastError());
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(GetLastError());
	}
	XDELETE g_pRetryQ;
	g_pRetryQ = NULL;

	// release our cpool memory
	if (!CDirNotBuffer::g_pDirNotPool->ReleaseMemory()) {
		return HRESULT_FROM_WIN32(GetLastError());
	} 
	_ASSERT(CDirNotBuffer::g_pDirNotPool->GetAllocCount() == 0);

	if ( CDirNotBuffer::g_pDirNotPool ) delete CDirNotBuffer::g_pDirNotPool;
	CDirNotBuffer::g_pDirNotPool = NULL;

	TraceFunctLeave();
	return S_OK;
}

void IDirectoryNotification::CleanupQueue(void) {
	if (g_pRetryQ) g_pRetryQ->CleanQueue(this);
}

HRESULT IDirectoryNotification::Initialize(WCHAR *pszDirectory, 
										   PVOID pContext,
										   BOOL bWatchSubTree,
										   DWORD dwNotifyFilter,
										   DWORD dwChangeAction,
										   PDIRNOT_COMPLETE_FN pfnComplete,
										   PDIRNOT_SECOND_COMPLETE_FN pfnSecondComplete,
										   BOOL bAppendStartEntry ) 
{
	TraceFunctEnter("IDirectoryNotification::Initialize");
	
	_ASSERT(m_pAtqContext == NULL);

	m_pContext = pContext;
	m_pfnComplete = pfnComplete;
	m_pfnSecondComplete = pfnSecondComplete;
	m_cPathname = lstrlen(pszDirectory);
	m_fShutdown = FALSE;
	m_cPendingIo = 0;
	m_bWatchSubTree = bWatchSubTree;
	m_dwNotifyFilter = dwNotifyFilter;
	m_dwChangeAction = dwChangeAction;

	// get the path to the directory
	if (m_cPathname > MAX_PATH) {
		ErrorTrace(0, "pathname %S is too long", pszDirectory);
		TraceFunctLeave();
		return E_INVALIDARG;
	}
	lstrcpy(m_szPathname, pszDirectory);

	// open the directory
	m_hDir = CreateFile(m_szPathname, FILE_LIST_DIRECTORY, 
						FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
						NULL, OPEN_EXISTING, 
						FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
						NULL);

	if (m_hDir == INVALID_HANDLE_VALUE) {
		ErrorTrace(0, "CreateFile(pszDirectory = %S) failed, ec = %lu", 
			pszDirectory, GetLastError());
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// add the handle to ATQ
	if (!AtqAddAsyncHandle(&m_pAtqContext, NULL, this, 
						   IDirectoryNotification::DirNotCompletion,
						   INFINITE, m_hDir))
	{
		DWORD ec = GetLastError();
		ErrorTrace(0, "AtqAddAsyncHandle failed, ec = %lu", ec);
		CloseHandle(m_hDir);
		m_hDir = INVALID_HANDLE_VALUE;
		m_pAtqContext = NULL;
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(ec);
	}

	// add an entry to the queue to process all of the existing files
	if ( bAppendStartEntry ) {
    	CDirNotStartupEntry *pEntry = XNEW CDirNotStartupEntry(this);
	    if (pEntry == NULL) {
		    ErrorTrace(0, "new pEntry failed", GetLastError());
    		AtqCloseFileHandle(m_pAtqContext);
	    	AtqFreeContext(m_pAtqContext, FALSE);
		    m_pAtqContext = NULL;
    		return E_OUTOFMEMORY;
	    }
    	g_pRetryQ->InsertIntoQueue(pEntry);
    }

	// this is set when its safe to do a shutdown
	m_heNoOutstandingIOs = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_heNoOutstandingIOs == NULL) {
		ErrorTrace(0, "m_heOutstandingIOs = CreateEvent() failed, ec = %lu",
			GetLastError());
		AtqCloseFileHandle(m_pAtqContext);
		AtqFreeContext(m_pAtqContext, FALSE);
		m_pAtqContext = NULL;
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// start the directory notification process
	HRESULT hr = PostDirNotification();
	if (FAILED(hr)) {
		ErrorTrace(0, "PostDirNotification() failed with 0x%08x", hr);
		AtqCloseFileHandle(m_pAtqContext);
		m_hDir = INVALID_HANDLE_VALUE;
		AtqFreeContext(m_pAtqContext, FALSE);
		m_pAtqContext = NULL;
	}

	TraceFunctLeave();
	return hr;
}

HRESULT IDirectoryNotification::Shutdown() {
	TraceFunctEnter("IDirectoryNotification::Shutdown");

	_ASSERT(m_pAtqContext != NULL);
	if (m_pAtqContext == NULL) return E_UNEXPECTED;

	m_fShutdown = TRUE;

	// close the handle to the directory. this will cause all of our 
	// outstanding IOs to complete.  when the last one cleans up it sets
	// the event m_heNoOutstandingIOs
	DebugTrace(0, "closing dirnot handle, all dirnot ATQ requests should complete");
	AtqCloseFileHandle(m_pAtqContext);

	// wait for all of the events to complete.  if they timeout then just
	// keep shutting down
	DWORD dw;
	do {
		dw = WaitForSingleObject(m_heNoOutstandingIOs, 500);
		switch (dw) {
			case WAIT_TIMEOUT:
				// give a stop hint
				if ( m_pfnShutdown ) m_pfnShutdown();
				break;
			case WAIT_OBJECT_0:
				// we're done
				break;
			default:
				// this case shouldn't happen
				ErrorTrace(0, "m_heNoOutstandingIOs was never set... GLE = %lu", GetLastError());
				_ASSERT(FALSE);
		}
	} while (dw == WAIT_TIMEOUT);
	CloseHandle(m_heNoOutstandingIOs);
	m_heNoOutstandingIOs = NULL;

	// this is done here to make sure that we don't finish the shutdown
	// phase while a thread might be in DoFindFile.  Once we've passed
	// through this lock all threads in DoFindFile will be aware of 
	// the m_fShutdown flag and won't make any more posts.
	m_rwShutdown.ExclusiveLock();

	// kill the ATQ context
	AtqFreeContext(m_pAtqContext, FALSE);
	m_pAtqContext = NULL;

	m_rwShutdown.ExclusiveUnlock();

	TraceFunctLeave();
	return S_OK;
}

HRESULT IDirectoryNotification::PostDirNotification() {
	TraceFunctEnter("IDirectoryNotification::PostDirNotification");

	_ASSERT(m_pAtqContext != NULL);
	if (m_pAtqContext == NULL) return E_POINTER;

	// don't pend an IO during shutdown
	if (m_fShutdown) return S_OK;

	CDirNotBuffer *pBuffer = new CDirNotBuffer(this);
	if (pBuffer == NULL) {
		TraceFunctLeave();
		return E_OUTOFMEMORY;
	}

	IncPendingIoCount();

	if (!AtqReadDirChanges(m_pAtqContext, pBuffer->GetData(), 
						   pBuffer->GetMaxDataSize(), m_bWatchSubTree, 
						   m_dwNotifyFilter, 
						   &pBuffer->m_Overlapped.Overlapped))
	{
		DWORD ec = GetLastError();
		ErrorTrace(0, "AtqReadDirChanges failed with %lu", ec);
		delete pBuffer;
		DecPendingIoCount();
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

VOID IDirectoryNotification::DirNotCompletion(PVOID pvContext, 
											  DWORD cWritten,
									 		  DWORD dwCompletionStatus, 
									 		  OVERLAPPED *lpOverlapped)
{
	TraceFunctEnter("IDirectoryNotification::DirNotCompletion");

	_DIRNOT_OVERLAPPED *pDirNotOverlapped = (_DIRNOT_OVERLAPPED *) lpOverlapped;
	CDirNotBuffer *pBuffer = pDirNotOverlapped->pBuffer;
	IDirectoryNotification *pDirNot = pBuffer->GetParent();

	_ASSERT(pDirNot == (IDirectoryNotification *) pvContext);
	_ASSERT(pDirNot->m_pAtqContext != NULL);

 	if (pDirNot->m_fShutdown) {
		// we want to clean up as quickly as possible during shutdown
		DebugTrace(0, "in shutdown mode, not posting a new dirnot");
	} else if (dwCompletionStatus != NO_ERROR) {
		// we received an error
		ErrorTrace(0, "received error %lu", GetLastError());
	} else if (cWritten > 0) {
		// the directory notification contains filename information

		// repost the directory notification
		_VERIFY((pDirNot->PostDirNotification() == S_OK) || pDirNot->m_fShutdown);

		PFILE_NOTIFY_INFORMATION pInfo = 
			(PFILE_NOTIFY_INFORMATION) pBuffer->GetData();
		while (1) {
			DebugTrace(0, "processing notification");

			// we only care about files added to this directory
			if (pInfo->Action == pDirNot->m_dwChangeAction ) {
				WCHAR szFilename[MAX_PATH + 1];

				lstrcpy(szFilename, pDirNot->m_szPathname);
				memcpy(&szFilename[pDirNot->m_cPathname], 
					pInfo->FileName, pInfo->FileNameLength);
				szFilename[pDirNot->m_cPathname+(pInfo->FileNameLength/2)]=0;
				DebugTrace(0, "file name %S was detected", szFilename);

				//
				// call the user's completion function.  if it fails then
				// insert their entry into the retry so that it can be 
				// called later
				//
				if (!pDirNot->CallCompletionFn(pDirNot->m_pContext, 
											   szFilename))
				{											  
					CDirNotRetryEntry *pEntry = 
						 XNEW CDirNotRetryEntry(pDirNot->m_pContext, szFilename,
							                  pDirNot);
					pDirNot->g_pRetryQ->InsertIntoQueue(pEntry);
				}
			}

			if (pInfo->NextEntryOffset == 0) {
				DebugTrace(0, "no more entries in this notification");
				break;
			}

			pInfo = (PFILE_NOTIFY_INFORMATION) 
				((PCHAR) pInfo + pInfo->NextEntryOffset);
		}
	} else {
	    // no bytes were written, search for files using FindFirstFile
		// BUGBUG - handle failure
		_VERIFY(pDirNot->CallSecondCompletionFn( pDirNot ) == S_OK);
		// now post a new dir change event
		// BUGBUG - handle failure
		_VERIFY((pDirNot->PostDirNotification() == S_OK) || pDirNot->m_fShutdown);
	}

	// delete the buffer that was used for this notification
    delete pBuffer;

	// we decrement only after we've incremented in the above if, so that
	// we only get to 0 pending IOs during shutdown.
	pDirNot->DecPendingIoCount();

	TraceFunctLeave();
}

//
// get a listing of files in the directory.  we can enter this state if there
// were so many new files that they couldn't fit into the buffer passed into
// AtqReadDirChanges
// 
HRESULT IDirectoryNotification::DoFindFile( IDirectoryNotification *pDirNot ) {
	WCHAR szFilename[MAX_PATH + 1];
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA find;

	TraceFunctEnter("IDirectoryNotification::DoFindFile");

	_ASSERT( pDirNot );

	pDirNot->m_rwShutdown.ShareLock();

	if (pDirNot->m_fShutdown) {
		pDirNot->m_rwShutdown.ShareUnlock();
		TraceFunctLeave();
		return S_OK;
	}

	_ASSERT(pDirNot->m_pAtqContext != NULL);
	if (pDirNot->m_pAtqContext == NULL) {
		pDirNot->m_rwShutdown.ShareUnlock();
		TraceFunctLeave();
		return E_FAIL;
	}

	_ASSERT(pDirNot->m_hDir != INVALID_HANDLE_VALUE);

	// make up the file spec we want to find
	lstrcpy(szFilename, pDirNot->m_szPathname);
	lstrcat(szFilename, TEXT("*"));

	DebugTrace(0, "FindFirstFile on %S", szFilename);

	hFindFile = FindFirstFile(szFilename, &find);
	if (hFindFile == INVALID_HANDLE_VALUE) {
		DWORD ec = GetLastError();
		ErrorTrace(0, "FindFirstFile failed, ec = %lu", ec);
		pDirNot->m_rwShutdown.ShareUnlock();
		TraceFunctLeave();
		return HRESULT_FROM_WIN32(ec);
	}

	do {
		// ignore subdirectories
		if (!(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
			// get the full name of the file to return it to the completion
			// function
			lstrcpy(szFilename, pDirNot->m_szPathname);
			lstrcat(szFilename, find.cFileName);

			DebugTrace(0, "file name %S was detected", szFilename);
			pDirNot->m_pfnComplete(pDirNot->m_pContext, szFilename);
		}
	} while (!pDirNot->m_fShutdown && FindNextFile(hFindFile, &find)); 

	// close handle
	FindClose(hFindFile);

	pDirNot->m_rwShutdown.ShareUnlock();
	TraceFunctLeave();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\hash\histtest\nntptest.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	"tigtypes.h"
#include	"ihash.h"

int __cdecl
main(	int	argc,	char*	argv[] ) {

	DeleteFile( "D:\\history.hsh" ) ;

	InitializeNNTPHashLibrary() ;

	CHistory::StartExpirationThreads( 10 ) ;

	char	szMessageId[256] ;

	CHistory*	pHistory = CHistory::CreateCHistory() ;

	pHistory->Initialize(	"d:\\history.hsh",
							TRUE, 
							0, 
							120, 
							20
							) ;

	for( int i=0; i < 10000000; i++ )	{

		wsprintf( szMessageId, "<%dfoobar@mydomain>", i ) ;
		FILETIME	ft ;
		GetSystemTimeAsFileTime( &ft ) ;

		pHistory->InsertMapEntry(	szMessageId, 
									&ft ) ;

		printf(" Number of entries is %d\n", pHistory->GetEntryCount() ) ;

		Sleep( 500 ) ;

	}



	CHistory::TermExpirationThreads() ;

	TermNNTPHashLibrary() ;
    return  0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\dirnot\utest\dirwatch.cpp ===
#include "dirnot.h"
#include <stdio.h>
#include <dbgtrace.h>
#include <winerror.h>
#include "stdlib.h"
#include <irtlmisc.h>
#include <xmemwrpr.h>

#define NNTP_ATQ_PARAMETERS \
	"System\\CurrentControlSet\\Services\\InetInfo\\Parameters"

#define MAX_INSTANCES 10

HANDLE g_heStop;
WCHAR g_szStopName[MAX_PATH];
IDirectoryNotification g_dirnot[MAX_INSTANCES];

char g_szPickupDirectory[MAX_PATH];
DWORD g_fAuto = TRUE;
DWORD g_cPreTestFiles = 100;
DWORD g_cFiles = 1000;
DWORD g_cWaitTime = 30;
DWORD g_cRetryTimeout = 5;

HRESULT __stdcall
DoNothing( IDirectoryNotification *pDirNot )
{
    printf( "Got second notify with context pointer 0x%p\n", pDirNot );
    return S_OK;
}

BOOL __stdcall
PrintFileName( PVOID pvContext, LPWSTR wszFileName )
{
    wprintf( L"The file is %s\n", wszFileName );
    return TRUE;
}

BOOL pickupfile(PVOID pContext, WCHAR *pszFilename) {
	HANDLE hFile;

	// try to open the file
	hFile = CreateFile(pszFilename, GENERIC_READ | GENERIC_WRITE, 0, NULL,
		OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		if (GetLastError() == ERROR_FILE_NOT_FOUND) {
			printf("%S: not found\n", pszFilename);
			return TRUE;
		} else {
			printf("%S: in use\n", pszFilename);
			return FALSE;
		}
	}

	printf("%S: opened\n", pszFilename);
	CloseHandle(hFile);
	DeleteFile(pszFilename);
	if (!g_fAuto && lstrcmp(pszFilename, g_szStopName) == 0) SetEvent(g_heStop);
	return TRUE;
}

HRESULT startdirwatch(DWORD dwInstance, char *szPath) {
	WCHAR szDirectory[MAX_PATH];

	if (!MultiByteToWideChar(CP_ACP, 0, szPath, -1, szDirectory,
							 sizeof(szDirectory) / sizeof(WCHAR)))
	{
		printf("MultiByteToWideChar failed, ec = %lu", GetLastError());
		return HRESULT_FROM_WIN32(GetLastError());
	}	

	if (dwInstance == 0 && !g_fAuto) {
		lstrcpy(g_szStopName, szDirectory);
		lstrcat(g_szStopName, TEXT("stop"));
		printf("shutdown by creating the file \"%S\"\n", g_szStopName);
	}

	printf("starting dirwatch instance %i on directory %S\n", dwInstance,
		szDirectory);
	return g_dirnot[dwInstance].Initialize( szDirectory,
	                                        NULL,
	                                        TRUE,
	                                        FILE_NOTIFY_CHANGE_SECURITY,
	                                        FILE_ACTION_MODIFIED,
	                                        PrintFileName,
	                                        DoNothing);
}

HRESULT stopdirwatch(DWORD dwInstance) {
	printf("stopping dirwatch instance %i\n", dwInstance);
	return g_dirnot[dwInstance].Shutdown();
}

#define INI_PICKUPDIR "PickupDirectory"
#define INI_AUTOTEST "AutoTest"
#define INI_PRETESTFILES "PreTestFilesToCreate"
#define INI_FILESTOCREATE "FilesToCreate"
#define INI_WAITTIME "TimeToWait"
#define INI_RETRYTIMEOUT "RetryTimeout"

char g_szDefaultSectionName[] = "dirwatch";
char *g_szSectionName;

int GetINIDWord(char *szINIFile, char *szKey, DWORD dwDefault) {
	char szBuf[MAX_PATH];

	GetPrivateProfileStringA(g_szSectionName,
							szKey,
							"default",
							szBuf,
							MAX_PATH,
							szINIFile);

	if (strcmp(szBuf, "default") == 0) {
		return dwDefault;
	} else {
		return atoi(szBuf);
	}
}

void ReadINIFile(char *pszINIFile) {
	g_fAuto = GetINIDWord(pszINIFile, INI_AUTOTEST, g_fAuto);
	g_cPreTestFiles = GetINIDWord(pszINIFile, INI_PRETESTFILES, g_cPreTestFiles);
	g_cFiles = GetINIDWord(pszINIFile, INI_FILESTOCREATE, g_cFiles);
	g_cWaitTime = GetINIDWord(pszINIFile, INI_WAITTIME, g_cWaitTime);
	g_cRetryTimeout = GetINIDWord(pszINIFile, INI_RETRYTIMEOUT, g_cRetryTimeout);

	GetPrivateProfileStringA(g_szSectionName,
							INI_PICKUPDIR,
							"",
							g_szPickupDirectory,
							MAX_PATH,
							pszINIFile);

}

void CreateFiles(char *pszDirectory, char *pszBase, DWORD cFiles) {
	DWORD i;

	for (i = 0; i < cFiles; i++) {
		HANDLE hFile;
		char pszFilename[MAX_PATH];

		sprintf(pszFilename, "%s%s%i", pszDirectory, pszBase, i);

		hFile = CreateFileA(pszFilename,
						    GENERIC_READ | GENERIC_WRITE,
						    FILE_SHARE_READ | FILE_SHARE_WRITE,
						    NULL,
						    CREATE_ALWAYS,
						    FILE_ATTRIBUTE_NORMAL,
						    NULL);
		if (hFile != INVALID_HANDLE_VALUE) {
			CloseHandle(hFile);
		}
	}
}

DWORD NumberOfFiles(char *pszDirectory, char *pszBase) {
	HANDLE hFileEnum;
	char szFilename[MAX_PATH];
	WIN32_FIND_DATAA finddata;
	DWORD cFiles = 0;

	sprintf(szFilename, "%s%s", pszDirectory, pszBase);

	hFileEnum = FindFirstFileA(szFilename, &finddata);
	if (hFileEnum != INVALID_HANDLE_VALUE) {
		do {
			printf("%s%s wasn't picked up\n", pszDirectory, finddata.cFileName);
			cFiles++;
		} while (FindNextFileA(hFileEnum, &finddata));
		FindClose(hFileEnum);
	}

	return cFiles;
}

int __cdecl main(int argc, char **argv) {
	HRESULT hr;
	DWORD i;
	
    _VERIFY( ExchMHeapCreate( NUM_EXCHMEM_HEAPS, 0, 100 * 1024, 0 ) );

	if (argc == 2 || argc == 3) {
		if (strcmp(argv[1], "/help") == 0) {
			printf("usage: dirwatch [<INI file>] [<INI section>]\n");
			printf("  Fields read from INI File: (section = [dirwatch])\n");
			printf("    PickupDirectory (default = %s)\n", g_szPickupDirectory);
			printf("      directory name should be of the form x:\\dirname\\\n");
			printf("    RetryTimeout (default = %i)\n", g_cRetryTimeout);
			printf("      retry time for directory notification queue\n");
			printf("    AutoTest (default = %i)\n", g_fAuto);
			printf("    --- the following fields are used in auto mode ---\n");
			printf("    PreTestFilesToCreate (default = %i)\n", g_cPreTestFiles);
			printf("      these files are created before starting pickup\n");
			printf("    FilesToCreate (default = %i)\n", g_cFiles);
			printf("      these files are created after starting pickup\n");
			printf("    TimeToWait (default = %i)\n", g_cWaitTime);
			printf("      this is the amount of time to wait for the files to be picked up\n");
			return 1;
		} else {
			if (argc == 3) g_szSectionName = argv[2];
			ReadINIFile(argv[1]);
		}
	}

	if (*g_szPickupDirectory == 0) {
		GetTempPathA(MAX_PATH, g_szPickupDirectory);
		lstrcatA(g_szPickupDirectory, "dirwatch\\");
	}
	CreateDirectoryA(g_szPickupDirectory, NULL);

	printf("parameters:\n");
	printf("PickupDirectory = %s\n", g_szPickupDirectory);
	printf("RetryTimeout = %i\n", g_cRetryTimeout);
	printf("AutoTest = %i\n", g_fAuto);
	printf("PreTestFilesToCreate = %i\n", g_cPreTestFiles);
	printf("FilesToCreate = %i\n", g_cFiles);
	printf("TimeToWait = %i\n\n", g_cWaitTime);

	InitAsyncTrace();
    InitializeIISRTL();
	AtqInitialize(NULL);
	hr = IDirectoryNotification::GlobalInitialize(g_cRetryTimeout, MAX_INSTANCES * 2, 1024, NULL);
	if (FAILED(hr)) {
		printf("IDirectoryNotification::GlobalInitialize returned hr = %08x\n", hr);
        _VERIFY( ExchMHeapDestroy() );
		return 0;
	}

	if (g_fAuto) {
		CreateFiles(g_szPickupDirectory, "pre-", g_cPreTestFiles);
	} else {
		g_heStop = CreateEvent(NULL, FALSE, FALSE, NULL);
	}

	hr = startdirwatch(0, g_szPickupDirectory);
	if (FAILED(hr)) {
		printf("startdirwatch failed with hr = 0x%x\n", hr);
	}

	if (g_fAuto) {
		CreateFiles(g_szPickupDirectory, "pickup-", g_cFiles);
		Sleep(g_cWaitTime * 1000);
	} else {
		WaitForSingleObject(g_heStop, INFINITE);
	}

	stopdirwatch(0);
	if (FAILED(hr)) {
		printf("stopdirwatch failed with hr = 0x%x\n", hr);
	}

	hr = IDirectoryNotification::GlobalShutdown();
	if (FAILED(hr)) {
		printf("IDirectoryNotification::GlobalShutdown returned hr = %08x\n", hr);
	}

	TermAsyncTrace();


    _VERIFY( ExchMHeapDestroy() );
	if (g_fAuto) {
		return NumberOfFiles(g_szPickupDirectory, "p*");
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\hash\cachetst\cachetst.cpp ===
#include	<windows.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<dbgtrace.h>
#include	"tigtypes.h"
#include	"ihash.h"


struct	Tables	{

	CMsgArtMap*	pArticle ;
	CXoverMap*	pXover ;
	CHistory*	pHistory ;

} ;
	



DWORD	WINAPI
HashCreateThread(	LPVOID	lpv ) {

	Tables*	pt = (Tables*)lpv ;


	CMsgArtMap*	pArticle = pt->pArticle ;
	CXoverMap*	pXover = pt->pXover ;
	CHistory*	pHistory = pt->pHistory ;

	char	szBuff[256] ;

	GROUP_ENTRY	rgGroups[40] ;

	for(	GROUPID	groupid=1; groupid< 20; groupid++ ) {
		for(	ARTICLEID	articleid = 1; articleid<10000; articleid ++ ) {

			DWORD	cb = wsprintf( szBuff, "<art=%dgrp=%d@mydomain.com>", 100*articleid, 100*groupid ) ;
			DWORD	dw ;
			for( DWORD	xPosts = 0; xPosts<10; xPosts ++ ) {

				rgGroups[xPosts].GroupId = groupid + 20 + xPosts ;
				rgGroups[xPosts].ArticleId = articleid ;

			}

			BOOL	fSuccess = pArticle->InsertMapEntry(	szBuff ) ;

			_ASSERT( fSuccess ) ;

			FILETIME	filetime ;
			GetSystemTimeAsFileTime( &filetime ) ;
			
			fSuccess = pXover->CreatePrimaryNovEntry(
									groupid, 
									articleid, 
									0, 
									200,
									&filetime, 
									szBuff, 
									cb, 
									10, 
									rgGroups
									) ;

			dw = GetLastError() ;

			_ASSERT(fSuccess) ;

			for( xPosts = 0; xPosts<10; xPosts ++ ) {
				
				fSuccess = pXover->CreateXPostNovEntry(
									rgGroups[xPosts].GroupId,
									rgGroups[xPosts].ArticleId, 
									0,
									200, 
									&filetime, 
									groupid, 
									articleid
									) ;

				dw = GetLastError() ;

				_ASSERT(fSuccess) ;
			}

			fSuccess = pArticle->SetArticleNumber(
										szBuff, 
										0,
										100, 
										groupid,
										articleid ) ;

			dw = GetLastError() ;

			_ASSERT( fSuccess ) ;

		}
	}
	return	0 ;
}


DWORD	WINAPI
SearchThread(	LPVOID	lpv ) {

	Tables*	pt = (Tables*)lpv ;


	CMsgArtMap*	pArticle = pt->pArticle ;
	CXoverMap*	pXover = pt->pXover ;
	CHistory*	pHistory = pt->pHistory ;


	GROUP_ENTRY	grpEntry[50] ;
	char	szBuff[512] ;
	DWORD	Retries = 0 ;
	
	for( GROUPID	groupid=30; groupid>10; groupid-- ) {


		for( ARTICLEID	articleid=1; articleid<10000; articleid ++ ) {
	
			Retries = 0 ;		
Retry:

			DWORD	Size=sizeof(grpEntry) ;
			DWORD	Number = 0 ;
			BOOL	fSuccess = pXover->GetArticleXPosts(
											groupid, 
											articleid, 
											FALSE, 
											&grpEntry[0], 
											Size, 
											Number 
											) ;

			DWORD	dw = GetLastError() ; 

			if( !fSuccess )	{
				if( Retries < 5 && dw == ERROR_FILE_NOT_FOUND ) {
					Retries ++ ;
					Sleep( 500 ) ;
					goto	Retry ;
				}	else	{
					_ASSERT(1==0) ;
				}
			}

			BOOL	fPrimary ;
			WORD	HeaderLength ;
			WORD	HeaderOffset ;
			FILETIME	filetime ;
			DWORD cStoreIds = 0;

			DWORD	DataLen = sizeof( szBuff ) ;

			fSuccess = pXover->ExtractNovEntryInfo(
											groupid, 
											articleid,
											fPrimary, 
											HeaderLength,
											HeaderOffset,
											&filetime,
											DataLen,
											szBuff,
											cStoreIds,
											NULL,
											NULL
											) ;

			dw = GetLastError() ;

			_ASSERT( fSuccess ) ;
			_ASSERT( !fPrimary || groupid < 20 ) ;
			_ASSERT( HeaderLength == 0 ) ;
			_ASSERT( HeaderOffset == 200 ) ;

			szBuff[DataLen] = '\0' ;

			fSuccess = pArticle->SearchMapEntry( szBuff ) ;

			dw = GetLastError() ;

			_ASSERT( fSuccess ) ;

			GROUPID	groupidTemp ;
			ARTICLEID	articleidTemp ;
			CStoreId storeid;

			if( pArticle->GetEntryArticleId(	szBuff, 
									HeaderOffset, 
									HeaderLength, 
									articleidTemp,
									groupidTemp,
									storeid) ) {

				if( groupid < 20 ) {
					_ASSERT( groupid == groupidTemp || groupidTemp == INVALID_GROUPID ) ;
					_ASSERT( articleidTemp == articleid || articleidTemp == INVALID_ARTICLEID ) ;
				}
				
				if( groupidTemp != INVALID_GROUPID ) {				

					GetSystemTimeAsFileTime( &filetime ) ;

					fSuccess = pHistory->InsertMapEntry( szBuff, &filetime ) ;

					_ASSERT( fSuccess ) ;

					fSuccess = pArticle->DeleteMapEntry( szBuff ) ;

					_ASSERT( fSuccess ) ;
				}

			}

		}
											
	}

	return	0 ;

}		

char	*ArticleFiles[] = {
	"d:\\arttest1.hsh", 
	"d:\\arttest2.hsh", 
	"d:\\arttest3.hsh"
} ;

char	*HistoryFiles[] = {
	"d:\\histtst1.hsh", 
	"d:\\histtst2.hsh", 
	"d:\\histtst3.hsh"
} ;

char	*XoverFiles[]	=	{
	"d:\\xovtst1.hsh",
	"d:\\xovtst2.hsh",	
	"d:\\xovtst3.hsh"
} ;


int __cdecl
main( int argc, char*	argv[] ) {


	BOOL	fSuccess = InitializeNNTPHashLibrary() ;
	
	_ASSERT( fSuccess ) ;

	HANDLE	rgh[20] ;

	Tables	table[3] ;

	for( int i=0; i<3; i++ ) {

		table[i].pArticle = CMsgArtMap::CreateMsgArtMap() ;
		table[i].pHistory = CHistory::CreateCHistory() ;
		table[i].pXover = CXoverMap::CreateXoverMap() ;

	}

	int	j = 0 ;

	for( i=0; i<1; i++ ) {

		DeleteFile( ArticleFiles[i] ) ;

		fSuccess = table[i].pArticle->Initialize(	ArticleFiles[i] ) ;

		_ASSERT( fSuccess ) ;

		DeleteFile( HistoryFiles[i] ) ;

		fSuccess = table[i].pHistory->Initialize(	HistoryFiles[i], TRUE, 0, 300 ) ;

		_ASSERT( fSuccess ) ;

		DeleteFile( XoverFiles[i] ) ;

		fSuccess = table[i].pXover->Initialize(		XoverFiles[i]	) ;

		_ASSERT( fSuccess ) ;

		DWORD	dwJunk = 0 ;
		rgh[j++] = CreateThread(	0, 0, HashCreateThread, &table[i], 0, &dwJunk ) ;

		rgh[j++] = CreateThread(	0, 0, SearchThread, &table[i], 0, &dwJunk ) ;

	}

	WaitForMultipleObjects( j, rgh, TRUE, INFINITE ) ;


	fSuccess = TermNNTPHashLibrary() ;

	_ASSERT( fSuccess ) ;

	return	0 ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\nntp\server\hash\src\nntphash.cpp ===
/*++

  NNTPHASH.CPP

  This file implements the classes defined in nntphash.h


--*/

#include	<windows.h>
#include	<dbgtrace.h>
#include    <wtypes.h>
#include    <xmemwrpr.h>
#include	"hashmap.h"
#include	"nntpdrv.h"
#include	"nntphash.h"


CCACHEPTR	g_pSharedCache ;

CStoreId CMsgArtMap::g_storeidDefault;
CStoreId CXoverMap::g_storeidDefault;


BOOL
InitializeNNTPHashLibrary(DWORD dwCacheSize )	{

	g_pSharedCache = new	CPageCache() ;	
	if( g_pSharedCache == 0 ) {
		return	FALSE ;
	}
	
    DWORD cPageEntry = 0 ;
    if( dwCacheSize ) {
        //
        //  Given the cache size, calculate the number of pages
        //
	    DWORD	block = dwCacheSize / 4096 ;

	    //
	    //	Now we want that to be divisible evenly by 32
	    //
	    cPageEntry = block & (~(32-1)) ;
    }

	if( !g_pSharedCache->Initialize(cPageEntry) ) {
		g_pSharedCache = 0 ;
		return	FALSE ;
	}

	if( !CHistoryImp::Init() ) {
		g_pSharedCache = 0 ;
		return	FALSE ;
	}
	return	TRUE ;
}

BOOL
TermNNTPHashLibrary()	{

	g_pSharedCache = 0 ;

	return	CHistoryImp::Term() ;

}


HASH_VALUE
INNHash(    LPBYTE  Key,
            DWORD   Length ) {

    return  CHashMap::CRCHash(  Key, Length ) ;

}

DWORD
GetArticleEntrySize( DWORD MsgIdLen )
{
	int cStoreId = 256;		// should have this be an argument, but its only
							// used by rebuild for now - BUGBUG

	return ((FIELD_OFFSET(ART_MAP_ENTRY, rgbStoreId) + 256 + MsgIdLen + 3) & ~3);
}

DWORD GetXoverEntrySize( DWORD VarLen )
{
	return ((sizeof(XOVER_MAP_ENTRY) -1 + (VarLen) + 3) & ~3);
}


CArticleData::CArticleData(WORD	HeaderOffset, WORD HeaderLength,
						   GROUPID PrimaryGroup, ARTICLEID ArticleNo,
						   CStoreId &storeid)	
{
	ZeroMemory( &m_articleData, sizeof( m_articleData ) ) ;
	m_articleData.HeaderOffset = HeaderOffset ;
	m_articleData.HeaderLength =  HeaderLength ;
	m_articleData.PrimaryGroupId = PrimaryGroup ;
	m_articleData.ArticleId = ArticleNo ;
	memcpy(m_articleData.rgbStoreId, storeid.pbStoreId, storeid.cLen);
	m_articleData.cStoreId = storeid.cLen;
}

//
//	Save the key into the hash table
//
LPBYTE CArticleData::Serialize(LPBYTE pbPtr) const {
	BYTE Flags;
	Flags = ARTFLAG_FLAGS_EXIST;

	DWORD cEntrySize = FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen);
	if (m_articleData.cStoreId > 0) Flags |= ARTFLAG_STOREID;

	memcpy(pbPtr, &m_articleData, cEntrySize);
	*pbPtr = Flags;

	WORD cbMsgLen = *((WORD *) (pbPtr + FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen)));
	DWORD cStoreIdSize = 0;
	if (m_articleData.cStoreId > 0) {
		DWORD iStoreIdOffset = FIELD_OFFSET(ART_MAP_ENTRY, MsgId) + cbMsgLen;
		cStoreIdSize = sizeof(m_articleData.cStoreId) + m_articleData.cStoreId;

		memcpy(pbPtr + iStoreIdOffset, &(m_articleData.cStoreId), cStoreIdSize);
	}

	return pbPtr + cEntrySize + sizeof(m_articleData.MsgIdLen) + cbMsgLen + cStoreIdSize;
}

//
//	Restore the key from the hash table
//
LPBYTE CArticleData::Restore(LPBYTE pbPtr, DWORD& cbOut) {
	// set these to their defaults since they may not be read
	m_articleData.Flags = 0;
	m_articleData.cStoreId = 0;

	// read the flags byte
	m_articleData.Flags = *pbPtr;

	// compute
	DWORD iEntryOffset = sizeof(m_articleData.Flags);
	DWORD cEntrySize = FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen);

	// see if there is a flags byte.
	if (!(m_articleData.Flags & ARTFLAG_FLAGS_EXIST)) {
		return RestoreMCIS( pbPtr, cbOut );
	}

	// copy the header length and offset fields
	memcpy(((BYTE *) (&m_articleData)) + 1, pbPtr + iEntryOffset, cEntrySize);

	// there is a store id for us to read
	DWORD cStoreIdData = 0;
	if (m_articleData.Flags & ARTFLAG_STOREID) {
		WORD cbMsgLen = *((WORD *) (pbPtr + FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen)));
		DWORD iStoreIdOffset = FIELD_OFFSET(ART_MAP_ENTRY, MsgId) + cbMsgLen;
		m_articleData.cStoreId = pbPtr[iStoreIdOffset];
		memcpy(&(m_articleData.rgbStoreId), pbPtr + iStoreIdOffset + 1, m_articleData.cStoreId);
		cStoreIdData = 1 + m_articleData.cStoreId;
	} else {
		m_articleData.cStoreId = 0;
	}

	return pbPtr + iEntryOffset + cEntrySize + cStoreIdData +
			sizeof(m_articleData.MsgIdLen) + m_articleData.MsgIdLen;
}

//
// Restore the key from an MCIS entry
//
LPBYTE CArticleData::RestoreMCIS(LPBYTE pbPtr, DWORD& cbOut ) {

    _ASSERT( pbPtr );
    PMCIS_ART_MAP_ENTRY pMap = PMCIS_ART_MAP_ENTRY( pbPtr );
    DWORD iEntryOffset = 0;
	DWORD cEntrySize = FIELD_OFFSET(ART_MAP_ENTRY, MsgIdLen) - sizeof(m_articleData.Flags);

    //
    // MCIS entries don't have flags
    //

    m_articleData.Flags = 0;

    //
    // MCIS entries don't have store id's
    //

    m_articleData.cStoreId = 0;

    //
    // Copy other members
    //

    m_articleData.HeaderOffset = pMap->HeaderOffset;
    m_articleData.HeaderLength = pMap->HeaderLength;
    m_articleData.PrimaryGroupId = pMap->PrimaryGroupId;
    m_articleData.ArticleId = pMap->ArticleId;
    m_articleData.MsgIdLen = pMap->MsgIdLen;

    return pbPtr + iEntryOffset + cEntrySize + sizeof( m_articleData.MsgIdLen )
                + m_articleData.MsgIdLen;
}

//
//	Return the size of the key
//
DWORD CArticleData::Size() const {
	return sizeof(m_articleData)
		   - sizeof(m_articleData.MsgId) 		// in the key
		   - sizeof(m_articleData.rgbStoreId)	// real size added below
		   + m_articleData.cStoreId;
}

//
//	Verify that the message-id looks legitimate !
//
BOOL CArticleData::Verify(LPBYTE pbContainer, LPBYTE pbPtr, DWORD cb) const {
	return	TRUE;
}

template< class	Key, class OldKey >
DWORD
CMessageIDKey<Key, OldKey>::Hash()	const	{
/*++

Routine Description :

	This function computes the hash value of a Message ID key

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT( m_cbMessageID != 0 ) ;

	return	CHashMap::CRCHash( (const BYTE *)m_lpbMessageID, m_cbMessageID ) ;
}

template< class	Key, class OldKey >
BOOL
CMessageIDKey<Key, OldKey>::CompareKeys(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function compares a key stored within ourselves to
	one that has been serialized into the hash table !

Arguments :

	Pointer to the start of the block of serialized data

Return Value :

	TRUE if the keys match !

--*/


	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT( m_cbMessageID != 0 ) ;
	_ASSERT( pbPtr != 0 ) ;

	Key*	pKey    = (Key*)pbPtr ;
	OldKey* pOldKey = NULL;
	DWORD   dwKeyLen    = 0;
	PVOID   pvKeyPos    = NULL;

	//
	// If we don't match the version, then we'll be degraded to
	// using older version
	//

	if ( !pKey->VersionMatch() ) {
	    pOldKey = (OldKey*)pbPtr;
	    pvKeyPos = pOldKey->KeyPosition();
	    dwKeyLen = pOldKey->KeyLength();
	} else {
	    pvKeyPos = pKey->KeyPosition();
	    dwKeyLen = pKey->KeyLength();
	}

	if( dwKeyLen == m_cbMessageID ) {

		return	memcmp( pvKeyPos, m_lpbMessageID, m_cbMessageID ) == 0 ;

	}
	return	FALSE ;
}

template< class	Key, class OldKey >
LPBYTE
CMessageIDKey<Key, OldKey >::EntryData(	LPBYTE	pbPtr,
							DWORD&	cbKeyOut )	const	{
/*++

Routine Description :

	This function returns a pointer to where the data is
	serialized.  We always return the pointer we were passed
	as we have funky serialization semantics that places
	the key not before the data but somewhere in the middle
	or end.

Arguments :

	pbPtr - Start of serialized hash entyr
	cbKeyOut - returns the size of the key

Return Value :

	Pointer to where the data resides - same as pbPtr

--*/


	_ASSERT( pbPtr != 0 ) ;
	
	Key*	pKey = (Key*)pbPtr ;
	cbKeyOut = pKey->KeyLength() ;

	return	pbPtr ;
}

template< class	Key, class OldKey >
LPBYTE
CMessageIDKey<Key, OldKey>::Serialize(	LPBYTE	pbPtr )	const	{
/*++

Routine Description :

	This function saves a key into the hash table.
	We use functions off of the template type 'Key' to
	determine where we should stick the message id

Arguments :

	pbPtr - Start od where we should serialize to

Return Value :

	same as pbPtr

--*/

	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT(	m_cbMessageID != 0 ) ;
	_ASSERT( pbPtr != 0 ) ;

    //
    // We should always save as new version, so never
    // use the OldKey here
    //
    
	Key*	pKey = (Key*)pbPtr ;

	pKey->KeyLength() = m_cbMessageID ;

	CopyMemory( pKey->KeyPosition(),
				m_lpbMessageID,
				m_cbMessageID ) ;
	return	pbPtr ;
}	

template< class	Key, class OldKey >
LPBYTE
CMessageIDKey<Key, OldKey>::Restore(	LPBYTE	pbPtr, DWORD	&cbOut )		{
/*++

Routine Description :

	This function is called to recover a key from where
	it was Serialize()'d .

Arguments :

	pbPtr - Start of the block of serialized data

Return Value :

	pbPtr if successfull, NULL otherwise

--*/

	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT( m_cbMessageID != 0 ) ;

	Key*	pKey    = (Key*)pbPtr ;
	OldKey* pOldKey = NULL;
	WORD    wKeyLen    = 0;
	PVOID   pvKeyPos    = NULL;

	//
	// If the version mismatches, I should use the OldKey
	//

	if ( !pKey->VersionMatch() ) {
        pOldKey = (OldKey*)pbPtr;
        wKeyLen = pOldKey->KeyLength();
        pvKeyPos = pOldKey->KeyPosition();
    } else {
        wKeyLen = pKey->KeyLength();
        pvKeyPos = pKey->KeyPosition();
    }

	if( wKeyLen <= m_cbMessageID ) {
		CopyMemory( m_lpbMessageID, pvKeyPos, wKeyLen ) ;
		m_cbMessageID = wKeyLen ;
		return	pbPtr ;
	}
	return	0 ;
}

template< class	Key, class OldKey >
DWORD
CMessageIDKey<Key, OldKey>::Size()	const	{
/*++

Routine Description :

	This function retruns the size of the key - which is just
	the number of bytes makeing up the message id.
	The bytes use to hold the serialized length are accounted
	for by the

Arguments :

	None

Return Value :

	32 bit hash value

--*/

	_ASSERT( m_lpbMessageID != 0 ) ;
	_ASSERT( m_cbMessageID != 0 ) ;

	return	m_cbMessageID ;
}

template< class	Key, class OldKey >
BOOL
CMessageIDKey< Key, OldKey >::Verify(	BYTE*	pbContainer, BYTE*	pbData, DWORD	cb )	const	{

	return	TRUE ;

}



typedef	CMessageIDKey< ART_MAP_ENTRY, MCIS_ART_MAP_ENTRY >	ARTICLE_KEY ;
typedef	CMessageIDKey< HISTORY_MAP_ENTRY, HISTORY_MAP_ENTRY >	HISTORY_KEY ;


CMsgArtMap*
CMsgArtMap::CreateMsgArtMap(StoreType st)	{
/*++

Routine Description :

	This function returns a pointer to an object which implements the
	CMsgArtMap interface.

Arguments :

	None

Return Value :

	If successfull a pointer to an object, otherwise NULL.

--*/

	return	new	CMsgArtMapImp() ;
}

CHistory*
CHistory::CreateCHistory(StoreType st)	{
/*++

Routine Description :

	This function returns a pointer to an object which implements the
	CHistory interface.

Arguments :

	None

Return Value :

	If successfull a pointer to an object, otherwise NULL.

--*/


	return	new	CHistoryImp() ;
}

CMsgArtMap::~CMsgArtMap() {
}


CMsgArtMapImp::CMsgArtMapImp()	{
/*++

Routine Description :

	This function constructs an implementation of the CMsgArtMap
	interface - not much for us to do most work happens in base classes.

Arguments :

	None

Return Value :

	None.

--*/
}

CMsgArtMapImp::~CMsgArtMapImp() {
/*++

Routine Description :

	Destroy ourselves - all work done in base classes !

Arguments :

	None

Return Value :

	None

--*/
}


BOOL
CMsgArtMapImp::DeleteMapEntry(	
		LPCSTR	MessageID
		)	{
/*++

Routine Description :

	Remove a Message ID from the hash table !

Arguments :

	MessageID - pointer to the message id to delete

Return Value :

	TRUE if successfully removed !

--*/

	ARTICLE_KEY	key( const_cast<LPSTR>(MessageID), (WORD)lstrlen( MessageID ) ) ;

	return	CHashMap::DeleteMapEntry(	&key ) ;
}

BOOL
CMsgArtMapImp::GetEntryArticleId(
		LPCSTR	MessageID,
		WORD&	HeaderOffset,
		WORD&	HeaderLength,
		ARTICLEID&	ArticleId,
		GROUPID&	GroupId,
		CStoreId	&storeid
		)	{
/*++

Routine Description :

	Get all the information we hold regarding a particular
	Message-ID

Arguments :

	MessageID - message ID to insert
	HeaderOffset - return val gets the offset to the start of
		the Header portion of the article within the file
	HeaderLength - Length of the RFC 822 article header
	ArticleId - the Article Id
	GroupId - the Group Id of the primary article

Return Value :

	TRUE if successfull

--*/

	ARTICLE_KEY	key( (LPSTR)MessageID, (WORD)lstrlen( MessageID ) ) ;

	CArticleData	data ;

	if( LookupMapEntry(	&key,
						&data ) )	{

		HeaderOffset = data.m_articleData.HeaderOffset ;
		HeaderLength = data.m_articleData.HeaderLength ;
		ArticleId = data.m_articleData.ArticleId ;
		GroupId = data.m_articleData.PrimaryGroupId ;
		storeid.cLen = data.m_articleData.cStoreId;
		_ASSERT(storeid.pbStoreId != NULL);
		memcpy(storeid.pbStoreId, data.m_articleData.rgbStoreId, storeid.cLen);
		return	TRUE ;
	}
	return	FALSE ;
}

BOOL
CMsgArtMapImp::Initialize(			
		LPSTR	lpstrArticleFile,
		HASH_FAILURE_PFN	pfn,
		BOOL	fNoBuffering
		)	{
/*++

Routine Description :

	This function initializes the hash table

Arguments :

	lpstrArticleFile - the file in which the hash table is located
	cNumPageEntry - number of PageEntry objects we should use
	pfn - function call back for when things go south

Return Value :

	TRUE if successfull

--*/

	return	CHashMap::Initialize(	lpstrArticleFile,
                                    ART_HEAD_SIGNATURE,
                                    0,
									1,
									g_pSharedCache,
									HASH_VFLAG_PAGE_BASIC_CHECKS,
									pfn,
									0,
									fNoBuffering
									) ;
}

BOOL
CMsgArtMapImp::InsertMapEntry(
		LPCSTR		MessageID,
		WORD		HeaderOffset,
		WORD		HeaderLength,
		GROUPID		PrimaryGroup,
		ARTICLEID	ArticleId,
		CStoreId	&storeid
		)	{
/*++

Routine Description :

	Insert a Message ID and all its associated data

Arguments :

	MessageID - the message id to insert into the table
	HeaderOffset - Offset to the RFC 822 header within its file
	HeaderLength - Length of RFC 822 header
	PrimaryGroup - The id of the group where the article will reside
	ArticleId - the id wihtin the primary group

Return Value :

	TRUE if successfull

--*/

	ARTICLE_KEY	key(	(LPSTR)MessageID, (WORD)lstrlen( MessageID ) ) ;
	CArticleData	data(	HeaderOffset,
							HeaderLength,
							PrimaryGroup,
							ArticleId ,
							storeid
							) ;

	return	CHashMap::InsertMapEntry(
							&key,
							&data,
							TRUE    // Only mark page dirty, don't flush to disk to save WriteFile
							) ;
}

BOOL
CMsgArtMapImp::SetArticleNumber(
		LPCSTR		MessageID,
		WORD		HeaderOffset,
		WORD		HeaderLength,
		GROUPID		PrimaryGroup,
		ARTICLEID	ArticleId,
		CStoreId	&storeid
		)	{
/*++

Routine Description :

	Modify the data associated with a Message ID

Arguments :

	MessageID - the message id to insert into the table
	HeaderOffset - Offset to the RFC 822 header within its file
	HeaderLength - Length of RFC 822 header
	PrimaryGroup - The id of the group where the article will reside
	ArticleId - the id wihtin the primary group

Return Value :

	TRUE if successfull

--*/
	ARTICLE_KEY	key(	(LPSTR)MessageID, (WORD)lstrlen( MessageID ) ) ;
	CArticleData	data(	HeaderOffset,
							HeaderLength,
							PrimaryGroup,
							ArticleId ,
							storeid
							) ;

	return	CHashMap::InsertOrUpdateMapEntry(
							&key,
							&data,
							TRUE
							) ;
}

BOOL
CMsgArtMapImp::SearchMapEntry(
		LPCSTR	MessageID
		)	{
/*++

Routine Description :

	Determine if the MessageID exists in the table

Arguments :

	MessageID - the Message ID to look for

Return Value :

	TRUE if it is found - FALSE and SetLastError() == ERROR_FILE_NOT_FOUND
		if not present in hash table

--*/

	ARTICLE_KEY	key(	const_cast<LPSTR>(MessageID), (WORD)lstrlen( MessageID ) ) ;

	return	CHashMap::Contains(	&key	) ;
}

void
CMsgArtMapImp::Shutdown(
		BOOL	fLocksHeld
		)	{
/*++

Routine Description :

	Terminate the hash table

Arguments :

	None

Return Value :

	None

--*/

	CHashMap::Shutdown( fLocksHeld ) ;

}

DWORD
CMsgArtMapImp::GetEntryCount()	{
/*++

Routine Description :

	Return the number of entries in the hash table

Arguments :

	None

Return Value :

	Number of Message ID's in the table

--*/

	return	CHashMap::GetEntryCount() ;

}

BOOL
CMsgArtMapImp::IsActive() {
/*++

Routine Description :

	Returns TRUE if hash table operational

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	return	CHashMap::IsActive() ;

}

CHistory::~CHistory()	{
}

BOOL
CHistoryImp::DeleteMapEntry(	
		LPSTR	MessageID
		)	{
/*++

Routine Description :

	Remove a Message ID from the hash table !

Arguments :

	MessageID - pointer to the message id to delete

Return Value :

	TRUE if successfully removed !

--*/

	HISTORY_KEY	key( MessageID, (WORD)lstrlen( MessageID ) ) ;

	return	CHashMap::DeleteMapEntry(	&key ) ;
}

BOOL
CHistoryImp::Initialize(			
		LPSTR	lpstrArticleFile,
		BOOL	fCreateExpirationThread,
		HASH_FAILURE_PFN	pfn,
		DWORD	ExpireTimeInSec,
		DWORD	MaxEntriesToCrawl,
		BOOL	fNoBuffering
		)	{
/*++

Routine Description :

	This function initializes the hash table

Arguments :

	lpstrArticleFile - the file in which the hash table is located
	cNumPageEntry - number of PageEntry objects we should use
	pfn - function call back for when things go south

Return Value :

	TRUE if successfull

--*/

	_ASSERT( ExpireTimeInSec != 0 ) ;
	_ASSERT( MaxEntriesToCrawl != 0 ) ;


	BOOL	fSuccess = CHashMap::Initialize(	lpstrArticleFile,
                                    HIST_HEAD_SIGNATURE,
                                    0,
									8,		// Fraction is set to 8 - we use only 1/8th of the pages
											//	available in the cache !
									g_pSharedCache,
									HASH_VFLAG_PAGE_BASIC_CHECKS,
									pfn,
									0,
									fNoBuffering
									) ;

	if( fSuccess )	{
		m_fExpire = fCreateExpirationThread ;

		m_expireTimeInSec = ExpireTimeInSec ;
		m_maxEntriesToCrawl = MaxEntriesToCrawl ;

	}

	return	fSuccess ;
}

DWORD
CHistoryImp::ExpireTimeInSec()	{


	return	m_expireTimeInSec ;
}

BOOL
CHistoryImp::InsertMapEntry(
		LPCSTR	MessageID,
		PFILETIME	BaseTime
		)	{
/*++

Routine Description :

	Insert a Message ID and all its associated data

Arguments :

	MessageID - the message id to insert into the table
	HeaderOffset - Offset to the RFC 822 header within its file
	HeaderLength - Length of RFC 822 header
	PrimaryGroup - The id of the group where the article will reside
	ArticleId - the id wihtin the primary group

Return Value :

	TRUE if successfull

--*/

	HISTORY_KEY	key(	(LPSTR)MessageID, (WORD)lstrlen( MessageID ) ) ;
	CHistoryData	data(	*((PULARGE_INTEGER)BaseTime) ) ;

	return	CHashMap::InsertMapEntry(
							&key,
							&data
							) ;
}

BOOL
CHistoryImp::SearchMapEntry(
		LPCSTR	MessageID
		)	{
/*++

Routine Description :

	Determine if the MessageID exists in the table

Arguments :

	MessageID - the Message ID to look for

Return Value :

	TRUE if it is found - FALSE and SetLastError() == ERROR_FILE_NOT_FOUND
		if not present in hash table

--*/

	HISTORY_KEY	key(	const_cast<LPSTR>(MessageID), (WORD)lstrlen( MessageID ) ) ;

	return	CHashMap::Contains(	&key	) ;
}

void
CHistoryImp::Shutdown(
		BOOL	fLocksHeld
		)	{
/*++

Routine Description :

	Terminate the hash table

Arguments :

	None

Return Value :

	None

--*/

	EnterCriticalSection( &g_listcrit ) ;

	if( m_pNext != 0 ) 
		m_pNext->m_pPrev = m_pPrev ;
	if( m_pPrev != 0 ) 
		m_pPrev->m_pNext = m_pNext ;
	m_pPrev = 0 ;
	m_pNext = 0 ;
		
	LeaveCriticalSection( &g_listcrit ) ;

	CHashMap::Shutdown( fLocksHeld ) ;

}

DWORD
CHistoryImp::GetEntryCount()	{
/*++

Routine Description :

	Return the number of entries in the hash table

Arguments :

	None

Return Value :

	Number of Message ID's in the table

--*/

	return	CHashMap::GetEntryCount() ;

}

BOOL
CHistoryImp::IsActive() {
/*++

Routine Description :

	Returns TRUE if hash table operational

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	return	CHashMap::IsActive() ;

}


HANDLE	CHistoryImp::g_hCrawler = 0 ;
DWORD	CHistoryImp::g_crawlerSleepTimeInSec = 30 ;
HANDLE	CHistoryImp::g_hTermination = 0 ;
CRITICAL_SECTION	CHistoryImp::g_listcrit ;
CHistoryList		CHistoryImp::g_listhead ;

BOOL
CHistoryImp::Init( ) {
/*++

Routine Description :

	Initialize globals

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	_ASSERT( g_hCrawler == 0 ) ;
	_ASSERT( g_hTermination == 0 ) ;
	_ASSERT( g_listhead.m_pNext = &g_listhead ) ;

	InitializeCriticalSection( &g_listcrit ) ;

	return	TRUE ;
}

BOOL
CHistoryImp::Term( ) {
/*++

Routine Description :

	Terminate globals

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	_ASSERT( g_hCrawler == 0 ) ;
	_ASSERT( g_hTermination == 0 ) ;
	_ASSERT( g_listhead.m_pNext = &g_listhead ) ;

	DeleteCriticalSection( &g_listcrit ) ;

	return	TRUE ;
}

CHistoryImp::CHistoryImp()	:
	m_expireTimeInSec( 0 ),
	m_maxEntriesToCrawl( 0 ),
	m_fExpire( FALSE ),
	m_fContextInitialized( FALSE ) {
/*++

Routine Description :

	Initialize a CHistoryImp object - we put ourselves into a
	doubly linked list of history hash tables so that a background
	thread can do expiration !

Arguments :

	None

Return Value :

	None

--*/

	EnterCriticalSection( &g_listcrit ) ;

	m_pNext = g_listhead.m_pNext ;
	m_pPrev = &g_listhead ;
	g_listhead.m_pNext = this ;
	m_pNext->m_pPrev = this ;
	
	LeaveCriticalSection( &g_listcrit ) ;

}	

CHistoryImp::~CHistoryImp()	{
/*++

Routine Description :

	Destroy a CHistoryImp object - remove it from the list
	of objects needing expiration processing !

Arguments :

	None

Return Value :

	None

--*/

	EnterCriticalSection( &g_listcrit ) ;

	if( m_pNext != 0 ) 
		m_pNext->m_pPrev = m_pPrev ;
	if( m_pPrev != 0 ) 
		m_pPrev->m_pNext = m_pNext ;
	m_pPrev = 0 ;
	m_pNext = 0 ;

	LeaveCriticalSection( &g_listcrit ) ;
}

BOOL
CHistory::StartExpirationThreads(	DWORD	CrawlerSleepTime ) {

	return	CHistoryImp::StartExpirationThreads( CrawlerSleepTime ) ;

}

BOOL
CHistory::TermExpirationThreads()	{

	return	CHistoryImp::TermExpirationThreads() ;

}

BOOL
CHistoryImp::StartExpirationThreads(	DWORD	CrawlerSleepTime	 ) {
/*++

Routine Description :

	Initialize globals

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

	_ASSERT( g_hCrawler == 0 ) ;
	_ASSERT( g_hTermination == 0 ) ;

    //
    // Create termination event
    //
    g_hTermination = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( g_hTermination == NULL )    {
		return	FALSE ;
    }

    //
    // Create crawler thread
    //
	DWORD	threadId ;

	g_hCrawler = CreateThread(
						NULL,               // attributes
						0,                  // stack size
						CHistoryImp::CrawlerThread,      // thread start
						0,        // param
						0,                  // creation params
						&threadId
						);

	if ( g_hCrawler == NULL )	{
		return	FALSE ;
	}

	return	TRUE ;
}

BOOL
CHistoryImp::TermExpirationThreads( ) {
/*++

Routine Description :

	Terminate globals

Arguments :

	None

Return Value :

	TRUE if everything is hunky-dory

--*/

#if 0
    //  this is all bogus!  It's doing something exactly
    //  like CHistoryImp::Term()!!!
    //  must be having too much beer :):)
	_ASSERT( g_hCrawler == 0 ) ;
	_ASSERT( g_hTermination == 0 ) ;
	_ASSERT( g_listhead.m_pNext = &g_listhead ) ;

	DeleteCriticalSection( &g_listcrit ) ;
#endif

    //
    //  We need to signal the History expiration thread
    //  for termination, if it's created in the first place
    //
    if (g_hCrawler != 0) {
        
        //
        //  This event should be initialized by StartExpirationThreads()
        //  Assert if not, go figure in dbg bld.
        //
        _ASSERT( g_hTermination != 0 );

        if (g_hTermination) {
            
            //
            //  signal the Crawler thread to die.
            //
            SetEvent( g_hTermination );

            //
            // Wait for the crawler to die
            //
            (VOID)WaitForSingleObject( g_hCrawler, INFINITE );

            _VERIFY(CloseHandle(g_hCrawler));
            g_hCrawler = 0;
        }
    }

    //
    //  destroy the event
    //
    if (g_hTermination != 0) {
        
        _VERIFY(CloseHandle(g_hTermination));
        g_hTermination = 0;
    }

	return	TRUE ;
}



DWORD
WINAPI
CHistoryImp::CrawlerThread(
        LPVOID Context
        )
/*++

Routine Description:

    This is the thread which walks history tables expiring articles !

Arguments:

    Context - unused.

Return Value:

    Bogus

--*/
{

    DWORD status;
    DWORD timeout = g_crawlerSleepTimeInSec * 1000;

    //
    // Loop until the termination event is signalled
    //

    while (TRUE) {

        status = WaitForSingleObject(
                            g_hTermination,
                            timeout
                            );

        if (status == WAIT_TIMEOUT) {

            //
            // expire articles
            //

			EnterCriticalSection( &g_listcrit ) ;

			for( CHistoryList*	p = g_listhead.m_pNext;
					p != &g_listhead;
					p = p->m_pNext ) {
				
				p->Expire() ;

			}

			LeaveCriticalSection( &g_listcrit ) ;

		} else if (status == WAIT_OBJECT_0) {

			break;
		} else {
			_ASSERT(FALSE);
			break;
		}
    }
    return 1;

} // CrawlerThread

    //
    // Additional work that needs to be done by the derived class
    // for an entry during a delete
    //
VOID
CHistoryImp::I_DoAuxDeleteEntry(
            IN PMAP_PAGE MapPage,
            IN DWORD EntryOffset
            ) {


	//
	//	When we delete an entry we need to figure out what
	//	the new low is !
	//

	PENTRYHEADER entry = (PENTRYHEADER)GET_ENTRY(MapPage, EntryOffset) ;

	HISTORY_MAP_ENTRY	*pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;
	ULARGE_INTEGER*	oldestTime = (PULARGE_INTEGER)(&MapPage->Reserved1) ;
	if( pHistory->BaseTime.QuadPart <= oldestTime->QuadPart ||
		oldestTime->HighPart == 0xFFFFFFFF ) {

_ASSERT( oldestTime->QuadPart == pHistory->BaseTime.QuadPart || oldestTime->HighPart == 0xFFFFFFFF ) ;

		oldestTime->HighPart = 0xFFFFFFFF ;

		for( int i=0, entriesScanned=0;
			i < MAX_LEAF_ENTRIES && entriesScanned < MapPage->ActualCount;
			i++ ) {


			SHORT	curEntryOffset = MapPage->Offset[i] ;
			if( curEntryOffset > 0 ) {

				entriesScanned ++ ;

				if( DWORD(curEntryOffset) != EntryOffset ) {

					entry = (PENTRYHEADER)GET_ENTRY(MapPage, curEntryOffset) ;
					pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

					if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

						oldestTime->QuadPart = pHistory->BaseTime.QuadPart ;

					}
				}
			}
		}
	}
#ifdef	_DEBUG
	//
	//	Check that the minimum exists in the page !
	//
	BOOL	fFound = FALSE ;
	int	entriesScanned = 0 ;
	for( int i=0; 
			i < MAX_LEAF_ENTRIES ;
			i++ ) {
		SHORT	curEntryOffset = MapPage->Offset[i] ;
		if( curEntryOffset > 0 ) {

			entriesScanned ++ ;

			if( DWORD(curEntryOffset) != EntryOffset ) {

				entry = (PENTRYHEADER)GET_ENTRY(MapPage, curEntryOffset) ;
				pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

				if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

					_ASSERT( oldestTime->HighPart == 0xFFFFFFFF ) ;

				}	else if( pHistory->BaseTime.QuadPart == oldestTime->QuadPart ) {
					fFound = TRUE ;
				}
			}
		}
	}
	_ASSERT( entriesScanned == MapPage->ActualCount || entriesScanned == MapPage->EntryCount ) ;
	_ASSERT( fFound || oldestTime->HighPart == 0xFFFFFFFF || MapPage->ActualCount == 0  ) ;
#endif
}

VOID
CHistoryImp::I_DoAuxInsertEntry(
            IN PMAP_PAGE MapPage,
            IN DWORD EntryOffset
            ) {

	//
	//	When we delete an entry we need to figure out what
	//	the new low is !
	//

	PENTRYHEADER entry = (PENTRYHEADER)GET_ENTRY(MapPage, EntryOffset) ;

	HISTORY_MAP_ENTRY	*pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

	ULARGE_INTEGER*	oldestTime = (PULARGE_INTEGER)(&MapPage->Reserved1) ;
	if( MapPage->ActualCount == 1 ||
		pHistory->BaseTime.QuadPart <= oldestTime->QuadPart ) {

		BOOL	fAccurate = oldestTime->HighPart != 0xFFFFFFFF ;
		oldestTime->QuadPart = pHistory->BaseTime.QuadPart ;

		if( !fAccurate ) {
			for( int i=0, entriesScanned=0; 
				i < MAX_LEAF_ENTRIES && entriesScanned < MapPage->ActualCount;
				i++ ) {
				SHORT	curEntryOffset = MapPage->Offset[i] ;
				if( curEntryOffset > 0 ) {
					entriesScanned ++ ;

					entry = (PENTRYHEADER)GET_ENTRY(MapPage, curEntryOffset) ;
					pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;
					if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

						oldestTime->QuadPart = pHistory->BaseTime.QuadPart ;

					}
				}
			}
		}
	}

#ifdef	_DEBUG
	//
	//	Check that the minimum exists in the page !
	//
	BOOL	fFound = FALSE ;
	int	entriesScanned = 0 ;
	for( int i=0; 
			i < MAX_LEAF_ENTRIES ;
			i++ ) {
		SHORT	curEntryOffset = MapPage->Offset[i] ;
		if( curEntryOffset > 0 ) {

			entriesScanned ++ ;

			if( DWORD(curEntryOffset) != EntryOffset ) {

				entry = (PENTRYHEADER)GET_ENTRY(MapPage, curEntryOffset) ;
				pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

				if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

					_ASSERT( FALSE ) ;

				}	else if( pHistory->BaseTime.QuadPart == oldestTime->QuadPart ) {
					fFound = TRUE ;
				}
			}
		}
	}
	_ASSERT( entriesScanned == MapPage->ActualCount || entriesScanned == MapPage->EntryCount ) ;
	_ASSERT( fFound || (MapPage->ActualCount == 1 || MapPage->ActualCount == 0)) ;
#endif


}



//
// Additional work that needs to be done by the derived class
// for an entry during a page split
//
VOID
CHistoryImp::I_DoAuxPageSplit(
            IN PMAP_PAGE OldPage,
            IN PMAP_PAGE NewPage,
            IN PVOID NewEntry
            ) {


	//
	//	In the history table the reserved words keep the smallest
	//	time stamp of any the entries - whatever we put in the new
	//	page during a split the smallest entry will still be
	//	the same !
	//
//	CopyMemory( &NewPage->Reserved1, &OldPage->Reserved1, 
//			sizeof( NewPage->Reserved1 ) * 4 ) ;


	PENTRYHEADER entry = (PENTRYHEADER)NewEntry ;
	HISTORY_MAP_ENTRY	*pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

	ULARGE_INTEGER*	oldestTime = (PULARGE_INTEGER)(&NewPage->Reserved1) ;
	if( NewPage->EntryCount == 1 ||
		pHistory->BaseTime.QuadPart <= oldestTime->QuadPart ) {

		oldestTime->QuadPart = pHistory->BaseTime.QuadPart ;
			
	}

#ifdef	_DEBUG
	//
	//	Check that the minimum exists in the page !
	//
	DWORD	EntryOffset = (LPBYTE)NewEntry - (LPBYTE)GET_ENTRY(NewPage,0);
	BOOL	fFound = FALSE ;
	int	entriesScanned = 0 ;
	for( int i=0; 
			i < MAX_LEAF_ENTRIES ;
			i++ ) {
		SHORT	curEntryOffset = NewPage->Offset[i] ;
		if( curEntryOffset > 0 ) {

			entriesScanned ++ ;

			if( DWORD(curEntryOffset) != EntryOffset ) {

				entry = (PENTRYHEADER)GET_ENTRY(NewPage, curEntryOffset) ;
				pHistory = (PHISTORY_MAP_ENTRY)&entry->Data[0] ;

				if( pHistory->BaseTime.QuadPart < oldestTime->QuadPart )	{

					_ASSERT( FALSE ) ;

				}	else if( pHistory->BaseTime.QuadPart == oldestTime->QuadPart ) {
					fFound = TRUE ;
				}
			}
		}
	}
	_ASSERT( entriesScanned == NewPage->ActualCount || entriesScanned == NewPage->EntryCount ) ;
	_ASSERT( fFound || (NewPage->ActualCount == 1 || NewPage->ActualCount == 0)) ;
#endif


}




class	CExpireEnum	:	public	IEnumInterface	{
public :

	DWORD			m_cEntries ;
	ULARGE_INTEGER	m_expireTime ;
	ULARGE_INTEGER	m_oldestTime ;

	CExpireEnum(	ULARGE_INTEGER	expireTime )	:
		m_cEntries( 0 ),
		m_expireTime( expireTime ) {
	}

	BOOL
	ExaminePage(	PMAP_PAGE	page )	{
		ULARGE_INTEGER	*oldestTime = (PULARGE_INTEGER)(&page->Reserved1) ;

		if( (oldestTime->HighPart != 0xFFFFFFFF) &&
			(oldestTime->QuadPart != 0 &&
			oldestTime->QuadPart > m_expireTime.QuadPart) ) {

			m_cEntries += page->ActualCount ;
			
			return	FALSE ;
		}
		return	TRUE ;
	}	

	BOOL
	ExamineEntry(	PMAP_PAGE	page,	LPBYTE	pbPtr )	{

		HISTORY_MAP_ENTRY*	pHistory = (PHISTORY_MAP_ENTRY)pbPtr ;

		if( pHistory->BaseTime.QuadPart < m_oldestTime.QuadPart ) {
			m_oldestTime = pHistory->BaseTime ;
		}

		m_cEntries ++ ;
		if( pHistory->BaseTime.QuadPart > m_expireTime.QuadPart )	{
			return	FALSE ;
		}
		return	TRUE ;
	}
} ;


#define LI_FROM_FILETIME( _pLi, _pFt ) {               \
            (_pLi)->LowPart = (_pFt)->dwLowDateTime;   \
            (_pLi)->HighPart = (_pFt)->dwHighDateTime; \
            }



void
CHistoryImp::Expire()	{
/*++

Routine Description:

    Do the grunt work of expiring stuff out of the history table

Arguments:

    None

Return Value:

    None

--*/



    DWORD status;
    DWORD currentPage = 1;
    ULARGE_INTEGER expireTime;
    ULARGE_INTEGER expireInterval;
    FILETIME fTime;
    DWORD entriesToCrawl;
	DWORD	entries = GetEntryCount() ;

	if( m_fExpire ) {

		if ( entries == 0 ) {
			return ;
		}

		//
		// How many pages to crawl?
		//

		entriesToCrawl = entries >> FRACTION_TO_CRAWL_SHFT;
		if ( entriesToCrawl > (100*m_maxEntriesToCrawl) ) {
			entriesToCrawl = (100*m_maxEntriesToCrawl) ;
		}	else if( entriesToCrawl == 0 ) {
			entriesToCrawl = 100 ;
		}


		expireInterval.QuadPart = m_expireTimeInSec;
		expireInterval.QuadPart *= (ULONGLONG)10 * 1000 * 1000;

		//
		// Compute expiration time
		//

		GetSystemTimeAsFileTime( &fTime );

		LI_FROM_FILETIME( &expireTime, &fTime );
		expireTime.QuadPart -= expireInterval.QuadPart;

		CExpireEnum	enumerator( expireTime) ;

		while( enumerator.m_cEntries <entriesToCrawl	) {

			
			char	szBuff[512] ;
			HISTORY_KEY	key(	szBuff, sizeof( szBuff )  ) ;
			ULARGE_INTEGER	ul ;
			ul.QuadPart = 0 ;
			CHistoryData	data( ul ) ;
			DWORD	cbKey ;
			DWORD	cbData ;
			WORD	words[4] ;
			PULARGE_INTEGER	oldestTime = (PULARGE_INTEGER)&words ; ;

			BOOL	fGetEntry = FALSE ;


			if( !m_fContextInitialized ) {
		
				fGetEntry = CHashMap::GetFirstMapEntry(
											&key,
											cbKey,
											&data,
											cbData,
											&m_ExpireContext,
											&enumerator
											) ;
				m_fContextInitialized = TRUE ;

			}	else	{

				fGetEntry = CHashMap::GetNextMapEntry(
											&key,
											cbKey,
											&data,
											cbData,
											&m_ExpireContext,
											&enumerator
											) ;

			}

			if( !fGetEntry )	{
				
				if( GetLastError() == ERROR_NO_MORE_ITEMS  ) {
					m_fContextInitialized = FALSE ;
				}
				
				break ;

			}	else	{

				//
				//	The enumerator we used already gauranteed that the
				//	entry we are eaxmining is ready to be expired !
				//

				CHashMap::DeleteMapEntry(	&key, TRUE ) ;

			}
		}
	}
}

#if 0

BOOL
CHistory::I_ExpireEntriesInPage(
                    IN DWORD CurrentPage,
                    IN PULARGE_INTEGER ExpireTime
                    )
/*++

Routine Description:

    This routine expires articles in a given page

Arguments:

	HLock - Handle to lock used to hold the page we are examining.
		Need to provide this to FlushPage()
    CurrentPage - Page to expire entries
    ExpireTime - Time to expire

Return Value:

    TRUE - Page processed for expiration.
    FALSE - Cannot get page pointer, means that hash table is inactive.

--*/
{
    PMAP_PAGE mapPage;
    HPAGELOCK hLock;
    DWORD oldCount;
    PULARGE_INTEGER oldestTime;
    DWORD i, entriesScanned;

    ENTER("ExpireEntriesInPage")

    //
    // Get the map pointer
    //

    mapPage = (PMAP_PAGE)GetAndLockPageByNumberNoDirLock(CurrentPage,hLock);
    if ( mapPage == NULL ) {
        LEAVE
        return FALSE;
    }

    //
    // See if there are pages to delete here.  If 0, then
    // we have no entries.
    //

    oldestTime = (PULARGE_INTEGER)&mapPage->Reserved1;

    if ( (oldCount = mapPage->ActualCount) > 0 ) {

        _ASSERT(oldestTime->QuadPart != 0);

        if ( ExpireTime->QuadPart < oldestTime->QuadPart ) {
            DO_DEBUG(HISTORY) {
                DebugTrace(0,"Page %d. Oldest is not old enough\n",CurrentPage);
            }
            goto exit;
        }

    } else {

        DO_DEBUG(HISTORY) {
            DebugTrace(0,"Page %d. No entries for this page\n",CurrentPage);
        }
        goto exit;
    }

    //
    // Look at all entries and see if we can expire any
    //

    oldestTime->LowPart = 0xffffffff;
    oldestTime->HighPart = 0xffffffff;

    for ( i = 0, entriesScanned = 0;
          entriesScanned < oldCount ;
          i++ ) {

        SHORT entryOffset;

        //
        // Get the offset
        //

        entryOffset = mapPage->ArtOffset[i];

        if ( entryOffset > 0 ) {

            PHISTORY_MAP_ENTRY entry;
            entry = (PHISTORY_MAP_ENTRY)GET_ENTRY(mapPage,entryOffset);

            //
     